<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-02T15:18:32+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">HTTP 连接管理</title><link href="https://feng-zhang0712.github.io//blog/2024/04-connection-management/" rel="alternate" type="text/html" title="HTTP 连接管理"/><published>2024-10-02T00:00:00+00:00</published><updated>2024-10-02T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/04-connection-management</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/04-connection-management/"><![CDATA[<blockquote> <p>本文节选自《HTTP 权威指南 - 第4章 连接管理》。</p> </blockquote> <p>通过本章，可以了解到：</p> <ul> <li>HTTP 是如何使用 TCP 连接的；</li> <li>TCP 连接的时延、瓶颈以及存在的障碍；</li> <li>HTTP 的优化，包括并行连接、keep-alive（持久连接）和管道化连接；</li> <li>管理连接时应该以及不应该做的事情。</li> </ul> <h2 id="一tcp-连接">一、TCP 连接</h2> <p>客户端应用程序可以打开一条 TCP/IP 连接，连接到可能运行在世界任何地方的服务器应用程序。如图 4-1 展示了当访问 <code class="language-plaintext highlighter-rouge">http：//www.joes-hardware.com：80/power-tools.html</code> 时，浏览器所执行的步骤。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-Web-browser-interacts-with-the-Web-server-over-a-TCP-connection-480.webp 480w,/assets/images/http-the-definitive-guide/the-Web-browser-interacts-with-the-Web-server-over-a-TCP-connection-800.webp 800w,/assets/images/http-the-definitive-guide/the-Web-browser-interacts-with-the-Web-server-over-a-TCP-connection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-Web-browser-interacts-with-the-Web-server-over-a-TCP-connection.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Web 浏览器通过 TCP 连接与 Web 服务器进行交互" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-1 Web 浏览器通过 TCP 连接与 Web 服务器进行交互 </div> <h3 id="11-tcp-的可靠数据管道">1.1 TCP 的可靠数据管道</h3> <p>HTTP 连接实际上就是 TCP 连接及其使用规则。TCP 连接是因特网上的可靠连接。TCP 为 HTTP 提供了一条可靠的比特传输管道。从 TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来（参见图 4-2）。</p> <div class="row justify-content-center"> <div class="col-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-carries-HTTP-data-sequentially-and-error-free-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-carries-HTTP-data-sequentially-and-error-free-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-carries-HTTP-data-sequentially-and-error-free-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-carries-HTTP-data-sequentially-and-error-free.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 会按序、无差错地承载 HTTP 数据" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-2 TCP 会按序、无差错地承载 HTTP 数据 </div> <h3 id="12-tcp-流是分段的由-ip-分组传送">1.2 TCP 流是分段的、由 IP 分组传送</h3> <p>TCP 的数据通过名为 <strong>IP 分组</strong>（或 <strong>IP 数据报</strong>）的小数据块来发送。如图 4-3a 所示，HTTP 就是 “HTTP over TCP over IP” 这个“协议栈”中的最顶层。其安全版本 HTTPS 就是在 HTTP 和 TCP 之间插入了一个（称为 TLS 或 SSL 的）密码加密层（图 4-3b）。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/HTTP-and-HTTPS-network-protocol-stacks-480.webp 480w,/assets/images/http-the-definitive-guide/HTTP-and-HTTPS-network-protocol-stacks-800.webp 800w,/assets/images/http-the-definitive-guide/HTTP-and-HTTPS-network-protocol-stacks-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/HTTP-and-HTTPS-network-protocol-stacks.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP 和 HTTPS 网络协议栈" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-3 HTTP 和 HTTPS 网络协议栈 </div> <p>HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输（参见图 4-4）。所有这些工作都由 TCP/IP 软件来处理，程序员什么都看不到。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-IP-packet-that-carries-the-TCP-segment-480.webp 480w,/assets/images/http-the-definitive-guide/the-IP-packet-that-carries-the-TCP-segment-800.webp 800w,/assets/images/http-the-definitive-guide/the-IP-packet-that-carries-the-TCP-segment-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-IP-packet-that-carries-the-TCP-segment.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="承载 TCP 段的 IP 分组，它承载了 TCP 数据流中的小块数据" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-4 承载 TCP 段的 IP 分组，它承载了 TCP 数据流中的小块数据 </div> <p>每个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址。每个 IP 分组中都包括：</p> <ul> <li>一个 IP 分组首部（通常为20 字节），包含了源和目的 IP 地址、长度和其他一些标记。</li> <li>一个 TCP 段首部（通常为 20 字节），包含了 TCP 端口号、TCP 控制标记，以及用于数据排序和完整性检查的一些数字值</li> <li>一个 TCP 数据块（0 个或多个字节）。</li> </ul> <h3 id="13-保持-tcp-连接持续不断地运行">1.3 保持 TCP 连接持续不断地运行</h3> <p>在任意时刻计算机都可以有几条 TCP 连接处于打开状态。TCP 通过端口号来保持所有这些连接持续不断地运行。</p> <p>IP 地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去。TCP 连接通过 4 个值来识别：</p> \[&lt;源 IP 地址、源端口号、目的 IP 地址、目的端口号&gt;\] <p>这 4 个值一起唯一地定义了一条连接。两条不同的 TCP 连接不能拥有 4 个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。在图 4-5 中，有 4 条连接：<code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">C</code> 和 <code class="language-plaintext highlighter-rouge">D</code>。表 4-1 列出了每个端口的相关信息。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-connection-value-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-connection-value-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-connection-value-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-connection-value.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 连接值" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 4-1 TCP 连接值 </div> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-different-TCP-connections-480.webp 480w,/assets/images/http-the-definitive-guide/4-different-TCP-connections-800.webp 800w,/assets/images/http-the-definitive-guide/4-different-TCP-connections-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-different-TCP-connections.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个不同的 TCP 连接" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-5 4 个不同的 TCP 连接 </div> <p>注意，有些连接共享了相同的目的端口号（<code class="language-plaintext highlighter-rouge">C</code> 和 <code class="language-plaintext highlighter-rouge">D</code> 都使用目的端口号 <code class="language-plaintext highlighter-rouge">80</code>）。有些连接使用了相同的源 IP 地址（<code class="language-plaintext highlighter-rouge">B</code> 和 <code class="language-plaintext highlighter-rouge">C</code>）。有些使用了相同的目的 IP 地址（<code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code>，<code class="language-plaintext highlighter-rouge">C</code> 和 <code class="language-plaintext highlighter-rouge">D</code>）。但没有两个不同连接所有的 4 个值都一样。</p> <h3 id="14-用-tcp-套接字编程">1.4 用 TCP 套接字编程</h3> <p>操作系统提供了一些操纵其 TCP 连接的工具。表 4-2 显示了<a href="https://en.wikipedia.org/wiki/Network_socket">套接字</a> API 提供的一些主要接口。这个套接字 API 向 HTTP 程序员隐藏了 TCP 和 IP 的所有细节。套接字 API 最初是为 Unix 操作系统开发的，但现在几乎所有的操作系统和语言中都有其变体存在。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/common-socket-interface-functions-needed-to-program-TCP-connections-480.webp 480w,/assets/images/http-the-definitive-guide/common-socket-interface-functions-needed-to-program-TCP-connections-800.webp 800w,/assets/images/http-the-definitive-guide/common-socket-interface-functions-needed-to-program-TCP-connections-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/common-socket-interface-functions-needed-to-program-TCP-connections.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="对 TCP 连接进行编程所需的常见套接字接口函数" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 4-2 对 TCP 连接进行编程所需的常见套接字接口函数 </div> <p>套接字 API 允许用户创建 TCP 的端点数据结构，将这些端点与远程服务器的 TCP 端点进行连接，并对数据流进行读写。TCP API 隐藏了所有底层网络协议的握手细节，以及 TCP 数据流与 IP 分组之间的分段和重装细节。</p> <p>图 4-1 显示了 Web 浏览器是如何用 HTTP 从 Joe 的五金商店下载 <code class="language-plaintext highlighter-rouge">power-tools.html</code> 页面的。图 4-6 中的伪代码说明了可以怎样通过套接字 API 来凸显客户端和服务器在实现 HTTP 事务时所应执行的步骤。</p> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-clients-and-servers-communicate-through-TCP-socket-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-clients-and-servers-communicate-through-TCP-socket-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-clients-and-servers-communicate-through-TCP-socket-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-clients-and-servers-communicate-through-TCP-socket.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 客户端和服务器是如何通过 TCP 套接字接口进行通信的" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-6 TCP 客户端和服务器是如何通过 TCP 套接字接口进行通信的 </div> <p>我们从 Web 服务器等待连接（参见图 4-6，<code class="language-plaintext highlighter-rouge">S4</code>）开始。客户端根据 URL 判定出 IP 地址和端口号，并建立一条到服务器的 TCP 连接（参见图 4-6，<code class="language-plaintext highlighter-rouge">C3</code>）。建立连接可能要花费一些时间，时间长短取决于服务器距离的远近、服务器的负载情况，以及因特网的拥挤程度。</p> <p>一旦建立了连接，客户端就会发送 HTTP 请求（参见图4-6，<code class="language-plaintext highlighter-rouge">C5</code>），服务器则会读取请求（参见图 4-6，<code class="language-plaintext highlighter-rouge">S6</code>）。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作（参见图4-6，<code class="language-plaintext highlighter-rouge">S7</code>），并将数据写回客户端。客户端读取数据（参见图 4-6，<code class="language-plaintext highlighter-rouge">C6</code>），并对响应数据进行处理（参见图4-6，<code class="language-plaintext highlighter-rouge">C7</code>）。</p> <h2 id="二对-tcp-性能的考虑">二、对 TCP 性能的考虑</h2> <p>HTTP 紧挨着 TCP，位于其上层，所以 HTTP 事务的性能在很大程度上取决于底层 TCP 通道的性能。本节重点介绍了一些很重要的、对这些 TCP 连接的性能考虑。</p> <h3 id="21-http-事务的时延">2.1 HTTP 事务的时延</h3> <p>图 4-7 描绘了 HTTP 事务主要的连接、传输以及处理时延。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/a-timeline-of-serial-HTTP-transactions-480.webp 480w,/assets/images/http-the-definitive-guide/a-timeline-of-serial-HTTP-transactions-800.webp 800w,/assets/images/http-the-definitive-guide/a-timeline-of-serial-HTTP-transactions-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/a-timeline-of-serial-HTTP-transactions.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="串行 HTTP 事务的时间线" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-7 串行 HTTP 事务的时间线 </div> <p>注意，与建立 TCP 连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。除非客户端或服务器超载，或正在处理复杂的动态资源，否则 HTTP 时延就是由 TCP 网络时延构成的。</p> <p>HTTP 事务的时延有以下几种主要原因。</p> <ol> <li>客户端首先需要根据 URI 确定 Web 服务器的 IP 地址和端口号。如果最近没有对 URI 中的主机名进行访问，通过 DNS 解析系统将 URI 中的主机名转换成一个 IP 地址可能要花费数十秒的时间。</li> <li>接下来，客户端会向服务器发送一条 TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的 TCP 连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个 HTTP 事务的话，这个值会快速地叠加上去。</li> <li>一旦连接建立起来了，客户端就会通过新建立的 TCP 管道来发送 HTTP 请求。数据到达时，Web 服务器会从 TCP 连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。</li> <li>然后，Web 服务器会回送 HTTP 响应，这也需要花费时间。这些 TCP 网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。</li> </ol> <h3 id="22-性能聚焦区域">2.2 性能聚焦区域</h3> <p>本节其余部分列出了一些会对 HTTP 程序员产生影响的、最常见的 TCP 相关时延，其中包括：</p> <ul> <li>TCP 连接建立握手；</li> <li>TCP 慢启动拥塞控制；</li> <li>数据聚集的 Nagle 算法；</li> <li>用于捎带确认的 TCP 延迟确认算法；</li> <li>TIME_WAIT 时延和端口耗尽。</li> </ul> <p>要编写高性能的 HTTP 软件，就应该理解上面的每个因素。</p> <h3 id="23-tcp-连接的握手时延">2.3 TCP 连接的握手时延</h3> <p>建立一条新的 TCP 连接时，甚至是在发送任意数据之前，TCP 软件之间会交换一系列的 IP 分组，对连接的有关参数进行沟通（参见图 4-8）。如果连接只用来传送少量数据，这些交换过程就会严重降低 HTTP 的性能。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-sends-two-packets-to-establish-a-connection-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-sends-two-packets-to-establish-a-connection-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-sends-two-packets-to-establish-a-connection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-sends-two-packets-to-establish-a-connection.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="在发送数据之前，TCP 要传送两个分组来建立连接" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-8 在发送数据之前，TCP 要传送两个分组来建立连接 </div> <p>TCP 连接握手需要经过以下几个步骤。</p> <ol> <li>请求新的 TCP 连接时，客户端要向服务器发送一个小的 TCP 分组（通常是 40 ~ 60 个字节）。这个分组中设置了一个特殊的 <code class="language-plaintext highlighter-rouge">SYN</code> 标记，说明这是一个连接请求。（参见图 4-8a）。</li> <li>如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个 TCP 分组，这个分组中的 <code class="language-plaintext highlighter-rouge">SYN</code> 和 <code class="language-plaintext highlighter-rouge">ACK</code> 标记都被置位，说明连接请求已被接受（参见图 4-8b）。</li> <li>最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（参见图 4-8c）。现代的 TCP 栈都允许客户端在这个确认分组中发送数据。</li> </ol> <p>HTTP 程序员永远不会看到这些分组——这些分组都由 TCP/IP 软件管理，对其是不可见的。HTTP 程序员看到的只是创建 TCP 连接时存在的时延。</p> <p>通常 HTTP 事务都不会交换太多数据，此时，<code class="language-plaintext highlighter-rouge">SYN</code>/<code class="language-plaintext highlighter-rouge">SYN+ACK</code> 握手（参见图 4-8a 和图 4-8b）会产生一个可测量的时延。TCP 连接的 <code class="language-plaintext highlighter-rouge">ACK</code> 分组（参见图4-8c）通常都足够大，可以承载整个 HTTP 请求报文，而且很多 HTTP 服务器响应报文都可以放入一个 IP 分组中去（比如，响应是包含了装饰性图片的小型 HTML 文件，或者是对浏览器高速缓存请求产生的 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应）。</p> <p>最后的结果是，小的 HTTP 事务可能会在 TCP 建立上花费 50%，或更多的时间。</p> <h3 id="24-延迟确认">2.4 延迟确认</h3> <p>由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以 TCP 实现了自己的确认机制来确保数据的成功传输。</p> <p>每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。</p> <p>由于确认报文很小，所以 TCP 允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP 将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多 TCP 栈都实现了一种“延迟确认”算法。延迟确认算法会在一个特定的窗口时间（通常是 100 ~ 200 毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p> <p>但是，HTTP 具有双峰特征的请求-应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p> <p>在对 TCP 栈的任何参数进行修改之前，一定要对自己在做什么有清醒的认识。TCP 中引入这些算法的目的是防止设计欠佳的应用程序对因特网造成破坏。对 TCP 配置进行的任意修改，都要绝对确保应用程序不会引发这些算法所要避免的问题。</p> <h3 id="25-tcp-慢启动">2.5 TCP 慢启动</h3> <p>TCP 数据传输的性能还取决于 TCP 连接的使用期（age）。TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为 TCP <strong>慢启动</strong>（slow start），用于防止因特网的突然过载和拥塞。</p> <p>TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个 HTTP 事务有大量数据要发送，是不能一次将所有分组都发送出去的。必须发送一个分组，等待确认；然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了，以此类推。这种方式被称为“打开拥塞窗口”。</p> <p>由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。由于已调谐连接要更快一些，所以 HTTP 中有一些可以重用现存连接的工具。</p> <h3 id="26-nagle-算法与-tcp_nodelay">2.6 Nagle 算法与 TCP_NODELAY</h3> <p>TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 TCP 栈中-即使一次只放一个字节也可以!但是，每个 TCP 段中都至少装载了 40 个字节的标记和首部，所以如果 TCP 发送了大量包含少量数据的分组，网络的性能就会严重下降。”</p> <p>Nagle 算法（根据其发明者 John Nagle 命名）试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。RFC 896 “IP/TCP 互连网络中的拥塞控制”对此算法进行了描述。</p> <p>Nagle 算法鼓励发送全尺寸（LAN 上最大尺寸的分组大约是 1500 字节，在因特网上是几百字节）的段。只有当所有其他分组都被确认之后，Nagle 算法才允许发送非全尺寸的分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。</p> <p>Nagle 算法会引发几种 HTTP 性能问题。首先，小的 HTTP 报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle 算法与延迟确认之间的交互存在问题 —— Nagle 算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟 100 ~ 200 毫秒。</p> <p>HTTP 应用程序常常会在自己的栈中设置参数 TCP_NODELAY，禁用 Nagle 算法，提高性能。如果要这么做的话，一定要确保会向 TCP 写入大块的数据，这样就不会产生一堆小分组了。</p> <h3 id="27-time_wait-累积与端口耗尽">2.7 TIME_WAIT 累积与端口耗尽</h3> <p>TIME_WAIT 端口耗尽是很严重的性能问题，会影响到性能基准，但在现实中相对较少出现。大多数遇到性能基准问题的人最终都会碰到这个问题，而且性能都会变得出乎意料地差，所以这个问题值得特别关注。</p> <p>当某个 TCP 端点关闭 TCP 连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是<strong>所估计的最大分段使用期的两倍</strong>（称为 <code class="language-plaintext highlighter-rouge">2MSL</code>，通常为 2 分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。实际上，<strong>这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同 IP 地址和端口号的连接</strong>。</p> <p>现在高速路由器的使用，使得重复分组几乎不可能在连接关闭的几分钟之后，出现在服务器上。有些操作系统会将 <code class="language-plaintext highlighter-rouge">2MSL</code> 设置为一个较小的值，但修改此值时要特别小心。分组确实会被复制，如果来自之前连接的复制分组插入了具有相同连接值的新 TCP 流，会破坏 TCP 数据。</p> <p><code class="language-plaintext highlighter-rouge">2MSL</code> 的连接关闭延迟通常不是什么问题，但在性能基准环境下就可能会成为一个问题。进行性能基准测试时，通常只有一台或几台用来产生流量的计算机连接到某系统中去，这样就限制了连接到服务器的客户端 IP 地址数。而且，服务器通常会在 HTTP 的默认 TCP 端口 <code class="language-plaintext highlighter-rouge">80</code> 上进行监听。用 TIME_WAIT 防止端口号重用时，这些情况也限制了可用的连接值组合。</p> <p>在只有一个客户端和一台 Web 服务器的异常情况下，构建一条 TCP 连接的 4 个值：</p> \[&lt;source-IP-address，source-port，destination-IP-address，destination-port&gt;\] <p>其中的 3 个都是固定的——只有源端口号可以随意改变：</p> \[&lt;client-IP，source-port，server-IP，80&gt;\] <p>客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限（比如，60000 个），而且在 <code class="language-plaintext highlighter-rouge">2MSL</code> 秒（比如，120 秒）内连接是无法重用的， 连接率就被限制在了 <code class="language-plaintext highlighter-rouge">60 000/120 = 500 次/秒</code>。如果再不断进行优化，并且服务器的连接率不高于 500 次/秒，就可确保不会遇到 TIME_WAIT 端口耗尽问题。要修正这个问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟 IP 地址以增加更多的连接组合。</p> <p>即使没有遇到端口耗尽问题，也要特别小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。在有大量打开连接或控制块的情况下，有些操作系统的速度会严重减缓。</p> <h2 id="三http-连接的处理">三、HTTP 连接的处理</h2> <h3 id="31-常被误解的-connection-首部">3.1 常被误解的 Connection 首部</h3> <p>HTTP 允许在客户端和最终的源端服务器之间存在一串 HTTP 中间实体（代理、高速缓存等）。可以从客户端开始，逐跳地将 HTTP 报文经过这些中间设备，转发到源端服务器上去（或者进行反向传输）。</p> <p>在某些情况下，两个相邻的 HTTP 应用程序会为它们共享的连接应用一组选项。HTTP 的 <code class="language-plaintext highlighter-rouge">Connection</code> 首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。比如，可以用 <code class="language-plaintext highlighter-rouge">Connection: close</code> 来说明发送完下一条报文之后必须关闭的连接。</p> <p>Connection 首部可以承载3种不同类型的标签， 因此有时会很令人费解：</p> <ul> <li>HTTP 首部字段名，列出了只与此连接有关的首部；</li> <li>任意标签值，用于描述此连接的非标准选项；</li> <li>值 <code class="language-plaintext highlighter-rouge">close</code>，说明操作完成之后需关闭这条持久连接。</li> </ul> <p>如果连接标签中包含了一个 HTTP 首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，<strong>必须删除 <code class="language-plaintext highlighter-rouge">Connection</code> 首部列出的所有首部字段</strong>。由于 <code class="language-plaintext highlighter-rouge">Connection</code> 首部可以防止无意中对本地首部的转发，因此将逐跳首部名放入 <code class="language-plaintext highlighter-rouge">Connection</code> 首部被称为“对首部的保护”。图 4-9 显示了一个这样的例子。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-Connection-header-allows-the-sender-to-specify-options-related-to-the-connection-480.webp 480w,/assets/images/http-the-definitive-guide/the-Connection-header-allows-the-sender-to-specify-options-related-to-the-connection-800.webp 800w,/assets/images/http-the-definitive-guide/the-Connection-header-allows-the-sender-to-specify-options-related-to-the-connection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-Connection-header-allows-the-sender-to-specify-options-related-to-the-connection.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Connection 首部允许发送端指定与连接有关的选项" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-9 Connection 首部允许发送端指定与连接有关的选项 </div> <p>HTTP 应用程序收到一条带有 <code class="language-plaintext highlighter-rouge">Connection</code> 首部的报文时，接收端会解析发送端请求的所有选项，并将其应用。然后会在将此报文转发给下一跳地址之前，删除 <code class="language-plaintext highlighter-rouge">Connection</code> 首部以及 <code class="language-plaintext highlighter-rouge">Connection</code> 中列出的所有首部。而且，可能还会有少量没有作为 <code class="language-plaintext highlighter-rouge">Connection</code> 首部值列出，但一定不能被代理转发的逐跳首部。其中包括 <code class="language-plaintext highlighter-rouge">Prxoy-Authenticate</code>、<code class="language-plaintext highlighter-rouge">Proxy-Connection</code>、<code class="language-plaintext highlighter-rouge">Transfer-Encoding</code> 和 <code class="language-plaintext highlighter-rouge">Upgrade</code>。</p> <h3 id="32-串行事务处理时延">3.2 串行事务处理时延</h3> <p>如果只对连接进行简单的管理，TCP 的性能时延可能会叠加起来。比如，假设有一个包含了 3 个嵌入图片的 Web 页面。浏览器需要发起 4 个 HTTP 事务来显示此页面：1 个用于顶层的 HTML 页面，3 个用于嵌入的图片。如果每个事务都需要（串行地建立）一条新的连接，那么连接时延和慢启动时延就会叠加起来（参见图 4-10）。”</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-serial-transactions-480.webp 480w,/assets/images/http-the-definitive-guide/4-serial-transactions-800.webp 800w,/assets/images/http-the-definitive-guide/4-serial-transactions-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-serial-transactions.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个事务（串行）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-10 4 个事务（串行） </div> <p>除了串行加载引入的实际时延之外，加载一幅图片时，页面上其他地方都没有动静也会让人觉得速度很慢。用户更希望能够同时加载多幅图片。IO 串行加载的另一个缺点是，有些浏览器在对象加载完毕之前无法获知对象的尺寸，而且它们可能需要尺寸信息来决定将对象放在屏幕的什么位置上，所以在加载了足够多的对象之前，无法在屏幕上显示任何内容。在这种情况下，可能浏览器串行装载对象的进度很正常， 但用户面对的却是一个空白的屏幕，对装载的进度一无所知。</p> <p>还有几种现存和新兴的方法可以提高 HTTP 的连接性能。</p> <ul> <li>并行连接：通过多条 TCP 连接发起并发的 HTTP 请求。</li> <li>持久连接：重用 TCP 连接，以消除连接及关闭时延。</li> <li>管道化连接：通过共享的 TCP 连接发起并发的 HTTP 请求。</li> <li>复用的连接：交替传送请求和响应报文（实验阶段）。</li> </ul> <h2 id="四并行连接">四、并行连接</h2> <p>如图 4-11 所示，HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。在这个例子中，并行加载了四幅嵌入式图片， 每个事务都有自己的 TCP 连接。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/each-component-on-the-page-contains-a-separate-HTTP-transaction-480.webp 480w,/assets/images/http-the-definitive-guide/each-component-on-the-page-contains-a-separate-HTTP-transaction-800.webp 800w,/assets/images/http-the-definitive-guide/each-component-on-the-page-contains-a-separate-HTTP-transaction-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/each-component-on-the-page-contains-a-separate-HTTP-transaction.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="页面上的每个组件都包含一个独立的 HTTP 事务" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-11 页面上的每个组件都包含一个独立的 HTTP 事务 </div> <h3 id="41-并行连接可能会提高页面的加载速度">4.1 并行连接可能会提高页面的加载速度</h3> <p>包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。</p> <p>图 4-12 显示了并行连接的时间线，比图 4-10 要快得多。首先装载的是封闭的 HTML 页面，然后并行处理其余的 3 个事务，每个事务都有自己的连接。”图片的装载是并行的，连接的时延也是重叠的。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-parallel-transactions-480.webp 480w,/assets/images/http-the-definitive-guide/4-parallel-transactions-800.webp 800w,/assets/images/http-the-definitive-guide/4-parallel-transactions-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-parallel-transactions.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个事务（并行）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-12 4 个事务（并行） </div> <h3 id="42-并行连接不一定更快">4.2 并行连接不一定更快</h3> <p>即使并行连接的速度可能会更快，但并不一定总是更快。客户端的网络带宽不足（比如，浏览器是通过一个 28.8 kbps 的 Modem 连接到因特网上去的）时，大部分的时间可能都是用来传送数据的。在这种情况下，一个连接到速度较快服务器上的 HTTP 事务就会很容易地耗尽所有可用的 Modem 带宽。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。</p> <p>而且，打开大量连接会消耗很多内存资源，从而引发自身的性能问题。复杂的 Web 页面可能会有数十或数百个内嵌对象。客户端可能可以打开数百个连接，但 Web 服务器通常要同时处理很多其他用户的请求，所以很少有 Web 服务器希望出现这样的情况。一百个用户同时发出申请，每个用户打开 100 个连接，服务器就要负责处理 10 000 个连接。这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。实际上，浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值（通常是 4 个）。服务器可以随意关闭来自特定客户端的超量连接。</p> <h2 id="五持久连接">五、持久连接</h2> <p>Web 客户端经常会打开到同一个站点的连接。比如，一个 Web 页面上的大部分内嵌图片通常都来自同一个 Web 站点，而且相当一部分指向其他对象的超链通常都指向同一个站点。因此，初始化了对某服务器 HTTP 请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求（比如，获取在线图片）。这种性质被称为<strong>站点局部性</strong>（site locality）。</p> <p>因此，HTTP/1.1（以及 HTTP/1.0 的各种增强版本）允许 HTTP 设备在事务处理结束之后将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求<strong>重用</strong>现存的连接。<strong>在事务处理结束之后仍然保持在打开状态的 TCP 连接被称为持久连接</strong>。非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。</p> <p>重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。</p> <h3 id="51-持久以及并行连接">5.1 持久以及并行连接</h3> <p>我们看到， 并行连接可以提高复合页面的传输速度。但并行连接也有一些缺点。</p> <ul> <li>每个事务都会打开/关闭一条新的连接，会耗费时间和带宽。</li> <li>由于 TCP 慢启动特性的存在，每条新连接的性能都会有所降低。</li> <li>可打开的并行连接数量实际上是有限的。</li> </ul> <p>持久连接有一些比并行连接更好的地方。持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。但是，管理持久连接时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。</p> <p>持久连接与并行连接配合使用可能是最高效的方式。现在，很多 Web 应用程序都会打开少量的并行连接，其中的每个都是持久连接。持久连接有两种类型：比较老的 HTTP/1.0+ <strong>keep-alive 连接</strong>，以及现代的 HTTP/1.1 <strong>persistent 连接</strong>。</p> <h3 id="52-http10-keep-alive-连接">5.2 HTTP/1.0+ keep-alive 连接</h3> <p>大约从 1996 年开始，很多 HTTP/1.0 浏览器和服务器都进行了扩展，以支持一种被称为 keep-alive 连接的早期实验型持久连接。这些早期的持久连接受到了一些互操作性设计方面问题的困扰，这些问题在后期的 HTTP/1.1 版本中都得到了修正，但很多客户端和服务器仍然在使用这些早期的 keep-alive 连接。</p> <p>图 4-13 显示了 keep-alive 连接的一些性能优点，图中将在串行连接上实现 4 个 HTTP 事务的时间线与在一条持久连接上实现同样事务所需的时间线进行了比较。由于去除了进行连接和关闭连接的开销，所以时间线有所缩减。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-serial-and-persistent-connection-transactions-480.webp 480w,/assets/images/http-the-definitive-guide/4-serial-and-persistent-connection-transactions-800.webp 800w,/assets/images/http-the-definitive-guide/4-serial-and-persistent-connection-transactions-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-serial-and-persistent-connection-transactions.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个事务（串行与持久连接）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-13 4 个事务（串行与持久连接） </div> <h3 id="53-keep-alive-操作">5.3 Keep-Alive 操作</h3> <p>keep-alive 已经不再使用了，而且在当前的 HTTP/1.1 规范中也没有对它的说明了。但浏览器和服务器对 keep-alive 握手的使用仍然相当广泛，因此，HTTP 的实现者应该做好与之进行交互操作的准备。现在我们来快速浏览一下 keep-alive 的操作（对keep-alive 握手更详细的解释请参见较早的 HTTP/1.1 规范版本（比如 RFC 2068））。实现 HTTP/1.0 keep-alive 连接的客户端可以通过包含 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部请求将一条连接保持在打开状态。</p> <p>如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部（参见图 4-14）。如果响应中没有 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，客户端就认为服务器不支持 keep-alive，会在发回响应报文之后关闭连接。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-handshake-of-a-keep-alive-transaction-480.webp 480w,/assets/images/http-the-definitive-guide/the-handshake-of-a-keep-alive-transaction-800.webp 800w,/assets/images/http-the-definitive-guide/the-handshake-of-a-keep-alive-transaction-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-handshake-of-a-keep-alive-transaction.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP/1.0 keep-alive 事务首部的握手过程" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-14 HTTP/1.0 keep-alive 事务首部的握手过程 </div> <h3 id="54-keep-alive-选项">5.4 Keep-Alive 选项</h3> <p>注意， <code class="language-plaintext highlighter-rouge">keep-Alive</code> 首部只是请求将连接保持在活跃状态。发出 keep-alive 请求之后，客户端和服务器并不一定会同意进行 keep-alive 会话。它们可以在任意时刻关闭空闲的 keep-alive 连接，并可随意限制 keep-alive 连接所处理事务的数量。可以用 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 通用首部中指定的、由逗号分隔的选项来调节 keep-alive 的行为。</p> <ul> <li>参数 <code class="language-plaintext highlighter-rouge">timeout</code> 是在 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 响应首部发送的。它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。</li> <li>参数 <code class="language-plaintext highlighter-rouge">max</code> 是在 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 响应首部发送的。它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。</li> <li><code class="language-plaintext highlighter-rouge">Keep-Alive</code> 首部还可支持任意未经处理的属性，这些属性主要用于诊断和调试。语法为 <code class="language-plaintext highlighter-rouge">name [=value]</code>。</li> </ul> <p><code class="language-plaintext highlighter-rouge">Keep-Alive</code> 首部完全是可选的，但只有在提供 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 时才能使用它。这里有个 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 响应首部的例子，这个例子说明服务器最多还会为另外 5 个事务保持连接的打开状态，或者将打开状态保持到连接空闲了 2 分钟之后。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
</span></code></pre></div></div> <h3 id="55-keep-alive-连接的限制和规则">5.5 Keep-Alive 连接的限制和规则</h3> <p>使用 keep-alive 连接时有一些限制和一些需要澄清的地方。</p> <ul> <li>在 HTTP/1.0 中，keep-alive 并不是默认使用的。客户端必须发送一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 请求首部来激活 keep-alive 连接。</li> <li><code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部必须随<strong>所有</strong>希望保持持久连接的报文一起发送。如果客户端没有发送 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，服务器就会在那条请求之后关闭连接。</li> <li>通过检测响应中是否包含 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 响应首部，客户端可以判断服务器是否会在发出响应之后关闭连接。</li> <li><strong>只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态</strong> - 也就是说实体的主体部分必须有正确的 <code class="language-plaintext highlighter-rouge">Content-Length</code>，有多部件媒体类型，或者用分块传输编码的方式进行了编码。在一条 keep-alive 信道中回送错误的 <code class="language-plaintext highlighter-rouge">Content-Length</code> 是很糟糕的事，这样的话，事务处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了。</li> <li>代理和网关必须执行 <code class="language-plaintext highlighter-rouge">Connection</code> 首部的规则。代理或网关必须在将报文转发出去或将其高速缓存之前，删除在 <code class="language-plaintext highlighter-rouge">Connection</code> 首部中命名的所有首部字段以及 <code class="language-plaintext highlighter-rouge">Connection</code> 首部自身。</li> <li>严格来说，不应该与无法确定是否支持 <code class="language-plaintext highlighter-rouge">Connection</code> 首部的代理服务器建立 keep-alive 连接，以防止出现下面要介绍的<strong>哑代理</strong>问题。在实际应用中不是总能做到这一点的。</li> <li>从技术上来讲，应该忽略所有来自 HTTP/1.0 设备的 <code class="language-plaintext highlighter-rouge">Connection</code> 首部字段（包括 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code>），因为它们可能是由比较老的代理服务器误转发的。但实际上，尽管可能会有在老代理上挂起的危险，有些客户端和服务器还是会违反这条规则。</li> <li>除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备。</li> </ul> <h3 id="56-keep-alive和哑代理">5.6 Keep-Alive和哑代理</h3> <p>我们来仔细看看 keep-alive 和<strong>哑代理</strong>中一些比较微妙的问题。Web 客户端的 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部应该只会对这条离开客户端的 TCP 链路产生影响。这就是将其称作“连接”首部的原因。如果客户端正在与一台 Web 服务器对话，客户端可以发送一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部来告知服务器希望保持连接的活跃状态。如果服务器支持 keep-alive，就回送一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，否则就不回送。</p> <h4 id="1connection-首部和盲中继">（1）Connection 首部和盲中继</h4> <p>问题出在代理上——尤其是那些不理解 <code class="language-plaintext highlighter-rouge">Connection</code> 首部，而且不知道在沿着转发链路将其发送出去之前，应该将该首部删除的代理。很多老的或简单的代理都是<strong>盲中继</strong>（blind relay），它们只是将字节从一个连接转发到另一个连接中去，不对 <code class="language-plaintext highlighter-rouge">Connection</code> 首部进行特殊的处理。</p> <p>假设有一个 Web 客户端正通过一个作为盲中继使用的哑代理与Web服务器进行对话。图 4-15 显示的就是这种情形。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/keep-alive-cannot-interoperate-with-agents-that-do-not-support-Connection-headers-480.webp 480w,/assets/images/http-the-definitive-guide/keep-alive-cannot-interoperate-with-agents-that-do-not-support-Connection-headers-800.webp 800w,/assets/images/http-the-definitive-guide/keep-alive-cannot-interoperate-with-agents-that-do-not-support-Connection-headers-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/keep-alive-cannot-interoperate-with-agents-that-do-not-support-Connection-headers.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="keep-alive 无法与不支持 Connection 首部的代理进行互操作" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-15 keep-alive 无法与不支持 Connection 首部的代理进行互操作 </div> <p>这幅图中发生的情况如下所示。</p> <ol> <li>在图 4-15a 中，Web 客户端向代理发送了一条报文，其中包含了 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，如果可能的话请求建立一条 keep-alive 连接。客户端等待响应，以确定对方是否认可它对 keep-alive 信道的请求。</li> <li>哑代理收到了这条 HTTP 请求，但它并不理解 <code class="language-plaintext highlighter-rouge">Connection</code> 首部（只是将其作为一个扩展首部对待）。代理不知道 keep-alive 是什么意思，因此只是沿着转发链路将报文一字不漏地发送给服务器（图 4-15b）。但 connection 首部是个逐跳首部，只适用于单条传输链路，不应该沿着传输链路向下传输。接下来，就要发生一些很糟糕的事情了。</li> <li>在图 4-15b 中，经过中继的 HTTP 请求抵达了 Web 服务器。当 Web 服务器收到经过代理转发的 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部时，会误以为代理（对服务器来说，这个代理看起来就和所有其他客户端一样）希望进行 keep-alive 对话!对 Web 服务器来说这没什么问题 —— 它同意进行 keep-alive 对话，并在图 4-15c 中回送了一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 响应首部。所以，此时 Web 服务器认为它在与代理进行 keep-alive 对话，会遵循 keep-alive 的规则。但代理却对 keep-alive 一无所知。不妙。</li> <li>在图 4-15d 中，哑代理将 Web 服务器的响应报文回送给客户端，并将来自 Web 服务器的 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部一起传送过去。客户端看到这个首部，就会认为代理同意进行 keep-alive 对话。所以，此时客户端和服务器都认为它们在进行 keep-alive 对话，但与它们进行对话的代理却对 keep-alive 一无所知。</li> <li>由于代理对 keep-alive 一无所知，所以会将收到的所有数据都回送给客户端，然后<strong>等待源端服务器关闭连接</strong>。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了，所以不会去关闭连接。这样，代理就会挂在那里等待连接的关闭。</li> <li>客户端在图 4-15d 中收到了回送的响应报文时，会立即转向下一条请求，在 keep-alive 连接上向代理发送另一条请求（参见图 4-15e）。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。</li> <li>这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时，并将其关闭为止。</li> </ol> <h4 id="2代理和逐跳首部">（2）代理和逐跳首部</h4> <p>为避免此类代理通信问题的发生，现代的代理都绝不能转发 <code class="language-plaintext highlighter-rouge">Connection</code> 首部和所有名字出现在 <code class="language-plaintext highlighter-rouge">Connection</code> 值中的首部。因此，如果一个代理收到了一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，是不应该转发 <code class="language-plaintext highlighter-rouge">Connection</code> 首部，或所有名为 Keep-Alive 的首部的。</p> <p>另外，还有几个不能作为 <code class="language-plaintext highlighter-rouge">Connection</code> 首部值列出，也不能被代理转发或作为缓存响应使用的首部。其中包括 <code class="language-plaintext highlighter-rouge">Proxy-Authenticate</code>、<code class="language-plaintext highlighter-rouge">Proxy-Connection</code>、<code class="language-plaintext highlighter-rouge">Transfer-Encoding</code> 和 <code class="language-plaintext highlighter-rouge">Upgrade</code>。</p> <h3 id="57-插入-proxy-connection">5.7 插入 Proxy-Connection</h3> <p>Netscape 的浏览器及代理实现者们提出了一个对盲中继问题的变通做法，这种做法并不要求所有的 Web 应用程序支持高版本的 HTTP。这种变通做法引入了一个名为 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 的新首部，解决了在客户端后面紧跟着一个盲中继所带来的问题 —— 但并没有解决所有其他情况下存在的问题。在显式配置了代理的情况下，现代浏览器都实现了 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code>，很多代理都能够理解它。</p> <p>问题是哑代理盲目地转发 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 之类的逐跳首部惹出了麻烦。逐跳首部只与一条特定的连接有关，不能被转发。当下游服务器误将转发来的首部作为来自代理自身的请求解释，用它来控制自己的连接时，就会引发问题。</p> <p>在网景的变通做法是，浏览器会向代理发送非标准的 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 扩展首部，而不是官方支持的著名的 <code class="language-plaintext highlighter-rouge">Connection</code> 首部。如果代理是盲中继，它会将无意义的 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部转发给 Web 服务器，服务器会忽略此首部，不会带来任何问题。但如果代理是个聪明的代理（能够理解持久连接的握手动作），就用一个 <code class="language-plaintext highlighter-rouge">Connection</code> 首部取代无意义的 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部，然后将其发送给服务器，以收到预期的效果。</p> <p>图 4-16a ~ 图 4-16d 显示了盲中继是如何向 Web 服务器转发 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部，而不带来任何问题的，Web 服务器忽略了这个首部，这样在客户端和代理，或者代理和服务器之间就不会建立起 keep-alive 连接了。图 4-16e ~ 图 4-16h 中那个聪明的代理知道 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部是对 keep-alive 对话的请求，它会发送自己的 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部来建立 keep-alive 连接。</p> <p>在客户端和服务器之间只有一个代理时可以用这种方案来解决问题。但如图 4-17 所示，如果在哑代理的任意一侧还有一个聪明的代理，这个问题就会再次露头了。而且，网络中出现“不可见”代理的情况现在变得很常见了，这些代理可以是防火墙、拦截缓存，或者是反向代理服务器的加速器。这些设备对浏览器是不可见的，所以浏览器不会向它们发送 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部。透明的 Web 应用程序正确地实现持久连接是非常重要的。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-Proxy-Connection-header-fixes-an-issue-caused-by-a-single-blind-relay-480.webp 480w,/assets/images/http-the-definitive-guide/the-Proxy-Connection-header-fixes-an-issue-caused-by-a-single-blind-relay-800.webp 800w,/assets/images/http-the-definitive-guide/the-Proxy-Connection-header-fixes-an-issue-caused-by-a-single-blind-relay-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-Proxy-Connection-header-fixes-an-issue-caused-by-a-single-blind-relay.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="proxy-Connection 首部修正了单个盲中继带来的问题" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-16 Proxy-Connection 首部修正了单个盲中继带来的问题 </div> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/Proxy-Connection-does-not-resolve-the-case-of-multiple-proxies-480.webp 480w,/assets/images/http-the-definitive-guide/Proxy-Connection-does-not-resolve-the-case-of-multiple-proxies-800.webp 800w,/assets/images/http-the-definitive-guide/Proxy-Connection-does-not-resolve-the-case-of-multiple-proxies-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/Proxy-Connection-does-not-resolve-the-case-of-multiple-proxies.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="对有多层次代理的情况，Proxy-Connection 仍然无法解决问题" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-17 对有多层次代理的情况，Proxy-Connection 仍然无法解决问题 </div> <h3 id="58-http11-持久连接">5.8 HTTP/1.1 持久连接</h3> <p>HTTP/1.1 逐渐停止了对 keep-alive 连接的支持，用一种名为<strong>持久连接</strong>（persistent connection）的改进型设计取代了它。持久连接的目的与 keep-alive 连接的目的相同，但工作机制更优一些。</p> <p>与 HTTP/1.0+ 的 keep-alive 连接不同，HTTP/1.1 持久连接在<strong>默认情况下是激活的</strong>。除非特别指明，否则 HTTP/1.1 假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文中显式地添加一个 <code class="language-plaintext highlighter-rouge">Connection: close</code> 首部。这是与以前的 HTTP 协议版本很重要的区别，在以前的版本中，keep-alive 连接要么是可选的，要么根本就不支持。</p> <p>HTTP/1.1 客户端假定在收到响应后，除非响应中包含了 <code class="language-plaintext highlighter-rouge">Connection: close</code> 首部，不然 HTTP/1.1 连接就仍维持在打开状态。但是，客户端和服务器仍然可以随时关闭空闲的连接。不发送 <code class="language-plaintext highlighter-rouge">Connection: close</code> 并不意味着服务器承诺永远将连接保持在打开状态。</p> <h3 id="59-持久连接的限制和规则">5.9 持久连接的限制和规则</h3> <p>在持久连接的使用中有以下限制和需要澄清的问题。</p> <ul> <li>发送了 <code class="language-plaintext highlighter-rouge">Connection: close</code> 请求首部之后，客户端就无法在那条连接上发送更多的请求了。</li> <li>如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个 <code class="language-plaintext highlighter-rouge">Connection: close</code> 请求首部。</li> <li>只有当连接上所有的报文都有正确的、自定义报文长度时 - 也就是说，实体主体部分的长度都和相应的 <code class="language-plaintext highlighter-rouge">Content-Length</code> 一致，或者是用分块传输编码方式编码的 —— 连接才能持久保持。</li> <li>HTTP/1.1 的代理必须能够分别管理与客户端和服务器的持久连接 —— 每个持久连接都只适用于一跳传输。</li> <li>（由于较老的代理会转发 <code class="language-plaintext highlighter-rouge">Connection</code> 首部，所以）HTTP/1.1 的代理服务器不应该与 HTTP/1.0 客户端建立持久连接，除非它们了解客户端的处理能力。实际上，这一点是很难做到的，很多厂商都违背了这一原则。</li> <li>尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求，但不管 <code class="language-plaintext highlighter-rouge">Connection</code> 首部取了什么值，HTTP/1.1 设备都可以在任意时刻关闭连接。</li> <li>HTTP/1.1 应用程序必须能够从异步的关闭中恢复出来。只要不存在可能会累积起来的副作用，客户端都应该重试这条请求。</li> <li>除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭了，客户端就必须要重新发起请求。</li> <li>一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。代理可能需要更多到服务器的连接来支持并发用户的通信，所以，如果有 <code class="language-plaintext highlighter-rouge">N</code> 个用户试图访问服务器的话，代理最多要维持 <code class="language-plaintext highlighter-rouge">2N</code> 条到任意服务器或父代理的连接。</li> </ul> <h2 id="六管道化连接">六、管道化连接</h2> <p>HTTP/1.1 允许在持久连接上可选地使用<strong>请求管道</strong>。这是相对于 keep-alive 连接的又一性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。图 4-18 a-c 显示了持久连接是怎样消除 TCP 连接时延，以及管道化请求（参见图 4-18c）是如何消除传输时延的。</p> <p>对管道化连接有几条限制。</p> <ul> <li>如果 HTTP 客户端无法确认连接是持久的，就不应该使用管道。</li> <li>必须按照与请求相同的顺序回送 HTTP 响应。HTTP 报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li> <li>HTTP 客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了 10 条请求，服务器可能在只处理了，比方说，5 条请求之后关闭连接。剩下的 5 条请求会失败，客户端必须能够应对这些过早关闭连接的情况，重新发出这些请求。</li> <li>HTTP 客户端不应该用管道化的方式发送会产生副作用的请求（比如 POST）。总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试 POST 这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险。</li> </ul> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-pipes-connect-the-transaction-480.webp 480w,/assets/images/http-the-definitive-guide/4-pipes-connect-the-transaction-800.webp 800w,/assets/images/http-the-definitive-guide/4-pipes-connect-the-transaction-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-pipes-connect-the-transaction.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个事务（管道连接）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-18 4 个事务（管道连接） </div> <h2 id="七关闭连接的奥秘">七、关闭连接的奥秘</h2> <h3 id="71-任意解除连接">7.1 “任意”解除连接</h3> <p>所有 HTTP 客户端、服务器或代理都可以在任意时刻关闭一条 TCP 传输连接。通常会在一条报文结束时关闭连接，但出错的时候，也可能在首部行的中间，或其他奇怪的地方关闭连接。对管道化持久连接来说，这种情形是很常见的。HTTP 应用程序可以在经过任意一段时间之后，关闭持久连接。比如，在持久连接空闲一段时间之后，服务器可能会决定将其关闭。</p> <p>但是，服务器永远都无法确定在它关闭“空闲”连接的那一刻，在线路那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现了连接错误。</p> <h3 id="72-content-length-及截尾操作">7.2 Content-Length 及截尾操作</h3> <p>每条 HTTP 响应都应该有精确的 <code class="language-plaintext highlighter-rouge">Content-Length</code> 首部，用以描述响应主体的尺寸。一些老的 HTTP 服务器会省略 <code class="language-plaintext highlighter-rouge">Content-Length</code> 首部，或者包含错误的长度指示，这样就要依赖服务器发出的连接关闭来说明数据的真实末尾。</p> <p>客户端或代理收到一条随连接关闭而结束的 HTTP 响应，且实际传输的实体长度与 <code class="language-plaintext highlighter-rouge">Content-Length</code> 并不匹配（或没有 <code class="language-plaintext highlighter-rouge">Content-Length</code>）时，接收端就应该质疑长度的正确性。</p> <p>如果接收端是个缓存代理，接收端就不应该缓存这条响应（以降低今后将潜在的错误报文混合起来的可能）。代理应该将有问题的报文原封不动地转发出去，而不应该试图去“校正” <code class="language-plaintext highlighter-rouge">Content-Length</code>，以维护语义的透明性。</p> <h3 id="73-连接关闭容限重试以及幂等性">7.3 连接关闭容限、重试以及幂等性</h3> <p>即使在非错误情况下，连接也可以在任意时刻关闭。HTTP 应用程序要做好正确处理非预期关闭的准备。如果在客户端执行事务的过程中，传输连接关闭了，那么，除非事务处理会带来一些副作用，否则客户端就应该重新打开连接，并重试一次。对管道化连接来说，这种情况更加严重一些。客户端可以将大量请求放入队列中排队，但源端服务器可以关闭连接，这样就会留下大量未处理的请求，需要重新调度。副作用是很重要的问题。如果在发送出一些请求数据之后，收到返回结果之前，连接关闭了，客户端就无法百分之百地确定服务器端实际激活了多少事务。有些事务，比如 <code class="language-plaintext highlighter-rouge">GET</code> 一个静态的 HTML 页面，可以反复执行多次，也不会有什么变化。而其他一些事务，比如向一个在线书店 <code class="language-plaintext highlighter-rouge">POST</code> 一张订单，就不能重复执行，不然会有下多张订单的危险。</p> <p><strong>如果一个事务，不管是执行一次还是很多次，得到的结果都相同，这个事务就是幂等的</strong>。实现者们可以认为 <code class="language-plaintext highlighter-rouge">GET</code>、<code class="language-plaintext highlighter-rouge">HEAD</code>、<code class="language-plaintext highlighter-rouge">PUT</code>、<code class="language-plaintext highlighter-rouge">DELETE</code>、<code class="language-plaintext highlighter-rouge">TRACE</code> 和 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 方法都共享这一特性。”客户端不应该以管道化方式传送<strong>非幂等请求</strong>（比如 <code class="language-plaintext highlighter-rouge">POST</code>）。否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条请求的响应状态。</p> <p>尽管用户 Agent 代理可能会让操作员来选择是否对请求进行重试，但一定不能自动重试非幂等方法或序列。比如，大多数浏览器都会在重载一个缓存的 <code class="language-plaintext highlighter-rouge">POST</code> 响应时提供一个对话框，询问用户是否希望再次发起事务处理。</p> <h3 id="74-正常关闭连接">7.4 正常关闭连接</h3> <p>如图 4-19 所示，TCP 连接是双向的。TCP 连接的每一端都有一个输入队列和一个输出队列，用于数据的读或写。放入一端输出队列中的数据最终会出现在另一端的输入队列中。</p> <div class="row justify-content-center"> <div class="col-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-connections-are-bidirectional-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-connections-are-bidirectional-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-connections-are-bidirectional-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-connections-are-bidirectional.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 连接是双向的" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-19 TCP 连接是双向的 </div> <h4 id="1完全关闭与半关闭">（1）完全关闭与半关闭</h4> <p>应用程序可以关闭 TCP 输入和输出信道中的任意一个，或者将两者都关闭了。套接字调用 <code class="language-plaintext highlighter-rouge">close()</code> 会将 TCP 连接的输入和输出信道都关闭了。这被称作“<strong>完全关闭</strong>”，如图 4-20a 所示。还可以用套接字调用 <code class="language-plaintext highlighter-rouge">shutdown()</code> 单独关闭输入或输出信道。这被称为“<strong>半关闭</strong>”，如图 4-20b 所示。</p> <h4 id="2tcp-关闭及重置错误">（2）TCP 关闭及重置错误</h4> <p>简单的 HTTP 应用程序可以只使用完全关闭。但当应用程序开始与很多其他类型的 HTTP 客户端、服务器和代理进行对话且开始使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误就变得很重要了。</p> <div class="row justify-content-center"> <div class="col-5"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/full-off-and-half-off-480.webp 480w,/assets/images/http-the-definitive-guide/full-off-and-half-off-800.webp 800w,/assets/images/http-the-definitive-guide/full-off-and-half-off-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/full-off-and-half-off.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="完全关闭和半关闭" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-20 完全关闭和半关闭 </div> <p>总之，关闭连接的输出信道总是很安全的。连接另一端的对等实体会在从其缓冲区中读出所有数据之后收到一条通知，说明流结束了，这样它就知道你将连接关闭了。关闭连接的输入信道比较危险，除非你知道另一端不打算再发送其他数据了。如果另一端向你已关闭的输入信道发送数据，操作系统就会向另一端的机器回送一条 TCP “连接被对端重置”的报文，如图 4-21 所示。大部分操作系统都会将这种情况作为很严重的错误来处理，删除对端还未读取的所有缓存数据。对管道化连接来说，这是非常糟糕的事情。</p> <div class="row justify-content-center"> <div class="col-5"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/connection-reset-by-peer-error-480.webp 480w,/assets/images/http-the-definitive-guide/connection-reset-by-peer-error-800.webp 800w,/assets/images/http-the-definitive-guide/connection-reset-by-peer-error-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/connection-reset-by-peer-error.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="将数据传送到已关闭连接时会产生“连接被对端重置”错误" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-21 将数据传送到已关闭连接时会产生“连接被对端重置”错误 </div> <p>比如你已经在一条持久连接上发送了 10 条管道式请求了，响应也已经收到了，正在操作系统的缓冲区中存着呢（但应用程序还未将其读走）。现在，假设你发送了第 11 条请求，但服务器认为你使用这条连接的时间已经够长了，决定将其关闭。那么你的第 11 条请求就会被发送到一条已关闭的连接上去，并会向你回送一条重置信息。这个重置信息会清空你的输入缓冲区。</p> <p>当你最终要去读取数据的时候，会得到一个连接被对端重置的错误，已缓存的未读 响应数据都丟失了， 尽管其中的大部分都已经成功抵达你的机器了。</p> <h4 id="3正常关闭">（3）正常关闭</h4> <p>HTTP 规范建议，当客户端或服务器突然要关闭一条连接时，应该“正常地关闭传输连接”，但它并没有说明应该如何去做。</p> <p>总之，实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待连接另一端的对等实体关闭它的输出信道。当两端都告诉对方它们不会再发送任何数据（比如关闭输出信道）之后，连接就会被完全关闭，而不会有重置的危险。</p> <p>但不幸的是，无法确保对等实体会实现半关闭，或对其进行检查。因此，想要正常关闭连接的应用程序应该先关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</p> <h2 id="八参考">八、参考</h2> <ul> <li><a href="https://www.oreilly.com/library/view/http-the-definitive/1565925092/">HTTP 权威指南</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="computer"/><category term="networks"/><category term="http"/><summary type="html"><![CDATA[本文节选自《HTTP 权威指南 - 第4章 连接管理》。]]></summary></entry><entry><title type="html">ES6 - 编程风格</title><link href="https://feng-zhang0712.github.io//blog/2024/style/" rel="alternate" type="text/html" title="ES6 - 编程风格"/><published>2024-09-20T00:00:00+00:00</published><updated>2024-09-20T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/style</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/style/"><![CDATA[<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。本章内容主要参考了 <a href="https://github.com/airbnb/javascript">Airbnb</a> 公司的 JavaScript 风格规范。</p> <h2 id="一块级作用域">一、块级作用域</h2> <h3 id="1let-取代-var">（1）let 取代 var</h3> <p>ES6 提出了两个新的声明变量的命令：<code class="language-plaintext highlighter-rouge">let</code> 和 <code class="language-plaintext highlighter-rouge">const</code>。其中，建议使用 <code class="language-plaintext highlighter-rouge">let</code> 命令取代 <code class="language-plaintext highlighter-rouge">var</code>，因为两者语义相同，而且 <code class="language-plaintext highlighter-rouge">let</code> 没有副作用。</p> <h3 id="2全局常量和线程安全">（2）全局常量和线程安全</h3> <p>在 <code class="language-plaintext highlighter-rouge">let</code> 和 <code class="language-plaintext highlighter-rouge">const</code> 之间，建议优先使用 <code class="language-plaintext highlighter-rouge">const</code>，尤其是在全局环境，不应该设置变量，只应设置<strong>常量</strong>。</p> <p><code class="language-plaintext highlighter-rouge">const</code> 优于 <code class="language-plaintext highlighter-rouge">let</code> 有几个原因。</p> <ul> <li><code class="language-plaintext highlighter-rouge">const</code> 可以提醒阅读程序的人，这个变量不应该改变。</li> <li><code class="language-plaintext highlighter-rouge">const</code> 比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算。</li> <li>JavaScript 编译器会对 <code class="language-plaintext highlighter-rouge">const</code> 进行优化，所以多使用 <code class="language-plaintext highlighter-rouge">const</code>，有利于提高程序的运行效率，也就是说 <code class="language-plaintext highlighter-rouge">let</code> 和 <code class="language-plaintext highlighter-rouge">const</code> 的本质区别，其实是编译器内部的处理不同。</li> <li><code class="language-plaintext highlighter-rouge">const</code> 可以防止无意间修改变量值所导致的错误。</li> </ul> <h2 id="二字符串">二、字符串</h2> <p>静态字符串一律使用<strong>单引号</strong>或<strong>反引号</strong>，不使用双引号。动态字符串使用反引号。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bad</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">foobar</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// acceptable</span>
<span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="s2">`foobar`</span><span class="p">;</span>

<span class="c1">// good</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">foobar</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="s2">`foo</span><span class="p">${</span><span class="nx">a</span><span class="p">}</span><span class="s2">bar`</span><span class="p">;</span>
</code></pre></div></div> <h2 id="三解构赋值">三、解构赋值</h2> <ul> <li>使用数组成员对变量赋值时，优先使用<strong>解构赋值</strong>。</li> <li>如果函数返回多个值，优先使用<strong>对象的解构赋值</strong>，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</li> </ul> <h2 id="四对象">四、对象</h2> <ul> <li>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</li> <li> <p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用 <code class="language-plaintext highlighter-rouge">Object.assign</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bad</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">// if reshape unavoidable</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>

<span class="c1">// good</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="kc">null</span> <span class="p">};</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div> </div> </li> <li> <p>如果对象的属性名是动态的，可以在创造对象的时候，使用<strong>属性表达式</strong>定义。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bad</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">id</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">San Francisco</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nf">getKey</span><span class="p">(</span><span class="dl">'</span><span class="s1">enabled</span><span class="dl">'</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="c1">// good</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">id</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">San Francisco</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">[</span><span class="nf">getKey</span><span class="p">(</span><span class="dl">'</span><span class="s1">enabled</span><span class="dl">'</span><span class="p">)]:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div> </div> </li> <li>对象的属性和方法，尽量采用<strong>简洁表达法</strong>，这样易于描述和书写。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">some value</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// bad</span>
<span class="kd">const</span> <span class="nx">atom</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">ref</span><span class="p">:</span> <span class="nx">ref</span><span class="p">,</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">addValue</span><span class="p">:</span> <span class="nf">function </span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">atom</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// good</span>
<span class="kd">const</span> <span class="nx">atom</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">ref</span><span class="p">,</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="nf">addValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">atom</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="五数组">五、数组</h2> <ul> <li>使用<strong>扩展运算符</strong>（<code class="language-plaintext highlighter-rouge">...</code>）拷贝数组。</li> <li>使用 <strong><code class="language-plaintext highlighter-rouge">Array.from</code></strong> 方法，将类似数组的对象转为数组。</li> </ul> <h2 id="六函数">六、函数</h2> <ul> <li>立即执行函数可以写成箭头函数的形式。</li> <li>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 <code class="language-plaintext highlighter-rouge">this</code>。</li> <li>箭头函数取代 <code class="language-plaintext highlighter-rouge">Function.prototype.bind</code>，不应再用 <code class="language-plaintext highlighter-rouge">self</code>/<code class="language-plaintext highlighter-rouge">_this</code>/<code class="language-plaintext highlighter-rouge">that</code> 绑定 <code class="language-plaintext highlighter-rouge">this</code>。</li> <li>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</li> <li>所有配置项都应该集中在一个对象，放在<strong>最后一个参数</strong>，布尔值最好不要直接作为参数，因为代码语义会很差，也不利于将来增加其他配置项。</li> <li>不要在函数体内使用 <code class="language-plaintext highlighter-rouge">arguments</code> 变量，使用 rest 运算符（<code class="language-plaintext highlighter-rouge">...</code>）代替。因为 rest 运算符显式表明你想要获取参数，而且 <code class="language-plaintext highlighter-rouge">arguments</code> 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</li> <li>使用<strong>默认值</strong>语法设置函数参数的默认值。</li> </ul> <h2 id="七map-解构">七、Map 解构</h2> <p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要 <code class="language-plaintext highlighter-rouge">key: value</code> 的数据结构，使用 Map 结构。因为 Map 有<strong>内建的遍历机制</strong>。</p> <h2 id="八class">八、Class</h2> <ul> <li>总是用 Class，取代需要 <code class="language-plaintext highlighter-rouge">prototype</code> 的操作。因为 Class 的写法更简洁，更易于理解。</li> <li>使用 <code class="language-plaintext highlighter-rouge">extends</code> 实现继承，因为这样更简单，不会有破坏 <code class="language-plaintext highlighter-rouge">instanceof</code> 运算的危险。</li> </ul> <h2 id="九模块">九、模块</h2> <p>ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">import</code> 取代 <code class="language-plaintext highlighter-rouge">require()</code>。</li> <li>使用 <code class="language-plaintext highlighter-rouge">export</code> 取代 <code class="language-plaintext highlighter-rouge">module.exports</code>。</li> <li>如果模块只有一个输出值，就使用 <code class="language-plaintext highlighter-rouge">export default</code>，如果模块有多个输出值，除非其中某个输出值特别重要，否则建议不要使用 <code class="language-plaintext highlighter-rouge">export default</code>，即多个输出值如果是<strong>平等关系</strong>，<code class="language-plaintext highlighter-rouge">export default</code> 与普通的 <code class="language-plaintext highlighter-rouge">export</code> 就不要同时使用。</li> <li>如果模块默认输出一个函数，函数名的首字母应该<strong>小写</strong>，表示这是一个<strong>工具方法</strong>。</li> <li>如果模块默认输出一个对象，对象名的首字母应该<strong>大写</strong>，表示这是一个<strong>配置值对象</strong>。</li> </ul> <h2 id="十eslint-的使用">十、ESLint 的使用</h2> <p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p> <ol> <li> <p>首先，在项目的根目录安装 ESLint。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> npm <span class="nb">install</span> <span class="nt">--save-dev</span> eslint
</code></pre></div> </div> </li> <li> <p>然后，安装 Airbnb 语法规则，以及 <code class="language-plaintext highlighter-rouge">import</code>、<code class="language-plaintext highlighter-rouge">a11y</code>、<code class="language-plaintext highlighter-rouge">react</code> 插件。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> npm <span class="nb">install</span> <span class="nt">--save-dev</span> eslint-config-airbnb
 npm <span class="nb">install</span> <span class="nt">--save-dev</span> eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react
</code></pre></div> </div> </li> <li> <p>最后，在项目的根目录下新建一个 <code class="language-plaintext highlighter-rouge">.eslintrc</code> 文件，配置 ESLint。</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"extends"</span><span class="p">:</span><span class="w"> </span><span class="s2">"eslint-config-airbnb"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span></code></pre></div> </div> </li> </ol> <p>现在就可以检查，当前项目的代码是否符合预设的规则。</p> <h2 id="十一参考">十一、参考</h2> <ul> <li>阮一峰，<a href="https://es6.ruanyifeng.com/#docs/style">ECMAScript 6 入门 - 编程风格</a></li> </ul>]]></content><author><name></name></author><category term="frontend"/><category term="es6"/><category term="style"/><category term="airbnb"/><summary type="html"><![CDATA[本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。本章内容主要参考了 Airbnb 公司的 JavaScript 风格规范。]]></summary></entry><entry><title type="html">计算机网络 - 应用层</title><link href="https://feng-zhang0712.github.io//blog/2024/application-layer/" rel="alternate" type="text/html" title="计算机网络 - 应用层"/><published>2024-09-15T00:00:00+00:00</published><updated>2024-09-15T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/application-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/application-layer/"><![CDATA[<p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程间的通信和协同工作来完成。应用进程间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规则。具体来说，应用层协议应当定义：</p> <ul> <li>应用进程交换的报文类型，如请求报文和响应报文。</li> <li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li> <li>字段的语义，即包含在字段中的信息的含义。</li> <li>进程何时、如何发送报文，以及对报文进行响应的规则。</li> </ul> <p>本章最重要的内容是：</p> <ul> <li>域名系统 DNS——从域名解析出 IP 地址。</li> <li>万维网和 HTTP 协议，以及万维网的两种不同的信息搜索引擎。</li> <li>电子邮件的传送过程，SMTP 协议和 POP3 协议、IMAP 协议使用的场合。</li> <li>动态主机配置协议 DHCP 的特点。</li> <li>网络管理的三个组成部分（SNMP 本身、管理信息结构 SMI 和管理信息库 MIB）的作用。</li> <li>系统调用和应用编程接口的基本概念。</li> <li>P2P 文件系统。</li> </ul> <h2 id="一域名系统-dns">一、域名系统 DNS</h2> <h3 id="11-域名系统概述">1.1 域名系统概述</h3> <p><strong>域名系统</strong> DNS（Domain Name System）是互联网使用的命名系统，用来把便于人们使用的机器名字转换 为IP 地址。</p> <p>互联网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行<strong>解析</strong>，仅少量解析需要在互联网上通信，因此 DNS 系统的效率很高。由于 DNS 是分布式系统，即使单个计算机出了故障，也不会妨碍整个 DNS 系统的正常运行。</p> <p>域名到 IP 地址的解析是由分布在互联网上的许多<strong>域名服务器程序</strong>（可简称为域名服务器）共同完成的。域名服务器程序在专设的结点上运行，而人们也常把运行域名服务器程序的机器称为<strong>域名服务器</strong>。</p> <p>域名到 IP 地址的解析过程的要点如下：当某个应用进程需要把主机名解析为 IP 地址时，该应用进程就调用<strong>解析程序</strong>，并成为 DNS 的一个客户，把待解析的域名放在 DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器（使用 UDP 是为了减少开销）。本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。应用进程获得目的主机的 IP 地址后即可进行通信。若本地域名服务器不能回答该请求，则此域名服务器就暂时成为 DNS 中的另一个客户，并向其他域名服务器发出查询请求。</p> <h3 id="12-互联网的域名结构">1.2 互联网的域名结构</h3> <p>互联网采用层次树状结构的命名方法，采用这种命名方法，任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结 构的名字，即域名（domain name）。这里，“域”（domain）是名字空间中一个可被管理的划 分。域还可以划分为子域，而子域还可继续划分为子域的子域，这样就形成了顶级域、二级 域、三级域，等等。从语法上讲，每个域名都由标号（label）序列组成，而各标号之间用点隔开。</p> <div class="row justify-content-center"> <div class="col-4"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/different-domain-names-480.webp 480w,/assets/images/computer-network/different-domain-names-800.webp 800w,/assets/images/computer-network/different-domain-names-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/different-domain-names.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="中央电视台用于收发电子邮件的计算机的域名" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>DNS 规定：</p> <ul> <li>域名中的标号都由英文字母和数字组成。</li> <li>每个标号不超过 63 个字符。</li> <li>不区分大小写字母。</li> <li>标号中除连字符（<code class="language-plaintext highlighter-rouge">-</code>）外不能使用其他的标点符号。</li> <li>级别最低的域名写在最左边，而级别最高的顶级域名则写在最右边。</li> <li>由多个标号组成的完整域名总共不超过 255 个字符</li> </ul> <p>原先的顶级域名共分为三大类：</p> <ol> <li><strong>国家顶级域名</strong> nTLD：如：<code class="language-plaintext highlighter-rouge">cn</code> 表示中国，<code class="language-plaintext highlighter-rouge">us</code> 表示美国，<code class="language-plaintext highlighter-rouge">uk</code> 表示英国，等等。</li> <li><strong>通用顶级域名</strong> gTLD：通用顶级域名有 20 个，即（这里只列举出了最初的 7 个）： <ul> <li><code class="language-plaintext highlighter-rouge">com</code>（公司企业）</li> <li><code class="language-plaintext highlighter-rouge">net</code>（网络服务机构）</li> <li><code class="language-plaintext highlighter-rouge">org</code>（非营利性组织）</li> <li><code class="language-plaintext highlighter-rouge">int</code>（国际组织）</li> <li><code class="language-plaintext highlighter-rouge">edu</code>（美国专用的教育机构）</li> <li><code class="language-plaintext highlighter-rouge">gov</code>（美国的政府部门）</li> <li><code class="language-plaintext highlighter-rouge">mil</code>（美国的军事部门）</li> </ul> </li> <li><strong>基础结构域名</strong>（infrastructure domain）：这种顶级域名只有一个，即 <code class="language-plaintext highlighter-rouge">arpa</code>，用于反向域名解析，因此又称为<strong>反向域名</strong>。</li> </ol> <p>注意，ICANN 后来正式批准了<strong>新顶级域名</strong>（New gTLD），因此任何公司、机构都有权向 ICANN 申请新的顶级域。</p> <p>用域名树来表示互联网的域名系统是最清楚的。图 6-1 是互联网域名空间的结构，它实际上是一个倒过来的树，在最上面的是根，但没有对应的名字。根下面一级的节点就是最高一级的顶级域名（由于根没有名字，所以在根下面一级的域名就叫做顶级域名）。顶级域名可往下划分子域，即二级域名。再往下划分就是三级域名、四级域名，等等。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-Internet's-domain-name-space-480.webp 480w,/assets/images/computer-network/the-Internet's-domain-name-space-800.webp 800w,/assets/images/computer-network/the-Internet's-domain-name-space-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-Internet's-domain-name-space.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="互联网的域名空间" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 6-1 互联网的域名空间 </div> <h3 id="13-域名服务器">1.3 域名服务器</h3> <p>一个服务器所负责管辖的（或有权限的）范围叫做<strong>区</strong>（zone）。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每个区设置相应的<strong>权限域名服务器</strong>（authoritative name server），用来保存该区中的所有主机的域名到 IP 地址的映射。由此看出，DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。区是 DNS 服务器实际管辖的范围。区可能等于或小于域，但一定不能大于域。</p> <p>图 6-2 是区的不同划分方法的举例。假定 abc 公司有下属部门 x 和 y，部门 x 下面又分三个分部门 u，v 和 w，而 y 下面还有其下属部门 t。图 6-2（a）表示 abc 公司只设一个区 <code class="language-plaintext highlighter-rouge">abc.com</code>。这时，区 <code class="language-plaintext highlighter-rouge">abc.com</code> 和域 <code class="language-plaintext highlighter-rouge">abc.com</code> 指的是同一件事。但图 6-2（b）表示 abc 公司划分了两个区（大的公司可能要划分多个区）：<code class="language-plaintext highlighter-rouge">abc.com</code> 和 <code class="language-plaintext highlighter-rouge">y.abc.com</code>。这两个区都隶属于域 <code class="language-plaintext highlighter-rouge">abc.com</code>，都各设置了相应的权限域名服务器。不难看出，区是“域”的子集。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/examples-of-DNS-zones-480.webp 480w,/assets/images/computer-network/examples-of-DNS-zones-800.webp 800w,/assets/images/computer-network/examples-of-DNS-zones-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/examples-of-DNS-zones.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="DNS 划分区的举例" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 6-2 DNS 划分区的举例 </div> <p>图 6-3 以图 6-2（b）中公司 abc 划分的两个区为例，给出了 DNS 域名服务器树状结构图。在图 6-3 中的每个域名服务器都能够进行部分域名到 IP 地址的解析。当某个 DNS 服务器不能进行域名到 IP 地址的转换时，它就设法找互联网上别的域名服务器进行解析。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/tree-structure-of-DNS-domain-name-server-480.webp 480w,/assets/images/computer-network/tree-structure-of-DNS-domain-name-server-800.webp 800w,/assets/images/computer-network/tree-structure-of-DNS-domain-name-server-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/tree-structure-of-DNS-domain-name-server.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="树状结构的 DNS 域名服务器" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 6-3 树状结构的 DNS 域名服务器 </div> <p>从图 6-3 可看出，互联网上的 DNS 域名服务器是按照层次安排的。每个域名服务器都只对域名体系中的一部分进行管辖。根据域名服务器所起的作用，可以把域名服务器划分为以下四种不同的类型：</p> <ul> <li><strong>根域名服务器</strong>（root name server）：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。根域名服务器是最重要的域名服务器，因为不管是哪个本地域名服务器，若要对互联网上任何一个域名进行解析（即转换为 IP 地址），只要自己无法解析，就首先要求助于根域名服务器。假定所有的根域名服务器都瘫痪了，那么整个互联网中的 DNS 系统就无法工作。据统计，到 2016 年2 月，全世界已经在 588 个<strong>地点</strong>（地点数值还在不断增加）安装了根域名服务器，但这么多的根域名服务器却只使用 13 个不同 IP 地址的域名，即 <code class="language-plaintext highlighter-rouge">a.rootservers.net</code>，<code class="language-plaintext highlighter-rouge">b.rootservers.net</code>，…，<code class="language-plaintext highlighter-rouge">m.rootservers.net</code>。注意，虽然互联网的根域名服务器总共只有 13 个域名，但这不表明根域名服务器是由 13 台<strong>机器</strong>所组成。实际上，在互联网中是由 13 套装置（13 installations）构成这 13 组根域名服务器[W-ROOT]。每套装置在很多地点安装根域名服务器（也可称为镜像根服务器），但都使用同一个域名。为了提供更可靠的服务，在每个地点的根域名服务器往往由多台机器组成。现在世界上大部分 DNS 域名服务器，都能就近找到一个根域名服务器查询 IP 地址（现在这些根域名服务器都已增加了 IPv6 地址）。为了方便，人们常用从 <code class="language-plaintext highlighter-rouge">A</code> 到 <code class="language-plaintext highlighter-rouge">M</code> 的前 13 个英文字母中的一个，来表示某组根域名服务器。注意，在许多情况下，根域名服务器并不直接把待查询的域名直接转换成 IP 地址（根域名服务器也没有存放这种信息），而是告诉本地域名服务器下一步应当找哪个顶级域名服务器进行查询。</li> <li><strong>顶级域名服务器</strong>（即 TLD 服务器）：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</li> <li><strong>权限域名服务器</strong>：指负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪个权限域名服务器。例如在图 6-2（b）中，区 <code class="language-plaintext highlighter-rouge">abc.com</code> 和区 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 各设有一个权限域名服务器。</li> <li><strong>本地域名服务器</strong>（local name server）：本地域名服务器并不属于图 6-3 所示的域名服务器层次结构，但它对域名系统非常重要。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每个互联网服务提供者 ISP，都可以拥有一个<strong>本地域名服务器</strong>，这种域名服务器有时也称为<strong>默认域名服务器</strong>。本地域名服务器离用户较近，一般不超过几个路由器的距离。当所要查询的主机也属于同一个本地 ISP 时，该本地域名服务器立即就能将所查询的主机名转换为它的 IP 地址，而不需要再去询问其他的域名服务器。</li> </ul> <p>为了提高域名服务器的可靠性， DNS域名服务器都把数据复制到几个域名服务器来保存，其中的一个是<strong>主域名服务器</strong>（master name server），其他的是<strong>辅助域名服务器</strong>（secondary name server）。当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。</p> <p>下面简单讨论一下域名的解析过程。这里要注意两点。</p> <ol> <li>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>（recursive query）。即：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</li> <li>本地域名服务器向根域名服务器的查询通常是采用<strong>迭代查询</strong>（iterative query）。迭代查询的特点是这样的：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪个域名服务器进行查询”。然后让本地域名服务器进行后续的查询（而不是替本地域名服务器进行后续的查询）。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地域名服务器下一步应当向哪个权限域名服务器进行查询，本地域名服务器就这样进行迭代查询。最后，知道了所要解析的域名的 IP 地址，然后把这个结果返回给发起查询的主机。当然，本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文的设置是要求使用哪种查询方式。</li> </ol> <p>图 6-5 用例子说明了这两种查询的区别。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/a-DNS-query-example-480.webp 480w,/assets/images/computer-network/a-DNS-query-example-800.webp 800w,/assets/images/computer-network/a-DNS-query-example-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/a-DNS-query-example.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="DNS 查询举例" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 6-5 DNS 查询举例 </div> <p>假定域名为 <code class="language-plaintext highlighter-rouge">m.xyz.com</code> 的主机想知道另一台主机（域名为 <code class="language-plaintext highlighter-rouge">y.abc.com</code>）的 IP 地址。例如，主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code> 打算发送邮件给主机 <code class="language-plaintext highlighter-rouge">y.abc.com</code>。这时就必须知道主机 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址。下面是图 6-5（a）的几个查询步骤：</p> <ol> <li>主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code> 先向其本地域名服务器 <code class="language-plaintext highlighter-rouge">dns.xyz.com</code> 进行递归查询。</li> <li>本地域名服务器采用迭代查询。它先向一个根域名服务器查询。</li> <li>根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器 <code class="language-plaintext highlighter-rouge">dns.com</code> 的 IP 地址。</li> <li>本地域名服务器向顶级域名服务器 <code class="language-plaintext highlighter-rouge">dns.com</code> 进行查询。</li> <li>顶级域名服务器 <code class="language-plaintext highlighter-rouge">dns.com</code> 告诉本地域名服务器，下一次应查询的权限域名服务器 <code class="language-plaintext highlighter-rouge">dns.abc.com</code> 的 IP 地址。</li> <li>本地域名服务器向权限域名服务器 <code class="language-plaintext highlighter-rouge">dns.abc.com</code> 进行查询。</li> <li>权限域名服务器 <code class="language-plaintext highlighter-rouge">dns.abc.com</code> 告诉本地域名服务器，所查询的主机的 IP 地址。</li> <li>本地域名服务器最后把查询结果告诉主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code>。</li> </ol> <p>我们注意到，这 8 个步骤总共要使用 8 个 UDP 用户数据报的报文。本地域名服务器经过三次迭代查询后，从权限域名服务器 <code class="language-plaintext highlighter-rouge">dns.abc.com</code> 得到了主机 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址，最后把结果返回给发起查询的主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code>。</p> <p>图 6-5（b）是本地域名服务器采用递归查询的情况。在这种情况下，本地域名服务器只需向根域名服务器查询一次，后面的几次查询都是在其他几个域名服务器之间进行的（步骤 3 至 6）。只是在步骤 7，本地域名服务器从根域名服务器得到了所需的 IP 地址。最后在步骤 8，本地域名服务器把查询结果告诉主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code>。整个的查询也是使用 8个 UDP 报文。</p> <p>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>（有时也称为高速缓存域名服务器）。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p> <p>例如，在图 6-5（a）的查询过程中，如果在不久前已经有用户查询过域名为 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址，那么本地域名服务器就不必向根域名服务器重新查询 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址，而是直接把高速缓存中存放的上次查询结果（即 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址）告诉用户。假定本地域名服务器的缓存中并没有 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的IP 地址，而是存放着顶级域名服务器 <code class="language-plaintext highlighter-rouge">dns.com</code> 的 IP 地址，那么本地域名服务器也可以不向根域名服务器进行查询，而是直接向 com 顶级域名服务器发送查询请求报文。这样不仅可以大大减轻根域名服务器的负荷，而且也能够使互联网上的 DNS 查询请求和回答报文的数量大为减少。</p> <h2 id="二文件传送协议">二、文件传送协议</h2> <h3 id="21">2.1</h3> <p>FTP 概述 文件传送协议 FTP （File Transfer Protocol） [RFC 959]是互联网上使用得最广泛的文件传 送协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用 ASCII 码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）。 FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。RFC 959 很早就成为了互联网的正式标准。 在互联网发展的早期阶段，用FTP 传送文件约占整个互联网的通信量的三分之一，而 由电子邮件和域名系统所产生的通信量还小于 FTP 所产生的通信量。只是到了 1995 年， WWW 的通信量才首次超过了FTP。 在下面 6。2。2 和 6。2。3 节分别介绍基于TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP，它们都是文件共享协议中的一大类，即复制整个文件，其特点是：若要存取一个文 件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然 后再将修改后的文件副本传回到原节点。 文件共享协议中的另一大类是联机访问（on-line access）。联机访问意味着允许多个程序 同时对一个文件进行存取。和数据库系统的不同之处是用户不需要调用一个特殊的客户进 程，而是由操作系统提供对远地共享文件进行访问的服务，就如同对本地文件的访问一样。 这就使用户可以用远地文件作为输入和输出来运行任何应用程序，而操作系统中的文件系统 则提供对共享文件的透明存取。透明存取的优点是：将原来用于处理本地文件的应用程序用 来处理远地文件时，不需要对该应用程序作明显的改动。属于文件共享协议的有网络文件系 统NFS （Network File System） [COME06]。网络文件系统NFS最初是在UNIX 操作系统环境 下实现文件和目录共享的。NFS 可使本地计算机共享远地的资源，就像这些资源在本地一 样。由于 NFS 原先是美国 SUN 公司在 TCP/IP 网络上创建的，因此目前 NFS 主要应用在 TCP/IP 网络上。然而现在 NFS 也可在 OS/2， MS-Windows， NetWare 等操作系统上运行。 NFS 还没有成为互联网的正式标准。经过几次修订更新，现在的最新版本（NFSv4）于 2015 年 3 月发布[RFC 7530]，目前还只是建议标准。限于篇幅，本书不讨论 NFS 的详细工 作过程。</p> <h3 id="22-ftp-的基本工作原理">2.2 FTP 的基本工作原理</h3> <p>网络环境中的一项基本应用就是将文件从一台计算机中复制到另一台可能相距很远的 计算机中。初看起来，在两台主机之间传送文件是很简单的事情。其实这往往非常困难。原 因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。经常遇到的问题是： （1） 计算机存储数据的格式不同。 （2） 文件的目录结构和文件命名的规定不同。 （3）对于相同的文件存取功能，操作系统使用的命令不同。 （4） 访问控制方法不同。 文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用TCP 可靠的运输服务。 FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。 FTP 使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程， 负责处理单个请求。 主进程的工作步骤如下： （1） 打开熟知端口（端口号为21），使客户进程能够连接上。 （2） 等待客户进程发出连接请求。 （3） 启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即 终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。 （4） 回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并 发进行的。 FTP 的工作情况如图6-6所示。图中的椭圆圈表示在系统中运行的进程。图中的服务器 端有两个从属进程：控制进程和数据传送进程。为简单起见，服务器端的主进程没有画上。 客户端除了控制进程和数据传送进程外，还有一个用户界面进程用来和用户接口。 在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：“控制连 接”和“数据连接”。控制连接在整个会话期间一直保持打开， FTP 客户所发出的传送请 求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传 输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后</p> <p>就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数 据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。由于 FTP 使用了一个分离的控制连接，因此 FTP 的控制信息是带外（out of band）传送的。 用户界面 TCP控制连接 控制进程 控制进程 互联网 数据传送 进程 数据传送 进程 FTP客户端 TCP 数据连接 FTP服务器端 图 6-6 FTP使用的两个TCP连接</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 21， 同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进 程用自己传送数据的熟知端口 20 与客户进程所提供的端口号建立数据传送连接。由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。 使用两个独立的连接的主要好处是使协议更加简单和更容易实现，同时在传输文件时 还可以利用控制连接对文件的传输进行控制。例如，客户发送“请求终止传输”。 FTP 并非对所有的数据传输都是最佳的。例如，计算机 A 上运行的应用程序要在远地 计算机 B 的一个很大的文件末尾添加一行信息。若使用 FTP，则应先将此文件从计算机 B 传送到计算机 A，添加上这一行信息后，再用FTP 将此文件传送到计算机 B，来回传送 这样大的文件很花时间。实际上这种传送是不必要的，因为计算机 A 并没有使用该文件的 内容。 然而网络文件系统 NFS 则采用另一种思路。NFS 允许应用进程打开一个远地文件，并 能在该文件的某一个特定的位置上开始读写数据。这样，NFS 可使用户只复制一个大文件 中的一个很小的片段，而不需要复制整个大文件。对于上述例子，计算机A中的 NFS 客户 软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 中的 NFS 服 务器，NFS 服务器更新文件后返回应答信息。在网络上传送的只是少量的修改数据。</p> <h3 id="23-简单文件传送协议-tftp">2.3 简单文件传送协议 TFTP</h3> <p>TCP/IP 协议族中还有一个简单文件传送协议 TFTP （Trivial File Transfer Protocol），它是 一个很小且易于实现的文件传送协议。TFTP 的版本是互联网的正式标准[RFC1350]。虽 然 TFTP 也使用客户服务器方式，但它使用UDP 数据报，因此 TFTP 需要有自己的差错改 正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录 的功能，也不能对用户进行身份鉴别。 TFTP 的主要优点有两个。第一，TFTP 可用于 UDP 环境。例如，当需要将程序或文件 同时向许多机器下载时就往往需要使用TFTP。第二，TFTP 代码所占的内存较小。这对较 小的计算机或某些特殊用途的设备是很重要的。这些设备不需要硬盘，只需要固化了 TFTP、UDP 和 IP 的小容量只读存储器即可。当接通电源后，设备执行只读存储器中的代 码，在网络上广播一个 TFTP 请求。网络上的 TFTP 服务器就发送响应，其中包括可执行二 进制程序。设备收到此文件后将其放入内存，然后开始运行程序。这种方式增加了灵活性， 也减少了开销。 TFTP的主要特点是： （1） 每次传送的数据报文中有512字节的数据，但最后一次可不足 512 字节。 （2）数据报文按序编号，从1开始。 （3） 支持 ASCII 码或二进制传送。 （4）可对文件进行读或写。 （5） 使用很简单的首部。 TFTP 的工作很像停止等待协议（见第 5 章 5。4。1 节）。发送完一个文件块后就等待对方 的确认，确认时应指明所确认的块编号。发完数据后在规定时间内收不到确认就要重发数据 PDU。发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这 样就可保证文件的传送不致因某一个数据报的丢失而告失败。 在一开始工作时。TFTP客户进程发送一个读请求报文或写请求报文给 TFTP 服务器进 程，其熟知端口号码为 69。TFTP服务器进程要选择一个新的端口和 TFTP 客户进程进行通 信。若文件长度恰好为512字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只 含首部而无数据的数据报文。若文件长度不是512字节的整数倍，则最后传送数据报文中的 数据字段一定不满512字节，这正好可作为文件结束的标志。</p> <h2 id="三远程终端协议-telnet">三、远程终端协议 TELNET</h2> <p>TELNET 是一个简单的远程终端协议[RFC 854]，它也是互联网的正式标准。用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录到远地的另一台主机上（使用主机 名或 IP 地址）。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接 连在远地主机上。因此，TELNET 又称为终端仿真协议。 TELNET 并不复杂，以前应用得很多。现在由于计算机的功能越来越强，用户已较少 使用TELNET了。 TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机 则运行 TELNET 服务器进程。和FTP的情况相似，服务器中的主进程等待新的请求，并产 生从属进程来处理每一个连接。 TELNET 能够适应许多计算机和操作系统的差异。例如，对于文本中一行的结束，有 的系统使用 ASCII 码的回车（CR），有的系统使用换行（LF），还有的系统使用两个字符，回车 -换行（CR-LF）。又如，在中断一个程序时，许多系统使用 Control-C （^C），但也有系统使用 ESC 按键。为了适应这种差异，TELNET 定义了数据和命令应怎样通过互联网。这些定义 就是所谓的网络虚拟终端 NVT （Network Virtual Terminal）。图 6-7 说明了 NVT 的意义。客户 软件把用户的击键和命令转换成NVT格式，并送交服务器。服务器软件把收到的数据和命 令从 NVT 格式转换成远地系统所需的格式。向用户返回数据时，服务器把远地系统的格式 转换为 NVT 格式，本地客户再从NVT 格式转换到本地系统所需的格式。 TELNET 客户端 TELNET 互联网 服务器端 TCP连接 客户 【服务器 使用客户端的格式 使用NVT 格式 使用服务器端的格式 图 6-7 TELNET 使用网络虚拟终端 NVT 格式</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"></div> <p>NVT 的格式定义很简单。所有的通信都使用8位一个字节。在运转时，NVT 使用7位 ASCII 码传送数据，而当高位置1时用作控制命令。ASCII 码共有95 个可打印字符（如字 母、数字、标点符号）和 33 个控制字符。所有可打印字符在 NVT 中的意义和在 ASCII 码 中一样。但 NVT 只使用了 ASCII 码的控制字符中的几个。此外，NVT 还定义了两字符的 CR-LF 为标准的行结束控制符。当用户键入回车按键时，TELNET 的客户就把它转换为 CR-LF 再进行传输，而TELNET 服务器要把 CR-LF 转换为远地机器的行结束字符。 TELNET 的选项协商（Option Negotiation）使 TELNET 客户和 TELNET 服务器可商定使 用更多的终端功能，协商的双方是平等的。</p> <h2 id="四万维网-www">四、万维网 WWW</h2> <h3 id="41-万维网概述">4.1 万维网概述</h3> <p><strong>万维网是一个大规模的、联机式的信息储藏所</strong>，英文简称为 Web。万维网以客户服务器方式工作。<strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>。</p> <p>万维网使用<strong>统一资源定位符</strong> URL（Uniform Resource Locator）来标志万维网上的各种文档，并使每个文档在整个互联网的范围内具有唯一的标识符 URL。客户程序与服务器程序之间的交互使用<strong>超文本传送协议</strong> HTTP（HyperText Transfer Protocol）。HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。万维网使用<strong>超文本标记语言</strong> HTML（HyperText Markup Language），使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来。</p> <h3 id="42-统一资源定位符-url">4.2 统一资源定位符 URL</h3> <h4 id="1url-的格式">（1）URL 的格式</h4> <p><strong>统一资源定位符</strong> URL 用来表示从互联网上的资源位置和访问这些资源的方法。互联网上的所有资源，都有一个唯一确定的 URL。URL 的一般形式由以下四个部分组成：</p> \[&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;\] <h4 id="2使用-http-的-url">（2）使用 HTTP 的 URL</h4> <p>对于万维网的网点的访问要使用 HTTP 协议。HTTP 的 URL 的一般形式是：</p> \[http://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;\] <p>HTTP 的默认端口号是 80，通常可省略。URL 里面的字母不分大小写。</p> <h3 id="43-超文本传送协议-http">4.3 超文本传送协议 HTTP</h3> <h4 id="1http-的操作过程">（1）HTTP 的操作过程</h4> <p>HTTP 协议定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP 是<strong>面向事务的</strong>（transaction-oriented）应用层协议，它是万维网上能够可靠地交换文件的重要基础。万维网的大致工作过程如图 6-9 所示。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/how-the-World-Wide-Web-works-480.webp 480w,/assets/images/computer-network/how-the-World-Wide-Web-works-800.webp 800w,/assets/images/computer-network/how-the-World-Wide-Web-works-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/how-the-World-Wide-Web-works.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="万维网的工作过程" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 6-9 万维网的工作过程 </div> <p>HTTP 使用面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。HTTP 不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP 协议<strong>本身是无连接的</strong>。这就是说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立 HTTP 连接。</p> <p>HTTP 协议是<strong>无状态的</strong>（stateless）。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同（假定现在服务器还没有把该页面更新），因为服务器并不记得曾经访问过的这个客户，也不记得为该客户曾经服务过多少次。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的 HTTP 请求。</p> <p>用户在点击鼠标链接某个万维网文档时，HTTP 协议首先要和服务器建立 TCP 连接。这需要使用三报文握手。当建立 TCP 连接的三报文握手的前两部分完成后（即经过了一个 RTT 时间后），万维网客户就把 HTTP 请求报文，作为建立 TCP 连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到 HTTP 请求报文后，就把所请求的文档作为响应报文返回给客户。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-time-required-to-request-a-World-Wide-Web-document-480.webp 480w,/assets/images/computer-network/the-time-required-to-request-a-World-Wide-Web-document-800.webp 800w,/assets/images/computer-network/the-time-required-to-request-a-World-Wide-Web-document-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-time-required-to-request-a-World-Wide-Web-document.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="请求一个万维网文档所需的时间" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 6-10 请求一个万维网文档所需的时间 </div> <p>从图 6-10 可看出，请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上两倍往返时间 RTT（一个 RTT 用于连接 TCP 连接，另一个RTT 用于请求和接收万维网文档。TCP 建立连接的三报文握手的第三个报文段中的数据，就是客户对万维网文档的请求报文）。</p> <ul> <li>HTTP/1.0 的主要缺点，是每请求一个文档就要有两倍 <code class="language-plaintext highlighter-rouge">RTT</code> 的开销。若一个主页上有很多链接的对象（如图片等）需要依次进行链接，那么每次链接下载都导致 <code class="language-plaintext highlighter-rouge">2 × RTT</code> 的开销。</li> <li>另一种开销就是万维网客户和服务器每次建立新的 TCP 连接都要分配缓存和变量。特别是万维网服务器往往要同时服务于大量客户的请求，所以这种<strong>非持续连接</strong>会使万维网服务器的负担很重。</li> </ul> <p>HTTP/1.1 协议较好地解决了这个问题，它使用<strong>持续连接</strong>（persistent connection）。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。目前一些流行的浏览器的默认设置就使用了 HTTP/1.1。</p> <p>HTTP/1。1 协议的持续连接有两种工作方式，即<strong>非流水线方式</strong>（without pipelining）和<strong>流水线方式</strong>（with pipelining）。</p> <ul> <li>非流水线方式的特点，是客户在收到前一个响应后才能发出下一个请求。因此，在 TCP 连接已建立后，客户每访问一次对象都要用去一个往返时间 <code class="language-plaintext highlighter-rouge">RTT</code>。这比非持续连接要用去两倍 <code class="language-plaintext highlighter-rouge">RTT</code> 的开销，节省了建立 TCP 连接所需的一个 <code class="language-plaintext highlighter-rouge">RTT</code> 时间。但非流水线方式还是有缺点的，因为服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</li> <li>流水线方式的特点，是客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用流水线方式时，客户访问所有的对象只需花费一个 <code class="language-plaintext highlighter-rouge">RTT</code> 时间。流水线工作方式使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li> </ul> <h4 id="2代理服务器">（2）代理服务器</h4> <p><strong>代理服务器</strong>（proxy server）是一种网络实体，它又称为<strong>万维网高速缓存</strong>（Web cache）。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器端工作，也可在中间系统上工作。</p> <p>设图 6-11（a）是校园网不使用代理服务器的情况。这时，校园网中所有的计算机都通过 2Mbit/s 专线链路（\(R_1 - R_2\)）与互联网上的源点服务器建立 TCP 连接。因而校园网各计算机访问互联网的通信量往往会使这条 2 Mbit/s 的链路过载，使得时延大大增加。</p> <p>图 6-11（b）是校园网使用代理服务器的情况。这时，访问互联网的过程是这样的：</p> <ol> <li>校园网的计算机中的浏览器向互联网的服务器请求服务时，就先和校园网的代理服务器建立 TCP 连接，并向代理服务器发出 HTTP 请求报文（见图 6-11（b）中的 ❶）。</li> <li>若代理服务器已经存放了所请求的对象，代理服务器就把这个对象放入 HTTP 响应报文中返回给计算机的浏览器。</li> <li>否则，代理服务器就代表发出请求的用户浏览器，与互联网上的<strong>源点服务器</strong>（origin server）建立 TCP 连接（如图 6-11（b）中的 ❷ 所示），并发送 HTTP 请求报文。</li> <li>源点服务器把所请求的对象放在 HTTP 响应报文中返回给校园网的代理服务器。</li> <li>代理服务器收到这个对象后，先复制在自己的本地存储器中（留待以后用），然后再把这个对象放在 HTTP 响应报文中，通过已建立的 TCP 连接（见图 6-11（b）中的 ❶），返回给请求该对象的浏览器。</li> </ol> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/function-of-proxy-server-480.webp 480w,/assets/images/computer-network/function-of-proxy-server-800.webp 800w,/assets/images/computer-network/function-of-proxy-server-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/function-of-proxy-server.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="代理服务器的作用" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 6-11 代理服务器的作用 </div> <p>代理服务器有时是作为服务器（当接受浏览器的 HTTP 请求时），有时是作为客户（当向互联网上的源点服务器发送 HTTP 请求时）。在使用代理服务器的情况下，由于有相当大一部分通信量局限在校园网的内部，因此，2 Mbit/s 专线链路（\(R_1 - R_2\)）上的通信量大大减少，因而减小了访问互联网的时延。</p> <h4 id="3http-的报文结构">（3）HTTP 的报文结构</h4> <p>HTTP 有两类报文：</p> <ul> <li>请求报文——从客户向服务器发送请求报文，见图 6-12（a）。</li> <li>响应报文——从服务器到客户的回答，见图 6-12（b）。</li> </ul> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/HTTP-packet-structure-480.webp 480w,/assets/images/computer-network/HTTP-packet-structure-800.webp 800w,/assets/images/computer-network/HTTP-packet-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/HTTP-packet-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP 的报文结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 6-12 HTTP 的报文结构 </div> <p>由于 HTTP 是<strong>面向文本的</strong>（text-oriented），因此在报文中的每个字段都是一些 ASCII 码串，因而各个字段的长度都是不确定的。 HTTP 请求报文和响应报文都由三个部分组成，这两种报文格式的区别是开始行不同。</p> <ul> <li><strong>开始行</strong>，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做<strong>请求行</strong>（Request-Line），而在响应报文中的开始行叫做<strong>状态行</strong>（Status-Line）。在开始行的三个字段之间都以空格分隔开，最后的 “CR” 和 “LF” 分别代表“回车”和“换行”。</li> <li><strong>首部行</strong>，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每个首部行中都有首部字段名和它的值，每行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</li> <li><strong>实体主体</strong>，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</li> </ul> <p>请求报文的第一行“请求行”只有三个内容，即方法、请求资源的 URL、HTTP 的版本。所谓“方法”就是对所请求的对象进行的操作，这些方法实际上也就是一些命令。因此，请求报文的类型是由它所采用的方法决定的。表 6-1 给出了请求报文中常用的几种方法。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/some-methods-of-HTTP-request-messages-480.webp 480w,/assets/images/computer-network/some-methods-of-HTTP-request-messages-800.webp 800w,/assets/images/computer-network/some-methods-of-HTTP-request-messages-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/some-methods-of-HTTP-request-messages.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP请求报文的一些方法" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 6-1 HTTP请求报文的一些方法 </div> <p>响应报文的第一行是状态行。状态行包括三项内容，即HTTP 的版本，状态码，以及解释状态码的简单短语。 <strong>状态码</strong>（Status-Code）都是三位数字的，分为 5 大类，这 5 大类的状态码都是以不同的数字开头的。</p> <ul> <li><strong>1xx</strong> 表示通知信息，如请求收到了或正在进行处理。</li> <li><strong>2xx</strong> 表示成功，如接受或知道了。</li> <li><strong>3xx</strong> 表示重定向，如要完成请求还必须采取进一步的行动。</li> <li><strong>4xx</strong> 表示客户的差错，如请求中有错误的语法或不能完成。</li> <li><strong>5xx</strong> 表示服务器的差错，如服务器失效无法完成请求。</li> </ul> <h4 id="4在服务器上存放用户的信息">（4）在服务器上存放用户的信息</h4> <p>HTTP 是无状态的，但在实际工作中，却常常希望能够识别用户。要做到这点，可以在 HTTP 中使用 Cookie。</p> <p>Cookie 是这样工作的。当用户 <code class="language-plaintext highlighter-rouge">A</code> 浏览某个使用 Cookie 的网站时，该网站的服务器就为 <code class="language-plaintext highlighter-rouge">A</code> 产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目。接着在给 <code class="language-plaintext highlighter-rouge">A</code> 的 HTTP 响应报文中添加一个叫做 <code class="language-plaintext highlighter-rouge">Set-cookie</code> 的首部行。例如这个首部行是这样的：</p> \[Set-cookie: 31d4d96e407aad42\] <p>当 <code class="language-plaintext highlighter-rouge">A</code> 收到这个响应时，其浏览器就在它管理的特定 Cookie 文件中添加一行，其中包括这个服务器的主机名和 <code class="language-plaintext highlighter-rouge">Set-cookie</code> 后面给出的识别码。当 <code class="language-plaintext highlighter-rouge">A</code> 继续浏览这个网站时，每发送一个 HTTP 请求报文，其浏览器就会从其 Cookie 文件中取出这个网站的识别码，并放到 HTTP 请求报文的 Cookie 首部行中：</p> \[Cookie: 31d4d96e407aad42\] <p>于是，这个网站就能够跟踪用戶 <code class="language-plaintext highlighter-rouge">31d4d96e407aad42</code>（用户 <code class="language-plaintext highlighter-rouge">A</code>）在该网站的活动。</p> <h3 id="44-万维网的文档">4.4 万维网的文档</h3> <h4 id="1超文本标记语言-html">（1）超文本标记语言 HTML</h4> <p>要使任何一台计算机都能显示出任何一个万维网服务器上的页面，就必须解决页面制 作的标准化问题。超文本标记语言 HTML （HyperText Markup Language）就是一种制作万维 网页面的标准语言，它消除了不同计算机之间信息交流的障碍。但请注意，HTML 并不是 应用层的协议，它只是万维网浏览器使用的一种语言。由于 HTML 非常易于掌握且实施简 单，因此它很快就成为万维网的重要基础[RFC 2854]。官方的 HTML 标准由万维网联盟 W3C（即WWW Consortium）负责制定。有关 HTML 的一些参考资料见[W-HTML]。从 HTML 在 1993 年问世后，就不断地对其版本进行更新。现在最新的版本是 HTML 5。0 （2014 年 9 月发布），新的版本增加了在网页中嵌入音频、视频以及交互式文档等功能。现 在一些主流的浏览器都支持HTML 5。0。 HTML 定义了许多用于排版的命令，即“标签”（tag）。例如，<i>表示后面开始用斜体 字排版，而</i>则表示斜体字排版到此结束。HTML 把各种标签嵌入到万维网的页面中，这 样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器（例如， Windows 的记事本 Notepad）创建的ASCII 码文件。但应注意，仅当 HTML 文档是以。html 或。htm 为后缀时，浏览器才对这样的 HTML 文档的各种标签进行解释。如果 HTML 文档 改为以。txt 为其后缀，则 HTML 解释程序就不对标签进行解释，而浏览器只能看见原来的文 本文件。 并非所有的浏览器都支持所有的 HTML 标签。若某一个浏览器不支持某一个 HTML 标 签，则浏览器将忽略此标签，但在一对不能识别的标签之间的文本仍然会被显示出来。 下面是一个简单例子，用来说明 HTML 文档中标签的用法。在每一个语句后面的花括 号中的字是给读者看的注释，在实际的 HTML 文档中并没有这种注释。</p> <html> <head> <TITLE>一个 HTML 的例子</TITLE> </head> <body> <h1>HTML 很容易掌握</h1> <p>这是第一个段落。</p> {HTML 文档开始} {首部开始} {“一个 HTML 的例子”是文档的标题} {首部结束} {主体开始} {“HTML 很容易掌握”是主体的1级题头} {<p>和</p>之间的文字是一个段落} <p>这是第二个段落。</p> </body> </html> <p>{&lt;P&gt;和&lt;/P&gt;之间的文字是一个段落} {主体结束} {HTML 文档结束} 把上面的 HTML 文档存入D盘的文件夹 HTML 中，文件名是HTML-example。html（注 意：实际的文档中没有注释部分）。当浏览器读取了该文档后，就按照 HTML 文档中的各种 标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并显示出来。图 6-13 表示 IE 浏览器在计算机屏幕上显示出的与该文档有关部分的画面。文档的标题（title）“一个 HTML 的例子”显示在浏览器最上面的标题栏中。文件的路径显示在地址栏中。再下面就 是文档的主体部分。主体部分的题头（heading），即文档主体部分的标题“HTML 很容易掌 握”，用较大的字号显示出来，因为在标签中指明了使用的是1级题头&lt;H1&gt;。 目前已开发出了很好的制作万维网页面的软件工具，使我们能够像使用 Word 文字处理 器那样很方便地制作各种页面。即使我们用 Word 文字处理器编辑了一个文件，但只要在 “另存为（Save As）”时选取文件后缀为。htm 或。html，就可以很方便地把 Word 的。doc 格式文 件转换为浏览器可以显示的HTML 格式的文档。 a 个HTML的例子 icrosoft Internet Explorer 文件（z） 编辑（g） 查看收款（a） 工具） 帮助 Q 地址（ ep1。html D：\HTML\HTHL-ex HTML很容易掌握 这是第一个段落、 这是第二个段落。 图6-13 在屏幕上显示的HTML 文档主体部分的例子</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>HTML 允许在万维网页面中插入图像。一个页面本身带有的图像称为内含图像（inline image）。HTML 标准并没有规定该图像的格式。实际上，大多数浏览器都支持 GIF 和 JPEG 文件。很多格式的图像占据的存储空间太大，因而这种图像在互联网传送时就很浪费时间。 例如，一幅位图文件（。bmp）可能要占用 500 ~ 700 KB 的存储空间。但若将此图像改存为经压 缩的 。gif 格式，则可能只有十几个千字节，大大减少了存储空间。 HTML 还规定了链接的设置方法。我们知道每个链接都有一个起点和终点。链接的起 点说明在万维网页面中的什么地方可引出一个链接。在一个页面中，链接的起点可以是一个 字或几个字，或是一幅图，或是一段文字。在浏览器所显示的页面上，链接的起点是很容易 识别的。在以文字作为链接的起点时，这些文字往往用不同的颜色显示（例如，一般的文字 用黑色字时，链接起点往往使用蓝色字），甚至还会加上下划线（一般由浏览器来设置）。当 我们将鼠标移动到一个链接的起点时，表示鼠标位置的箭头就变成了一只手。这时只要点击 鼠标，这个链接就被激活。</p> <p>链接的终点可以是其他网站上的页面。这种链接方式叫做远程链接。这时必须在 HTML 文档中指明链接到的网站的URL。有时链接可以指向本计算机中的某一个文件或本 文件中的某处，这叫做本地链接。这时必须在HTML 文档中指明链接的路径。 实际上，现在这种链接方式已经不局限于用在万维网文档中。在最常用的 Word 文字处 理器的工具栏中，也设有“插入超链接”的按钮。只要点击这个按钮，就可以看到设置超链 接的窗口。用户可以很方便地在自己写的 Word 文档中设置各种链接的起点和终点。 在这一小节的最后，我们还要简单介绍一下和浏览器有关的几种其他语言。 XML （Extensible Markup Language）是可扩展标记语言，它和 HTML 很相似。但 XML 的设计宗旨是传输数据，而不是显示数据（HTML 是为了在浏览器上显示数据）。更具体 些，XML 用于标记电子文件，使其具有结构性的标记语言，可用来标记数据、定义数据类 型，是一种允许用户对自己的标记语言进行定义的源语言。XML 是一种简单、与平台无关 并被广泛采用的标准。XML 相对于 HTML 的优点是它将用户界面与结构化数据分隔开 来。这种数据与显示的分离使得集成来自不同源的数据成为可能。客户信息、订单、研究结 果、账单付款、病历、目录数据及其他信息都可以转换为 XML。XML 不是要替换 HTML，而是对 HTML 的补充。XML 标记由文档的作者定义，并且是无限制的。HTML 标记则是预定义的；HTML 作者只能使用当前 HTML 标准所支持的标记。 另一种语言 XHTML （Extensible HTML）是可扩展超文本标记语言，它与HTML 4。01 几 乎是相同的。但XHTML 是更严格的HTML 版本，也是一个W3C标准（2000年1月制 定），是作为一种 XML 应用被重新定义的HTML，并将逐渐取代HTML。所有新的浏览器 都支持 XHTML。 还有一种语言 CSS （Cascading Style Sheets）是层叠样式表，它是一种样式表语言，用于 为HTML 文档定义布局。CSS 与HTML 的区别就是：HTML 用于结构化内容，而 CSS 则 用于格式化结构化的内容。例如，在浏览器上显示的字体、颜色、边距、高度、宽度、背景 图像等方面，都能够给出精确的规定。现在所有的浏览器都支持 CSS。</p> <h4 id="2动态万维网文档">（2）动态万维网文档</h4> <p>上面所讨论的万维网文档只是万维网文档中最基本的一种，即所谓的静态文档（static document）。静态文档在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程 中，内容不会改变。由于这种文档的内容不会改变，因此用户对静态文档的每次读取所得到 的返回结果都是相同的。 静态文档的最大优点是简单。由于 HTML 是一种排版语言，因此静态文档可以由不懂 程序设计的人员来创建。但静态文档的缺点是不够灵活。当信息变化时就要由文档的作者手 工对文档进行修改。可见，变化频繁的文档不适于做成静态文档。 动态文档（dynamic document）是指文档的内容是在浏览器访问万维网服务器时才由应用 程序动态创建的。当浏览器请求到达时，万维网服务器要运行另一个应用程序，并把控制转 移到此应用程序。接着，该应用程序对浏览器发来的数据进行处理，并输出 HTTP 格式的文 档，万维网服务器把应用程序的输出作为对浏览器的响应。由于对浏览器每次请求的响应都 是临时生成的，因此用户通过动态文档所看到的内容是不断变化的。动态文档的主要优点是 具有报告当前最新信息的能力。例如，动态文档可用来报告股市行情、天气预报或民航售票 情况等内容。但动态文档的创建难度比静态文档的高，因为动态文档的开发不是直接编写文</p> <p>档本身，而是编写用于生成文档的应用程序，这就要求动态文档的开发人员必须会编程，而 所编写的程序还要通过大范围的测试，以保证输入的有效性。 动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方 法不同。而从浏览器的角度看，这两种文档并没有区别。动态文档和静态文档的内容都遵循 HTML 所规定的格式，浏览器仅根据在屏幕上看到的内容无法判定服务器送来的是哪一种 文档，只有文档的开发者才知道。 从以上所述可以看出，要实现动态文档就必须在以下两个方面对万维网服务器的功能 进行扩充： （1）应增加另一个应用程序，用来处理浏览器发来的数据，并创建动态文档。 （2）应增加一个机制，用来使万维网服务器将浏览器发来的数据传送给这个应用程序， 然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。 图 6-14 是扩充了功能的万维网服务器的示意图。这里增加了一个机制，叫做通用网关 接口 CGI （Common Gateway Interface）。CGI 是一种标准，它定义了动态文档应如何创建， 输入数据应如何提供给应用程序，以及输出结果应如何使用。 在万维网服务器中新增加的应用程序叫做 CGI 程序。取这个名字的原因是：万维网服 务器与 CGI 的通信遵循 CGI 标准。“通用”是因为这个标准所定义的规则对其他任何语言都 是通用的。“网关”二字的出现是因为 CGI程序还可能访问其他的服务器资源，如数据库或 图形软件包，因而 CGI程序的作用有点像一个网关。也有人将 CGI 程序简称为网关程序。 “接口”是因为有一些已定义好的变量和调用等可供其他 CGI 程序使用。请读者注意：在 看到 CGI 这个名词时，应弄清是指CGI 标准，还是指CGI程序。 万维网 万维网服务器 客户端 浏览器 互联网 ·程序 服务器 程序 数据库 HTTP CGD ② CGI 程序创建动态文档 ● 请求文档 HTTP请求报文 ● 响应动态 文档 HTTP 响应报文 图6-14 扩充了功能的万维网服务器</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>CGI 程序的正式名字是 CGI 脚本（script）。按照计算机科学的一般概念，“脚本”指的 是一个程序，它被另一个程序（解释程序）而不是计算机的处理机来解释或执行。有一些语 言专门作为脚本语言（script language），如 Perl， REXX（在IBM 主机上使用），JavaScript 以 及 Tcl/Tk等。脚本也可用一些常用的编程语言写出，如C，C++等。使用脚本语言可更容易 和更快地进行编码，这对一些有限功能的小程序是很合适的。但一个脚本运行起来比一般的</p> <p>编译程序要慢，因为它的每一条指令先要被另一个程序来处理（这就要一些附加的指令）， 而不是直接被指令处理器来处理。脚本不一定是一个独立的程序，它可以是一个动态装入的 库，甚至是服务器的一个子程序。 CGI 程序又称为 cgi-bin 脚本，这是因为在许多万维网服务器上，为便于找到 CGI 程 序，就将 CGI 程序放在/cgi-bin 的目录下。</p> <h4 id="3活动万维网文档">（3）活动万维网文档</h4> <p>随着 HTTP 和万维网浏览器的发展，上一节所述的动态文档已明显地不能满足发展的 需要。这是因为，动态文档一旦建立，它所包含的信息内容也就固定下来而无法及时刷新屏 幕。另外，像动画之类的显示效果，动态文档也无法提供。 有两种技术可用于浏览器屏幕显示的连续更新。一种技术称为服务器推送（server push），这种技术是将所有的工作都交给服务器。服务器不断地运行与动态文档相关联的应 用程序，定期更新信息，并发送更新过的文档。 尽管从用户的角度看，这样做可达到连续更新的目的，但这也有很大的缺点。首先， 为了满足很多客户的请求，服务器就要运行很多服务器推送程序。这将造成过多的服务器开 销。其次，服务器推送技术要求服务器为每一个浏览器客户维持一个不释放的 TCP 连接。 随着 TCP 连接的数目增加，每一个连接所能分配到的网络带宽就下降，这就导致网络传输 时延的增大。 另一种提供屏幕连续更新的技术是活动文档（active document）。这种技术是把所有的工 作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段活动文档程序副 本，使该程序副本在浏览器端运行。这时，活动文档程序可与用户直接交互，并可连续地改 变屏幕的显示。只要用户运行活动文档程序，活动文档的内容就可以连续地改变。由于活动 文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。 从传送的角度看，浏览器和服务器都把活动文档看成是静态文档。在服务器上的活动 文档的内容是不变的，这点和动态文档是不同的。浏览器可在本地缓存一份活动文档的副 本。活动文档还可处理成压缩形式，以便于存储和传送。另一点要注意的是，活动文档本身 并不包括其运行所需的全部软件，大部分的支持软件是事先存放在浏览器中的。图 6-15 说 明了活动文档的创建过程。 • 278 • 万维网 客户端 万维网服务器 浏览器 程序 互联网 服务器 程序 ● 请求文档 ● 此程序在 客户端创建 出活动文档 =D 文档 HTTP HTTP请求报文 HTTP响应报文 程序 ② 响应程序 程序| 程序事先被编译 图6-15 活动文档由服务器发送过来的程序在客户端创建</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>成二进制代码， 存放为文件</p> <p>由美国 SUN 公司开发的 Java 语言是一项用于创建和运行活动文档的技术。在 Java 技 术中使用了一个新的名词“小应用程序”（applet）来描述活动文档程序。当用户从万维网服 务器下载一个嵌入了Java 小应用程序的 HTML 文档后，用户可在浏览器的显示屏幕上点击 某个图像，然后就可看到动画的效果；或是在某个下拉式菜单中点击某个项目，即可看到根 据用户键入的数据所得到的计算结果。实际上，Java技术是活动文档技术的一部分。限于 篇幅，有关 Java技术的进一步讨论这里从略。</p> <h3 id="45-万维网的信息检索系统">4.5 万维网的信息检索系统</h3> <h4 id="1全文检索搜索与分类目录搜索">（1）全文检索搜索与分类目录搜索</h4> <p>万维网是一个大规模的、联机式的信息储藏所。那么，应当采用什么方法才能找到所 需的信息呢？如果已经知道存放该信息的网点，那么只要在浏览器的地址（Location）框内键 入该网点的 URL 并按回车键，就可进入该网点。但是，若不知道要找的信息在何网点，那 就要使用万维网的搜索工具。 在万维网中用来进行搜索的工具叫做搜索引擎（search engine）。搜索引擎的种类很多， 但大体上可划分为两大类，即全文检索搜索引擎和分类目录搜索引擎。 全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件（例如 一种叫做“蜘蛛”或“网络机器人”的 Spider 程序）到互联网上的各网站收集信息，找到 一个网站后可以从这个网站再链接到另一个网站，像蜘蛛爬行一样。然后按照一定的规则建 立一个很大的在线索引数据库供用户查询。用户在查询时只要输入关键词，就从已经建立的 索引数据库里进行查询（并不是实时地在互联网上检索到的信息）。因此很可能有些查到的 信息已经是过时的（例如很多年前的）。建立这种索引数据库的网站必须定期对已建立的数 据库进行更新维护（但不少网站的维护很不及时，因此对查找到的信息-定要注意其发布的 时间）。现在全球最大的并且最受欢迎的全文检索搜索引擎就是谷歌 Google （www。google。com）。谷歌提供的主要的搜索服务有：网页搜索、图片搜索、视频搜索、地图 搜索、新闻搜索、购物搜索、博客搜索、论坛搜索、学术搜索、财经搜索等。应全球用户的 需求，谷歌在美国及世界各地创建数据中心。至2013年底，谷歌的数据中心在全球共设有 12 处。大多数数据中心的业主基于信息安全考虑，极少透露其数据中心的信息及內部情 形。 我们将在下一小节简单介绍谷歌搜索技术的特点。现在“谷歌”不仅是网站名，而且 还是动词。例如，“谷歌一下”的意思就是“用谷歌网站进行信息搜索”。在全文检索搜索引 擎中另外两个著名的网站是美国微软的必应（cn。bing。com）和中国的百度（www。baidu。com）。 分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交网站信 息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条 件，则输入到分类目录的数据库中，供网上用户查询。因此，分类目录搜索也叫做分类网站 搜索。分类目录的好处就是用户可根据网站设计好的目录有针对性地逐级查询所需要的信</p> <p>息，查询时不需要使用关键词，只需要按照分类（先找大类，再找下面的小类），因而查询 的准确性较好。但分类目录查询的结果并不是具体的页面，而是被收录网站主页的 URL 地 址，因而所得到的内容就比较有限。相比之下，全文检索可以检索出大量的信息（一次检索 的结果是几百万条，甚至是千万条以上），但缺点是查询结果不够准确，往往是罗列出了海 量的信息（如上千万个页面），使用户无法迅速找到所需的信息。在分类目录搜索引擎中最 著名的就是雅虎（www。yahoo。com）。国内著名的分类搜索引擎有雅虎中国（cn。yahoo。com）、新 浪（sina。com。cn）、搜狐（www。sohu。com）、网易（www。163。com）等。 图 6-16 说明了上述这两种搜索方法的区别。图 6-16（a）是全文搜索谷歌的首页。用户只 需在空白的栏目中键入拟搜索的关键词，搜索引擎就返回搜索结果，用户可根据屏幕上显示 的结果继续点击下去，直到看到满意的结果。图 6-16（b）是分类检索新浪网的首页。我们可 以看到页面上有三行共 63 个类别。用户要检索的内容通常总是在这几十个类别之中，因此 按类别点击查找下去，最后就可以查找到所要检索的内容。 Google ↓ （a）全文检索举例 sina sina。com。cn Siha新浪网 微博 大家正在竣：攜眷高格调喝法 南京 15°C 核心价值观： 网站举报APP下载 O 燒烤网络空间 維护网民权益 新闻 军事 社会 国际 财经 股票 基金 期货 科技 手机探索外汇 体育 NBA 中超 奥运 娱乐 明星 电影 座 汽车 报价 买车 秒车 博客 专栏 文史天气 视频 综艺 航拍 直播 房产 二手房家居 收藏 时间 女性健康 育儿 教育 高考 公益 佛学 圖片 读书 情感 法院 城市 鲜城 旅游 航空 游戏 页游 手游 SHOW 江苏 English 彩票高尔夫 微博 邮箱 更多 √ （b）分类检索举例 图6-16 举例说明两种检索的区别</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>从用户的角度看，使用这两种不同的搜索引擎一般都能够实现自己查询信息的目的。 为了使用户能够更加方便地搜索到有用信息，目前许多网站往往同时具有全文检索搜索和分 类目录搜索的功能。在互联网上搜索信息需要经验的积累。要多实践才能掌握从互联网获取 信息的技巧。 这里再强调一下，不管哪种搜索引擎，就是告诉你只要链接到什么地方就可以检索到 所需的信息。搜索引擎网站本身并没有直接存储这些信息。 值得注意的是，目前出现了垂直搜索引擎（Vertical Search Engine），它针对某一特定领 域、特定人群或某一特定需求提供搜索服务。垂直搜索也是提供关键字来进行搜索的，但被 放到了一个行业知识的上下文中，返回的结果更倾向于信息、消息、条目等。例如，对买房 的人讲，他希望查找的是房子的具体供求信息（如面积、地点、价格等），而不是有关房子 供求的一般性的论文或新闻、政策等。目前热门的垂直搜索行业有：购物、旅游、汽车、求 职、房产、交友等。还有一种元搜索引擎（Meta Search Engine），它把用户提交的检索请求 发送到多个独立的搜索引擎上去搜索，并把检索结果集中统一处理，以统一的格式提供 给用户，因此是搜索引擎之上的搜索引擎。它的主要精力放在提高搜索速度、智能化处 理搜索结果、个性化搜索功能的设置和用户检索界面的友好性上。元搜索引擎的查全率 和查准率都比较高。</p> <h4 id="2google-搜索技术的特点">（2）Google 搜索技术的特点</h4> <p>Google 的搜索引擎性能优良，因为它使用了先进的硬件和软件。以往的大多数的搜索 引擎是使用少量大型服务器。在访问高峰期，搜索的速度就会明显减慢。Google 则利用在 互联网上相互链接的计算机来快速查找每个搜索的答案，并且成功地缩短了查找的相应时 间。Google 的搜索软件可同时进行许多运算，它的核心技术就是 PageRank™，译为网页排 名。 PageRank 对搜索出来的结果按重要性进行排序，这是 Google 的两个创始人 Larry Page 和 Sergey Brin 共同开发出来的[W-GOOGLE]。由于用户在有限的时间内，不可能阅读全部 的搜索结果（因为数量往往非常大），而通常仅仅是查阅一下前几个（或前几十个）项目。 因此用户希望检索结果能够按重要性来排序。但怎样确定某个页面的重要性呢？传统的搜索 引擎往往是检查关键字在网页上出现的频率。PageRank 技术则把整个互联网当作了一个整 体对待，检查整个网络链接的结构，并确定哪些网页重要性最高。更具体些，就是如果有很 多网站上的链接都指向页面 A，那么页面 A 就比较重要。PageRank 对链接的数目进行加权 统计。对来自重要网站的链接，其权重也较大。统计链接数目的问题是一个二维矩阵相乘的 问题，从理论上讲，这种二维矩阵的元素数是网页数目的平方。对于1亿个网页，这个矩阵 就有1亿亿个元素。这样大的矩阵相乘，计算量是非常大的。Larry Page 和 Sergey Brin 两人 利用稀疏矩阵计算的技巧，大大地简化了计算量。他们用迭代的方法解决了这个问题。他们 先假定所有网页的排名是相同的，并且根据此初始值，算出各个网页的第一次迭代排名，再 根据第一次迭代排名算出第二次的排名。他们从理论上证明了不论初始值如何选取，这种算 法都保证了网页排名的估计值能收敛到排名的真实值。这种算法是完全没有任何人工干预 的，厂商不可能用金钱购买网页的排名。Google 还要进行超文本匹配分析，以确定哪些网 页与正在执行的特定搜索相关。在综合考虑整体重要性以及与特定查询的相关性之后， Google 就把最相关、最可靠的搜索结果放在首位。 然而有一些著名网站通过“竞价排名”把虚假广告信息放在检索结果的首位，结果误 导了消费者，使受骗者蒙受很大的损失。因此对网络搜索的结果，我们应认真分析其真伪， 提高辨别能力，不要随意轻信网络检索的广告信息（哪怕是知名度很高的网站）。</p> <h3 id="46-博客和微博">4.6 博客和微博</h3> <p>近年来，万维网的一些新的应用广为流行，这就是博客和微博。下面进行简单的介绍。</p> <h4 id="1博客">（1）博客</h4> <p>我们知道，建立网站就是万维网的一种应用。博客（blog）和网站有很相似的地方。博客 的作者可以源源不断地往万维网上的个人博客里填充内容，供其他网民阅读。网民可以用浏 览器上网阅读博客、发表评论，也可以什么都不做。 博客是万维网日志（weblog）的简称。也有人把 blog 进行音译，译为“部落格”，或“部 落阁”。还有人用“博文”来表示“博客文章”。 本来，网络日志是指个人撰写并在互联网上发布的、属于网络共享的个人日记。但现 在它不仅可以是个人日记，而且可以有无数的形式和大小，也没有任何实际的规则。 现在博客已经极大地扩充了互联网的应用和影响，成为了所有网民都可以参与的一种 新媒体，并使得无数的网民有了发言权，有了与政府、机构、企业，以及很多人交流的机</p> <p>会。在博客出现以前，网民是互联网上内容的消费者，网民在互联网上搜寻并下载感兴趣的 信息。这些信息是其他人生产的，他们把这些信息放在互联网的某个服务器上，供广大网民 使用（也就是供网民消费）。但博客改变了这种情况，网民不仅是互联网上内容的消费者， 而且还是互联网上内容的生产者。 从历史上看，weblog 这个新词是 Jorn Barger 于1997 年创造的。简写的 blog（这是今 天最常用的术语）则是 Peter Merholz 于1999年创造的。不久，有人把blog 既当作名词，也 当作动词，表示编辑博客或写博客。接着，新名词 blogger 也出现了，它表示博客的拥有 者，或博客内容的撰写者和维护者，或博客用户。博客可以看成是继电子邮件、电子公告牌 系统 BBS 和即时传信 IM （Instant Messaging）之后的第四种网络交流方式。 现在从一些著名的门户网站的主页上都能很容易地进入到博客页面，这让用户查看博 客或发表自己的博客都非常方便。前面的图 6-16（b）所示的新浪网站首页， 就可看到在几十 个分类中的第1行第9列的“博客”。 当我们在新浪网站主页点击“博客”时，就可以看到各式各样的博客。也可以利用搜 索工具寻找所需的博客。如果我们已在新浪博客注册了，那么也可随时把自己的博客发表在 此，让别人来阅读。我们还可直接登录新浪博客网站 blog。sina。com。cn。 博客与个人网站还是有不少区别的。这里最主要的区别就是建立个人网站成本较高， 需要租用个人空间、域名等，同时建立网站的个人需要懂得 HTML 语言和网页制作等相关 技术；但博客在这方面是不需要什么投资的，所需的技术仅仅是会上网和会用键盘或书写板 输入汉字即可。因此网民用较短的时间就能够把自己写的博客发表在网上，而不像制作个人 网站那样花费较多的时间。正因为写博客的门槛较低，广大的网民才有可能成为今天互联网 上的信息制造者。 顺便提一下，不要把“博客”和“播客”弄混。播客（Podcast）是苹果手机的一个预装软 件，能够让用户通过手机订阅和自动下载所预订的音乐文件，以便随时欣赏音乐。</p> <h4 id="2微博">（2）微博</h4> <p>在图 6-16（b）新浪网站首页各种分类的第1行的最后，可以找到“微博”。微博就是微型 博客（microblog），又称为微博客，它的意思已经非常清楚。博客或微博里的朋友，常称为 “博友”。微博也被人戏称为“围脖”，把博友戏称为“脖友”。 但微博不同于一般的博客。微博只记录片段、碎语，三言两语，现场记录，发发感 慨，晒晒心情，永远只针对一个问题进行回答。微博只是记录自己琐碎的生活，呈现给人 看，而且必须很真实。微博中不必有太多的逻辑思维，很随便，很自由，有点像电影中的一 个镜头。写微博比写其他东西简单多了，不需要标题，不需要段落，更不需要漂亮的词汇。 2009 年是中国微博蓬勃发展的一年，相继出现了新浪微博、139说客、9911、嘀咕网、 同学网、贫嘴等微博客。例如，新浪微博就是由中国最大的门户网站新浪网推出的微博服 务，是中国目前用户数最多的微博网站（weibo。com），名人用户众多是新浪微博的一大特 色，基本已经覆盖大部分知名文体明星、企业高管、媒体人士。用户可以通过网页、WAP 网、手机短信彩信、手机客户端等多种方式更新自己的微博。每条微博字数最初限制为 140</p> <p>英文字符，但现在已增加了“长微博”的选项， 可输入更多的字符。微博还提供插入图片、 视频、音乐等功能。根据统计，从2010年3月到2012年3月共两年的时间，新浪微博的覆 盖人数从 2510。9 万增长到 3 亿人，而其中 90%的用户认为微博改变了他们与媒体接触的方 式。 现在不少地方政府也开通了微博（即政务微博），这是信息公开的表现。政府可以通过 政务微博，及时公布政情、公务、资讯等，获取与民众更多、更直接、更快的沟通，特别是 在突发事件或者群体性事件发生的时候，微博就能够成为政府新闻发布的一种重要手段。 虽然政务微博具有“传递信息、沟通上下、解决问题”的功能性特点，并受到广大网 民的欢迎，但政务微博的日常管理也非常重要。如果政务微博因缺乏良好的管理而不能够满 足群众的各种需求，那么它就会成为一种无用的摆设。 微博是一种互动及传播性极快的工具，其实时性、现场感及快捷性，往往超过所有媒 体。这是因为微博对用户的技术要求门槛非常低，而且在语言的编排组织上，没有博客那么 高。另外，微博开通的多种API 使大量的用户可通过手机、网络等方式来即时更新自己的 个人信息。微博网站的即时传信功能非常强大，可以通过QQ和MSN直接书写。 我们正处在一个急剧变革的时代，人们需要用贯穿不同社会阶层的信息去了解社会、 改变生活。在互联网上微博的出现正好满足了广大网民的需求。微博发布、转发信息的功能 很强大，这种一个人的“通讯社”将对整个社会产生越来越大的影响。</p> <h3 id="47-社交网站">4.7 社交网站</h3> <p>社交网站 SNS （Social Networking Site）是近年来发展非常迅速的一种网站，其作用是为 一群拥有相同兴趣与活动的人创建在线社区。社交网站的功能非常丰富，如电子邮件、即时 传信（在线聊天）、博客撰写、共享相册、上传视频、网页游戏、创建社团、刊登广告等， 对现实社交结构已经形成了巨大冲击。社交网络服务提供商针对不同的群众，有着不同的定 位，对个人消费者都是免费的。这种网站通过朋友，一传十，十传百地把联系范围不断扩大 下去。前面曾提到过的BBS和微博，可以看作是社交网站的前身。 2004 年社交网站脸书（Facebook，又名面书、脸谱、脸谱网）在美国诞生。脸书最初的用 户定位是大学生，但现在它的用户范围已经扩大了很多。接着社交网站热潮席卷全球，而国内 以人人网、开心网等为代表的社交网站也如雨后春笋般迅速崛起。社交网站极大地丰富了人 们的社交生活，孕育了新的经济增长点，其所蕴含的巨大商业价值和社会力量也正凸显出来。 毫无疑问，目前世界上排名第一且分布最广的社交网站是脸书。脸书最大的特点就是 可以非常方便地寻找朋友或联系老同学、老同事，能够简易地在朋友圈中分享图片、视频和 音频文件（现在也可以发送其他文件，如。docx， xlsx 等），以及通过集成的地图功能分享用 户所在的位置。现在脸书的月度活跃用户已达11。5亿人之多，其中半数以上为移动电话用 户。在 2010年3月，脸书在美国的访问人数已超过谷歌，成为全美访问量最大的网站。脸 书的官网域名为 Facebook。com，并持有。cn 域名 Facebook。cn。排名第二的社交网站是视频分 享网站 YouTube，其月度活跃用户人数为10亿人。2006年 YouTube。com 网站被谷歌收购， 目前谷歌手上持有了 youtube。com/。com。cn/。net/。org 等域名。国内类似的视频分享网站有优酷 （www。youku。com）、土豆（movie。tudou。com）、56网（56。com）等。 另一种能够提供微博服务的社交网络现在也很流行。例如推特 Twitter （twitter。com） 网 站创建于 2006 年，它可以让用户发表不超过140个英文字符的消息。这些消息也被称为</p> <p>“推文”（Tweet）。我国的新浪微博（www。weibo。com）、腾讯微博（t。qq。com）等就是这种性质的 社交网站。职业性社交网站领英LinkedIn 也是很受欢迎的网站。 目前在我国最为流行的社交网站就是微信（weixin。qq。com）。微信最初是专为手机用户使 用的聊天工具，其功能是“收发信息、拍照分享、联系朋友”。但几年来经过多次系统更 新，现在微信不仅可传送文字短信、图片、录音电话、视频短片，还可提供实时音频或视频 聊天，甚至可进行网上购物、转账、打车，等等。原来微信仅限于在手机上使用，但新的微 信版本已能够安装在普通电脑上。现在微信的功能已远远超越了社交领域。我们知道，电子 邮件可以发送给网上任何一个并不认识你的用户，也不管他是否愿意接收你发送的邮件。各 种博客和微博也可供任何上网用户浏览。但微信只能在确定的朋友圈中交换信息。正是由于 朋友之间更加需要交换信息，而微信的功能又不断在扩展，因此微信在我国已成为几乎每个 网民都使用的应用软件。</p> <h2 id="五电子邮件">五、电子邮件</h2> <h3 id="51-电子邮件概述">5.1 电子邮件概述</h3> <p>大家知道，实时通信的电话有两个严重缺点。第一，电话通信的主叫和被叫双方必须 同时在场。第二，有些电话常常不必要地打断被叫者的工作或休息。 电子邮件（e-mail）是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件 发送到收件人使用的邮件服务器，并放在其中的收件人邮箱（mail box）中，收件人可在自己 方便时上网到自己使用的邮件服务器进行读取。这相当于互联网为用户设立了存放邮件的信 箱，因此 e-mail 有时也称为“电子信箱”。电子邮件不仅使用方便，而且还具有传递迅速和 费用低廉的优点。据有的公司报道，使用电子邮件后可提高劳动生产率 30%以上。现在电 子邮件不仅可传送文字信息，而且还可附上声音和图像。由于电子邮件和手机的广泛使用， 现已迫使传统的电报业务退出市场，因为这种传统电报既贵又慢，且很不方便。 1982 年 ARPANET 的电子邮件问世后，很快就成为最受广大网民欢迎的互联网应用。 电子邮件的两个最重要的标准就是：简单邮件传送协议SMTP（Simple Mail Transfer Protocol） [RFC 5321]和互联网文本报文格式[RFC 5322]。 由于互联网的 SMTP 只能传送可打印的7位ASCII 码邮件，因此在 1993 年又提出了通 用互联网邮件扩充 MIME （Multipurpose Internet Mail Extensions）。MIME 在其邮件首部中说 明了邮件的数据类型（如文本、声音、图像、视像等）。在 MIME 邮件中可同时传送多种类 型的数据。这在多媒体通信的环境下是非常有用的。 一个电子邮件系统应具有图 6-17 所示的三个主要组成构件，这就是用户代理、邮件服 务器，以及邮件发送协议（如 SMTP）和邮件读取协议（如POP3）。POP3 是邮局协议（Post Office Protocol）的版本3。凡是有TCP 连接的，都经过了互联网，有的甚至可以跨越数千公 里的距离。这里为简洁起见，没有画出网络。在互联网中，邮件服务器的数量是很大的。正 是这些邮件服务器构成了电子邮件基础结构的核心。在图6-17 中为了说明问题，仅仅画出 了两个邮件服务器。</p> <p>发件人 用户代理 发送方 接收方 发送邮件服务器 邮件服务器 邮件 SMTP SMTP SMTP POP3 读取 邮件 POP3 收件人 用户代理 POP3 客戶 TCP （服务器） 服务器 TCP 客戶 连接 连接 SMTP 发送邮件 SMTP /SMTP™ 客戶 TCP 连接 服务器 用户邮箱 （读取邮件） 发送方 （发送邮件） SMTP POP3 （发送邮件）SMTP 接收方 用户代理 邮件缓存 发送方 邮件服务器 互联网 接收方 邮件服务器 用户代理 图6-17 电子邮件的最主要的组成构件</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>用户代理 UA （User Agent）就是用户与电子邮件系统的接口，在大多数情况下它就是运 行在用户电脑中的一个程序。因此用户代理又称为电子邮件客户端软件。用户代理向用户提 供一个很友好的接口（目前主要是窗口界面）来发送和接收邮件。现在可供大家选择的用户 代理有很多种。例如，微软公司的Outlook Express 和我国张小龙制作的Foxmail，都是很受 欢迎的电子邮件用户代理。 用户代理至少应当具有以下4个功能。 （1）撰写。给用户提供编辑信件的环境。例如，应让用户能创建便于使用的通讯录（有 常用的人名和地址）。回信时不仅能很方便地从来信中提取出对方地址，并自动地将此地址 写入到邮件中合适的位置，而且还能方便地对来信提出的问题进行答复（系统自动将来信复 制一份在用户撰写回信的窗口中，因而用户不需要再输入来信中的问题）。 （2） 显示。能方便地在计算机屏幕上显示出来信（包括来信附上的声音和图像）。 （3）处理。处理包括发送邮件和接收邮件。收件人应能根据情况按不同方式对来信进行 处理。例如，阅读后删除、存盘、打印、转发等，以及自建目录对来信进行分类保存。有时 还可在读取信件之前先查看一下邮件的发件人和长度等，对于不愿收的信件可直接在邮箱中 删除。 （4） 通信。发信人在撰写完邮件后，要利用邮件发送协议发送到用户所使用的邮件服务 收件人在接收邮件时，要使用邮件读取协议从本地邮件服务器接收邮件。 互联网上有许多邮件服务器可供用户选用（有些要收取少量的邮箱费用）。邮件服务器 24 小时不间断地工作，并且具有很大容量的邮件信箱。邮件服务器的功能是发送和接收邮 件，同时还要向发件人报告邮件传送的结果（已交付、被拒绝、丢失等）。邮件服务器按照 客户服务器方式工作。邮件服务器需要使用两种不同的协议。一种协议用于用户代理向邮件 服务器发送邮件或在邮件服务器之间发送邮件，如 SMTP 协议，而另一种协议用于用户代 理从邮件服务器读取邮件，如邮局协议 POP3。 这里应当注意，邮件服务器必须能够同时充当客户和服务器。例如，当邮件服务器 A</p> <p>向另一个邮件服务器B发送邮件时，A 就作为 SMTP 客户，而 B 是 SMTP 服务器。反之， 当 B 向 A 发送邮件时，B 就是 SMTP 客户，而A 就是 SMTP 服务器。 图 6-17 给出了计算机之间发送和接收电子邮件的几个重要步骤。请注意，SMTP 和 POP3（或 IMAP）都是使用TCP连接来传送邮件的，使用TCP 的目的是为了可靠地传送 邮件。 发件人调用计算机中的用户代理撰写和编辑要发送的邮件。 • 发件人点击屏幕上的“发送邮件”按钮，把发送邮件的工作全都交给用户代理来完 成。用户代理把邮件用 SMTP 协议发给发送方邮件服务器，用户代理充当 SMTP 客户，而 发送方邮件服务器充当 SMTP 服务器。用户代理所进行的这些工作，用户是看不到的。有 的用户代理可以让用户在屏幕上看见邮件发送的进度显示。用户所使用的邮件服务器究竟在 什么地方，用户并不知道，也不必要知道。实际上，用户在把写好的信件交付给用户代理 后，就什么都不用管了。 ● SMTP 服务器收到用户代理发来的邮件后，就把邮件临时存放在邮件缓存队列中， 等待发送到接收方的邮件服务器（等待时间的长短取决于邮件服务器的处理能力和队列中待 发送的信件的数量。但这种等待时间一般都远远大于分组在路由器中等待转发的排队时 间）。 ● 发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP 服务器建立TCP连 接，然后就把邮件缓存队列中的邮件依次发送出去。请注意，邮件不会在互联网中的某个中 间邮件服务器落地。如果SMTP客户还有一些邮件要发送到同一个邮件服务器，那么可以 在原来已建立的TCP连接上重复发送。如果SMTP客户无法和SMTP服务器建立TCP连接 （例如，接收方服务器过负荷或出了故障），那么要发送的邮件就会继续保存在发送方的邮 件服务器中，并在稍后一段时间再进行新的尝试。如果SMTP客户超过了规定的时间还不 能把邮件发送出去，那么发送邮件服务器就把这种情况通知用户代理。 ● 运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的 用户邮箱中，等待收件人进行读取。 • 收件人在打算收信时，就运行计算机中的用户代理，使用POP3（或IMAP）协议读 取发送给自己的邮件。请注意，在图6-17中，POP3 服务器和 POP3 客户之间的箭头表示的 是邮件传送的方向。但它们之间的通信是由POP3客户发起的。 请注意这里有两种不同的通信方式。一种是“推”（push）： SMTP 客户把邮件“推”给 SMTP 服务器。另一种是“拉”（pull）：POP3 客户把邮件从 POP3 服务器“拉”过来。细心 的读者可能会想到这样的问题：如果让图 6-17 中的邮件服务器程序就在发送和接收方的 计算机中运行，那么岂不是可以直接把邮件发送到收件人的计算机中？ 答案是“不行”。这是因为并非所有的计算机都能运行邮件服务器程序。有些计算机可能 没有足够的存储空间来运行允许程序在后台运行的操作系统，或是可能没有足够的 CPU 能 力来运行邮件服务器程序。更重要的是，邮件服务器程序必须不间断地运行，每天24 小时 都必须不间断地连接在互联网上，否则就可能使很多外面发来的邮件无法接收。这样看来， 让用户的计算机运行邮件服务器程序显然是很不现实的（一般用户在不使用计算机时就将机 器关闭）。让来信暂时存储在用户的邮件服务器中，而当用户方便时就从邮件服务器的用户 信箱中读取来信，则是一种比较合理的做法。在 Foxmail 中使用一种“特快专递”服务。这 种服务就是从发件人的用户代理直接利用 SMTP 把邮件发送到接收方邮件服务器。这就加</p> <p>快了邮件的交付（省去在发送邮件服务器中的排队等待时间）。但这种“特快专递”和邮 政的 EMS 直接把邮件送到用户家中不同，它并没有把邮件直接发送到收件人的计算机中。 但有些邮件服务器为了防止垃圾邮件和计算机病毒，拒绝接收从一般用户直接发来的邮件。 电子邮件由信封（envelope）和内容（content）两部分组成。电子邮件的传输程序根据邮件信 封上的信息来传送邮件。这与邮局按照信封上的信息投递信件是相似的。 在邮件的信封上，最重要的就是收件人的地址。TCP/IP体系的电子邮件系统规定电子 邮件地址（e-mail address）的格式如下： 用户名 @ 邮件服务器的域名 （6-1） 在上式中，符号“@”读作“at”，表示“在”的意思。例如，在电子邮件地址 “xyz@abc。com”中，“abc。com”就是邮件服务器的域名，而“xyz”就是在这个邮件服务 器中收件人的用户名，也就是收件人邮箱名，是收件人为自己定义的字符串标识符。但应注 意，这个用户名在邮件服务器中必须是唯一的（当用户定义自己的用户名时，邮件服务器要 负责检查该用户名在本服务器中的唯一性）。这样就保证了每一个电子邮件地址在世界范围 内是唯一的。这对保证电子邮件能够在整个互联网范围内的准确交付是十分重要的。电子邮 件的用户一般采用容易记忆的字符串。</p> <h3 id="52-简单邮件传送协议-smtp">5.2 简单邮件传送协议 SMTP</h3> <p>下面介绍 SMTP的一些主要特点。 SMTP 规定了在两个相互通信的 SMTP 进程之间应如何交换信息。由于SMTP 使用客 户服务器方式，因此负责发送邮件的SMTP 进程就是SMTP客户，而负责接收邮件的 SMTP 进程就是SMTP服务器。至于邮件内部的格式，邮件如何存储，以及邮件系统应以多 快的速度来发送邮件，SMTP也都未做出规定。 SMTP 规定了 14条命令和21种应答信息。每条命令用几个字母组成，而每一种应答信 息一般只有一行信息，由一个3位数字的代码开始，后面附上（也可不附上）很简单的文字 说明。下面通过发送和接收方的邮件服务器之间的 SMTP 通信的三个阶段介绍几个最主 要的命令和响应信息。</p> <h4 id="1连接建立">（1）连接建立</h4> <p>发件人的邮件送到发送方邮件服务器的邮件缓存后，SMTP 客户就每隔一定时间（例如 30分钟）对邮件缓存扫描一次。如发现有邮件，就使用SMTP 的熟知端口号码 25 与接收方 邮件服务器的 SMTP 服务器建立 TCP 连接。在连接建立后，接收方 SMTP 服务器要发出 “220 Service ready”（服务就绪）。然后 SMTP 客户向SMTP 服务器发送HELO命令，附上 发送方的主机名。SMTP 服务器若有能力接收邮件，则回答：“250 OK”，表示已准备好接 收。若 SMTP 服务器不可用，则回答“421 Service not available”（服务不可用）。 如在一定时间内（例如三天）发送不了邮件，邮件服务器会把这个情况通知发件人。 SMTP 不使用中间的邮件服务器。不管发送和接收方的邮件服务器相隔有多远，不管 在邮件传送过程中要经过多少个路由器，TCP 连接总是在发送和接收方这两个邮件服务 器之间直接建立。当接收方邮件服务器出故障而不能工作时，发送方邮件服务器只能等待一 段时间后再尝试和该邮件服务器建立 TCP 连接，而不能先找一个中间的邮件服务器建立</p> <p>TCP 连接。</p> <h4 id="2邮件传送">（2）邮件传送</h4> <p>邮件的传送从 MAIL 命令开始。MAIL 命令后面有发件人的地址。如：MAIL FROM： &lt;xiexiren@tsinghua。org。cn&gt;。若 SMTP 服务器已准备好接收邮件，则回答“250 OK”。否 则，返回一个代码，指出原因。如：451（处理时出错），452 （存储空间不够），500 （命令 无法识别）等。 下面跟着一个或多个 RCPT 命令，取决于把同一个邮件发送给一个或多个收件人，其 格式为 RCPT TO：<收件人地址>。RCPT 是 recipient（收件人）的缩写。每发送一个 RCPT 命令，都应当有相应的信息从 SMTP 服务器返回，如：“250 OK”，表示指明的邮箱在接收 方的系统中，或“550 No such user here”（无此用户），即不存在此邮箱。 RCPT 命令的作用就是：先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮 件。这样做是为了避免浪费通信资源，不至于发送了很长的邮件以后才知道地址错误。 再下面就是 DATA 命令，表示要开始传送邮件的内容了。SMTP 服务器返回的信息是： “354 Start mail input； end with <CRLF>。<CRLF>”。这里<CRLF>是“回车换行”的意思。若 不能接收邮件，则返回421（服务器不可用），500（命令无法识别）等。接着 SMTP 客户就 发送邮件的内容。发送完毕后，再发送<CRLF>。<CRLF>（两个回车换行中间用一个点隔 开）表示邮件内容结束。实际上在服务器端看到的可打印字符只是一个英文的句点。若邮件 收到了，则 SMTP 服务器返回信息“250 OK”，或返回差错代码。 虽然 SMTP 使用TCP连接试图使邮件的传送可靠，但“发送成功”并不等于“收件人 读取了这个邮件”。当一个邮件传送到接收方的邮件服务器后（即接收方的邮件服务器收下 了这个邮件），再往后的情况如何，就有好几种可能性。接收方的邮件服务器也可能接着就 出了故障，使收到的邮件全部丢失（在收件人读取信件之前）。也可能被邮件服务器的软件 当作垃圾邮件删除了。也可能收件人在清理自己的邮箱时，把尚未读取的邮件一起都删除 了。有时收件人由于某种原因，很久没有查阅自己的邮箱，根本不知道自己的邮箱中有一些 来信。因此，一个邮件即使是“发送成功”，收件人也不一定会读取到这个邮件。尽管如 此，基于 SMTP 的电子邮件通常都被认为是可靠的。 3。 连接释放 邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是“221 （服务关闭）”，表示SMTP 同意释放 TCP 连接。邮件传送的全部过程即结束。 这里再强调一下，使用电子邮件的用户看不见以上这些过程，所有这些复杂过程都被 电子邮件的用户代理屏蔽了。 已经广泛使用多年的 SMTP 存在着一些缺点。例如，发送电子邮件不需要经过鉴别。 这就是说，在 FROM 命令后面的地址可以任意填写。这就大大方便了垃圾邮件的作者，给 收信人添加了麻烦（有人估计，在全世界所有的电子邮件中，垃圾邮件至少占到 50%以 上，甚至高达 90%）。又如，SMTP 本来就是为传送 ASCII 码而不是传送二进制数据设计 的。虽然后来有了 MIME 可以传送二进制数据（见后面 6。5。6 节的介绍），但在传送非 ASCII 码的长报文时，在网络上的传输效率是不高的。此外，SMTP 传送的邮件是明文，不 利于保密。</CRLF></CRLF></CRLF></CRLF></CRLF></收件人地址></p> <p>为了解决上述问题，2008 年 10 月颁布的 RFC 5321 对 SMTP 进行了扩充，成为扩充的 SMTP （Extended SMTP），记为ESMTP。RFC 5321 在许多命令中增加了扩展的参数。新增加 的功能有：客户端的鉴别，服务器接受二进制报文，服务器接受分块传送的大报文，发送前 先检查报文的大小，使用安全传输 TLS（见下一章 7。6。2 节），以及使用国际化地址等。考 虑到现在的许多 SMTP 邮件服务器可能还没有升级到 ESMTP，因此特规定使用 ESMTP 的 客户端在准备传送报文时，不是发送 HLLO 而是发送 EHLO 报文。如果 EHLO 报文被对方 服务器端拒绝，就表明对方仍然是一个标准的 SMTP 邮件服务器（不使用扩展的参数），因 而就要按照原来使用的SMTP 参数进行邮件的传送。如果 EHLO 报文被接受了，那么客户 端就可以使用 ESMTP扩展的参数传送报文了。</p> <h3 id="53-电子邮件的信息格式">5.3 电子邮件的信息格式</h3> <p>一个电子邮件分为信封和内容两大部分。在 RFC 5322 文档中只规定了邮件内容中的首 部（header）格式，而对邮件的主体（body）部分则让用户自由撰写。用户写好首部后，邮件系统 自动地将信封所需的信息提取出来并写在信封上。所以用户不需要填写电子邮件信封上的信 息。 邮件内容首部包括一些关键字，后面加上冒号。最重要的关键字是：To 和 Subject。 “To：”后面填入一个或多个收件人的电子邮件地址。在电子邮件软件中，用户把经常 通信的对象姓名和电子邮件地址写到地址簿（address book）中。当撰写邮件时，只需打开地址 簿，点击收件人名字，收件人的电子邮件地址就会自动地填入到合适的位置上。 “ Subject： ”是邮件的主题。它反映了邮件的主要内容。主题类似于文件系统的文件 名，便于用户查找邮件。 邮件首部还有一项是抄送“Cc：”。这两个字符来自“Carbon copy”，意思是留下一个 “复写副本”。这是借用旧的名词，表示应给某某人发送一个邮件副本。 有些邮件系统允许用户使用关键字 Bcc （Blind carbon copy）来实现盲复写副本。这是使 发件人能将邮件的副本送给某人，但不希望此事为收件人知道。Bcc 又称为暗送。 首部关键字还有“From”和“Date”，表示发件人的电子邮件地址和发信日期。这两项 一般都由邮件系统自动填入。 另一个关键字是“Reply-To”，即对方回信所用的地址。这个地址可以与发件人发信时 所用的地址不同。例如有时到外地借用他人的邮箱给自己的朋友发送邮件，但仍希望对方将 回信发送到自己的邮箱。这一项可以事先设置好，不需要在每次写信时进行设置。</p> <h3 id="54-邮件读取协议-pop3-和-imap">5.4 邮件读取协议 POP3 和 IMAP</h3> <p>现在常用的邮件读取协议有两个，即邮局协议第 3 个版本 POP3 和网际报文存取协议 IMAP （Internet Message Access Protocol）。现分别讨论如下。 邮局协议 POP 是一个非常简单，但功能有限的邮件读取协议。邮局协议 POP 最初公布 于1984年。经过几次更新，现在使用的是1996年的版本POP3 [RFC 1939]，它已成为互联 网的正式标准。大多数的ISP 都支持 POP3。 POP3 也使用客户服务器的工作方式。在接收邮件的用户计算机中的用户代理必须运行 POP3 客户程序，而在收件人所连接的ISP的邮件服务器中则运行 POP3 服务器程序。当 然，这个 ISP 的邮件服务器还必须运行 SMTP 服务器程序，以便接收发送邮件服务器的</p> <p>SMTP 客户程序发来的邮件。这些请参阅图 6-17。POP3 服务器只有在用户输入鉴别信息 （用户名和口令）后，才允许对邮箱进行读取。 POP3 协议的一个特点就是只要用户从 POP3 服务器读取了邮件，POP3 服务器就把该 邮件删除。这在某些情况下就不够方便。例如，某用户在办公室的台式计算机上接收了一个 邮件，还来不及写回信，就马上携带笔记本电脑出差。当他打开笔记本电脑写回信时， POP3 服务器上却已经删除了原来已经看过的邮件（除非他事先将这些邮件复制到笔记本电 脑中）。为了解决这一问题，POP3 进行了一些功能扩充，其中包括让用户能够事先设置 邮件读取后仍然在POP3 服务器中存放的时间[RFC 2449]。目前 RFC 2449 是互联网建议 标准。 另一个读取邮件的协议是网际报文存取协议 IMAP，它比 POP3 复杂得多。IMAP 和 POP 都按客户服务器方式工作，但它们有很大的差别。现在较新的版本是2003年3月修订 的版本 4，即 IMAP4 [RFC 3501]，它目前也是互联网的建议标准。不过在习惯上，对这个 协议大家很少加上版本号“4”，而经常简单地用IMAP表示IMAP4。但是对 POP3 却不会 忘记写上版本号“3”。 在使用 IMAP 时，在用户的计算机上运行 IMAP 客户程序，然后与接收方的邮件服务 器上的 IMAP 服务器程序建立TCP连接。用户在自己的计算机上就可以操纵邮件服务器的 邮箱，就像在本地操纵一样，因此 IMAP 是一个联机协议。当用户计算机上的IMAP 客户程 序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该 邮件才传到用户的计算机上。用户可以根据需要为自己的邮箱创建便于分类管理的层次式的 邮箱文件夹，并且能够将存放的邮件从某一个文件夹中移动到另一个文件夹中。用户也可按 某种条件对邮件进行查找。在用户未发出删除邮件的命令之前，IMAP 服务器邮箱中的邮件 一直保存着。 IMAP 最大的好处就是用户可以在不同的地方使用不同的计算机（例如，使用办公室的 计算机、或家中的计算机，或在外地使用笔记本电脑）随时上网阅读和处理自己在邮件服务 器中的邮件。IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像 附件（此文件可能很大）的邮件，而用户使用的是无线上网，信道的传输速率很低。为了节 省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很大的附件。 IMAP 的缺点是如果用户没有将邮件复制到自己的计算机上，则邮件一直存放在 IMAP 服务器上。要想查阅自己的邮件，必须先上网。 下面的表 6-2 给出了 IMAP 和 POP3 的主要功能的比较。 表 6-2 IMAP 和POP3的主要功能比较 操作位置 操作内容 IMAP 收件箱 发件箱 阅读、标记、移动、删除邮件等 保存到已发送 创建文件夹 草稿 新建自定义的文件夹 保存草稿 垃圾文件夹 接收并移入垃圾文件夹的邮件 客户端与邮箱更新同步 客户端与邮箱更新同步 客户端与邮箱更新同步 客户端与邮箱更新同步 支持 POP3 仅在客户端内 仅在客户端内 仅在客户端内 仅在客户端内 不支持 广告邮件 接收并移入广告邮件夹的邮件 支持 不支持 最后再强调一下，不要把邮件读取协议 POP3 或IMAP 与邮件传送协议 SMTP 弄混。发</p> <p>件人的用户代理向发送方邮件服务器发送邮件，以及发送方邮件服务器向接收方邮件服务器 发送邮件，都是使用 SMTP 协议。而POP3 或IMAP则是用户代理从接收方邮件服务器上读 取邮件所使用的协议。</p> <h3 id="55-基于万维网的电子邮件">5.5 基于万维网的电子邮件</h3> <p>从前面的图 6-17 可看出，用户要使用电子邮件，必须在自己使用的计算机中安装用户 代理软件 UA。如果外出到某地而又未携带自己的笔记本电脑，那么要使用别人的计算机进 行电子邮件的收发，将是非常不方便的。 现在这个问题解决了。在20 世纪 90 年代中期，Hotmail 推出了基于万维网的电子邮件 （Webmail）。今天，几乎所有的著名网站以及大学或公司，都提供了万维网电子邮件。常用 的万维网电子邮件有谷歌的 Gmail，微软的 Hotmail，雅虎的 Yahoo! Mail。我国的网易 （163 或126）和新浪（sina）等互联网技术公司也都提供万维网邮件服务。 万维网电子邮件的好处就是：不管在什么地方（在任何一个国家的网吧、宾馆或朋友 家中），只要能够找到上网的计算机，在打开任何一种浏览器后，就可以非常方便地收发电 子邮件。使用万维网电子邮件不需要在计算机中再安装用户代理软件。浏览器本身可以向用 户提供非常友好的电子邮件界面（和原来的用户代理提供的界面相似），使用户在浏览器上 就能够很方便地撰写和收发电子邮件。 例如，你使用的是网易163邮箱，那么在任何一个浏览器的地址栏中，键入 163邮 箱的 URL （mail。163。com），按回车键后，就可以使用163 电子邮件了，这和在家中一样 方便。你曾经接收和发送过的邮件，已删除的邮件以及你的通讯录等内容，都照常呈现在屏 幕上。 我们知道，用户在浏览器中浏览各种信息时需要使用HTTP 协议。因此，在浏览器和 互联网上的邮件服务器之间传送邮件时，仍然使用HTTP协议。但是在各邮件服务器之间传 送邮件时，则仍然使用SMTP协议。</p> <h3 id="56-通用互联网邮件扩充mime">5.6 通用互联网邮件扩充MIME</h3> <h4 id="1mime-概述">（1）MIME 概述</h4> <p>前面所述的电子邮件协议 SMTP 有以下缺点： （1） SMTP 不能传送可执行文件或其他的二进制对象。人们曾试图将二进制文件转换为 SMTP 使用的 ASCII 文本，例如流行的 UNIX_UUencode/UUdecode 方案，但这些均未形成 正式标准或事实上的标准。 （2） SMTP 限于传送7位的ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚 至带重音符号的法文或德文）就无法传送。即使在 SMTP 网关将 EBCDIC 码（即扩充的二/ 十进制交换码）转换为ASCII码，也会遇到一些麻烦。 （3） SMTP 服务器会拒绝超过一定长度的邮件。 （4） 某些 SMTP 的实现并没有完全按照SMTP 的互联网标准。常见的问题如下： 回车、换行的删除和增加； 超过 76 个字符时的处理：截断或自动换行； 后面多余空格的删除；</p> <p>• 将制表符 tab 转换为若干个空格。 于是在这种情况下就提出了通用互联网邮件扩充 MIME [RFC 2045~2049]。MIME并 没有改动或取代 SMTP。MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结 构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程 序和协议下传送。图6-18表示MIME 和 SMTP 的关系。 用户 用户 非 ASCII码 MIME 非 ASCII码 MIME | 7位ASCII码 7位ASCII码 7位ASCII码 SMTP SMTP 图6-18 MIME 和 SMTP 的关系</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>MIME 主要包括以下三部分内容： （1） 5 个新的邮件首部字段，它们可包含在原来的邮件首部中。这些字段提供了有关邮 件主体的信息。 （2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。 （3）定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。 为适应于任意数据类型和表示，每个MIME 报文包含告知收件人数据类型和使用编码 的信息。MIME 把增加的信息加入到原来的邮件首部中。 下面是 MIME 增加的5个新的邮件首部的名称及其意义（有的可以是选项）。 （1） MIME-Version： 标志 MIME 的版本。现在的版本号是1。0。若无此行，则为英文文 本。 （2） Content-Description：这是可读字符串，说明此邮件主体是否是图像、音频或视频。 （3） Content-Id：邮件的唯一标识符。 （4） Content-Transfer-Encoding： 在传送时邮件的主体是如何编码的。 （5） Content-Type： 说明邮件主体的数据类型和子类型。 上述的前三项的意思很清楚，因此下面只对后两项进行介绍。</p> <h4 id="2内容传送编码">（2）内容传送编码</h4> <p>下面介绍三种常用的内容传送编码 （Content-Transfer-Encoding）。 最简单的编码就是7位ASCII 码，而每行不能超过1000个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。 另一种编码称为quoted-printable，这种编码方法适用于所传送的数据中只有少量的非 ASCII 码，例如汉字。这种编码方法的要点就是对于所有可打印的ASCII 码，除特殊字符等 号“=”外，都不改变。等号“=”和不可打印的 ASCII 码以及非 ASCII 码的数据的编码方 法是：先将每个字节的二进制代码用两个十六进制数字表示，然后在前面再加上一个等号 “=”。例如，汉字的“系统”的二进制编码是：11001111 10110101 11001101 10110011（共 有 32 位，但这四个字节都不是 ASCII 码），其十六进制数字表示为：CFB5CDB3。用 quoted-printable 编码表示为：=CF=B5=CD=B3，这12个字符都是可打印的ASCII 字符，它 •</p> <p>们的二进制编码需要96位，和原来的32位相比，开销达200%。而等号“=”的二进制代 码为 00111101，即十六进制的 3D，因此等号“=”的quoted-printable 编码为“=3D”。 对于任意的二进制文件，可用 base64 编码。这种编码方法是先把二进制代码划分为一 个个 24 位长的单元，然后把每一个24位单元划分为4个6位组。每一个6位组按以下方法 转换成 ASCII 码。6位的二进制代码共有 64 种不同的值，从0到63。用 A 表示 0，用 B 表 示1，等等。26个大写字母排列完毕后，接下去再排26个小写字母，再后面是10个数字， 最后用“+”表示 62，而用“/”表示63。再用两个连在一起的等号“= ”和一个等号 “=”分别表示最后一组的代码只有 8 位或 16 位。回车和换行都忽略，它们可在任何地方 插入。 下面是一个 base64编码的例子： 24位二进制代码 划分为4个6位组 对应的 base64编码 用 ASCII编码发送 01001001 00110001 01111001 010010 010011 000101 111001 S T F 5 01010011 01010100 01000110 00110101 不难看出，24 位的二进制代码采用 base64编码后变成了32位，开销为25%。</p> <h4 id="3内容类型">（3）内容类型</h4> <p>MIME 标准规定 Content-Type 说明必须含有两个标识符，即内容类型（type）和子类型 （subtype），中间用“/”分开。 MIME 标准原先定义了7个基本内容类型和15种子类型（见RFC 1521，但这个文档已 被列入“陈旧的”）。除了内容类型和子类型，MIME 允许发件人和收件人自己定义专用的内 容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串 X-开始。但是，后来陆续出现了几百个子类型，而且子类型的数目还在不断地增加。现在 可以在网站上查出现有的MIME类型和子类型的名称，以及申请新的子类型的具体步骤[W- MEDIA-TYPE]。表6-3 列出了MIME的内容类型、子类型举例及其说明®。 表6-3 可出现在 MIME Content-Type 说明中的类型及子类型举例 内容类型 子类型举例 text（文本） |plain， html， xml， css image（图像） audio （音频） | gif， jpeg， tiff | basic， mpeg， mp4 video （视频） | mpeg， mp4， quicktime 说明 | 不同格式的文本 | 不同格式的静止图像 可听见的声音 不同格式的影片</p> <p>续表 内容类型 子类型举例 说明 | model （模型） vrml | 3D模型 不同应用程序产生的数据 （ message （报文） | multipart（多部分） | 封装的报文 多种类型的组合 | application（应用） | octet-stream， pdf， javascript， zip |http， rfc822 | mixed， alternative， parallel， digest MIME 的内容类型中的 multipart 是很有用的，因为它使邮件增加了相当大的灵活性。 MIME 标准为 multipart 定义了四种可能的子类型，每个子类型都提供重要功能。 （1） mixed 子类型允许单个报文含有多个相互独立的子报文，每个子报文可有自己的类 型和编码。mixed 子类型报文使用户能够在单个报文中附上文本、图形和声音，或者用额外 数据段发送一个备忘录，类似商业信笺含有的附件。在 mixed 后面还要用到一个关键字，即 Boundary=，此关键字定义了分隔报文各部分所用的字符串（由邮件系统定义），只要在邮 件的内容中不会出现这样的字符串即可。当某一行以两个连字符“–”开始，后面紧跟上述 的字符串，就表示下面开始了另一个子报文。 （2） alternative 子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件和 软件系统的收件人发送备忘录时，这种类型的 multipart 报文很有用。例如，用户可同时用 普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在查看 图形时选择格式化的形式。 （3） parallel 子类型允许单个报文含有可同时显示的各个子部分（例如，图像和声音子部 分必须一起播放）。 （4） digest 子类型允许单个报文含有一组其他报文（如从讨论中收集电子邮件报文）。 下面显示了一个 MIME 邮件，它包含有一个简单解释的文本和含有非文本信息的照 片。邮件中第一部分的注解说明第二部分含有一张照片。 From： xiexiren@tsinghua。org。cn To： xyz@163。com MIME-Version： 1。0 Content-Type： multipart/mixed； boundary=qwertyuiop –qwertyuiop XYZ： 你要的图片在此邮件中，收到后请回信。 –qwertyuiop Content-Type： image/gif Content-Transfer-Encoding： base64 。。。data for the image （图像的数据）。。。 –qwertyuiop– 谢希仁 上面最后一行表示 boundary 的字符串后面还有两个连字符“–”，表示整个multipart 的 结束。</p> <h2 id="六动态主机配置协议-dhcp">六、动态主机配置协议 DHCP</h2> <p>为了把协议软件做成通用的和便于移植的，协议软件的编写者不会把所有的细节都固 定在源代码中。相反，他们把协议软件参数化。这就使得在很多台计算机上有可能使用同一 个经过编译的二进制代码。一台计算机和另一台计算机的许多区别，都可以通过一些不同的 参数来体现。在协议软件运行之前，必须给每一个参数赋值。 在协议软件中给这些参数赋值的动作叫做协议配置。一个协议软件在使用之前必须是 已正确配置的。具体的配置信息有哪些则取决于协议栈。例如，连接到互联网的计算机的协 议软件需要配置的项目包括： （1） IP 地址； （2） 子网掩码； （3） 默认路由器的IP 地址； （4）域名服务器的IP 地址。 为了省去给计算机配置 IP 地址的麻烦，我们能否在计算机的生产过程中，事先给每一 台计算机配置好一个唯一的 IP 地址呢（如同每一个以太网适配器拥有一个唯一的硬件地 址）？这显然是不行的。这是因为 IP 地址不仅包括了主机号，而且还包括了网络号。一个 IP 地址指出了一台计算机连接在哪一个网络上。当计算机还在生产时，无法知道它在出厂 后将被连接到哪一个网络上。因此，需要连接到互联网的计算机，必须对IP地址等项目进 行协议配置。 用人工进行协议配置很不方便，而且容易出错。因此，应当采用自动协议配置的方法。 互联网现在广泛使用的是动态主机配置协议 DHCP （Dynamic Host Configuration Protocol），它提供了一种机制，称为即插即用连网（plug-and-play networking）。这种机制允许 一台计算机加入新的网络和获取 IP 地址而不用手工参与。DHCP 最新的 RFC 文档是 1997 年的 RFC 2131 和 RFC 2132，目前还是互联网草案标准。 DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一 个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。DHCP 给运行服务器 软件而位置固定的计算机指派一个永久地址，而当这计算机重新启动时其地址不改变。 DHCP 使用客户服务器方式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送 发现报文（DHCPDISCOVER）（将目的IP地址置为全1，即255。255。255。255），这时该主机 就成为 DHCP 客户。发送广播报文是因为现在还不知道 DHCP 服务器在什么地方，因此要 发现（DISCOVER）DHCP 服务器的IP地址。这台主机目前还没有自己的IP 地址，因此它 将 IP 数据报的源 IP 地址设为全0。这样，在本地网络上的所有主机都能够收到这个广播报 文，但只有 DHCP 服务器才对此广播报文进行回答。DHCP服务器先在其数据库中查找该 计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 （address pool）中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文 （DHCPOFFER），表示“提供”了IP地址等配置信息。 但是我们并不愿意在每一个网络上都设置一个 DHCP 服务器，因为这样会使 DHCP 服 务器的数量太多。因此现在是使每一个网络至少有一个 DHCP 中继代理（relay agent）（通常 是一台路由器，见图 6-19），它配置了 DHCP 服务器的IP地址信息。当 DHCP 中继代理收 到主机 A 以广播形式发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等</p> <p>待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再把此提供报文发回给 主机 A。需要注意的是，图6-19 只是个示意图。实际上，DHCP 报文只是 UDP 用户数据报 的数据，它还要加上 UDP 首部、IP数据报首部，以及以太网的 MAC 帧的首部和尾部后， 才能在链路上传送。 主机A 广播 DHCPDISCOVER 单播 DHCPDISCOVER 其他网络 DHCP 服务器 DHCP 中继代理 图6-19 DHCP 中继代理以单播方式转发发现报文 DHCP 服务器分配给 DHCP 客户的IP地址是临时的，因此 DHCP 客戶只能在一段有限 的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期（lease period），但并没 有具体规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。例 如，一个校园网的 DHCP 服务器可将租用期设定为1小时。DHCP 服务器在给 DHCP 发送 的提供报文的选项中给出租用期的数值。按照 RFC 2132 的规定，租用期用4字节的二进制 数字表示，单位是秒。因此可供选择的租用期范围从1秒到136年。DHCP客户也可在自己 发送的报文中（例如，发现报文）提出对租用期的要求。 DHCP 的详细工作过程如图6-20 所示。DHCP 客户使用的 UDP 端口是68，而 DHCP 服务器使用的 UDP端口是67。这两个 UDP 端口都是熟知端口。 被动打开 67 服务器 · UDP 67 服务器 客戶 68 DHCPDISCOVER UDP UDP 客戶 68 DHCPOFFER 67 服务器 。 UDP UDP 客戶 68 DHCPREQUEST 67 服务器 UDP UDP 客户 68 DHCPACK 67 服务器 UDP UDP 6 客户 68 UDP 客户 68 UDP DHCPREQUEST 1 DHCPACK 67 服务器 UDP 67 服务器 。 UDP 客户 68 DHCPNACK 67 服务器 UDP UDP 9 客户 68 DHCPRELEASE 67 服务器 UDP UDP 图6-20 DHCP 协议的工作过程</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>下面按照图 6-20 中的注释编号（●至）进行简单的解释。 1 DHCP 服务器被动打开UDP端口67，等待客户端发来的报文。 2 DHCP 客户从 UDP 端口 68 发送 DHCP 发现报文。 • 凡收到 DHCP 发现报文的DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客戶</p> <p>可能收到多个 DHCP 提供报文。 4 DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器 发送 DHCP 请求报文。 • 被选择的 DHCP服务器发送确认报文 DHCPACK。从这时起，DHCP 客戶就可以使 用这个 IP 地址了。这种状态叫做已绑定状态，因为在 DHCP 客户端的 IP 地址和硬 件地址已经完成绑定，并且可以开始使用得到的临时 IP 地址了。 DHCP 客户现在要根据服务器提供的租用期T 设置两个计时器 T和T2，它们的超 时时间分别是 0。5T 和0。875T。当超时时间到了就要请求更新租用期。 • 租用期过了一半（Tı 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租 用期。 DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用 期，重新设置计时器。 8 DHCP 服务器若不同意，则发回否认报文 DHCPNACK。这时 DHCP 客户必须立即 停止使用原来的IP 地址，而必须重新申请IP 地址（回到步骤●）。 若 DHCP 服务器不响应步骤的请求报文 DHCPREQUEST，则在租用期过了 87。5%时（T2 时间到），DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复 步骤●），然后又继续后面的步骤。 9 DHCP 客户可以随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发 送释放报文 DHCPRELEASE 即可。 DHCP 很适合于经常移动位置的计算机。当计算机使用 Windows 操作系统时，点击 “控制面板”的“网络”图标就可以找到某个连接中的“网络”下面的菜单，找到 TCP/IP 协议后点击其“属性”按钮，若选择“自动获得IP 地址”和“自动获得DNS 服务器地 址”，就表示是使用DHCP 协议。</p> <h2 id="七简单网络管理协议-snmp">七、简单网络管理协议 SNMP</h2> <h3 id="71-网络管理的基本概念">7.1 网络管理的基本概念</h3> <p>虽然网络管理还没有精确定义，但它的内容可归纳为： 网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、 测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行 性能、服务质量等。网络管理常简称为网管。 我们可以看到，网络管理并不是指对网络进行行政上的管理。 网络是一个非常复杂的分布式系统。这是因为网络上有很多不同厂家生产的、运行着 多种协议的结点（主要是路由器），而这些结点还在相互通信和交换信息。网络的状态总是 不断地变化着。可见，我们必须使用一种机制来读取这些结点上的状态信息，有时还要把一 些新的状态信息写入到这些结点上。 下面简单介绍网络管理模型中的主要构件（见图6-21）。 管理站又称为管理器，是整个网络管理系统的核心，它通常是个有着良好图形界面的 高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理</p> <p>站发出的。管理站的所在部门也常称为网络运行中心 NOC （Network Operations Center）。管 理站中的关键构件是管理程序（如图6-21 中有字母 M 的椭圆形图标所示）。管理程序在运 行时就成为管理进程。管理站（硬件）或管理程序（软件）都可称为管理者（manager）或管 理器，所以这里的 manager 不是指人而是指机器或软件。网络管理员（administrator）才是指 人。大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的 设备。 被管设备 被管设备 互联网 被管设备 被管设备 被管设备 网管协议 网络 管理站 管理员 M ·管理程序（运行SNMP客户程序） A ·代理程序（运行 SNMP 服务器程序） 图6-21 网络管理的一般模型 在被管网络中有很多的被管设备（包括设备中的软件）。被管设备可以是主机、路由 器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多被管对象 （Managed Object）。被管对象可以是被管设备中的某个硬件（例如，一块网络接口卡），也可 以是某些硬件或软件（例如，路由选择协议）的配置参数的集合。被管设备有时可称为网络 元素或简称为网元。在被管设备中也会有一些不能被管的对象（在下面的 6。7。2 节将会讲到 对象命名树，所谓不能被管的对象就是不在对象命名树上的对象）。 在每一个被管设备中都要运行一个程序以便和管理站中的管理程序进行通信。这些运 行着的程序叫做网络管理代理程序，或简称为代理（agent）（如图6-22 中有字母 A 的几个椭 圆形图标所示）。代理程序在管理程序的命令和控制下，在被管设备上采取本地的行动。 在图 6-22 中还有一个重要构件就是网络管理协议，简称为网管协议。后面还要讨论它 的作用。 简单网络管理协议 SNMP （Simple Network Management Protocol）中的管理程序和代理程 序按客户服务器方式工作。管理程序运行 SNMP 客户程序，而代理程序运行 SNMP 服务器 程序。在被管对象上运行的 SNMP 服务器程序不停地监听来自管理站的 SNMP 客户程序的 请求（或命令）。一旦发现了，就立即返回管理站所需的信息，或执行某个动作（例如，把 某个参数的设置进行更新）。在网管系统中往往是一个（或少数几个）客户程序与很多的服 务器程序进行交互。 关于网络管理有一个基本原理，这就是： 若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有 对象的影响必须尽量小些。 SNMP 正是按照这样的基本原理来设计的。 SNMP 发布于 1988 年。OSI 虽然在这之前就已制定出许多的网络管理标准，但当时 （到现在也很少）却没有符合 OSI 网管标准的产品。SNMP 最重要的指导思想就是要尽可 能简单。SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。在网</p> <p>络正常工作时，SNMP 可实现统计、配置和测试等功能。当网络出故障时，可实现各种差错 检测和恢复功能。经过近二十年的使用，SNMP 不断修订完善，较新的版本是SNMPv3，而 前两个版本分别是SNMPv2 和 SNMPv1。但一般可简称为 SNMP。现在 SNMPv3 已成为互 联网标准（STD 62）。SNMPv3 最大的改进就是安全特性。也就是说，只有被授权的人员才 有资格执行网络管理的功能（如关闭某一条链路）和读取有关网络管理的信息（如读取一个 配置文件的內容）。然而 SNMP 协议已相当庞大，一点也不“简单”，整个标准共有八个 RFC 文档[RFC 3411~3418]。因此这里只能给出一些最基本的概念。 若网络元素使用的不是 SNMP 协议而是另一种网络管理协议，那么 SNMP 协议就无法 控制该网络元素。这时可使用委托代理（proxy agent）。委托代理能提供如协议转换和过滤操 作等功能对被管对象进行管理。 SNMP 的网络管理由三个部分组成，即SNMP 本身、管理信息结构 SMI （Structure of Management Information）和管理信息库 MIB （Management Information Base）。下面简述这三 部分的作用。 SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象 （变量名及其状态（值）。SNMP 负责读取和改变这些数值。 SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和 对象的值进行编码的规则。这样做是为了确保网络管理数据的语法和语义无二义性。但从 SMI 的名称并不能看出它的功能。请注意，SMI 并不定义一个实体应管理的对象数目，也 不定义被管对象名以及对象名及其值之间的关联。 MIB 在被管理的实体中创建了命名对象，并规定了其类型。 为了更好地理解上述的几个组成部分，可以把它们和程序设计进行一下对比。 我们在编程时要使用某种语言，而这种语言就是用来定义编程的规则。例如，一个变 量名必须从字母开始而后面接着是字母数字。在网络管理中，这些规则由SMI来定义。 在程序设计中必须对变量进行说明。例如，int counter，表示变量 counter 是整数类型。 MIB 在网络管理中就做这样的事情。MIB 给每个对象命名，并定义对象的类型。 在编程中的说明语句之后，程序需要写出一些语句用来存储变量的值，并在需要时改 变这些变量的值。SNMP 在网络管理中完成这件任务。SNMP 按照SMI 定义的规则，存 储、改变和解释这些已由MIB 说明的对象的值。 总之，SMI 建立规则，MIB对变量进行说明，而SNMP 完成网管的动作。 下面就一一介绍上述的三个构件。</p> <h3 id="72-管理信息结构-smi">7.2 管理信息结构 SMI</h3> <p>管理信息结构 SMI 是 SNMP 的重要组成部分。根据 6。7。1 节所讲的，SMI 的功能应当 有三个，即规定： （1）被管对象应怎样命名； （2）用来存储被管对象的数据类型有哪些； （3） 在网络上传送的管理数据应如何编码。</p> <h4 id="1被管对象的命名">（1）被管对象的命名</h4> <p>SMI 规定，所有的被管对象都必须处在对象命名树（object naming tree）上。图6-22 给出</p> <p>了对象命名树的一部分。对象命名树的根没有名字，它的下面有三个顶级对象，都是世界上 著名的标准制定单位，即ITU-T （过去叫做CCITT），ISO，以及这两个组织的联合体，它 们的标号分别是 0 到 2。图中的对象名习惯上用英文小写表示。在 ISO 的下面的一个标号为 3 的节点是 ISO 认同的的组织成员 org。在其下面有一个美国国防部 dod （Department of Defense）的子树（标号为 6），再下面就是 internet（标号为 1）。在只讨论 internet 中的对象 时，可只画出 internet 以下的子树，并在internet 节点旁边写上对象标识符 1。3。6。1 即可。 根 itu-t （0） iso （1） iso/itu-t （2） org （3） dod （6） internet （1） 1。3。6。1 （iso。org。dod。internet） mgmt （2） mib-2（1） 1。3。6。1。2。1 （iso。org。dod。internet。mgmt。mib-2） system（1） 八 interface（2） at（3） ip（4） icmp（5） tcp（6） udp（7） 八 八 egp（8） 。。。 八 八八 ipInReceives（3） 1。3。6。1。2。1。4。3 图6-22 SMI规定所有被管对象必须在命名树上</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>在 internet 节点下面的标号为2的节点是mgmt（管理）。再下面只有一个节点，即管理 信息库 mib-2，其对象标识符为1。3。6。1。2。1。在mib-2 下面包含了所有被SNMP 管理的对象 （见下面6。7。3 节的讨论）。</p> <h4 id="2被管对象的数据类型">（2）被管对象的数据类型</h4> <p>SMI 使用基本的抽象语法记法1（即ISO制定的ASN。1）来定义数据类型，但又增加 了一些新的定义。因此 SMI 既是ASN。1 的子集，又是ASN。1 的超集。ASN。1 的记法很严 格，它使得数据的含义不存在任何可能的二义性。例如，使用ASN。1 时不能简单地说 个具有整数值的变量”，而必须说明该变量的准确格式和整数取值的范围。当网络中的计算 机对数据项并不都使用相同的表示时，采用这种精确的记法就尤其重要。 我们知道，任何数据都具有两种重要的属性，即值（value）与类型（type）。这里“值”是 某个值集合中的一个元素，而“类型”则是值集合的名字。如果给定一种类型，则这种类型 的一个值就是该类型的一个具体实例。 SMI 把数据类型分为两大类：简单类型和结构化类型。简单类型是最基本的、直接使 用 ASN。1 定义的类型。表6-4 给出了最主要的几种简单类型。</p> <p>表6-4 几种最主要的简单类型 类型 大小 说明 INTEGER 4字节 在-231 到231-1之间的整数 Interger32 4 字节 和 INTEGER 相同 Unsigned32 4 字节 在0到22 −1之间的无符号数 OCTET STRING 可变 不超过65535字节长的字节串 OBJECT IDENTIFIER 可变 对象标识符 IPAddress 4 字节 由4个整数组成的IP地址 Counter32 4字节 可从0增加到23”的整数；当它到达最大值时就返回到0 TimeTicks 4字节 记录时间的计数值，以1/100秒为单位 BITS 比特串 Opaque 可变 不解释的串 SMI 定义了两种结构化数据类型，即 sequence 和 sequence ofo 数据类型 sequence 类似于 C 语言中的 struct 或 record，它是一些简单数据类型的组合 （不一定要相同的类型）。而数据类型 sequence of 类似于 C 语言中的 array，它是同样类型 的简单数据类型的组合，或同样类型的 sequence 数据类型的组合。</p> <h4 id="3编码方法">（3）编码方法</h4> <p>SMI 使用 ASN。1 制定的基本编码规则BER（Basic Encoding Rule）进行数据的编码。BER 指明了每种数据的类型和值。在发送端用 BER 编码，可把用ASN。1 所表述的报文转换成唯 一的比特序列。在接收端用BER 进行解码，就可得到该比特序列所表示的ASN。1报文。 初看起来，或许用两个字段就能表示类型和值。但由于表示值可能需要多个字节，因 此还需要一个指出“要用多少字节表示值”的长度字段。因此 ASN。1 把所有的数据元素都 表示为 T-L-V 三个字段组成的序列（见图6-23）。T字段（Tag）定义数据的类型，L 字段 （Length）定义 V 字段的长度，而V字段（Value）定义数据的值。 字节 1 可变 可变 数据元素 标记T 长度L 值V 类别 格式 位2 编 号 1 5 图6-23 用TLV 方法进行编码</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>（1） T 字段又叫做标记字段，占1 字节。T 字段比较复杂，因为它要定义的数据类型较 多。T字段又再分为以下三个子字段： 类别（2位）共四种：通用类（00），即 ASN。1 定义的类型；应用类（01），即 SMI 定 义的类型；上下文类（10），即上下文所定义的类型；专用类（11），保留为特定厂商 定义的类型。 格式（1 位）共两种，指出数据类型的种类：简单数据类型（0），结构化数据类型 （1）。 •</p> <p>编号（5位）用来标志不同的数据类型。编号的范围一般为0~30。当编号大于 30 时，T 字段就要扩展为多个字节（这种情况很少用到，可参考 ITU-T X。209，这里 从略）。 表6-5是一些数据类型的T字段的编码。 表6-5 几种数据类型的T字段编码 数据类型 类别 格式 编号 T字段（二进制） T字段（十六进制） INTEGER 00 0 00010 00000010 02 OCTET STRING 00 0 00100 00000100 04 OBJECT IDENTIFIER 00 0 00110 00000110 06 NULL 00 0 00101 00000101 05 Sequence， sequence of 00 1 10000 00110000 30 IPAddress 01 0 00000 01000000 40 Counter 01 0 00001 01000001 41 Gauge 01 0 00010 01000010 42 TimeTicks Opaque 01 0 00011 01000011 43 01 0 00100 01000100 44 （2） L 字段又叫做长度字段（单字节或多字节）。当字段为单字节时，其最高位为 0， 后面的7位定义V字段的长度。当L 字段为多个字节时，其最高位为 1，而后面的 7 位定 义后续字节的字节数（用二进制整数表示）。这时，所有的后续字节并置起来的二进制整数 定义V字段的长度。图6-24给出了L字段的格式。 指出V字段长度=2字节 单字节的L字段00000010 指出后续字节数 = 2 指出V字段长度=262字节 多字节的L字段 0000010 0000000100000110 后续字节数=2 图6-24 L字段的格式</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>（3） V 字段又叫做值字段，用于定义数据元素的值。 根据以上所述，我们给出两个用十六进制表示的编码例子。例如，INTEGER 15，根据 表 6-5，其 T 字段是02，再根据表 6-4，INTEGER 类型要用4字节编码。最后得出 TLV 编 码为 02 04 00 00 00 OF。又如 IPAddress 192。1。2。3，IPAddress 的T字段是40，V字段需要4 字节表示，因此IPAddress 192。1。2。3 的TLV编码是4004C0 01 02 03。 TLV 方法中的V字段还可嵌套其他数据元素的TLV 字段，并可多重嵌套。</p> <h3 id="73-管理信息库-mib">7.3 管理信息库 MIB</h3> <p>所谓“管理信息”就是指在互联网的网管框架中被管对象的集合。被管对象必须维持 可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚拟的信息存储器，所 以才称为管理信息库 MIB。管理程序就使用 MIB 中这些信息的值对网络进行管理（如读取 或重新设置这些值）。只有在 MIB 中的对象才是 SNMP 所能够管理的。例如，路由器应当 •</p> <p>维持各网络接口的状态、入分组和出分组的流量、丢弃的分组和有差错的报文的统计信息， 而调制解调器则应当维持发送和接收的字符数、码元传输速率和接受的呼叫等统计信息。因 此在 MIB 中就必须有上面这样一些信息。 我们再看一下图 6-22，可以找到节点 mib-2 下面的部分是 MIB 子树。表 6-6 给出了节 点 mib-2 所包含的前八个信息类别代表的意思（在后面还有好几个类别）。 表6-6 节点 mib-2 所包含的信息类别举例 类别 标号 所包含的信息 system （1） interfaces （2） 主机或路由器的操作系统 各种网络接口 address translation （3） 地址转换（例如，ARP 映射） ip （4） IP 软件 icmp （5） ICMP 软件 tcp （6） TCP 软件 udp （7） UDP 软件 egp （8） EGP 软件 我们可以用个简单例子进一步说明 MIB 的意义。例如，从图 6-22 可以看出，对象 ip 的标号是4。因此，所有与 IP 有关的对象都从前缀 1。3。6。1。2。1。4 开始。 （1） 在节点 ip 下面有个名为ipInReceives 的 MIB 变量（见图6-22），表示收到的 IP 数据 报数。这个变量的标号是3，变量的名字是： iso。org。dod。internet。mgmt。mib。ip。ipInReceives， 而相应的数值表示是：1。3。6。1。2。1。4。3。 （2）当 SNMP 在报文中使用 MIB 变量时，对于简单类型的变量，后缀0指具有该名字 的变量的实例。因此，当这个变量出现在发送给路由器的报文中时，ipInReceives 的数值表 示（即变量的一个实例）就是：1。3。6。1。2。1。4。3。0。 （3） 请注意，对于分配给一个 MIB 变量的数值或后缀是完全没有办法进行推算的，必 须查找已发布的标准。 上面所说的 MIB对象命名树的大小并没有限制。下面给出若干 MIB 变量的例子（见表 6-7），以便更好地理解 MIB 的意义。这里的“变量”是指特定对象的一个实例。 表 6-7 MIB 变量的例子 MIB 变量 所属类别 意义 sysUpTime system 距上次重启动的时间 ifNumber interfaces 网络接口数 ifMtu interfaces 特定接口的最大传送单元 MTU ipDefaultTTL ip IP 在生存时间字段中使用的值 ipInReceives ip 接收到的数据报数目 ipForwDatagrams ip 转发的数据报数目 ipOutNoRoutes ip 路由选择失败的数目 ipReasmOKs ip 重装的数据报数目 ipFragOKs ip 分片的数据报数目 ipRouting Table ip IP 路由表 icmpInEchos icmp 收到的 ICMP 回送请求数目</p> <p>MIB 变量 所属类别 tcpRtoMin tcp 意义 TCP 允许的最小重传时间 tcpMaxConn tcp tcpInSegs udpInDatagrams tcp udp 允许的最大TCP 连接数目 已收到的TCP报文段数目 已收到的 UDP数据报数目 续表 上面列举的大多数项目的值可用一个整数来表示。但 MIB 也定义了更复杂的结构。例 如，MIB 变量 ipRoutingTable 则定义一个完整的路由表。还有其他一些 MIB 变量定义了路 由表项目的内容，并允许网络管理协议访问路由器中的单个项目，包括前缀、地址掩码以及 下一跳地址等。当然，MIB 变量只给出了每个数据项的逻辑定义，而一个路由器使用的內 部数据结构可能与 MIB 的定义不同。当一个查询到达路由器时，路由器上的代理软件负责 MIB 变量和路由器用于存储信息的数据结构之间的映射。</p> <h3 id="74-snmp-的协议数据单元和报文">7.4 SNMP 的协议数据单元和报文</h3> <p>实际上，SNMP 的操作只有两种基本的管理功能，即： （1）“读”操作，用 Get 报文来检测各被管对象的状况； （2）“写”操作，用Set报文来改变各被管对象的状况。 SNMP 的这些功能通过探询操作来实现，即SNMP 管理进程定时向被管理设备周期性 地发送探询信息。上述时间间隔可通过 SNMP 的管理信息库 MIB 来建立。探询的好处是： 第一，可使系统相对简单；第二，能限制通过网络所产生的管理信息的通信量。但探询管理 协议不够灵活，而且所能管理的设备数目不能太多。探询系统的开销也较大。如探询频繁而 并未得到有用的报告，则通信线路和计算机的CPU周期就被浪费了。 但 SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为 陷阱（trap），表示它能够捕捉“事件”。但这种陷阱信息的参数是受限制的。 当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达 到某些门限值的事件（这就叫做过滤）。这种方法的好处是：第一，仅在严重事件发生时才 发送陷阱；第二，陷阱信息很简单且所需字节数很少。 总之，使用探询（至少是周期性地）以维持对网络资源的实时监视，同时也采用陷阱 机制报告特殊事件，使得 SNMP成为一种有效的网络管理协议。 SNMP 使用无连接的UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保 证可靠交付的。这里还要指出，SNMP 使用UDP 的方法有些特殊。在运行代理程序的服务 器端用熟知端口161 来接收Get 或Set报文和发送响应报文（与熟知端口通信的客户端使用 临时端口），但运行管理程序的客户端则使用熟知端口162来接收来自各代理的 trap 报文。 SNMP 现在共定义了如表 6-8 所示的8种类型的协议数据单元[RFC 3416]，其中 PDU 编号为4的已经废弃了。在 PDU 编号后面是对应的T字段值（十六进制表示）。 表6-8 SNMP定义的协议数据单元类型 PDU 编号（T字段 ） PDU 名称 用途 0 （A0） GetRequest 管理者从代理读取一个或一组变量的值</p> <p>PDU 编号（T字段 ） 1（Al） PDU 名称 GetNextRequest 用途 续表 管理者从代理读取 MIB 树上的下一个变量的值（即使不知道此变量名也行）。 此操作可反复进行，特别是按顺序一一读取列表中的值很方便 2 （A2） Response 代理向管理者或管理者向管理者发送对五种 Request 报文的响应，并提供差错 码、差错状态等信息 3（A3） SetRequest 管理者对代理的一个或多个MIB 变量的值进行设置 5（A5） 6（A6） GetBulkRequest 管理者从代理读取大数据块的值（如大的列表中的值） InformRequest 管理者从另一远程管理者读取该管理者控制的代理中的变量值 7 （A7） 8（A8） SNMPv2Trap 代理向管理者报告代理中发生的异常事件 Report 在管理者之间报告某些类型的差错，目前尚未定义 和大多数 TCP/IP协议不一样，SNMP报文没有固定的字段。相反，它们使用标准 ASN。1 编码。因此，SNMP报文用人工进行编码和理解时都比较困难。为此，在图 6-25 中 给出了 SNMPv1 的报文格式。可以看出，一个 SNMP 报文共由四个部分组成，即版本、首 部、安全参数和SNMP报文的数据部分。版本现在已是版本3。首部包括报文标识（message identification）、最大报文长度、报文标志（message flag）。报文标志占1字节，其中的每一位 定义安全类型或其他信息。安全参数用来产生报文摘要（见下一章的7。4节）。 从图6-25 可看出，在SNMP PDU 前面还有两个有关加密信息的字段。这是当数据部分 需要加密时才使用的两个字段。与网络管理直接相关的是后面的 SNMP PDU 部分。对于表 6-8 给出的前四种PDU的格式都是相同的，即由PDU类型、请求ID、差错状态、差错索引 以及变量绑定这几个字段组成。PDU 的各种类型以及类型的编号和T字段的编码已在表6-8 中给出。下面简单介绍一下其他字段的作用。 IP数据报 UDP数据报 20字节 8字节 SNMP 报文 IP UDP 首部首部 版本 首部 安全 参数 SNMP 报文的数据部分 上下文引擎 ID | 上下文名 PDU 类型 请求ID 差错状态差错索引 名 值名值 有关加密信息的字段 首部 SNMP PDU 图6-25 SNMP 的报文格式</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>变量绑定 （1）请求标识符（request ID） 由管理进程设置的4字节数值。代理进程在发送响应 报文时也要返回此请求标识符。由于管理进程可同时向许多代理发出请求读取变量值的报 文，因此设置了请求标识符可使管理进程能够识别返回的响应是对应于哪一个请求报文。 （2） 差错状态（error status） 在请求报文中，这个字段是零。当代理进程响应时，就填 入 0~18 中的一个数字。例如表示 noError （一切正常），1表示tooBig（代理无法把回答 装入到一个 SNMP 报文之中），2 表示 noSuchName（操作指明了一个不存在的变量），3表 示badValue（无效值或无效语法），等等[RFC3416]。</p> <p>（3） 差错索引（error index） 在请求报文中，这个字段是零。当代理进程响应时，若出 现 noSuchName， badValue或readOnly 的差错，代理进程就设置一个整数，指明有差错的变 量在变量列表中的偏移。 （4） 变量绑定（variable-bindings） 中，变量的值应忽略（类型是NULL）。 指明一个或多个变量的名和对应的值。在请求报文 为了大致了解 ASN。1 给出的定义的形式，下面举出定义 GetRequest-PDU 的例子。两个 连字符“–”后面的是注解。 Get-request-PDU ：：= [0] IMPLICIT SEQUENCE { –[0]表示上下文类，编号为0 –类型是SEQUENCE –变量 request-id的类型是integer32 request-id integer32， error-status INTEGER {0。。18}， error-index variable-bindings VarBindList} –变量 error-status取值为0~18的整数 INTEGER {0。。max-bindings}， –变量 error-index 取值为0~max-bindings 的整数 –变量 variable-binding 的类型是VarBindList 但变量 VarBindList 是什么类型呢？还需要继续定义（这里从略）。上面 ASN。1 定义中 的第二行中的 IMPLICIT 叫做隐式标记，是为了在进行编码时可省去对IMPLICIT 后面的类 型（SEQUENCE）的编码，使最后得出的编码更加简洁。 下面我们假定管理者发送 GetRequest-PDU，为的是从某路由器的代理进程获得“收到 UDP数据报的数目”的信息。从图6-22可以查出，mib-2 下面第7个节点是udp，而udp节 点下面的第一个节点就是 udpInDatagrams。由于这个节点已经是叶节点（即没有连接在它下 面的子节点了），读取这个节点的数值时应在节点标识符后面加上0，即 1。3。1。1。2。1。7。1。0。这 样，可得出 GetRequest-PDU 的ASN。1 编码如图6-26 所示。 T L INTEGER 04 T GetRequest-PDU A0 1D L GetRequest -PDU request-id error-status error-index variable-bindings L VarBind V T LV LV T T 05 AE 56 02 INTEGER 01：00 INTEGER 01 00 SEQUENCE OF OF request-ID T L SEQUENCE OD name value T L V T L OBJECT IDENTIFIER 09 01 03 06 01 02 01 01 01 00 1。 3。 6。 1。 2。 1。 7。 1。0 NULL 00 图6-26 GetRequest-PDU的ASN。1 编码</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>可以把图中各字段的十六进制编码表示如下。 A0 1D 02 04 05 AE 56 02 02 01 00 02 01 00 • 306 • 30 OF 30 0D — GetRequest-PDU，上下文类型，长度1D16=29 – INTEGER 类型，长度 0416，request-id = 05 AE56 02 – INTEGER类型，长度 0116， error status = 0016 – INTEGER 类型，长度 0116， error index = 0016 — SEQUENCE OF 类型，长度 OF16 = 15 — SEQUENCE 类型，长度 0。6 = 13</p> <p>06 09 01 03 06 01 02 01 07 01 00 05 00 –</p> <ul> <li>OBJECT IDENTIFIER类型，长度 0916， udpInDatagrams – NULL 类型，长度 0016</li> </ul> <h2 id="八应用进程跨越网络的通信">八、应用进程跨越网络的通信</h2> <p>在这以前我们已经讨论了互联网使用的几种常用的应用层协议，这些应用协议使广大 用户可以更加方便地利用互联网的资源。 现在的问题是：如果我们还有一些特定的应用需要互联网的支持，但这些应用又不能 直接使用已经标准化的互联网应用协议，那么我们应当做哪些工作？要回答这个问题，实际 上就是要了解下面要介绍的系统调用和应用编程接口。这些问题实际上需要一门专门的课程 来学习，我们在这里只能给出一些初步的概念。</p> <h3 id="81-系统调用和应用编程接口">8.1 系统调用和应用编程接口</h3> <p>大多数操作系统使用系统调用（system call）的机制在应用程序和操作系统之间传递控制 权。对程序员来说，系统调用和一般程序设计中的函数调用非常相似，只是系统调用是将控 制权传递给了操作系统。图6-27说明了多个应用进程使用系统调用的机制。 应用程序 1 应用程序2 。。。 应用程序 n 在用户地址空间中 的应用程序 由应用程序调用的系统函数 系统调用接口 包括 TCP/IP 协议软件的操作系统内核 系统地址空间中 的协议软件 图6-27 多个应用进程使用系统调用的机制</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口。此接 口再把控制权传递给计算机的操作系统。操作系统把这个调用转给某个内部过程，并执行所 请求的操作。内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程。总 之，只要应用进程需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执 行必要的操作后把控制权返回给应用进程。因此，系统调用接口实际上就是应用进程的控制 权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些 程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口 API （Application Programming Interface）。API从程序设计的角度定义了许多标准的系统调用 函数。应用进程只要使用标准的系统调用函数就可得到操作系统的服务。因此从程序设计的 角度看，也可以把API看成是应用程序和操作系统之间的接口。 现在 TCP/IP 协议软件已驻留在操作系统中。由于TCP/IP 协议族被设计成能运行在多 种操作系统的环境中，因此 TCP/IP 标准没有规定应用程序与 TCP/IP 协议软件如何接口的细 节，而是允许系统设计者能够选择有关 API 的具体实现细节。目前，只有几种可供应用程 序使用 TCP/IP 的应用编程接口 API。这里最著名的就是美国加利福尼亚大学伯克利分校为 Berkeley UNIX 操作系统定义了一种 API，它又称为套接字接口（socket interface） （或插口接 口）。微软公司在其操作系统中采用了套接字接口 API，形成了一个稍有不同的 API，并称</p> <p>之为 Windows Socket，简称为 WinSock。AT&amp;T 为其 UNIX系统V 定义了一种API，简写为 TLI （Transport Layer Interface）。 我们知道，若要让计算机做某件事情，就要编写使计算机能理解的程序。在网络环境 下的计算机应用都有一个共同特点，这就是：在不同地点的计算机要通过网络进行通信。从 另一种角度看，计算机之间的通信就是本计算机要读取另一个地点的计算机中的数据，或者 要把数据从本计算机写入到另一个地点的计算机中。这种“读取”和“写入”的过程都要用 到上面所说的系统调用。 在讨论网络编程时常常把套接字作为应用进程和运输层协议之间的接口，图6-28 表示 这一概念。图中假定了运输层使用TCP 协议（若使用UDP协议，情况也是类似的，只是 UDP 是无连接的。通信的两端仍然可用两个套接字来标志）。现在套接字已成为计算机操作 系统内核的一部分。 客户 服务器 由应用程序 控制 应用进程 应用进程 套接字 |套接字 互联网 由操作系统 TCP TCP 控制 图6-28 套接字成为应用进程与运输层协议的接口</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>请注意：在套接字以上的进程是受应用程序控制的，而在套接字以下的运输层协议软 件则是受计算机操作系统的控制。因此，只要应用程序使用TCP/IP 协议进行通信，它就必 须通过套接字与操作系统交互（这就要使用系统调用函数）并请求其服务。我们应当注意 到，应用程序的开发者对套接字以上的应用进程具有完全的控制，但对套接字以下的运输层 却只有很少的控制，例如，可以选择运输层协议（TCP 或UDP）以及一些运输层的参数 （如最大缓存空间和最大报文长度等）。 当应用进程（客户或服务器）需要使用网络进行通信时，必须首先发出 socket 系统调 用，请求操作系统为其创建一个“套接字”。这个调用的实际效果是请求操作系统把网络通 信所需要的一些系统资源（存储器空间、CPU 时间、网络带宽等）分配给该应用进程。操 作系统为这些资源的总和用一个叫做套接字描述符（socket descriptor）的号码（小的整数）来 表示，然后把这个套接字描述符返回给应用进程。此后，应用进程所进行的网络操作（建立 连接、收发数据、调整网络通信参数等）都必须使用这个套接字描述符。所以，几乎所有的 网络系统调用都把这个套接字描述符作为套接字的许多参数中的第一个参数。在处理系统调 用的时候，通过套接字描述符，操作系统就可以识别出应该使用哪些资源来完成应用进程所 请求的服务。通信完毕后，应用进程通过一个关闭套接字的 close 系统调用通知操作系统回 收与该套接字描述符相关的所有资源。由此可见，套接字是应用进程为了获得网络通信服务 而与操作系统进行交互时使用的一种机制。 图 6-29 给出了当应用进程发出 socket 系统调用时，操作系统所创建的套接字描述符 与套接字数据结构的关系。由于在一个机器中可能同时出现多个套接字，因此需要有一个存 放套接字描述符的表，而每一个套接字描述符有一个指针指向存放套接字的地址。在套接字</p> <p>的数据结构中有许多参数要填写。图 6-29 中已填写好的参数是协议族（PF_INET，表示使 用 Internet 的 TCP/IP 协议族）和服务（SOCKSTREAM，表示使用流式服务，也就是使用 TCP 服务）。在刚刚创建一个新的套接字时，有灰色背景的四个项目（本地和远地 IP 地址， 本地和远地端口）都是未填写的，因此它和任何机器中的应用进程暂时都还没有联系。 操作系统 套接字描述符表 （每一个进程一个描述符） 套接字的数据结构 0 1 2。 3。 4。 0： 协议族：PF_INET 1： 服务：SOCK_STREAM 2： 3： 远地 4： ： 图6-29 调用 socket 创建套接字 。。。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <h3 id="82-几种常用的系统调用">8.2 几种常用的系统调用</h3> <p>下面我们以使用TCP 的服务为例介绍几种常用的系统调用。</p> <h4 id="1连接建立阶段">（1）连接建立阶段</h4> <p>当套接字被创建后，它的端口号和IP 地址都是空的，因此应用进程要调用 bind（绑 定）来指明套接字的本地地址（本地端口号和本地 IP 地址）。在服务器端调用bind 时就是 把熟知端口号和本地IP 地址填写到已创建的套接字中。这就叫做把本地地址绑定到套接 字。在客户端也可以不调用 bind，这时由操作系统内核自动分配一个动态端口号（通信结 束后由系统收回）。 服务器在调用 bind 后，还必须调用 listen （收听）把套接字设置为被动方式，以便 随时接受客户的服务请求。UDP 服务器由于只提供无连接服务，不使用 listen 系统调 用。 服务器紧接着就调用 accept（接受），以便把远地客户进程发来的连接请求提取出 来。系统调用 accept 的一个变量就是要指明是从哪一个套接字发起的连接。 调用 accept 要完成的动作较多。这是因为一个服务器必须能够同时处理多个连接。 这样的服务器常称为并发方式（concurrent）工作的服务器。可以有多种方法实现这种并发方 式。图 6-30 所示的是一种实现方法。 主服务器进程 M（就是通常所说的服务器进程）一调用 accept，就为每一个新的连 接请求创建一个新的套接字，并把这个新创建的套接字的标识符返回给发起连接的客户方。 与此同时，主服务器进程还要创建一个从属服务器进程（如图6-30 中的S）来处理新建立 的连接。这样，从属服务器进程用这个新创建的套接字和客户进程建立连接，而主服务器进 程用原来的套接字重新调用 accept，继续接受下一个连接请求。在已建立的连接上，从属</p> <p>服务器进程就使用这个新创建的套接字传送和接收数据。数据通信结束后，从属服务器进程 就关闭这个新创建的套接字，同时这个从属服务器也被撤销。 主服务器进程 M 从属服务器进程 服务器 应用进程 S3 S2 S₁ 接受连接请求 的套接字 （原来的套接字） 连接 连接 连接 套接字 套接字 套接字 - 操作系统 （新创建的套接字） 图6-30 并发方式工作的服务器 总之，在任一时刻，服务器中总是有一个主服务器进程和零个或多个从属服务器进 程。主服务器进程用原来的套接字接受连接请求，而从属服务器进程用新创建的套接字（在 图 6-30 中注明是“连接套接字”）和相应的客户建立连接并可进行双向传送数据。 以上介绍的是服务器为了接受客户端发起的连接请求而进行的一些系统调用。现在看 一下客户端的情况。当使用 TCP 协议的客户已经调用 socket 创建了套接字后，客户进程 就调用 connect，以便和远地服务器建立连接（这就是主动打开，相当于客户发出的连接 请求）。在 connect 系统调用中，客户必须指明远地端点（即远地服务器的IP地址和端口 号）。</p> <h4 id="2数据传送阶段">（2）数据传送阶段</h4> <p>客户和服务器都在 TCP 连接上使用 send 系统调用传送数据，使用recv 系统调用接 收数据。通常客户使用 send 发送请求，而服务器使用 send 发送回答。服务器使用 recv 接收客户用 send 调用发送的请求。客户在发完请求后用recv 接收回答。 调用 send 需要三个变量：数据要发往的套接字的描述符、要发送的数据的地址以及数 据的长度。通常 send 调用把数据复制到操作系统内核的缓存中。若系统的缓存已满， send 就暂时阻塞，直到缓存有空间存放新的数据。 调用 recv 也需要三个变量：要使用的套接字的描述符、缓存的地址以及缓存空间的长 度。</p> <h4 id="3连接释放阶段">（3）连接释放阶段</h4> <p>一旦客户或服务器结束使用套接字，就把套接字撤销。这时就调用 close 释放连接和 撤销套接字。 图 6-31 画出了上述的一些系统调用的使用顺序。有些系统调用在一个 TCP 连接中可能 会循环使用。</p> <p>客户端 服务器端 socket bind socket listen connect 连接建立请求 accept send recv close recv send close 图6-31 系统调用使用顺序的例子</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"></div> <p>UDP 服务器由于只提供无连接服务，因此不使用listen 和 accept 系统调用。</p> <h2 id="九p2p-应用">九、P2P 应用</h2> <p>我们在第1章1。3。1 节中已经简单地介绍了P2P 应用的概念。现在我们将进一步讨论 P2P 应用的若干工作原理。 P2P 应用就是指具有 P2P 体系结构的网络应用。所谓 P2P 体系结构就是在这样的网络 应用中，没有（或只有极少数的）固定的服务器，而绝大多数的交互都是使用对等方式 （P2P 方式）进行的。 P2P 应用的范围很广，例如，文件分发、实时音频或视频会议、数据库系统、网络服务 支持（如 P2P 打车软件、P2P理财等）。限于篇幅，下面只介绍最常用的P2P文件分发的工 作原理。 P2P 文件分发不需要使用集中式的媒体服务器，而所有的音频/视频文件都是在普通的 互联网用户之间传输的。这其实是相当于有很多（有时达到上百万个）分散在各地的媒体服 务器（由普通用户的计算机充当这种媒体服务器）向其他用户提供所要下载的音频/视频文 件。这种 P2P 文件分发方式解决了集中式媒体服务器可能出现的瓶颈问题。 目前在互联网流量中，P2P 工作方式下的文件分发已占据了最大的份额，比万维网应用 所占的比例大得多。因此单纯从流量的角度看，P2P 文件分发应当是互联网上最重要的应 用。现在 P2P 文件分发不仅传送音频文件 MP3，而且还传送视频文件（10~1000 MB，或 更大）、各种软件和图像文件。</p> <h3 id="91-具有集中目录服务器的-p2p-工作方式">9.1 具有集中目录服务器的 P2P 工作方式</h3> <p>最早使用 P2P 工作方式的是Napster。这个名称来自1999 年美国东北大学的新生 Shawn Fanning 所写的一个叫做 Napster 的软件。利用这个软件就可通过互联网免费下载各种 MP3</p> <p>音乐。Napster 的出现使MP3成为网络音乐事实上的标准。 Napster 能够搜索音乐文件，能够提供检索功能。所有音乐文件的索引信息都集中存放 在 Napster 目录服务器中。这个目录服务器起着索引的作用。使用者只要查找目录服务器， 就可知道应从何处下载所要的MP3文件。在2000年，Napster 成为互联网上最流行的 P2P 应用，并占据互联网上的通信量中相当大的比例。 这里的关键就是运行 Napster 的所有用户，都必须及时向 Napster 的目录服务器报告自 己已经存有哪些音乐文件。Napster 目录服务器就用这些用户信息建立起一个动态数据库， 集中存储了所有用户的音乐文件信息（即对象名和相应的 IP 地址）。当某个用户想下载某个 MP3 文件时，就向目录服务器发出查询（这个过程仍是传统的客户-服务器方式），目录服 务器检索出结果后向用户返回存放这一文件的计算机 IP 地址，于是这个用户就可以从中选 取一个地址下载想要得到的 MP3文件（这个下载过程就是P2P 方式）。可以看出，Napster 的文件传输是分散的（P2P方式），但文件的定位则是集中的（客户服务器方式）。 图 6-32 是Napster 的工作过程的示意图。假定 Napster 目录服务器已经建立了其用户的 动态数据库。图中给出了某个用户要下载音乐文件的主要交互过程。 A Napster 集中式 目录服务器 A有，B，C有。 谁有文件 MP3#？ 请求文件 MP3# MP3# C B 图6-32 Napster 的工作过程</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>● 用戶X向Napster 目录服务器查询（客户—服务器方式）谁有音乐文件 MP3#。 ② Napster 目录服务器回答X：有三个地点有文件MP3#，即A，B和C（给出了这三个 地点的 IP 地址）。于是用户X得知所需的文件 MP3#的三个下载地点。 ● 用戶 X 可以随机地选择三个地点中的任一个，也可以使用 PING 报文寻找最方便下 载的一个。在图 6-32 中，我们假定 X向A发送下载文件 MP3#的请求报文。现在X和A都 使用 P2P 方式通信，互相成为对等方，X是临时的客户，而对等方A是临时的服务器。 ● 对等方A（现在作为服务器）把文件MP3#发送给X。 这种集中式目录服务器的最大缺点就是可靠性差，而且会成为其性能的瓶颈（尤其是 在用户数非常多的情况下）。更为严重的是这种做法侵犯了唱片公司的版权。虽然 Napster 网站并没有直接非法复制任何 MP3 文件（Napster 网站不存储任何 MP3 文件，因而并没有 直接侵犯版权），但法院还是判决 Napster 属于“间接侵害版权”，因此在 2000 年 7 月底</p> <p>Napster 网站就被迫关闭了。</p> <h3 id="92-具有全分布式结构的p2p文件共享程序">9.2 具有全分布式结构的P2P文件共享程序</h3> <p>在第一代 P2P 文件共享网站 Napster 关闭后，开始出现了以 Gnutella 为代表的第二代 P2P 文件共享程序。Gnutella 是一种采用全分布方法定位内容的P2P文件共享应用程序。 Gnutella 与 Napster 最大的区别就是不使用集中式的目录服务器进行查询，而是使用洪泛法 在大量 Gnutella 用户之间进行查询。为了不使查询的通信量过大，Gnutella 设计了一种有限 范围的洪泛查询。这样可以减少倾注到互联网的查询流量，但由于查询的范围受限，因而这 也影响到查询定位的准确性。 为了更加有效地在大量用户之间使用P2P技术下载共享文件，最近几年已经开发出很 多种第三代 P2P 共享文件程序[KURO13]，它们使用分散定位和分散传输技术。如 KaZaA， 电骡 eMule，比特洪流BT（BitTorrent）等。 下面对比特洪流 BT 的主要特点进行简单的介绍。 在 P2P 的文件分发应用中，2001 年由 Brahm Cohen 开发的 BitTorrent （中文意思是“比 特洪流”）是很具代表性的一个。取这个名称的原因就是 BitTorrent 把参与某个文件分发的 所有对等方的集合称为一个洪流（torrent）。为了方便，下面我们使用 BitTorrent 的简称 BT。 BT 把对等方下载文件的数据单元称为文件块（chunk），一个文件块的长度是固定不变的，例 如，典型的数值是 256 KB。当一个新的对等方加入某个洪流时，一开始并没有文件块。 但新的对等方逐渐地能够下载到一些文件块。而与此同时，它也为别的对等方上传一些文件 块。某个对等方获得了整个的文件后，可以立即退出这个洪流（相当于自私的用户），也可 继续留在这个洪流中，为其他的对等方上传文件块（相当于无私的用户）。加入或退出某个 洪流可在任何时间完成（即使在某个文件还没有下载完毕时），也是完全自由的。 BT 的协议相当复杂[W-BT]。下面讨论其基本机制。 每一个洪流都有一个基础设施结点，叫做追踪器（tracker）。当一个对等方加入洪流时， 必须向追踪器登记（或称为注册），并周期性地通知追踪器它仍在洪流中。追踪器因而就跟 踪了洪流中的对等方。一个洪流中可以拥有少到几个多到几百或几千个对等方。 我们用图 6-33 来进一步说明 BT 的工作原理。当一个新的对等方A加入洪流时，追踪 器就随机地从参与的对等方集合中选择若干个（例如，30个），并把这些对等方的IP 地址 告诉 A。于是 A就和这些对等方建立了TCP 连接。我们称所有与A建立了TCP 连接的对 等方为“相邻对等方”（neighboring peers）。在图 6-33 中我们画出了 A 有三个相邻对等方 （B，C 和 D）。这些相邻对等方的数目是动态变化的，有的不久就离开了，但又有新加入 进来的。请注意，实际的网络拓扑可能是非常复杂的（参见图6-34的实际网络图）。我们知 道，TCP 连接只是个逻辑连接，而每一个 TCP 连接可能会穿越很多的网络。因此我们在讨 论问题时，可以利用实际网络上面的一个更加简洁的覆盖网络，这个覆盖网络忽略了实际网 络的许多细节，使问题的讨论更加方便。在覆盖网络中，A的三个相邻对等方就看得很清 楚。然而在实际网络中，则反映不出这几个对等方的相邻关系。 在任何时刻，每一个对等方可能只拥有某文件的一个文件块子集，而不同的对等方所 拥有的文件块子集也不会完全相同。对等方A将通过TCP连接周期性地向其相邻对等方索 取它们拥有的文件块列表。根据收到的文件块列表，A就知道了应当请求哪一个相邻对等方 把哪些自己缺少的文件块发送过来。</p> <p>追踪器 TCP连接 D D BT 覆盖网络 实际网络 图6-33 在覆盖网络中对等方的相邻关系的示意图</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"></div> <p>图 6-34 是对等方之间互相传送数据块的示意图。例如，A 向 B、C和D 索取数据块， 但 B 同时也向C和D传送数据块，D和C还互相传送数据块。由于P2P对等用户的数量非 常多，因此，从不同的对等方获得不同的数据块，然后组装成整个的文件，一般要比仅从一 个地方下载整个的文件要快很多。 对等方A 对等方 对等方 B 图例： 数据块 数据块传送 对等方C 图6-34 对等方之间互相传送文件数据块</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>然而 A 必须做出两个重要决定。第一，哪些文件块是首先需要向其相邻对等方请求 的？第二，在很多向 A 请求文件块的相邻对等方中，A应当向哪些相邻对等方发送所请求 的文件块？ 对于第一个问题，A要使用叫做最稀有的优先（rarest first）的技术。我们知道，凡是A所 缺少的而正好相邻对等方已拥有的文件块，都应当去索取。可能其中的某些文件块，很多相 邻对等方都有（即文件块的副本很多），这就是“不稀有的”文件块，以后可慢慢请求。如 果 A 所缺少的文件块在相邻对等方中的副本很少，那就是“很稀有的”。因此，A 首先应当 请求副本最少的文件块（即最稀有的）。否则，一旦拥有最稀有文件块的对等方退出了洪 流，就会影响A对所缺文件块的收集。 对于第二个问题，BT 采用了一种更加机灵的算法，其基本思想就是：凡当前有以最高 数据率向 A 传送文件块的某相邻对等方，A就优先把所请求的文件块传送给该相邻对等 方。具体来说，A 持续地测量从其相邻对等方接收数据的速率，并确定速率最高的4个相邻 对等方。接着，A就把文件块发送给这4个相邻对等方。每隔10秒钟，A 还要重新计算数 据率，然后可能修改这4个对等方。在 BT 的术语中，这4个对等方叫做已疏通的或无障碍</p> <p>的（unchoked）对等方。更重要的是，每隔30秒，A要随机地找一个另外的相邻对等方 B，并 向其发送文件块。这样，A有可能成为B的前4位上传文件块的提供者。在此情况下，B 也有可能向 A 发送文件块。如果B发送文件的速率足够快，那么B也有可能进入A的前 4 位上传文件块的提供者。这样做的结果是，这些对等方相互之间都能够以令人满意的速率 交换文件块。</p> <h3 id="93-p2p-文件分发的分析">9.3 P2P 文件分发的分析</h3> <p>我们从一个例子开始，来讨论 P2P 文件分发中的几个重要概念[KURO13]。 在图 6-35 中，有N台主机要从互联网上的服务器下载一个大文件，其长度为 F bit。在 图中我们把这个文件也记为F。按照习惯，从互联网传送数据到主机，叫做下载 （download），而反过来传送数据，即从主机向互联网传送，则称为上传（upload）或上载。服务 器的文件是供互联网上的用户享用的，因此服务器的文件只是单方向上传到互联网。我们把 服务器的上传速率记为us，单位是bit/s。再假定主机与互联网连接的链路的上传速率和下载 速率分别为 u； 和d，单位都是bit/s。我们还假定互联网的核心部分不会产生拥塞。瓶颈只 会发生在服务器的接入链路，或者是某些主机的接入链路。 62 d2 d₁ dN UN 文件 F 互联网 Из 5 ds 服务器 图6-35 文件分发的例子</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"></div> <p>我们先在传统的客户服务器方式下，计算给所有主机分发完毕的最短时间 Tes。 从服务器端考虑，N 台主机共需要从服务器得到的数据总量（比特数）是NF。如果服 务器能够不停地以其上传速率us向各主机传送数据，一直到各主机都收到文件 F，就需要 时间 NF/us，单位是秒。由此可见，不可能小于 NF/us 如果 N 台主机都以各自的下载速率不停地下载文件F，那么下载速率最慢的主机（设 其下载速率为 dmin）的下载文件时间（F/dmin），将是N个下载时间中最大的一个。由此可 见，Tas也不可能小于 F/dmin。 如果 NF/us ≥ F/dmin，则瓶颈在服务器端的接入链路。这时 Tes = NF/us。 如果 F/dmin ≥ NF/us，则瓶颈在下载最慢的主机的接入链路。这时Tes = F/dmin。 由此可得出所有主机都下载完文件F的最少时间是</p> <p>NF F Tes = max- us da min （6-2） 从以上分析可以看出，若公式（6-2）括号中的第一项远大于第二项，则 Ts近似与主机数 N成正比。如果主机数增大1000倍，那么文件的分发时间也要增大 1000 倍。 下面讨论在 P2P方式下，文件全部分发完毕的最少时间 Tp2p。然而在P2P方式下，文 件分发所需的时间较难计算，这是因为每一台主机在接收文件的同时，还利用自己的上传能 力向其他主机传送文件。文件传送所需的时间取决于主机向对等方传送文件的具体方式。但 是，我们还是可以导出文件分发所需的最少时间的表达式。 在文件分发开始时，只有服务器有文件F。服务器必须把文件F的每一个比特通过接入 链路传送到互联网（至少要传送一次）。因此文件分发的最少时间不可能小于F/us。和客户- 服务器方式相比，在P2P方式下，服务器不需要一遍一遍地发送文件F，因为互联网上的其 他主机（即对等方）可以代替服务器向其他对等方分发文件 F。 在 P2P 方式下，下载速率最慢的主机（设其下载速率为dmin）下载文件 F 的时间是 F/dmin，这是 N个对等方下载时间中最大的一个。可见文件分发的最少时间不可能小于 F/dmin。这个结论和客户服务器方式是一样的。 整个系统中所有主机（包括服务器）的上传速率之和是ur=us+U1+U2+。。。+uyo因 此，文件分发的最少时间也不可能小于 NF/uTo 这样，我们得出在P2P方式下所有主机都下载完文件F的最少时间的下限是 F F NF Tpzp≥max- us d UT min （6-3） 在公式（6-3）的推导过程中，我们假定每一个对等方只要收到一个比特就立即上传到互 联网的其他对等方。但实际上是把收到的若干个比特组成一个数据块后再上传出去。但是当 文件 F 很大时，我们也可以在公式（6-3）中取等号，作为文件F的最少分发时间 Tpzp的近似 值。 有一种情况最值得我们注意。这就是对等方的数目N非常大，因此在公式（6-3）的括号 中的最后一项的值将远大于前两项的值。这样，Tpzp值的下限就近似为NF/uT 我们再假定一些数据。设所有的对等方的上传速率都是u，并且 Flu ==== 1 小时，所有对 等方的下载速率都不小于服务器的上传速率，因而不会对我们的计算产生影响。我们还设服 务器的上传速率us=10u。当N=30时，用公式（6-3）算出所有主机都下载完文件F的最少时 间的下限是 Tp2p = 0。75 F/u= 0。75小时&lt;1小时（不管多大）。如果采用客户-服务器方 式，则当N=30时，所有主机都下载完文件F的最少时间是Ts=NF/us=3小时。</p> <h3 id="94-在-p2p-对等方中搜索对象">9.4 在 P2P 对等方中搜索对象</h3> <p>在 P2P 文件系统中，对等方用户的数量非常多，并且处于一种无序的状态。任何一个 对等方可以随时加入进来或随时退出。在这种情况下，怎样有效地找到所需的文件，也就是 怎样有效地定位对等方及其资源，乃是P2P系统中的一个十分重要的问题。 限于篇幅，我们在这里只简单介绍一下怎样利用散列函数来定位对等方。 我们知道，Gnutella 是一种采用全分布方法定位内容的P2P文件共享应用程序，它解决</p> <p>了集中式目录服务器所造成的瓶颈问题。然而 Gnutella 是在非结构化的覆盖网络中采用查询 洪泛的方法来进行查找的，因此查找的效率较低。现在比较好的查找方法是设法构建一种分 布式数据库，以进行对等方及其资源的定位。这种分布式数据库在概念上并不复杂，只要能 够支持大量对等方（可能有几百万个）进行索引查找即可。存储在数据库中的信息只有两个 部分： （1）要查找的资源名K（例如，电影或歌曲的名字）。资源名也可称为关键字。 （2）存放该对象的结点的IP地址N。有的IP地址还附带有端口号。 存放在数据库中的信息就是大量成对出现的（资源名 K，结点的 IP 地址 N）。在查找某 资源名 K 时，只要在数据库中查找到匹配的资源名K，数据库就能够返回对应的结点的 IP 地址 N。所以问题的关键就是要设法把每个资源名K 存放在一个非常便于查找的地方。 细心的读者可能会联想到曾在前面 6。1 节讨论的 DNS 域名系统。DNS 是根据主机的域 名来查找其 IP 地址，这和 P2P 的情况有相似之处。但我们知道，主机的域名是结构化的命 名系统，因此域名服务器可以划分为几种不同的级别（如根服务器等）便于查找。但 P2P 系统则不同，其资源名是非结构化的。因此不能套用DNS的那种查找方法。 前面已经讲过，Napster 在一个集中式目录服务器中构建的查找数据库虽然很简单，但 性能上却有瓶颈。在 P2P 系统中，应怎样构建分布式的P2P数据库？让每个对等方都拥有 所有对等方 IP 地址的列表是不可行的。让所有成对出现的（资源名 K， IP 地址 N）随机地分 散到各对等方也是不可行的。因为这将使查找对象的次数过大，无法使用。现在广泛使用的 索引和查找技术叫做分布式散列表 DHT （Distributed Hash Table）。DHT 也可译为分布式哈希 表，它是由大量对等方共同维护的散列表。基于 DHT 的具体算法已有不少，如 Chord， Pastry，CAN （Content Addressable Network），以及Kademilia 等。下面简单介绍广泛使用的 Chord 算法，这是美国麻省理工大学于2001年提出的[STOI01]。 分布式散列表 DHT 利用散列函数，把资源名K及其存放的结点IP地址N都分别映射 为资源名标识符 KID 和结点标识符 NID。如果所有的对等方都使用散列函数 SHA-1（我们 在下一章 7。4。1 节还要介绍 SHA-1 在网络安全方面的应用），那么通过散列得出的标识符 KID 和 NID 都是 160位二进制数字，且其数值范围在[0， 2’60 - 1]之间。虽然从理论上讲，散 列函数 SHA-1 是多对一的函数，但实际上不同输入得到相同的输出的概率是极小的。此 外，通过 SHA-1 映射得到的标识符能够比较均匀而稀疏地分布在 Chord 环上。为便于讨 论，我们假定现在标识符只有5位二进制数字，也就是说，所有经散列函数得出的标识符的 数值范围都在[0， 31]之间。Chord 把结点按标识符数值从小到大沿顺时针排列成一个环形覆 盖网络（见图 6-36（a）），并按照下面的规则进行映射： （1） 结点标识符 NID 按照其标识符值映射到 Chord 环上对应的点，见图 6-36（a）中标有 NID 的小圆点，如 N4， N7， N10， N20， N26 和 N30。 （2） 资源名标识符 KID 则按照其标识符值映射到与其值最接近的下一个 NID，见图 6- 36（a）中标有 KID 的小方块。所谓“最接近的下一个”NID 就是指：从KID值开始，按顺时 针方向沿 Chord 环遇到的下一个 NID。例如，K31 和K2应放在N4，因为在环上从 31 和 2 按顺时针方向遇到的下一个 NID 是 N4。同理，K8，K12，K23 和K29应分别放在N10， N20， N26 和 N30。如果碰巧同时出现 K29和N29（这种概率极小），那么K29 就应当放在 N29。 请注意：在图 6-36中，K31 和K2 都放在N4，这表示要查找存放资源K31 或 K2 的结 点的 IP 地址，就应当到结点N4去查找。请注意，资源 K31 和 K2 并非存放在结点 N4。</p> <p>这就是说，每个资源由 Chord 环上与其标识符值最接近的下一个结点提供服务。我们 再强调一下，Chord 环并非实际的网络。在 Chord环上相邻的结点，在地理上很可能相距非 常远。 N30 K31 K2 N30 K31 K2 图例：ONID K29 31 0 1 30 2 K29 29 3 N4 KID 30 31 0 1 2 K23 ☑ 29 1N4 28 28 N26 27 27 6 26 K23 25 7ON7 25 70N7 8 8 24 24 9 9 23 23 K8 K8 10 10 22 22 11 N10 11 N10 21 21 20 20 N20 19 N20 K12 18 17 16 15 （a） KID 和 NID映射在环上 18 17 16 15 -K12 N13 （b）N13加入，N26退出 图 6-36 基于 DHT 的 Chord 环</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <p>Chord 环上的每一个结点都要维护两个指针变量，一个指向其后继结点，而另一个指向 其前任结点。例如，在图 6-36（a）中，N10 的后继结点是N20（沿顺时针方向 N10 的下一个 结点），其前任结点是N7（沿逆时针方向N10之前的一个结点）。如果一个新的结点 N13 加 入进来，那么 N20 的前任结点就变为N13，因而 K12 就要从N20的位置移到 N13，同时 N10 的后继结点就变为N13（见图6-36（b））。此外，如果结点 N26 退出，那么 K23 就要移 到N30，而N30 的前任结点就变为N20，同时N20的后继结点变为N30。 在这样的 Chord 环上查找资源，从理论上讲，任何一个结点，只要从其后继结点一个 个地遍历查找下去，一定可以找到所查询的资源。可见要定位一个资源，平均需要沿环发送 查找报文 N/2 个，或遍历 O（N）个结点（N为环上的总结点数）。显然，这种顺序查找的方法 效率很低。 = 为了加速查找，在 Chord 环上可以增加一些指针表（finger table），它又称为路由表或查 找器表。若 Chord 环上的标识符有 m 位（现在 m 5），则在结点n上的指针表可设置不超 过 m 个指针，指向其后继的结点。我们先看图 6-37中结点 N4的指针表。指针表中的第2 列是从 N4 可以指向的多个后继结点。本来每一个结点仅仅指向沿顺时针方向的下一个后继 结点，但现在则指向多个后继结点（在本例中就是 N7，N10 和N20）。第1列的第i行是计 算 （N4 + 2’-‘），用来得出后继结点。例如，第4行 i = 4，算出（N4 + 2-1） = N4 + 8 = 12，而 Chord 环上的结点 12 的后继结点是N20。图中还画出了从 N4 到这几个后继结点的 连线（这些连线就是 Chord 环上的弦，Chord 名字由此得出）。还有一点要注意的是，在 N20 的指针表中的第5行，N20+16=36，但按照模 2‘运算，36 mod 2 = 4，恰好结点4的 后继结点是N4。 假定在图 6-37 中的结点 N4 要查找 K29。如果用遍历各结点的方法，则要查找 5 次， 即 N7→N10→N20→N29→N30。但若利用指针表，则 N4 首先在自己的指针表中寻找在不 到 29 且最接近 29 的结点，即N20，然后把定位资源 K29 的请求发送给 N20。在 N20 的指 针表中继续类似的寻找。结果是：最接近29的结点是N30。这就是存放资源 K29 的结点。 这种查找方法类似于二分查找，只用了两次查找，定位一个资源仅需 O（logz）步。</p> <p>N30 K31 K2 图例： ● NID N4 的指针表 K29 31 0 1 2 KID N4 29 N4 + 1 |N7 28 N4 + 2 NZ N26 N4 + 4 N10 K23 ONG N4 + 8 |N20 8 N4+16 N20 24 N20 的指针表 23 K8 N20+1 N26 N20+2 N26 11 JN10 N20+4 N26 12 19 13 N20+8 N30 N20 |N20+16 N4 K12 图6-37 结点 N4 和N20 的指针表 在 P2P 网络中，对等方可能相当频繁地加入或退出系统，这就需要很好地维护这个分 布式数据库（维护各结点的指针和指针表），而这种维护的工作量可能会很大。当对等方数 量非常大时，究竟采用何种查询机制更加合理，则需要根据具体情况来确定。 P2P 技术还在不断地改进，但随着 P2P 文件共享程序日益广泛地使用，也产生了一系列 的问题有待于解决。这些问题已迫使人们要重新思考下一代互联网应如何演进。例如，音频 /视频文件的知识产权就是其中的一个问题。又如，当非法盗版的、或不健康的音频/视频文 件在互联网上利用 P2P 文件共享程序广泛传播时，要对P2P的流量进行有效的管理，在技 术上还是有相当的难度。由于现在 P2P 文件共享程序的大量使用，已经消耗了互联网主干 网上大部分的带宽。因此，怎样制定出合理的收费标准，既能够让广大网民接受，又能使网 络运营商赢利并继续加大投入，也是目前迫切需要解决的问题。</p> <h2 id="十本章的重要概念">十、本章的重要概念</h2> <p>应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于不同主机中的 多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所 遵循的协议。应用层的许多协议都是基于客户服务器方式的。客户是服务请求方， 服务器是服务提供方。 域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。DNS 是一个联机分布式数据库系统，并采用客户服务器方式。 域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序（即域名服务 器）共同完成的。 互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器， 都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制IP 地址中的 点没有关系。 域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服 务器。 文件传送协议 FTP 使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客戶 和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接。实际用于传输 文件的是数据连接。 万维网 WWW 是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网</p> <p>• 上的一个站点链接到另一个站点。 万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回 客户所要的万维网文档。在客户程序主窗口上显示出的万维网文档称为页面。 万维网使用统一资源定位符 URL 来标志万维网上的各种文档，并使每一个文档在整 个互联网的范围内具有唯一的标识符 URL。 万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议 HTTP。HTTP 使用TCP连接进行可靠的传送。但HTTP协议本身是无连接、无状 态的。HTTP/1。1协议使用了持续连接（分为非流水线方式和流水线方式）。 万维网使用超文本标记语言 HTML 来显示各种万维网页面。 万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的 过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时 才由应用程序动态创建的。 活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可 连续地改变屏幕的显示。 • 在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索 搜索引擎和分类目录搜索引擎两大类。 • 电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发送 到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自 己使用的邮件服务器进行读取，相当于“电子信箱”。 一个电子邮件系统有三个主要组成构件，即：用户代理、邮件服务器，以及邮件协 议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和IMAP）。用户代 理和邮件服务器都要运行这些协议。 电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的 视窗界面来发送和接收邮件。 从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送，都要使用 SMTP 协议。但用户代理从邮件服务器读取邮件时，则要使用 POP3（或IMAP） 协议。 基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏览器和邮件服 务器之间的邮件传送使用 HTTP 协议，而在邮件服务器之间邮件的传送仍然使用 SMTP 协议。 简单网络管理协议 SNMP 由三部分组成，即（1） SNMP 本身，负责读取和改变各代 理中的对象名及其状态数值；（2）管理信息结构 SMI，定义命名对象和定义对象类 型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的基本编码规 则 BER；（3） 管理信息库 MIB，在被管理的实体中创建了命名对象，并规定了其类 型。 系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称 为应用编程接口API。API就是应用程序和操作系统之间的接口。 • 套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而 与操作系统进行交互时使用的一种机制。 目前 P2P 工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应 用所占的比例大得多。 • BT 是很流行的一种P2P应用。BT采用“最稀有的优先”的技术，可以尽早把最 稀有的文件收集到。此外，凡有当前以最高数据率向某个对等方传送文件块的相 邻对等方，该对等方就优先把所请求的文件传送给这些相邻对等方。这样做的结 果是，这些对等方相互之间都能够以令人满意的速率交换文件块。 当对方的数量很大时，采用P2P方式下载大文件，要比传统的客户服务器方式 快得多。 • 在P2P 应用中，广泛使用的索引和查找技术是分布式散列表DHT。</p>]]></content><author><name></name></author><category term="blog"/><category term="computer"/><category term="networks"/><category term="application layer"/><category term="OSI"/><summary type="html"><![CDATA[每个应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程间的通信和协同工作来完成。应用进程间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规则。具体来说，应用层协议应当定义：]]></summary></entry><entry><title type="html">计算机网络 - 运输层</title><link href="https://feng-zhang0712.github.io//blog/2024/transport-layer/" rel="alternate" type="text/html" title="计算机网络 - 运输层"/><published>2024-09-14T00:00:00+00:00</published><updated>2024-09-14T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/transport-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/transport-layer/"><![CDATA[<p>本章先概括介绍运输层协议的特点、进程之间的通信和端口等重要概念，然后讲述比较简单的 UDP 协议。其余的篇幅都是讨论较为复杂但非常重要的 TCP 协议和可靠传输的工作原理，包括停止等待协议和 ARQ 协议。在详细讲述 TCP 报文段的首部格式之后，讨论 TCP 的三个重要问题：滑动窗口、流量控制和拥塞控制机制。最后，介绍 TCP 的连接管理。</p> <p><strong>运输层</strong>是整个网络体系结构中的关键层次之一。一定要弄清以下一些重要概念：</p> <ul> <li>运输层为相互通信的应用进程提供逻辑通信。</li> <li>端口和套接字的意义。</li> <li>无连接的 UDP 的特点。</li> <li>面向连接的 TCP 的特点。</li> <li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议。</li> <li>TCP 的滑动窗口、流量控制、拥塞控制和连接管理。</li> </ul> <h2 id="一运输层协议概述">一、运输层协议概述</h2> <h3 id="11-进程之间的通信">1.1 进程之间的通信</h3> <p>从通信和信息处理的角度看，<strong>运输层向它上面的应用层提供通信服务</strong>，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p> <p>下面通过图 5-1 的示意图来说明运输层的作用。设局域网 \(LAN_1\) 上的主机 <code class="language-plaintext highlighter-rouge">A</code> 和局域网 \(LAN_2\) 上的主机 <code class="language-plaintext highlighter-rouge">B</code> 通过互连的广域网 WAN 进行通信。我们知道，IP 协议能够把源主机 <code class="language-plaintext highlighter-rouge">A</code> 发送出的分组，按照首部中的目的地址，送交到目的主机 <code class="language-plaintext highlighter-rouge">B</code>，那么，为什么还需要运输层呢？</p> <p>从 IP 层来说，通信的两端是两台主机。IP 数据报的首部明确地标志了这两台主机的 IP 地址。但“两台主机之间的通信”这种说法还不够清楚。这是因为，真正进行通信的实体是在主机中的进程，是这台主机中的一个<strong>进程</strong>和另一台主机中的一个<strong>进程</strong>在交换数据（即通信）。因此严格地讲，两台主机进行通信就是两台主机中的<strong>应用进程互相通信</strong>。IP 协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。从运输层的角度看，<strong>通信的真正端点并不是主机而是主机中的进程</strong>。也就是说，<strong>端到端的通信</strong>是应用进程之间的通信。在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。在图 5-1 中，主机 <code class="language-plaintext highlighter-rouge">A</code> 的应用进程 \(AP_1\) 和主机 <code class="language-plaintext highlighter-rouge">B</code> 的应用进程 \(AP_3\) 通信，而与此同时，应用进程 \(AP_2\) 也和对方的应用进程 \(AP_4\) 通信。这表明运输层有一个很重要的功能——<strong>复用</strong>（multiplexing）和<strong>分用</strong>（demultiplexing）。</p> <ul> <li><strong>复用</strong>：指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部）。比如，应用层所有的应用进程都可以通过运输层再传送到 IP 层（网络层）。</li> <li><strong>分用</strong>：指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。比如，运输层从 IP 层收到发送给各应用进程的数据后，必须分别交付指明的各应用进程。</li> </ul> <p>图 5-1 中两个运输层之间有一个双向粗箭头，写明“<strong>运输层提供应用进程间的逻辑通信</strong>”。“逻辑通信”的意思是：从应用层来看，只要把应用层报文交给下面的运输层，运输层就可以把这些报文传送到对方的运输层，<strong>好像这种通信就是沿水平方向直接传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。数据的传送是沿着图中的虚线方向（经过多个层次）传送的</strong>。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-transport-layer-provides-logical-communication-for-application-processes-that-communicate-with-each-other-480.webp 480w,/assets/images/computer-network/the-transport-layer-provides-logical-communication-for-application-processes-that-communicate-with-each-other-800.webp 800w,/assets/images/computer-network/the-transport-layer-provides-logical-communication-for-application-processes-that-communicate-with-each-other-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-transport-layer-provides-logical-communication-for-application-processes-that-communicate-with-each-other.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="运输层为相互通信的应用进程提供了逻辑通信" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-1 运输层为相互通信的应用进程提供了逻辑通信 </div> <p>从这里可以看出网络层和运输层有明显的区别。<strong>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信</strong>（见图 5-2）。</p> <p>运输层还要对收到的报文进行<strong>差错检测</strong>。在网络层，IP 数据报首部中的检验和字段，只检验首部是否出现差错而不检查数据部分。根据应用程序的不同需求，运输层需要有两种不同的运输协议，即<strong>面向连接的 TCP</strong> 和<strong>无连接的 UDP</strong>。</p> <p><strong>运输层向高层用户屏蔽了下面网络核心的细节</strong>（如网络拓扑、所采用的路由选择协议等），<strong>它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道</strong>，但这条逻辑通信信道上层的表现却因运输层使用的不同协议而有很大的差别。当运输层<strong>采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的</strong>（只提供尽最大努力服务），但这种逻辑通信信道就相当于<strong>一条全双工的可靠信道</strong>。但当运输层<strong>采用无连接的 UDP 协议</strong>时，这种逻辑通信信道仍然是一条<strong>不可靠信道</strong>。</p> <div class="row justify-content-center"> <div class="col-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/major-differences-between-transport-layer-protocols-and-network-layer-protocols-480.webp 480w,/assets/images/computer-network/major-differences-between-transport-layer-protocols-and-network-layer-protocols-800.webp 800w,/assets/images/computer-network/major-differences-between-transport-layer-protocols-and-network-layer-protocols-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/major-differences-between-transport-layer-protocols-and-network-layer-protocols.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="运输层协议和网络层协议的主要区别" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-2 运输层协议和网络层协议的主要区别 </div> <h3 id="12-运输层的两个主要协议">1.2 运输层的两个主要协议</h3> <p>TCP/IP 运输层的两个主要协议都是互联网的正式标准，即：</p> <ul> <li><strong>用户数据报协议</strong> UDP（User Datagram Protocol）[RFC 768]</li> <li><strong>传输控制协议</strong> TCP（Transmission Control Protocol）[RFC 793]</li> </ul> <p>图 5-3 给出了这两种协议在协议栈中的位置。</p> <div class="row justify-content-center"> <div class="col-3"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/transport-layer-protocol-in-tcp-ip-system-480.webp 480w,/assets/images/computer-network/transport-layer-protocol-in-tcp-ip-system-800.webp 800w,/assets/images/computer-network/transport-layer-protocol-in-tcp-ip-system-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/transport-layer-protocol-in-tcp-ip-system.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP/IP 体系中的运输层协议" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-3 TCP/IP 体系中的运输层协议 </div> <p>按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做<strong>运输协议数据单元</strong> TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 <strong>TCP 报文段</strong>或 <strong>UDP 用户数据报</strong>。</p> <ul> <li>UDP 在传送数据之前<strong>不需要先建立连接</strong>。远地主机的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。</li> <li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</li> </ul> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/various-application-and-application-layer-protocols-using-UDP-and-TCP-protocols-480.webp 480w,/assets/images/computer-network/various-application-and-application-layer-protocols-using-UDP-and-TCP-protocols-800.webp 800w,/assets/images/computer-network/various-application-and-application-layer-protocols-using-UDP-and-TCP-protocols-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/various-application-and-application-layer-protocols-using-UDP-and-TCP-protocols.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="使用 UDP 和 TCP 协议的各种应用和应用层协议" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 5-1 使用 UDP 和 TCP 协议的各种应用和应用层协议 </div> <h3 id="13-运输层的端口">1.3 运输层的端口</h3> <p>给应用层的每个应用进程赋予一个非常明确的标志是至关重要的。为了使运行不同操作系统的计算机的应用进程能够互相通信，必须用统一的方法（而这种方法必须与特定操作系统无关）对 TCP/IP 体系的应用进程进行标志。做法是在运输层使用<strong>协议端口号</strong>（protocol port number），或通常简称为<strong>端口</strong>（port）。这就是说，虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 或 UDP 根据其首部中的目的端口号把数据交付应用层的目的应用进程。</p> <p>注意，这种<strong>在协议栈层间的抽象的协议端口是软件端口</strong>，和路由器或交换机上的硬件端口是完全不同的概念。硬件端口是<strong>不同硬件设备</strong>进行交互的接口，而<strong>软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址</strong>。</p> <p>TCP/IP 的运输层用一个 16 位<strong>端口号</strong>来标志一个端口。<strong>端口号只具有本地意义</strong>，它只是为了标志<strong>本计算机</strong>应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是<strong>没有关联</strong>的。16 位的端口号可允许有 65535 个不同的端口号，这个数目对一个计算机来说是足够用的。</p> <p>由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且要知道对方的端口号（为了找到对方计算机中的应用进程）。互联网上的计算机通信是采用客户-服务器方式。客户在发起通信请求时，必须先知道对方服务器的 IP 地址和端口号。因此运输层的端口号分为下面的两大类。</p> <h4 id="1服务器端使用的端口号">（1）服务器端使用的端口号</h4> <p>这里又分为两类，最重要的一类叫做<strong>熟知端口号</strong>（well-known port number）或<strong>系统端口号</strong>，数值为 0 ~ 1023。这些数值可在网址 <a href="www.iana.org"><code class="language-plaintext highlighter-rouge">www.iana.org</code></a> 查到。IANA 把这些端口号指派给了 TCP/IP 最重要的一些应用程序，让所有的用户都知道。当一种新的应用程序出现后，IANA 必须为它指派一个熟知端口，否则互联网上的其他应用进程就无法和它进行通信。</p> <div class="row justify-content-center"> <div class="col-10"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/commonly-used-port-number-480.webp 480w,/assets/images/computer-network/commonly-used-port-number-800.webp 800w,/assets/images/computer-network/commonly-used-port-number-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/commonly-used-port-number.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="常用的熟知端口号" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 5-2 常用的熟知端口号 </div> <p>另一类叫做<strong>登记端口号</strong>，数值为 1024 ~ 49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在 IANA 按照规定的手续登记，以防止重复。</p> <h4 id="2客户端使用的端口号">（2）客户端使用的端口号</h4> <p>数值为 49152 ~ 65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做<strong>短暂端口号</strong>。这类端口号留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已使用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。</p> <h2 id="二用户数据报协议-udp">二、用户数据报协议 UDP</h2> <h3 id="21-udp-概述">2.1 UDP 概述</h3> <p>用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即<strong>复用</strong>、<strong>分用</strong>以及<strong>差错检测</strong>的功能。UDP 的主要特点是：</p> <ul> <li>UDP 是<strong>无连接的</strong>，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。</li> <li>UDP 使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。</li> <li>UDP 是<strong>面向报文</strong>的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文，如图 5-4 所示。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP 一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP层在传送时可能要进行分片，这会降低 IP 层的效率。反之，若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。</li> </ul> <div class="row justify-content-center"> <div class="col-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/udp-is-packet-oriented-480.webp 480w,/assets/images/computer-network/udp-is-packet-oriented-800.webp 800w,/assets/images/computer-network/udp-is-packet-oriented-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/udp-is-packet-oriented.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="UDP 是面向报文的" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-4 UDP 是面向报文的 </div> <ul> <li>UDP <strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很多的实时应用（如 IP 电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP 正好适合这种要求。</li> <li>UDP <strong>支持一对一，一对多、多对一和多对多的交互通信</strong>。</li> <li>UDP 的<strong>首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li> </ul> <p>虽然某些实时应用需要使用没有拥塞控制的 UDP，但当很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，结果大家都无法正常接收。因此，不使用拥塞控制功能的 UDP 有可能会引起网络产生严重的拥塞问题。还有一些使用 UDP 的实时应用，需要对 UDP 的不可靠的传输进行适当的改进，以减少数据的丢失。在这种情况下，应用进程本身可以在不影响应用的实时性的前提下，增加一些提高可靠性的措施，如采用前向纠错或重传已丢失的报文。</p> <h3 id="22-udp-的首部格式">2.2 UDP 的首部格式</h3> <p>用户数据报 UDP 有两个字段：<strong>数据字段</strong>和<strong>首部字段</strong>。首部字段很简单，只有 8 个字节（图 5-5），由四个字段组成，<strong>每个字段的长度都是两个字节</strong>。各字段意义如下：</p> <ul> <li><strong>源端口</strong>：源端口号。在需要对方回信时选用。不需要时可用全 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><strong>目的端口</strong>：目的端口号。这在终点交付报文时必须使用。</li> <li><strong>长度</strong>：UDP 用户数据报的长度，其最小值是 <code class="language-plaintext highlighter-rouge">8</code>（仅有首部）。</li> <li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错。有错就丢弃。</li> </ul> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/header-and-pseudo-header-of-a-udp-user-datagram-480.webp 480w,/assets/images/computer-network/header-and-pseudo-header-of-a-udp-user-datagram-800.webp 800w,/assets/images/computer-network/header-and-pseudo-header-of-a-udp-user-datagram-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/header-and-pseudo-header-of-a-udp-user-datagram.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="UDP 用户数据报的首部和伪首部" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-5 UDP 用户数据报的首部和伪首部 </div> <p>当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程。图 5-6 是 UDP 基于端口分用的示意图。</p> <div class="row justify-content-center"> <div class="col-4"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/udp-is-port-based-splitting-480.webp 480w,/assets/images/computer-network/udp-is-port-based-splitting-800.webp 800w,/assets/images/computer-network/udp-is-port-based-splitting-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/udp-is-port-based-splitting.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="UDP 基于端口的分用" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-6 UDP 基于端口的分用 </div> <p>如果接收方 UDP 发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程），就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。</p> <p>注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字（TCP 之间的通信必须要在两个套接字之间建立连接）。</p> <p>在计算检验和时，要在 UDP 用户数据报之前增加 <code class="language-plaintext highlighter-rouge">12</code> 个字节的<strong>伪首部</strong>。所谓“伪首部”是因为这种伪首部并不是 UDP 用户数据报真正的首部。只是在计算检验和时，临时添加在 UDP 用户数据报前面，得到一个临时的 UDP 用户数据报。检验和就是按照这个临时的 UDP 用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。图 5-5 的最上面给出了伪首部各字段的内容。UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。但不同的是：IP 数据报的检验和只检验 IP 数据报的首部，但 UDP 的检验和是<strong>把首部和数据部分一起都检验</strong>。</p> <ul> <li>在发送方，首先是先把全 <code class="language-plaintext highlighter-rouge">0</code> 放入检验和字段。再把伪首部以及 UDP 用户数据报看成是由许多 16 位的字串接起来的。若 UDP 用户数据报的数据部分不是偶数个字节，则要填入一个全 <code class="language-plaintext highlighter-rouge">0</code> 字节（但此字节不发送）。然后按二进制反码计算出这些 16 位字的和。将此和的二进制反码写入检验和字段后，就发送这样的 UDP 用户数据报。</li> <li>在接收方，把收到的 UDP 用户数据报连同伪首部（以及可能的填充全零字节）一起，按二进制反码求这些 16 位字的和。当无差错时其结果应为全 <code class="language-plaintext highlighter-rouge">1</code>。否则就表明有差错出现，接收方就应丢弃这个 UDP 用户数据报（也可以上交给应用层，但附上出现了差错的警告）。</li> </ul> <p>图 5-7 给出了一个计算 UDP 检验和的例子。这里假定用户数据报的长度是 <code class="language-plaintext highlighter-rouge">15</code> 字节，因此要添加一个全 <code class="language-plaintext highlighter-rouge">0</code> 的字节。这种简单的差错检验方法的检错能力并不强，但它的好处是简单，处理起来较快。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/example-of-calculating-udp-checksum-480.webp 480w,/assets/images/computer-network/example-of-calculating-udp-checksum-800.webp 800w,/assets/images/computer-network/example-of-calculating-udp-checksum-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/example-of-calculating-udp-checksum.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="计算 UDP 检验和的例子" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-7 计算 UDP 检验和的例子 </div> <p>如图 5-5 所示，伪首部的第 <code class="language-plaintext highlighter-rouge">3</code> 字段是全 <code class="language-plaintext highlighter-rouge">0</code>；第 4 字段是 IP 首部中的协议字段的值。以前已讲过，对于 UDP，此协议字段值为 <code class="language-plaintext highlighter-rouge">17</code>；第 5 字段是 UDP 用户数据报的长度。因此，这样的检验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及 UDP 用户数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。</p> <h2 id="三传输控制协议-tcp-概述">三、传输控制协议 TCP 概述</h2> <h3 id="31-tcp-最主要的特点">3.1 TCP 最主要的特点</h3> <ul> <li>TCP 是<strong>面向连接的运输层协议</strong>。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。</li> <li>每条 TCP 连接只能有两个<strong>端点</strong>（endpoint），每条 TCP 连接只能是点对点的（一对一）。</li> <li>TCP 提供<strong>可靠交付</strong>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li> <li>TCP 提供<strong>全双工通信</strong>。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序把数据传送给 TCP 的缓存，TCP 在合适的时候把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</li> <li><strong>面向字节流</strong>。TCP 中的“<strong>流</strong>”（stream）指的是<strong>流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交付下来的数据仅仅看成是一连串的<strong>无结构的字节流</strong>。TCP 并不知道所传送的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的 TCP 共 10 个数据块，但接收方的 TCP 可能只用了 4 个数据块就把收到的字节流交付上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。图 5-8 是上述概念的示意图。</li> </ul> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/tcp-byte-stream-oriented-concept-480.webp 480w,/assets/images/computer-network/tcp-byte-stream-oriented-concept-800.webp 800w,/assets/images/computer-network/tcp-byte-stream-oriented-concept-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/tcp-byte-stream-oriented-concept.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 面向字节流的概念" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-8 TCP 面向字节流的概念 </div> <p>图 5-8 中的 TCP 连接是一条<strong>虚连接</strong>（也就是<strong>逻辑连接</strong>），而不是一条真正的物理连接。TCP 报文段先要传送到 IP 层，加上 IP 首部后，再传送到数据链路层。再加上数据链路层的首部和尾部后，才离开主机发送到物理链路。图 5-8 指出，TCP 和 UDP 在发送报文时所采用的方式完全不同。TCP 并不关心应用进程一次把多长的报文发送到 TCP 的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。如果应用进程传送到 TCP 缓存的数据块太长，TCP 就可以把它划分短一些再传送。如果应用进程一次只发来一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</p> <h3 id="32-tcp-的连接">3.2 TCP 的连接</h3> <p>TCP 把<strong>连接</strong>作为<strong>最基本的抽象</strong>。每条 TCP 连接有两个<strong>端点</strong>。TCP 连接的端点叫做<strong>套接字</strong>（socket）或<strong>插口</strong>。根据 RFC 793 的定义：端口号<strong>拼接到</strong>（concatenated with）IP 地址即构成了套接字。因此，套接字的表示方法是在点分十进制的 IP 地址后面写上端口号，中间用冒号或逗号隔开。例如，若 IP 地址是 192.3.4.5 而端口号是 80，那么得到的套接字就是（192.3.4.5:80）。</p> \[套接字 socket =（IP 地址: 端口号）\] <p><strong>每条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定</strong>。即：</p> \[TCP 连接 ::= \{socket_1，socket_2\} = \{（IP_1: prot_1），（IP_2: prot_2）\}\] <p>这里 \(IP_1\) 和 \(IP_2\) 分别是两个端点主机的 IP 地址，而 \(prot_1\) 和 \(prot_2\) 分别是两个端点主机中的端口号。TCP 连接的两个套接字就是 \(socket_1\) 和 \(socket_2\)。可见套接字 socket 是个很抽象的概念。</p> <ul> <li><strong>TCP 连接的端点是个很抽象的套接字</strong>，即（<strong>IP 地址: 端口号</strong>）。</li> <li>同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中。</li> </ul> <h2 id="四可靠传输的工作原理">四、可靠传输的工作原理</h2> <p>理想的传输条件有以下两个特点：</p> <ol> <li>传输信道不产生差错。</li> <li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li> </ol> <p>在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。然而实际的网络都不具备以上两个理想条件。但我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。这样一来，本来不可靠的传输信道就能够实现可靠传输。</p> <h3 id="41-停止等待协议">4.1 停止等待协议</h3> <p>全双工通信的双方既是发送方也是接收方。下面为了讨论问题的方便，我们仅考虑 <code class="language-plaintext highlighter-rouge">A</code> 发送数据而 <code class="language-plaintext highlighter-rouge">B</code> 接收数据并发送确认。因此 <code class="language-plaintext highlighter-rouge">A</code> 叫做<strong>发送方</strong>，而 <code class="language-plaintext highlighter-rouge">B</code> 叫做<strong>接收方</strong>。因为这里是讨论可靠传输的原理，因此把传送的数据单元都称为分组，而并不考虑数据是在哪个层次上传送的。“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p> <h4 id="1无差错情况">（1）无差错情况</h4> <p>图 5-9（a）是最简单的无差错情况。<code class="language-plaintext highlighter-rouge">A</code> 发送分组 \(M_1\)，发完就暂停发送，等待 <code class="language-plaintext highlighter-rouge">B</code> 的确认。<code class="language-plaintext highlighter-rouge">B</code> 收到了 \(M_1\) 就向 <code class="language-plaintext highlighter-rouge">A</code> 发送确认。<code class="language-plaintext highlighter-rouge">A</code> 在收到了对 \(M_1\) 的确认后，就再发送下一个分组 \(M_2\)。同样，在收到 <code class="language-plaintext highlighter-rouge">B</code> 对 \(M_2\) 的确认后，再发送 \(M_3\)。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/stop-and-wait-protocol-480.webp 480w,/assets/images/computer-network/stop-and-wait-protocol-800.webp 800w,/assets/images/computer-network/stop-and-wait-protocol-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/stop-and-wait-protocol.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="停止等待协议" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-9 停止等待协议 </div> <h4 id="2出现差错">（2）出现差错</h4> <p>图 5-9（b）是分组在传输过程中出现差错的情况。<code class="language-plaintext highlighter-rouge">B</code> 接收 \(M_1\) 时检测出了差错，就丢弃 \(M_1\)，其他什么也不做（不通知 <code class="language-plaintext highlighter-rouge">A</code> 收到有差错的分组）。也可能是 \(M_1\) 在传输过程中丢失了，这时 <code class="language-plaintext highlighter-rouge">B</code> 当然什么都不知道。在这两种情况下，<code class="language-plaintext highlighter-rouge">B</code> 都不会发送任何信息。可靠传输协议是这样设计的：<code class="language-plaintext highlighter-rouge">A</code> 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个<strong>超时计时器</strong>。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。其实在图 5-9（a）中，<code class="language-plaintext highlighter-rouge">A</code> 为每个已发送的分组都设置了一个超时计时器。但 <code class="language-plaintext highlighter-rouge">A</code> 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器。</p> <p>这里应注意以下三点。</p> <ol> <li><code class="language-plaintext highlighter-rouge">A</code> 在发送完一个分组后，<strong>必须暂时保留已发送的分组的副本</strong>（在发生超时重传时使用）。只有在收到相应的确认后才能清除暂时保留的分组副本。</li> <li>分组和确认分组都必须进行<strong>编号</strong>。这样才能明确是哪个发送出去的分组收到了确认，而哪个分组还没有收到确认。</li> <li>超时计时器设置的重传时间<strong>应当比数据在分组传输的平均往返时间更长一些</strong>。图 5-9（b）中的一段虚线表示如果 \(M_1\) 正确到达 <code class="language-plaintext highlighter-rouge">B</code> 同时 <code class="language-plaintext highlighter-rouge">A</code> 也正确收到确认的过程。可见重传时间应设定为比平均往返时间更长一些。显然，如果重传时间设定得很长，那么通信的效率就会很低。但如果重传时间设定得太短，以致产生不必要的重传，就浪费了网络资源。然而，在运输层重传时间的准确设定是非常复杂的，这是因为已发送出的分组到底会经过哪些网络，以及这些网络将会产生多大的时延（这取决于这些网络当时的拥塞情况），这些都是不确定因素。图 5-9 中把往返时间当作固定的（这并不符合网络的实际情况），只是为了讲述原理的方便。</li> </ol> <h4 id="3确认丢失和确认迟到">（3）确认丢失和确认迟到</h4> <p>图 5-10（a）说明的是另一种情况。<code class="language-plaintext highlighter-rouge">B</code> 所发送的对 \(M_1\) 的确认丢失了。<code class="language-plaintext highlighter-rouge">A</code> 在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是 <code class="language-plaintext highlighter-rouge">B</code> 发送的确认丢失了。因此 <code class="language-plaintext highlighter-rouge">A</code> 在超时计时器到期后就要重传 \(M_1\)。现在应注意 <code class="language-plaintext highlighter-rouge">B</code> 的动作。假定 <code class="language-plaintext highlighter-rouge">B</code> 又收到了重传的分组 \(M_1\)。这时应采取两个行动。</p> <ol> <li>丢弃这个重复的分组 \(M_1\)，不向上层交付。</li> <li>向 <code class="language-plaintext highlighter-rouge">A</code> 发送确认。不能认为已经发送过确认就不再发送，因为 <code class="language-plaintext highlighter-rouge">A</code> 之所以重传 \(M_1\) 就表示 <code class="language-plaintext highlighter-rouge">A</code> 没有收到对 \(M_1\) 的确认。</li> </ol> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/confirmation-missiong-and-confirmation-late-480.webp 480w,/assets/images/computer-network/confirmation-missiong-and-confirmation-late-800.webp 800w,/assets/images/computer-network/confirmation-missiong-and-confirmation-late-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/confirmation-missiong-and-confirmation-late.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="确认丢失和确认迟到" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-10 确认丢失和确认迟到 </div> <p>图 5-10（b）也是一种可能出现的情况。传输过程中没有出现差错，但 <code class="language-plaintext highlighter-rouge">B</code> 对分组 \(M_1\) 的确认迟到了。<code class="language-plaintext highlighter-rouge">A</code> 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。<code class="language-plaintext highlighter-rouge">B</code> 仍然会收到重复的 \(M_1\) 并且同样要丢弃重复的 \(M_1\)，并重传确认分组。</p> <p>通常 <code class="language-plaintext highlighter-rouge">A</code> 最终总是可以收到对所有发出的分组的确认。如果 <code class="language-plaintext highlighter-rouge">A</code> 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。</p> <p>使用上述的确认和重传机制，我们就可以<strong>在不可靠的传输网络上实现可靠的通信</strong>。</p> <p>像上述的这种可靠传输协议常称为<strong>自动重传请求</strong> ARQ（Automatic Repeat reQuest）。意思是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</p> <h4 id="4信道利用率">（4）信道利用率</h4> <p>停止等待协议的优点是简单，但缺点是信道利用率太低。我们可以用图 5-11 来说明这个问题。为简单起见，假定在 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 之间有一条直通的信道来传送分组。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-channel-utilization-of-the-stop-wait-protocol-is-too-low-480.webp 480w,/assets/images/computer-network/the-channel-utilization-of-the-stop-wait-protocol-is-too-low-800.webp 800w,/assets/images/computer-network/the-channel-utilization-of-the-stop-wait-protocol-is-too-low-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-channel-utilization-of-the-stop-wait-protocol-is-too-low.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="停止等待协议的信道利用率太低" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-11 停止等待协议的信道利用率太低 </div> <p>假定 <code class="language-plaintext highlighter-rouge">A</code> 发送分组需要的时间是 \(T_D\)。显然，\(T_D\) 等于分组长度除以数据率。再假定分组正确到达 <code class="language-plaintext highlighter-rouge">B</code> 后，<code class="language-plaintext highlighter-rouge">B</code> 处理分组的时间可以忽略不计，同时立即发回确认。假定 <code class="language-plaintext highlighter-rouge">B</code> 发送确认分组需要时间 \(T_A\)。如果 <code class="language-plaintext highlighter-rouge">A</code> 处理确认分组的时间也可以忽略不计，那么 <code class="language-plaintext highlighter-rouge">A</code> 在经过时间 \((T_D + RTT + T_A)\) 后就可以再发送下一个分组，这里的 <code class="language-plaintext highlighter-rouge">RTT</code> 是往返时间。因为仅仅是在时间 \(T_D\) 内才用来传送有用的数据（包括分组的首部），因此信道的利用率 <code class="language-plaintext highlighter-rouge">U</code> 可用下式计算：</p> \[U = \frac{T_D}{T_D + RTT + T_A}\] <p>我们知道，上式中的往返时间 <code class="language-plaintext highlighter-rouge">RTT</code> 取决于所使用的信道。例如，假定 1200 km 的信道的往返时间 <code class="language-plaintext highlighter-rouge">RTT = 20ms</code>。分组长度是 <code class="language-plaintext highlighter-rouge">1200bit</code>，发送速率是 <code class="language-plaintext highlighter-rouge">1Mbit/s</code>。若忽略处理时间和 \(T_A\)（\(T_A\) 一般都远小于 \(T_D\)），则可算出信道的利用率 <code class="language-plaintext highlighter-rouge">U = 5.66%</code>。但若把发送速率提高到 <code class="language-plaintext highlighter-rouge">10Mbit/s</code>，则 \(U = 5.96 \times 10^{-4}\)。信道在绝大多数时间内都是空闲的。</p> <p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用<strong>流水线传输</strong>（如图 5-12 所示）。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/pipelined-transmission-can-improve-channel-utilization-480.webp 480w,/assets/images/computer-network/pipelined-transmission-can-improve-channel-utilization-800.webp 800w,/assets/images/computer-network/pipelined-transmission-can-improve-channel-utilization-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/pipelined-transmission-can-improve-channel-utilization.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="流水线传输可提高信道利用率" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-12 流水线传输可提高信道利用率 </div> <p>当使用流水线传输时，就要使用下面介绍的<strong>连续 ARQ 协议</strong>和<strong>滑动窗口协议</strong>。</p> <h3 id="42-连续-arq-协议">4.2 连续 ARQ 协议</h3> <p>图 5-13（a）表示发送方维持的<strong>发送窗口</strong>，它的意义是：位于发送窗口内的 5 个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</p> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/how-the-continuous-arq-protocol-works-480.webp 480w,/assets/images/computer-network/how-the-continuous-arq-protocol-works-800.webp 800w,/assets/images/computer-network/how-the-continuous-arq-protocol-works-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/how-the-continuous-arq-protocol-works.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="连续 ARQ 协议的工作原理" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-13 连续 ARQ 协议的工作原理 </div> <p>连续 ARQ 协议规定：</p> <ul> <li>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。图 5-13（b）表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。如果原来已经发送了前 5 个分组，那么现在就可以发送窗口内的第 6 个分组了。</li> <li>接收方一般都是采用<strong>累积确认</strong>的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，<strong>对按序到达的最后一个分组发送确认</strong>，这就表示：到这个分组为止的所有分组都已正确收到了。</li> </ul> <p>累积确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。例如，如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</p> <h2 id="五tcp-报文段的首部格式">五、TCP 报文段的首部格式</h2> <p>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。TCP 报文段首部的前 20 个字节是固定的（图 5-14），后面有 <code class="language-plaintext highlighter-rouge">4n</code> 字节是根据需要而增加的选项（n 是整数）。因此 TCP 首部的最小长度是 <code class="language-plaintext highlighter-rouge">20</code> 字节。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-header-format-of-a-TCP-packet-segment-480.webp 480w,/assets/images/computer-network/the-header-format-of-a-TCP-packet-segment-800.webp 800w,/assets/images/computer-network/the-header-format-of-a-TCP-packet-segment-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-header-format-of-a-TCP-packet-segment.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 报文段的首部格式" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-14 TCP 报文段的首部格式 </div> <p>首部固定部分各字段的意义如下：</p> <ol> <li><strong>源端口</strong>和<strong>目的端口</strong>：各占 2 个字节，分别写入源端口号和目的端口号。和前面图 5-6 所示的 UDP 的分用相似，TCP 的分用功能也是通过端口实现的。</li> <li><strong>序号</strong>：占 4 字节。序号范围是[0，\(2^{32}\) - 1]，共 \(2^{32}\)（即 4 294 967 296）个序号。序号增加到 \(2^{32}\) − 1 后，下一个序号就又回到 0。也就是说，序号使用 \(mod 2^{32}\) 运算。TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的<strong>每个字节都按顺序编号</strong>。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是<strong>本报文段</strong>所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是 <code class="language-plaintext highlighter-rouge">301</code>，而携带的数据共有 <code class="language-plaintext highlighter-rouge">100</code> 字节。这就表明：本报文段的数据的第一个字节的序号是 <code class="language-plaintext highlighter-rouge">301</code>，最后一个字节的序号是 <code class="language-plaintext highlighter-rouge">400</code>。显然，下一个报文段（如果还有的话）的数据序号应当从 <code class="language-plaintext highlighter-rouge">401</code> 开始，即下一个报文段的序号字段值应为 <code class="language-plaintext highlighter-rouge">401</code>。这个字段的名称也叫做“<strong>报文段序号</strong>”。</li> <li> <p><strong>确认号</strong>：占 4 字节，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。例如，<code class="language-plaintext highlighter-rouge">B</code> 正确收到了 <code class="language-plaintext highlighter-rouge">A</code> 发送过来的一个报文段，其序号字段值是 <code class="language-plaintext highlighter-rouge">501</code>，而数据长度是 <code class="language-plaintext highlighter-rouge">200</code> 字节（序号 501 ~ 700），这表明 <code class="language-plaintext highlighter-rouge">B</code> 正确收到了 <code class="language-plaintext highlighter-rouge">A</code> 发送的到序号 <code class="language-plaintext highlighter-rouge">700</code> 为止的数据。因此，<code class="language-plaintext highlighter-rouge">B</code> 期望收到 <code class="language-plaintext highlighter-rouge">A</code> 的下一个数据序号是 <code class="language-plaintext highlighter-rouge">701</code>，于是 <code class="language-plaintext highlighter-rouge">B</code> 在发送给 <code class="language-plaintext highlighter-rouge">A</code> 的确认报文段中把确认号置为 <code class="language-plaintext highlighter-rouge">701</code>。</p> <p><strong>若确认号 = <code class="language-plaintext highlighter-rouge">N</code>，则表明：到序号 <code class="language-plaintext highlighter-rouge">N - 1</code> 为止的所有数据都已正确收到</strong>。由于序号字段有 32 位长，可对 4GB 的数据进行编号。在一般情况下可保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。</p> </li> <li><strong>数据偏移</strong>：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出 TCP 报文段的<strong>首部长度</strong>。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。注意，“数据偏移”的单位是 32 位字（即以 4 字节长的字为计算单位）。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度（即选项长度不能超过 40 字节）。</li> <li><strong>保留</strong>：占 6 位，保留为今后使用，但目前应置为 0。</li> <li> <p><strong>紧急</strong> URG（URGent）：当 <code class="language-plaintext highlighter-rouge">URG = 1</code> 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（Control + C）。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了许多时间。</p> <p>当 <code class="language-plaintext highlighter-rouge">URG = 1</code> 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。这时要与首部中<strong>紧急指针</strong>（Urgent Pointer）字段配合使用。</p> </li> <li><strong>确认</strong> ACK（ACKnowledgment）：仅当 <code class="language-plaintext highlighter-rouge">ACK = 1</code> 时确认号字段才有效。当 <code class="language-plaintext highlighter-rouge">ACK = 0</code> 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 <code class="language-plaintext highlighter-rouge">ACK = 1</code>。</li> <li><strong>推送</strong> PSH（PuSH）：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 <code class="language-plaintext highlighter-rouge">PSH = 1</code>，并立即创建一个报文段发送出去。接收方 TCP 收到 <code class="language-plaintext highlighter-rouge">PSH = 1</code> 的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。虽然应用程序可以选择推送操作，但推送操作很少使用。</li> <li><strong>复位</strong> RST（ReSeT）：当 <code class="language-plaintext highlighter-rouge">RST = 1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。<code class="language-plaintext highlighter-rouge">RST = 1</code> 还用来拒绝一个非法的报文段或拒绝打开一个连接。<code class="language-plaintext highlighter-rouge">RST</code> 也可称为重建位或重置位。</li> <li><strong>同步</strong> SYN（SYNchronization）：在连接建立时用来同步序号。当 <code class="language-plaintext highlighter-rouge">SYN = 1</code> 而 <code class="language-plaintext highlighter-rouge">ACK = 0</code> 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 <code class="language-plaintext highlighter-rouge">SYN = 1</code> 和 <code class="language-plaintext highlighter-rouge">ACK = 1</code>。因此，<code class="language-plaintext highlighter-rouge">SYN</code> 置为 <code class="language-plaintext highlighter-rouge">1</code> 就表示这是一个连接请求或连接接受报文。</li> <li><strong>终止</strong> FIN（FINis，意思是“完”、“终”）：用来释放一个连接。当 <code class="language-plaintext highlighter-rouge">FIN = 1</code> 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li> <li> <p><strong>窗口</strong>：占 2 字节。窗口值是 [0，\(2^{16}\) - 1] 之间的整数。窗口指的是发送本报文段的一方的<strong>接收窗口</strong>（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<strong>窗口值作为接收方让发送方设置其发送窗口的依据</strong>。</p> <p>例如，发送了一个报文段，其确认号是 701，窗口字段是 1000。这就是告诉对方：“从 701 号算起，我（即发送报文段的一方）的接收缓存空间还可接收 1000 个字节数据（字节序号是 701 ~ 1700），你在给我发送数据时，必须考虑到这一点。”<strong>窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着</strong>。</p> </li> <li><strong>检验和</strong>：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 <code class="language-plaintext highlighter-rouge">12</code> 字节的伪首部。伪首部的格式与图 5-5 中 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6），把第 5 字段中的 UDP 长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。</li> <li><strong>紧急指针</strong>：占 2 字节。紧急指针仅在 <code class="language-plaintext highlighter-rouge">URG = 1</code> 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。注意，即使窗口为零时也可发送紧急数据。</li> <li> <p><strong>选项</strong>：长度可变，最长可达 40 字节。当没有使用“选项“时，TCP 的首部长度是 20 字节。</p> <p>TCP 最初只规定了一种选项，即<strong>最大报文段长度</strong> MSS（Maximum Segment Size）[RFC 879]。随着互联网的发展，又陆续增加了几个选项。如<strong>窗口扩大</strong>选项、<strong>时间戳</strong>选项等（见建议标准 RFC 7323）。以后又增加了有关<strong>选择确认</strong>（SACK）选项（见建议标准 RFC 2018）。这些选项的位置都在图 5-14 所示的选项字段中。</p> <ul> <li> <p><strong>最大报文段长度</strong> MSS：是<strong>每个</strong> TCP 报文段中的<strong>数据字段的最大长度</strong>。数据字段加上 TCP 首部才等于整个的 TCP 报文段。</p> <p>我们知道，TCP 报文段的数据部分，至少要加上 40 字节的首部（TCP 首部 20 字节和 IP 首部 20 字节，这里都还没有考虑首部中的选项部分），才能组装成一个 IP 数据报。若选择较小的 MSS 长度，网络的利用率就降低。设想在极端的情况下，当 TCP 报文段只含有 1 字节的数据时，在 IP 层传输的数据报的开销至少有 40 字节（包括 TCP 报文段的首部和 IP 数据报的首部）。这样，对网络的利用率就不会超过 1/41。到了数据链路层还要加上一些开销。但反过来，若 TCP 报文段非常长，那么在 IP 层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。</p> <p>因此，MSS 应尽可能大些，只要在 IP 层传输时不需要再分片就行。由于 IP 数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要分片的 MSS，如果改走另一条路径就可能需要进行分片。因此最佳的 MSS 是很难确定的。在连接建立的过程中，双方都把自己能够支持的 MSS 写入这一字段，以后就按照这个数值传送数据，两个传送方向可以有不同的 MSS 值。若主机未填写这一项，则 MSS 的默认值是 536 字节长。因此，所有在互联网上的主机都应能接受的报文段长度是 536 + 20（固定首部长度）= 556字节。</p> </li> <li> <p><strong>窗口扩大</strong>选项是为了扩大窗口。我们知道，TCP 首部中窗口字段长度是 16 位，因此最大的窗口大小为 64K 字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和带宽都很大，要获得高吞吐率需要更大的窗口大小。窗口扩大选项占 3 字节，其中有一个字节表示<strong>移位值</strong> S。新的窗口值等于 TCP 首部中的窗口位数从 16 增大到（16 + S）。移位值允许使用的最大值是 14，相当于窗口最大值增大 \(2^{(16 + 14)} - 1 = 2^{30} - 1\)。窗口扩大选项可以在双方初始建立 TCP 连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送 <code class="language-plaintext highlighter-rouge">S = 0</code> 的选项，使窗口大小回到 16。</p> </li> <li> <p><strong>时间戳</strong>选项占 10 字节，其中最主要的字段是<strong>时间戳值</strong>字段（4 字节）和<strong>时间戳回送回答</strong>字段（4 字节）。时间戳选项有以下两个功能：</p> <ul> <li>用来计算往返时间 RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出 RTT 来。</li> <li>用于处理 TCP 序号超过 \(2^{32}\) 的情况，这又称为防止序号绕回 PAWS（Protect Against Wrapped Sequence numbers）。我们知道，TCP 报文段的序号只有 32 位，而每增加 \(2^{32}\) 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次 TCP 连接的数据传送中序号很可能会被重复使用。例如，当使用 1.5 Mbit/s 的速率发送报文段时，序号重复要 6 小时以上。但若用 2.5Gbit/s 的速率发送报文段，则不到 14 秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。</li> </ul> </li> </ul> </li> </ol> <h2 id="六tcp-可靠传输的实现">六、TCP 可靠传输的实现</h2> <h3 id="61-以字节为单位的滑动窗口">6.1 以字节为单位的滑动窗口</h3> <p>假定 <code class="language-plaintext highlighter-rouge">A</code> 收到了 <code class="language-plaintext highlighter-rouge">B</code> <strong>发来</strong>的确认报文段，其中窗口是 <code class="language-plaintext highlighter-rouge">20</code> 字节，而确认号是 <code class="language-plaintext highlighter-rouge">31</code>（这表明 <code class="language-plaintext highlighter-rouge">B</code> 期望收到的下一个序号是 <code class="language-plaintext highlighter-rouge">31</code>，而序号 <code class="language-plaintext highlighter-rouge">30</code> 为止的数据已经收到了）。根据这两个数据，<code class="language-plaintext highlighter-rouge">A</code> 就构造出自己的发送窗口，如图 5-15 所示。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/according-to-the-window-value-given-by-B-A-constructs-its-own-sending-window-480.webp 480w,/assets/images/computer-network/according-to-the-window-value-given-by-B-A-constructs-its-own-sending-window-800.webp 800w,/assets/images/computer-network/according-to-the-window-value-given-by-B-A-constructs-its-own-sending-window-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/according-to-the-window-value-given-by-B-A-constructs-its-own-sending-window.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="根据 B 给出的窗口值，A 构造出自己的发送窗口" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-15 根据 B 给出的窗口值，A 构造出自己的发送窗口 </div> <p>在没有收到 <code class="language-plaintext highlighter-rouge">B</code> 的确认的情况下，<code class="language-plaintext highlighter-rouge">A</code> 可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。</p> <p>发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。接收方会把自己的接收窗口数值放在窗口字段中发送给对方，因此，<code class="language-plaintext highlighter-rouge">A</code> 的发送窗口一定不能超过 <code class="language-plaintext highlighter-rouge">B</code> 的接收窗口数值。（注意，发送方的发送窗口大小还要受到当时网络拥塞程度的制约。但在目前，我们暂不考虑网络拥塞的影响。）发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。</p> <p>发送窗口的位置由窗口前沿和后沿的位置共同确定。</p> <ul> <li>发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。</li> <li>发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况： <ul> <li>一是没有收到新的确认，对方通知的窗口大小也不变。</li> <li>二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。</li> </ul> </li> <li>发送窗口前沿也有可能<strong>向后收缩</strong>。这发生在对方通知的窗口缩小了。但 TCP 的标准<strong>强烈不赞成这样做</strong>。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。</li> </ul> <p>假定 <code class="language-plaintext highlighter-rouge">A</code> 发送了序号为 <code class="language-plaintext highlighter-rouge">31 ~ 41</code> 的数据。这时，发送窗口位置并未改变（图 5-16），但发送窗口内靠后面有 <code class="language-plaintext highlighter-rouge">11</code> 个字节（灰色小方框表示）表示已发送但未收到确认。而发送窗口内靠前面的 <code class="language-plaintext highlighter-rouge">9</code> 个字节（<code class="language-plaintext highlighter-rouge">42 ~ 50</code>）是允许发送但尚未发送的。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/A-sent-11-bytes-of-data-480.webp 480w,/assets/images/computer-network/A-sent-11-bytes-of-data-800.webp 800w,/assets/images/computer-network/A-sent-11-bytes-of-data-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/A-sent-11-bytes-of-data.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="A 发送了 11 个字节的数据" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-16 A 发送了 11 个字节的数据* </div> <p>从以上所述可以看出，要描述一个发送窗口的状态需要三个指针：\(P_1\)，\(P_2\) 和 \(P_3\)（图 5-16）。指针都指向字节的序号。这三个指针指向的几个部分的意义如下：</p> <ul> <li>小于 \(P_1\) 的是已发送并已收到确认的部分，而大于 \(P_3\) 的是不允许发送的部分。</li> <li>\(P_3 - P_1\) = <code class="language-plaintext highlighter-rouge">A</code> 的发送窗口。</li> <li>\(P_2 - P_1\) = 已发送但尚未收到确认的字节数。</li> <li>\(P_3 - P_2\) = 允许发送但当前尚未发送的字节数（又称为<strong>可用窗口</strong>或<strong>有效窗口</strong>）。</li> </ul> <p><code class="language-plaintext highlighter-rouge">B</code> 的接收窗口大小是 <code class="language-plaintext highlighter-rouge">20</code>。在接收窗口外面，到 <code class="language-plaintext highlighter-rouge">30</code> 号为止的数据是已经发送过确认，并且已经交付主机了。因此在 <code class="language-plaintext highlighter-rouge">B</code> 可以不再保留这些数据。接收窗口内的序号（<code class="language-plaintext highlighter-rouge">31 ~ 50</code>）是允许接收的。在图 5-16 中，<code class="language-plaintext highlighter-rouge">B</code> 收到了序号为 <code class="language-plaintext highlighter-rouge">32</code> 和 <code class="language-plaintext highlighter-rouge">33</code> 的数据。这些数据没有按序到达，因为序号为 <code class="language-plaintext highlighter-rouge">31</code> 的数据没有收到（也许丢失了，也许滞留在网络中的某处）。注意，<code class="language-plaintext highlighter-rouge">B</code> <strong>只能对按序收到的数据中的最高序号给出确认</strong>，因此 <code class="language-plaintext highlighter-rouge">B</code> 发送的确认报文段中的确认号仍然是 <code class="language-plaintext highlighter-rouge">31</code>（即期望收到的序号），而不能是 <code class="language-plaintext highlighter-rouge">32</code> 或 <code class="language-plaintext highlighter-rouge">33</code>。</p> <p>假定 <code class="language-plaintext highlighter-rouge">B</code> 收到了序号为 <code class="language-plaintext highlighter-rouge">31</code> 的数据，并把序号为 <code class="language-plaintext highlighter-rouge">31 ～ 33</code> 的数据交付主机，然后 <code class="language-plaintext highlighter-rouge">B</code> 删除这些数据。接着把接收窗口向前移动 3 个序号（图 5-17），同时给 <code class="language-plaintext highlighter-rouge">A</code> 发送确认，其中窗口值仍为 <code class="language-plaintext highlighter-rouge">20</code>，但确认号是 <code class="language-plaintext highlighter-rouge">34</code>。这表明 <code class="language-plaintext highlighter-rouge">B</code> 已经收到了到序号 <code class="language-plaintext highlighter-rouge">33</code> 为止的数据。我们注意到，<code class="language-plaintext highlighter-rouge">B</code> 还收到了序号为 <code class="language-plaintext highlighter-rouge">37</code>，<code class="language-plaintext highlighter-rouge">38</code> 和 <code class="language-plaintext highlighter-rouge">40</code> 的数据，但这些都没有按序到达，只能先暂存在接收窗口中。<code class="language-plaintext highlighter-rouge">A</code> 收到 <code class="language-plaintext highlighter-rouge">B</code> 的确认后，就可以把发送窗口向前滑动 3 个序号，但指针 \(P_2\) 不动。可以看出，现在 <code class="language-plaintext highlighter-rouge">A</code> 的可用窗口增大了，可发送的序号范围是 <code class="language-plaintext highlighter-rouge">42 ~ 53</code>。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/when-A-receives-the-new-confirmation-number-the-sending-window-slides-forward-480.webp 480w,/assets/images/computer-network/when-A-receives-the-new-confirmation-number-the-sending-window-slides-forward-800.webp 800w,/assets/images/computer-network/when-A-receives-the-new-confirmation-number-the-sending-window-slides-forward-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/when-A-receives-the-new-confirmation-number-the-sending-window-slides-forward.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="A 收到新的确认号，发送窗口向前滑动" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-17 A 收到新的确认号，发送窗口向前滑动 </div> <p><code class="language-plaintext highlighter-rouge">A</code> 在继续发送完序号 <code class="language-plaintext highlighter-rouge">42 ~ 53</code> 的数据后，指针 \(P_2\) 向前移动和 \(P_3\) 重合。发送窗口内的序号都已用完，但还没有再收到确认（图 5-18）。由于 <code class="language-plaintext highlighter-rouge">A</code> 的发送窗口已满，可用窗口已减小到零，因此必须停止发送。请注意，存在下面这种可能性，就是发送窗口内所有的数据都已正确到达 <code class="language-plaintext highlighter-rouge">B</code>，<code class="language-plaintext highlighter-rouge">B</code> 也早已发出了确认。但不幸的是，所有这些确认都滞留在网络中。为了保证可靠传输，<code class="language-plaintext highlighter-rouge">A</code> 只能认为 <code class="language-plaintext highlighter-rouge">B</code> 还没有收到这些数据。于是，<code class="language-plaintext highlighter-rouge">A</code> 在经过一段时间后（由超时计时器控制）就重传这部分数据，重新设置超时计时器，直到收到 <code class="language-plaintext highlighter-rouge">B</code> 的确认为止。如果 <code class="language-plaintext highlighter-rouge">A</code> 收到确认号落在发送窗口内，那么 <code class="language-plaintext highlighter-rouge">A</code> 就可以使发送窗口继续向前滑动，并发送新的数据。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-serial-numbers-in-the-send-window-are-sent-but-not-confirmed-480.webp 480w,/assets/images/computer-network/the-serial-numbers-in-the-send-window-are-sent-but-not-confirmed-800.webp 800w,/assets/images/computer-network/the-serial-numbers-in-the-send-window-are-sent-but-not-confirmed-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-serial-numbers-in-the-send-window-are-sent-but-not-confirmed.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="发送窗口内的序号都属于已发送但未被确认" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-18 发送窗口内的序号都属于已发送但未被确认 </div> <p>我们在前面的图 5-8 中曾给出了这样的概念：发送方的应用进程把字节流写入 TCP 的发送缓存，接收方的应用进程从 TCP 的接收缓存中读取字节流。下面我们就进一步讨论前面讲的窗口和缓存的关系。图 5-19 画出了发送方维持的发送缓存和发送窗口，以及接收方维持的接收缓存和接收窗口。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/relationship-between-TCP-cache-and-window-480.webp 480w,/assets/images/computer-network/relationship-between-TCP-cache-and-window-800.webp 800w,/assets/images/computer-network/relationship-between-TCP-cache-and-window-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/relationship-between-TCP-cache-and-window.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 的缓存和窗口的关系" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-19 TCP 的缓存和窗口的关系 </div> <p>我们先看一下图 5-19（a）所示的发送方的情况。发送缓存用来暂时存放：</p> <ul> <li>发送应用程序传送给发送方 TCP 准备发送的数据。</li> <li>TCP 已发送出但尚未收到确认的数据。</li> </ul> <p>发送窗口通常只是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节减去最后被确认的字节，就是还保留在发送缓存中的被写入的字节数。发送应用程序必须控制写入缓存的速率，不能太快，否则发送缓存就会没有存放数据的空间。</p> <p>再看一下图 5-19（b）所示的接收方的情况。接收缓存用来暂时存放：</p> <ul> <li>按序到达的，但尚未被接收应用程序读取的数据。</li> <li>未按序到达的数据。</li> </ul> <p>如果收到的分组被检测出有差错，则要丢弃。如果接收应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到零。反之，如果接收应用程序能够及时从接收缓存中读取收到的数据，接收窗口就可以增大，但最大不能超过接收缓存的大小。图 5-19（b）中还指出了下一个期望收到的字节号。这个字节号也就是接收方给发送方的报文段的首部中的确认号。</p> <p>根据以上所讨论的，我们还要再强调以下三点。</p> <ul> <li>虽然 <code class="language-plaintext highlighter-rouge">A</code> 的发送窗口是根据 <code class="language-plaintext highlighter-rouge">B</code> 的接收窗口设置的，但在同一时刻，<code class="language-plaintext highlighter-rouge">A</code> 的发送窗口并不总是和 <code class="language-plaintext highlighter-rouge">B</code> 的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后（这个时间还是不确定的）。另外，发送方 <code class="language-plaintext highlighter-rouge">A</code> 还可能根据网络当时的拥塞情况适当减小自己的发送窗口数值。</li> <li>对于不按序到达的数据应如何处理，TCP 标准并无明确规定。如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利（因为发送方会重复传送较多的数据）。因此 TCP 通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<strong>按序交付上层的应用进程</strong>。</li> <li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两点。 <ul> <li>接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认[RFC 1122]。</li> <li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li> </ul> </li> </ul> <p>最后再强调一下，TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清是哪一方的窗口。</p> <h3 id="62-超时重传时间的选择">6.2 超时重传时间的选择</h3> <p>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是<strong>报文段的往返时间 RTT</strong>。TCP 保留了 RTT 的一个<strong>加权平均往返时间</strong> RTTs（这又称为<strong>平滑的往返时间</strong>，S 表示 Smoothed。因为进行的是加权平均，因此得出的结果更加平滑）。每当第一次测量到 RTT 样本时，RTT 值就取为所测量到的 RTT 样本值。但以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTs：</p> \[新的 RTT_S = （1 - \alpha）×（旧的 RTT_S） + \alpha x （新的 RTT 样本）\] <p>在上式中，0 ≤ \(\alpha\) &lt; 1。若 \(\alpha\) 很接近于零，表示新的 \(RTT_S\) 值和旧的 \(RTT_S\) 值相比变化不大，而对新的 RTT 样本影响不大（RTT 值更新较慢）。若选择 \(\alpha\) 接近于 1，则表示新的 \(RTT_S\) 值受新的 RTT 样本的影响较大（RTT 值更新较快）。已成为建议标准的 RFC 6298 推荐的 \(\alpha\) 值为 1/8，即 0.125。用这种方法得出的加权平均往返时间 \(RTT_S\) 就比测量出的 RTT 值更加平滑。</p> <p>显然，超时计时器设置的<strong>超时重传时间</strong> RTO（Retransmission Time-Out）应略大于上面得出的加权平均往返时间 \(RTT_S\)。RFC 6298 建议使用下式计算 RTO：</p> \[RTO = RTT_S + 4 × RTT_D\] <p>而 \(RTT_D\) 是 RTT 的<strong>偏差</strong>的加权平均值，它与 \(RTT_S\) 和新的 RTT 样本之差有关。RFC 6298 建议这样计算 \(RTT_D\)。当第一次测量时，\(RTT_D\) 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 \(RTT_D\)：</p> \[新的 RTT_D = （1 - \beta） ×（旧的 RTT_D）+ \beta x |RTT_S - 新的 RTT 样本|\] <p>这里 \(\beta\) 是个小于 1 的系数，它的推荐值是 1/4，即 0.25。</p> <p>如图 5-20 所示，发送出一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段。经过了一段时间后，收到了确认报文段。现在的问题是：<strong>如何判定此确认报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认</strong>？由于重传的报文段和原来的报文段完全一样，因此源主机在收到确认后，就无法做出正确的判断，而正确的判断对确定加权平均 \(RTT_S\) 的值关系很大。</p> <p>若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认，则这样计算出的 \(RTT_S\) 和超时重传时间 RTO 就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间 RTO 就越来越长。</p> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/to-which-packet-segment-is-the-received-acknowledgement-480.webp 480w,/assets/images/computer-network/to-which-packet-segment-is-the-received-acknowledgement-800.webp 800w,/assets/images/computer-network/to-which-packet-segment-is-the-received-acknowledgement-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/to-which-packet-segment-is-the-received-acknowledgement.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="收到的确认是对哪个报文段的确认？" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-20 收到的确认是对哪个报文段的确认？ </div> <p>同样，若收到的确认是对原来的报文段的确认，但被当成是对重传报文段的确认，则由此计算出的 \(RTT_S\) 和 RTO 都会偏小。这就必然导致报文段过多地重传。这样就有可能使 RTO 越来越短。</p> <p>根据以上所述，Karn 提出了一个算法：<strong>在计算加权平均 RTTs 时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均 RTTs 和 RTO 就较准确</strong>。</p> <p>但是，这又引起新的问题。设想出现这样的情况：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</p> <p>因此要对 Karn 算法进行修正。方法是：报文段每传一次，就把超时重传时间 RTO 增大一些。典型的做法是取新的重传时间为旧的重传时间的 2 倍。当不再发生报文段的重传时，才根据上面给出的公式计算超时重传时间。实践证明，这种策略较为合理。总之，Karn 算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返时间的估测，使计算结果更加合理。</p> <h3 id="63-选择确认-sack">6.3 选择确认 SACK</h3> <p>我们用一个例子来说明<strong>选择确认</strong>（Selective ACK）的工作原理。TCP 的接收方在接收对方发送过来的数据字节流的序号不连续，结果就形成了一些不连续的字节块（如图 5-21 所示）。可以看出，序号 <code class="language-plaintext highlighter-rouge">1 ~ 1000</code> 收到了，但序号 <code class="language-plaintext highlighter-rouge">1001 ~ 1500</code> 没有收到。接下来的字节流又收到了，可是又缺少了 <code class="language-plaintext highlighter-rouge">3001 ~ 3500</code>。再后面从序号 <code class="language-plaintext highlighter-rouge">4501</code> 起又没有收到。也就是说，接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-received-byte-stream-sequence-number-is-inconsistent-480.webp 480w,/assets/images/computer-network/the-received-byte-stream-sequence-number-is-inconsistent-800.webp 800w,/assets/images/computer-network/the-received-byte-stream-sequence-number-is-inconsistent-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-received-byte-stream-sequence-number-is-inconsistent.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="接收到的字节流序号不连续" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-21 接收到的字节流序号不连续 </div> <p>从图 5-21 可看出，和前后字节不连续的每个字节块都有两个边界：左边界和右边界。因此在图中用四个指针标记这些边界。请注意，第一个字节块的左边界 \(L_1\) = 1501，但右边界 \(R_1\) = 3001 而不是 3000。这就是说，左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。同理，第二个字节块的左边界 \(L_2\) = 3501，而右边界 \(R_2\) = 4501。</p> <p>我们知道，TCP 的首部没有哪个字段能够提供上述这些字节块的边界信息。RFC 2018 规定，如果要使用选择确认 SACK，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节（因为序号有 32 位，需要使用 4 个字节表示），因此在选项中最多只能指明 4 个字节块的边界信息。这是因为 4 个字节块共有 8 个边界，因而需要用 32 个字节来描述。另外还需要两个字节。一个字节用来指明是 SACK 选项，另一个字节是指明这个选项要占用多少字节。如果要报告五个字节块的边界信息，那么至少需要 42 个字节。这就超过了选项长度的 40 字节的上限。互联网建议标准 RFC 2018 还对报告这些边界信息的格式都做出了非常明确的规定，这里从略。</p> <p>然而，SACK 文档并没有指明发送方应当怎样响应 SACK。因此大多数的实现还是重传所有未被确认的数据块。</p> <h2 id="七tcp-的流量控制">七、TCP 的流量控制</h2> <h3 id="71-利用滑动窗口实现流量控制">7.1 利用滑动窗口实现流量控制</h3> <p>所谓<strong>流量控制</strong>（flow control）就是<strong>让发送方的发送速率不要太快，要让接收方来得及接收</strong>。利用滑动窗口机制可以很方便地在 TCP 连接上实现对发送方的流量控制。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/example-of-flow-control-using-variable-window-480.webp 480w,/assets/images/computer-network/example-of-flow-control-using-variable-window-800.webp 800w,/assets/images/computer-network/example-of-flow-control-using-variable-window-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/example-of-flow-control-using-variable-window.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="利用可变窗口进行流量控制举例" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-22 利用可变窗口进行流量控制举例 </div> <p>设 <code class="language-plaintext highlighter-rouge">A</code> 向 <code class="language-plaintext highlighter-rouge">B</code> 发送数据。在连接建立时，<code class="language-plaintext highlighter-rouge">B</code> 告诉了 <code class="language-plaintext highlighter-rouge">A</code>：“我的接收窗口 <code class="language-plaintext highlighter-rouge">rwnd = 400</code>”（这里 rwnd 表示 receiver window）。因此，<strong>发送方的发送窗口不能超过接收方给出的接收窗口的数值</strong>。注意，TCP 的<strong>窗口单位是字节，不是报文段</strong>。TCP 连接建立时的窗口协商过程在图中没有显示出来。再设每个报文段为 100 字节长，而数据报文段序号的初始值设为 1（见图中第一个箭头上面的序号 <code class="language-plaintext highlighter-rouge">seq = 1</code>）（注意，图中箭头上面大写 <code class="language-plaintext highlighter-rouge">ACK</code> 表示首部中的确认 <code class="language-plaintext highlighter-rouge">ACK</code>，小写 <code class="language-plaintext highlighter-rouge">ack</code> 表示确认字段的值）。</p> <p>接收方的主机 <code class="language-plaintext highlighter-rouge">B</code> 进行了三次流量控制。第一次把窗口减小到 <code class="language-plaintext highlighter-rouge">rwnd = 300</code>，第二次又减到 <code class="language-plaintext highlighter-rouge">rwnd = 100</code>，最后减到 <code class="language-plaintext highlighter-rouge">rwnd = 0</code>，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机 <code class="language-plaintext highlighter-rouge">B</code> 重新发出一个新的窗口值为止。<code class="language-plaintext highlighter-rouge">B</code> 向 <code class="language-plaintext highlighter-rouge">A</code> 发送的三个报文段都设置了 <code class="language-plaintext highlighter-rouge">ACK = 1</code>，只有在 <code class="language-plaintext highlighter-rouge">ACK = 1</code> 时确认号字段才有意义。</p> <p>现在我们考虑一种情况。在图 5-22 中，<code class="language-plaintext highlighter-rouge">B</code> 向 <code class="language-plaintext highlighter-rouge">A</code> 发送了零窗口的报文段后不久，<code class="language-plaintext highlighter-rouge">B</code> 的接收缓存又有了一些存储空间。于是 <code class="language-plaintext highlighter-rouge">B</code> 向 <code class="language-plaintext highlighter-rouge">A</code> 发送了 <code class="language-plaintext highlighter-rouge">rwnd = 400</code> 的报文段。然而这个报文段在传送过程中丢失了。<code class="language-plaintext highlighter-rouge">A</code> 一直等待收到 <code class="language-plaintext highlighter-rouge">B</code> 发送的非零窗口的通知，而 <code class="language-plaintext highlighter-rouge">B</code> 也一直等待 <code class="language-plaintext highlighter-rouge">A</code> 发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p> <p>为了解决这个问题，TCP 为每个连接设有一个<strong>持续计时器</strong>（persistence timer）。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个<strong>零窗口探测报文段</strong>（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</p> <h3 id="72-tcp-的传输效率">7.2 TCP 的传输效率</h3> <p>应用进程把数据传送到 TCP 的发送缓存后，剩下的发送任务就由 TCP 来控制了。可以用不同的机制来控制 TCP 报文段的发送时机。</p> <ol> <li>第一种机制是 TCP 维持一个变量，它等于<strong>最大报文段长度 MSS</strong>。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li> <li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的<strong>推送</strong>（push）操作。</li> <li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li> </ol> <p>但是，如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。</p> <p>例如，一个交互式用户使用一条 TELNET 连接（运输层为 TCP 协议）。假设用户只发 1 个字符，加上 20 字节的首部后，得到 21 字节长的 TCP 报文段。再加上 20 字节的 IP 首部，形成 41 字节长的 IP 数据报。在接收方 TCP 立即发出确认，构成的数据报是 40 字节长（假定没有数据发送）。若用户要求远地主机回送这一字符，则又要发回 41 字节长的 IP 数据报和 40 字节长的确认 IP 数据报。这样，用户仅发 1 个字符时，线路上就需传送总长度为 162 字节共 4 个报文段。当线路带宽并不富裕时，这种传送方法的效率的确不高。因此应适当推迟发回确认报文，并尽量使用捎带确认的方法。</p> <p>在 TCP 的实现中广泛使用 Nagle 算法：若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。</p> <p>另一个问题叫做<strong>糊涂窗口综合征</strong>（silly window syndrome）[RFC 813]，有时也会使 TCP 的性能变坏。设想一种情况：TCP 接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取 1 个字节（这样就使接收缓存空间仅腾出 1 个字节），然后向发送方发送确认，并把窗口设置为 1 个字节（但发送的数据报是 40 字节长）。接着，发送方又发来 1 个字节的数据（请注意，发送方发送的 IP 数据报是 41 字节长）。接收方发回确认，仍然将窗口设置为 1 个字节。这样进行下去，使网络的效率很低。</p> <p>要解决这个问题，可以<strong>让接收方等待一段时间</strong>，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者<strong>等到接收缓存已有一半空闲的空间</strong>。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p> <p>上述两种方法可配合使用。使得在发送方不发送很小的报文段的同时，接收方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。</p> <h2 id="八tcp-的拥塞控制">八、TCP 的拥塞控制</h2> <h3 id="81-拥塞控制的一般原理">8.1 拥塞控制的一般原理</h3> <p>在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>（congestion）。可以把出现网络拥塞的条件写成如下的关系式：</p> \[\sum 对资源的需求 &gt; 可用资源\] <p>网络拥塞是一个非常复杂的问题，往往由许多因素引起。例如，当某个结点缓存的容量太小时，到达该结点的分组因无存储空间暂存而不得不被丢弃。现在设想将该结点缓存的容量扩展到非常大，于是凡到达该结点的分组均可在结点的缓存队列中排队，不受任何限制。由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数分组的排队等待时间将会大大增加，结果上层软件只好把它们进行重传（因为早就超时了）。由此可见，简单地扩大缓存的存储空间同样会造成网络资源的严重浪费，因而解决不了网络拥塞的问题。又如，处理机处理的速率太慢可能引起网络的拥塞。简单地将处理机的速率提高，可能会使上述情况缓解一些，但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统的各个部分不匹配。只有所有的部分都平衡了，问题才会得到解决。</p> <p>拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。</p> <p>拥塞控制与流量控制的关系密切，它们之间也存在着一些差别。</p> <ul> <li><strong>拥塞控制</strong>指<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</strong>。拥塞控制所要做的都有一个前提，就是<strong>网络能够承受现有的网络负荷</strong>。拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。但 TCP 连接的端点只要迟迟不能收到对方的确认信息，就猜想在当前网络中的某处很可能发生了拥塞，但这时却无法知道拥塞到底发生在网络的何处，也无法知道发生拥塞的具体原因。</li> <li><strong>流量控制往往是指点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题（接收端控制发送端）。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li> </ul> <p>可以用一个简单例子说明这种区别。设某个光纤网络的链路传输速率为 1000 Gbit/s。有一台巨型计算机向一台个人电脑以 1 Gbit/s 的速率传送文件。显然，网络本身的带宽是足够大的，因而不存在产生拥塞的问题。但流量控制却是必需的，因为巨型计算机必须经常停下来，以便使个人电脑来得及接收。但如果有另一个网络，其链路传输速率为 1 Mbit/s，而有 1000 台大型计算机连接在这个网络上。假定其中的 500 台计算机分别向其余的 500 台计算机以 100 kbit/s 的速率发送文件。那么现在的问题已不是接收端的大型计算机是否来得及接收，而是整个网络的输入负载是否超过网络所能承受的。</p> <p>拥塞控制和流量控制之所以常常被弄混，是因为某些拥塞控制算法是向发送端发送控制报文，并告诉发送端，网络已出现麻烦，必须放慢发送速率。这点又和流量控制是很相似的。</p> <p>进行拥塞控制需要付出代价。这首先需要获得网络内部流量分布的信息。在实施拥塞控制时，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外开销。拥塞控制有时需要将一些资源（如缓存、带宽等）分配给个别用户（或一些类别的用户）单独使用，这样就使得网络资源不能更好地实现共享。十分明显，在设计拥塞控制策略时，必须全面衡量得失。</p> <p>在图 5-23 中的横坐标是<strong>提供的负载</strong>（offered load），代表单位时间内输入给网络的分组数目。因此提供的负载也称为<strong>输入负载</strong>或<strong>网络负载</strong>。纵坐标是<strong>吞吐量</strong>（throughput），代表单位时间内从网络输出的分组数目。具有理想拥塞控制的网络，在吞吐量饱和之前，网络吞吐量应等于提供的负载，故吞吐量曲线是 45° 的斜线。但当提供的负载超过某一限度时，由于网络资源受限，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了（例如，输入到网络的某些分组被某个结点丢弃了）。虽然如此，在这种理想的拥塞控制作用下，网络的吞吐量仍然维持在其所能达到的最大值。</p> <div class="row justify-content-center"> <div class="col-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-role-of-congestion-control-480.webp 480w,/assets/images/computer-network/the-role-of-congestion-control-800.webp 800w,/assets/images/computer-network/the-role-of-congestion-control-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-role-of-congestion-control.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="拥塞控制所起的作用" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-23 拥塞控制所起的作用 </div> <p>但是，实际网络的情况就很不相同了。从图 5-23 可看出，随着提供的负载的增大，网络吞吐量的增长速率逐渐减小。也就是说，在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了。当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了<strong>轻度拥塞</strong>的状态。当提供的负载达到某一数值时，网络的吞吐量反而随提供的负载的增大而下降，这时<strong>网络就进入了拥塞状态</strong>。当提供的负载继续增大到某一数值时，网络的吞吐量就下降到零，网络已无法工作，这就是所谓的<strong>死锁</strong>（deadlock）。</p> <p>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态的</strong>（而不是静态的）问题。当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丟失是网络发生拥塞的征兆而不是原因。在许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至发生死锁的原因。<strong>这点应特别引起重视</strong>。</p> <p>由于计算机网络是一个很复杂的系统，因此可以从控制理论的角度来看拥塞控制这个问题。这样，从大的方面看，可以分为<strong>开环控制</strong>和<strong>闭环控制</strong>两种方法。开环控制就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正了。闭环控制是基于反馈环路的概念，主要有以下几种措施：</p> <ul> <li>监测网络系统以便检测到拥塞在何时、何处发生。</li> <li>把拥塞发生的信息传送到可采取行动的地方。</li> <li>调整网络系统的运行以解决出现的问题。</li> </ul> <p>有很多的方法可用来监测网络的拥塞。主要的一些指标是：由于缺少缓存空间而被丟弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准差，等等。上述这些指标的上升都标志着拥塞的增长。</p> <p>一般在监测到拥塞发生时，要将拥塞发生的信息传送到产生分组的源站。当然，通知拥塞发生的分组同样会使网络更加拥塞。</p> <p>另一种方法是在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示网络没有拥塞或产生了拥塞。也可以由一些主机或路由器周期性地发出探测分组，以询问拥塞是否发生。</p> <p>此外，过于频繁地采取行动以缓和网络的拥塞，会使系统产生不稳定的振荡。但过于迟缓地采取行动又不具有任何实用价值。因此，要采用某种折中的方法。但选择正确的时间常数是相当困难的。</p> <h3 id="82-tcp-的拥塞控制方法">8.2 TCP 的拥塞控制方法</h3> <p>TCP 进行拥塞控制的算法有四种，即<strong>慢开始</strong>（slow-start）、<strong>拥塞避免</strong>（congestion avoidance）、<strong>快重传</strong>（fast retransmit）和<strong>快恢复</strong>（fast recovery）[RFC 5681]。为了集中精力讨论拥塞控制，我们假定：</p> <ul> <li>数据是单方向传送的，对方只传送确认报文。</li> <li>接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。</li> </ul> <h4 id="1慢开始和拥塞避免">（1）慢开始和拥塞避免</h4> <p>下面讨论的拥塞控制也叫做<strong>基于窗口</strong>的拥塞控制。发送方维持一个叫做<strong>拥塞窗口</strong> cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p> <p>发送方又是如何知道网络发生了拥塞呢？我们知道，当网络发生拥塞时，路由器就要丢弃分组。因此只要发送方没有按时收到应当到达的确认报文，也就是说，只要出现了超时，就可以猜想网络可能出现了拥塞。现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1%）。因此，<strong>判断网络拥塞的依据就是出现了超时</strong>。</p> <p>下面将讨论拥塞窗口 cwnd 的大小是怎样变化的。我们从“慢开始算法”讲起。<strong>慢开始</strong>算法的思路是这样的：当主机开始发送数据时，由于并不清楚网络的负荷情况，所以如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞。经验证明，较好的方法是先探测一下，即<strong>由小到大逐渐增大发送窗口</strong>，也就是说，<strong>由小到大逐渐增大拥塞窗口数值</strong>。</p> <p>在刚刚开始发送报文段时，先把初始拥塞窗口 cwnd 设置为 不超过 2 至 4 个发送方的最大报文段 SMSS（Sender Maximum Segment Size）的数值。具体的规定如下：</p> <ul> <li>若 SMSS &gt; 2190 字节，则设置<code class="language-plaintext highlighter-rouge">初始拥塞窗口 cwnd = 2 × SMSS 字节</code>，且不得超过 2 个报文段。</li> <li>若（SMSS &gt; 1095 字节）且（SMSS ≤ 2190 字节），则设置<code class="language-plaintext highlighter-rouge">初始拥塞窗口 cwnd = 3 × SMSS 字节</code>，且不得超过 3 个报文段。</li> <li>若 SMSS ≤ 1095 字节，则设置<code class="language-plaintext highlighter-rouge">初始拥塞窗口 cwnd = 4 × SMSS 字节</code>，且不得超过 4 个报文段。</li> </ul> <p>可见这个规定就是限制初始拥塞窗口的字节数。</p> <p>慢开始规定，在每收到一个<strong>对新的报文段的确认</strong>后，可以把拥塞窗口增加最多一个 SMSS 的数值。更具体些，就是：</p> \[拥塞窗口 cwnd 每次的增加量 = min(N, SMSS)\] <p>其中 <code class="language-plaintext highlighter-rouge">N</code> 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。不难看出，当 <code class="language-plaintext highlighter-rouge">N &lt; SMSS</code> 时，拥塞窗口每次的增加量要小于 SMSS。</p> <p>用这样的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</p> <p>下面用例子说明慢开始算法的原理。注意，虽然实际上 TCP 是用字节数作为窗口大小的单位。但为叙述方便起见，我们用报文段的个数作为窗口大小的单位，这样可以使用较小的数字来阐明拥塞控制的原理。</p> <p>在一开始发送方先设置 <code class="language-plaintext highlighter-rouge">cwnd = 1</code>，发送第一个报文段 \(M_1\)，接收方收到后确认 \(M_1\)。发送方收到对 \(M_1\) 的确认后，设置 <code class="language-plaintext highlighter-rouge">cwnd = 2</code>，于是发送方接着发送 \(M_2\) 和 \(M_3\) 两个报文段。接收方收到后发回对 \(M_2\) 和 \(M_3\) 的确认。发送方每收到一个<strong>对新报文段的确认</strong>（重传的不算在內）就使发送方的拥塞窗口加 1，因此发送方在收到两个确认后，设置 <code class="language-plaintext highlighter-rouge">cwnd = 4</code>，并可发送 \(M_4\) ~ \(M_7\)，共 4 个报文段（见图 5-24）。因此使用慢开始算法后，<strong>每经过一个传输轮次</strong>（transmission round），<strong>拥塞窗口 cwnd 就加倍</strong>。</p> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/each-time-the-sender-receives-an-acknowledgement-the-window-cwnd-is-increased-by-1-480.webp 480w,/assets/images/computer-network/each-time-the-sender-receives-an-acknowledgement-the-window-cwnd-is-increased-by-1-800.webp 800w,/assets/images/computer-network/each-time-the-sender-receives-an-acknowledgement-the-window-cwnd-is-increased-by-1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/each-time-the-sender-receives-an-acknowledgement-the-window-cwnd-is-increased-by-1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="发送方每收到一个确认就把窗口 cwnd 加 1" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-24 发送方每收到一个确认就把窗口 cwnd 加 1 </div> <p>从图 5-24 可以看出，一个传输轮次所经历的时间其实就是往返时间 <code class="language-plaintext highlighter-rouge">RTT</code>（请注意，RTT 并非是恒定的数值）。使用“传输<strong>轮次</strong>”是更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。例如，拥塞窗口 cwnd 的大小是 4 个报文段，那么这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。</p> <p>我们还要指出，慢开始的“慢”并不是指 cwnd 的增长速率慢，而是指在 TCP 开始发送报文段时先设置 <code class="language-plaintext highlighter-rouge">cwnd = 1</code>，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大 cwnd。这当然比设置大的 cwnd 值一下子把许多报文段注入到网络中要“<strong>慢得多</strong>”。这对防止网络出现拥塞是一个非常好的方法。</p> <p>注意，在 TCP 的实际运行中，发送方只要收到一个对新报文段的确认，其拥塞窗口 cwnd 就立即加 1， 并可以立即发送新的报文段，而不需要等这个轮次中所有的确认都收到后（如图 5-24 所示的那样）再发送新的报文段。</p> <p>为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限</strong> ssthresh 状态变量。慢开始门限 ssthresh 的用法如下：</p> <ul> <li>当 cwnd &lt; ssthresh 时，使用上述的<strong>慢开始</strong>算法。</li> <li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用<strong>拥塞避免</strong>算法。</li> <li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li> </ul> <p><strong>拥塞避免</strong>算法的思路是让拥塞窗口 cwnd 缓慢地增大，即<strong>每经过一个往返时间</strong> RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“<strong>加法增大</strong>”AI（Additive Increase）的特点。这表明在拥塞避免阶段，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p> <p>下面的示例中，假定 TCP 的发送窗口等于拥塞窗口。当 TCP 连接进行初始化时，把拥塞窗口 cwnd 置为 1。为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。（注意，图 5-25 的横坐标是传输轮次，不是时间。）</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/tcp-congestion-window-cwnd-changes-during-congestion-control-480.webp 480w,/assets/images/computer-network/tcp-congestion-window-cwnd-changes-during-congestion-control-800.webp 800w,/assets/images/computer-network/tcp-congestion-window-cwnd-changes-during-congestion-control-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/tcp-congestion-window-cwnd-changes-during-congestion-control.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 拥塞窗口 cwnd 在拥塞控制时的变化情况" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-25 TCP 拥塞窗口 cwnd 在拥塞控制时的变化情况 </div> <ol> <li>慢开始门限的初始值设置为 16 个报文段，即 <code class="language-plaintext highlighter-rouge">ssthresh = 16</code>。在执行慢开始算法时，发送方每收到一个对新报文段的确认 <code class="language-plaintext highlighter-rouge">ACK</code>，就把拥塞窗口值加 1，然后开始下一轮的传输。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（图中的点❶，此时拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd = 16</code>），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。（注意，“拥塞避免”并非完全能够避免拥塞。“拥塞避免”是说把拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞</strong>。）</li> <li>当拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd = 24</code> 时，网络出现了超时（图中的点❷），发送方判断为网络拥塞。于是调整门限值 <code class="language-plaintext highlighter-rouge">ssthresh = cwnd / 2 = 12</code>，同时设置拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd = 1</code>，进入慢开始阶段。</li> <li>按照慢开始算法，发送方每收到一个对新报文段的确认 <code class="language-plaintext highlighter-rouge">ACK</code>，就把拥塞窗口值加 1。当拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd = ssthresh = 12</code> 时（图中的点❸，这是<strong>新</strong>的 ssthresh 值），改为执行拥塞避免算法，拥塞窗口按线性规律增大。</li> <li> <p>当拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd = 16</code> 时（图中的点❹），出现了一个新的情况，就是发送方一连收到 3 个对同一个报文段的重复确认（图中记为 <code class="language-plaintext highlighter-rouge">3-ACK</code>）。关于这个问题要解释如下。</p> <p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口 cwnd 又设置为 1，因而降低了传输效率。</p> <p>采用快重传算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了<strong>失序的报文段</strong>也要立即发出对已收到的报文段的重复确认。如图 5-26 所示，接收方收到了 \(M_1\) 和 \(M_2\) 后都分别及时发出了确认。现假定接收方没有收到 \(M_3\) 但却收到了 \(M_4\)。本来接收方可以什么都不做。但按照快重传算法，接收方<strong>必须立即发送 \(M_2\) 的重复确认</strong>，以便让发送方及早知道接收方没有收到报文段 \(M_3\)。发送方接着发送 \(M_5\) 和 \(M_6\)。接收方收到后也仍要再次分别发出对 \(M_2\) 的重复确认。这样，发送方共收到了接收方的 4 个对 $ $M_2 \(的确认，其中后 3 个都是重复确认。快重传算法规定，发送方只要**一连收到 3 个重复确认**，就知道接收方确实没有收到报文段\) M_3 $$，因而应当<strong>立即进行重传</strong>（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约 20%。</p> <p>因此，在图 5-25 中的点❹，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。</p> </li> <li>这时，发送方调整门限值 <code class="language-plaintext highlighter-rouge">ssthresh = = cwnd / 2 = 8</code>，同时设置拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd = ssthresh = 8</code>（见图 5-25 中的点❺），并开始执行拥塞避免算法（在图 5-25 中还标注有“TCP Reno 版本”，表示区别于老的 TCP Tahao 版本）。</li> </ol> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/fast-retransmission-diagram-480.webp 480w,/assets/images/computer-network/fast-retransmission-diagram-800.webp 800w,/assets/images/computer-network/fast-retransmission-diagram-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/fast-retransmission-diagram.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="快重传的示意图" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-26 快重传的示意图 </div> <p>注意，也有的快恢复实现是把快恢复开始时的拥塞窗口 cwnd 值再增大一些（增大 3 个报文段的长度），即等于新的 <code class="language-plaintext highlighter-rouge">ssthresh + 3 × MSS</code>。这样做的理由是：既然发送方收到 3 个重复的确认，就表明有 3 个分组已经离开了网络。这 3 个分组不再消耗网络的资源而是停留在接收方的缓存中（接收方发送出 3 个重复的确认就证明了这个事实）。可见现在网络中并不是堆积了分组而是减少了 3 个分组。因此可以适当把拥塞窗口扩大些。</p> <p>从图 5-25 可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的，这常称为<strong>加法增大</strong> AI（Additive Increase）。而一旦出现超时或 3 个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD（Multiplicative Decrease）。二者合在一起就是所谓的 AIMD 算法。采用这样的拥塞控制方法使得 TCP 的性能有明显的改进[STEV94][RFC 5681]。根据以上所述，TCP 的拥塞控制可以归纳为图 5-27 的流程图。这个流程图就比图 5-25 所示的特例要更加全面些。例如，图 5-25 没有说明在慢开始阶段如果出现了超时（即出现了网络拥塞）或出现 <code class="language-plaintext highlighter-rouge">3-ACK</code>，发送方应采取什么措施。但从图 5-27 的流程图就可以很明确地知道发送方应采取的措施。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/flow-diagram-of-tcp-congestion-control-480.webp 480w,/assets/images/computer-network/flow-diagram-of-tcp-congestion-control-800.webp 800w,/assets/images/computer-network/flow-diagram-of-tcp-congestion-control-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/flow-diagram-of-tcp-congestion-control.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 的拥塞控制的流程图" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-27 TCP 的拥塞控制的流程图 </div> <p>在这一节的开始我们就假定了接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。但实际上接收方的缓存空间总是有限的。接收方根据自己的接收能力设定了接收方窗口 rwnd，并把这个窗口值写入 TCP 首部中的窗口字段，传送给发送方。因此，<strong>接收方窗口</strong>又称为<strong>通知窗口</strong>（advertised window）。因此，从接收方对发送方的流量控制的角度考虑，<strong>发送方的发送窗口一定不能超过对方给出的接收方窗口值 rwnd</strong>。如果把本节所讨论的拥塞控制和接收方对发送方的流量控制一起考虑，那么很显然，发送方的窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，也就是说：</p> \[发送方窗口的上限值 = Min[rwnd, cwnd]\] <p>上式指出：</p> <ul> <li>当 <code class="language-plaintext highlighter-rouge">rwnd &lt; cwnd</code> 时，是接收方的接收能力限制发送方窗口的最大值。</li> <li>当 <code class="language-plaintext highlighter-rouge">cwnd &lt; rwnd</code> 时，则是网络的拥塞程度限制发送方窗口的最大值。</li> </ul> <p>也就是说， rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。</p> <h3 id="83-主动队列管理-aqm">8.3 主动队列管理 AQM</h3> <p>网络层的策略对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。在最简单的情况下，路由器的队列通常都是按照“<strong>先进先出</strong>” FIFO（First In First Out）的规则处理到来的分组。由于队列长度总是有限的，因此当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做<strong>尾部丢弃策略</strong>（tail-drop policy）。</p> <p>路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入拥塞控制的慢开始状态，结果使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。更为严重的是，在网络中通常有很多的 TCP 连接（它们有不同的源点和终点），这些连接中的报文段通常是复用在网络层的 IP 数据报中传送。在这种情况下，若发生了路由器中的尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这许多 TCP 连接在同一时间突然都进入到慢开始状态。这在 TCP 的术语中称为<strong>全局同步</strong>（global syncronization）。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p> <p>为了避免发生网络中的全局同步现象，在 1998 年提出了<strong>主动队列管理</strong> AQM（Active Queue Management）。所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。这样就太被动了。应当在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。这样就提醒了发送方放慢发送的速率，因而有可能使网络拥塞的程度减轻，甚至不出现网络拥塞。AQM 可以有不同实现方法，其中曾流行多年的就是<strong>随机早期检测</strong> RED（Random Early Detection）。实现 RED 时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED 就按照规定的算法先计算当前的平均队列长度。</p> <ul> <li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。</li> <li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li> <li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率把新到达的分组丢弃（这就体现了丢弃分组的随机性）。</li> </ul> <p>由此可见，RED 不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，而是在检测到网络拥塞的早期征兆时（即路由器的平均队列长度达到一定数值时），就以概率 p 丢弃个别的分组，让拥塞控制只在个别的 TCP 连接上进行，因而避免发生全局性的拥塞控制。</p> <p>在 RED 的操作中，最难处理的就是丢弃概率 <code class="language-plaintext highlighter-rouge">p</code> 的选择，因为 <code class="language-plaintext highlighter-rouge">p</code> 并不是个常数。对每个到达的分组，都必须计算丢弃概率 <code class="language-plaintext highlighter-rouge">p</code> 的数值。IETF 曾经推荐在互联网中的路由器使用 RED 机制[RFC 2309]，但多年的实践证明，RED 的使用效果并不太理想。因此，在 2015 年公布的 RFC 7567 已经把过去的 RFC 2309 列为“陈旧的”，并且不再推荐使用 RED。对路由器进行主动队列管理 AQM 仍是必要的。AQM 实际上就是对路由器中的分组排队进行智能管理，而不是简单地把队列的尾部丢弃。现在已经有几种不同的算法来代替旧的 RED，但都还在实验阶段。目前还没有一种算法能够成为 IETF 的标准。</p> <h2 id="九tcp-的运输连接管理">九、TCP 的运输连接管理</h2> <p>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的建立和释放是每次面向连接的通信中必不可少的过程。运输连接有三个阶段，即：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p> <p>在 TCP 连接建立过程中要解决以下三个问题：</p> <ul> <li>要使每一方能够确知对方的存在。</li> <li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</li> <li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li> </ul> <p>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做<strong>客户</strong>（client），而被动等待连接建立的应用进程叫做<strong>服务器</strong>（server）。</p> <h3 id="91-tcp-连接建立">9.1 TCP 连接建立</h3> <p>TCP 建立连接的过程叫做<strong>握手</strong>，握手需要在客户和服务器之间交换三个 TCP 报文段。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/a-three-packet-handshake-is-used-to-establish-a-TCP-connection-480.webp 480w,/assets/images/computer-network/a-three-packet-handshake-is-used-to-establish-a-TCP-connection-800.webp 800w,/assets/images/computer-network/a-three-packet-handshake-is-used-to-establish-a-TCP-connection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/a-three-packet-handshake-is-used-to-establish-a-TCP-connection.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="用三报文握手建立 TCP 连接" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-28 用三报文握手建立 TCP 连接 </div> <p>假定主机 <code class="language-plaintext highlighter-rouge">A</code> 运行的是 TCP 客户程序，而 <code class="language-plaintext highlighter-rouge">B</code> 运行 TCP 服务器程序。最初两端的 TCP 进程都处于 <code class="language-plaintext highlighter-rouge">CLOSED</code>（关闭）状态。在本例中，<code class="language-plaintext highlighter-rouge">A</code> <strong>主动打开连接</strong>，而 <code class="language-plaintext highlighter-rouge">B</code> <strong>被动打开连接</strong>。</p> <ol> <li>一开始，<code class="language-plaintext highlighter-rouge">B</code> 的 TCP 服务器进程先创建<strong>传输控制块</strong> TCB，准备接受客户进程的连接请求。然后服务器进程就处于 <code class="language-plaintext highlighter-rouge">LISTEN</code>（收听）状态，等待客户的连接请求。如有，即作出响应。</li> <li><code class="language-plaintext highlighter-rouge">A</code> 的 TCP 客户进程也是首先创建传输控制模块 TCB。然后，在打算建立 TCP 连接时，向 <code class="language-plaintext highlighter-rouge">B</code> 发出连接请求报文段，这时首部中的同步位 <code class="language-plaintext highlighter-rouge">SYN = 1</code>，同时选择一个初始序号 <code class="language-plaintext highlighter-rouge">seq = x</code>。TCP 规定，<code class="language-plaintext highlighter-rouge">SYN</code> 报文段（即 <code class="language-plaintext highlighter-rouge">SYN = 1</code> 的报文段）不能携带数据，但要<strong>消耗掉一个序号</strong>。这时，TCP 客户进程进入 <code class="language-plaintext highlighter-rouge">SYN-SENT</code>（同步已发送）状态。</li> <li><code class="language-plaintext highlighter-rouge">B</code> 收到连接请求报文段后，如同意建立连接， 则向 <code class="language-plaintext highlighter-rouge">A</code> 发送确认。在确认报文段中应把 <code class="language-plaintext highlighter-rouge">SYN</code> 位和 <code class="language-plaintext highlighter-rouge">ACK</code> 位都置 1，确认号是 <code class="language-plaintext highlighter-rouge">ack = x + 1</code>，同时也为自己选择一个初始序号 <code class="language-plaintext highlighter-rouge">seq = y</code>。注意，这个报文段也不能携带数据，但同样要<strong>消耗掉一个序号</strong>。这时 TCP 服务器进程进入 <code class="language-plaintext highlighter-rouge">SYN-RCVD</code>（同步收到）状态。</li> <li>TCP 客户进程收到 <code class="language-plaintext highlighter-rouge">B</code> 的确认后，还要向 <code class="language-plaintext highlighter-rouge">B</code> 给出确认。确认报文段的 <code class="language-plaintext highlighter-rouge">ACK = 1</code>，确认号 <code class="language-plaintext highlighter-rouge">ack = y + 1</code>，而自己的序号 <code class="language-plaintext highlighter-rouge">seq = x + 1</code>。TCP 的标准规定，<code class="language-plaintext highlighter-rouge">ACK</code> 报文段可以携带数据。但<strong>如果不携带数据则不消耗序号</strong>，在这种情况下，下一个数据报文段的序号仍是 <code class="language-plaintext highlighter-rouge">seq = x + 1</code>。这时，TCP 连接已经建立，<code class="language-plaintext highlighter-rouge">A</code> 进入 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code>（已建立连接）状态。当 <code class="language-plaintext highlighter-rouge">B</code> 收到 <code class="language-plaintext highlighter-rouge">A</code> 的确认后，也进入 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> 状态。</li> </ol> <p>上面给出的连接建立过程叫做<strong>三报文握手</strong>。注意，在图 5-28 中 <code class="language-plaintext highlighter-rouge">B</code> 发送给 <code class="language-plaintext highlighter-rouge">A</code> 的报文段，也可拆成两个报文段。可以先发送一个确认报文段（<code class="language-plaintext highlighter-rouge">ACK = 1</code>，<code class="language-plaintext highlighter-rouge">ack = x + 1</code>），然后再发送一个同步报文段（<code class="language-plaintext highlighter-rouge">SYN = 1</code>，<code class="language-plaintext highlighter-rouge">seq = y</code>）。这样的过程就变成了<strong>四报文握手</strong>，但效果是一样的。</p> <p>为什么 <code class="language-plaintext highlighter-rouge">A</code> 最后还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了 <code class="language-plaintext highlighter-rouge">B</code>，因而产生错误。所谓“已失效的连接请求报文段”是这样产生的：</p> <ul> <li>正常情况下：<code class="language-plaintext highlighter-rouge">A</code> 发出连接请求，但因连接请求报文丢失而未收到确认。于是 <code class="language-plaintext highlighter-rouge">A</code> 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。<code class="language-plaintext highlighter-rouge">A</code> 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 <code class="language-plaintext highlighter-rouge">B</code>，没有“已失效的连接请求报文段”。</li> <li>异常情况：<code class="language-plaintext highlighter-rouge">A</code> 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 <code class="language-plaintext highlighter-rouge">B</code>。本来这是一个早已失效的报文段。但 <code class="language-plaintext highlighter-rouge">B</code> 收到此失效的连接请求报文段后，就误认为是 <code class="language-plaintext highlighter-rouge">A</code> 又发出一次新的连接请求。于是就向 <code class="language-plaintext highlighter-rouge">A</code> 发出确认报文段，同意建立连接。假定不采用报文握手，那么只要 <code class="language-plaintext highlighter-rouge">B</code> 发出确认，新的连接就建立了。由于现在 <code class="language-plaintext highlighter-rouge">A</code> 并没有发出建立连接的请求，因此不会理睬 <code class="language-plaintext highlighter-rouge">B</code> 的确认，也不会向 <code class="language-plaintext highlighter-rouge">B</code> 发送数据。但 <code class="language-plaintext highlighter-rouge">B</code> 却以为新的运输连接已经建立了，并一直等待 <code class="language-plaintext highlighter-rouge">A</code> 发来数据。<code class="language-plaintext highlighter-rouge">B</code> 的许多资源就这样白白浪费了。</li> </ul> <p>采用三报文握手的办法，可以防止上述现象的发生。例如在刚才的异常情况下，A 不会向 B 的确认发出确认。B 由于收不到确认，就知道 A 并没有要求建立连接。</p> <h3 id="92-tcp-的连接释放">9.2 TCP 的连接释放</h3> <p>数据传输结束后，通信的双方都可释放连接。现在 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 都处于 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> 状态（图 5-29）。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-process-of-releasing-the-TCP-connection-480.webp 480w,/assets/images/computer-network/the-process-of-releasing-the-TCP-connection-800.webp 800w,/assets/images/computer-network/the-process-of-releasing-the-TCP-connection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-process-of-releasing-the-TCP-connection.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 连接释放的过程" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-29 TCP 连接释放的过程 </div> <ol> <li><code class="language-plaintext highlighter-rouge">A</code> 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。<code class="language-plaintext highlighter-rouge">A</code> 把连接释放报文段首部的终止控制位 <code class="language-plaintext highlighter-rouge">FIN = 1</code>，其序号 <code class="language-plaintext highlighter-rouge">seq = u</code>，它等于前面已传送过的数据的最后一个字节的序号加 1。这时 <code class="language-plaintext highlighter-rouge">A</code> 进入 <code class="language-plaintext highlighter-rouge">FIN-WAIT-1</code>（终止等待 1）状态，等待 <code class="language-plaintext highlighter-rouge">B</code> 的确认。注意，TCP 规定，<code class="language-plaintext highlighter-rouge">FIN</code> 报文段即使不携带数据，它也消耗掉一个序号。</li> <li><code class="language-plaintext highlighter-rouge">B</code> 收到连接释放报文段后即发出确认，确认号是 <code class="language-plaintext highlighter-rouge">ack = u + 1</code>，而这个报文段自己的序号是 <code class="language-plaintext highlighter-rouge">seq = v</code>，等于 <code class="language-plaintext highlighter-rouge">B</code> 前面已传送过的数据的最后一个字节的序号加 1。然后 <code class="language-plaintext highlighter-rouge">B</code> 就进入 <code class="language-plaintext highlighter-rouge">CLOSE-WAIT</code>（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 <code class="language-plaintext highlighter-rouge">A</code> 到 <code class="language-plaintext highlighter-rouge">B</code> 这个方向的连接就释放了，这时的 TCP 连接处于<strong>半关闭</strong>（half-close）状态，即 <code class="language-plaintext highlighter-rouge">A</code> 已经没有数据要发送了，但 <code class="language-plaintext highlighter-rouge">B</code> 若发送数据，<code class="language-plaintext highlighter-rouge">A</code> 仍要接收。也就是说，从 <code class="language-plaintext highlighter-rouge">B</code> 到 <code class="language-plaintext highlighter-rouge">A</code> 这个方向的连接并未关闭，这个状态可能会持续一段时间。</li> <li><code class="language-plaintext highlighter-rouge">A</code> 收到来自 <code class="language-plaintext highlighter-rouge">B</code> 的确认后，就进入 <code class="language-plaintext highlighter-rouge">FIN-WAIT-2</code>（终止等待 2）状态，等待 <code class="language-plaintext highlighter-rouge">B</code> 发出的连接释放报文段。</li> <li>若 <code class="language-plaintext highlighter-rouge">B</code> 已经没有要向 <code class="language-plaintext highlighter-rouge">A</code> 发送的数据，其应用进程就通知 TCP 释放连接。这时 <code class="language-plaintext highlighter-rouge">B</code> 发出的连接释放报文段必须使 <code class="language-plaintext highlighter-rouge">FIN = 1</code>。现假定 <code class="language-plaintext highlighter-rouge">B</code> 的序号为 <code class="language-plaintext highlighter-rouge">seq = w</code>（在半关闭状态 <code class="language-plaintext highlighter-rouge">B</code> 可能又发送了一些数据）。<code class="language-plaintext highlighter-rouge">B</code> 还必须重复上次已发送过的确认号 <code class="language-plaintext highlighter-rouge">ack = u + 1</code>。这时 <code class="language-plaintext highlighter-rouge">B</code> 就进入 <code class="language-plaintext highlighter-rouge">LAST-ACK</code>（最后确认）状态，等待 <code class="language-plaintext highlighter-rouge">A</code> 的确认。</li> <li><code class="language-plaintext highlighter-rouge">A</code> 在收到 <code class="language-plaintext highlighter-rouge">B</code> 的连接释放报文段后，必须对此发出确认。在确认报文段中把 <code class="language-plaintext highlighter-rouge">ACK = 1</code>，确认号 <code class="language-plaintext highlighter-rouge">ack = w + 1</code>，而自己的序号是 <code class="language-plaintext highlighter-rouge">seq = u + 1</code>（根据 TCP 标准，前面发送过的 <code class="language-plaintext highlighter-rouge">FIN</code> 报文段要消耗一个序号）。然后进入到 <code class="language-plaintext highlighter-rouge">TIME-WAIT</code>（时间等待）状态。注意，现在 TCP 连接还没有释放掉。必须经过<strong>时间等待计时器</strong>（TIME-WAIT timer）设置的时间 <code class="language-plaintext highlighter-rouge">2MSL</code> 后，<code class="language-plaintext highlighter-rouge">A</code> 才进入到 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态。时间 MSL 叫做<strong>最长报文段寿命</strong>（Maximum Segment Lifetime），RFC 793 建议设为 2 分钟。但这完全是从工程上来考虑的，对于现在的网络，MSL = 2 分钟可能太长了一些。因此 TCP 允许不同的实现可根据具体情况使用更小的 MSL 值。因此，从 <code class="language-plaintext highlighter-rouge">A</code> 进入到 <code class="language-plaintext highlighter-rouge">TIME-WAIT</code> 状态后，要经过 4 分钟才能进入到 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态，才能开始建立下一个新的连接。当 <code class="language-plaintext highlighter-rouge">A</code> 撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。</li> </ol> <p>为什么 <code class="language-plaintext highlighter-rouge">A</code> 在 <code class="language-plaintext highlighter-rouge">TIME-WAIT</code> 状态必须等待 <code class="language-plaintext highlighter-rouge">2MSL</code> 的时间呢？</p> <ul> <li>第一，为了保证 <code class="language-plaintext highlighter-rouge">A</code> 发送的最后一个 <code class="language-plaintext highlighter-rouge">ACK</code> 报文段能够到达 <code class="language-plaintext highlighter-rouge">B</code>。这个 <code class="language-plaintext highlighter-rouge">ACK</code> 报文段有可能丢失，因而使处在 <code class="language-plaintext highlighter-rouge">LAST-ACK</code> 状态的 <code class="language-plaintext highlighter-rouge">B</code> 收不到对已发送的 <code class="language-plaintext highlighter-rouge">FIN</code> + <code class="language-plaintext highlighter-rouge">ACK</code> 报文段的确认。<code class="language-plaintext highlighter-rouge">B</code> 会超时重传这个 <code class="language-plaintext highlighter-rouge">FIN</code> + <code class="language-plaintext highlighter-rouge">ACK</code> 报文段，而 <code class="language-plaintext highlighter-rouge">A</code> 就能在 <code class="language-plaintext highlighter-rouge">2MSL</code> 时间内收到这个重传的 <code class="language-plaintext highlighter-rouge">FIN</code> + <code class="language-plaintext highlighter-rouge">ACK</code> 报文段。接着 <code class="language-plaintext highlighter-rouge">A</code> 重传一次确认，重新启动 <code class="language-plaintext highlighter-rouge">2MSL</code> 计时器。最后，<code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 都正常进入到 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态。如果 <code class="language-plaintext highlighter-rouge">A</code> 在 <code class="language-plaintext highlighter-rouge">TIME-WAIT</code> 状态不等待一段时间，而是在发送完 <code class="language-plaintext highlighter-rouge">ACK</code> 报文段后立即释放连接，那么就无法收到 <code class="language-plaintext highlighter-rouge">B</code> 重传的 <code class="language-plaintext highlighter-rouge">FIN</code> + <code class="language-plaintext highlighter-rouge">ACK</code> 报文段，因而也不会再发送一次确认报文段。这样，<code class="language-plaintext highlighter-rouge">B</code> 就无法按照正常步骤进入 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态。</li> <li>第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。<code class="language-plaintext highlighter-rouge">A</code> 在发送完最后一个 <code class="language-plaintext highlighter-rouge">ACK</code> 报文段后，再经过时间 <code class="language-plaintext highlighter-rouge">2MSL</code>，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。<code class="language-plaintext highlighter-rouge">B</code> 只要收到了 <code class="language-plaintext highlighter-rouge">A</code> 发出的确认，就进入 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态。同样，在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。我们注意到，<code class="language-plaintext highlighter-rouge">B</code> 结束 TCP 连接的时间要比 <code class="language-plaintext highlighter-rouge">A</code> 早一些。</li> </ul> <p>上述的 TCP 连接释放过程是四报文握手。</p> <p>除时间等待计时器外，TCP 还设有一个<strong>保活计时器</strong>（keepalive timer）。设想有这样的情况：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p> <h3 id="93-tcp-的有限状态机">9.3 TCP 的有限状态机</h3> <p>为了更清晰地看出 TCP 连接的各种状态之间的关系，图 5-30 给出了 TCP 的有限状态机。图中每个方框即 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。请注意图中有三种不同的箭头。粗实线箭头表示对客户进程的正常变迁。粗虚线箭头表示对服务器进程的正常变迁。另一种细线箭头表示异常变迁。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-finite-state-machine-of-TCP-480.webp 480w,/assets/images/computer-network/the-finite-state-machine-of-TCP-800.webp 800w,/assets/images/computer-network/the-finite-state-machine-of-TCP-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/computer-network/the-finite-state-machine-of-TCP.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 的有限状态机" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 5-30 TCP 的有限状态机 </div> <p>我们可以把图 5-30 和前面的图 5-28、图 5-29 对照起来看。在图 5-28 和图 5-29 中左边客户进程从上到下的状态变迁，就是图 5-30 中粗实线箭头所指的状态变迁。而在图 5-28 和5 -29 右边服务器进程从上到下的状态变迁，就是图 5-30中粗虚线箭头所指的状态变迁。</p> <h2 id="十本章的重要概念">十、本章的重要概念</h2> <ul> <li>运输层提供应用进程间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</li> <li>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</li> <li>运输层有两个主要的协议：TCP 和 UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。</li> <li>运输层用一个 16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。</li> <li>两台计算机中的进程要互相通信，不仅要知道对方的IP地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。</li> <li>运输层的端口号分为服务器端使用的端口号（0 ~ 1023 指派给熟知端口，1024 ～ 49151 是登记端口号）和客户端暂时使用的端口号（49152 ~ 65535）。</li> <li>UDP 的主要特点是：（1）无连接；（2）尽最大努力交付；（3）面向报文；（4）无拥塞控制；（5）支持一对一，一对多、多对一和多对多的交互通信；（6）首部开销小（只有四个字段：源端口、目的端口、长度、检验和）。</li> <li>TCP 的主要特点是：（1）面向连接；（2）每一条 TCP 连接只能是点对点的（一对一）；（3）提供可靠交付的服务；（4）提供全双工通信；（5）面向字节流。</li> <li>TCP 用主机的 IP 地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。</li> <li>停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。分组需要进行编号。</li> <li>超时重传是指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</li> <li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</li> <li>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已正确收到了。</li> <li>TCP 报文段首部的前 20 个字节是固定的，后面有 4N 字节是根据需要而增加的选项（N 是整数）。在一个TCP 连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。</li> <li>TCP 首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明：到序号N-1为止的所有数据都已正确收到。</li> <li>TCP 首部中的窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着的。</li> <li>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口前沿通常是不断向前移动的。</li> <li>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</li> <li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</li> <li>流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li> <li>为了进行拥塞控制，TCP 的发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</li> <li>TCP 的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网络层，也可以使路由器采用适当的分组丢弃策略(如主动队列管理 AQM)，以减少网络拥塞的发生。</li> <li>运输连接有三个阶段，即：连接建立、数据传送和连接释放。</li> <li>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 的连接建立采用三报文握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。</li> <li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后就进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接。</li> </ul> <h2 id="十一参考">十一、参考</h2> <ul> <li>谢希仁，<a href="https://book.douban.com/subject/26960678/">《计算机网络（第七版） - 第 5 章 运输层》</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="computer"/><category term="networks"/><category term="transport layer"/><category term="OSI"/><summary type="html"><![CDATA[本章先概括介绍运输层协议的特点、进程之间的通信和端口等重要概念，然后讲述比较简单的 UDP 协议。其余的篇幅都是讨论较为复杂但非常重要的 TCP 协议和可靠传输的工作原理，包括停止等待协议和 ARQ 协议。在详细讲述 TCP 报文段的首部格式之后，讨论 TCP 的三个重要问题：滑动窗口、流量控制和拥塞控制机制。最后，介绍 TCP 的连接管理。]]></summary></entry><entry><title type="html">响应式 Web 设计</title><link href="https://feng-zhang0712.github.io//blog/2024/responsive-web-design/" rel="alternate" type="text/html" title="响应式 Web 设计"/><published>2024-09-14T00:00:00+00:00</published><updated>2024-09-14T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/responsive-web-design</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/responsive-web-design/"><![CDATA[<h2 id="一简介">一、简介</h2> <p>响应式 Web 设计，指网页内容会随着访问它的视口及设备的不同而呈现不同的样式。</p> <p>在响应式设计的早期，人们会针对不同的流行的设备宽度设置<strong>断点</strong>，所谓“断点”，就是某个宽度临界点，跨过这个点布局就会发生显著变化。显然，这并不是一个好的做法，因为这样实际上把设计跟特定的屏幕大小绑定了。既然是响应式设计，那应该与显示它的设备无关才对，而不是只在某些屏幕中才最合适。断点应该由内容和设计本身决定，也就是，根据项目的实际需求设计决定。</p> <h2 id="二媒体查询">二、媒体查询</h2> <p><strong>媒体查询</strong>（Media Queries）主要用于设计响应式 Web 设计，使网页能够适应不同的设备和屏幕尺寸。即根据设备的特性（如屏幕宽度、高度、分辨率等）应用不同的样式。W3C 对媒体查询的定义是：媒体查询包含媒体类型和零个或多个检测媒体特性的表达式（比如，<code class="language-plaintext highlighter-rouge">width</code>、<code class="language-plaintext highlighter-rouge">height</code> 和 <code class="language-plaintext highlighter-rouge">color</code> 都是可用于媒体查询的特性）。使用媒体查询，可以不必修改内容本身，而让网页适配不同的设备。</p> <p>常用媒体特性如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">width</code>：视口的宽度。</li> <li><code class="language-plaintext highlighter-rouge">height</code>：视口的高度。</li> <li><code class="language-plaintext highlighter-rouge">device-width</code>：设备屏幕的宽度。</li> <li><code class="language-plaintext highlighter-rouge">device-height</code>：设备屏幕的高度。</li> <li><code class="language-plaintext highlighter-rouge">resolution</code>：设备屏幕的分辨率，通常以 <code class="language-plaintext highlighter-rouge">dpi</code>（每英寸点数）或 <code class="language-plaintext highlighter-rouge">dppx</code>（每像素点数）表示。</li> <li><code class="language-plaintext highlighter-rouge">orientation</code>：设备的方向，可以是 <code class="language-plaintext highlighter-rouge">portrait</code> 或 <code class="language-plaintext highlighter-rouge">landscape</code>。</li> <li><code class="language-plaintext highlighter-rouge">aspect-ratio</code>：视口的宽高比。不如，16∶9 的宽屏显示器可以写成 <code class="language-plaintext highlighter-rouge">aspect-ratio: 16/9</code>。</li> <li><code class="language-plaintext highlighter-rouge">color</code>：设备的颜色位深。</li> <li><code class="language-plaintext highlighter-rouge">color-index</code>：设备颜色查找表中的条目数，值必须是数值，且不能为负。</li> <li><code class="language-plaintext highlighter-rouge">monochrome</code>：单色帧缓冲中表示每个像素的位数，值必须是数值（整数），比如 <code class="language-plaintext highlighter-rouge">monochrome: 2</code>，且不能为负。</li> <li><code class="language-plaintext highlighter-rouge">scan</code>：针对电视的逐行扫描（progressive）和隔行扫描（interlace）。例如 720p HD TV（720p 中的 <code class="language-plaintext highlighter-rouge">p</code> 表示 progressive，即逐行）可以使用 <code class="language-plaintext highlighter-rouge">scan: progressive</code> 来判断； 而 1080i HD TV（1080i 中的 <code class="language-plaintext highlighter-rouge">i</code> 表示 interlace，即隔行）可以使用 <code class="language-plaintext highlighter-rouge">scan: interlace</code> 来判断。</li> <li><code class="language-plaintext highlighter-rouge">grid</code>：设备基于栅格还是位图。</li> </ul> <p>上面列表中的特性，除 <code class="language-plaintext highlighter-rouge">grid</code> 外，都可以加上 <code class="language-plaintext highlighter-rouge">min-</code> 或 <code class="language-plaintext highlighter-rouge">max-</code> 前缀以指定范围。</p> <h3 id="21-媒体查询的语法">2.1 媒体查询的语法</h3> <p>下面是一个最简单的媒体查询语法结构。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@media</span> <span class="n">media-type</span> <span class="n">and</span> <span class="p">(</span><span class="n">media-feature</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">/* CSS规则 */</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">media-type</code>：指定设备类型，如 <code class="language-plaintext highlighter-rouge">screen</code>、<code class="language-plaintext highlighter-rouge">print</code> 等。可以省略，表示适用于所有类型（此时 <code class="language-plaintext highlighter-rouge">media-type: all</code>）。</li> <li><code class="language-plaintext highlighter-rouge">media-feature</code>：指定的媒体特性，如 <code class="language-plaintext highlighter-rouge">max-width</code>、<code class="language-plaintext highlighter-rouge">min-width</code> 等。</li> </ul> <p>也可以在 <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性中指定设备类型。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"style sheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">media=</span><span class="s">"screen"</span> <span class="na">href=</span><span class="s">"style.css"</span><span class="nt">&gt;</span> 
</code></pre></div></div> <h3 id="22-组合媒体查询">2.2 组合媒体查询</h3> <p>多个媒体查询组合，使用逗号（<code class="language-plaintext highlighter-rouge">,</code>）分隔不同的查询条件。表示如果任意一个条件为真则应用样式。还可以使用逻辑运算符 <code class="language-plaintext highlighter-rouge">and</code>、<code class="language-plaintext highlighter-rouge">or</code>、<code class="language-plaintext highlighter-rouge">not</code> 组合多个条件。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* 适用于屏幕最大宽度为600px或屏幕高度为 800px 的设备 */</span>
<span class="k">@media</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">),</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-height</span><span class="p">:</span> <span class="m">800px</span><span class="p">)</span> <span class="p">{</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">lightblue</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c">/* 适用于屏幕宽度在 600px 到 1200px 之间且横向模式的设备 */</span>
<span class="k">@media</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">min-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span> <span class="m">1200px</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">orientation</span><span class="p">:</span> <span class="nb">landscape</span><span class="p">)</span> <span class="p">{</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">lightgreen</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以在使用 <code class="language-plaintext highlighter-rouge">@import</code> 导入 CSS 时使用媒体查询，有条件地向当前样式表中加载其他样式表。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@import</span> <span class="sx">url("phone.css")</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span><span class="m">360px</span><span class="p">);</span> 
</code></pre></div></div> <p>上面的代码表示，<code class="language-plaintext highlighter-rouge">phone.css</code> 样式表生效的条件是：设备类型必须是屏幕设备，且视口不超过 360px。</p> <p>注意，在针对所有设备的媒体查询中，可以使用简写语法，即省略关键字 <code class="language-plaintext highlighter-rouge">all</code>（以及紧随其后的 <code class="language-plaintext highlighter-rouge">and</code>）。换句话说，如果不指定关键字，则关键字就是 <code class="language-plaintext highlighter-rouge">all</code>。</p> <h3 id="23-视口的-meta-标签">2.3 视口的 meta 标签</h3> <p>视口的 <code class="language-plaintext highlighter-rouge">meta</code> 标签，是网页与移动浏览器的接口。网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。视口的 <code class="language-plaintext highlighter-rouge">meta</code> 标签主要使用以下几个属性控制页面在移动端的行为。</p> <ul> <li><code class="language-plaintext highlighter-rouge">width</code>：用于设置页面的宽度。</li> <li><code class="language-plaintext highlighter-rouge">height</code>：用于设置页面的高度，通常设置了 <code class="language-plaintext highlighter-rouge">width</code> 就不会再设置 <code class="language-plaintext highlighter-rouge">height</code>。</li> <li><code class="language-plaintext highlighter-rouge">initial-scale</code>：设置页面的初始缩放比例。</li> <li><code class="language-plaintext highlighter-rouge">user-scalable</code>：一个布尔值，用于设置页面是否可以缩放。</li> <li><code class="language-plaintext highlighter-rouge">minimum-scale</code>：设置页面的最小缩放比例，只有在 <code class="language-plaintext highlighter-rouge">user-scalable=true</code> 时，此属性才会生效。</li> <li><code class="language-plaintext highlighter-rouge">maximum-scale</code>：设置页面的最大缩放比例，只有在 <code class="language-plaintext highlighter-rouge">user-scalable=true</code> 时，此属性才会生效。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">meta</span> <span class="nt">name</span><span class="o">=</span><span class="s1">"viewport"</span> <span class="nt">content</span><span class="o">=</span><span class="s1">"width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=0.5, maximum-scale=3"</span> <span class="o">/&gt;</span> 
</code></pre></div></div> <p>上面的代码表示，在移动设备上，页面的宽度为设备宽度，页面初始的缩放比例为 1，允许用户进行缩放操作，且最小和最大缩放比例分别为 0.5 和 3。</p> <h2 id="三弹性布局网格布局与响应式图片">三、弹性布局、网格布局与响应式图片</h2> <p>布局的传统解决方案，基于盒状模型，依赖 <code class="language-plaintext highlighter-rouge">display</code> + <code class="language-plaintext highlighter-rouge">position</code> + <code class="language-plaintext highlighter-rouge">float</code> 等属性。而现代的布局方案，更多的是使用 Flex 和 Grid 布局。下面依次对他们进行介绍。</p> <h3 id="31-盒模型">3.1 盒模型</h3> <p>CSS 盒模型指一个元素在页面上所占据的空间。由四部分组成：<code class="language-plaintext highlighter-rouge">content</code>、<code class="language-plaintext highlighter-rouge">padding</code>、<code class="language-plaintext highlighter-rouge">border</code> 和 <code class="language-plaintext highlighter-rouge">margin</code>。盒模型主要分为两种：标准盒模型和替代盒模型。</p> <p>（1）标准盒模型（content-box）</p> <p>此模型元素的 <code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code>，只包含内容的宽高，不包含 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>。 此时 <code class="language-plaintext highlighter-rouge">padding</code>、<code class="language-plaintext highlighter-rouge">border</code> 和 <code class="language-plaintext highlighter-rouge">margin</code> 都在这个盒子的外部。</p> <p>（2）替代盒模型（border-box）</p> <p>也叫 IE 盒子模型，此模型元素的 <code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code>，包含 <code class="language-plaintext highlighter-rouge">content</code>、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>。此时 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code> 都在盒子内部。</p> <p>（3）可以通过 <code class="language-plaintext highlighter-rouge">box-sizing</code> 属性，设置一个元素显示为哪种盒模型。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">box-sizing</span><span class="o">:</span> <span class="nt">content-box</span> <span class="o">(</span><span class="nt">默认</span><span class="o">)</span> <span class="o">|</span> <span class="nt">border-box</span><span class="o">;</span>
</code></pre></div></div> <h3 id="32-布局相关属性">3.2 布局相关属性</h3> <p>先介绍几个跟布局相关的属性，他们是：<code class="language-plaintext highlighter-rouge">display</code>、<code class="language-plaintext highlighter-rouge">position</code> 和 <code class="language-plaintext highlighter-rouge">z-index</code>。</p> <p>（1）<code class="language-plaintext highlighter-rouge">display</code> 属性设置元素是否被视为块级或行级盒子以及用于子元素的布局。其语法格式如下（以下只列出了 display 属性的几个常用取值）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">display</span><span class="o">:</span> <span class="nt">flex</span> <span class="o">|</span> <span class="nt">grid</span> <span class="o">|</span> <span class="nt">none</span> <span class="o">|</span> <span class="nt">block</span> <span class="o">|</span> <span class="nt">inline</span> <span class="o">|</span> <span class="nt">inline-block</span> <span class="o">|</span> <span class="nt">table</span><span class="o">;</span>
</code></pre></div></div> <p>注意区分 <code class="language-plaintext highlighter-rouge">display: none</code>、<code class="language-plaintext highlighter-rouge">visibility: hidden</code> 及 <code class="language-plaintext highlighter-rouge">opacity: 0</code> 之间的区别。</p> <ul> <li><code class="language-plaintext highlighter-rouge">display: none</code>：用于将元素完全从页面中移除，包括占用的空间。</li> <li><code class="language-plaintext highlighter-rouge">visibility: hidden</code>：用于隐藏元素，但元素占用的空间会保留，且该元素仍会影响页面布局。</li> <li><code class="language-plaintext highlighter-rouge">opacity: 0</code>：元素依然参与正常布局，且依然“可见”，只是该元素变为透明样式，但用户依然可以与其交互 ·。</li> </ul> <p>（2）<code class="language-plaintext highlighter-rouge">position</code> 属性用于指定一个元素在页面的定位方式。其语法格式如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">position</span><span class="o">:</span> <span class="nt">static</span> <span class="o">(</span><span class="nt">默认</span><span class="o">)</span> <span class="o">|</span> <span class="nt">relative</span> <span class="o">|</span> <span class="nt">absolute</span> <span class="o">|</span> <span class="nt">fixed</span> <span class="o">|</span> <span class="nt">sticky</span><span class="o">;</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">static</code>：默认值，表示元素按照正常的文档流进行布局。使用 <code class="language-plaintext highlighter-rouge">static</code> 定位的元素不会被定位偏移（此时，<code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 属性无效）。</li> <li><code class="language-plaintext highlighter-rouge">relative</code>：定位的元素相对于其正常位置进行偏移。使用 <code class="language-plaintext highlighter-rouge">relative</code> 定位的元素仍然占据原来的空间，但可以通过 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 属性进行偏移。适用于需要微调元素位置的场景。</li> <li><code class="language-plaintext highlighter-rouge">absolute</code>：定位的元素脱离正常文档流，不再占据空间。使用 <code class="language-plaintext highlighter-rouge">absolute</code> 定位的元素相对于最近的非 <code class="language-plaintext highlighter-rouge">static</code> 的祖先元素进行定位。如果没有这样的祖先元素，则相对于网页的根元素 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 进行定位。适用于需要精确定位的场景。</li> <li><code class="language-plaintext highlighter-rouge">fixed</code>：定位的元素脱离正常文档流，不再占据空间。使用 <code class="language-plaintext highlighter-rouge">fixed</code> 定位的元素相对于 视口（浏览器窗口）进行定位，即使页面滚动，其位置也不会改变。适用于需要固定位置的元素，如导航栏、工具栏等。</li> <li> <p><code class="language-plaintext highlighter-rouge">sticky</code>：定位的元素根据用户的滚动位置进行切换，介于 <code class="language-plaintext highlighter-rouge">relative</code> 和 <code class="language-plaintext highlighter-rouge">fixed</code> 之间。使用 <code class="language-plaintext highlighter-rouge">sticky</code> 定位的元素在跨越特定阈值（即 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 设置的值）之前表现为 <code class="language-plaintext highlighter-rouge">relative</code> 定位，跨越阈值后表现为 <code class="language-plaintext highlighter-rouge">fixed</code> 定位。适用于需要在滚动时固定位置的元素，如表头、侧边栏等。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">#toolbar</span> <span class="p">{</span>
  <span class="nl">top</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="n">sticky</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码中，页面向下滚动时，<code class="language-plaintext highlighter-rouge">#toolbar</code> 的父元素开始脱离视口，一旦视口的顶部与 <code class="language-plaintext highlighter-rouge">#toolbar</code> 的距离小于 20px（门槛值），<code class="language-plaintext highlighter-rouge">#toolbar</code> 就自动变为 <code class="language-plaintext highlighter-rouge">fixed</code> 定位，保持与视口顶部 20px 的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），<code class="language-plaintext highlighter-rouge">#toolbar</code> 恢复成 <code class="language-plaintext highlighter-rouge">relative</code> 定位。</p> </li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">z-index</code> 属性用于控制重叠元素的层叠顺序。</p> <p><code class="language-plaintext highlighter-rouge">z-index</code> 只有在 <code class="language-plaintext highlighter-rouge">position</code> 属性值为 <code class="language-plaintext highlighter-rouge">relative</code>、<code class="language-plaintext highlighter-rouge">absolute</code>、<code class="language-plaintext highlighter-rouge">fixed</code> 或 <code class="language-plaintext highlighter-rouge">sticky</code> 时才有效。<code class="language-plaintext highlighter-rouge">z-index</code> 的值可以是正整数、负整数或零，值越大，元素的层级越高。</p> <h3 id="33-flex-布局">3.3 Flex 布局</h3> <p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span><span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 也可以为行内元素开启 Flex 布局 */</span>
<span class="nc">.box</span><span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意，设为 Flex 布局以后，子元素的 <code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">clear</code> 和 <code class="language-plaintext highlighter-rouge">vertical-align</code> 属性将失效。</p> <h4 id="331-基本概念">3.3.1 基本概念</h4> <p>采用 Flex 布局的元素，称为 Flex <strong>容器</strong>（container）。它的所有子元素自动成为容器成员，称为 Flex <strong>项目</strong>（item）。</p> <p>容器默认存在两根轴：水平的<strong>主轴</strong>（main axis）和垂直的<strong>交叉轴</strong>（cross axis）。主轴的开始位置（与边框的交叉点）叫做 <strong>main start</strong>，结束位置叫做 <strong>main end</strong>；交叉轴的开始位置叫做 <strong>cross start</strong>，结束位置叫做 <strong>cross end</strong>。</p> <p><strong>项目默认沿主轴排列</strong>。单个项目占据的主轴空间叫做 <strong>main size</strong>，占据的交叉轴空间叫做 <strong>cross size</strong>。</p> <h4 id="332-容器的属性">3.3.2 容器的属性</h4> <p>作用在容器上的属性有 6 个：<code class="language-plaintext highlighter-rouge">flex-direction</code>、<code class="language-plaintext highlighter-rouge">flex-wrap</code>、<code class="language-plaintext highlighter-rouge">flex-flow</code>、<code class="language-plaintext highlighter-rouge">justify-content</code>、<code class="language-plaintext highlighter-rouge">align-items</code> 和 <code class="language-plaintext highlighter-rouge">align-content</code>。下面，依次对他们进行讲解。</p> <p>（1）<code class="language-plaintext highlighter-rouge">flex-direction</code>：用于决定主轴的方向（即项目的排列方向）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">row</span> <span class="err">|</span> <span class="n">row-reverse</span> <span class="err">|</span> <span class="n">column</span> <span class="err">|</span> <span class="n">column-reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="flex-direction 属性"/></p> <ul> <li><code class="language-plaintext highlighter-rouge">row</code>（默认值）：主轴为水平方向，起点在左端。</li> <li><code class="language-plaintext highlighter-rouge">row-reverse</code>：主轴为水平方向，起点在右端。</li> <li><code class="language-plaintext highlighter-rouge">column</code>：主轴为垂直方向，起点在上沿。</li> <li><code class="language-plaintext highlighter-rouge">column-reverse</code>：主轴为垂直方向，起点在下沿。</li> </ul> <p>（2）<code class="language-plaintext highlighter-rouge">flex-wrap</code>：默认情况下，项目都排在一条线（又称”轴线”）上。<code class="language-plaintext highlighter-rouge">flex-wrap</code> 属性定义，如果一条轴线排不下，如何换行。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span><span class="p">{</span>
  <span class="nl">flex-wrap</span><span class="p">:</span> <span class="nb">nowrap</span> <span class="err">|</span> <span class="n">wrap</span> <span class="err">|</span> <span class="n">wrap-reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">nowrap</code>（默认）：不换行。</li> <li><code class="language-plaintext highlighter-rouge">wrap</code>：换行，第一行在上方。</li> <li><code class="language-plaintext highlighter-rouge">wrap-reverse</code>：换行，第一行在下方。</li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">flex-flow</code>：<code class="language-plaintext highlighter-rouge">flex-direction</code> 属性和 <code class="language-plaintext highlighter-rouge">flex-wrap</code> 属性的简写形式，默认值为 <code class="language-plaintext highlighter-rouge">row nowrap</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">flex-flow</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">flex-direction</span><span class="err">&gt;</span> <span class="err">||</span> <span class="err">&lt;</span><span class="n">flex-wrap</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（4）<code class="language-plaintext highlighter-rouge">justify-content</code>：定义项目在主轴上的对齐方式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-around</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="justify-content 属性"/></p> <p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>（默认值）：左对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：右对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>： 居中。</li> <li><code class="language-plaintext highlighter-rouge">space-between</code>：两端对齐，项目之间的间隔都相等。</li> <li><code class="language-plaintext highlighter-rouge">space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li> </ul> <p>（5）<code class="language-plaintext highlighter-rouge">align-items</code>：定义项目在交叉轴上的对齐方式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="nb">baseline</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="align-items 属性"/></p> <p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>：交叉轴的起点对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：交叉轴的终点对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：交叉轴的中点对齐。</li> <li><code class="language-plaintext highlighter-rouge">baseline</code>: 项目的第一行文字的基线对齐。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>（默认值）：如果项目未设置高度或设为 <code class="language-plaintext highlighter-rouge">auto</code>，将占满整个容器的高度。</li> </ul> <p>（6）align-content：定义多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="align-content 属性"/></p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>：与交叉轴的起点对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：与交叉轴的终点对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：与交叉轴的中点对齐。</li> <li><code class="language-plaintext highlighter-rouge">space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li> <li><code class="language-plaintext highlighter-rouge">space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>（默认值）：轴线占满整个交叉轴。</li> </ul> <h4 id="333-项目的属性">3.3.3 项目的属性</h4> <p>作用在项目上的属性有 6 个：<code class="language-plaintext highlighter-rouge">order</code>、<code class="language-plaintext highlighter-rouge">flex-grow</code>、<code class="language-plaintext highlighter-rouge">flex-shrink</code>、<code class="language-plaintext highlighter-rouge">flex-basis</code>、<code class="language-plaintext highlighter-rouge">flex</code> 和 <code class="language-plaintext highlighter-rouge">align-self</code>。下面，依次对他们进行讲解。</p> <p>（1）<code class="language-plaintext highlighter-rouge">order</code>：定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">order</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">integer</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">flex-grow</code>：定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-grow</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">number</span><span class="err">&gt;</span><span class="p">;</span> <span class="c">/* default 0 */</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果所有项目的 <code class="language-plaintext highlighter-rouge">flex-grow</code> 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code class="language-plaintext highlighter-rouge">flex-grow</code> 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p> <p>（3）<code class="language-plaintext highlighter-rouge">flex-shrink</code>：定义项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-shrink</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">number</span><span class="err">&gt;</span><span class="p">;</span> <span class="c">/* default 1 */</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果所有项目的 <code class="language-plaintext highlighter-rouge">flex-shrink</code> 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 <code class="language-plaintext highlighter-rouge">flex-shrink</code> 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</p> <p>（4）<code class="language-plaintext highlighter-rouge">flex-basis</code>：定义在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 <code class="language-plaintext highlighter-rouge">auto</code>，即项目的本来大小。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-basis</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">length</span><span class="err">&gt;</span> <span class="err">|</span> <span class="nb">auto</span><span class="p">;</span> <span class="c">/* default auto */</span>
<span class="p">}</span>
</code></pre></div></div> <p>它可以设为跟 <code class="language-plaintext highlighter-rouge">width</code> 或 <code class="language-plaintext highlighter-rouge">height</code> 属性一样的值（比如 350px），则项目将占据固定空间。</p> <p>（5）<code class="language-plaintext highlighter-rouge">flex</code>：<code class="language-plaintext highlighter-rouge">flex-grow</code>, <code class="language-plaintext highlighter-rouge">flex-shrink</code> 和 <code class="language-plaintext highlighter-rouge">flex-basis</code> 的简写，默认值为 <code class="language-plaintext highlighter-rouge">0 1 auto</code>。后两个属性可选。</p> <p>该属性有两个快捷值：<code class="language-plaintext highlighter-rouge">auto</code> (<code class="language-plaintext highlighter-rouge">1 1 auto</code>) 和 <code class="language-plaintext highlighter-rouge">none</code> (<code class="language-plaintext highlighter-rouge">0 0 auto</code>)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p> <p>（6）<code class="language-plaintext highlighter-rouge">align-self</code>：<code class="language-plaintext highlighter-rouge">align-self</code> 属性允许单个项目有与其他项目有不一样的对齐方式，可覆盖 <code class="language-plaintext highlighter-rouge">align-items</code> 属性。默认值为 <code class="language-plaintext highlighter-rouge">auto</code>，表示继承父元素的 <code class="language-plaintext highlighter-rouge">align-items</code> 属性，如果没有父元素，则等同于 <code class="language-plaintext highlighter-rouge">stretch</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="nb">auto</span> <span class="err">|</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="nb">baseline</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="align-self 属性"/></p> <p>该属性可能取 6 个值，除了 <code class="language-plaintext highlighter-rouge">auto</code>，其他都与 <code class="language-plaintext highlighter-rouge">align-items</code> 属性完全一致。</p> <h3 id="34-grid-布局">3.4 Grid 布局</h3> <p>网格布局（Grid）将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p> <p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”<strong>行</strong>“和”<strong>列</strong>“，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。</p> <h4 id="341-基本概念">3.4.1 基本概念</h4> <p>（1）采用网格布局的区域，称为<strong>容器</strong>（container）。容器内部采用网格定位的子元素，称为<strong>项目</strong>（item）。</p> <p>注意：项目只能是容器的<strong>顶层子元素</strong>，不包含项目的子元素。Grid 布局只对项目生效。</p> <p>（2）容器里面的水平区域称为”<strong>行</strong>“（row），垂直区域称为”<strong>列</strong>“（column）。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032502.png" alt="Grid 布局的行和列"/></p> <p>（3）行和列的交叉区域，称为”<strong>单元格</strong>“（cell）。正常情况下，<code class="language-plaintext highlighter-rouge">n</code> 行和 <code class="language-plaintext highlighter-rouge">m</code> 列会产生 <code class="language-plaintext highlighter-rouge">n x m</code> 个单元格。比如，3 行 3 列会产生 9 个单元格。</p> <p>（4）划分网格的线，称为”<strong>网格线</strong>“（grid line）。水平网格线划分出行，垂直网格线划分出列。</p> <p>正常情况下，<code class="language-plaintext highlighter-rouge">n</code> 行有 <code class="language-plaintext highlighter-rouge">n + 1</code> 根水平网格线，<code class="language-plaintext highlighter-rouge">m</code> 列有 <code class="language-plaintext highlighter-rouge">m + 1</code> 根垂直网格线，比如三行就有四根水平网格线。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032503.png" alt="Grid 布局的网格线"/></p> <p>上图是一个 4 x 4 的网格，共有 5 根水平网格线和 5 根垂直网格线。</p> <h4 id="342-容器属性">3.4.2 容器属性</h4> <p>（1）<code class="language-plaintext highlighter-rouge">display: grid</code>：指定一个容器采用网格布局。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032504.png" alt="display: grid 的效果"/></p> <p>上图是 <code class="language-plaintext highlighter-rouge">display: grid</code> 的<a href="https://jsbin.com/guvivum/edit?html,css,output">效果</a>。</p> <p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-grid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032505.png" alt="display: inline-grid 的效果"/></p> <p>上图是 <code class="language-plaintext highlighter-rouge">display: inline-grid</code> 的<a href="https://jsbin.com/qatitav/edit?html,css,output">效果</a>。</p> <p>注意，设为网格布局以后，容器子元素（项目）的 <code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">display: inline-block</code>、<code class="language-plaintext highlighter-rouge">display: table-cell</code>、<code class="language-plaintext highlighter-rouge">vertical-align</code> 和 <code class="language-plaintext highlighter-rouge">column-*</code> 等设置都将失效。</p> <p>（2）<code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性、<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性定义每列的列宽，<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性定义每行的行高。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/qiginur/edit?css,output">上面代码</a>指定了一个三行三列的网格，列宽和行高都是 100px。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032506.png" alt="grid-template-rows 属性，grid-template-columns 属性"/></p> <p>除了使用<strong>绝对单位</strong>，也可以使用<strong>百分比</strong>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">33.33%</span> <span class="m">33.33%</span> <span class="m">33.33%</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">33.33%</span> <span class="m">33.33%</span> <span class="m">33.33%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">repeat()</code>：函数用于重复一组值。上面的代码用 <code class="language-plaintext highlighter-rouge">repeat()</code> 改写如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">33.33%</span><span class="p">);</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">33.33%</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">repeat()</code> 接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。<code class="language-plaintext highlighter-rouge">repeat()</code> 也可以重复某种模式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">100</span><span class="nt">px</span> <span class="err">20</span><span class="nt">px</span> <span class="err">80</span><span class="nt">px</span><span class="o">);</span>
</code></pre></div> </div> <p>上面代码定义了 6 列，第一列和第四列的宽度为 100px，第二列和第五列为 20px，第三列和第六列为 80px。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032507.png" alt="repeat() 重复某种模式"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">auto-fill</code> 关键字：表示自动填充。有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每行（或每列）容纳尽可能多的单元格，这时可以使用 <code class="language-plaintext highlighter-rouge">auto-fill</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="n">auto-fill</span><span class="p">,</span> <span class="m">100px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p><a href="https://jsbin.com/himoku/edit?css,output">上面代码</a>表示每列宽度 100px，然后自动填充，直到容器不能放置更多的列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032508.png" alt="auto-fill"/></p> <p>除了 <code class="language-plaintext highlighter-rouge">auto-fill</code>，还有一个关键字 <code class="language-plaintext highlighter-rouge">auto-fit</code>，两者的行为基本是相同的。只有当容器足够宽，可以在一行容纳所有单元格，并且单元格宽度不固定的时候，才会有行为差异：<code class="language-plaintext highlighter-rouge">auto-fill</code> 会用空格子填满剩余宽度，<code class="language-plaintext highlighter-rouge">auto-fit</code> 则会尽量扩大单元格的宽度。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">fr</code>（fraction 的缩写，意为”片段”）关键字：用于表示比例关系。如果两列的宽度分别为 1fr 和 2fr，就表示后者是前者的两倍。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">1</span><span class="n">fr</span> <span class="m">1</span><span class="n">fr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p><a href="https://jsbin.com/hadexek/edit?html,css,output">上面代码</a>表示两个相同宽度的列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032509.png" alt="fr 表示的相同宽度的列"/></p> <p><code class="language-plaintext highlighter-rouge">fr</code> 可以与绝对长度的单位结合使用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">150px</span> <span class="m">1</span><span class="n">fr</span> <span class="m">2</span><span class="n">fr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码表示，第一列的宽度为 150px，第二列的宽度是第三列的一半。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032510.png" alt="fr 与绝对长度的单位结合使用"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">minmax()</code>：此函数用于产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="err">1</span><span class="nt">fr</span> <span class="err">1</span><span class="nt">fr</span> <span class="nt">minmax</span><span class="o">(</span><span class="err">100</span><span class="nt">px</span><span class="o">,</span> <span class="err">1</span><span class="nt">fr</span><span class="o">);</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">minmax(100px, 1fr)</code> 表示列宽不小于 100px，不大于 1fr。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">auto</code> 关键字：表示由浏览器自己决定长度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="err">100</span><span class="nt">px</span> <span class="nt">auto</span> <span class="err">100</span><span class="nt">px</span><span class="o">;</span>
</code></pre></div> </div> <p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了 <code class="language-plaintext highlighter-rouge">min-width</code>，且这个值大于最大宽度。</p> </li> <li> <p>网格线的名称：<code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性里面，还可以使用方括号，指定每根网格线的名字，方便以后的引用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">c3</span><span class="p">]</span> <span class="nb">auto</span> <span class="p">[</span><span class="n">c4</span><span class="p">];</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">r3</span><span class="p">]</span> <span class="nb">auto</span> <span class="p">[</span><span class="n">r4</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码指定网格布局为 3 行 x 3 列，因此有 4 根垂直网格线和 4 根水平网格线。方括号里面依次是这八根线的名字。</p> <p>网格布局允许同一根线有多个名字，比如 <code class="language-plaintext highlighter-rouge">[fifth-line row-5]</code>。</p> </li> <li> <p>布局实例</p> <p><code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性对于网页布局非常有用。两栏式布局只需要一行代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.wrapper</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">70%</span> <span class="m">30%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码将左边栏设为 70%，右边栏设为 30%。传统的十二网格布局，写起来也很容易。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="err">12</span><span class="o">,</span> <span class="err">1</span><span class="nt">fr</span><span class="o">);</span>
</code></pre></div> </div> </li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">grid-row-gap</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 属性、<code class="language-plaintext highlighter-rouge">grid-gap</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-row-gap</code> 属性设置行与行的间隔（行间距），<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 属性设置列与列的间隔（列间距）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">grid-row-gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="py">grid-column-gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/mezufab/edit?css,output">上面代码</a>中，<code class="language-plaintext highlighter-rouge">grid-row-gap</code> 用于设置行间距，grid-column-gap 用于设置列间距。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032511.png" alt="grid-row-gap 属性、grid-column-gap 属性"/></p> <p><code class="language-plaintext highlighter-rouge">grid-gap</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-column-gap</code> 和 <code class="language-plaintext highlighter-rouge">grid-row-gap</code> 的合并简写形式，语法如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-gap</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">grid-row-gap</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">grid-column-gap</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>因此，上面一段 CSS 代码等同于下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">grid-gap</span><span class="p">:</span> <span class="m">20px</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">grid-gap</code> 省略了第二个值，浏览器认为第二个值等于第一个值。</p> <p>注意，根据最新标准，上面三个属性名的 <code class="language-plaintext highlighter-rouge">grid-</code> 前缀已经删除，<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 和 <code class="language-plaintext highlighter-rouge">grid-row-gap</code> 写成 column-gap 和 <code class="language-plaintext highlighter-rouge">row-gap</code>，<code class="language-plaintext highlighter-rouge">grid-gap</code> 写成 <code class="language-plaintext highlighter-rouge">gap</code>。</p> <p>（4）<code class="language-plaintext highlighter-rouge">grid-template-areas</code> 属性</p> <p>网格布局允许指定”<strong>区域</strong>“（area），一个区域由单个或多个单元格组成。<code class="language-plaintext highlighter-rouge">grid-template-areas</code> 属性用于定义区域。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-areas</span><span class="p">:</span> <span class="s2">'a b c'</span>
                       <span class="s2">'d e f'</span>
                       <span class="s2">'g h i'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码先划分出 9 个单元格，然后将其定名为 <code class="language-plaintext highlighter-rouge">a</code> 到 <code class="language-plaintext highlighter-rouge">i</code> 的九个区域，分别对应这九个单元格。</p> <p>多个单元格合并成一个区域的写法如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s2">'a a a'</span>
                     <span class="s2">'b b b'</span>
                     <span class="s2">'c c c'</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码将9个单元格分成 <code class="language-plaintext highlighter-rouge">a</code>、<code class="language-plaintext highlighter-rouge">b</code>、<code class="language-plaintext highlighter-rouge">c</code> 三个区域。</p> <p>下面是一个布局实例。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s1">"header header header"</span>
                     <span class="s1">"main main sidebar"</span>
                     <span class="s1">"footer footer footer"</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码中，顶部是页眉区域 <code class="language-plaintext highlighter-rouge">header</code>，底部是页脚区域 <code class="language-plaintext highlighter-rouge">footer</code>，中间部分则为 <code class="language-plaintext highlighter-rouge">main</code> 和 <code class="language-plaintext highlighter-rouge">sidebar</code>。</p> <p>如果某些区域不需要利用，则使用”点”（<code class="language-plaintext highlighter-rouge">.</code>）表示。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s2">'a . c'</span>
                     <span class="s2">'d . f'</span>
                     <span class="s2">'g . i'</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p> <p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名 <code class="language-plaintext highlighter-rouge">-start</code>，终止网格线自动命名为区域名 <code class="language-plaintext highlighter-rouge">-end</code>。比如，区域名为 <code class="language-plaintext highlighter-rouge">header</code>，则起始位置的水平网格线和垂直网格线叫做 <code class="language-plaintext highlighter-rouge">header-start</code>，终止位置的水平网格线和垂直网格线叫做 <code class="language-plaintext highlighter-rouge">header-end</code>。</p> <p>（5）<code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性</p> <p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032506.png" alt="子元素排列顺序"/></p> <p>这个顺序由 <code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性决定，默认值是 <code class="language-plaintext highlighter-rouge">row</code>，即”<strong>先行后列</strong>“。也可以将它设成 <code class="language-plaintext highlighter-rouge">column</code>，变成”<strong>先列后行</strong>“。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">column</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/xutokec/edit?css,output">上面代码</a>设置了 <code class="language-plaintext highlighter-rouge">column</code> 以后，放置顺序就变成了下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032512.png" alt="按照 column 方式排列"/></p> <p><code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性除了设置成 <code class="language-plaintext highlighter-rouge">row</code> 和 <code class="language-plaintext highlighter-rouge">column</code>，还可以设成 <code class="language-plaintext highlighter-rouge">row dense</code> 和 <code class="language-plaintext highlighter-rouge">column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p> <p><a href="https://jsbin.com/wapejok/edit?css,output">下面的例子</a>让 1 号项目和 2 号项目各占据两个单元格，然后在默认的 grid-auto-flow: row 情况下，会产生下面这样的布局。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032513.png" alt="grid-auto-flow: row 时，元素的排列方式"/></p> <p>上图中，1 号项目后面的位置是空的，这是因为 3 号项目默认跟着 2 号项目，所以会排在 2 号项目后面。</p> <p>现在修改设置，设为 <code class="language-plaintext highlighter-rouge">row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">row</span> <span class="nt">dense</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/helewuy/edit?css,output">上面代码</a>的效果如下。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032514.png" alt="grid-auto-flow: row dense 时，元素的排列方式"/></p> <p>上图会先填满第一行，再填满第二行，所以 3 号项目会紧跟在 1 号项目的后面。8 号项目和 9 号项目就会排到第四行。</p> <p>如果将设置改为 <code class="language-plaintext highlighter-rouge">column dense</code>，表示”先列后行”，并且尽量填满空格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">column</span> <span class="nt">dense</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/pupoduc/1/edit?html,css,output">上面代码</a>的效果如下。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032515.png" alt="grid-auto-flow: column dense 时，元素的排列方式"/></p> <p>上图会先填满第一列，再填满第 2 列，所以 3 号项目在第一列，4 号项目在第二列。8 号项目和 9 号项目被挤到了第四列。</p> <p>（6）<code class="language-plaintext highlighter-rouge">justify-items</code> 属性、<code class="language-plaintext highlighter-rouge">align-items</code> 属性、<code class="language-plaintext highlighter-rouge">place-items</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">justify-items</code> 属性设置单元格内容的<strong>水平位置</strong>（左中右），<code class="language-plaintext highlighter-rouge">align-items</code> 属性设置单元格内容的<strong>垂直位置</strong>（上中下）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">justify-items</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性的写法完全相同，都可以取下面这些值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">start</code>：对齐单元格的起始边缘。</li> <li><code class="language-plaintext highlighter-rouge">end</code>：对齐单元格的结束边缘。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：单元格内部居中。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">justify-items</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/gijeqej/edit?css,output">上面代码</a>表示，单元格的内容左对齐，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032516.png" alt="justify-items: start 的效果"/></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/tecawur/edit?css,output">上面代码</a>表示，单元格的内容头部对齐，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032517.png" alt="align-items: start 的效果"/></p> <p><code class="language-plaintext highlighter-rouge">place-items</code> 属性是 <code class="language-plaintext highlighter-rouge">align-items</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-items</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-items</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-items</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-items</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>如果省略第二个值，则浏览器认为与第一个值相等。</p> <p>（7）<code class="language-plaintext highlighter-rouge">justify-content</code> 属性、<code class="language-plaintext highlighter-rouge">align-content</code> 属性、<code class="language-plaintext highlighter-rouge">place-content</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">justify-content</code> 属性是整个内容区域在容器里面的<strong>水平位置</strong>（左中右），<code class="language-plaintext highlighter-rouge">align-content</code> 属性是整个内容区域的<strong>垂直位置</strong>（上中下）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-evenly</span><span class="p">;</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-evenly</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以 <code class="language-plaintext highlighter-rouge">justify-content</code> 属性为例，<code class="language-plaintext highlighter-rouge">align-content</code> 属性的图完全一样，只是将水平方向改成垂直方向。）</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">start</code> - 对齐容器的起始边框。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032519.png" alt="justify-content: start 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">end</code> - 对齐容器的结束边框。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032518.png" alt="justify-content: end 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">center</code> - 容器内部居中。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032520.png" alt="justify-content: center 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">stretch</code> - 项目大小没有指定时，拉伸占据整个网格容器。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032521.png" alt="justify-content: stretch 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-around</code> - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032522.png" alt="justify-content: space-around 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-between</code> - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032523.png" alt="justify-content: space-between 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-evenly</code> - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032524.png" alt="justify-content: space-evenly 的效果"/></p> </li> </ul> <p><code class="language-plaintext highlighter-rouge">place-content</code> 属性是 <code class="language-plaintext highlighter-rouge">align-content</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-content</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-content</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-content</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-content</span><span class="o">&gt;</span>
</code></pre></div></div> <p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p> <p>（8）<code class="language-plaintext highlighter-rouge">grid-auto-columns</code> 属性、<code class="language-plaintext highlighter-rouge">grid-auto-rows</code> 属性</p> <p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p> <p><code class="language-plaintext highlighter-rouge">grid-auto-columns</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-auto-rows</code> 属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与 <code class="language-plaintext highlighter-rouge">grid-template-columns</code> 和 <code class="language-plaintext highlighter-rouge">grid-template-rows</code> 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p> <p><a href="https://jsbin.com/sayuric/edit?css,output">下面的例子</a>里面，划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-auto-rows</span><span class="p">:</span> <span class="m">50px</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面代码指定新增的行高统一为 50px（原始的行高为 100px）。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032525.png" alt="grid-auto-columns 属性、grid-auto-rows 属性"/></p> <p>（9）<code class="language-plaintext highlighter-rouge">grid-template</code> 属性、<code class="language-plaintext highlighter-rouge">grid</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-template</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-template-columns</code>、<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 和 <code class="language-plaintext highlighter-rouge">grid-template-areas</code> 这三个属性的合并简写形式。</p> <p>grid 属性是 <code class="language-plaintext highlighter-rouge">grid-template-rows</code>、<code class="language-plaintext highlighter-rouge">grid-template-columns</code>、<code class="language-plaintext highlighter-rouge">grid-template-areas</code>、<code class="language-plaintext highlighter-rouge">grid-auto-rows</code>、<code class="language-plaintext highlighter-rouge">grid-auto-columns</code>、<code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 这六个属性的合并简写形式。</p> <p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p> <h4 id="343-项目属性">3.4.3 项目属性</h4> <p>（1）<code class="language-plaintext highlighter-rouge">grid-column-start</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column-end</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row-start</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row-end</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row</code> 属性</p> <p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p> <ul> <li><code class="language-plaintext highlighter-rouge">grid-column-start</code>：左边框所在的垂直网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-column-end</code>：右边框所在的垂直网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-row-start</code>：上边框所在的水平网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-row-end</code>：下边框所在的水平网格线</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/yukobuf/edit?css,output">上面代码</a>指定，1 号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032526.png" alt="grid-column-start: 2且grid-column-end: 4时的效果"/></p> <p>上图中，只指定了 1 号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p> <p>除了 1 号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的 <code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性决定，这个属性的默认值是 <code class="language-plaintext highlighter-rouge">row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成 <code class="language-plaintext highlighter-rouge">column</code>、<code class="language-plaintext highlighter-rouge">row dense</code> 和 <code class="language-plaintext highlighter-rouge">column dense</code>，看看其他项目的位置发生了怎样的变化。</p> <p><a href="https://jsbin.com/nagobey/edit?html,css,output">下面的例子</a>是指定四个边框位置的效果。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">3</span><span class="p">;</span>
  <span class="py">grid-row-start</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="py">grid-row-end</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032527.png" alt="grid-column-start: 1 且 grid-column-end: 3 且 grid-row-start: 2 且 grid-row-end: 4时的效果"/></p> <p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="n">header-start</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="n">header-end</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p> <p>这四个属性的值还可以使用 <code class="language-plaintext highlighter-rouge">span</code> 关键字，表示”<strong>跨越</strong>“，即左右边框（上下边框）之间跨越多少个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/hehumay/edit?html,css,output">上面代码</a>表示，1 号项目的左边框距离右边框跨越 2 个网格。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032528.png" alt="`grid-column-start: span 2` 时的效果"/></p> <p>这与<a href="https://jsbin.com/mujihib/edit?html,css,output">下面的代码</a>效果完全一样。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">grid-column</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-column-start</code> 和 <code class="language-plaintext highlighter-rouge">grid-column-end</code> 的合并简写形式，<code class="language-plaintext highlighter-rouge">grid-row</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-row-start</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-row-end</code> 的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">start-line</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">end-line</span><span class="err">&gt;</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">start-line</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">end-line</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>下面是一个例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等同于 */</span>
<span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">3</span><span class="p">;</span>
  <span class="py">grid-row-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-row-end</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，项目 item-1 占据第一行，从第一根列线到第三根列线。</p> <p>这两个属性之中，也可以使用 span 关键字，表示跨越多少个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#b03532</span><span class="p">;</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等同于 */</span>
<span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#b03532</span><span class="p">;</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/volugow/edit?html,css,output">上面代码</a>中，项目 <code class="language-plaintext highlighter-rouge">item-1</code> 占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032529.png" alt="grid-column: 1 / 3 且 grid-row: 1 / 3 时 item-1 占据的区域"/></p> <p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，项目 <code class="language-plaintext highlighter-rouge">item-1</code> 占据左上角第一个网格。</p> <p>（2）<code class="language-plaintext highlighter-rouge">grid-area</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-area</code> 属性指定项目放在哪一个区域。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，1 号项目位于 <code class="language-plaintext highlighter-rouge">e</code> 区域，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032530.png" alt="grid-area: e 时的效果"/></p> <p><code class="language-plaintext highlighter-rouge">grid-area</code> 属性还可用作 <code class="language-plaintext highlighter-rouge">grid-row-start</code>、<code class="language-plaintext highlighter-rouge">grid-column-start</code>、<code class="language-plaintext highlighter-rouge">grid-row-end</code>、<code class="language-plaintext highlighter-rouge">grid-column-end</code> 的合并简写形式，直接指定项目的位置。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">row-start</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">column-start</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">row-end</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">column-end</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（3）<code class="language-plaintext highlighter-rouge">justify-self</code> 属性、<code class="language-plaintext highlighter-rouge">align-self</code> 属性、<code class="language-plaintext highlighter-rouge">place-self</code> 属性</p> <ul> <li><code class="language-plaintext highlighter-rouge">justify-self</code> 属性设置单元格内容的水平位置（左中右），跟 <code class="language-plaintext highlighter-rouge">justify-items</code> 属性的用法完全一致，但只作用于单个项目。</li> <li><code class="language-plaintext highlighter-rouge">align-self</code> 属性设置单元格内容的垂直位置（上中下），跟 <code class="language-plaintext highlighter-rouge">align-items</code> 属性的用法完全一致，也是只作用于单个项目。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="py">justify-self</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性都可以取下面四个值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">start</code>：对齐单元格的起始边缘。</li> <li><code class="language-plaintext highlighter-rouge">end</code>：对齐单元格的结束边缘。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：单元格内部居中。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li> </ul> <p>下面是 <code class="language-plaintext highlighter-rouge">justify-self: start</code> 的例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span>  <span class="p">{</span>
  <span class="py">justify-self</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032532.png" alt="justify-self: start 时的效果"/></p> <p><code class="language-plaintext highlighter-rouge">place-self</code> 属性是 <code class="language-plaintext highlighter-rouge">align-self</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-self</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-self</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-self</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-self</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>如果省略第二个值，<code class="language-plaintext highlighter-rouge">place-self</code> 属性会认为这两个值相等。</p> <h3 id="35-响应式图片">3.5 响应式图片</h3> <h3 id="351-srcset-属性">3.5.1 <code class="language-plaintext highlighter-rouge">srcset</code> 属性</h3> <p><code class="language-plaintext highlighter-rouge">srcset</code> 属性用来指定多张图像，适应<strong>不同像素密度</strong>的屏幕。它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，然后是像素密度的描述符。请看下面的例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-320w.jpg,
             foo-480w.jpg 1.5x,
             foo-640w.jpg 2x"</span>
     <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-640w.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">srcset</code> 属性给出了三个图像 URL，适应三种不同的像素密度。</p> <p>浏览器会根据当前设备的像素密度，选择需要加载的图像。如果 <code class="language-plaintext highlighter-rouge">srcset</code> 属性都不满足条件，那么就加载 <code class="language-plaintext highlighter-rouge">src</code> 属性指定的默认图像。</p> <h3 id="352-srcset-属性sizes-属性">3.5.2 <code class="language-plaintext highlighter-rouge">srcset</code> 属性、<code class="language-plaintext highlighter-rouge">sizes</code> 属性</h3> <p><code class="language-plaintext highlighter-rouge">sizes</code> 属性与 <code class="language-plaintext highlighter-rouge">srcset</code> 属性配合使用，可以实现根据不同的设备宽度应用不同尺寸的图像。其实现步骤如下。</p> <ol> <li><code class="language-plaintext highlighter-rouge">srcset</code> 属性列出所有可用的图像。</li> </ol> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-160.jpg 160w,
              foo-320.jpg 320w,
              foo-640.jpg 640w,
              foo-1280.jpg 1280w"</span>
      <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-1280.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">srcset</code> 属性列出四张可用的图像，每张图像的 URL 后面是一个空格，再加上宽度描述符。<strong>宽度描述符就是图像原始的宽度，加上字符 <code class="language-plaintext highlighter-rouge">w</code></strong>。上例的四种图片的原始宽度分别为 160px、320px、640px 和 1280px。</p> <ol> <li><code class="language-plaintext highlighter-rouge">sizes</code> 属性列出不同设备的图像显示宽度。</li> </ol> <p><code class="language-plaintext highlighter-rouge">sizes</code> 属性的值是一个逗号分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图像的显示宽度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">sizes</span><span class="o">=</span><span class="s1">"(max-width: 440px) 100vw,
              (max-width: 900px) 33vw,
              254px"</span>
      <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-160.jpg 160w,
              foo-320.jpg 320w,
              foo-640.jpg 640w,
              foo-1280.jpg 1280w"</span>
      <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-1280.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">sizes</code> 属性给出了三种屏幕条件，以及对应的图像显示宽度。宽度不超过 440px 的设备，图像显示宽度为 100%；宽度 441px 到 900px 的设备，图像显示宽度为 33%；宽度 900px 以上的设备，图像显示宽度为 254px。</p> <ol> <li>浏览器根据当前设备的宽度，从 <code class="language-plaintext highlighter-rouge">sizes</code> 属性获得图像的显示宽度，然后从 <code class="language-plaintext highlighter-rouge">srcset</code> 属性找出最接近该宽度的图像，进行加载。</li> </ol> <p>假定当前设备的屏幕宽度是 480px，浏览器从 <code class="language-plaintext highlighter-rouge">sizes</code> 属性查询得到，图片的显示宽度是 33vw（即 33%），等于 160px。<code class="language-plaintext highlighter-rouge">srcset</code> 属性里面，正好有宽度等于 160px 的图片，于是加载 <code class="language-plaintext highlighter-rouge">foo-160.jpg</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">sizes</code> 属性必须与 <code class="language-plaintext highlighter-rouge">srcset</code> 属性搭配使用。单独使用 <code class="language-plaintext highlighter-rouge">sizes</code> 属性是无效的。</p> <h3 id="353-picture-标签source-标签">3.5.3 <code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签、<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签</h3> <p>使用 <code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签和 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签，可以实现对不同尺寸及不同像素密度屏幕的适配。<picture> 标签是一个容器标签，内部使用 <source/> 和 <img/>，指定不同情况下加载的图像。</picture></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">media</span><span class="o">=</span><span class="s1">"(max-width: 500px)"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"cat-vertical.jpg"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 501px)"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"cat-horizontal.jpg"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">src</span><span class="o">=</span><span class="s1">"cat.jpg"</span> <span class="nt">alt</span><span class="o">=</span><span class="s1">"cat"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签内部有两个 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签和一个 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签。</p> <p><code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性给出媒体查询表达式，<code class="language-plaintext highlighter-rouge">srcset</code> 属性就是 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">srcset</code> 属性，给出加载的图像文件。<code class="language-plaintext highlighter-rouge">sizes</code> 属性其实这里也可以用，但由于有了 <code class="language-plaintext highlighter-rouge">media</code> 属性，就没有必要了。浏览器<strong>按照</strong> <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> <strong>标签出现的顺序</strong>，依次判断当前设备是否满足 <code class="language-plaintext highlighter-rouge">media</code> 属性的媒体查询表达式，如果满足就加载 <code class="language-plaintext highlighter-rouge">srcset</code> 属性指定的图片文件，并且不再执行后面的 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签和 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签。</p> <p><code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签是默认情况下加载的图像，用来满足上面所有 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 都不匹配的情况。</p> <p>上面例子中，设备宽度如果不超过 500px，就加载竖屏的图像，否则加载横屏的图像。</p> <p>下面给出一个例子，同时考虑屏幕尺寸和像素密度的适配。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@desktop.png,
                  homepage-person@desktop-2x.png 2x"</span>       
          <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 990px)"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@tablet.png,
                  homepage-person@tablet-2x.png 2x"</span> 
          <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 750px)"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@mobile.png,
               homepage-person@mobile-2x.png 2x"</span> 
       <span class="nt">alt</span><span class="o">=</span><span class="s1">"Shopify Merchant, Corrine Anestopoulos"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性给出屏幕尺寸的适配条件，每个条件都用 <code class="language-plaintext highlighter-rouge">srcset</code> 属性，再给出两种像素密度的图像 URL。</p> <h3 id="354-source-标签的-type-属性">3.5.4 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性</h3> <p>除了响应式图像，<code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签还可以用来选择不同格式的图像。比如，如果当前浏览器支持 Webp 格式，就加载这种格式的图像，否则加载 PNG 图像。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">type</span><span class="o">=</span><span class="s1">"image/svg+xml"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"logo.xml"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">type</span><span class="o">=</span><span class="s1">"image/webp"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"logo.webp"</span><span class="o">&gt;</span> 
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">src</span><span class="o">=</span><span class="s1">"logo.png"</span> <span class="nt">alt</span><span class="o">=</span><span class="s1">"ACME Corp"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性给出图像的 MIME 类型，<code class="language-plaintext highlighter-rouge">srcset</code> 是对应的图像 URL。</p> <p>浏览器按照 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签出现的顺序，依次检查是否支持 <code class="language-plaintext highlighter-rouge">type</code> 属性指定的图像格式，如果支持就加载图像，并且不再检查后面的 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签了。上面例子中，图像加载优先顺序依次为 svg 格式、webp 格式和 png 格式。</p> <h2 id="四h5-与响应式-web-设计">四、H5 与响应式 Web 设计</h2> <h3 id="41-h5-页面结构新特性">4.1 H5 页面结构新特性</h3> <p>（1）<code class="language-plaintext highlighter-rouge">doctype</code>：用于告诉浏览器文档类型。相比于 H4 的写法，新写法简化了很多。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">lang 属性</code>：用于指定文档使用的语言。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
</code></pre></div></div> <p>（3）<code class="language-plaintext highlighter-rouge">charset</code>：<code class="language-plaintext highlighter-rouge">charset</code> 属性用于指定字符编码。除非有特殊需要，否则 <code class="language-plaintext highlighter-rouge">charset</code> 的属性值一般都是 <code class="language-plaintext highlighter-rouge">utf-8</code>。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
</code></pre></div></div> <h3 id="42-h5-结构化元素">4.2 H5 结构化元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;main&gt;</code>：用于表示页面的主内容区。通常，每个页面的主内容区只能有一个，而且不能作为 <code class="language-plaintext highlighter-rouge">article</code>、<code class="language-plaintext highlighter-rouge">aside</code>、<code class="language-plaintext highlighter-rouge">header</code>、<code class="language-plaintext highlighter-rouge">footer</code>、<code class="language-plaintext highlighter-rouge">nav</code> 或 <code class="language-plaintext highlighter-rouge">header</code> 等其他 H5 语义元素的后代。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;section&gt;</code>：用于定义文档或应用中一个通用的区块。比如，某块内容包含自然标题（h1 ~ h6），就可以使用 <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> 标签作为容器。</p> <p>（3）<code class="language-plaintext highlighter-rouge">&lt;nav&gt;</code>：用于包装主导航链接。</p> <p>（4）<code class="language-plaintext highlighter-rouge">&lt;article&gt;</code>：用于包含一个独立的内容块。比如，有博客正文和新闻报道就可以放在 <code class="language-plaintext highlighter-rouge">&lt;article&gt;</code> 中。</p> <p>（5）<code class="language-plaintext highlighter-rouge">&lt;aside&gt;</code>：用于包含与其旁边内容不相关的内容。常用于侧边栏、突出引用、广告和导航元素。</p> <p>（6）<code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;figcaption&gt;</code>：<code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 常用于包含注解、图示、照片和代码等。<code class="language-plaintext highlighter-rouge">&lt;figcaption&gt;</code> 可作为 <code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 的嵌套元素使用。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;figure</span> <span class="na">class=</span><span class="s">"MoneyShot"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;img</span> <span class="na">class=</span><span class="s">"MoneyShotImg"</span> <span class="na">src=</span><span class="s">"img/scones.jpg"</span> <span class="na">alt=</span><span class="s">"Incredible scones"</span> <span class="nt">/&gt;</span> 
  <span class="nt">&lt;figcaption</span> <span class="na">class=</span><span class="s">"ImageCaption"</span><span class="nt">&gt;</span>
    Incredible scones, picture from Wikipedia
  <span class="nt">&lt;/figcaption&gt;</span> 
<span class="nt">&lt;/figure&gt;</span> 
</code></pre></div></div> <p>（7）<code class="language-plaintext highlighter-rouge">&lt;detail&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;summary&gt;</code>：这两个元素经常成对出现，比如，我们经常使用的“展开/收起”部件，就可以用它们来实现。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;details&gt;</span> 
  <span class="nt">&lt;summary&gt;</span>I ate 15 scones in one day<span class="nt">&lt;/summary&gt;</span> 
  <span class="nt">&lt;p&gt;</span>Of course I didn't. It would probably kill me if I did. What a way to go. Mmmmmm, scones!<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/details&gt;</span>
</code></pre></div></div> <p>在不添加任何样式的请款下，上面代码的（展开）效果如下。</p> <p><img src="/assets/images/css/detail-and-summary.png" alt="details and summary tag"/></p> <p>（8）<code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>：常用在站点页头作为“报头”。它可以在一个页面中出现多次（比如，页面中每个 <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> 中都可以有一个 <code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>）。</p> <p>（9）<code class="language-plaintext highlighter-rouge">&lt;footer&gt;</code>：常用于在相应区块中包含与区块相关的内容，可以包含指向其他文档的链接，或者版权声明。<code class="language-plaintext highlighter-rouge">&lt;footer&gt;</code> 同样可以在页面中出现多次。</p> <p>（10）<code class="language-plaintext highlighter-rouge">&lt;address&gt;</code>：用于标记联系人信息，比如地址信息。</p> <p>（11）<code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code> ~ <code class="language-plaintext highlighter-rouge">&lt;h6&gt;</code>：h1 到 h6 元素不能用于标记副标题、字幕、广告语，除非想把它们用作新区块或子区块的标题。</p> <h3 id="43-h5-文本级元素">4.3 H5 文本级元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;b&gt;</code>：表示只为引人注意而标记的文本，不传达更多的重要性信息，也不用于表达其他的愿望或情绪。比如，不用于文章摘要中的关键词、评测当中的产品名、交互式文本程序中的可执行命令，等等。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code>：表示内容中需要强调的部分。</p> <p>（3）<code class="language-plaintext highlighter-rouge">&lt;i&gt;</code>：表示一段文本，用于表示另一种愿望或情绪，或者以突出不同文本形式的方式表达偏离正文的意思。</p> <h3 id="44-新的媒体元素">4.4 新的媒体元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;video&gt;</code>：用于在页面中嵌入视频，<code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> 标签必须成对使用。如果浏览器不支持此标签，可以在其中潜入一段文字，用于提示。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">src=</span><span class="s">"myVideo.mp4"</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span><span class="nt">&gt;</span>
  What, do you mean you don't understand HTML5?
<span class="nt">&lt;/video&gt;</span> 
</code></pre></div></div> <p>对于某些旧版本浏览器，可以使用 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签以提供后备资源。比如，除了提供 MP4 版本的视频，如果想某些低版本浏览器也能看到视频，可以添加一个 Flash源 作为后备。或者，如果用户浏览器没有任何播放条件，还可以提供一个下载视频的链接。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span> <span class="na">controls</span> <span class="na">preload=</span><span class="s">"auto"</span> <span class="na">loop</span> <span class="na">poster=</span><span class="s">"myVideoPoster.png"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">"video/myVideo.mp4"</span> <span class="na">type=</span><span class="s">"video/mp4"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;object</span>
    <span class="na">width=</span><span class="s">"640"</span>
    <span class="na">height=</span><span class="s">"480"</span>
    <span class="na">type=</span><span class="s">"application/x-shockwaveflash"</span>
    <span class="na">data=</span><span class="s">"myFlashVideo.SWF"</span>
  <span class="nt">&gt;</span>
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"movie"</span> <span class="na">value=</span><span class="s">"myFlashVideo.swf"</span> <span class="nt">/&gt;</span> 
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"flashvars"</span> <span class="na">value=</span><span class="s">"controlbar=over&amp;amp;image=myVideoPoster.jpg&amp;amp;file=myVideo.mp4"</span> <span class="nt">/&gt;</span> 
    <span class="nt">&lt;img</span>
      <span class="na">src=</span><span class="s">"myVideoPoster.png"</span>
      <span class="na">width=</span><span class="s">"640"</span>
      <span class="na">height=</span><span class="s">"480"</span>
      <span class="na">alt=</span><span class="s">"__ TITLE__"</span>
      <span class="na">title=</span><span class="s">"No video playback capabilities, please download the video below"</span>
    <span class="nt">/&gt;</span> 
  <span class="nt">&lt;/object&gt;</span> 
  <span class="nt">&lt;p&gt;</span>
    <span class="nt">&lt;b&gt;</span>Download Video:<span class="nt">&lt;/b&gt;</span> MP4 Format: <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"myVideo.mp4"</span><span class="nt">&gt;</span>"MP4"<span class="nt">&lt;/a&gt;</span> 
  <span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/video&gt;</span>
</code></pre></div></div> <p>通常，很难对不同的视频播放画面做响应式设计，多数情况下，影片的播放比例并不相同。<a href="http://embedresponsively.com/">这里</a> 有一个网站，你可以把视频的 url 地址粘贴进去，就会得到一段响应式代码，从而使得在网页缩放时，视频依然会保持应有的比例。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;audio&gt;</code>：<code class="language-plaintext highlighter-rouge">&lt;audio&gt;</code> 用于在页面中嵌入音频，其用法与 <code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> 类似。</p> <h3 id="45-其他特性">4.5 其他特性</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 标签中可以放多个元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"index.html"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;h2&gt;</span>The home page<span class="nt">&lt;/h2&gt;</span> 
  <span class="nt">&lt;p&gt;</span>This paragraph also links to the home page<span class="nt">&lt;/p&gt;</span> 
  <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"home-image.png"</span> <span class="na">alt=</span><span class="s">"home-slice"</span> <span class="nt">/&gt;</span> 
<span class="nt">&lt;/a&gt;</span> 
</code></pre></div></div> <p>（2）WCAG 和 WAI-ARIA</p> <p>WCAG 和 WAI-ARIA 提供了与无障碍交互相关的标准。</p> <h2 id="五css3-新特性">五、CSS3 新特性</h2> <p>这部分并不会讨论 CSS3 中所有的新特性，而只是讨论跟响应式设计有关的新特性。</p> <h3 id="51-css-响应式多列布局">5.1 CSS 响应式多列布局</h3> <p>以下示例，以下面的代码布局为例进行讲解。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;main&gt;</span> 
  <span class="nt">&lt;p&gt;</span>lloremipsimLoremipsum dolor sit amet, consectetur ... <span class="nt">&lt;/p&gt;</span> 
  <span class="nt">&lt;p&gt;</span>lloremipsimLoremipsum dolor sit amet, consectetur ... <span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/main&gt;</span>
</code></pre></div></div> <p>（1）使用 CSS 多列布局可以通过几种方式让文本分成多列显示。比如，可以给每列设定固定的列宽。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-width</span><span class="p">:</span> <span class="m">12em</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码表示，设置没列的宽度为 12em，改变视口宽度时，列宽不变，列数动态改变。</p> <p>（2）固定列数，可变宽度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-count</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码表示，当页面缩放时，列数固定，宽度可变。</p> <p>（3）添加列间距和分隔线。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-gap</span><span class="p">:</span> <span class="m">2em</span><span class="p">;</span> 
  <span class="nl">column-rule</span><span class="p">:</span> <span class="nb">thin</span> <span class="nb">dotted</span> <span class="m">#999</span><span class="p">;</span> 
  <span class="nl">column-width</span><span class="p">:</span> <span class="m">12em</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码，用于给列间添加间距和分隔线。</p> <h3 id="52-断字">5.2 断字</h3> <p>（1）容器中的文字默认一行显示，如果文字太长，超出了容器的长度，就会显示在容器外面。可以使用下面的方式，对文字进行<strong>换行</strong>处理。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">word-wrap</span><span class="o">:</span> <span class="nt">break-word</span><span class="o">;</span>
</code></pre></div></div> <p>（2）可以对文字<strong>截短</strong>处理，并且使得超出容器宽度的部分，显示为 <code class="language-plaintext highlighter-rouge">...</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">p</span> <span class="p">{</span> 
 <span class="nl">width</span><span class="p">:</span> <span class="m">520px</span><span class="p">;</span> 
 <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span> 
 <span class="nl">text-overflow</span><span class="p">:</span> <span class="n">ellipsis</span><span class="p">;</span> 
 <span class="nl">white-space</span><span class="p">:</span> <span class="n">no-wrap</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>最后的 <code class="language-plaintext highlighter-rouge">white-space: nowrap</code> 声明是为了确保长出来的文本不会折行显示在外部元素中。</p> <h3 id="53-在-css-中创建分支">5.3 在 CSS 中创建分支</h3> <p>在响应式设计，经常会碰到某些设备不支持什么特性或技术的情况。此时，往往需要在 CSS 中创建一个分支。如果浏览器支持某特性，就应用一段代码；如果不支持，则应用另一段代码。这点类似于 JavaScript 中 <code class="language-plaintext highlighter-rouge">if...else</code> 语句。</p> <p>在 CSS 中创建分支有两种手段。一是完全基于 CSS，但支持的浏览器却不多； 二是借助 JavaScript 库，获得广泛兼容性。</p> <p>（1）特性查询</p> <p>CSS 原生的分支语法就是特性查询，比如下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">(</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span>

<span class="k">@supports</span> <span class="n">not</span> <span class="p">(</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-block</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码表示，如果浏览器支持 <code class="language-plaintext highlighter-rouge">display: flex</code>，就对 <code class="language-plaintext highlighter-rouge">.item</code> 选择器设置一种样式；否则，则设置为另一种样式。</p> <p>（2）组合条件</p> <p>假设我们只想在浏览器支持 flexbox 和 <code class="language-plaintext highlighter-rouge">pointer: coarse</code> 时应用某些规则，可以使用下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">((</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nb">pointer</span><span class="p">:</span> <span class="n">coarse</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">and</code> 关键字，其他支持的关键字还有 <code class="language-plaintext highlighter-rouge">or</code>。比如，除了前面两个条件满足之外，如果浏览器支持 3D 变形也想应用样式，那么可以使用下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">((</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nb">pointer</span><span class="p">:</span> <span class="n">coarse</span><span class="p">))</span> <span class="n">or</span> <span class="p">(</span><span class="n">transform</span><span class="p">:</span> <span class="n">translate3d</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>注意，某些低版本及 IE 浏览器，并不支持 <code class="language-plaintext highlighter-rouge">@support</code> 关键字。</p> <p>（3）在 <code class="language-plaintext highlighter-rouge">@supports</code> 得到广泛支持以前，还可以使用 Modernizr 这个 JavaScript 工具在 CSS 中实现分支。</p> <h3 id="54-新的-css3-选择器">5.4 新的 CSS3 选择器</h3> <p>（1）属性选择器，用于对某些元素的属性进行选择。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">border</span><span class="p">:</span> <span class="m">3px</span> <span class="nb">dashed</span> <span class="m">#e15f5f</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，表示选中任何包含 <code class="language-plaintext highlighter-rouge">alt</code> 属性的 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 元素。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">=</span><span class="s1">"sausages"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="c">/* 样式 */</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码，只会选择 <code class="language-plaintext highlighter-rouge">alt</code> 属性值为 <code class="language-plaintext highlighter-rouge">sausages</code> 的 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>元素。即同时指定了属性的值，进一步缩小了搜索范围。</p> <p>CSS3 支持依据属性选择器包含的子字符串来选择元素。这时分为三种情况：</p> <ul> <li>以 xxx 开头。</li> <li>包含 xxx。</li> <li>以 xxx 结尾。</li> </ul> <p>（2）选中属性值以某字符串开头的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"img/ace-film.jpg"</span> <span class="na">alt=</span><span class="s">"film-ace"</span><span class="nt">&gt;</span> 
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"img/rubbish-film.jpg"</span> <span class="na">alt=</span><span class="s">"film-rubbish"</span><span class="nt">&gt;</span> 
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">^=</span><span class="s1">"film"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="c">/* 样式 */</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">^</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">alt</code> 属性值中以 <code class="language-plaintext highlighter-rouge">film</code> 字符串开头的情况。即此时会选中 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 表情中，<code class="language-plaintext highlighter-rouge">alt</code> 属性以 <code class="language-plaintext highlighter-rouge">film</code> 开头的元素（在这里会同时选中上边的两个 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签）。</p> <p>（2）选中属性值包含某字符串的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"scones cream jam"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">data-ingredients</span><span class="o">*=</span><span class="s1">"cream"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的属性选择器，使用 <code class="language-plaintext highlighter-rouge">*</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">data-ingredients</code> 属性值中包含 <code class="language-plaintext highlighter-rouge">cream</code> 字符串的情况。此时 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 标签会被选中。</p> <p>（3）选中属性值以某字符串结尾的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"scones cream jam"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"toast jam butter"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"jam toast butter"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">data-ingredients</span><span class="err">$</span><span class="o">=</span><span class="s1">"jam"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的属性选择器，使用 <code class="language-plaintext highlighter-rouge">$</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">data-ingredients</code> 属性值中以 <code class="language-plaintext highlighter-rouge">jam</code> 字符串结尾的情况。此时，第一个 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 标签会被选中。</p> <h3 id="55-伪类选择器">5.5 伪类选择器</h3> <ul> <li><code class="language-plaintext highlighter-rouge">:last-child</code>：用于选择某个父元素中的最后一个子元素。</li> <li><code class="language-plaintext highlighter-rouge">:nth-child(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-last-child(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-of-type(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-last-of-type(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:not</code>：</li> <li><code class="language-plaintext highlighter-rouge">:empty</code>：</li> <li><code class="language-plaintext highlighter-rouge">:first-line</code>：</li> <li><code class="language-plaintext highlighter-rouge">:has</code>：</li> </ul> <h3 id="56-calc-函数">5.6 <code class="language-plaintext highlighter-rouge">calc()</code> 函数</h3> <h3 id="57-css3-的新颜色格式及透明度">5.7 CSS3 的新颜色格式及透明度</h3> <p>（1）可以使用 <code class="language-plaintext highlighter-rouge">rgb()</code> 或 <code class="language-plaintext highlighter-rouge">rgba()</code> 函数定义颜色，前者接收三个参数（取值为 0 ~ 255），分别表示红、绿、蓝三原色分量的值，后者除了这三个参数，还可以接受一个 alpha 透明度数值，取值为 0 ~ 1。</p> <p>（2）CSS3 还支持HSL（Hue Saturation Lightness，色相、饱和度、亮度）颜色系统。</p> <h2 id="六css3-高级技术">六、CSS3 高级技术</h2> <h2 id="七svg-与响应式-web-设计">七、SVG 与响应式 Web 设计</h2> <h2 id="八css3-过渡变形和动画">八、CSS3 过渡、变形和动画</h2> <h2 id="九表单">九、表单</h2> <h2 id="十参考">十、参考</h2> <ul> <li><a href="https://benfrain.com/">Ben Frain</a>，《响应式 Web 设计：HTML5和CSS实战》</li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a></li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程</a></li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2019/06/responsive-images.html">响应式图像教程</a></li> </ul>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="media queries"/><category term="responsive web design"/><category term="responsive images"/><category term="flex box layout"/><category term="grid layout"/><summary type="html"><![CDATA[一、简介]]></summary></entry><entry><title type="html">计算机网络 - 网络层</title><link href="https://feng-zhang0712.github.io//blog/2024/network-layer/" rel="alternate" type="text/html" title="计算机网络 - 网络层"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/network-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/network-layer/"><![CDATA[<p>本章的核心内容——网际协议 IP 是本书的一个重点内容。本章还要讨论网际控制报文协议 ICMP，几种常用的路由选择协议，IPv6 的主要特点，IP 多播的概念。本章最重要的内容是：</p> <ul> <li>虚拟互连网络的概念。</li> <li>IP 地址与物理地址的关系。</li> <li>传统的分类的 IP 地址（包括子网掩码）和无分类域间路由选择 CIDR。</li> <li>路由选择协议的工作原理。</li> </ul> <h2 id="一网络层提供的两种服务">一、网络层提供的两种服务</h2> <p>计算机网络发展的早期，人们曾认为，计算机网络应模仿打电话所使用的面向连接的通信方式。当两台计算机进行通信时，应当先建立连接（但在分组交换中是建立一条<strong>虚电路</strong> VC（Virtual Circuit）），以预留双方通信所需的一切网络资源。然后双方就沿着已建立的虚电路发送分组。图 4-1（a）是网络提供虚电路服务的示意图。主机 $H_1$ 和 $H_2$ 之间交换的分组都必须在事先建立的虚电路上传送。</p> <p>但互联网的先驱者却提出一种崭新的网络设计思路。他们认为，电信网提供的端到端可靠传输的服务对电话业务无疑是很合适的，因为电信网的终端（电话机）非常简单，没有智能，也没有差错处理能力。因此电信网必须负责把用户电话机产生的话音信号可靠地传送到对方的电话机，使还原后的话音质量符合技术规范的要求。但计算机网络的端系统是有智能的计算机。计算机有很强的差错处理能力（这点和传统的电话机有本质上的差别）。因此，互联网在设计上就采用了和电信网完全不同的思路。</p> <p>互联网采用的设计思路是这样的：<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong>。这里的“数据报”（datagram）指我们经常使用的“分组”。</p> <p>网络在发送分组时不需要先建立连接。每个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。<strong>网络层不提供服务质量的承诺</strong>。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器比较简单，且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。</p> <p>图 4-1（b）给出了网络提供数据报服务的示意图。主机 $H_1$ 向 $H_2$ 发送的分组各自独立地选择路由，并且在传送的过程中还可能丢失。</p> <p><img src="/assets/images/computer-network/two-types-of-services-provided-by-the-network-layer.png" alt="网络层提供的两种服务"/> <em>图 4-1 网络层提供的两种服务</em></p> <p>| 对比的方面 | 虚电路服务 | 数据报服务 | | — | — | — | | 思路 | 可靠通信应当由网络来保证 | 可靠通信应当由用户主机来保证 | | 连接的建立 | 必须有 | 不需要 | | 终点地址 | 仅在连接建立阶段使用，每个分组使用短的虚电路号 | 每个分组都有终点的完整地址 | | 分组的转发 | 属于同一条虚电路的分组均按照同一路由进行转发 | 每个分组独立选择路由进行转发 | | 当结点出故障时 | 所有通过出故障的结点的虚电路均不能工作 | 出故障的结点可能会丢失分组，一些路由可能会发生变化 | | 分组的顺序 | 总是按发送顺序到达终点 | 到达终点的时间不一定按发送顺序 | | 端到端的差错处理和流量控制 | 可以由网络负责，也可以由用户主机负责 | 由用户主机负责 | <em>表 4-1 虚电路服务与数据报服务的对比</em></p> <h2 id="二网际协议-ip">二、网际协议 IP</h2> <p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一[STEV94][COME06][FORO10]，也是最重要的互联网标准协议之一（注意，这里所讲的 IP 是 IP 的第 4 个版本（IPv4）。但在讲述 IP 协议的各种原理时，往往不在 IP 后面加上版本号。在后面的 <a href="#六ipv6">第六节</a> 会介绍较新的版本 IPv6）。</p> <p>与 IP 协议配套使用的还有三个协议：</p> <ul> <li><strong>地址解析协议 ARP</strong>（Address Resolution Protocol）</li> <li><strong>网际控制报文协议 ICMP</strong>（Internet Control Message Protocol）</li> <li><strong>网际组管理协议 IGMP</strong>（Internet Group Management Protocol）</li> </ul> <p>图 4-2 画出了这三个协议和网际协议 IP 的关系。在这一层中，ARP 画在最下面，因为 IP 经常要使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层常常被称为<strong>网际层</strong>（internet layer），或 <strong>IP 层</strong>。</p> <p><img src="/assets/images/computer-network/internet-protocol-ip-and-its-supporting-protocols.png" alt="网际协议 IP 及其配套协议"/> <em>图 4-2 网际协议 IP及其配套协议</em></p> <h3 id="21-虚拟互连网络">2.1 虚拟互连网络</h3> <p>将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p> <ul> <li>物理层使用的中间设备叫做<strong>转发器</strong>（repeater）。</li> <li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>（bridge）。</li> <li>网络层使用的中间设备叫做<strong>路由器</strong>（router）。</li> <li>在网络层以上使用的中间设备叫做<strong>网关</strong>（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li> </ul> <p>当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称之为网络互连。网关由于比较复杂，目前使用得较少。因此现在我们讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。注意，由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关（本书有时也这样用）。</p> <p>图 4-3（a）表示有许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的<strong>网际协议 IP</strong>（Internet Protocol），因此可以把互连以后的计算机网络看成如图 4-3（b）所示的一个<strong>虚拟互连网络</strong>（internet）。所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。这种使用 IP协 议的虚拟互连网络可简称为 IP 网。使用 IP 网的好处是：当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节（如具体的编址方案、路由选择协议，等等）。如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网（Internet）。</p> <p><img src="/assets/images/computer-network/the-concept-of-ip-network.png" alt="IP 网的概念"/> <em>图 4-3 IP 网的概念</em></p> <p>在图 4-4 所示的互联网中的源主机 $H_1$ 要把一个 IP 数据报发送给目的主机 $H_2$。根据之前讲过的分组交换的存储转发概念，主机 $H_1$ 先要查找自己的路由表，看目的主机是否就在本网络上。如是，则不需要经过任何路由器而是<strong>直接交付</strong>，任务就完成了。如不是，则必须把 IP 数据报发送给某个路由器（图中的 $R_1$）。$R_1$ 在查找了自己的路由表后，知道应当把数据报转发给 $R_2$ 进行<strong>间接交付</strong>。这样一直转发下去，最后由路由器 $R_5$ 知道自己是和 $H_2$ 连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报直接交付目的主机 $H_2$。图中画出了源主机、目的主机以及各路由器的协议栈。我们注意到，主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向（用黑色粗线表示）。我们还可注意到，在 $R_4$ 和 $R_5$ 之间使用了卫星链路，而 $R_5$ 所连接的是个无线局域网。在 $R_1$ 到 $R_4$ 之间的三个网络则可以是任意类型的网络。总之，这里强调的是：<strong>互联网可以由多种异构网络互连组成</strong>。</p> <p>如果我们只从网络层考虑问题，那么IP 数据报就可以想象是在网络层中传送，其传送路径是：</p> \[H_1 → R_1 → R_2 → R_3 → R_4 → R_5 → H_2\] <p><img src="/assets/images/computer-network/transmission-of-packets-over-the-internet.png" alt="分组在互联网中的传送"/> <em>图 4-4 分组在互联网中的传送</em></p> <h3 id="22-分类的-ip-地址">2.2 分类的 IP 地址</h3> <p>在 TCP/IP 体系中，IP 地址是一个最基本的概念。有关 IP 最重要的文档就是互联网的正式标准 RFC 791。</p> <h4 id="1ip-地址及其表示方法">（1）IP 地址及其表示方法</h4> <p>整个的互联网就是一个<strong>单一的、抽象的网络</strong>。IP 地址就是给互联网上的每台主机（或路由器）的每个接口分配一个在全世界范围内是唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上很方便地进行寻址。IP 地址现在由<strong>互联网名字和数字分配机构 ICANN</strong>（Internet Corporation for Assigned Names and Numbers）进行分配。</p> <p>IP 地址的编址方法共经过了三个历史阶段。</p> <ol> <li><strong>分类的 IP 地址</strong>：这是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li> <li><strong>子网的划分</strong>：这是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</li> <li><strong>构成超网</strong>：这是比较新的无分类编址方法。1993 年提出后很快就得到推广应用。</li> </ol> <p>所谓“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每类地址都由两个固定长度的字段组成。</p> <ol> <li><strong>网络号</strong>（net-id）：第一个字段。它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。</li> <li><strong>主机号</strong>（host-id）：第二个字段。它标志该主机（或路由器）。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li> </ol> <p>由此可见，一个 IP 地址<strong>在整个互联网范围内是唯一的</strong>。这种两级的 IP 地址可以记为：</p> \[IP 地址 ::= {&lt;网络号&gt;, &lt;主机号&gt;}\] <p>上式中的符号“::=”表示“<strong>定义为</strong>”。图 4-5 给出了各种 IP 地址的网络号字段和主机号字段，这里 A 类、B 类和 C 类地址都是单播地址（一对一通信），是最常用的。</p> <p><img src="/assets/images/computer-network/the-network-number-field-and-host-number-field-in-the-ip-address.png" alt="IP 地址中的网络号字段和主机号字段"/> <em>图 4-5 IP 地址中的网络号字段和主机号字段</em></p> <p>从图 4-5 可以看出：</p> <ul> <li>A 类、B 类和 C 类地址的网络号字段（在图中这个字段是灰色的）分别为 1 个、2 个和 3 个字节长，而在网络号字段的最前面有 1~3 位的<strong>类别位</strong>，其数值分别规定为 0、10 和 110。</li> <li>A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。</li> <li>D 类地址（前 4 位是 1110）用于多播（一对多通信）。</li> <li>E 类地址（前 4 位是 1111）保留为以后用。</li> </ul> <p>这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、B 类和 C 类地址的区分已成为历史[RFC1812]，但由于很多文献和资料都还使用传统的分类的 IP 地址，而且从概念的演进上更清晰，因此我们在这里还要从分类的 IP 地址讲起。</p> <p>从 IP 地址的结构来看，IP 地址并不仅仅指明一台主机，而是还指明了主机连接到的网络。</p> <p>把 IP 地址划分为 A 类、B 类、C 类三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把 IP 地址划分为 A 类、B 类和 C 类是为了更好地满足不同用户的要求。当某个单位申请到一个 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。</p> <p>对主机或路由器来说，IP 地址都是 32 位的二进制代码。为了提高可读性，我们常把 32 位的 IP 地址中的每 8 位插入一个空格（但在机器中并没有这样的空格）。为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做<strong>点分十进制记法</strong>（dotted decimal notation）。图 4-6 是一个 B 类 IP 地址的表示方法。显然，128.11.3.31 比 10000000 00001011 00000011 00011111 书写起来要方便得多。</p> <p><img src="/assets/images/computer-network/the-use-of-dotted-decimal-notation-improves-readability.png" alt="采用点分十进制记法能够提高可读性"/> <em>图 4-6 采用点分十进制记法能够提高可读性</em></p> <h4 id="2常用的三种类别的-ip-地址">（2）常用的三种类别的 IP 地址</h4> <p>A 类地址的网络号字段占 1 个字节，只有 7 位可供使用（该字段的第一位已固定为 0），但可指派的网络号是 126 个（即 $2^{-7} - 2$）。减 2 的原因是：第一，IP 地址中的全 0 表示“这个（this）”。网络号字段为全 0 的 IP 地址是个保留地址，意思是“<strong>本网络</strong>”；第二，网络号为 127（即 01111111）保留作为本地软件<strong>环回测试</strong>（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。</p> <p>A 类地址的主机号占 3 个字节，因此每个 A 类网络中的最大主机数是 $2^{24} - 2$，即 16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>单个网络地址</strong>（例如，一主机的 IP 地址为5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示“所有的（all）”，因此全 1 的主机号字段表示该网络上的所有主机。</p> <p>IP 地址空间共有 $2^{32}$（即 4294967296）个地址。整个 A 类地址空间共有 21 个地址，占整个 IP 地址空间的 50%。</p> <p>B 类地址的网络号字段有 2 个字节，但前面两位（10）已经固定了，只剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此这里不存在网络总数减 2 的问题。但实际上 B 类网络地址128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0 [COME06]。因此 B 类地址可指派的网络数为 $2^{14} - 1$，即 16383。B 类地址的每个网络上的最大主机数是 $2^{16} - 2$，即 65534。这里需要减 2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 $2^{30}$ 个地址，占整个 IP 地址空间的 25%。</p> <p>C 类地址有 3 个字节的网络号字段，最前面的 3 位是（110），还有 21 位可以进行分配。C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络地址是 192.0.1.0 [COME06]，因此 C 类地址可指派的网络总数是 $2^{21} - 1$，即 2097151。每个 C 类地址的最大主机数是 $2^8 - 2$，即 254。整个 C 类地址空间共约有 $2^{29}$ 个地址，占整个 IP 地址的 12.5%。</p> <p>这样，我们就可得出表 4-2 所示的 IP 地址的指派范围。</p> <p>| 网络类别 | 最大可指派的网络数 | 第一个可指派的网络号 | 最后一个可指派的网络号 | 每个网络中的最大主机数 | | — | — | — | — | — | | A | $126(2^7 - 2)$ | 1 | 126 | 16777214 | | B | $16383(2^{14} - 1)$ | 128.1 | 191.255 | 65534 | | C | $2097151(2^{21} - 1)$ | 192.0.1 | 223.255.255 | 254 | <em>表 4-2 IP 地址的指派范围</em></p> <p>表 4-3 给出了一般不使用的特殊 IP 地址，这些地址只能在特定的情况下使用。</p> <p>| 网络号 | 主机号 | 源地址使用 | 目的地址使用 | 代表的意思 | | — | — | — | — | — | | 0 | 0 | 可以 | 不可 | 在本网络上的本主机（见6。6节 DHCP 协议） | | 0 | host-id | 可以 | 不可 | 在本网络上的某台主机 host-id | | 全 1 | 全 1 | 不可 | 可以 | 只在本网络上进行广播（各路由器均不转发） | | net-id | 全 1 | 不可 | 可以 | 对 net-id 上的所有主机进行广播 | | 127 | 非全 0 或全 1 的任何数 | 可以 | 可以 | 用于本地软件环回测试 | <em>表 4-3 一般不使用的特殊 IP 地址</em></p> <p>IP 地址具有以下一些重要特点。</p> <ol> <li>每个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种<strong>分等级的地址结构</strong>。分两个等级的好处是： <ul> <li>第一，IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong>（第一级），而剩下的主机号（第二级）则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理；</li> <li>第二，路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong>（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而<strong>减小了路由表所占的存储空间以及查找路由表的时间</strong>。</li> </ul> </li> <li>实际上 IP 地址是标志一台主机（或路由器）和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>（multihomed host）。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。这好比一个建筑正好处在北京路和上海路的交叉口上，那么这个建筑就可以拥有两个门牌号码。例如，北京路 4 号和上海路 37 号。</li> <li>按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，<strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li> <li>在 IP 地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是<strong>平等</strong>的。所谓平等，是指互联网同等对待每个 IP 地址。图 4-7 画出了三个局域网（$LAN_1$，$LAN_2$ 和 $LAN_3$）通过三个路由器（$R_1$，$R_2$ 和 $R_3$）互连起来所构成的一个互联网（此互联网用虚线圆角方框表示）。其中局域网 $LAN_2$， 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有一个 IP 地址。</li> </ol> <p>我们应当注意到：</p> <ul> <li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。图中所示的网络号就是 IP 地址中的网络号字段的值，这也是文献中常见的一种表示方法。另一种表示方法是用主机号为全 0 的网络 IP 地址。</li> <li>用网桥（它只在链路层工作）互连的网段仍然是一个局域网，只能有一个网络号。</li> <li>路由器总是具有两个或两个以上的 IP 地址。即路由器的每个接口都有一个不同网络号的 IP 地址。</li> <li>当两个路由器直接相连时（例如通过一条租用线路），在连线两端的接口处，可以分配也可以不分配 IP 地址。如分配了 IP 地址，则这段连线就构成了一种只包含一段线路的特殊“网络”（如图中的 $N_1$，$N_2$ 和 $N_3$）。之所以叫做“网络”是因为它有 IP 地址。但为了节省 IP 地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配 IP 地址。通常把这样的特殊网络叫做<strong>无编号网络</strong>（unnumbered network）或<strong>无名网络</strong>（anonymous network）[COME06]。</li> </ul> <p><img src="/assets/images/computer-network/an-ip-address-on-the-internet.png" alt="互联网中的 IP 地址"/> <em>图 4-7 互联网中的 IP 地址</em></p> <h3 id="23-ip-地址与硬件地址">2.3 IP 地址与硬件地址</h3> <p>图 4-8 说明了 IP 地址与硬件地址的区别。从层次的角度看，<strong>物理地址是数据链路层和物理层使用的地址</strong>，而 <strong>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</strong>。</p> <p><img src="/assets/images/computer-network/differences-between-ip-addresses-and-hardware-addresses.png" alt="IP 地址与硬件地址的区别"/> <em>图 4-8 IP 地址与硬件地址的区别</em></p> <p>在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在MAC 帧的首部中。</p> <p>连接在通信链路上的设备（主机或路由器）在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。</p> <p>总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。</p> <p>图 4-9（a）画的是三个局域网用两个路由器 $R_1$ 和 $R_2$ 互连起来。现在主机 $H_1$ 要和主机 $H_2$ 通信。这两台主机的 IP 地址分别是 $IP_1$ 和 $IP_2$，而它们的硬件地址分别为 $HA_1$ 和 $HA2_1$（HA 表示 Hardware Address）。通信的路径是：$H_1$ → 经过 $R_1$ 转发 → 再经过 $R_2$ 转发 → $H_2$。路由器 $R_1$ 因同时连接到两个局域网上，因此它有两个硬件地址，即 $HA_3$ 和 $HA_4$。同理，路由器 $R_2$ 也有两个硬件地址 $HA_5$ 和 $HA_6$。</p> <p><img src="/assets/images/computer-network/ip-addresses-and-hardware-addresses-at-different-levels.png" alt="从不同层次上看 IP 地址和硬件地址"/> <em>图 4-9 从不同层次上看 IP 地址和硬件地址</em></p> <p>图4-9（b）特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。</p> <p><img src="/assets/images/computer-network/source-and-destination-addresses-of-different-levels-and-ranges.png" alt="图 4-9（b）中不同层次、不同区间的源地址和目的地址"/> <em>表 4-4 图 4-9（b）中不同层次、不同区间的源地址和目的地址</em></p> <p>这里要强调指出以下几点：</p> <ul> <li><strong>在 IP 层抽象的互联网上只能看到 IP 数据报</strong>。虽然 IP 数据报要经过路由器 $R_1$ 和 $R_2$ 的两次转发，但在它的首部中的源地址和目的地址始终分别是 $IP_1$ 和 $IP_2$。图中的数据报上写的“从 $IP_1$ 到 $IP_2$”就表示前者是源地址而后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li> <li>虽然在 IP 数据报首部有源站 IP 地址，但<strong>路由器只根据目的站的 IP 地址的网络号进行路由选择</strong>。</li> <li><strong>在局域网的链路层，只能看见 MAC 帧</strong>。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图 4-9（b）。开始在 $H_1$ 到 $R_1$ 间传送时，MAC 帧首部中写的是从硬件地址 $HA_1$，发送到硬件地址 $HA_3$，路由器 $R_1$ 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新添加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 $HA_4$ 和 $HA_5$。路由器 $R_2$ 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变成为 $HA_6$ 和 $HA_2$。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。</li> <li>尽管互连在一起的网络的硬件地址体系各不相同，但<strong>IP 层抽象的互联网却屏蔽了下层这些很复杂的细节</strong>。<strong>只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信</strong>。上述的这种“屏蔽”概念是一个很有用，很普遍的基本概念。例如，计算机中广泛使用的图形用户界面使得用户只需简单地点击几下鼠标就能让计算机完成很多任务。实际上计算机要完成这些任务必须执行很多条指令。但这些复杂的过程全都被设计良好的图形用户界面屏蔽掉了，使用户看不见这些复杂过程。</li> </ul> <p>以上这些概念是计算机网络的精髓所在，对这些重要概念务必仔细思考和掌握。到目前为止，还有两个重要问题没有解决：</p> <ol> <li>主机或路由器怎样知道应当在 MAC 帧的首部填入什么样的硬件地址？</li> <li>路由器中的路由表是怎样得出的？</li> </ol> <p>第一个问题就是下一节所要讲的内容，而第二个问题将在后面的 <a href="#五互联网的路由选择协议">第五节</a> 节详细讨论。</p> <h3 id="24-地址解析协议-arp">2.4 地址解析协议 ARP</h3> <p>在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址。地址解析协议 ARP 就是用来解决这样的问题的。图 4-10 说明了 ARP 协议的作用。</p> <p><img src="/assets/images/computer-network/function-of-arp-protocol.png" alt="ARP 协议的作用"/> <em>图 4-10 ARP 协议的作用</em></p> <p>由于是 IP 协议使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。ARP 协议的用途是为了从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。注意，还有一个旧的协议叫做逆地址解析协议 RARP，它的作用是使只知道自己硬件地址的主机能够通过 RARP 协议找出其 IP 地址。现在的 DHCP 协议已经包含了 RARP 协议的功能。因此本书不再介绍 RARP 协议。</p> <p>我们知道，网络层使用的是 IP 地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但 IP 地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系（例如，IP 地址有 32 位，而局域网的硬件地址是 48 位）。此外，在一个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变。<strong>地址解析协议 ARP</strong> 解决这个问题的方法是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。</p> <p>每台主机都设有一个 <strong>ARP 高速缓存</strong>（ARP cache），里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p> <p>当主机 A 要向<strong>本局域网</strong>上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。也有可能查不到主机 B 的 IP 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 ARP，然后按以下步骤找出主机 B 的硬件地址。</p> <ol> <li>ARP 进程在本局域网上广播发送一个 ARP 请求分组（具体格式可参阅[COME06]的第 23 章）。图 4-11（a）是主机 A 广播发送 ARP 请求分组的示意图。ARP 请求分组的主要内容是：“我的 IP 地址是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18。我想知道 IP 地址为 209.0.0.6 的主机的硬件地址。”</li> <li>在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组。</li> <li>主机 B 的 IP 地址与 ARP 请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机 A 发送 ARP 响应分组（其格式见[COME06]），同时在这个 ARP 响应分组中写入自己的硬件地址。由于其余的所有主机的 IP 地址都与 ARP 请求分组中要查询的 IP 地址不一致，因此都不理睬这个 ARP 请求分组，见图 4-11（b）。ARP 响应分组的主要内容是：“我的 IP 地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A。”请注意：虽然 ARP 请求分组是广播发送的，但 ARP 响应分组是普通的单播，即从一个源地址发送到一个目的地址。</li> <li>主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的IP 地址到硬件地址的映射。</li> </ol> <p><img src="/assets/images/computer-network/the-working-principle-of-the-address-resolution-protocol.png" alt="地址解析协议 ARP 的工作原理"/> <em>图 4-11 地址解析协议 ARP 的工作原理</em></p> <p>在上述第（3）步中，当主机 B 收到 A 的 ARP 请求分组时，同时会把主机 A 的地址映射写入主机 B 自己的 ARP 高速缓存中。以后主机 B 向 A 发送数据报时就很方便了。</p> <p>ARP 把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。</p> <p>ARP 对保存在高速缓存中的每个映射地址项目都设置生存时间（例如，10 ～ 20 分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目的生存时间是很重要的。设想有一种情况。主机 A 和 B 通信。A 的 ARP 高速缓存里保存有 B 的硬件地址。但 B 的网络适配器突然坏了，B 立即更换了一块，因此 B 的硬件地址就改变了。假定 A 还要和 B 继续通信。A 在其 ARP 高速缓存中查找到 B 原先的硬件地址，并使用该硬件地址向 B 发送数据帧。但 B 原先的硬件地址已经失效了，因此 A 无法找到主机 B。但是过了一段不长的生存时间，A 的 ARP 高速缓存中已经删除了 B 原先的硬件地址，于是 A 重新广播发送 ARP 请求分组，又找到了 B。</p> <p>注意，ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如，在前面的图 4-9 中，主机 H 就无法解析出另一个局域网上主机 $H_2$ 的硬件地址（实际上主机 $H_1$ 也不需要知道远程主机 $H_2$ 的硬件地址）。主机 $H_1$ 发送给 $H_2$ 的 IP 数据报首先需要通过与主机 $H_1$ 连接在同一个局域网上的路由器 $R_1$ 来转发。因此主机 $H_1$ 这时需要把路由器 $R_1$ 的 IP 地址 $IP_3$，解析为硬件地址 $HA_3$，以便能够把 IP 数据报传送到路由器 $R_1$。以后 $R_1$ 从转发表找出了下一跳路由器 $R_2$，同时使用 ARP 解析出 $R_2$ 的硬件地址 $HA_5$。于是 IP 数据报按照硬件地址 $HA_5$，转发到路由器 $R_2$。路由器 $R_2$ 在转发这个 IP 数据报时用类似方法解析出目的主机 $H_2$ 的硬件地址 $HA_2$，使 IP 数据报最终交付主机 $H_2$。</p> <p>从 IP 地址到硬件地址的解析是自动进行的，<strong>主机的用户对这种地址解析过程是不知道的</strong>。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地把这个 IP 地址解析为链路层所需要的硬件地址。</p> <p>下面我们归纳出使用ARP的四种典型情况（图4-12）。</p> <p><img src="/assets/images/computer-network/four-typical-scenarios-for-using-arp.png" alt="使用 ARP 的四种典型情况"/> <em>图4 -12 使用 ARP 的四种典型情况</em></p> <ol> <li>发送方是主机（如 $H_1$），要把 IP 数据报发送到同一个网络上的另一台主机（如 $H_2$）。这时 $H_1$ 发送 ARP 请求分组（在网上广播），找到目的主机 $H_2$ 的硬件地址。</li> <li>发送方是主机（如 $H_1$），要把 IP 数据报发送到另一个网络上的一台主机（如 $H_3$ 或 $H_4$）。这时 $H_1$ 发送 ARP 请求分组（在网上广播），找到网上的一个路由器 $R_1$ 的硬件地址。剩下的工作由路由器 $R_1$ 来完成。$R_1$ 要做的事情是下面的（3）或（4）。</li> <li>发送方是路由器（如 $R_1$），要把 IP 数据报转发到与 $R_1$ 连接在同一个网络（网 2）上的主机（如 $H_3$）。这时 $R_1$ 发送 ARP 请求分组（在网 2 上广播），找到目的主机 $H_3$ 的硬件地址。</li> <li>发送方是路由器（如 $R_1$），要把 IP 数据报转发到网 3 上的一台主机（如 $H_4$）。$H_4$ 与 $R_1$ 不是连接在同一个网络上。这时 $R_1$ 发送 ARP 请求分组（在网 2 上广播），找到连接在网 2 上的一个路由器 R2 的硬件地址。剩下的工作由这个路由器 $R_2$ 来完成。</li> </ol> <p>在许多情况下需要多次使用 ARP。但这只是以上几种情况的反复使用而已。</p> <p>既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的 IP 地址，而不直接使用硬件地址进行通信？由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但 IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p> <h3 id="25-ip-数据报的格式">2.5 IP 数据报的格式</h3> <p>IP 数据报的格式能够说明 IP 协议都具有什么功能。在 TCP/IP 的标准中，各种数据格式常常以 32 位（即 4 字节）为单位来描述。图 4-13 是 IP 数据报的完整格式。</p> <p><img src="/assets/images/computer-network/format-of-the-ip-datagram.png" alt="IP 数据报的格式"/> <em>图 4-13 IP 数据报的格式</em></p> <p>从图 4-13 可看出，一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。</p> <h4 id="1ip-数据报首部的固定部分中的各字段">（1）IP 数据报首部的固定部分中的各字段</h4> <ul> <li><strong>版本</strong>：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4（即 IPv4）。</li> <li><strong>首部长度</strong>：占 4 位，可表示的最大十进制数值是 15。请注意，首部长度字段所表示数的单位是 32 位字（1 个 32 位字长是 4 字节）。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 5（即二进制表示的首部长度是 0101）。而当首部长度为最大值 1111 时（即十进制数的 15），就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节（即首部长度为 0101），这时不使用任何选项。</li> <li><strong>区分服务</strong>：占 8 位，用来获得更好的服务。只有在使用区分服务时，这个字段才起作用。一般情况下不使用这个字段[RFC2474，3168，3260]。</li> <li> <p><strong>总长度</strong>：总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 $2^{16} - 1$ = 65535 字节。 然而实际上传送这样长的数据报在现实中是极少遇到的。</p> <p>我们知道，在 IP 层下面的每种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为<strong>最大传送单元 MTU</strong>（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的 MTU 值。例如，最常用的以太网就规定其 MTU 值是 1500 字节。若所传送的数据报长度超过数据链路层的 MTU 值，就必须把过长的数据报进行分片处理。</p> <p>虽然使用尽可能长的 IP 数据报会使传输效率得到提高（因为每个 IP 数据报中首部长度占数据报总长度的比例就会小些），但数据报短些也有好处。每个 IP 数据报越短，路由器转发的速度就越快。为此，IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p> <p>在进行分片时（见后面的“片偏移”字段），数据报首部中的“总长度”字段是指分片后的每个分片的首部长度与该分片的数据长度的总和。</p> </li> <li> <p><strong>标识</strong>（identification）：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p> </li> <li><strong>标志</strong>（flag）：占 3 位，但目前只有两位有意义。 <ul> <li>标志字段中的最低位记为 MF（More Fragment）。MF = 1 即表示后面“还有分片”的数据报。MF = 0 表示这已是若干数据报片中的最后一个。</li> <li>标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF = 0 时才允许分片。</li> </ul> </li> <li> <p><strong>片偏移</strong>：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位。这就是说，每个分片的长度一定是 8 字节（64 位）的整数倍。下面举一个例子。 【例 4-1】 一数据报的总长度为 3820 字节，其数据部分为 3800 字节长（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。于是分为 3 个数据报片，其数据部分的长度分别为 1400，1400 和 1000 字节。原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。图 4-14 给出分片后得出的结果（注意片偏移的数值）。</p> <p><img src="/assets/images/computer-network/example-for-fragment-datagram.png" alt="数据报的分片举例"/> <em>图 4-14 数据报的分片举例</em></p> <p>表 4-5 是本例中数据报首部与分片有关的字段中的数值，其中标识字段的值是任意给定的（12345）。具有相同标识的数据报片在目的站就可无误地重装成原来的数据报。</p> <p>| | 总长度 | 标识 | MF | DF | 片偏移 | | :—: | :—: | :—: | :—: | :—: | :—: | | 原始数据报 | 3820 | 12345 | 0 | 0 | 0 | | 数据报片 1 | 1420 | 12345 | 1 | 0 | 0 | | 数据报片 2 | 1420 | 12345 | 1 | 0 | 175 | | 数据报片 3 | 1020 | 12345 | 0 | 0 | 350 | <em>表 4-5 IP 数据报首部中与分片有关的字段中的数值</em></p> <p>现在假定数据报片 2 经过某个网络时还需要再进行分片，即划分为数据报片 2-1（携带数据 800 字节）和数据报片 2-2（携带数据 600 字节）。那么这两个数据报片的总长度、标识、MF、DF 和片偏移分别为：820，12345，1，0， 175；620，12345，1，0，275。</p> </li> <li> <p><strong>生存时间</strong>：占 8 位，生存时间字段常用的英文缩写是 TTL（Time To Live），表明这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子（例如从路由器 $R_1$ 转发到 $R_2$，再转发到 $R_3$，然后又转发到 $R_1$），因而白白消耗网络资源。最初的设计是以秒作为 TTL 值的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于 1 秒，后来就把 TTL 字段的功能改为“<strong>跳数限制</strong>”（但名称不变）。路由器在每次转发数据报之前就把 TTL 值减 1。若 TTL 值减小到零，就丢弃这个数据报，不再转发。因此，现在 TTL 的单位不再是秒，而是<strong>跳数</strong>。TTL 的意义是指明数据报在互联网中至多可经过多少个路由器。显然，数据报能在互联网中经过的路由器的最大数值是 255。若把 TTL 的初始值设置为 1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前 TTL 值就减小到零，因而就会被这个路由器丢弃。</p> </li> <li> <p><strong>协议</strong>：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。</p> <p>常用的一些协议和相应的协议字段值如下：</p> <table> <thead> <tr> <th>协议名</th> <th>ICMP</th> <th>IGMP</th> <th>IP</th> <th>TCP</th> <th>EGP</th> <th>IGP</th> <th>UDP</th> <th>IPv6</th> <th>ESP</th> <th>OSPF</th> </tr> </thead> <tbody> <tr> <td>协议字段值</td> <td>1</td> <td>2</td> <td>4</td> <td>6</td> <td>8</td> <td>9</td> <td>17</td> <td>41</td> <td>50</td> <td>89</td> </tr> </tbody> </table> </li> <li> <p><strong>首部检验和</strong>：占 16 位。这个字段<strong>只检验数据报的首部</strong>，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的 CRC 检验码而采用下面的简单计算方法：在发送方，先把 IP 数据报首部划分为许多 16 位字的序列，并把检验和字段置零。用反码算术运算把所有 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有 16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为 0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。图 4-15 说明了 IP 数据报首部检验和的计算过程。</p> <p><img src="/assets/images/computer-network/the-calculation-process-of-ip-datagram-header-check-sum.png" alt="IP 数据报首部检验和的计算过程"/> <em>图 4-15 IP 数据报首部检验和的计算过程</em></p> </li> <li><strong>源地址</strong>：占 32 位。</li> <li><strong>目的地址</strong>：占 32 位。</li> </ul> <h4 id="2ip-数据报首部的可变部分">（2）IP 数据报首部的可变部分</h4> <p>IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。</p> <p>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 IPv6 就把 IP 数据报的首部长度做成固定的。</p> <h3 id="26-ip-层转发分组的流程">2.6 IP 层转发分组的流程</h3> <p>图 4-16（a）是一个路由表的简单例子。有四个 A 类网络通过三个路由器连接在一起。每个网络上都可能有成千上万台主机（图中没有画出这些主机）。可以想象，若路由表指出到每台主机应怎样转发，则所得出的路由表就会过于庞大（如果每个网络有 1 万台主机，四个网络就有 4 万台主机，因而每个路由表就有 4 万个项目，即 4 万行。每一行对应于一台主机）。但若路由表指出到某个网络应如何转发，则每个路由器中的路由表就只包含 4 个项目（即只有 4 行，每一行对应于一个网络）。以路由器 $R_2$ 的路由表为例。由于 $R_2$ 同时连接在网络 2 和网络 3 上，因此只要目的主机在网络 2 或网络 3上，都可通过接口 0 或 1 由路由器 $R_2$ 直接交付（当然还要利用地址解析协议 ARP 才能找到这些主机相应的硬件地址）。若目的主机在网络 1 中，则下一跳路由器应为 $R_1$，其 IP 地址为 20.0.0.7。路由器 $R_2$ 和 $R_1$ 由于同时连接在网络 2 上，因此从路由器 $R_2$ 分组转发到路由器 $R_1$ 是很容易的。同理，若目的主机在网络 4 中，则路由器 $R_2$ 应把分组转发给 IP 地址为30.0.0.1 的路由器 $R_3$。我们应当注意到，图中的每个路由器都有两个不同的 IP 地址。</p> <p>可以把整个的网络拓扑简化为图 4-16（b）所示的那样。在简化图中，网络变成了一条链路，但每个路由器旁边都注明其 IP 地址。使用这样的简化图，可以使我们不必关心某个网络内部的具体拓扑以及连接在该网络上有多少台主机，因为这些对于研究分组转发问题并没有什么关系。这样的简化图强调了在互联网上转发分组时，是从一个路由器转发到下一个路由器。</p> <p>总之，在路由表中，对每一条路由最主要的是以下两个信息：</p> \[（目的网络地址，下一跳地址）\] <p><img src="/assets/images/computer-network/an-example-of-routing-table.png" alt="路由表举例"/> <em>图 4-16 路由表举例</em></p> <p>于是，我们就根据目的网络地址来确定下一跳路由器，这样做可得出以下的结果。</p> <ul> <li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li> <li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li> </ul> <p>虽然互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做<strong>特定主机路由</strong>。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某台主机的特殊路由就十分有用。</p> <p>路由器还可采用<strong>默认路由</strong>（default route）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。实际上，默认路由在主机发送 IP 数据报时往往更能显示出它的好处。我们之前讲过，主机在发送每个 IP 数据报时都要查找自己的路由表。如果一台主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。例如，在图 4-17 的互联网中，连接在网络上的任何一台主机中的路由表只需要三个项目即可。第一个项目就是到本网络主机的路由，其目的网络就是本网络 $N_1$，因而不需要路由器转发，而是直接交付。第二个项目是到网络 $N_2$ 的路由，对应的下一跳路由器是 $R_2$。第三个项目就是<strong>默认路由</strong>。只要目的网络是其他网络（不是 $N_1$ 或 $N_2$），就一律选择默认路由，把数据报先间接交付路由器 $R_1$，让再 $R_1$ 转发给互联网中的下一个路由器，一直转发到目的网络上的路由器，最后进行直接交付。在实际上的路由器中，像图 4-17 路由表中所示的“直接”和“其他”的几个字符并没有出现在路由表中，而是被记为 0.0.0.0。</p> <p><img src="/assets/images/computer-network/router-r1-acts-as-the-default-router-for-network-n1.png" alt="路由器 $R_1$ 充当网络 $N_1$ 的默认路由器"/> <em>图 4-17 路由器 $R_1$ 充当网络 $N_1$ 的默认路由器</em></p> <p>这里我们应当强调指出，在 IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。在 IP 数据报的首部写上的 IP 地址是源 IP 地址和目的 IP 地址，而没有中间经过的路由器的 IP 地址。既然 IP 数据报中没有下一跳路由器的 IP 地址，那么待转发的数据报又怎样能够找到下一跳路由器呢？</p> <p>当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（必须使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用 ARP 得到硬件地址、把硬件地址写入 MAC 帧的首部等过程，将不断地重复进行，造成了一定的开销。</p> <p>那么，能不能在路由表中不使用 IP 地址而直接使用硬件地址呢？不行。我们一定要弄清楚，使用抽象的 IP 地址，本来就是为了隐蔽各种底层网络的复杂性而便于分析和研究问题，这样就不可避免地要付出代价，例如在选择路由时多了一些开销。但反过来，如果在路由表中直接使用硬件地址，那就会带来更多的麻烦。</p> <p>根据以上所述，可归纳出<strong>分组转发算法</strong>如下：</p> <ol> <li>从数据报的首部提取目的主机的 IP 地址 D，得出目的网络地址为 N。</li> <li>若 N 就是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行（3）。</li> <li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。</li> <li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）。</li> <li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）。</li> <li>报告转发分组出错。</li> </ol> <p>这里我们要再强调一下，路由表并没有给分组指明到某个网络的完整路径（即先经过哪一个路由器，然后再经过哪一个路由器，等等）。路由表指出，到某个网络应当先到某个路由器（即下一跳路由器），在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</p> <h2 id="三-划分子网和构造超网">三、 划分子网和构造超网</h2> <h3 id="31-划分子网">3.1 划分子网</h3> <h4 id="1从两级-ip-地址到三级-ip-地址">（1）从两级 IP 地址到三级 IP 地址</h4> <p>在今天看来，在 ARPANET 的早期，IP 地址的设计不够合理。</p> <ol> <li><strong>IP 地址空间的利用率有时很低</strong>。每个 A 类地址网络可连接的主机数超过 1000 万，而每个 B 类地址网络可连接的主机数也超过 6 万。有的单位申请到了一个 B 类地址网络，但所连接的主机数并不多，可是又不愿意申请一个足够使用的 C 类地址，理由是考虑到今后可能的发展。IP 地址的浪费，还会使 IP 地址空间的资源过早地被用完。</li> <li>给每个物理网络分配一个网络号会<strong>使路由表变得太大</strong>因而使网络性能变坏。每个路由器都应当能够从路由表查出应怎样到达其他网络的下一跳路由器。因此，互联网中的网络数越多，路由器的路由表的项目数也就越多。这样，即使我们拥有足够多的 IP 地址资源可以给每个物理网络分配一个网络号，也会导致路由器的路由表中的项目数过多。这不仅增加了路由器的成本（需要更多的存储空间），而且使查找路由时耗费更多的时间，同时也使路由器之间定期交换的路由信息急剧增加，因而使路由器和整个互联网的性能都下降了。</li> <li><strong>两级 IP 地址不够灵活</strong>。有时情况紧急，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必事先到互联网管理机构去申请新的网络号。原来的两级 IP 地址无法做到这一点。</li> </ol> <p>为解决上述问题，在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级 IP 地址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做<strong>划分子网</strong>（subnetting）[RFC 950]，或<strong>子网寻址</strong>或<strong>子网路由选择</strong>。划分子网已成为互联网的正式标准协议。</p> <p>划分子网的基本思路如下：</p> <ol> <li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个<strong>子网</strong>（subnet）。划分子网纯属一个单位内部的事情。本单位以外的网络<strong>看不见</strong>这个网络是由多少个子网组成，因为这个单位对<strong>外仍然表现为一个网络</strong>。</li> <li> <p>划分子网的方法是从网络的主机号借用若干位作为子网号（subnet-id），当然主机号也就相应减少了同样的位数。于是两级 IP 地址在<strong>本单位内部</strong>就变为<strong>三级</strong> IP 地址：网络号、子网号和主机号。也可以用以下记法来表示： \(IP 地址 ::== {&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}\)</p> </li> <li>凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。</li> </ol> <p>下面用例子说明划分子网的概念。图 4-18 表示某单位拥有一个 B 类 IP 地址，网络地址是 145.13.0.0（网络号是 145.13）。凡目的地址为 145.13.x.x 的数据报都被送到这个网络上的路由器 $R_1$。</p> <p><img src="/assets/images/computer-network/a-b-network.png" alt="一个 B 类网络 145.13.0.0"/> <em>图 4-18 一个 B 类网络 145.13.0.0</em></p> <p>现把图 4-18 的网络划分为三个子网（图 4-19）。这里假定子网号占用 8 位，因此在增加了子网号后，主机号就只有 8 位。所划分的三个子网分别是：145.13.3.0，145.13.7.0 和 145.13.21.0 。在划分子网后，整个网络对外部仍表现为一个网络，其网络地址仍为 145.13.0.0。但网络 145.13.0.0 上的路由器 $R_1$ 在收到外来的数据报后，再根据数据报的目的地址把它转发到相应的子网。</p> <p><img src="/assets/images/computer-network/a-subnet-of-b-network.png" alt="把图 4-18 的网络 145.13.0.0 划分为三个子网，但对外仍是一个网络"/> <em>图 4-19 把图 4-18 的网络 145.13.0.0 划分为三个子网，但对外仍是一个网络</em></p> <p>总之，当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。</p> <h4 id="2子网掩码">（2）子网掩码</h4> <p>假定有一个数据报（其目的地址是 145.13.3.10）已经到达了路由器 $R_1$。那么这个路由器如何把它转发到子网 145.13.3.0 呢？</p> <p>我们知道，从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。因此必须另外想办法，这就是使用<strong>子网掩码</strong>（subnet mask）（见图4-20）。</p> <p><img src="/assets/images/computer-network/each-field-and-subnet-mask-of-the-ip-address.png" alt="IP 地址的各字段和子网掩码"/> <em>图 4-20 IP 地址的各字段和子网掩码（以 145.13.3.30 为例）</em></p> <ul> <li>图 4-20（a）是 IP 地址为 145.13.3.10 的主机本来的两级 IP 地址结构。</li> <li>图 4-20（b）是这个两级 IP 地址的子网掩码。</li> <li>图 4-20（c）是同一地址的三级 IP 地址结构，也就是说，现在从原来 16 位的主机号中拿出 8 位作为子网号，而主机号由 16 位减少到 8 位。请注意，现在子网号为 3 的网络的<strong>网络地址</strong>是 145.13.3.0（既不是原来两级 IP 地址的网络地址 145.13.0.0，也不是简单的子网号 3）。为了使路由器 $R_1$ 能够很方便地从数据报中的目的 IP 地址中提取出所要找的子网的网络地址，路由器 $R_1$ 就要使用三级 IP 地址的子网掩码。</li> <li>图 4-20（d）是三级 IP 地址的子网掩码，它也是 32 位，由一串 24 个 1 和跟随的一串 8 个 0 组成。子网掩码中的 1 对应于 IP 地址中原来二级地址中的 16 位网络号加上新增加的 8 位子网号，而子网掩码中的 0 对应于现在的 8 位主机号。虽然 RFC 文档中没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用<strong>连续的 1</strong>，以免出现可能发生的差错。</li> <li>图 4-20（e）表示 $R_1$ 把三级 IP 地址的子网掩码和收到的数据报的目的 IP 地址 145.13.3.10 逐位相“与”（AND）（计算机进行这种逻辑 AND 运算是很容易的），得出了所要找的<strong>子网的网络地址</strong> 145.13.3.0。</li> </ul> <p>使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“<strong>与</strong>”运算（AND），就能够立即得出网络地址。这样在路由器处理到来的分组时就可采用同样的算法。</p> <p>归纳一下上述的要点。从网络 145.13.0.0 外面看，这就是一个普通的 B 类网络，其子网掩码为 16 个连 1 后面跟上 16 个连 0。但进入到这个网络后（即到了路由器 $R_1$），就看到了还有许多网络（即划分了子网后的许多网络），其网络地址是 145.13.x.0（这里 x 可以表示不同的数值），而这些网络的子网掩码都是 24 个连 1 后面跟上 8 个连 0。总之，在这个 B 类网络的外面和里面，看到的网络是不一样的。</p> <p>这里还要弄清一个问题，这就是：在不划分子网时，既然没有子网，为什么还要使用子网掩码？这就是为了更便于查找路由表。现在互联网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用<strong>默认子网掩码</strong>。默认子网掩码中的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相“与”（AND），就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。显然：</p> <ul> <li>A 类地址的默认子网掩码是255.0.0.0，或 0xFF000000（注：对应二进制为 11111111 00000000 00000000 00000000）。</li> <li>B 类地址的默认子网掩码是255.255.0.0，或 0xFFFF0000（注：对应二进制为 11111111 11111111 00000000 00000000）。</li> <li>C 类地址的默认子网掩码是255.255.255.0，或 0xFFFFFF00（注：对应二进制为 11111111 11111111 11111111 00000000）。</li> </ul> <p>图 4-21 是这三类 IP 地址的网络地址和相应的默认子网掩码。</p> <p><img src="/assets/images/computer-network/default-subnet-mask-of-class-a-b-and-c-ip-addresses.png" alt="A 类、B 类和 C 类 IP 地址的默认子网掩码"/> <em>图 4-21 A 类、B 类和 C 类 IP 地址的默认子网掩码</em></p> <p><strong>子网掩码是一个网络或一个子网的重要属性</strong>。在 RFC 950 成为互联网的正式标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。我们以一个 B 类地址为例，说明可以有多少种子网划分的方法。在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的（见表 4-6）。</p> <p>| 子网号的位数 | 子网掩码 | 子网数 | 每个子网的主机数 | | :-: | :-: | :-: | :-: | :-: | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | <em>表 4-6 B 类地址的子网划分选择（使用固定长度子网）</em></p> <p>在表 4-6 中，子网数是根据子网号（subnet-id）计算出来的。若 subnet-id 有 n 位，则共有 $2^n$ 种可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数。</p> <p>表中的“子网号的位数”中没有 0，1，15 和 16这四种情况，因为这没有意义。</p> <p>注意，虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，<strong>现在全 1 和全 0 的子网号也可以使用了</strong>，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种用法。</p> <p>我们可以看出，若使用较少位数的子网号，则每一个子网上可连接的主机数就较多。反之，若使用较多位数的子网号，则子网的数目较多但每个子网上可连接的主机数就较少。因此我们可根据网络的具体情况（一共需要划分多少个子网，每个子网中最多有多少台主机）来选择合适的子网掩码。</p> <p>通过简单的计算，读者不难得到这样的结论：<strong>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数</strong>。例如，本来一个 B 类地址最多可连接 65534 台主机，但表 4-6 中任意一行的最后两项的乘积一定小于 65534。对 A 类和 C 类地址的子网划分也可得出类似的表格。</p> <p>【例 4-2】已知 IP 地址是 141.14.72.24，子网掩码是 255.255.192.0。试求网络地址。</p> <p>【解】子网掩码是 11111111 11111111 11000000 00000000。请注意，掩码的前两个字节都是全 1，因此网络地址的前两个字节可写为 141.14。子网掩码的第四字节是全 0，因此网络地址的第四字节是 0。可见本题仅需对地址中的第三字节进行计算。我们只要把 IP 地址和子网掩码的第三字节用二进制表示，就可以很容易地得出网络地址（图 4-22）。</p> <p><img src="/assets/images/computer-network/network-address-calculation.png" alt="网络地址的计算"/> <em>图 4-22 网络地址的计算</em></p> <p>注意，在一个 IP 地址中不允许把十进制和二进制混合使用。图 4-22 中（b）和（d）的写法，仅仅为了说明解题的步骤，而并非表示平时可以这样书写 IP 地址。</p> <p>【例 4-3】在上例中，若子网掩码改为 255.255.224.0。试求网络地址，并讨论所得结果。</p> <p>【解】 用同样方法可得出网络地址是 141.14.64.0，和上例的结果相同（图 4-23）。</p> <p><img src="/assets/images/computer-network/different-subnet-masks-give-the-same-network-address.png" alt="不同的子网掩码得出相同的网络地址"/> <em>图 4-23 不同的子网掩码得出相同的网络地址</em></p> <p>这个例子说明，同样的 IP 地址和不同的子网掩码可以得出相同的网络地址。但是，不同的掩码的效果是不同的。在例 4-2 中，子网号是 2 位，主机号是 14 位。在例 4-3 中，子网号是 3 位，主机号是 13 位。因此这两个例子中可划分的子网数和每个子网中的最大主机数都是不一样的。</p> <h3 id="32-使用子网时分组的转发">3.2 使用子网时分组的转发</h3> <p>使用子网划分后，路由表必须包含以下三项内容：<strong>目的网络地址</strong>、<strong>子网掩码</strong>和<strong>下一跳地址</strong>。在划分子网的情况下，路由器转发分组的算法如下：</p> <ol> <li>从收到的数据报的首部提取目的 IP 地址 D。</li> <li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 逐位相“<strong>与</strong>”（AND 操作），看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去），转发任务结束。否则就是间接交付，执行（3）。</li> <li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。</li> <li>对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和 D 逐位相“<strong>与</strong>”（AND 操作），其结果为 N。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行（5）。</li> <li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）。</li> <li>报告转发分组出错。</li> </ol> <p>【例 4-4】图 4-24 有三个子网，两个路由器，以及路由器 $R_1$ 中的部分路由表。现在源主机 $H_1$ 向目的主机 $H_2$ 发送分组。试讨论 $R_1$ 收到 $H_1$ 向 $H_2$ 发送的分组后查找路由表的过程。</p> <p><img src="/assets/images/computer-network/host-h1-sends-packets-to-h2.png" alt="主机 $H_1$ 向 $H_2$ 发送分组"/> <em>图 4-24 主机 $H_1$ 向 $H_2$ 发送分组</em></p> <p>【解】源主机 $H_1$ 向目的主机 $H_2$ 发送的分组的目的地址是 $H_2$ 的 IP 地址 128.30.33.138。源主机 $H_1$ 首先要进行的操作是要判断：发送的这个分组，是在本子网上进行直接交付还是要通过本子网上的路由器进行间接交付？</p> <p>源主机 $H_1$ 把本子网的“子网掩码 255.255.255.128”与目的主机 $H_2$ 的“IP 地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），得出 128.30.33.128，它不等于 $H_1$ 的网络地址（128.30.33.0）。这说明 $H_2$ 与 $H_1$ 不在同一个子网上。因此 $H_1$ 不能把分组直接交付 $H_2$，而必须交给子网上的默认路由器 $R_1$，由 $R_1$ 来转发。</p> <p>路由器 $R_1$ 在收到一个分组后，就在其路由表中逐行寻找有无匹配的网络地址。</p> <p>先看 $R_1$ 路由表中的第一行。用这一行的“子网掩码 255.255.255.128”和收到的分组的“目的地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），得出 128.30.33.128。然后和这一行给出的目的网络地址 128.30.33.0 进行比较。但比较的结果不一致（即不匹配）。</p> <p>用同样方法继续往下找第二行。用第二行的“子网掩码 255.255.255.128”和该分组的“目的地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），结果也是 128.30.33.128。这个结果和第二行的目的网络地址 128.30.33.128 相匹配，说明这个网络（子网 2） 就是收到的分组所要寻找的目的网络。于是不需要再继续查找下去。$R_1$ 把分组从接口 1 直接交付主机 $H_2$（它们都在一个子网上）。</p> <h3 id="33-无分类编址-cidr构造超网">3.3 无分类编址 CIDR（构造超网）</h3> <h4 id="1网络前缀">（1）网络前缀</h4> <p>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：</p> <ol> <li>B 类地址在 1992 年已分配了近一半，眼看很快就将全部分配完毕!</li> <li>互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。</li> <li>整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽了。</li> </ol> <p>当时预计前两个问题将在 1994 年变得非常严重。因此 IETF 很快就研究出采用无分类编址的方法来解决前两个问题。IETF 认为上面的第三个问题属于更加长远的问题，因此专门成立 IPv6 工作组负责研究解决新版本 IP 协议的问题。</p> <p>其实早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用<strong>变长子网掩码</strong> VLSM（Variable Length Subnet Mask）可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出<strong>无分类编址</strong>方法，它的正式名字是无分类域间路由选择 CIDR（Classless Inter-Domain Routing，CIDR 的读音是“sider”）。</p> <p>CIDR 最主要的特点有两个：</p> <ol> <li><strong>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念</strong>，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是“<strong>网络前缀</strong>”（network-prefix）（或简称为“前缀”），用来指明网络，后面部分则用来指明主机。因此 CIDR 使 IP 地址从三级编址（使用子网掩码）又回到了两级编址，但这已是<strong>无分类的两级编址</strong>。其记法是：</li> </ol> \[IP 地址 ::= {&lt;网络前缀&gt;，&lt;主机号&gt;}\] <p>CIDR 还使用“<strong>斜线记法</strong>”（slash notation），或称为 <strong>CIDR 记法</strong>，即在 IP 地址后面加上斜线“/”，然后写上网络前缀所占的位数。</p> <ol> <li>CIDR 把网络前缀都相同的连续的 IP 地址组成一个“CIDR <strong>地址块</strong>”。我们只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。例如，已知 IP 地址 128.14.35.7/20 是某 CIDR 地址块中的一个地址，现在把它写成二进制表示，其中的前 20 位是网络前缀（用粗体和下划线表示出），而前缀后面的 12 位是主机号：</li> </ol> \[128.14.35.7/20 = \underline{10000000 00001110 0010}0011 00000111\] <p>这个地址所在的地址块中的最小地址和最大地址可以很方便地得出：</p> <table> <thead> <tr> <th>最小地址</th> <th>128.14.32.0</th> <th>$\underline{10000000 00001110 0010}0000 00000000$</th> </tr> </thead> <tbody> <tr> <td>最大地址</td> <td>128.14.47.255</td> <td>$\underline{10000000 00001110 0010}1111 11111111$</td> </tr> </tbody> </table> <p>当然，以上这两个特殊地址的主机是全和全 1 的地址。一般并不使用。通常只使用在这两个特殊地址之间的地址。不难看出，这个地址块共有 $2^{12}$ 个地址。我们可以用地址块中的最小地址和网络前缀的位数指明这个地址块。例如，上面的地址块可记为 128.14.32.0/20。在不需要指出地址块的起始地址时，也可把这样的地址块简称为“/20 地址块”。</p> <p>为了更方便地进行路由选择，CIDR 使用 32 位的<strong>地址掩码</strong>（address mask）。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为子网掩码。例如，/20 地址块的地址掩码是：11111111 11111111 11110000 00000000（20 个连续的 1）。<strong>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数</strong>。</p> <p>注意，“CIDR 不使用子网”是指 CIDR 并没有在 32 位地址中指明若干位作为子网字段。但分配到一个 CIDR 地址块的单位，仍然可以在本单位内根据需要划分出一些子网。这些子网也都只有一个网络前缀和一台主机号字段，但子网的网络前缀比整个单位的网络前缀要长些。例如，某单位分配到地址块/20，就可以再继续划分为 8 个子网（即需要从主机号中借用 3 位来划分子网）。这时每个子网的网络前缀就变成 23 位（原来的 20 位加上从主机号借来的 3 位），比该单位的网络前缀多了 3 位。</p> <p>斜线记法还有一个好处就是它除了表示一个 IP 地址外，还提供了其他一些重要信息。我们举例说明如下。</p> <p>例如，地址 192.199.170.82/27 不仅表示IP 地址是 192.199.170.82，而且还表示这个地址块的网络的前缀有 27 位（剩下的 5 位是主机号），因此这个地址块包含 32 个 IP 地址（232）。通过简单的计算还可得出，这个地址块的最小地址是192.199.170.64，最大地址是 192.199.170.95。具体的计算方法是这样的。找出地址掩码中 1 和 0 的交界处发生在地址中的哪个字节。现在是在第四个字节。因此只要把这一个字节的十进制 82 用二进制表示即可。十进制 82 的二进制是 01010010，取其前 3 位（这 3 位加上前 3 个字节的 24 位等于前缀的 27 位），再把后面 5 位都写成 0，即 $010\underline{00000}$，等于十进制的 64。这就找出了地址块的最小地址 192.199.170.64。再把地址的第四字节的最后 5 位都置 1，即 $010\underline{11111}$，等于十进制的 95，这就找出了地址块中的最大地址 192.199.170.95。</p> <p>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong>（route aggregation），它使得路由表中的一个项目可以表示原来传统分类地址的很多个（例如上千个）路由。路由聚合也称为<strong>构成超网</strong>（supernetting）。路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p> <p>CIDR 记法有多种形式，例如，地址块 10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。另一种简化表示方法是在网络前缀的后面加一个星号 <code class="language-plaintext highlighter-rouge">*</code>，如：</p> \[00001010 00*\] <p>意思是：在星号 <code class="language-plaintext highlighter-rouge">*</code> 之前是网络前缀，而星号 <code class="language-plaintext highlighter-rouge">*</code> 表示 IP 地址中的主机号，可以是任意值。</p> <p>前缀位数不是 8 的整数倍时，需要进行简单的计算才能得到一些地址信息。</p> <p>表 4-7 给出了最常用的 CIDR 地址块。表中的 K 表示 $2^{10}$ 即 1024。网络前缀小于 13 或大于 27 都较少使用。在“包含的地址数”中没有把全 1 和全 0 的主机号除外。</p> <p>| CIDR 前缀长度 | 点分十进制 | 包含的地址数 | 相当于包含分类的网络数 | | :-: | :-: | :-: | :-: | | /13 | 255.248.0.0 | 512 K | 8 个 B 类或 2048 个 C 类 | | /14 | 255.252.0.0 | 256 K | 4 个 B 类或 1024 个 C 类 | | /15 | 255.254.0.0 | 128 K | 2 个 B 类或 512 个 C 类 | | /16 | 255.255.0.0 | 64 K | 1 个 B 类或 256 个 C 类 | | /17 | 255.255.128.0 | 32 K | 128 个 C 类 | | /18 | 255.255.192.0 | 16 K | 64个 C 类 | | /19 | 255.255.224.0 | 8 K | 32 个 C 类 | | /20 | 255.255.240.0 | 4 K | 16 个 C 类 | | /21 | 255.255.248.0 | 2 K | 8 个 C 类 | | /22 | 255.255.252.0 | 1 K | 4 个 C 类 | | /23 | 255.255.254.0 | 512 | 2 个 C 类 | | /24 | 255.255.255.0 | 256 | 1 个 C 类 | | /25 | 255.255.255.128 | 128 | 1/2 个 C 类 | | /26 | 255.255.255.192 | 64 | 1/4 个 C 类 | | /27 | 255.255.255.224 | 32 | 1/8 个 C 类 | <em>表 4-7 常用的 CIDR 地址块</em></p> <p>从表 4-7 可看出，每一个 CIDR 地址块中的地址数一定是 2 的整数次幂。除最后几行外，CIDR 地址块都包含了多个 C 类地址（是一个 C 类地址的 $2^n$ 倍，n 是整数），这就是“<strong>构成超网</strong>”这一名词的来源。</p> <p>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。然而在分类地址的环境中，向一个部门分配 IP 地址，就只能以 <code class="language-plaintext highlighter-rouge">/8</code>，<code class="language-plaintext highlighter-rouge">/16</code> 或 <code class="language-plaintext highlighter-rouge">/24</code> 为单位来分配。这就很不灵活。</p> <p>图 4-25 给出的是 CIDR 地址块分配的例子。假定某 ISP 已拥有地址块 206.0.64.0/18（相当于有 64 个 C 类网络）。现在某大学需要 800 个 IP 地址。ISP 可以给该大学分配一个地址块 206.0.68.0/22，它包括 1024（即 $2^{10}$） 个 IP 地址，相当于 4 个连续的 C 类 <code class="language-plaintext highlighter-rouge">/24</code> 地址块，占该 ISP 拥有的地址空间的 1/16。这个大学然后可自由地对本校的各系分配地址块，而各系还可再划分本系的地址块。CIDR 的地址块分配有时不易看清，这是因为网络前缀和主机号的界限不是恰好出现在整数字节处。只要写出地址的二进制表示（从图中的地址块的二进制表示中可看出，实际上只需要将其中的一个关键字节转换为二进制的表示即可），弄清网络前缀的位数，就不会把地址块的范围弄错。</p> <p><img src="/assets/images/computer-network/example-for-dividing-cidr-address-blocks.png" alt="CIDR 地址块划分举例"/> <em>图 4-25 CIDR 地址块划分举例</em></p> <p>从图 4-25 可以清楚地看出<strong>地址聚合</strong>的概念。这个 ISP 共拥有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，就只需用路由聚合后的一个项目 206.0.64.0/18 就能找到该 ISP。同理，这个大学共有 4 个系。在 ISP 内的路由器的路由表中，也需使用 206.0.68.0/22 这个项目。这个项目好比是大学的收发室。凡寄给这个大学任何一个系的邮件，邮递员都不考虑大学各个系的地址，而是把这些邮件集中投递到大学的收发室，然后由大学的收发室再进行下一步的投递。这样就减轻了邮递员的工作量（相当于简化了路由表的查找）。</p> <p>从图 4-25 下面表格中的二进制地址可看出，把四个系的路由聚合为大学的一个路由（即构成超网），是将网络前缀<strong>缩短</strong>。<strong>网络前缀越短，其地址块所包含的地址数就越多</strong>。而在三级结构的 IP 地址中，划分子网是使网络前缀变长。</p> <h4 id="2最长前缀匹配">（2）最长前缀匹配</h4> <p>在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个 部分组成，因此在路由表中的项目也要有相应的改变。这时，每个项目由“网络前缀”和 “下一跳地址”组成。但是在查找路由表时可能会得到不止一个匹配结果。这样就带来一个 问题：我们应当从这些匹配结果中选择哪一条路由呢？ 正确的答案是：应当从匹配结果中选择具有最长网络前缀的路由。这叫做最长前缀匹 配（longest-prefix matching），这是因为网络前缀越长，其地址块就越小，因而路由就越具体 （more specific）。最长前缀匹配又称为最长匹配或最佳匹配。为了说明最长前缀匹配的概 念，我们仍以前面的例子来讨论。 假定大学下属的四系希望 ISP 把转发给四系的数据报直接发到四系而不要经过大学的路 由器，但又不愿意改变自己使用的 IP 地址块。因此，在 ISP 的路由器的路由表中，至少要 有以下两个项目，即206。0。68。0/22（大学）和206。0。71。128/25（四系）。现在假定 ISP 收到一 个数据报，其目的 IP 地址为D=206。0。71。130。把D分别和路由表中这两个项目的掩码逐位 相“与”（AND操作）。将所得的逐位 AND 操作的结果按顺序写在下面。 D 和 11111111 11111111 1111110000000000 逐位相“与”=206。0。68。0/22 匹配 D 和 11111111 11111111 11111111 10000000 逐位相“与”=206。0。71。128/25 匹配 不难看出，现在同一个 IP 地址 D 可以在路由表中找到两个目的网络（大学和四系）和 该地址相匹配。根据最长前缀匹配的原理，应当选择后者，把收到的数据报转发到后一个目 的网络（四系），即选择两个匹配的地址中更具体的一个。 从以上的讨论可以看出，如果IP 地址的分配一开始就采用 CIDR，那么我们可以按网 络所在的地理位置来分配地址块，这样就可大大减少路由表中的路由项目。例如，可以将世 界划分为四大地区，每一地区分配一个 CIDR 地址块： 地址块 194/7 （194。0。0。0至195。255。255。255）分配给欧洲； 地址块 198/7（198。0。0。0至199。255。255。255）分配给北美洲； 地址块 200/7 （200。0。0。0至201。255。255。255）分配给中美洲和南美洲； 地址块 202/7 （202。0。0。0至203。255。255。255）分配给亚洲和太平洋地区。 上面的每一个地址块包含有约3200 万个地址。这种分配地址的方法就使得IP地址与地 理位置相关联。它的好处是可以大大压缩路由表中的项目数。例如，凡是从中国发往北美的</p> <p>IP数据报（不管它是地址块198/7中的哪一个地址）都先送交位于美国的一个路由器，因此 在路由表中使用一个项目就行了。 但是，在使用 CIDR 之前，互联网的地址管理机构没有按地理位置来分配 IP 地址。现 在要把已分配出的IP 地址收回再重新分配是件十分困难的事，因为这牵涉到很多正在工作 的主机必须改变其 IP 地址。尽管这样，CIDR 的使用已经推迟了 IP 地址耗尽的日期。 3。使用二叉线索查找路由表 使用 CIDR 后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。当路 由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。例如， 连接路由器的线路的速率为10Gbit/s，而分组的平均长度为2000 bit，那么路由器就应当平均 每秒钟能够处理 500万个分组（常记为5Mpps）。或者说，路由器处理一个分组的平均时间只 有200 ns （1 ns = 10-秒）。因此，查找每一个路由所需的时间是非常短的。可见在路由表中 必须使用很好的数据结构和使用先进的快速查找算法，这一直是人们积极研究的热门课题。 对无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。例 如，给定一个目的地址 D。对每一个可能的网络前缀长度M，路由器从 D 中提取前 M 个位成 一个网络前缀，然后查找路由表中的网络前缀。所找到的最长匹配就对应于要查找的路由。 这种最简单的算法的明显缺点就是查找的次数太多。最坏的情况是路由表中没有这个 路由。在这种情况下，算法仍要进行32次（具有32位的网络前缀是一个特定主机路由）。 就是要找到一个传统的 B 类地址（即/16），也要查找 16次。对于经常使用的默认路由，这 种算法都要经历31次不必要的查找。 为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构 中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索（binary trie），它是一种 特殊结构的树。IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二 叉线索中的各个路径就代表路由表中存放的各个地址。 图 4-26 用一个例子来说明二叉线索的结构。图中给出了 5 个 IP 地址。为了简化二叉线 索的结构，可以先找出对应于每一个 IP 地址的唯一前缀（unique prefix）。所谓唯一前缀就是 在表中所有的 IP 地址中，该前缀是唯一的。这样就可以用这些唯一前缀来构造二叉线索。 在进行查找时，只要能够和唯一前缀相匹配就行了。 32位的IP地址 01000110 00000000 00000000 00000000 01010110 00000000 00000000 00000000 0 唯一前缀 0100 0101 01100001 00000000 00000000 00000000 10110000 00000010 00000000 00000000 011 10110 10111011 00001010 00000000 00000000 10111 1 图4-26 用5个前缀构成的二叉线索</p> <p>从二叉线索的根节点自顶向下的深度最多有32层，每一层对应于IP地址中的一位。 个 IP 地址存入二叉线索的规则很简单。先检查IP地址左边的第一位，如为0，则第一层的 节点就在根节点的左下方；如为 1，则在右下方。然后再检查地址的第二位，构造出第二层 的节点。依此类推，直到唯一前缀的最后一位。由于唯一前缀一般都小于32 位，因此用唯 一前缀构造的二叉线索的深度往往不到 32 层。图中较粗的折线就是前缀 0101 在这个二叉线 索中的路径。二叉线索中的小圆圈是中间节点，而在路径终点的小方框是叶节点（也叫做外 部节点）。每个叶节点代表一个唯一前缀。节点之间的连线旁边的数字表示这条边在唯一前 缀中对应的比特是0或1。 假定有一个 IP 地址是 10011011 01111010 00000000 00000000，需要查找该地址是否在 此二叉线索中。我们从最左边查起。很容易发现，查到第三个字符（即前缀 10 后面的 0） 时，在二叉线索中就找不到匹配的，说明这个地址不在这个二叉线索中。 以上只是给出了二叉线索这种数据结构的用法，而并没有说明“与唯一前缀匹配”和 “与网络前缀匹配”的关系。显然，要将二叉线索用于路由表中，还必须使二叉线索中的每 一个叶节点包含所对应的网络前缀和子网掩码。当搜索到一个叶节点时，就必须将寻找匹配 的目的地址和该叶节点的子网掩码进行逐位“与”运算，看结果是否与对应的网络前缀相匹 配。若匹配，就按下一跳的接口转发该分组。否则，就丢弃该分组。 总之，二叉线索只是提供了一种可以快速在路由表中找到匹配的叶节点的机制。但这 是否和网络前缀匹配，还要和子网掩码进行一次逻辑与的运算。 为了提高二叉线索的查找速度，广泛使用了各种压缩技术。例如，在图 4-26 中的最后 两个地址，其最前面的4位都是1011。因此，只要一个地址的前4位是1011，就可以跳过 前面4位（即压缩了4个层次）而直接从第5位开始比较。这样就可以减少查找的时间。当 然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由表时都可以提高查找 速度，因此这样做还是值得的。</p> <h2 id="四网际控制报文协议-icmp">四、网际控制报文协议 ICMP</h2> <p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了<strong>网际控制报文协议 ICMP</strong>（Internet Control Message Protocol）[RFC 792]。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议。但ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 报文格式如图 4-27 所示。</p> <p><img src="/assets/images/computer-network/icmp-packet-format.png" alt="ICMP 报文的格式"/> <em>图 4-27 ICMP 报文的格式</em></p> <h3 id="41-icmp-报文的种类">4.1 ICMP 报文的种类</h3> <p>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</p> <p>ICMP 报文的前4个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4 个字节的内容与ICMP的类型有关。最后面是数据字段，其长度取决于ICMP的类型。表 4-8 给出了几种常用的ICMP报文类型。</p> <p>| ICMP 报文种类 | 类型的值 | ICMP 报文的类型 | | - | - | - | | 差错报告报文 | 3 | 终点不可达 | | 差错报告报文 | 11 | 时间超过 | | 差错报告报文 | 12 | 参数问题 | | 差错报告报文 | 5 | 改变路由（Redirect） | | 询问报文 | 8 或 0 | 回送（Echo）请求或回答 | | 询问报文 | 13 或 14 | 时间戳（Timestamp）请求或回答 | <em>表 4-8 几种常用的 ICMP报文类型</em></p> <p>ICMP 报文的代码字段是为了进一步区分某种类型中的几种不同情况。检验和字段用来检验整个 ICMP报文。我们应当还记得，IP数据报首部的检验和并不检验 IP 数据报的内容，因此不能保证经过传输的ICMP报文不产生差错。</p> <p>表4-8 给出的 ICMP差错报告报文共有四种，即：</p> <ol> <li>终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li> <li>时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li> <li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li> <li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li> </ol> <p>下面对改变路由报文进行简短的解释。我们知道，在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每个目的网络的最佳路由（通过和其他路由器交换路由信息）。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器R（而不是默认路由器）。</p> <p>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式（图 4-28）。把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段。再加上相应的 ICMP 差错报告报文的前 8 个字节，就构成了 ICMP 差错报告报文。提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号（对于 TCP 和 UDP）以及运输层报文的发送序号（对于 TCP）。这些信息对源点通知高层协议是有用的。整个 ICMP 报文作为 IP 数据报的数据字段发送给源点。</p> <p><img src="/assets/images/computer-network/the-content-of-the-data-field-of-an-icmp-error-report-packet.png" alt="ICMP 差错报告报文的数据字段的内容"/> <em>图 4-28 ICMP 差错报告报文的数据字段的内容</em></p> <p>下面是不应发送 ICMP 差错报告报文的几种情况。</p> <ul> <li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li> <li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。</li> <li>对具有多播地址的数据报，都不发送 ICMP 差错报告报文。</li> <li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 差错报告报文。</li> </ul> <p>常用的 ICMP 询问报文有两种，即：</p> <ol> <li><strong>回送请求和回答</strong>：ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</li> <li><strong>时间戳请求和回答</strong>：ICMP 时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年 1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。</li> </ol> <h3 id="42-icmp-的应用举例">4.2 ICMP 的应用举例</h3> <p>ICMP 的一个重要应用就是分组网间探测 PING （Packet InterNet Groper），用来测试两台 主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使 用网络层 ICMP 的一个例子。它没有通过运输层的TCP 或UDP。 Windows 操作系统的用户可在接入互联网后转入 MS DOS（点击“开始”，点击“运 行”，再键入“cmd”）。看见屏幕上的提示符后，就键入“ping hostname”（这里的 hostname 是要测试连通性的主机名或它的IP 地址），按回车键后就可看到结果。 图 4-29 给出了从南京的一台 PC 到新浪网的邮件服务器 mail。sina。com。cn 的连通性的测 试结果。PC 一连发出四个 ICMP 回送请求报文。如果邮件服务器 mail。sina。com。cn 正常工作 而且响应这个 ICMP 回送请求报文（有的主机为了防止恶意攻击就不理睬外界发送过来的这 种报文），那么它就发回 ICMP 回送回答报文。由于往返的 ICMP 报文上都有时间戳，因此 很容易得出往返时间。最后显示出的是统计结果：发送到哪个机器（IP 地址），发送的、收 到的和丢失的分组数（但不给出分组丢失的原因），以及往返时间的最小值、最大值和平均</p> <p>值。从得到的结果可以看出，第三个测试分组丢失了。</p> <div class="language-ssh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">C</span>：<span class="err">\</span>Documents and Settings<span class="err">\</span>XXR&gt;piny nail.sina.com.cn

<span class="k">Pinging</span> nail.sina.com.cn [202。108。43。230] with <span class="m">32</span> bytes of data：

<span class="k">Reply</span> from <span class="m">202</span>.108.43.230： bytes=32 time=368ms TTL=242
<span class="k">Reply</span> from <span class="m">202</span>.108.43.230；bytes=32 time=324ns TTL=242 Request timed out。
<span class="k">Reply</span> from <span class="m">202</span>.108.43.230： bytes <span class="m">32</span> time-374ms TTL-242

<span class="k">Ping</span> statistics for <span class="m">202</span>.108.43.230：Packets： Sent = <span class="m">4</span>。 Received = <span class="m">3</span>， Lost <span class="m">1</span> （25% loss）。
<span class="k">Approximate</span> round trip times in milli-seconds：Minimum <span class="m">368</span>ms， Maximum <span class="m">374</span>ns， Average <span class="m">372</span>ns
</code></pre></div></div> <p><em>图 4-29 用 PING 测试主机的连通性</em></p> <p>另一个非常有用的应用是 traceroute（这是 UNIX 操作系统中名字），它用来跟踪一个分 组从源点到终点的路径。在 Windows 操作系统中这个命令是 tracert。下面简单介绍这个程 序的工作原理。 Traceroute 从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的 UDP 用户数据报。第一个数据报 Pı 的生存时间 TTL 设置为 1。当 Pı 到达路径上的第一个 路由器 Rı 时，路由器R， 先收下它，接着把 TTL 的值减 1。由于 TTL 等于零了，Rı 就把 Pı 丢弃了，并向源主机发送一个 ICMP 时间超过差错报告报文。 源主机接着发送第二个数据报P2，并把 TTL 设置为2。P，先到达路由器Rı，Rı 收下后 把 TTL 减 1 再转发给路由器R2R2 收到 P2时 TTL 为1，但减1 后 TTL 变为零了。R，就丢 弃 P2，并向源主机发送一个 ICMP时间超过差错报告报文。这样一直继续下去。当最后一 个数据报刚刚到达目的主机时，数据报的TTL 是 1。主机不转发数据报，也不把 TTL 值减 1。但因 IP 数据报中封装的是无法交付的运输层的 UDP 用户数据报，因此目的主机要向源 主机发送 ICMP 终点不可达差错报告报文（见下一章的5。2。2节）。 这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的 ICMP 报文正 好给出了源主机想知道的路由信息——到达目的主机所经过的路由器的IP地址，以及到达 其中的每一个路由器的往返时间。图 4-30 是从南京的一个 PC 向新浪网的邮件服务器 mail。sina。com。cn 发出的 tracert 命令后所获得的结果。图中每一行有三个时间出现，是因为 对应于每一个 TTL 值，源主机要发送三次同样的 IP 数据报。 我们还应注意到，从原则上讲，IP 数据报经过的路由器越多，所花费的时间也会越 多。但从图 4-30 可看出，有时正好相反。这是因为互联网的拥塞程度随时都在变化，也很 难预料到。因此，完全有这样的可能：经过更多的路由器反而花费更少的时间。</p> <div class="language-ssh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">IC</span>：<span class="err">\</span>Documents and Settings<span class="err">\</span><span class="m">22</span>R&gt;tracert nail.sina.com.cn
<span class="k">Tracing</span> route to nail.sina.com.cn [202.188.43.230]
<span class="k">over</span> maximum of <span class="m">30</span> hops：
<span class="k">1</span> <span class="m">24</span>ms <span class="m">24</span>ms <span class="m">23</span>ms <span class="m">222</span>.95.172.1
<span class="k">2</span> <span class="m">23</span>ms <span class="m">24</span>ms <span class="m">22</span>ms <span class="m">221</span>.231.204.129
<span class="k">3</span> <span class="m">23</span>ms <span class="m">22</span>ms <span class="m">23</span>ms <span class="m">221</span>.231.206.9
<span class="k">4</span> <span class="m">24</span>ms <span class="m">23</span>ms <span class="m">24</span>ms <span class="m">202</span>.97.27.37
<span class="k">5</span> <span class="m">22</span>ms <span class="m">23</span>ms <span class="m">24</span>ns <span class="m">202</span>.97.41.226
<span class="k">6</span> <span class="m">28</span>ns <span class="m">28</span>ms <span class="m">28</span>ms <span class="m">202</span>.97.35.25
<span class="k">7</span> <span class="m">50</span>ns <span class="m">50</span>ms <span class="m">51</span>ms <span class="m">202</span>.97.36.86
<span class="k">8</span> <span class="m">308</span>ms <span class="m">311</span>ms <span class="m">310</span>ms <span class="m">219</span>.158.32.1
<span class="k">9</span> <span class="m">387</span>ns <span class="m">305</span>ms <span class="m">385</span>ns <span class="m">219</span>.158.13.17
<span class="k">10</span> <span class="m">164</span>ms <span class="m">164</span>ms <span class="m">165</span>ms <span class="m">202</span>.96.12.154
<span class="k">11</span> <span class="m">322</span>ms <span class="m">320</span>ms <span class="m">2988</span>ms <span class="m">61</span>.135.148.50
<span class="k">12</span> <span class="m">321</span>ms <span class="m">322</span>ms <span class="m">320</span>ms freenai143-230.sina.com [202.108.43.230]
<span class="k">Trace</span> conplete。
</code></pre></div></div> <p><em>图 4-30 用 tracert 命令获得到目的主机的路由信息</em></p> <h2 id="五互联网的路由选择协议">五、互联网的路由选择协议</h2> <p>本节将讨论几种常用的路由选择协议，也就是要讨论路由表中的路由是怎样得出的。</p> <h3 id="51-有关路由选择协议的几个基本概念">5.1 有关路由选择协议的几个基本概念</h3> <h4 id="1理想的路由算法">（1）理想的路由算法</h4> <p>路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点[BELL86]：</p> <ol> <li><strong>算法必须是正确的和完整的</strong>。这里，“正确”的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li> <li><strong>算法在计算上应简单</strong>。路由选择的计算不应使网络通信量增加太多的额外开销。</li> <li><strong>算法应能适应通信量和网络拓扑的变化</strong>，这就是说，要有<strong>自适应性</strong>。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“<strong>稳健性</strong>”（robustness）。</li> <li><strong>算法应具有稳定性</strong>。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li> <li><strong>算法应是公平的</strong>。路由选择算法应对所有用户（除对少数优先级高的用户）都是平等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就明显地不符合公平性的要求。</li> <li><strong>算法应是最佳的</strong>。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到“最佳”的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，<strong>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已</strong>。</li> </ol> <p>一个实际的路由选择算法，应尽可能接近于理想的算法。在不同的应用条件下，对以上提出的六个方面也可有不同的侧重。</p> <p>倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即<strong>静态路由选择策略</strong>与<strong>动态路由选择策略</strong>。</p> <ul> <li>静态路由选择也叫做<strong>非自适应路由选择</strong>，其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li> <li>动态路由选择也叫做<strong>自适应路由选择</strong>，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。</li> </ul> <h4 id="2分层次的路由选择协议">（2）分层次的路由选择协议</h4> <p>互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。由于以下两个原因，互联网采用分层次的路由选择协议：</p> <ol> <li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li> <li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。</li> </ol> <p>为此，可以把整个互联网划分为许多较小的<strong>自治系统</strong>（autonomous system），一般都记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是一个<strong>单一的和一致的路由选择策略</strong>[RFC 4271]。</p> <p>在目前的互联网中，一个大的 ISP 就是一个自治系统。这样，互联网就把路由选择协议划分为两大类，即：</p> <ol> <li><strong>内部网关协议</strong> IGP（Interior Gateway Protocol）：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li> <li><strong>外部网关协议</strong> EGP（External Gateway Protocol）：若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4（BGP-4）。</li> </ol> <p>自治系统之间的路由选择也叫做<strong>域间路由选择</strong>（interdomain routing），而在自治系统内部的路由选择叫做<strong>域内路由选择</strong>（intradomain routing）。</p> <p>图 4-31 是两个自治系统互连在一起的示意图。每个自治系统自己决定在本自治系统内部运行哪个内部路由选择协议（例如，可以是 RIP，也可以是 OSPF）。但每个自治系统都有一个或多个路由器（图中的路由器 $R_1$ 和 $R_2$）除运行本系统的内部路由选择协议外，还要运行自治系统间的路由选择协议（BGP-4）。</p> <p><img src="/assets/images/computer-network/autonomous-system-and-interior-gateway-protocol-and-external-gateway-protocol.png" alt="自治系统和内部网关协议、外部网关协议"/> <em>图 4-31 自治系统和内部网关协议、外部网关协议</em></p> <p>总之，使用分层次的路由选择方法，可将互联网的路由选择协议划分为：</p> <ul> <li><strong>内部网关协议</strong> IGP：具体的协议有多种，如 RIP 和 OSPF 等。</li> <li><strong>外部网关协议</strong> EGP：目前使用的协议就是 BGP。</li> </ul> <p>对于比较大的自治系统，还可将所有的网络再进行一次划分。例如，可以构筑一个链路速率较高的主干网和许多速率较低的区域网。每个区域网通过路由器连接到主干网。当在一个区域内找不到目的站时，就通过路由器经过主干网到达另一个区域网，或者通过外部路由器到别的自治系统中去查找。</p> <h4 id="52-内部网关协议-rip">5.2 内部网关协议 RIP</h4> <p>1。工作原理 RIP （Routing Information Protocol）是内部网关协议IGP 中最先得到广泛使用的协议[RFC 1058]，它的中文名称叫做路由信息协议，但很少被使用。RIP 是一种分布式的基于距离向 量的路由选择协议，是互联网的标准协议，其最大优点就是简单。 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记 录（因此，这是一组距离，即“距离向量”）。RIP 协议将“距离”定义如下： 从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离 定义为所经过的路由器数加1。“加1”是因为到达目的网络后就进行直接交付，而到直接连 接的网络的距离已经定义为 1。例如在前面讲过的图 4-16 中，路由器R， 到网或网 2 的距</p> <p>离都是1（直接连接），而到网3的距离是2，到网4的距离是3。 RIP 协议的“距离”也称为“跳数”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多 只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型 互联网。 需要注意的是，到直接连接的网络的距离也可定义为0（采用这种定义的理由是：路由 器在和直接连接在该网络上的主机通信时，不需要经过另外的路由器。既然每经过一个路由 器要将距离加 1，那么不再经过路由器的距离就应当为0）。作者编写的其他版本的教材过去 也曾使用过这种定义。但两种不同的定义对实现 RIP 协议并无影响，因为重要的是要找出 最短距离，将所有的距离都加1或都减1，对选择最佳路由其实是一样的。 RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由（即 最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。 本节讨论的 RIP 协议和下一节要讨论的OSPF协议，都是分布式路由选择协议。它们的 共同特点就是每一个路由器都要不断地和其他一些路由器交换路由信息。我们一定要弄清以 下三个要点，即和哪些路由器交换信息？交换什么信息？在什么时候交换信息？ RIP 协议的特点是： （1）仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器， 那么这两个路由器就是相邻的。RIP协议规定，不相邻的路由器不交换信息。 （2） 路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。也就 是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到每个网络应经 过的下一跳路由器”。 （3）按固定的时间间隔交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由 信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路 由信息。 这里要强调一点：路由器在刚刚开始工作时，它的路由表是空的。然后路由器就得出 到直接相连的几个网络的距离（这些距离定义为 1）。接着，每一个路由器也只和数目非常 有限的相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知 道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 看起来 RIP 协议有些奇怪，因为“我的路由表中的信息要依赖于你的，而你的信息又 依赖于我的。”然而事实证明，通过这样的方式——“我告诉别人一些信息，而别人又告诉 我一些信息。我再把我知道的更新后的信息告诉别人，别人也这样把更新后的信息再告诉 我”，最后在自治系统中所有的结点都得到了正确的路由选择信息。在一般情况下，RIP 协 议可以收敛，并且过程也较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选 择信息的过程。 路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳 地址。路由表更新的原则是找出到每个目的网络的最短距离。这种更新算法又称为距离向量 算法。下面就是 RIP 协议使用的距离向量算法。</p> <p>2。距离向量算法 对每一个相邻路由器发送过来的RIP报文，进行以下步骤： （1） 对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一 跳”字段中的地址都改为X，并把所有的“距离”字段的值加1（见后面的解释1）。每一个 项目都有三个关键数据，即：到目的网络N，距离是d，下一跳路由器是X。 （2）对修改后的RIP报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络N，则把该项目添加到路由表中（见解释2）。 否则（即在路由表中有目的网络N，这时就再查看下一跳路由器地址） 若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目（见解释3）。 否则（即这个项目是：到目的网络，但下一跳路由器不是X） 若收到的项目中的距离d小于路由表中的距离，则进行更新（见解释4）， 否则什么也不做。（见解释5） （3） 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路 由器，即把距离置为16（距离为16表示不可达）。 （4） 返回。 上面给出的距离向量算法的基础就是 Bellman-Ford 算法（或Ford-Fulkerson 算法）。这 种算法的要点是这样的： 设 X 是结点 A到B的最短路径上的一个结点。若把路径A→B拆成两段路径A→X 和 X→B，则每一段路径A→X和X→B也都分别是结点A到X和结点X到B的最短路径。 下面是对上述距离向量算法的五点解释。 解释：这样做是为了便于进行本路由表的更新。假设从位于地址X的相邻路由器发来 的 RIP 报文的某一个项目是：“Net2， 3， Y”，意思是“我经过路由器Y到网络 Net2 的距离是 3”，那么本路由器就可推断出：“我经过X到网络Net2的距离应为3+1=4”。于是，本路 由器就把收到的 RIP报文的这一个项目修改为“Net2， 4， X”，作为下一步和路由表中原有项 目进行比较时使用（只有比较后才能知道是否需要更新）。读者可注意到，收到的项目中的 Y对本路由器是没有用的，因为Y不是本路由器的下一跳路由器地址。 解释 2： 表明这是新的目的网络，应当加入到路由表中。例如，本路由表中没有到目的 网络 Net2 的路由，那么在路由表中就要加入新的项目“Net2， 4， X”。 解释 3：为什么要替换呢？因为这是最新的消息，要以最新的消息为准。到目的网络的 距离有可能增大或减小，但也可能没有改变。例如，不管原来路由表中的项目是“Net2， 3， X”还是“Net2，5，X”，都要更新为现在的“Net2， 4， X”。 解释4：例如，若路由表中已有项目“Net2， 5， P”，就要更新为“Net2， 4， X”。因为到网 络 Net2 的距离原来是5，现在减到4，更短了。 解释5： 若距离更大了，显然不应更新。若距离不变，更新后得不到好处，因此也不更新。 【例4-5】已知路由器R6有表4-9（a）所示的路由表。现在收到相邻路由器R4发来的路 由更新信息，如表4-9（b）所示。试更新路由器R6的路由表。</p> <p>表4-9（a） 路由器 Rs 的路由表 目的网络 Net2 距离 3 下一跳路由器 R4 Net3 4 Rs 。。。 表4-9（b） R4发来的路由更新信息 目的网络 Netl 距离 3 Net2 4 Net3 下一跳路由器 R₁ R2 1 直接交付 【解】 如同路由器一样，我们不需要知道该网络的拓扑。 先把表4-9（b）中的距离都加1，并把下一跳路由器都改为R4。得出表4-9（c）。 表4-9（c） 修改后的表4-9（b） 目的网络 距离 下一跳路由器 Netl 4 R4 Net2 5 R4 Net3 2 R4 把这个表的每一行和表4-9（a）进行比较。 第一行在表4-9（a）中没有，因此要把这一行添加到表4-9（a）中。 第二行的 Net2 在表4-9（a）中有，且下一跳路由器也是 R4。因此要更新（距离增大了）。 第三行的 Net3 在表4-9（a）中有，但下一跳路由器不同。于是就要比较距离。新的路由 信息的距离是2，小于原来表中的4，因此要更新。 这样，得出更新后的R的路由表如表4-9（d）所示。 表4-9（d） 路由器R6更新后的路由表 目的网络 距离 下一跳路由器 Net1 4 R4 Net2 5 R4 Net3 2 R4 RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并 不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最 少）。这里还应注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由 于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p> <p>3。 RIP 协议的报文格式 现在较新的 RIP 版本是1998年11 月公布的 RIP2 [RFC2453]（已成为互联网标准），新 版本协议本身并无多大变化，但性能上有些改进。RIP2 可以支持变长子网掩码和无分类域 间路由选择 CIDR。此外，RIP2还提供简单的鉴别过程支持多播。 图 4-32 是 RIP2 的报文格式，它和RIP1 的首部相同，但后面的路由部分不一样。从图 4-32 还可看出，RIP 协议使用运输层的用户数据报 UDP 进行传送（使用 UDP 的端口 520。 端口的意义见 5。2。2节）。 4 字节 命令 版本 必为0 4 字节 地址标识符 路由标记 网络地址 路由信息 子网掩码 下一跳路由器地址 （20字节/路由） 可重复出现 最多 25 个 首部 路由部分 距离（1-16） IP UDP 首部 首部 RIP报文 UDP 用户数据报 IP数据报 图4-32RIP2的报文格式 RIP 报文由首部和路由部分组成。 RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1表示请求路由信 息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为 0”是为了4字节字的对齐。 RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址 族标识符（又称为地址类别）字段用来标志所使用的地址协议。如采用 IP 地址就令这个字 段的值为2（原来考虑RIP也可用于其他非 TCP/IP 协议的情况）。路由标记填入自治系统号 ASN （Autonomous System Number），这是考虑使RIP 有可能收到本自治系统以外的路由选 择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的 距离。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是4+20× 25 = 504 字节。如超过，必须再用一个RIP报文来传送。 RIP2 还具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息（20 字 节）的位置用作鉴别。这时应将地址族标识符置为全1（即0xFFFF），而路由标记写入鉴别 类型，剩下的 16字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放 入24个路由信息。</p> <p>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所 有的路由器。我们可以用图 4-33 的简单例子来说明。设三个网络通过两个路由器互连起 来，并且都已建立了各自的路由表。图中路由器交换的信息只给出了我们感兴趣的一行内 容。路由器 Rı 中的“1， 1， 直接”表示“到网1的距离是1，直接交付”。路由器 R№ 中的“1， 2， Rı”表示“到网1的距离是2，下一跳经过 Rı”。 现在假定路由器 R， 到网 1 的链路出了故障，Rı 无法到达网 1。于是路由器 Rı 把到网 1 的距离改为 16（表示到网 1 不可达），因而在 Rı的路由表中的相应项目变为“1，16，直 接”。但是，很可能要经过30秒钟后，才把更新信息发送给R2。然而R，可能已经先把自 己的路由表发送给了R，其中有“1， 2， Rı”这一项。 | 1，1，直接 1， 2， R₁ 正常情况 网1 网2 网了 R₁ R₂ 网1出故障 网 2 网了 R2 R₁ 1，16，直接 1， 2， R₁ 1， 3， R， 1，4， R₁ 1， 5， R， D ： 1， 16， R， → 1， 16， R₁ 图4-33 RIP协议的缺点：坏消息传播得慢 Rı 收到 R2 的更新报文后，误认为可经过R，到达网1，于是把收到的路由信息“1，2， Rı”修改为：“1， 3， Rı”，表明“我到网1的距离是 3，下一跳经过R”，并把更新后的信息 发送给 R2。 同理，R，接着又更新自己的路由表为“1， 4， Rı”，以为“我到网 1 距离是 4，下一跳经 过 Rı”。 这样的更新一直继续下去，直到 R 和R2 到网 1的距离都增大到16时，R 和R2 才知道 原来网1是不可达的。RIP 协议的这一特点叫做：好消息传播得快，而坏消息传播得慢。网 络出故障的传播时间往往需要较长的时间（例如数分钟）。这是RIP 的一个主要缺点。 但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。 为了使坏消息传播得更快些，可以采取多种措施。例如，让路由器记录收到某特定路 由信息的接口，而不让同一路由信息再通过此接口向反方向传送。 总之，RIP 协议最大的优点就是实现简单，开销较小。但 RIP 协议的缺点也较多。首 先，RIP 限制了网络的规模，它能使用的最大距离为15（16表示不可达）。其次，路由器之 间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最 后，“坏消息传播得慢，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使 用下一节所述的 OSPF 协议。然而目前在规模较小的网络中，使用 RIP 协议的仍占多数。</p> <p>4。5。3 内部网关协议 OSPF 1。 OSPF 协议的基本特点 这个协议的名字是开放最短路径优先 OSPF （Open Shortest Path First）。它是为克服 RIP 的缺点在 1989年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 的第二个版本OSPF2 已成为互联网标准协议 [RFC 2328]。关于OSPF 可参阅专著[MOY98]，[HUIT95]。 请注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径 优先”。实际上，所有的在自治系统内部使用的路由选择协议（包括RIP 协议）都是要寻找 一条最短的路径。 OSPF 最主要的特征就是使用分布式的链路状态协议（link state protocol），而不是像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样： （1）向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法（flooding），这就是 路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息 发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区 域中所有的路由器都得到了这个信息的一个副本。更具体的做法后面还要讨论。我们应注 意，RIP 协议是仅仅向自己相邻的几个路由器发送信息。 （2） 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道 的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的 “度量”（metric）。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都 由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。我们应注 意，对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。 （3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。 从上述的三个方面可以看出，OSPF 和 RIP 的工作原理相差较大。 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链 路状态数据库（link-state database），这个数据库实际上就是全网的拓扑结构图。这个拓扑结 构图在全网范围内是一致的（这称为链路状态数据库的同步）。因此，每一个路由器都知道 全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使 用链路状态数据库中的数据，构造出自己的路由表（例如，使用 Dijkstra 的最短路径路由算 法）。我们注意到，RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由 器，但却不知道全网的拓扑结构（只有到了下一跳路由器，才能知道再下一跳应当怎样 走）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。 OSPF 的更新过程收敛得快是其重要优点。</p> <p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的 范围，叫做区域（area）。图4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。当然，一个区域也不能太大，在一个区域内的路 由器最好不超过200个。 至其他自治系统 自治系统 AS 主干区域 0。0。0。0 R， R6 网6。 R&gt; Rs 网13 7 网23 R2 网43 网83 XX3 5 区域 0。0。0。3 区域0。0。0。1 区域0。0。0。2 图4-34 OSPF划分为两种不同的区域 划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是 整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域 的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以 外的区域进行通信，OSPF 使用层次结构的区域划分。在上层的区域叫做主干区域（backbone area）。主干区域的标识符规定为0。0。0。0。主干区域的作用是用来连通其他在下层的区域。从 其他区域来的信息都由区域边界路由器（area border router）进行概括。在图4-34 中，路由器 R3，R4 和R，都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。 在主干区域内的路由器叫做主干路由器（backbone router），如 R3，R4，Rs，R6 和R7。一个主 干路由器可以同时是区域边界路由器，如R3，R4 和R7。在主干区域内还要有一个路由器专 门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做自治系统边界路由器 （如图中的R。）。 采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复 杂了。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议 能够用于规模很大的自治系统中。这里，我们再一次地看到划分层次在网络设计中的重要 性。 OSPF 不用 UDP 而是直接用 IP 数据报传送（其IP数据报首部的协议字段值为89）。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以 不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据 报，而整个数据报就必须重传。 OSPF 分组使用24字节的固定长度首部（见图4-35），分组的数据部分可以是五种类型 分组中的一种。下面简单介绍 OSPF 首部各字段的意义。 （1） 版本 当前的版本号是2。 （2） 类型 可以是五种类型分组中的一种。 （3）分组长度 包括 OSPF 首部在内的分组长度，以字节为单位。 （4）路由器标识符 标志发送该分组的路由器的接口的 IP 地址。</p> <p>（5） 区域标识符 分组属于的区域的标识符。 （6） 检验和 用来检测分组中的差错。 （7） 鉴别类型 目前只有两种，0（不用）和1（口令）。 （8） 鉴别 鉴别类型为0时就填入0，鉴别类型为1则填入8个字符的口令。 位 0 8 16 31 版本 类型 分组长度 路由器标识符 区域标识符 检验和 鉴别类型 鉴 别 鉴 别 -24字节- OSPF 分组首部 类型1至类型5 的OSPF 分组 IP数据报首部一 OSPF 分组 IP数据报 图4-35 OSPF分组用IP数据报传送 除了以上的几个基本特点外，OSPF 还具有下列的一些特点： （1） OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实 时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此， OSPF 对于不同类型的业务可计算出不同的路由。链路的代价可以是1至65535中的任何一 个无量纲的数，因此十分灵活。商用的网络在使用OSPF时，通常根据链路带宽来计算链路 的代价。这种灵活性是RIP所没有的。 （2） 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路 径。这叫做多路径间的负载平衡（load balancing）。在代价相同的多条路径上分配通信量是 通信量工程中的简单形式。RIP只能找出到某个网络的一条路径。 （3） 所有在 OSPF 路由器之间交换的分组（例如，链路状态更新分组）都具有鉴别的功 能，因而保证了仅在可信赖的路由器之间交换链路状态信息。 （4） OSPF 支持可变长度的子网划分和无分类的编址 CIDR。 （5） 由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一 个 32 位的序号，序号越大状态就越新。OSPF规定，链路状态序号增长的速率不得超过每5 秒钟1次。这样，全部序号空间在600年内不会产生重复号。 2。 OSPF 的五种分组类型 OSPF 共有以下五种分组类型： （1） 类型 1，问候（Hello）分组，用来发现和维持邻站的可达性。 （2） 类型 2，数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库 中的所有链路状态项目的摘要信息。 （3） 类型 3，链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目 的详细信息。 （4）类型 4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。这 种分组是最复杂的，也是OSPF协议最核心的部分。路由器使用这种分组将其链路状态通知 给邻站。链路状态更新分组共有五种不同的链路状态[RFC2328]，这里从略。 （5） 类型 5，链路状态确认（Link State Acknowledgment）分组，对链路更新分组的确认。 OSPF 规定，每两个相邻路由器每隔10秒钟要交换一次问候分组。这样就能确知哪些 邻站是可达的。对相邻路由器来说，“可达”是最基本的要求，因为只有可达邻站的链路状 态信息才存入链路状态数据库（路由表就是根据链路状态数据库计算出来的）。在正常情况 下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由 器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重 新计算路由表。 其他的四种分组都是用来进行链路状态数据库的同步。所谓同步就是指不同路由器的 链路状态数据库的内容是一样的。两个同步的路由器叫做“完全邻接的”（fully adjacent）路 由器。不是完全邻接的路由器表明它们虽然在物理上是相邻的，但其链路状态数据库并没有 达到一致。 当一个路由器刚开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工 作，以及将数据发往相邻路由器所需的“代价”。如果所有的路由器都把自己的本地链路状 态信息对全网进行广播，那么各路由器只要将这些链路状态信息综合起来就可得出链路状态 数据库。但这样做开销太大，因此 OSPF 采用下面的办法。 OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态 摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了 数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对 方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网 同步的链路数据库就建立了。图 4-36 给出了OSPF 的基本操作，说明了两个路由器需要交 换各种类型的分组。 问候 确定可达性 达到数据库的同步 问候 数据库描述 数据库描述 数据库描述 数据库描述 新情况下的同步 链路状态请求 链路状态更新 链路状态确认 图4-36 OSPF 的基本操作 在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路 状态更新分组，用洪泛法向全网更新链路状态。OSPF 使用的是可靠的洪泛法，其要点见图 4-37 所示。设路由器R 用洪泛法发出链路状态更新分组。图中用一些小的箭头表示更新分 组。第一次先发给相邻的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上 游路由器除外。可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要 发送一次确认）。图中的空心箭头表示确认分组。 更新报文 R R R ACK报文 R 图4-37 用可靠的洪泛法发送更新分组 为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规 模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。由于 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于100 ms。 若 N 个路由器连接在一个以太网上，则每个路由器要向其他（N - 1）个路由器发送链路 状态信息，因而共有 N（N-1）个链路状态要在这个以太网上传送。OSPF 协议对这种多点接 入的局域网采用了指定的路由器（designated router）的方法，使广播的信息量大大减少。指定 的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。 4。5。4 外部网关协议 BGP 1989 年，公布了新的外部网关协议——边界网关协议 BGP。为简单起见，后面我们把 目前使用最多的版本 BGP-4 经常简写为 BGP。最近已经陆续发布了一些 BGP-4 的更新文 档，但目前 BGP-4仍然是草案标准[RFC 4271]。 我们首先应当弄清，在不同自治系统 AS 之间的路由选择为什么不能使用前面讨论过的 内部网关协议，如 RIP 或OSPF？ 我们知道，内部网关协议（如RIP 或OSPF）主要是设法使数据报在一个AS中尽可能 有效地从源站传送到目的站。在一个AS 内部也不需要考虑其他方面的策略。然而 BGP 使 用的环境却不同。这主要是因为以下的两个原因： 第一，互联网的规模太大，使得自治系统 AS 之间路由选择非常困难。连接在互联网主 干网上的路由器，必须对任何有效的IP 地址都能在路由表中找到匹配的目的网络。目前在 互联网的主干网路由器中，一个路由表的项目数早已超过了5万个网络前缀。如果使用链路 状态协议，则每一个路由器必须维持一个很大的链路状态数据库。对于这样大的主干网用 Dijkstra算法计算最短路径时花费的时间也太长。另外，由于自治系统 AS 各自运行自己选 定的内部路由选择协议，并使用本AS 指明的路径度量，因此，当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。例如，对某AS 来说，代价 为1000可能表示一条比较长的路由。但对另一AS代价为1000却可能表示不可接受的坏路 由。因此，对于自治系统 AS之间的路由选择，要用“代价”作为度量来寻找最佳路由也是 很不现实的。比较合理的做法是在自治系统之间交换“可达性”信息（即“可到达”或“不 可到达”）。例如，告诉相邻路由器：“到达目的网络N可经过自治系统 ASx”。 第二，自治系统 AS 之间的路由选择必须考虑有关策略。由于相互连接的网络的性能相 差很大，根据最短距离（即最少跳数）找出来的路径，可能并不合适。也有的路径的使用代 价很高或很不安全。还有一种情况，如自治系统 AS要发送数据报给自治系统 ASz，本来最 好是经过自治系统 AS3。但 AS， 不愿意让这些数据报通过本自治系统的网络，因为“这是他 们的事情，和我们没有关系。”但另一方面，自治系统 AS，愿意让某些相邻自治系统的数据 报通过自己的网络，特别是对那些付了服务费的某些自治系统更是如此。因此，自治系统之 间的路由选择协议应当允许使用多种路由选择策略。这些策略包括政治、安全或经济方面的 考虑。例如，我国国内的站点在互相传送数据报时不应经过国外兜圈子，特别是，不要经过 某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置 的，但这些策略并不是自治系统之间的路由选择协议本身。还可举出一些策略的例子，如： “仅在到达下列这些地址时才经过ASx”，“AS和AS， 相比时应优先通过 ASx”，等等。显 然，使用这些策略是为了找出较好的路径而不是最佳路径。 由于上述情况，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的 路由（不能兜圈子），而并非要寻找一条最佳路由。BGP 采用了路径向量（path vector）路由选 择协议，它与距离向量协议（如RIP）和链路状态协议（如OSPF）都有很大的区别。 在配置 BGP 时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 “BGP 发言人”。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是BGP边界路由器，但也可以不是BGP 边界路由器。 一个 BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息，就要先建立TCP 连接 （端口号为 179），然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会 话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使 用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两 个 BGP 发言人，彼此成为对方的邻站（neighbor）或对等站（peer）。 图 4-38 表示 BGP 发言人和自治系统 AS的关系的示意图。在图中画出了三个自治系统 中的 5 个 BGP 发言人。每一个 BGP 发言人除了必须运行 BGP 协议外，还必须运行该自治 系统所使用的内部网关协议，如 OSPF 或 RIP。 BGP BGP ASı 发言人 发言人 AS2 BGP 发言人 BGP 发言人 AS3 BGP 发言人 AS4 AS5 图4-38 BGP发言人和自治系统 AS的关系 边界网关协议 BGP所交换的网络可达性的信息就是要到达某个网络（用网络前缀表 示）所要经过的一系列自治系统。当BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。图 4-39 表示从图 4-38 的 AS 上的一个 BGP 发言人构造出的自治系统连通图，它是树形结构，不存 在回路。 AS， AS， AS AS ASF 图4-39 自治系统AS的连通图举例 在第 1 章的 1。2。2 节我们已经介绍了当前互联网的多级结构特点（图1-4）。这种多级结 构的网络拓扑决定了BGP路由选择协议的特点。 图 4-40 给出了一个 BGP 发言人交换路径向量的例子。自治系统 AS2 的BGP 发言人通 知主干网的 BGP 发言人：“要到达网络 Nı，N2，N3 N4可经过ASz。”主干网在收到这个通 知后，就发出通知：“要到达网络 Nı， N2， N3 和 N4 可沿路径（ASı，ASz）。”同理，主干网还 可发出通知：“要到达网络 Ns， N｡ 和N，可沿路径（ASı， AS3）。” 地区 ISP （ASz） 本地ISP（AS） N，N2 主干网 （AS） 本地ISP（AS） N3， N4 本地ISP（AS） Ns 地区 ISP （AS3） 本地 ISP（AS） No，N7 图4-40 BGP发言人交换路径向量的例子 从上面的讨论可看出，BGP 协议交换路由信息的结点数量级是自治系统个数量级， 这要比这些自治系统中的网络数少很多。要在许多自治系统之间寻找一条较好的路径，就是</p> <p>要寻找正确的 BGP 发言人（或边界路由器），而在每一个自治系统中 BGP 发言人（或边界 路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。 BGP 支持无分类域间路由选择 CIDR，因此 BGP 的路由表也就应当包括目的网络前 缀、下一跳路由器，以及到达该目的网络所要经过的自治系统序列。由于使用了路径向量的 信息，就可以很容易地避免产生兜圈子的路由。如果一个BGP 发言人收到了其他 BGP 发言 人发来的路径通知，它就要检查一下本自治系统是否在此通知的路径中。如果在这条路径 中，就不能采用这条路径（因为会兜圈子）。 在 BGP 刚刚运行时，BGP 的邻站是交换整个的BGP路由表。但以后只需要在发生变 化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。 在 RFC 4271 中规定了BGP-4 的四种报文： （1） OPEN（打开）报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。 （2）UPDATE（更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由。 （3）KEEPALIVE（保活）报文，用来周期性地证实邻站的连通性。 （4）NOTIFICATION（通知）报文，用来发送检测到的差错。 若两个邻站属于两个不同 AS，而其中一个邻站打算和另一个邻站定期地交换路由信 息，这就应当有一个商谈的过程（因为很可能对方路由器的负荷已很重因而不愿意再加重负 担）。因此，一开始向邻站进行商谈时就必须发送 OPEN 报文。如果邻站接受这种邻站关 系，就用 KEEPALIVE 报文响应。这样，两个 BGP 发言人的邻站关系就建立了。 一旦邻站关系建立了，就要继续维持这种关系。双方中的每一方都需要确信对方是存 在的，且一直在保持这种邻站关系。为此，这两个 BGP 发言人彼此要周期性地交换 KEEPALIVE 报文（一般每隔30秒）。KEEPALIVE 报文只有 19 字节长（只用 BGP 报文的 通用首部），因此不会造成网络上太大的开销。 UPDATE 报文是BGP 协议的核心内容。BGP 发言人可以用UPDATE 报文撤销它以前 曾经通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路 由时，每个更新报文只能增加一条。 BGP 可以很容易地解决距离向量路由选择算法中的“坏消息传播得慢”这一问题。当 某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很 容易选择出新的路由。距离向量算法往往不能给出正确的选择，是因为这些算法不能指出哪 些邻站到目的站的路由是独立的。 图 4-41 给出了 BGP报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度 为 19 字节。通用首部分为三个字段。标记（marker）字段为16字节长，用来鉴别收到的 BGP 报文（这是假定将来有人会发明出合理的鉴别方案）。当不使用鉴别时，标记字段要置为全 1。长度字段指出包括通用首部在内的整个 BGP报文以字节为单位的长度，最小值是 19， 最大值是 4096。类型字段的值为1到4，分别对应于上述四种 BGP报文中的一种。 OPEN 报文共有6个字段，即版本（1字节，现在的值是4）、本自治系统号（2 字节， 使用全球唯一的16 位自治系统号，由ICANN 地区登记机构分配）、保持时间（2 字节，以 秒计算的保持为邻站关系的时间）、BGP 标识符（4字节，通常就是该路由器的IP 地址）、 可选参数长度（1字节）和可选参数。</p> <p>字节 16 2 1 H 标 记 长度 类型 BGP报文通用首部 BGP报文主体部分 | TCP 首部 BGP 报文 IP 首部 TCP报文 图4-41 BGP报文具有通用的首部 UPDATE 报文共有5个字段，即不可行路由长度（2字节，指明下一个字段的长度）、 撤销的路由（列出所有要撤销的路由）、路径属性总长度（2 字节，指明下一个字段的长 度）、路径属性（定义在这个报文中增加的路径的属性）和网络层可达性信息 NLRI （Network Layer Reachability Information）。最后这个字段定义发出此报文的网络，包括网络 前缀的位数、IP 地址前缀。 KEEPALIVE 报文只有BGP的19字节长的通用首部。 NOTIFICATION 报文有3 个字段，即差错代码（1 字节）、差错子代码（1 字节）和差 错数据（给出有关差错的诊断信息）。 在讨论完路由选择之后，我们再来介绍路由器的构成。 4。5。5 路由器的构成 1。路由器的结构 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。 从路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路 由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组， 直到该分组到达终点为止。路由器的转发分组正是网络层的主要工作。图 4-42 给出了一种 典型的路由器的构成框图。 路由选择处理机 路由选择协议 路由选择 路由表 输入端口 输出端口 23元 3 分组处理 转发表 分组转发 输入端口 输出端口 1-2-3 交换结构 3 2 -1 图4-42 典型的路由器的结构（图中的数字1~3表示相应层次的构件） 部分。 从图 4-42 可以看出，整个的路由器结构可划分为两大部分：路由选择部分和分组转发 路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任 务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信 息而不断地更新和维护路由表。关于怎样根据路由选择协议构造和更新路由表，我们已在前 面的4。5。2至4。5。4节讨论过了。 分组转发部分是本节所要讨论的问题，它由三部分组成：交换结构、一组输入端口和 一组输出端口（请注意：这里的端口就是硬件接口）。下面分别讨论每一部分的组成。 交换结构（switching fabric）又称为交换组织，它的作用就是根据转发表（forwarding table） 对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构本 身就是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中 的网络”。 请注意“转发”和“路由选择”是有区别的。在互联网中，“转发”就是路由器根据转 发表把收到的 IP数据报从路由器合适的端口转发出去。“转发”仅仅涉及到一个路由器。但 “路由选择”则涉及到很多路由器，路由表则是许多路由器协同工作的结果。这些路由器按 照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态地改变所选择的路由，并 由此构造出整个的路由表。路由表一般仅包含从目的网络到下一跳（用 IP 地址表示）的映 射，而转发表是从路由表得出的。转发表必须包含完成转发功能所必需的信息。这就是说， 在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC 地址信息（如下一 跳的以太网地址）的映射。将转发表和路由表用不同的数据结构实现会带来一些好处，这是 因为在转发分组时，转发表的结构应当查找过程最优化，但路由表则需要对网络拓扑变化 的计算最优化。路由表总是用软件实现的，但转发表则甚至可用特殊的硬件来实现。请读者 注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，而可以笼统地都使 用路由表这一名词。 在图 4-42 中，路由器的输入和输出端口里面都各有三个方框，用方框中的 1， 2 和 3 分 别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按 照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理 模块。若接收到的分组是路由器之间交换路由信息的分组（如 RIP 或OSPF 分组等），则把 这种分组送交路由器的路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照 分组首部中的目的地址查找转发表，根据得出的结果，分组就经过交换结构到达合适的输出 端口。一个路由器的输入端口和输出端口就做在路由器的线路接口卡上。 输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分 散化，往往把复制的转发表放在每一个输入端口中（如图 4-42 中的虚线箭头所示）。路由选 择处理机负责对各转发表的副本进行更新。这些副本常称为“影子副本”（shadow copy）。分 散化交换可以避免在路由器中的某一点上出现瓶颈。 以上介绍的查找转发表和转发分组的概念虽然并不复杂，但在具体的实现中还是会遇 到不少困难。问题就在于路由器必须以很高的速率转发分组。最理想的情况是输入端口的处 理速率能够跟上线路把分组传送到路由器的速率。这种速率称为线速（line speed 或 wire speed）。可以粗略地估算一下。设线路是OC-48 链路，即 2。5 Gbit/s。若分组长度为256 字 节，那么线速就应当达到每秒能够处理 100 万以上的分组。现在常用 Mpps （百万分组每 秒）为单位来说明一个路由器对收到的分组的处理速率有多高。在路由器的设计中，怎样提 高查找转发表的速率是一个十分重要的研究课题。 当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个 后到的分组就必须在队列中排队等待，因而产生了一定的时延。图4-43 给出了在输入端口 的队列中排队的分组的示意图。 输入端口的处理 网络层处理 分组排队 数据链路层| · 物理层处理 处理 查表和转发 从线路接收分组 交换结构 图4-43 输入端口对线路上收到的分组的处理 我们再来观察在输出端口上的情况（图4-44）。输出端口从交换结构接收分组，然后把 它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上它就是一 个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组 就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给 物理层后发送到外部线路。 交换结构 向线路发送分组 输出端口的处理 网络层处理 分组排队 数据链路层 物理层处理· 处理 缓存管理 图4-44 输出端口把交换结构传送过来的分组发送到线路上 从以上的讨论可以看出，分组在路由器的输入端口和输出端口都可能会在队列中排队 等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少 到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。以前我们提到过的分 组丢失就是发生在路由器中的输入或输出队列产生溢出的时候。当然，设备或线路出故障也 可能使分组丢失。 2。交换结构 交换结构是路由器的关键构件[KURO13]。正是这个交换结构把分组从一个输入端口 转移到某个合适的输出端口。实现这样的交换有多种方法，图4-45 给出了三种常用的交 换方法。这三种方法都是将输入端口 I收到的分组转发到输出端口 Oz。下面简单介绍它 们的特点。 存储器 （a）通过存储器 -0-0-0 总线 （b）通过总线 互连网络 （c）通过互连网络 图4-45 三种常用的交换方法 最早使用的路由器就是利用普通的计算机，用计算机的 CPU 作为路由器的路由选择处 理机。路由器的输入和输出端口的功能和传统的操作系统中的I/O设备一样。当路由器的某 个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复 制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适 的输出端口的缓存中。若存储器的带宽（读或写）为每秒M个分组，那么路由器的交换速 率（即分组从输入端口传送到输出端口的速率）一定小于M/2。这是因为存储器对分组的读 和写需要花费的时间是同一个数量级。 许多现代的路由器也通过存储器进行交换，图4-45（a）的示意图表示分组通过存储器进 行交换。与早期的路由器的区别就是，目的地址的查找和分组在存储器中的缓存都是在输入 端口中进行的。Cisco 公司的 Catalyst 8500 系列交换机（有的公司把路由器也称为交换机） 和 Bay Network 公司的 Accelar 1200系列路由器就采用了共享存储器的方法。 图4-45（b）是通过总线进行交换的示意图。采用这种方式时，数据报从输入端口通过共 享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。但是，由于总线是 共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线 忙（因为总线正在传送另一个分组），则被阻塞而不能通过交换结构，并在输入端口排队等 待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的 限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品 都采用这种通过总线的交换方式。例如，Cisco 公司的 Catalyst 1900系列交换机就使用了带 宽达到 1 Gbit/s 的总线（叫做Packet Exchange Bus）。 图4-45（c）画的是通过纵横交换结构（crossbar switch fabric）进行交换。这种交换机构常称 为互连网络（interconnection network），它有 2N 条总线，可以使 N个输入端口和 N 个输出端 口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收 到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口 的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个 输出端口。但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到 达的分组就被阻塞，必须在输入端口排队。采用这种交换方式的路由器例子是 Cisco 公司的 12000系列交换路由器，它使用的互连网络的带宽达60Gbit/s。</p> <h2 id="六ipv6">六、IPv6</h2> <p>IP 是互联网的核心协议。现在使用的IP（即IPv4）是在20世纪70年代末期设计的。 互联网经过几十年的飞速发展，到2011年2月，IPv4的地址已经耗尽，ISP已经不能再申 请到新的IP 地址块了。我国在2014年至2015年也逐步停止了向新用户和应用分配IPv4地 址，同时全面开始商用部署 IPv6。 解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的IP，即 IPv6。到目 前为止，IPv6 还只是草案标准阶段[RFC2460，4862，4443]。有关向IPv6 转换的进展情况见 有关网站[W-NGTRANS]。 4。6。1 IPv6 的基本首部 IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组，而不是IPv4 的数据 报。为方便起见，本书仍采用数据报这一名词（[COME06]和[TANE11]也是这样做的）。 IPv6 所引进的主要变化如下： （1）更大的地址空间。IPv6 把地址从IPv4 的32 位增大到4倍，即增大到128位，使地 址空间增大了 26倍。这样大的地址空间在可预见的将来是不会用完的。 （2） 扩展的地址层次结构。IPv6 由于地址空间很大，因此可以划分为更多的层次。 （3） 灵活的首部格式。IPv6 数据报的首部和IPv4 的并不兼容。IPv6 定义了许多可选的 扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路 由器对扩展首部不进行处理（除逐跳扩展首部外）。 （4） 改进的选项。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选 项。但 IPv6 的首部长度是固定的，其选项放在有效载荷中。我们知道，IPv4 所规定的选项 是固定不变的，其选项放在首部的可变部分。 （5） 允许协议继续扩充。这一点很重要，因为技术总是在不断地发展（如网络硬件的更 新）而新的应用也还会出现。但我们知道，IPv4 的功能是固定不变的。 （6） 支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。 （7）支持资源的预分配。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。 （8） IPv6 首部改为8字节对齐（即首部长度必须是8字节的整数倍）。原来的IPv4 首部 是4字节对齐。 IPv6 数据报由两大部分组成，即基本首部（base header）和后面的有效载荷（payload）。有 效载荷也称为净负荷。有效载荷允许有零个或多个扩展首部（extension header），再后面是数 据部分（图4-46）。但请注意， 所有的扩展首部并不属于IPv6 数据报的首部。 IPv6 数据报 发送在前 基本首部 有 效 载 荷 40字节 不超过65535字节 扩展 首部1 扩展 首部N 数 据部 分 图4-46 具有多个可选扩展首部的IPv6数据报的一般形式 与 IPv4 相比，IPv6对首部中的某些字段进行了如下的更改： • 取消了首部长度字段，因为它的首部长度是固定的（40字节）。 取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。 • 取消了总长度字段，改用有效载荷长度字段。 • 取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。 • 把 TTL 字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致）。 取消了协议字段，改用下一个首部字段。 取消了检验和字段，这样就加快了路由器处理数据报的速度。我们知道，在数据链 路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的 用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确 传送到目的进程为止。因此在网络层的差错检测可以精简掉。 • 取消了选项字段，而用扩展首部来实现选项功能。 由于把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有8个（虽然首 部长度增大了一倍）。 下面解释 IPv6 基本首部中各字段的作用（参见图4-47）。 IPv6的 位0 4 12 16 24 31 版本 通信量类 流标号 有效载荷长度 下一个首部 跳数限制 基本首部 （40B） IPv6的 有效载荷 （至64KB） 源地址 （128位） 目的地址 （128位） 有效载荷（扩展首部/数据） 图4-47 40字节长的IPv6基本首部 （1） 版本（version） 占4位。它指明了协议的版本，对IPv6 该字段是6。 （2） 通信量类（traffic class） 占8位。这是为了区分不同的IPv6 数据报的类别或优先 级。目前正在进行不同的通信量类性能的实验。 （3） 流标号（flow label） 占 20 位。IPv6的一个新的机制是支持资源预分配，并且允 许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流（flow）的抽象概念。所 谓“流”就是互联网络上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音 频或视频传输），而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属 于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别 有用。对于传统的电子邮件或非实时数据，流标号则没有用处，把它置为0即可。关于流标 号可参考[RFC 6437]。 （4）有效载荷长度（payload length） 占 16 位。它指明IPv6数据报除基本首部以外的字 节数（所有扩展首部都算在有效载荷之内）。这个字段的最大值是64KB（65535字节）。 （5） 下一个首部（next header） 占8位。它相当于IPv4 的协议字段或可选字段。 • 当IPv6 数据报没有扩展首部时，下一个首部字段的作用和IPv4 的协议字段一样， 它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议（例如：6 或17分别表示应交付运输层TCP或UDP）。 当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。 占8位。用来防止数据报在网络中无限期地存在。源点在每 （6） 跳数限制（hop limit） 个数据报发出时即设定某个跳数限制（最大为 255 跳）。每个路由器在转发数据报时，要先 把跳数限制字段中的值减1。当跳数限制的值为零时，就要把这个数据报丢弃。 （7） 源地址 （8） 目的地址 占 128 位。是数据报的发送端的 IP 地址。 占 128 位。是数据报的接收端的 IP 地址。 下面我们介绍一下 IPv6 的扩展首部。 大家知道，IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上 的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。然 而实际上很多的选项在途中的路由器上是不需要检查的（因为不需要使用这些选项的信 息）。IPv6 把原来IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端 的源点和终点的主机来处理，而数据报途中经过的路由器都不处理这些扩展首部（只有一个 首部例外，即逐跳选项扩展首部），这样就大大提高了路由器的处理效率。 在 RFC 2460 中定义了以下六种扩展首部：（1）逐跳选项；（2） 路由选择；（3）分片；（4） 鉴别；（5） 封装安全有效载荷；（6） 目的站选项。 每一个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的第一 个字段都是 8 位的“下一个首部”字段。此字段的值指出了在该扩展首部后面的字段是什 么。当使用多个扩展首部时，应按以上的先后顺序出现。高层首部总是放在最后面。 4。6。2 IPv6 的地址 一般来讲，一个IPv6 数据报的目的地址可以是以下三种基本类型地址之一： （1） 单播（unicast） 单播就是传统的点对点通信。 （2） 多播（multicast） 多播是一点对多点的通信，数据报发送到一组计算机中的每一 个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。 （3） 任播（anycast） 这是 IPv6 增加的一种类型。任播的终点是一组计算机，但数据报 只交付其中的一个，通常是距离最近的一个。 IPv6 把实现 IPv6 的主机和路由器均称为结点。由于一个结点可能会使用多条链路与其 他的一些结点相连，因此一个结点可能有多个与链路相连的接口。这样，IPv6 给结点的每 一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当 到达该结点的目的地址。 在 IPv6 中，每个地址占128位，地址空间大于3。4x108。如果整个地球表面（包括陆 地和水面）都覆盖着计算机，那么IPv6 允许每平方米拥有7x103 个IP地址。如果地址分配 速率是每微秒分配100万个地址，则需要 101°年的时间才能将所有可能的地址分配完毕。 可见在想象到的将来，IPv6的地址空间是不可能用完的。 巨大的地址范围还必须使维护互联网的人易于阅读和操纵这些地址。IPv4 所用的点分 十进制记法现在也不够方便了。例如，一个用点分十进制记法的128位的地址为： 104。230。140。100。255。255。255。255。0。0。17。128。150。10。255。255 为了使地址再稍简洁些，IPv6使用冒号十六进制记法（colon hexadecimal notation，简写 为 colon hex），它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如，如果前 面所给的点分十进制数记法的值改为冒号十六进制记法，就变成了： 68E6：8C64：FFFF：FFFF：0：1180：960A： FFFF 在十六进制记法中，允许把数字前面的0省略。上面就把 0000 中的前三个0省略了。 冒号十六进制记法还包含两个技术使它尤其有用。首先，冒号十六进制记法可以允许 零压缩（zero compression），即一连串连续的零可以为一对冒号所取代，例如： 可压缩为： FF05：0：0：0：0：0：0：B3 FF05：：B3 为了保证零压缩有一个不含混的解释，规定在任一地址中只能使用一次零压缩。该技 术对已建议的分配策略特别有用，因为会有许多地址包含较长连续的零串。 其次，冒号十六进制记法可结合使用点分十进制记法的后缀。我们下面会看到这种结 合在 IPv4 向 IPv6的转换阶段特别有用。例如，下面的串是一个合法的冒号十六进制记法： 0：0：0：0：0：0：128。10。2。1 请注意，在这种记法中，虽然为冒号所分隔的每个值是两个字节（16位）的量，但每个点 分十进制部分的值则指明一个字节（8位）的值。再使用零压缩即可得出： ：： 128。10。2。1 下面再给出几个使用零压缩的例子。 1080：0：0：0：8：800：200C：417A 记为 FF01：0：0：0：0：0：0：101 （多播地址） 记为 0：0：0：0：0：0：0：1（环回地址） 1080：：8：800：200C：417A FF01：：101 记为 ：： 1 记为 ： ： 0：0：0：0：0：0：0：0（未指明地址） CIDR 的斜线表示法仍然可用。例如，60 位的前缀 12AB00000000CD3（十六进制表</p> <p>示的15个字符，每个字符代表4位二进制数字）可记为： 12AB 0000：0000：CD30：0000：0000：0000：0000/60 或12AB：：CD30：0：0：0：0/60 或12AB：0：0：CD30：：/60 （不能把16位地址CD30块中的最后的省略） 但不允许记为： 12AB：0：0：CD3/60 或 12AB：：CD30/60 （这是地址12AB：0：0：0：0：0：0：CD30的前60 位二进制） 或 12AB：：CD3/60 （这是地址12AB：0：0：0：0：0：0：0CD3的前60位二进制） IPv6 的地址分类见表4-10所示[RFC 4291]。 表4-10 IPv6 的地址分类 地址类型 未指明地址 环回地址 多播地址 二进制前缀 00。0 （128位），可记为：：128。 00。。。1 （128位），可记为：1/128。 11111111 （8位），可记为FF00：：/8。 本地链路单播地址 全球单播地址 1111111010 （10位），可记为FE80/10。 （除上述四种外，所有其他的二进制前缀） 对表 4-10 所列举的几种地址简单解释如下。 未指明地址 这是 16 字节的全 0 地址，可缩写为两个冒号“：：”。这个地址不能用 作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的 IP 地址。这类地址仅此一个。 环回地址 IPv6 的环回地址是0：0：0：0：0：0：0：1，可缩写为：：1。 它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。 多播地址 功能和 IPv4 的一样。这类地址占IPv6地址总数的1/256。 本地链路单播地址（Link-Local Unicast Address） 有些单位的网络使用TCP/IP 协议， 但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信， 但不能和互联网上的其他主机通信。这类地址占IPv6地址总数的 1/1024。 全球单播地址 IPv6 的这一类单播地址是使用得最多的一类。曾提出过多种方案来进 一步划分这128位的单播地址。根据2006年发布的草案标准 RFC 4291 的建议， IPv6 单播 地址的划分方法非常灵活，可以如图 4-48 所示的任何一种。这就是说，可把整个的 128 比 特都作为一个结点的地址。也可用n比特作为子网前缀，用剩下的（128-n）比特作为接口标 识符（相当于 IPv4 的主机号）。当然也可以划分为三级，用n比特作为全球路由选择前缀， 用 m 比特作为子网前缀，而用剩下的（128-n-m）比特作为接口标识符。 结点地址（128 bit） 子网前缀（nbit） 接口标识符（128-n）bit 全球路由选择前缀（nbit） 子网标识符（mbit） 接口标识符（128-n-m）bit 图4-48 IPv6的单播地址的几种划分方法</p> <p>4。6。3 从IPv4 向 IPv6 过渡 由于现在整个互联网的规模太大，因此，“规定一个日期，从这一天起所有的路由器一 律都改用IPv6”，显然是不可行的。这样，向IPv6 过渡只能采用逐步演进的办法，同时， 还必须使新安装的IPv6系统能够向后兼容。这就是说，IPv6系统必须能够接收和转发 IPv4 分组，并且能够为IPv4分组选择路由。 下面介绍两种向IPv6 过渡的策略，即使用双协议栈和使用隧道技术[RFC 2473，2529， 3056， 4038， 4213]。 1。双协议栈 双协议栈（dual stack）是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有双 协议栈：一个 IPv4 和一个IPv6。因此双协议栈主机（或路由器）既能够和IPv6的系统通 信，又能够和 IPv4 的系统通信。双协议栈的主机（或路由器）记为IPv6/IPv4，表明它同时 具有两种 IP 地址：一个IPv6地址和一个 IPv4 地址。 双协议栈主机在和 IPv6 主机通信时采用IPv6 地址，而和 IPv4 主机通信时则采用IPv4 地址。但双协议栈主机怎样知道目的主机是采用哪一种地址呢？它是使用域名系统 DNS 来 查询的。若 DNS 返回的是IPv4地址，双协议栈的源主机就使用 IPv4 地址。但当 DNS 返回 的是 IPv6 地址，源主机就使用 IPv6 地址。 图 4-49 所示的情况是源主机A 和目的主机 F都使用IPv6，所以A向F发送 IPv6 数据 报，路径是 A→B→C→D→E→F。中间 B 到 E 这段路径是IPv4 网络，路由器 B 不能向 C 转发 IPv6 数据报，因为C只使用IPv4 协议。B 是IPv6/IPv4 路由器，它把IPv6 数据报首部 转换为IPv4 数据报首部后发送给CC再转发到D。当D转发到 IPv4 网络的出口路由器E 时（E 也是 IPv6/IPv4 路由器），再恢复成原来的IPv6 数据报。需要注意的是：IPv6 首部中 的某些字段却无法恢复。例如，原来 IPv6 首部中的流标号 X在最后恢复出的IPv6 数据报中 只能变为空缺。这种信息的损失是使用首部转换方法所不可避免的。 IPv6 A 双协议栈 IPv6/IPv4 B IPv4 网络 双协议栈 IPv6/IPv4 D E IPv6 F 流标号：X 源地址：A 目的地址：F 源地址：A 目的地址：F 源地址：A 目的地址：F 流标号：无 源地址：A 目的地址：F 数据部分 数据部分 数据部分 数据部分 IPv4 数据报 IPv4 数据报 IPv6 数据报 IPv6 数据报 图4-49 使用双协议栈进行从IPv4 到IPv6的过渡 2。隧道技术 向 IPv6 过渡的另一种方法是隧道技术（tunneling）。图 4-50 给出了隧道技术的工作原 理。这种方法的要点就是在IPv6 数据报要进入IPv4 网络时，把IPv6数据报封装成为IPv4 数据报。现在整个的IPv6数据报变成了IPv4 数据报的数据部分。这样的IPv4 数据报从路 由器 B 经过路由器C和D，传送到E，而原来的IPv6数据报就好像在IPv4 网络的隧道中传 输，什么都没有变化。当IPv4数据报离开IPv4 网络中的隧道时，再把数据部分（即原来的 IPv6 数据报）交给主机的IPv6 协议栈。图中的一条粗线表示在IPv4 网络中好像有一个从B 到E的“IPv6隧道”，路由器B是隧道的入口而E是出口。请注意，在隧道中传送的数据 报的源地址是B而目的地址是E。 要使双协议栈的主机知道IPv4 数据报里面封装的数据是一个IPv6 数据报，就必须把 IPv4 首部的协议字段的值设置为4141表示数据报的数据部分是IPv6数据报）。 双协议栈 IPv4 网络 双协议栈 IPv6 IPv6/IPv4 IPv6/IPv4 IPv6 B A IPv6 隧道 。IPv6 隧道 D IPv6 隧道 E F 流标号：X 源地址：A 目的地址：F 源地址：B 源地址：B 目的地址：E 目的地址：E 流标号：X 源地址：A 目的地址：F IPv6 IPv6 数据报 数据报 数据部分 IPv4 数据报 IPv4 数据报 数据部分 IPv4 网络 IPv6 数据报 IPv6 数据报 图4-50 使用隧道技术进行从IPv4 到IPv6的过渡 4。6。4 ICMPv6 和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数 据报。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6，它比 ICMPv4 要复杂得多。地址解析协议 ARP 和网际组管理协议 IGMP 的功能都已被合并到 ICMPv6 中（图4-51）。 ICMP IGMP IPv4 ARP 版本4中的网络层 ICMPv6 IPv6 版本6中的网络层 图4-51 新旧版本中的网络层的比较 ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播 通信。ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类 时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为ICMPv6 报 文，而把另一些报文定义为邻站发现 ND （Neighbor-Discovery）报文或多播听众交付 MLD （Multicast Listener Delivery）报文。其实所有这些报文都应当是ICMPv6 报文，只是功能和作 用不同而已。因此我们把这些报文都列入ICMPv6 的不同类别。使用这种分类方法的原因是 所有这些报文都具有相同的格式，并且所有报文类型都由 ICMPv6 协议处理。其实，像 ND</p> <p>和 MLD 这样的协议都是运行在 ICMPv6 协议之下的。基于这样的考虑，可把ICMPv6 报文 分类如图4-52 所示。请注意，邻站发现报文和组成员关系报文分别是在ND 协议和 MLD 协 议的控制下进行发送和接收的。 ICMPv6 报文 差错报文 信息报文 邻站发现报文 ND triX 组成员关系报文 MLD 协议 图4-52 ICMPv6 报文的分类 关于 ICMPv6 的进一步讨论可参阅[FORO10]，这里从略。</p> <h2 id="七ip-多播">七、IP 多播</h2> <p>4。7。1 IP 多播的基本概念 1988年 Steve Deering 首次在其博士学位论文中提出 IP 多播的概念。1992年3月IETF 在互联网范围首次试验 IETF 会议声音的多播，当时有 20 个网点可同时听到会议的声音。IP 多播是需要在互联网上增加更多的智能才能提供的一种服务。现在 IP 多播（multicast，以 前曾译为组播）已成为互联网的一个热门课题。这是由于有许多的应用需要由一个源点发送 到许多个终点，即一对多的通信。例如，实时信息的交付（如新闻、股市行情等），软件更 新，交互式会议等。随着互联网的用户数目的急剧增加，以及多媒体通信的开展，有更多的 业务需要多播来支持。关于IP多播可参考[W-MCAST]。 与单播相比，在一对多的通信中，多播可大大节约网络资源。图 4-53（a）是视频服务器 用单播方式向 90 台主机传送同样的视频节目。为此，需要发送 90 个单播，即同一个视频分 组要发送 90 个副本。图4-53（b）是视频服务器用多播方式向属于同一个多播组的 90 个成员 传送节目。这时，视频服务器只需把视频分组当作多播数据报来发送，并且只需发送一次。 路由器 Rı 在转发分组时，需要把收到的分组复制成3个副本，分别向 R2、R， 和 R&amp; 各转发1 个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此不需要复制分组， 在局域网上的多播组成员都能收到这个视频分组。 当多播组的主机数很大时（如成千上万个），采用多播方式就可明显地减轻网络中各种 资源的消耗。在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多 播数据报的软件。能够运行多播协议的路由器称为多播路由器（multicast router）。多播路由器 当然也可以转发普通的单播IP数据报。 为了适应交互式音频和视频信息的多播，从1992 年起，在互联网上开始试验虚拟的多 播主干网 MBONE （Multicast Backbone On the InterNEt）。 MBONE 可把分组传播给地点分散 但属于一个组的许多台主机。现在多播主干网已经有了相当大的规模。 在互联网上进行多播就叫做IP 多播。IP多播所传送的分组需要使用多播 IP 地址。 我们知道，在互联网中每一台主机必须有一个全球唯一的IP地址。如果某台主机现在 想接收某个特定多播组的分组，那么怎样才能使这个多播数据报传送到这台主机？</p> <p>视频服务器M 视频服务器 M 发送1次多播 发送90次单播 1个 90 个 R₁ 复制 R₁ 30个 30个 30个 R2 R3 R₁ R2 R3 Rai 个 30个 30个 30个 多播 多播 ♡ 多播 共有90个主机接收视频节目 （a）单播 多播组成员共有90个 （b） 多播 图4-53 单播与多播的比较 显然，这个多播数据报的目的地址一定不能写入这台主机的IP地址。这是因为在同一 时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入这样多的 主机的IP 地址。在多播数据报的目的地址写入的是多播组的标识符，然后设法让加入到这 个多播组的主机的IP地址与多播组的标识符关联起来。 其实多播组的标识符就是IP地址中的D类地址。D类IP地址的前四位是1110，因此 D 类地址范围是224。0。0。0 到239。255。255。255。我们就用每一个D类地址标志一个多播组。 这样，D 类地址共可标志 228个多播组，也就是说，在同一时间可以允许有超过2。6亿的多 播组在互联网上运行。多数据报也是“尽最大努力交付”，不保证一定能够交付多播组内 的所有成员。因此，多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的 地址，并且首部中的协议字段值是2，表明使用网际组管理协议 IGMP。 显然，多播地址只能用于目的地址，而不能用于源地址。此外，对多播数据报不产生 ICMP 差错报文。因此，若在PING命令后面键入多播地址，将永远不会收到响应。 IP 多播可以分为两种。一种是只在本局域网上进行硬件多播，另一种则是在互联网的 范围进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入 到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播 交付多播组的所有成员（如图4-53（b）所示）。下面就先讨论这种硬件多播。 4。7。2 在局域网上进行硬件多播 互联网号码指派管理局IANA 拥有的以太网地址块的高24位为00-00-5E，因此 TCP/IP 协议使用的以太网多播地址块的范围是从 00-00-5E-00-00-00 到 00-00-5E-FF-FF-FF。在第3 章 3。4。3 节已讲过，以太网硬件地址字段中的第1字节的最低位为1时即为多播地址，这种 多播地址数占IANA 分配到的地址数的一半。因此IANA 拥有的以太网多播地址的范围是从 01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF。不难看出，在每一个地址中，只有23 位可用作多 播。这只能和D 类IP地址中的23位有一一对应的关系。D类IP地址可供分配的有 28 位， 可见在这 28 位中的前 5 位不能用来构成以太网硬件地址（图4-54）。例如，IP 多播地址 224。128。64。32（即E0-80-40-20）和另一个IP多播地址 224。0。64。32（即E0-00-40-20）转换成 以太网的硬件多播地址都是 01-00-5E-00-40-20。由于多播 IP 地址与以太网硬件地址的映射 关系不是唯一的，因此收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本 主机要接收的数据报丢弃。 ·这5位不使用 0 8 16 24 31 D 类 1110 IP 地址 0 1 0 0 5 E 00000001 00000000 010111100 表示多播 最低23位来自D类IP地址 48位以太网地址 图4-54 D类IP地址与以太网多播地址的映射关系 下面就讨论进行IP多播所需要的协议。 4。7。3 网际组管理协议IGMP 和多播路由选择协议 1。 IP多需要两种协议 图4-55是在互联网上传送多播数据报的例子。图中标有IP地址的四台主机都参加了一 个多播组，其组地址是226。15。37。123。显然，多播数据报应当传送到路由器Rı，R和R3， 而不应当传送到路由器R4，因为与R4连接的局域网上现在没有这个多播组的成员。但这些 路由器又怎样知道多播组的成员信息呢？这就要利用一个协议，叫做网际组管理协议 IGMP （Internet Group Management Protocol）。 135。27。74。52 参加多播组 226。15。37。123 128。56。24。34 未参加 多播组 参加多播组 226。15。37。123 R₁ IGMP 130。12。14。56 参加多播组 IGMP 226。15。37。123 IGMP R2 多播组 Ra 226。15。37。123 130。12。14。43 IGMP 参加多播组 226。15。37。123 未参加 多播组 Ral 未参加 未参加 多播组 多播组 图 4-55 IGMP 使多播路由器知道多播组成员信息 图 4-55 强调了 IGMP 的本地使用范围。请注意，IGMP 并非在互联网范围内对所有多 播组成员进行管理的协议。IGMP 不知道IP多播组包含的成员数，也不知道这些成员都分 布在哪些网络上，等等。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上 是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。 显然，仅有 IGMP 协议是不能完成多任务的。连接在局域网上的多播路由器还必须 和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成 员。这就需要使用多播路由选择协议。</p> <p>然而多播路由选择协议要比单播路由选择协议复杂得多。我们可以通过一个简单的例 子来说明（图4-56）。 N 多播组① R N， G F B E ˙多播组② 图4-56 用来说明多播路由选择的例子 我们假定图 4-56中有两个多播组。多播组①的成员有主机 A，B和C，而多播组②的 成员有主机 D，E和F。这些主机分布在三个网络上（N1，N2和N3）。 路由器 R 不应当向网络N，转发多播组①的分组，因为网络N，上没有多播组①的成 员。但是每一台主机可以随时加入或离开一个多播组。例如，如果主机 G 现在加入了多播 组①，那么从这时起，路由器 R 就必须也向网络 N； 转发多播组①的分组。这就是说，多播 转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由 选择通常是在网络拓扑发生变化时才需要更新路由。 再看一种情况。主机 E 和 F 都是多播组②的成员。当 E 向 F 发送多播数据报时，路由 器 R 把这个多播数据报转发到网络 N3。但当 F E 发送多播数据报时，路由器R则把多播 数据报转发到网络 Nz。如果路由器 R 收到来自主机A的多播数据报（A不是多播组②的成 员，但也可向多播组发送多播数据报），那么路由器R 就应当把多播数据报转发到 N2 和 N3。由此可见，多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地 址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。 还有一种情况。主机 G 没有参加任何多播组，但 G 却可向任何多播组发送多播数据 报。例如，G 可向多播组①或②发送多播数据报。主机 G 所在的局域网上可以没有任何多 播组的成员。显然，多播数据报所经过的许多网络，也不一定非要有多播组成员。总之，多 播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。 正因为如此，IP多播就成为比较复杂的问题。下面介绍这两种协议的要点。 2。 网际组管理协议 IGMP IGMP 已有了三个版本。1989年公布的RFC1112（IGMPv1）早已成为了互联网的标准 协议。2002年10月公布的建议标准IGMPv3是最新的[RFC 3376]。 和网际控制报文协议 ICMP 相似，IGMP 使用IP数据报传递其报文（即IGMP 报文加 上 IP 首部构成IP数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独 的协议，而是属于整个网际协议IP的一个组成部分。 从概念上讲，IGMP 的工作可分为两个阶段。 第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到IGMP报文后，还要利用 多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。 第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主 机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路</p> <p>由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路 由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给 其他的多播路由器。 IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些 具体措施如下： （1） 在主机和多播路由器之间的所有通信都是使用IP多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加IP多播的主 机不会收到 IGMP 报文。 （2） 多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报 文，而不需要对每一个组发送一个询问报文（虽然也允许对一个特定组发送询问报文）。默 认的询问速率是每125 秒发送一次（通信量并不太大）。 （3）当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个 来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。 （4） 在 IGMP 的询问报文中有一个数值，它指明一个最长响应时间（默认值为 10 秒）。当收到询问时，主机在0到之间随机选择发送响应所需经过的时延。因此，若一台 主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的 响应最先发送。 （5） 同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自 己就可以不再发送响应了。这样就抑制了不必要的通信量。 多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据 报是使用硬件多播。多播路由器只需要知道网络上是否至少还有一台主机是本组成员即可。 实际上，对询问报文每一个组只需有一台主机发送响应。 如果一台主机上有多个进程都加入了某个多播组，那么这台主机对发给这个多播组的 每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。 最后我们还要强调指出，多播数据报的发送者和接收者都不知道（也无法找出）一个 多播组的成员有多少，以及这些成员是哪些主机。互联网中的路由器和主机都不知道哪个应 用进程将要向哪个多播组发送多播数据报，因为任何应用进程都可以在任何时候向任何一个 多播组发送多播数据报，而这个应用进程并不需要加入这个多播组。 IGMP 的报文格式可参阅有关文档[RFC 3376]，这里从略。 3。 多播路由选择协议 虽然在 TCP/IP 中IP多播协议已成为建议标准，但多播路由选择协议（用来在多播路由 器之间传播路由信息）则尚未标准化。 在多播过程中一个多播组中的成员是动态变化的。例如在收听网上某个广播节目时， 随时会有主机加入或离开这个多播组。多播路由选择实际上就是要找出以源主机为根节点的 多播转发树。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据 报，但在多播转发树上的路由器不会收到重复的多播数据报（即多播数据报不应在互联网中 兜圈子）。不难看出，对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的 源点也会有不同的多播转发树。 已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：</p> <p>（1）洪泛与剪除。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相 邻接的。一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈 子，采用了叫做反向路径广播 RPB （Reverse Path Broadcasting）的策略。RPB 的要点是：每 一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进 行这种检查很容易，只要从本路由器寻找到源点的最短路径上（之所以叫做反向路径，因为 在计算最短路径时是把源点当作终点）的第一个路由器是否就是刚才把多播数据报送来的路 由器。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就 丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上（也就是说， 存在几条同样长度的最短路径），那么只能选择一条最短路径，选择的准则就是看这几条最 短路径中的相邻路由器的IP地址最小。图4-57的例子说明了这一概念。 R₂ 源点 转发多播数据报 X 收到后即丢弃 Rs 剪除没有 R4 组成员的树枝 图4-57 反向路径广播RPB 和剪除 为简单起见，在图4-57中的网络用路由器之间的链路来表示。我们假定各路由器之间 的距离都是 1。路由器 Rı 收到源点发来的多播数据报后，向R 和R] 转发。R， 发现 R， 就在 自己到源点的最短路径上，因此向 R， 和R4 转发收到的数据报。R， 发现 R， 不在自己到源点 的最短路径上，因此丢弃 R2 发来的数据报。其他路由器也这样转发。R， 到源点有两条最短 路径：R┐→R4→R2→Rı →源点；R→ R5 → R3 → R｣ → 源点。我们再假定 R4 的IP地址比 Rs 的 IP 地址小，所以我们只使用前一条最短路径。因此R， 只转发 Ra传过来的数据报，而丢弃 Rs 传过来的数据报。最后就得出了用来转发多播数据报的多播转发树（图中用粗线表示）， 以后就按这个多播转发树来转发多播数据报。这样就避免了多播数据报兜圈子，同时每一个 路由器也不会接收重复的多播数据报。 如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播 组的成员，就应把它和下游的树枝一起剪除。例如，在图 4-57中虚线椭圆表示剪除的部 分。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。 （2） 隧道技术（tunneling）。隧道技术适用于多播组的位置在地理上很分散的情况。例如 在图 4-58 中，网1和网2都支持多播。现在网1中的主机向网2中的一些主机进行多播。 但路由器 Rı 和 R2 之间的网络并不支持多播，因而R 和R，不能按多播地址转发数据报。为 此，路由器 Rı 就对多数据报进行再次封装，即再加上普通数据报首部，使之成为向单一 目的站发送的单播（unicast）数据报，然后通过“隧道”（tunnel）从R，发送到 R2。</p> <p>网1和网2中 网1 （支持多播） 网 2 的多播数据报 （支持多播） 首部 数据 不支持多播 的网络 R2 首部 IP数据报的数据 隧道 隧道通行的 单播IP数据报 图4-58 隧道技术在多播中的应用 单播数据报到达路由器R后，再由路由器R剥去其首部，使它又恢复成原来的多播数 据报，继续向多个目的站转发。这一点和英吉利海峡隧道运送汽车的情况相似。英吉利海峡 隧道不允许汽车在隧道中行驶。但是，可以把汽车放置在隧道中行驶的电气火车上来通过隧 道。过了隧道后，汽车又可以继续在公路上行驶。这种使用隧道技术传送数据报又叫做IP 中的 IP （IP-in-IP）。 （3）基于核心的发现技术。这种方法对于多播组的大小在较大范围内变化时都适合。这 种方法是对每一个多播组 G 指定一个核心（core）路由器，给出它的IP 单播地址。核心路由器 按照前面讲过的方法创建出对应于多播组G 的转发树。如果有一个路由器，向这个核心路 由器发送数据报，那么它在途中经过的每一个路由器都要检查其内容。当数据报到达参加了 多播组 G 的路由器 Rą 时，R， 就处理这个数据报。如果 Rı 发出的是一个多播数据报，其目 的地址是 G 的组地址，R，就向多播组G 的成员转发这个多播数据报。如果R 发出的数据 报是一个请求加入多播组 G 的数据报，R，就把这个信息加到它的路由中，并用隧道技术向 Rı转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多 了，扩大了多播转发树的覆盖范围。 目前还没有在整个互联网范围使用的多播路由选择协议。下面是一些建议使用的多播 路由选择协议。 距离向量多播路由选择协议 DVMRP （Distance Vector Multicast Routing Protocol）是在互 联网上使用的第一个多播路由选择协议[RFC 1075]。由于在 UNIX 系统中实现 RIP 的程序叫 做 routed，所以在 routed 的前面加表示多播的字母m，叫做mrouted，它使用 DVMRP 在路 由器之间传播路由信息。 基于核心的转发树 CBT （Core Based Tree） [RFC 2189，2201]。这个协议使用核心路由器 作为转发树的根节点。一个大的自治系统 AS 可划分为几个区域，每一个区域选择一个核心 路由器（也叫做中心路由器 center router，或汇聚点路由器 rendezvous router）。 开放最短通路优先的多播扩展 MOSPF （Multicast extensions to OSPF） [RFC 1585]。这个 协议是单播路由选择协议 OSPF 的扩充，使用于一个机构内。MOSPF 使用多播链路状态路 由选择创建出基于源点的多播转发树。 协议无关多播-稀疏方式 PIM-SM （Protocol Independent Multicast-Sparse Mode） [RFC 4601]。这个协议使用和 CBT 同样的方法构成多播转发树。采用“协议无关”这个名词是強 调：虽然在建立多播转发树时是使用单播数据报来和远程路由器联系的，但这并不要求使用 特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。 协议无关多播-密集方式 PIM-DM （Protocol Independent Multicast-Dense Mode） [RFC 3973]。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。 PIM-DM 不使用核心路由器，而是使用洪泛方式转发数据报。</p> <h2 id="八虚拟专用网vpn-和网络地址转换-nat">八、虚拟专用网VPN 和网络地址转换 NAT</h2> <p>4。8。1 虚拟专用网 VPN 由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机 数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。 实际上，在许多情况下，很多主机主要还是和本机构内的其他主机进行通信（例如，在大型 商场或宾馆中，有很多用于营业和管理的计算机。显然这些计算机并不都需要和互联网相 连）。假定在一个机构内部的计算机通信也是采用TCP/IP 协议，那么从原则上讲，对于这些 仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。这就是说，让这些计算机 使用仅在本机构有效的IP地址（这种地址称为本地地址），而不需要向互联网的管理机构申 请全球唯一的 IP 地址（这种地址称为全球地址）。这样就可以大大节约宝贵的全球IP 地址 资源。 但是，如果任意选择一些 IP 地址作为本机构内部使用的本地地址，那么在某种情况下 可能会引起一些麻烦。例如，有时机构内部的某台主机需要和互联网连接，那么这种仅在内 部使用的本地地址就有可能和互联网中某个IP 地址重合，这样就会出现地址的二义性问 题。 为了解决这一问题，RFC 1918 指明了一些专用地址（private address）。这些地址只能用 于一个机构的内部通信，而不能用于和互联网上的主机通信。换言之，专用地址只能用做本 地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一 律不进行转发。2013 年 4 月，RFC 6890 全面地给出了所有特殊用途的IPv4地址，但三个 专用地址块的指派并无变化，即 （1） 10。0。0。0 10。255。255。255 （或记为10。0。0。0/8，它又称为24位块） （2） 172。16。0。0 172。31。255。255 （或记为172。16。0。0/12，它又称为20位块） （3） 192。168。0。0 192。168。255。255 （或记为192。168。0。0/16，它又称为16位块） 上面的三个地址块分别相当于一个A类网络、16个连续的B类网络和256个连续的C 类网络。A 类地址本来早已用完了，而上面的地址 10。0。0。0 本来是分配给 ARPANET 的。由 于 ARPANET 已经关闭停止运行了，因此这个地址就用作专用地址。 采用这样的专用 IP 地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫 做专用网。显然，全世界可能有很多的专用互连网络具有相同的专用 IP 地址，但这并不会 引起麻烦，因为这些专用地址仅在本机构内部使用。专用 IP 地址也叫做可重用地址 （reusable address）。 有时一个很大的机构的许多部门分布的范围很广（例如，在世界各地），这些部门经常 要互相交换信息。这可以有两种方法。（1）租用电信公司的通信线路为本机构专用。这种方 法虽然简单方便，但线路的租金太高，一般难于承受。（2）利用公用的互联网作为本机构各 专用网之间的通信载体，这样的专用网又称为虚拟专用网 VPN（Virtual Private Network）。 之所以称为“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不 是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的互联</p> <p>网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。加密需要采用的协议 将在7。6。1 节讨论。“虚拟”表示“好像是”，但实际上并不是，因为现在并没有真正使用通 信专线，而 VPN只是在效果上和真正的专用网一样。一个机构要构建自己的VPN 就必须为 它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其 他场所的地址。 图 4-59 以两个场所为例说明如何使用IP隧道技术实现虚拟专用网。 假定某个机构在两个相隔较远的场所建立了专用网 A 和 B，其网络地址分别为专用地 址 10。1。0。0 和 10。2。0。0。现在这两个场所需要通过公用的互联网构成一个 VPN。 显然，每一个场所至少要有一个路由器具有合法的全球IP地址，如图4-59（a）中的路由 器 Rı 和 R2。这两个路由器和互联网的接口地址必须是合法的全球IP 地址。路由器 R」 和 R2 在专用网内部网络的接口地址则是专用网的本地地址。 加密的从X到Y的内部数据报 源地址：125。1。2。3 目的地址：194。4。5。6 外部数据报的数据部分 外部数据报 数据报首部 场所A 125。1。2。3 194。4。5。6 场所 B X 隧道 Y 10。2。0。0 10。1。0。0 10。2。0。3 10。1。0。1 互联网 （a）使用隧道技术 场所 A 虚拟专用网VPN 场所 B X Y 10。2。0。0 10。1。0。0 10。2。0。3 10。1。0。1 （b）构成虚拟专用网 图4-59 用隧道技术实现虚拟专用网 在每一个场所 A或B内部的通信量都不经过互联网。但如果场所A的主机 X 要和另一 个场所 B 的主机Y通信，那么就必须经过路由器R 和R2。主机 X 向主机 Y 发送的 IP 数据 报的源地址是 10。1。0。1，而目的地址是10。2。0。3。这个数据报先作为本机构的内部数据报从X 发送到与互联网连接的路由器Rı。路由器 R， 收到内部数据报后，发现其目的网络必须通过 互联网才能到达，就把整个的内部数据报进行加密（这样就保证了内部数据报的安全），然 后重新加上数据报的首部，封装成为在互联网上发送的外部数据报，其源地址是路由器 Rı 的全球地址 125。1。2。3，而目的地址是路由器R的全球地址 194。4。5。6。路由器，收到数据报 后将其数据部分取出进行解密，恢复出原来的内部数据报（目的地址是10。2。0。3），交付主机 Y。可见，虽然 X 向 Y 发送的数据报是通过了公用的互联网，但在效果上就好像是在本部 门的专用网上传送一样。如果主机Y要向X发送数据报，那么所进行的步骤也是类似的。 请注意，数据报从R 传送到 R， 可能要经过互联网中的很多个网络和路由器。但从逻辑</p> <p>上看，在 Rı到R，之间好像是一条直通的点对点链路，图4-59（a）中的“隧道”就是这个意 思。 如图 4-59（b）所示的、由场所 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为内联 网（intranet 或intranet VPN，即内联网VPN），表示场所A和B都属于同一个机构。 有时一个机构的 VPN 需要有某些外部机构（通常就是合作伙伴）参加进来。这样的 VPN 就称为外联网（extranet 或extranet VPN，即外联网 VPN）。 请注意，内联网和外联网都采用了互联网技术，即都是基于TCP/IP协议的。 还有一种类型的VPN，就是远程接入 VPN （remote access VPN）。我们知道，有的公司 可能并没有分布在不同场所的部门，但却有很多流动员工在外地工作。公司需要和他们保持 联系，有时还可能一起开电话会议或视频会议。远程接入 VPN 可以满足这种需求。在外地 工作的员工通过拨号接入互联网，而驻留在员工个人电脑中的 VPN 软件可以在员工的个人 电脑和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容也是保密的，员工 们感到好像就是使用公司内部的本地网络。 4。8。2网络地址转换 NAT 下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地 IP 地址 （即仅在本专用网内使用的专用地址），但现在又想和互联网上的主机通信（并不需要加 密），那么应当采取什么措施呢？ 最简单的办法就是设法再申请一些全球IP地址。但这在很多情况下是不容易做到的， 因为全球 IPv4 的地址已所剩不多了。目前使用得最多的方法是采用网络地址转换。 网络地址转换 NAT （Network Address Translation）方法是在1994年提出的。这种方法需 要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路 由器，它至少有一个有效的外部全球IP 地址。这样，所有使用本地地址的主机在和外界通 信时，都要在 NAT 路由器上将其本地地址转换成全球IP地址，才能和互联网连接。 图 4-60 给出了NAT 路由器的工作原理。在图中，专用网 192。168。0。0 内所有主机的 IP 地址都是本地 IP地址 192。168。x。x。NAT 路由器至少要有一个全球IP地址，才能和互联网相 连。图 4-60 表示出 NAT 路由器有一个全球 IP 地址 172。38。1。5（当然，NAT 路由器可以有多 个全球 IP 地址）。 全球IP地址 专用网192。168。0。0 172。38。1。5 主机B 源IP 地址 213。18。2。4 主机A 192。168。0。3 192。168。0。3 源 IP 地址 172。38。1。5 互联网 NAT 路由器 目的IP 地址 192。168。0。3 目的IP地址 172。38。1。5 图4-60 NAT路由器的工作原理 NAT 路由器收到从专用网内部的主机 A 发往互联网上主机 B 的 IP数据报：源IP地址 是 192。168。0。3，而目的 IP 地址是213。18。2。4。NAT 路由器把IP数据报的源 IP 地址</p> <p>192。168。0。3，转换为新的IP地址（即NAT 路由器的全球IP地址） 172。38。1。5，然后转发 出去。因此，主机B收到这个IP数据报时，以为A的IP地址是172。38。1。5。当B给A发 送应答时，IP数据报的目的IP地址是NAT路由器的IP地址172。38。1。5。B并不知道A的专 用地址 192。168。0。3。实际上，即使知道了，也不能使用，因为互联网上的路由器都不转发目 的地址是专用网本地IP地址的IP数据报。当NAT路由器收到互联网上的主机B发来的IP 数据报时，还要进行一次IP地址的转换。通过NAT 地址转换表，就可把IP数据报上的旧 的目的 IP 地址172。38。1。5，转换为新的目的IP地址192。168。0。3（主机A真正的本地IP地 址）。表 4-11 给出了NAT 地址转换表的举例。表中的前两行数据对应于图4-60中所举的例 子。第一列“方向”中的“出”表示离开专用网，而“入”表示进入专用网。表中后两行数 据（图4-60中没有画出对应的IP数据报）表示专用网内的另一主机192。168。0。7 向互联网发 送了IP数据报，而NAT路由器还有另外一个全球IP地址172。38。1。6。 表4-11 NAT地址转换表举例 方向 字段 旧的 IP 地址 新的 IP 地址 出 源 IP 地址 入 目的 IP 地址 192。168。0。3 172。38。1。5 172。38。1。5 192。168。0。3 出 入 源 IP 地址 目的 IP 地址 192。168。0。7 172。38。1。6 172。38。1。6 192。168。0。7 由此可见，当 NAT 路由器具有n个全球 IP 地址时，专用网内最多可以同时有n 台主机 接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的 全球IP地址。 显然，通过 NAT 路由器的通信必须由专用网内的主机发起。设想互联网上的主机要发 起通信，当 IP 数据报到达 NAT 路由器时，NAT 路由器就不知道应当把目的IP 地址转换成 专用网内的哪一个本地IP 地址。这就表明，这种专用网内部的主机不能充当服务器用，因 为互联网上的客户无法请求专用网内的服务器提供服务。 为了更加有效地利用 NAT 路由器上的全球IP 地址，现在常用的 NAT 转换表把运输层 的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的 全球 IP 地址，因而可以同时和互联网上的不同主机进行通信[COME06]。 由于运输层的端口号将在下一章 5。1。3 节讨论，因此，建议在学完运输层的有关内容 后，再学习下面的内容。从系统性考虑，把下面的这部分内容放在本章中介绍较为合适。 使用端口号的 NAT 也叫做网络地址与端口号转换 NAPT （Network Address and Port Translation），而不使用端口号的NAT 就叫做传统的NAT （traditional NAT）。但在许多文献中 并没有这样区分，而是不加区分地都使用 NAT 这个更加简洁的缩写词。表 4-12 说明了 NAPT 的地址转换机制。 表4-12 NAPT 地址转换表举例 方向 字段 出 源 IP 地址：TCP 源端口 出 源IP 地址：TCP 源端口 入 目的IP 地址：TCP 目的端口 入 目的 IP 地址：TCP 目的端口 192。168。0。4：30000 172。38。1。5：40001 172。38。1。5：40002 192。168。0。4：30000 旧的IP 地址和端口号 新的IP地址和端口号 192。168。0。3：30000 172。38。1。5：40001 172。38。1。5：40002 192。168。0。3：30000 • 188。</p> <p>从表 4-12 可以看出，在专用网内主机 192。168。0。3 向互联网发送IP数据报，其 TCP 端 口号选择为 30000。NAPT 把源IP地址和TCP端口号都进行转换（如果使用UDP，则对 UDP 的端口号进行转换。原理是一样的）。另一台主机192。168。0。4 也选择了同样的 TCP 端 口号 30000。这纯属巧合（端口号仅在本主机中才有意义）。现在 NAPT 把专用网内不同的 源 IP 地址都转换为同样的全球IP地址。但对源主机所采用的TCP端口号（不管相同或不 同），则转换为不同的新的端口号。因此，当NAPT 路由器收到从互联网发来的应答时，就 可以从 IP 数据报的数据部分找出运输层的端口号，然后根据不同的目的端口号，从NAPT 转换表中找到正确的目的主机。 应当指出，从层次的角度看，NAPT的机制有些特殊。普通路由器在转发IP数据报 时，对于源 IP地址或目的IP地址都是不改变的。但NAT 路由器在转发IP数据报时，一定 要更换其IP地址（转换源IP地址或目的IP地址）。其次，普通路由器在转发分组时，是工 作在网络层。但NAPT 路由器还要查看和转换运输层的端口号，而这本来应当属于运输层 的范畴。也正因为这样，NAPT 曾遭受了一些人的批评，认为NAPT的操作没有严格按照 次的关系。但不管怎样，NAT（包括NAPT）已成为互联网的一个重要构件。有关 NAT 的 详细讨论可参阅建议标准 RFC3022 和IETF 关于 NAT 工作组的网站[W-NAT]。</p> <h2 id="九多协议标记交换-mpls">九、多协议标记交换 MPLS</h2> <p>IETF于1997年成立了MPLS工作组，为的是开发出一种新的协议。这种新的协议就是 多协议标记交换MPLS （MultiProtocol Label Switching）。“多协议”表示在MPLS 的上层可以 采用多种协议。IETF 还综合了许多公司的类似技术，如Cisco 公司的标记交换 TAG （TAG Switching），以及Ipsilon 公司的IP交换（IP Switching）等。2001年1月MPLS终于成为互联 网的建议标准[RFC 3031，3032][W-MPLS]。 MPLS 利用面向连接技术，使每个分组携带一个叫做标记（label）的小整数（这叫做打 上标记）。当分组到达交换机（即标记交换路由器）时，交换机读取分组的标记，并用标记 值来检索分组转发表。这样就比查找路由表来转发分组要快得多。 人们经常把 MPLS与异步传递方式 ATM （Asynchronous Transfer Mode）联系起来，这仅 仅是因为它们都采用了面向连接的工作方式。以前很多人都曾认为网络的发展方向是以 ATM 为核心的宽带综合业务数字 B-ISDN。然而价格低廉得多的高速IP路由器仍然占领了 市场，最终导致 ATM 技术和 B-ISDN 未能够成为网络的发展方向。MPLS 并没有取代IP， 而是作为一种IP增强技术，被广泛地应用在互联网中。 MPLS 具有以下三个方面的特点：（1）支持面向连接的服务质量。（2） 支持流量工程， 平衡网络负载。（3）有效地支持虚拟专用网 VPN。 下面讨论 MPLS 的基本工作原理。</p> <p>4。9。1 MPLS 的工作原理 1。基本工作过程 在传统的IP网络中，分组每到达一个路由器，都必须查找路由表，并按照“最长前缀 匹配”的原则找到下一跳的IP地址（请注意，前缀的长度是不确定的。当网络很大时，查 找含有大量项目的路由表要花费很多的时间。在出现突发性的通信量时，往往还会使缓存溢 出，这就会引起分组丢失、传输时延增大和服务质量下降。 MPLS 的一个重要特点就是在 MPLS 域的入口处，给每一个IP数据报打上固定长度 “标记”，然后对打上标记的IP数据报用硬件进行转发，这就使得IP数据报转发的过程大 大地加快了。采用硬件技术对打上标记的IP数据报进行转发就称为标记交换。“交换”也 表示在转发时不再上升到第三层查找转发表，而是根据标记在第二层（链路层）用硬件进行 转发。MPLS 可使用多种链路层协议，如PPP、以太网、ATM 以及帧中继等。图4-61 是 MPLS 协议的基本原理的示意图。 MPLS 域 打上标记 B 去除标记 LDP LDP ☑ LDP 3 2 打上标记 的分组 \的分组 打上标记 2 打上标记 的分组 MPLS MPLS 入口结点 X 出口结点 ☑ 普通IP分组 打上标记的分组 普通路由器 范 标记交换路由器 LSR 图4-61 MPLS 协议的基本原理 MPLS 域（MPLS domain）是指该域中有许多彼此相邻的路由器，并且所有的路由器都是 支持 MPLS 技术的标记交换路由器 LSR （Label Switching Router）。 LSR 同时具有标记交换和 路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择 功能构造转发表。 图4-61 中给出了MPLS 的基本工作过程如下： （1） MPLS 域中的各 LSR 使用专门的标记分配协议 LDP （Label Distribution Protocol）交换 报文，并找出和特定标记相对应的路径，即标记交换路径 LSP（Label Switched Path）。例如 在图中的路径 A→B→C→D。各LSR 根据这些路径构造出转发表。这个过程和路由器构造 自己的路由表相似[RFC 3031]，限于篇幅，这里不讨论转发表构造的详细步骤。但应注意的 是，MPLS 是面向连接的，因为在标记交换路径LSP上的第一个 LSR 就根据IP数据报的初 始标记确定了整个的标记交换路径，就像一条虚连接一样。</p> <p>（2） 当一个 IP 数据报进入到MPLS 域时，MPLS 入口结点（ingress node）就给它打上标记 （后面我们就会知道，这实际上是插入一个 MPLS 首部），并按照转发表把它转发给下一个 LSR。以后的所有LSR都按照标记进行转发。 给 IP 数据报打标记的过程叫做分类（classification）。严格的第三层（网络层）分类只使用 了 IP 首部中的字段，如源IP地址和目的IP地址等。大多数运营商实现了第四层（运输层） 分类（除了要检查IP首部外，运输层还要检查TCP或UDP 首部中的协议端口号），而有些运 营商则实现了第五层（应用层）分类（更进一步地检查数据报的内部并考虑其有效载荷）。 （3）由于在全网内统一分配全局标记数值是非常困难的，因此一个标记仅仅在两个标记 交换路由器 LSR 之间才有意义。分组每经过一个 LSR，LSR 就要做两件事：一是转发，二 是更换新的标记，即把入标记更换成为出标记。这就叫做标记对换（label swapping）。做这 两件事所需的数据都已清楚地写在转发表中。例如，图 4-61 中的标记交换路由器B 从入接 口0收到一个入标记为3的IP数据报，查找了如下的转发表： 入接口 0 入标记 出接口 出标记 3 1 1 为1。 标记交换路由器B就知道应当把该IP数据报从出接口 1 转发出去，同时把标记对换 当IP数据报进入下一个LSR时，这时的入标记就是刚才得到的出标记。因此，标记交 换路由器C接着在转发该IP数据报时，又把入标记1对换为出标记2。 （4） 当 IP 数据报离开 MPLS 域时，MPLS 出口结点（egress node）就把 MPLS 的标记去 除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。 上述的这种“由入口 LSR 确定进入 MPLS 域以后的转发路径”称为显式路由选择 （explicit routing），它和互联网中通常使用的“每一个路由器逐跳进行路由选择”有着很大的 区别。 下面再讨论 MPLS 中的几个重要概念。 2。 转发等价类 FEC MPLS 有个很重要的概念就是转发等价类 FEC （Forwarding Equivalence Class）。所谓 “转发等价类”就是路由器按照同样方式对待的IP 数据报的集合。这里“按照同样方式对 待”表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级 等。FEC 的例子是： （1） 目的 IP 地址与某一个特定 IP 地址的前缀匹配的IP 数据报（这就相当于普通的 IP 路由器）； （2） 所有源地址与目的地址都相同的 IP 数据报； （3） 具有某种服务质量需求的 IP 数据报。 总之，划分 FEC 的方法不受什么限制，这都由网络管理员来控制，因此非常灵活。入 口结点并不是给每一个IP数据报指派一个不同的标记，而是将属于同样 FEC 的 IP 数据报</p> <p>都指派同样的标记。FEC 和标记是一一对应的关系。 图 4-62 给出一个把 FEC 用于负载平衡的例子。图4-62（a）的主机H 和H2分别向H，和 H4 发送大量数据。路由器A和C是数据传输必须经过的。但传统的路由选择协议只能选择 最短路径A→B→C，这就可能导致这段最短路径过载。 H B H₂ （a） 传统路由选择协议使最短路径A→B→C过载 H， H B H₁ H A H₂ Ha （b） 利用FEC使通信量较为均衡 图4-62 FEC用于负载平衡 图 4-62（b）表示在 MPLS 的情况下，入口结点 A 可设置两种 FEC：“源地址为 H 而目的 地址为 Hţ”和“源地址为 H， 而目的地址为 H4”，把前一种 FEC 的路径设置为 Hı→A→B→ C→H3，而后一种的路径设置为 H2→A→D→E→C→H4。这样可使网络的负载较为平衡。网 络管理员采用自定义的 FEC 就可以更好地管理网络的资源。这种均衡网络负载的做法也称 为流量工程 TE （Traffic Engineering）或通信量工程。 4。9。2 MPLS 首部的位置与格式 MPLS 并不要求下层的网络都使用面向连接的技术。因此一对 MPLS 路由器之间的物理 连接，既可以由一个专用电路组成，如 OC-48 线路，也可以使用像以太网这样的网络。但 是这些网络并不提供打标记的手段，而IPv4 数据报首部也没有多余的位置存放 MPLS 标 记。这就需要使用一种封装技术：在把IP数据报封装成以太网帧之前，先要插入一个 MPLS 首部。从层次的角度看，MPLS 首部就处在第二层和第三层之间（图 4-63）。在把加 上 MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为 884716，而在多播的情况下为884816。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的IP数据报。 网络层 MPLS 首部 插入 数据链路层 图4-63 MPLS 首部的位置 图4-64 给出了 MPLS 首部的格式。可见“给IP数据报打上标记”其实就是在以太网的 帧首部和 IP 数据报的首部之间插入一个4字节的 MPLS 首部。具体的标记就在“标记值” 这个字段中。</p> <p>位 20 3 1 8 标记值 试验 S 生存时间 TTL 以太网帧 帧首部MPLS 首部IP首部 IP 数据 部 分 帧尾部 IP数据报 发送在前 图4-64 MPLS 首部的格式 占 20 位。由于一个 MPLS 标记占 20位，因此从理论上讲，在设置 MPLS 首部共包括以下四个字段： （1） 标记值 MPLS 时可以使用标记的所有 20 位，因而可以同时容纳高达220个流（即1048576个流）。 但是，实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管 理和设置每条交换路径。 （2） 试验 占3位，目前保留用于试验。 （3） 栈 S 占1位，在有“标记栈”时使用。 （4） 生存时间 TTL 占8位，用来防止 MPLS 分组在MPLS 域中兜圈子。 本章的重要概念 • TCP/IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数 据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组 可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。 • IP 网是虚拟的，因为从网络层上看，IP网就是一个统一的、抽象的网络（实际上 是异构的）。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统 一的、抽象的 IP 地址处理主机之间的通信问题。 在互联网上的交付有两种：在本网络上的直接交付（不经过路由器）和到其他网络 的间接交付（经过至少一个路由器，但最后一次一定是直接交付）。 一个 IP 地址在整个互联网范围内是唯一的。分类的IP 地址包括 A 类、B 类和 C 类地址（单播地址），以及D类地址（多播地址）。E类地址未使用。 分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络 号字段最前面的类别位指明IP地址的类别。 • IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络 号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的 网络号来转发分组。 • IP 地址标志一台主机（或路由器）和一条链路的接口。多归属主机同时连接到两 个或更多的网络上。这样的主机同时具有两个或更多的IP 地址，其网络号必须是 不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两 个不同的 IP 地址。 按照互联网的观点，用转发器或网桥连接起来的若干个局域网仍为一个网络。所有 分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广 域网）都是平等的。 物理地址（即硬件地址）是数据链路层和物理层使用的地址，而 IP 地址是网络层</p> <p>和以上各层使用的地址，是一种逻辑地址（用软件实现的），在数据链路层看不见 数据报的IP 地址。 IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所 有IP数据报必须具有的（源地址、目的地址，总长度等重要字段都在固定首部 中）。一些长度可变的可选字段放在固定首部的后面。 IP 首部中的生存时间字段给出了IP数据报在互联网中所能经过的最大路由器数， 可防止IP 数据报在互联网中无限制地兜圈子。 地址解析协议 ARP 把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由 器的 IP 地址和硬件地址的映射问题。ARP 的高速缓存可以大大减少网络上的通信 量。 在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。 无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指 明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”。IP地址的分配都以CIDR 地址块为单位。 CIDR 的 32 位地址掩码（或子网掩码）由一串 1 和一串0组成，而1的个数就是 前缀的长度。只要把 IP 地址和地址掩码逐位进行“逻辑与（AND）”运算，就很 容易得出网络地址。A类地址的默认地址掩码是 255。0。0。0。B类地址的默认地址掩 码是255。255。0。0C类地址的默认地址掩码是255。255。255。0。 路由聚合（把许多前缀相同的地址用一个来代替）有利于减少路由表中的项目，减 少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 “转发”和“路由选择”有区别。“转发”是单个路由器的动作。“路由选择”是许 多路由器共同协作的过程，这些路由器相互交换信息，目的是生成路由表，再从路 由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转 发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使 用路由表这一名词。 自治系统（AS）就是在单一的技术管理下的一组路由器。一个自治系统对其他自 治系统表现出的是一个单一的和一致的路由选择策略。 路由选择协议有两大类：内部网关协议（或自治系统内部的路由选择协议），如 RIP 和 OSPF；外部网关协议（或自治系统之间的路由选择协议），如BGP-4。 RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按固定 的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自 治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器。 OSPF 是分布式的链路状态协议，适用于大型互联网。OSPF 只在链路状态发生变 化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由 器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路 的“度量”。“度量”可表示费用、距离、时延、带宽等，可统称为“代价”。所有 的路由器最终都能建立一个全网的拓扑结构图。 BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协</p> <p>议。BGP 力求寻找一条能够到达目的网络（可达）且比较好的路由（不兜圈子）， 而并非要寻找一条最佳路由。 网际控制报文协议ICMP是IP层的协议。ICMP报文作为IP数据报的数据，加上 首部后组成 IP数据报发送出去。使用ICMP并非为了实现可靠传输。ICMP 允许 主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两 种，即 ICMP差错报告报文和 ICMP 询问报文。 ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通 性。PING 使用了ICMP 回送请求与回送回答报文。 要解决 IP 地址耗尽的问题，最根本的办法就是采用具有更大地址空间的新版本的 IP 协议，即 IPv6。 IPv6 所带来的主要变化是：（1）更大的地址空间（采用128位的地址）； （2） 灵活的 首部格式；（3） 改进的选项；（4） 支持即插即用；（5）支持资源的预分配；（6） IPv6 首部改为8字节对齐。 IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有 的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。 IPv6 的地址使用冒号十六进制记法。 向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的IPv6系统能够向后兼容。 向 IPv6 过渡可以使用双协议栈或使用隧道技术。 • 与单播相比，在一对多的通信中，IP多播可大大节约网络资源。IP多播使用 D 类 IP 地址。IP 多播需要使用网际组管理协议 IGMP 和多播路由选择协议。 虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体。VPN 内 部使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球IP 地 址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送 的数据都必须加密。 使用网络地址转换NAT技术，可以在专用网络内部使用专用IP 地址，而仅在连接 到互联网的路由器使用全球IP地址。这样就大大节约了宝贵的 IP 地址。 MPLS 的特点： （1） 支持面向连接的服务质量；（2） 支持流量工程，平衡网络负 载；（3）有效地支持虚拟专用网 VPN。 MPLS 在入口结点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第 二层（链路层）用硬件进行转发（在标记交换路由器中进行标记对换），因而转发 速率大大加快。</p>]]></content><author><name></name></author><category term="blog"/><category term="computer"/><category term="networks"/><category term="network layer"/><category term="OSI"/><summary type="html"><![CDATA[本章的核心内容——网际协议 IP 是本书的一个重点内容。本章还要讨论网际控制报文协议 ICMP，几种常用的路由选择协议，IPv6 的主要特点，IP 多播的概念。本章最重要的内容是：]]></summary></entry><entry><title type="html">CSS Modules 用法教程</title><link href="https://feng-zhang0712.github.io//blog/2024/css-modules/" rel="alternate" type="text/html" title="CSS Modules 用法教程"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/css-modules</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/css-modules/"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2016/06/css_modules.html">CSS Modules 用法教程</a></p>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="css modules"/><summary type="html"><![CDATA[CSS Modules 用法教程]]></summary></entry><entry><title type="html">CSS 预处理器</title><link href="https://feng-zhang0712.github.io//blog/2024/css-preprocessor/" rel="alternate" type="text/html" title="CSS 预处理器"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/css-preprocessor</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/css-preprocessor/"><![CDATA[<h2 id="一概念">一、概念</h2> <p>CSS 预处理器是一种脚本语言，扩展了原生 CSS 的功能。通过预处理器，可以使用更高级的语法和特性来编写样式代码。预处理器文件（如 .sass）在编译过程中会被转换成标准的 CSS 文件。</p> <h2 id="二常见的-css-预处理器">二、常见的 CSS 预处理器</h2> <p>Sass：提供了两种语法，Sass（缩进语法）和 SCSS（类似 CSS 的语法）。Sass 是目前最流行的预处理器之一。 LESS：另一个流行的预处理器，语法上与 CSS 更接近，容易上手。</p> <h2 id="三预处理器的用途和优点">三、预处理器的用途和优点</h2> <h3 id="31-变量">3.1 变量</h3> <p>预处理器支持变量，可以用来存储重复使用的值（如颜色）等。</p> <h3 id="32-嵌套">3.2 嵌套</h3> <p>预处理器允许嵌套 CSS，可以更清晰地表示层次结构。</p> <h3 id="33-混合宏mixin">3.3. 混合宏（Mixin）</h3> <p>混合宏允许定义一组可重用的样式规则，类似于函数。可以通过传递参数自定义样式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@mixin</span> <span class="n">border-radius</span><span class="p">(</span><span class="err">$</span><span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">-webkit-border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
     <span class="nl">-moz-border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
          <span class="nl">border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button</span> <span class="p">{</span>
  <span class="err">@include</span> <span class="err">border-radius(10px);</span>
<span class="p">}</span>

</code></pre></div></div> <h3 id="34-继承">3.4 继承</h3> <p>预处理器支持继承样式，一个选择器可以继承另一个选择器的样式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="nt">button-styles</span> <span class="p">{</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">10px</span> <span class="m">20px</span><span class="p">;</span>
  <span class="nl">border</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
  <span class="nl">cursor</span><span class="p">:</span> <span class="nb">pointer</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button</span> <span class="p">{</span>
  <span class="err">@extend</span> <span class="err">%button-styles;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="m">#3498db</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button-secondary</span> <span class="p">{</span>
  <span class="err">@extend</span> <span class="err">%button-styles;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="m">#2ecc71</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="35-函数">3.5 函数</h3> <p>预处理器允许定义函数，进行复杂的计算和逻辑操作，然后返回值，供样式规则使用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@function</span> <span class="n">calculate-margin</span><span class="p">(</span><span class="err">$</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">@return</span> <span class="err">$</span><span class="n">value</span> <span class="err">*</span> <span class="m">1.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="n">calculate-margin</span><span class="p">(</span><span class="m">10px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="36-导入和拆分文件">3.6 导入和拆分文件</h3> <p>预处理器支持将样式拆分成多个文件，并使用 @import 语句导入。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* _variables.scss */</span>
<span class="err">$</span><span class="nt">primary-color</span><span class="o">:</span> <span class="err">#3498</span><span class="nt">db</span><span class="o">;</span>
<span class="err">$</span><span class="nt">secondary-color</span><span class="o">:</span> <span class="err">#2</span><span class="nt">ecc71</span><span class="o">;</span>

<span class="c">/* _mixins.scss */</span>
<span class="k">@mixin</span> <span class="n">flex-center</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* styles.scss */</span>
<span class="k">@import</span> <span class="s2">'variables'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s2">'mixins'</span><span class="p">;</span>
<span class="nc">.header</span> <span class="p">{</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="err">$</span><span class="n">primary-color</span><span class="p">;</span>
  <span class="err">@include</span> <span class="err">flex-center;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100vh</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="37-条件语句和循环">3.7 条件语句和循环</h3> <p>预处理器支持条件语句和循环。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="nt">themes</span><span class="o">:</span> <span class="o">(</span><span class="s2">'light'</span><span class="o">,</span> <span class="s2">'dark'</span><span class="o">);</span>
<span class="k">@each</span> <span class="err">$</span><span class="n">theme</span> <span class="n">in</span> <span class="err">$</span><span class="n">themes</span> <span class="p">{</span>
  <span class="nc">.theme-</span><span class="err">#</span><span class="p">{</span><span class="err">$theme</span><span class="p">}</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="n">if</span><span class="p">(</span><span class="err">$</span><span class="n">theme</span> <span class="err">==</span> <span class="s2">'light'</span><span class="p">,</span> <span class="m">#fff</span><span class="p">,</span> <span class="m">#333</span><span class="p">);</span>
    <span class="nl">color</span><span class="p">:</span> <span class="n">if</span><span class="p">(</span><span class="err">$</span><span class="n">theme</span> <span class="err">==</span> <span class="s2">'light'</span><span class="p">,</span> <span class="m">#333</span><span class="p">,</span> <span class="m">#fff</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="sass"/><summary type="html"><![CDATA[一、概念]]></summary></entry><entry><title type="html">React 中的事件</title><link href="https://feng-zhang0712.github.io//blog/2024/events-in-react/" rel="alternate" type="text/html" title="React 中的事件"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/events-in-react</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/events-in-react/"><![CDATA[<p>React 的事件代理机制（Event Delegation）是其性能优化的一种手段。通过事件代理，React 将所有的事件监听器统一绑定到根元素，而不是每个具体的 DOM 元素上。这种方法减少了实际绑定到 DOM 元素上的事件处理器数量，从而提升了性能，特别是在有大量动态生成的元素时。</p> <h3 id="事件代理的工作原理">事件代理的工作原理</h3> <ol> <li><strong>统一绑定事件处理器</strong>：React 会在组件挂载时，将所有事件处理器统一绑定到应用的根元素（例如 <code class="language-plaintext highlighter-rouge">document</code> 或 <code class="language-plaintext highlighter-rouge">root</code> DOM 节点）。</li> <li><strong>事件捕获和冒泡</strong>：当用户在具体的 DOM 元素上触发事件时，事件会按照捕获和冒泡的机制传播。React 利用这个机制，在事件冒泡到根元素时捕获事件。</li> <li><strong>事件分发</strong>：在根元素上捕获到事件后，React 解析事件的目标元素，并根据目标元素和事件类型，找到对应的 React 组件实例和事件处理器，然后调用该处理器。</li> </ol> <h3 id="优点">优点</h3> <ul> <li><strong>性能优化</strong>：减少了实际绑定在 DOM 元素上的事件处理器数量，降低了内存消耗和性能开销。</li> <li><strong>简化事件管理</strong>：通过统一的事件处理机制，简化了事件添加和移除的管理。</li> </ul> <h3 id="示例">示例</h3> <p>以下是一个简单的示例，展示了事件代理的基本概念：</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">ButtonList</span> <span class="kd">extends</span> <span class="nc">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 获取被点击的按钮元素</span>
    <span class="kd">const</span> <span class="nx">button</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Button </span><span class="p">${</span><span class="nx">button</span><span class="p">.</span><span class="nx">textContent</span><span class="p">}</span><span class="s2"> clicked!`</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 1<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 2<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 3<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">ButtonList</span><span class="p">;</span>
</code></pre></div></div> <p>在这个示例中，三个按钮的点击事件都通过 <code class="language-plaintext highlighter-rouge">div</code> 容器上的 <code class="language-plaintext highlighter-rouge">onClick</code> 处理器进行处理。点击任意按钮时，事件会冒泡到 <code class="language-plaintext highlighter-rouge">div</code> 容器，被捕获并处理。</p> <h3 id="深入理解">深入理解</h3> <ul> <li><strong>合成事件</strong>：React 使用合成事件（Synthetic Events）对象来封装浏览器的原生事件对象。合成事件对象提供了与原生事件对象相同的接口，但具备跨浏览器的兼容性。</li> <li><strong>事件池</strong>：React 维护一个事件池，用于存储和复用合成事件对象。事件处理器执行后，合成事件对象会被复用以提高性能。因此，在事件处理器中，不能异步访问合成事件对象；如果需要异步访问，可以调用 <code class="language-plaintext highlighter-rouge">event.persist()</code> 方法防止对象被复用。</li> </ul> <h3 id="注意事项">注意事项</h3> <ul> <li><strong>异步访问事件对象</strong>：在异步函数中访问合成事件对象时，需要调用 <code class="language-plaintext highlighter-rouge">event.persist()</code> 方法。例如：</li> </ul> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nf">persist</span><span class="p">();</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span> <span class="c1">// 异步访问事件对象</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li><strong>非冒泡事件</strong>：某些事件不会冒泡，例如 <code class="language-plaintext highlighter-rouge">onBlur</code> 和 <code class="language-plaintext highlighter-rouge">onFocus</code>。React 通过特殊处理，将这些事件也通过事件代理机制进行处理。</li> </ul> <h3 id="总结">总结</h3> <p>React 的事件代理机制通过在根元素上统一绑定事件处理器，有效地减少了实际绑定在 DOM 元素上的事件处理器数量，提升了性能，并简化了事件管理。这是 React 提升性能和简化事件管理的一种重要手段。</p>]]></content><author><name></name></author><category term="frontend"/><category term="react"/><category term="events"/><summary type="html"><![CDATA[React 的事件代理机制（Event Delegation）是其性能优化的一种手段。通过事件代理，React 将所有的事件监听器统一绑定到根元素，而不是每个具体的 DOM 元素上。这种方法减少了实际绑定到 DOM 元素上的事件处理器数量，从而提升了性能，特别是在有大量动态生成的元素时。]]></summary></entry><entry><title type="html">ES6 - Array</title><link href="https://feng-zhang0712.github.io//blog/2024/array/" rel="alternate" type="text/html" title="ES6 - Array"/><published>2024-09-12T00:00:00+00:00</published><updated>2024-09-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/array</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/array/"><![CDATA[]]></content><author><name></name></author><category term="frontend"/><category term="React"/><category term="es6"/><summary type="html"><![CDATA[]]></summary></entry></feed>