<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-19T14:03:32+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">《JavaScript 教程 - 浏览器模型》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/bom/" rel="alternate" type="text/html" title="《JavaScript 教程 - 浏览器模型》摘录"/><published>2024-10-18T00:00:00+00:00</published><updated>2024-10-18T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/bom</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/bom/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/bom/">《JavaScript 教程 - 浏览器模型》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一浏览器模型概述">一、浏览器模型概述</h2> <h3 id="1-代码嵌入网页的方法">1. 代码嵌入网页的方法</h3> <p>网页中嵌入 JavaScript 代码，主要有四种方法。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素直接嵌入代码。</p> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性用来指定脚本类型。<code class="language-plaintext highlighter-rouge">type</code> 属性可以设为两种值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">text/javascript</code>：这是<strong>默认值</strong>，也是历史上一贯设定的值。如果你省略 <code class="language-plaintext highlighter-rouge">type</code> 属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li> <li><code class="language-plaintext highlighter-rouge">application/javascript</code>：对于较新的浏览器，建议设为这个值。</li> </ul> <p>如果 <code class="language-plaintext highlighter-rouge">type</code> 属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的 <code class="language-plaintext highlighter-rouge">type</code> 属性即可。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签通过 src 属性加载外部脚本。为了防止攻击者篡改外部脚本，script 标签允许设置一个 <code class="language-plaintext highlighter-rouge">integrity</code> 属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://www.example.com/script.js"</span>
  <span class="na">integrity=</span><span class="s">"sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs="</span><span class="nt">&gt;</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div> </div> </li> <li> <p>事件属性：网页元素的事件属性（比如 <code class="language-plaintext highlighter-rouge">onclick</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">button</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">myBtn</span><span class="dl">"</span> <span class="nx">onclick</span><span class="o">=</span><span class="dl">"</span><span class="s2">console.log(this.id)</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">点击</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span></code></pre></div> </div> </li> <li> <p>URL 协议：URL 支持 <code class="language-plaintext highlighter-rouge">javascript:</code> 协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">javascript:console.log('Hello')</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">点击</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">javascript:</code> 协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以 <code class="language-plaintext highlighter-rouge">javascript:</code> 网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上 <code class="language-plaintext highlighter-rouge">void</code>，或者在脚本最后加上 <code class="language-plaintext highlighter-rouge">void 0</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">javascript: void new Date().toLocaleTimeString();</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">点击</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">javascript: new Date().toLocaleTimeString();void 0;</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">点击</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div> </div> <p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p> </li> </ul> <h3 id="2-script-元素">2. script 元素</h3> <h4 id="21-工作原理">2.1 工作原理</h4> <p>正常的网页加载流程是这样的。</p> <ol> <li>对于 HTML 网页，浏览器边下载边解析。</li> <li>解析过程中，浏览器发现 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li> <li>如果 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li> <li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li> </ol> <p><strong>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染</strong>。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p> <p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“<strong>假死</strong>”状态，这被称为“<strong>阻塞效应</strong>”。</p> <p>为了避免这种情况，较好的做法是将 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签都放在页面底部，而不是头部。这样做有几个好处。</p> <ul> <li>即使遇到脚本失去响应，网页主体的渲染也已经完成，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</li> <li>避免因 DOM 结构生成之前调用 DOM 节点而导致的 JavaScript 报错，因为这时 DOM 已经生成了。</li> </ul> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;script&gt;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">);</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div> <p>上面代码执行时会报错，因为此时 document.body 元素还未生成。有几种方式可以解决这个问题。</p> <ul> <li>设定 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件的回调函数。</li> <li>使用 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">onload</code> 属性。</li> <li>将脚本放在页面底部。</li> </ul> <p>如果有多个 <code class="language-plaintext highlighter-rouge">script</code> 标签，比如下面这样。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"a.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"b.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div> <p>浏览器会同时<strong>并行</strong>下载 <code class="language-plaintext highlighter-rouge">a.js</code> 和 <code class="language-plaintext highlighter-rouge">b.js</code>，但是，执行时会保证先执行 <code class="language-plaintext highlighter-rouge">a.js</code>，然后再执行 <code class="language-plaintext highlighter-rouge">b.js</code>，即使后者先下载完成，也是如此。也就是说，<strong>脚本的执行顺序由它们在页面中的出现顺序决定</strong>，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p> <p><strong>解析和执行 CSS，也会产生阻塞</strong>。</p> <p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载 6～20 个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p> <h4 id="22-defer-属性">2.2 defer 属性</h4> <p><code class="language-plaintext highlighter-rouge">defer</code> 属性可以延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</p> <p><code class="language-plaintext highlighter-rouge">defer</code> 属性的运行流程如下。</p> <ol> <li>浏览器开始解析 HTML 网页。</li> <li>解析过程中，发现带有 <code class="language-plaintext highlighter-rouge">defer</code> 属性的 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素。</li> <li>浏览器继续往下解析 HTML 网页，同时并行下载 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素加载的外部脚本。</li> <li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li> </ol> <p>有了 <code class="language-plaintext highlighter-rouge">defer</code> 属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件触发前执行（即刚刚读取完 <code class="language-plaintext highlighter-rouge">&lt;/html&gt;</code> 标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p> <ul> <li>对于内置而不是加载外部脚本的 <code class="language-plaintext highlighter-rouge">script</code> 标签，以及动态生成的 <code class="language-plaintext highlighter-rouge">script</code> 标签，<code class="language-plaintext highlighter-rouge">defer</code> 属性不起作用。</li> <li>使用 <code class="language-plaintext highlighter-rouge">defer</code> 加载的外部脚本不应该使用 <code class="language-plaintext highlighter-rouge">document.write</code> 方法。</li> </ul> <h4 id="23-async-属性">2.3 async 属性</h4> <p><code class="language-plaintext highlighter-rouge">async</code> 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p> <ol> <li>浏览器开始解析 HTML 网页。</li> <li>解析过程中，发现带有 <code class="language-plaintext highlighter-rouge">async</code> 属性的 <code class="language-plaintext highlighter-rouge">script</code> 标签。</li> <li>浏览器继续往下解析 HTML 网页，同时并行下载 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签中的外部脚本。</li> <li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li> <li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li> </ol> <p><code class="language-plaintext highlighter-rouge">async</code> 属性可以保证脚本下载的同时，浏览器继续渲染。</p> <ul> <li>一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。</li> <li>使用 <code class="language-plaintext highlighter-rouge">async</code> 属性的脚本文件里面的代码，不应该使用 <code class="language-plaintext highlighter-rouge">document.write</code> 方法。</li> </ul> <p>一般来说，如果脚本之间没有依赖关系，就使用 <code class="language-plaintext highlighter-rouge">async</code> 属性，如果脚本之间有依赖关系，就使用 <code class="language-plaintext highlighter-rouge">defer</code> 属性。如果同时使用 <code class="language-plaintext highlighter-rouge">async</code> 和 <code class="language-plaintext highlighter-rouge">defer</code> 属性，后者不起作用，浏览器行为由 <code class="language-plaintext highlighter-rouge">async</code> 属性决定。</p> <h4 id="24-脚本的动态加载">2.4 脚本的动态加载</h4> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素还可以动态生成，这种方法的好处是，动态生成的 <code class="language-plaintext highlighter-rouge">script</code> 标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。可以通过设置 <code class="language-plaintext highlighter-rouge">async</code> 属性为 <code class="language-plaintext highlighter-rouge">false</code> 解决这个问题。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">a.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b.js</span><span class="dl">'</span><span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">script</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
  <span class="nx">script</span><span class="p">.</span><span class="k">async</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="25-加载使用的协议">2.5 加载使用的协议</h4> <p>如果不指定协议，浏览器默认采用 HTTP 协议下载。如果要采用 HTTPS 协议下载，必需写明。但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">//example.js</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div> <h3 id="3-浏览器的组成">3. 浏览器的组成</h3> <p>浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。</p> <h4 id="31-渲染引擎">3.1 渲染引擎</h4> <p>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。</p> <p>渲染引擎处理网页，通常分成四个阶段。</p> <ol> <li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li> <li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li> <li>布局：计算出渲染树的布局（layout）。</li> <li>绘制：将渲染树绘制到屏幕。</li> </ol> <p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p> <h4 id="32-重流和重绘">3.2 重流和重绘</h4> <p>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p> <p>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（<code class="language-plaintext highlighter-rouge">a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p> <p>重流和重绘并不一定一起发生，<strong>重流必然导致重绘，重绘不一定需要重流</strong>。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p> <p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p> <p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘 <code class="language-plaintext highlighter-rouge">table</code> 布局和 <code class="language-plaintext highlighter-rouge">flex</code> 布局，开销都会比较大。</p> <p>下面是一些优化技巧。</p> <ul> <li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li> <li>缓存 DOM 信息。</li> <li>不要一项一项地改变样式，而是使用 CSS <code class="language-plaintext highlighter-rouge">class</code> 一次性改变样式。</li> <li>使用 <code class="language-plaintext highlighter-rouge">documentFragment</code> 操作 DOM</li> <li>动画使用 <code class="language-plaintext highlighter-rouge">absolute</code> 定位或 <code class="language-plaintext highlighter-rouge">fixed</code> 定位，这样可以减少对其他元素的影响。</li> <li>只在必要时才显示隐藏元素。</li> <li>使用 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li> <li>使用虚拟 DOM（virtual DOM）库。</li> </ul> <h4 id="33-javascript-引擎">3.3 JavaScript 引擎</h4> <p>JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。</p> <p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p> <p>为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p> <p>早期，浏览器内部对 JavaScript 的处理过程如下：</p> <ol> <li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li> <li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li> <li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li> <li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li> </ol> <p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p> <p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。</p> <h2 id="二window-对象">二、window 对象</h2> <h3 id="1-概述">1. 概述</h3> <p>浏览器里面，<code class="language-plaintext highlighter-rouge">window</code> 对象指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p> <h3 id="2-window-对象的属性">2. window 对象的属性</h3> <h4 id="21-通用属性">2.1 通用属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.name</code> 属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的 <code class="language-plaintext highlighter-rouge">target</code> 属性使用。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.closed</code> 属性返回一个布尔值，表示窗口是否关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">popup</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">();</span>
<span class="k">if </span><span class="p">((</span><span class="nx">popup</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">popup</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 窗口仍然打开着</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">window.opener</code> 属性表示打开当前窗口的<strong>父窗口</strong>。</p> <p>如果两个窗口之间不需要通信，建议将子窗口的 <code class="language-plaintext highlighter-rouge">opener</code> 属性显式设为 <code class="language-plaintext highlighter-rouge">null</code>，这样可以减少一些安全隐患。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">newWin</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">example.html</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">newWindow</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">height=400,width=400</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">newWin</span><span class="p">.</span><span class="nx">opener</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div> </div> <p>通过 <code class="language-plaintext highlighter-rouge">opener</code> 属性，可以获得父窗口的全局属性和方法，但只限于两个窗口<strong>同源</strong>的情况，且其中一个窗口由另一个打开。<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 元素添加 <code class="language-plaintext highlighter-rouge">rel="noopener"</code> 属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"https://an.evil.site"</span> <span class="na">target=</span><span class="s">"_blank"</span> <span class="na">rel=</span><span class="s">"noopener"</span><span class="nt">&gt;</span>
恶意网站
<span class="nt">&lt;/a&gt;</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">window.self</code> 和 <code class="language-plaintext highlighter-rouge">window.window</code> 属性都指向窗口（<code class="language-plaintext highlighter-rouge">window</code>）本身。这两个属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.frames</code> 属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括 <code class="language-plaintext highlighter-rouge">frame</code> 元素和 <code class="language-plaintext highlighter-rouge">iframe</code> 元素。</p> <p><code class="language-plaintext highlighter-rouge">window.frames[0]</code> 表示页面中第一个框架窗口。</p> <p>如果 <code class="language-plaintext highlighter-rouge">iframe</code> 元素设置了 <code class="language-plaintext highlighter-rouge">id</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 属性，那么就可以用属性值，引用这个 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口。比如 <code class="language-plaintext highlighter-rouge">&lt;iframe name="myIFrame"&gt;</code> 可以用 <code class="language-plaintext highlighter-rouge">frames['myIFrame']</code> 或者 <code class="language-plaintext highlighter-rouge">frames.myIFrame</code> 来引用。</p> <p><code class="language-plaintext highlighter-rouge">frames</code> 属性实际上是 <code class="language-plaintext highlighter-rouge">window</code> 对象的别名。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">frames</span> <span class="o">===</span> <span class="nb">window</span> <span class="c1">// true</span>
</code></pre></div> </div> <p>因此，<code class="language-plaintext highlighter-rouge">frames[0]</code> 也可以用 <code class="language-plaintext highlighter-rouge">window[0]</code> 表示。但是，从语义上看，<code class="language-plaintext highlighter-rouge">frames</code> 更清晰，而且考虑到 <code class="language-plaintext highlighter-rouge">window</code> 还是全局对象，因此推荐表示多窗口时，总是使用 <code class="language-plaintext highlighter-rouge">frames[0]</code> 的写法。</p> </li> <li><code class="language-plaintext highlighter-rouge">window.length</code> 属性返回当前网页包含的框架总数。如果当前网页不包含 <code class="language-plaintext highlighter-rouge">frame</code> 和 <code class="language-plaintext highlighter-rouge">iframe</code> 元素，那么 <code class="language-plaintext highlighter-rouge">window.length</code> 就返回 0。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.frameElement</code> 属性主要用于当前窗口嵌在另一个网页的情况（嵌入 <code class="language-plaintext highlighter-rouge">&lt;object&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 或 <code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 元素），返回当前窗口所在的那个元素节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;iframe src="about.html"&gt;&lt;/iframe&gt;</span>

<span class="c1">// 下面的脚本在 about.html 里面</span>
<span class="kd">var</span> <span class="nx">frameEl</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">frameElement</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">frameEl</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">frameEl</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">other.html</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">frameEl</code> 变量就是 <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素。</p> </li> <li><code class="language-plaintext highlighter-rouge">window.top</code> 属性指向<strong>最顶层窗口</strong>，主要用于在框架窗口（<code class="language-plaintext highlighter-rouge">frame</code>）里面获取顶层窗口。</li> <li><code class="language-plaintext highlighter-rouge">window.parent</code> 属性指向<strong>父窗口</strong>。如果当前窗口没有父窗口，<code class="language-plaintext highlighter-rouge">window.parent</code> 指向自身。</li> <li><code class="language-plaintext highlighter-rouge">window.status</code> 属性用于读写浏览器状态栏的文本。很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</li> <li><code class="language-plaintext highlighter-rouge">window.devicePixelRatio</code> 属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。它表示一个 CSS 像素由多少个物理像素组成。</li> </ul> <h4 id="22-位置大小属性">2.2 位置大小属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.screenX</code> 和 <code class="language-plaintext highlighter-rouge">window.screenY</code> 属性：返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.innerHeight</code> 和 <code class="language-plaintext highlighter-rouge">window.innerWidth</code> 属性：返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。</p> <p>用户放大网页的时候（比如将网页从 100% 的大小放大为 200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是 960px），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。注意，这两个属性值包括滚动条的高度和宽度。</p> </li> <li><code class="language-plaintext highlighter-rouge">window.outerHeight</code> 和 <code class="language-plaintext highlighter-rouge">window.outerWidth</code> 属性：返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。</li> <li><code class="language-plaintext highlighter-rouge">window.scrollX</code> 和 <code class="language-plaintext highlighter-rouge">window.scrollY</code> 属性返回页面的水平/垂直滚动距离，单位都为像素。这两个属性只读。</li> <li><code class="language-plaintext highlighter-rouge">window.pageXOffset</code> 和 <code class="language-plaintext highlighter-rouge">window.pageYOffset</code> 属性是 <code class="language-plaintext highlighter-rouge">window.scrollX</code> 和 <code class="language-plaintext highlighter-rouge">window.scrollY</code> 别名。</li> </ul> <h4 id="23-组件属性">2.3 组件属性</h4> <p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p> <ul> <li><code class="language-plaintext highlighter-rouge">window.locationbar</code>：地址栏对象</li> <li><code class="language-plaintext highlighter-rouge">window.menubar</code>：菜单栏对象</li> <li><code class="language-plaintext highlighter-rouge">window.scrollbars</code>：窗口的滚动条对象</li> <li><code class="language-plaintext highlighter-rouge">window.toolbar</code>：工具栏对象</li> <li><code class="language-plaintext highlighter-rouge">window.statusbar</code>：状态栏对象</li> <li><code class="language-plaintext highlighter-rouge">window.personalbar</code>：用户安装的个人工具栏对象</li> </ul> <p>这些对象的 <code class="language-plaintext highlighter-rouge">visible</code> 属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p> <h4 id="24-全局对象属性">2.4 全局对象属性</h4> <p>全局对象属性指向一些浏览器原生的全局对象。</p> <ul> <li><code class="language-plaintext highlighter-rouge">window.document</code>：指向 <code class="language-plaintext highlighter-rouge">document</code> 对象。注意，这个属性有同源限制。只有来自<strong>同源</strong>的脚本才能读取这个属性。</li> <li><code class="language-plaintext highlighter-rouge">window.location</code>：指向 <code class="language-plaintext highlighter-rouge">Location</code> 对象，用于获取当前窗口的 URL 信息。它等同于 <code class="language-plaintext highlighter-rouge">document.location</code> 属性。</li> <li><code class="language-plaintext highlighter-rouge">window.navigator</code>：指向 <code class="language-plaintext highlighter-rouge">Navigator</code> 对象，用于获取<strong>环境信息</strong>。</li> <li><code class="language-plaintext highlighter-rouge">window.history</code>：指向 <code class="language-plaintext highlighter-rouge">History</code> 对象，表示浏览器的浏览历史。</li> <li><code class="language-plaintext highlighter-rouge">window.localStorage</code>：指向本地储存的 <code class="language-plaintext highlighter-rouge">localStorage</code> 数据。</li> <li><code class="language-plaintext highlighter-rouge">window.sessionStorage</code>：指向本地储存的 <code class="language-plaintext highlighter-rouge">sessionStorage</code> 数据。</li> <li><code class="language-plaintext highlighter-rouge">window.console</code>：指向 <code class="language-plaintext highlighter-rouge">console</code> 对象，用于操作控制台。</li> <li><code class="language-plaintext highlighter-rouge">window.screen</code>：指向 <code class="language-plaintext highlighter-rouge">Screen</code> 对象，表示屏幕信息。</li> </ul> <h4 id="25-windowissecurecontext">2.5 window.isSecureContext</h4> <p><code class="language-plaintext highlighter-rouge">window.isSecureContext</code> 属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是 <code class="language-plaintext highlighter-rouge">true</code>，否则就是 <code class="language-plaintext highlighter-rouge">false</code>。</p> <h3 id="3-window-对象的方法">3. window 对象的方法</h3> <h4 id="31-windowalertwindowpromptwindowconfirm">3.1 window.alert()，window.prompt()，window.confirm()</h4> <p>window.alert()、window.prompt()、window.confirm() 都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p> <ul> <li><code class="language-plaintext highlighter-rouge">window.alert(message)</code> 方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。无返回值。</li> <li><code class="language-plaintext highlighter-rouge">window.confirm(message)</code> 方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。返回一个布尔值，表示是否选择了确定（<code class="language-plaintext highlighter-rouge">true</code>）还是取消（<code class="language-plaintext highlighter-rouge">false</code>）。</li> <li><code class="language-plaintext highlighter-rouge">window.prompt(message, defaultValue)</code> 方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。返回一个包含用户输入文本的字符串，或 <code class="language-plaintext highlighter-rouge">null</code>。</li> </ul> <h4 id="32-windowopen-windowclosewindowstop">3.2 window.open(), window.close()，window.stop()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">window.open(url, target, [windowFeatures])</code> 方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用。</p> <ul> <li>url：字符串，表示新窗口的网址。如果省略，默认网址就是 <code class="language-plaintext highlighter-rouge">about:blank</code>。</li> <li>target：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用 <code class="language-plaintext highlighter-rouge">_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code class="language-plaintext highlighter-rouge">_self</code> 表示当前窗口，<code class="language-plaintext highlighter-rouge">_top</code> 表示顶层窗口，<code class="language-plaintext highlighter-rouge">_parent</code> 表示上一层窗口。</li> <li><code class="language-plaintext highlighter-rouge">windowFeatures</code>：字符串，内容为逗号分隔的键值对，表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。关于此参数支持的配置项，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open#windowfeatures">windowfeatures 属性</a>。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">window.close()</code> 方法用于关闭当前窗口，一般只用来关闭 <code class="language-plaintext highlighter-rouge">window.open</code> 方法新建的窗口。该方法只对顶层窗口有效，<code class="language-plaintext highlighter-rouge">iframe</code> 框架之中的窗口使用该方法无效。</li> <li><code class="language-plaintext highlighter-rouge">window.stop()</code> 方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</li> </ul> <h4 id="33-windowmovetowindowmoveby">3.3 window.moveTo()，window.moveBy()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.moveTo(x, y)</code> 方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</li> <li><code class="language-plaintext highlighter-rouge">window.moveBy(deltaX, deltaY)</code> 方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</li> </ul> <p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用 <code class="language-plaintext highlighter-rouge">window.open()</code> 方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。</p> <h4 id="34-windowresizetowindowresizeby">3.4 window.resizeTo()，window.resizeBy()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.resizeTo(aWidth, aHeight)</code> 方法用于缩放窗口到指定大小。它接受两个参数，第一个是缩放后的窗口宽度（<code class="language-plaintext highlighter-rouge">aWidth</code> 属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code class="language-plaintext highlighter-rouge">aHeight</code> 属性）。</li> <li><code class="language-plaintext highlighter-rouge">window.resizeBy(xDelta, yDelta)</code> 方法用于缩放窗口。它与 <code class="language-plaintext highlighter-rouge">window.resizeTo()</code> 的区别是，它按照相对的量缩放，<code class="language-plaintext highlighter-rouge">window.resizeTo()</code> 需要给出缩放后的绝对大小。它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</li> </ul> <h4 id="35-windowscrolltowindowscrollwindowscrollby">3.5 window.scrollTo()，window.scroll()，window.scrollBy()</h4> <ul> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scrollTo(x-coord, y-coord)</code></td> <td><code class="language-plaintext highlighter-rouge">window.scrollTo(options)</code> 方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。它也可以接受一个配置对象作为参数，配置对象 <code class="language-plaintext highlighter-rouge">options</code> 有三个属性。</td> </tr> </tbody> </table> <ul> <li><code class="language-plaintext highlighter-rouge">top</code>：滚动后页面左上角的垂直坐标，即 <code class="language-plaintext highlighter-rouge">y</code> 坐标。</li> <li><code class="language-plaintext highlighter-rouge">left</code>：滚动后页面左上角的水平坐标，即 <code class="language-plaintext highlighter-rouge">x</code> 坐标。</li> <li><code class="language-plaintext highlighter-rouge">behavior</code>：字符串，表示滚动的方式，有三个可能值（<code class="language-plaintext highlighter-rouge">smooth</code>、<code class="language-plaintext highlighter-rouge">instant</code>、<code class="language-plaintext highlighter-rouge">auto</code>），默认值为 <code class="language-plaintext highlighter-rouge">auto</code>。</li> </ul> </li> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scrollBy(x-coord, y-coord)</code></td> <td><code class="language-plaintext highlighter-rouge">window.scrollBy(options)</code> 方法用于将网页滚动指定距离（单位像素）。</td> </tr> </tbody> </table> </li> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scroll(x-coord, y-coord)</code></td> <td><code class="language-plaintext highlighter-rouge">window.scroll(options)</code> 方法是 <code class="language-plaintext highlighter-rouge">window.scrollTo()</code> 方法的别名。</td> </tr> </tbody> </table> </li> </ul> <p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Element.scrollTop</code></li> <li><code class="language-plaintext highlighter-rouge">Element.scrollLeft</code></li> <li><code class="language-plaintext highlighter-rouge">Element.scrollIntoView()</code></li> </ul> <h4 id="36-windowprint">3.6 window.print()</h4> <p><code class="language-plaintext highlighter-rouge">window.print()</code> 方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p> <h4 id="37-windowfocuswindowblur">3.7 window.focus()，window.blur()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.focus()</code> 方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</li> <li><code class="language-plaintext highlighter-rouge">window.blur()</code> 方法将焦点从窗口移除。</li> </ul> <h4 id="38-windowgetselection">3.8 window.getSelection()</h4> <p><code class="language-plaintext highlighter-rouge">window.getSelection()</code> 方法返回一个 <code class="language-plaintext highlighter-rouge">Selection</code> 对象，表示用户现在选中的文本。使用 <code class="language-plaintext highlighter-rouge">Selection</code> 对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法可以得到选中的文本。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">selObj</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">getSelection</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">selectedText</span> <span class="o">=</span> <span class="nx">selObj</span><span class="p">.</span><span class="nf">toString</span><span class="p">();</span>
</code></pre></div></div> <h4 id="39-windowgetcomputedstylewindowmatchmedia">3.9 window.getComputedStyle()，window.matchMedia()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.getComputedStyle(element, pseudoElt)</code> 方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象。</li> <li><code class="language-plaintext highlighter-rouge">window.matchMedia(mediaQueryString)</code> 方法用来检查 CSS 的 <code class="language-plaintext highlighter-rouge">mediaQuery</code> 语句。</li> </ul> <h4 id="310-windowrequestanimationframe">3.10 window.requestAnimationFrame()</h4> <p><code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 方法跟 <code class="language-plaintext highlighter-rouge">setTimeout</code> 类似，都是推迟某个函数的执行。不同之处在于，<code class="language-plaintext highlighter-rouge">setTimeout</code> 必须指定推迟的时间，<code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code class="language-plaintext highlighter-rouge">requestAnimationFrame()</code> 会暂停执行。</p> <p>如果某个函数会改变网页的布局，一般就放在 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p> <p>该方法接受一个回调函数作为参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">callback</code> 是一个回调函数。<code class="language-plaintext highlighter-rouge">callback</code> 执行时，它的参数就是系统传入的一个高精度时间戳（<code class="language-plaintext highlighter-rouge">performance.now()</code> 的返回值），单位是毫秒，表示距离网页加载的时间。</p> <p><code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 的返回值是一个整数，这个整数可以传入 <code class="language-plaintext highlighter-rouge">window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p> <p>下面是一个 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 执行网页动画的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">animate</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">absolute</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">step</span><span class="p">(</span><span class="nx">timestamp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">start</span><span class="p">)</span> <span class="nx">start</span> <span class="o">=</span> <span class="nx">timestamp</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">progress</span> <span class="o">=</span> <span class="nx">timestamp</span> <span class="o">-</span> <span class="nx">start</span><span class="p">;</span>
  <span class="c1">// 元素不断向右移，最大不超过200像素</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">progress</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
  <span class="c1">// 如果距离第一次执行不超过 2000 毫秒，</span>
  <span class="c1">// 就继续执行动画</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">progress</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">step</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">step</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码定义了一个网页动画，持续时间是 2 秒，会让元素向右移动。</p> <h4 id="311-windowrequestidlecallback">3.11 window.requestIdleCallback()</h4> <p><code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 跟 <code class="language-plaintext highlighter-rouge">setTimeout</code> 类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用 <code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 将其推迟执行，以保证网页性能。</p> <p>它跟 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在 16ms 之内完成；<code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 可以保证回调函数在系统资源空闲时执行。</p> <p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">requestIdleCallback</span><span class="p">(</span><span class="nx">callback</span><span class="p">[,</span> <span class="nx">options</span><span class="p">])</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">callback</code> 参数是一个回调函数。该回调函数执行时，系统会传入一个 <code class="language-plaintext highlighter-rouge">IdleDeadline</code> 对象作为参数。<code class="language-plaintext highlighter-rouge">IdleDeadline</code> 对象有一个 <code class="language-plaintext highlighter-rouge">didTimeout</code> 属性（布尔值，表示是否为超时调用）和一个 <code class="language-plaintext highlighter-rouge">timeRemaining()</code> 方法（返回该空闲时段剩余的毫秒数）。</p> <p><code class="language-plaintext highlighter-rouge">options</code> 参数是一个配置对象，目前只有 <code class="language-plaintext highlighter-rouge">timeout</code> 一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p> <p><code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 方法返回一个整数。该整数可以传入 <code class="language-plaintext highlighter-rouge">window.cancelIdleCallback()</code> 取消回调函数。</p> <p>下面是一个例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">requestIdleCallback</span><span class="p">(</span><span class="nx">myNonEssentialWork</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">myNonEssentialWork</span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while </span><span class="p">(</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">timeRemaining</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">doWorkIfNeeded</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">requestIdleCallback()</code> 用来执行非关键任务 <code class="language-plaintext highlighter-rouge">myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p> <p>下面是指定 <code class="language-plaintext highlighter-rouge">timeout</code> 的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">requestIdleCallback</span><span class="p">(</span><span class="nx">processPendingAnalyticsEvents</span><span class="p">,</span> <span class="p">{</span> <span class="na">timeout</span><span class="p">:</span> <span class="mi">2000</span> <span class="p">});</span>
</code></pre></div></div> <p>上面代码指定，<code class="language-plaintext highlighter-rouge">processPendingAnalyticsEvents</code> 必须在未来 2 秒之内执行。</p> <p>如果由于超时导致回调函数执行，则 <code class="language-plaintext highlighter-rouge">deadline.timeRemaining()</code> 返回 <code class="language-plaintext highlighter-rouge">0</code>，<code class="language-plaintext highlighter-rouge">deadline.didTimeout</code> 返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>如果多次执行 <code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p> <h3 id="4-事件">4. 事件</h3> <h4 id="41-load-事件和-onload-属性">4.1 load 事件和 onload 属性</h4> <p>load 事件发生在文档在浏览器窗口加载完毕时。window.onload 属性可以指定这个事件的回调函数。</p> <h4 id="42-error-事件和-onerror-属性">4.2 error 事件和 onerror 属性</h4> <p>error 事件发生在浏览器脚本发生错误时，window.onerror 属性可以指定该事件的回调函数。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p> <h4 id="43-window-对象的事件监听属性">4.3 window 对象的事件监听属性</h4> <p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code class="language-plaintext highlighter-rouge">window</code> 对象还具有以下的事件监听函数属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">window.onafterprint</code>：<code class="language-plaintext highlighter-rouge">afterprint</code>事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onbeforeprint</code>：<code class="language-plaintext highlighter-rouge">beforeprint</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onbeforeunload</code>：<code class="language-plaintext highlighter-rouge">beforeunload</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onhashchange</code>：<code class="language-plaintext highlighter-rouge">hashchange</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onlanguagechange</code>: <code class="language-plaintext highlighter-rouge">languagechange</code> 的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onmessage</code>：<code class="language-plaintext highlighter-rouge">message</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onmessageerror</code>：<code class="language-plaintext highlighter-rouge">MessageError</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onoffline</code>：<code class="language-plaintext highlighter-rouge">offline</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.ononline</code>：<code class="language-plaintext highlighter-rouge">online</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onpagehide</code>：<code class="language-plaintext highlighter-rouge">pagehide</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onpageshow</code>：<code class="language-plaintext highlighter-rouge">pageshow</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onpopstate</code>：<code class="language-plaintext highlighter-rouge">popstate</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onstorage</code>：<code class="language-plaintext highlighter-rouge">storage</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onunhandledrejection</code>：未处理的 <code class="language-plaintext highlighter-rouge">Promise</code> 对象的 <code class="language-plaintext highlighter-rouge">reject</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onunload</code>：<code class="language-plaintext highlighter-rouge">unload</code> 事件的监听函数。</li> </ul> <h3 id="5-多窗口操作">5. 多窗口操作</h3> <p>由于网页可以使用 <code class="language-plaintext highlighter-rouge">iframe</code> 元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p> <h4 id="51-窗口的引用">5.1 窗口的引用</h4> <p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p> <ul> <li><code class="language-plaintext highlighter-rouge">top</code>：顶层窗口，即最上层的那个窗口</li> <li><code class="language-plaintext highlighter-rouge">parent</code>：父窗口</li> <li><code class="language-plaintext highlighter-rouge">self</code>：当前窗口，即自身</li> </ul> <p>与这些变量对应，浏览器还提供一些特殊的窗口名，供 <code class="language-plaintext highlighter-rouge">window.open()</code> 方法、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 标签、<code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> 标签等引用。</p> <ul> <li><code class="language-plaintext highlighter-rouge">_top</code>：顶层窗口</li> <li><code class="language-plaintext highlighter-rouge">_parent</code>：父窗口</li> <li><code class="language-plaintext highlighter-rouge">_blank</code>：新窗口</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">somepage.html</span><span class="dl">"</span> <span class="nx">target</span><span class="o">=</span><span class="dl">"</span><span class="s2">_top</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">Link</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div></div> <p>上面代码就表示在顶层窗口打开链接。</p> <h4 id="52-iframe-元素">5.2 iframe 元素</h4> <p>对于 <code class="language-plaintext highlighter-rouge">iframe</code> 嵌入的窗口，<code class="language-plaintext highlighter-rouge">document.getElementById</code> 方法可以拿到该窗口的 DOM 节点，然后使用 <code class="language-plaintext highlighter-rouge">contentWindow</code> 属性获得 <code class="language-plaintext highlighter-rouge">iframe</code> 节点包含的 <code class="language-plaintext highlighter-rouge">window</code> 对象。</p> <p><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素的 <code class="language-plaintext highlighter-rouge">contentDocument</code> 属性，可以拿到子窗口的 <code class="language-plaintext highlighter-rouge">document</code> 对象。</p> <p><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素遵守<strong>同源策略</strong>，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用 <code class="language-plaintext highlighter-rouge">window.postMessage</code> 方法。</p> <p><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 窗口内部，使用 <code class="language-plaintext highlighter-rouge">window.parent</code> 引用父窗口。如果当前页面没有父窗口，则 <code class="language-plaintext highlighter-rouge">window.parent</code> 属性返回自身。因此，可以通过 <code class="language-plaintext highlighter-rouge">window.parent</code> 是否等于 <code class="language-plaintext highlighter-rouge">window.self</code>，判断当前窗口是否为 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">parent</span> <span class="o">!==</span> <span class="nb">window</span><span class="p">.</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 当前窗口是子窗口</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 窗口的 <code class="language-plaintext highlighter-rouge">window</code> 对象，有一个 <code class="language-plaintext highlighter-rouge">frameElement</code> 属性，返回 <code class="language-plaintext highlighter-rouge">4</code> 在父窗口中的 DOM 节点。</p> <h4 id="53-windowframes-属性">5.3 window.frames 属性</h4> <p><code class="language-plaintext highlighter-rouge">window.frames</code> 属性返回一个类似数组的对象，成员是所有子窗口的 <code class="language-plaintext highlighter-rouge">window</code> 对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code class="language-plaintext highlighter-rouge">frames[0]</code> 返回第一个子窗口，<code class="language-plaintext highlighter-rouge">frames[1].frames[2]</code>返 回第二个子窗口内部的第三个子窗口。</p> <p>注意，<code class="language-plaintext highlighter-rouge">window.frames</code> 每个成员的值，是框架内的窗口（即框架的 <code class="language-plaintext highlighter-rouge">window</code> 对象），而不是 <code class="language-plaintext highlighter-rouge">iframe</code> 标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用 <code class="language-plaintext highlighter-rouge">window.frames[0].document</code> 的写法。</p> <p>另外，如果 <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素设置了 <code class="language-plaintext highlighter-rouge">name</code> 或 <code class="language-plaintext highlighter-rouge">id</code> 属性，那么属性值会自动成为全局变量，并且可以通过 <code class="language-plaintext highlighter-rouge">window.frames</code> 属性引用，返回子窗口的 <code class="language-plaintext highlighter-rouge">window</code> 对象。</p> <h2 id="三navigator-对象screen-对象">三、Navigator 对象，Screen 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="四cookie">四、Cookie</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="五xmlhttprequest-对象">五、XMLHttpRequest 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="六同源限制">六、同源限制</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="七cors-通信">七、CORS 通信</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="八storage-接口">八、Storage 接口</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="九history-对象">九、History 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十location-对象url-对象urlsearchparams-对象">十、Location 对象，URL 对象，URLSearchParams 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十一arraybuffer-对象blob-对象">十一、ArrayBuffer 对象，Blob 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十二file-对象filelist-对象filereader-对象">十二、File 对象，FileList 对象，FileReader 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十三表单formdata-对象">十三、表单，FormData 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十四indexeddb-api">十四、IndexedDB API</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十五web-worker">十五、Web Worker</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十六参考">十六参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/bom/">JavaScript 教程 - 浏览器模型</a></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><category term="bom"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 浏览器模型》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/events/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-17T00:00:00+00:00</published><updated>2024-10-17T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/events</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/events/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/events/">《JavaScript 教程 - 事件》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一eventtarget-接口">一、EventTarget 接口</h2> <p>DOM 节点的事件操作（监听和触发），都定义在 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code class="language-plaintext highlighter-rouge">XMLHttpRequest</code>、<code class="language-plaintext highlighter-rouge">AudioNode</code>、<code class="language-plaintext highlighter-rouge">AudioContext</code>）也部署了这个接口。</p> <p>该接口主要提供三个实例方法。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">addEventListener(type, listener[, useCapture])</code>：用于在当前节点或对象上（即部署了 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口的对象），定义一个特定事件的监听函数。</p> <p>第三个参数除了布尔值 <code class="language-plaintext highlighter-rouge">useCapture</code>，还可以是一个监听器配置对象，定制事件监听行为。该对象有以下属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">capture</code>：布尔值，如果设为 <code class="language-plaintext highlighter-rouge">true</code>，表示监听函数在捕获阶段触发，默认为 <code class="language-plaintext highlighter-rouge">false</code>，在冒泡阶段触发。</li> <li><code class="language-plaintext highlighter-rouge">once</code>：布尔值，如果设为 <code class="language-plaintext highlighter-rouge">true</code>，表示监听函数执行一次就会自动移除，后面将不再监听该事件。该属性默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">passive</code>：布尔值，设为 <code class="language-plaintext highlighter-rouge">true</code> 时，表示禁止监听函数调用 <code class="language-plaintext highlighter-rouge">preventDefault()</code> 方法。如果调用了，浏览器将忽略这个要求，并在控制台输出一条警告。该属性默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">signal</code>：该属性的值为一个 <code class="language-plaintext highlighter-rouge">AbortSignal</code> 对象，为监听器设置了一个信号通道，用来在需要时发出信号，移除监听函数。</li> </ul> <p><code class="language-plaintext highlighter-rouge">addEventListener()</code> 方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用 <code class="language-plaintext highlighter-rouge">removeEventListener()</code> 方法手动去除）。</p> </li> <li><code class="language-plaintext highlighter-rouge">removeEventListener(type, listener[, useCapture])</code>：用于移除事件的监听函数，与 <code class="language-plaintext highlighter-rouge">addEventListener()</code> 方法完全一致。它的第一个参数“事件类型”，大小写敏感。</li> <li><code class="language-plaintext highlighter-rouge">dispatchEvent(event)</code>：用于在当前节点上触发指定事件，从而触发监听函数的执行。</li> </ul> <h2 id="二事件模型">二、事件模型</h2> <p>JavaScript 有三种方法，可以为事件绑定监听函数。</p> <ul> <li>HTML 的 <code class="language-plaintext highlighter-rouge">on-</code> 属性。使用这个方法指定的监听代码，只会在<strong>冒泡阶段</strong>触发。</li> <li>元素节点的事件属性。使用这个方法指定的监听函数，也是只会在<strong>冒泡阶段</strong>触发。</li> <li> <p><code class="language-plaintext highlighter-rouge">EventTarget.addEventListener()</code>，推荐使用这种方法。它有如下优点：</p> <ul> <li>同一个事件可以添加多个监听函数。</li> <li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li> <li>除了 DOM 节点，其他对象（比如 <code class="language-plaintext highlighter-rouge">window</code>、<code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> 等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li> </ul> </li> </ul> <p>上面三种方式，函数内部的 this 指向触发事件的那个元素节点。</p> <p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p> <ul> <li>第一阶段：从 <code class="language-plaintext highlighter-rouge">window</code> 对象传导到目标节点（上层传到底层），称为“<strong>捕获阶段</strong>”（capture phase）。</li> <li>第二阶段：在目标节点上触发，称为“<strong>目标阶段</strong>”（target phase）。</li> <li>第三阶段：从目标节点传导回 <code class="language-plaintext highlighter-rouge">window</code> 对象（从底层传回上层），称为“<strong>冒泡阶段</strong>”（bubbling phase）。</li> </ul> <p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的<strong>代理</strong>（delegation）。</p> <h2 id="三event-对象">三、Event 对象</h2> <h3 id="1-概述">1. 概述</h3> <p><code class="language-plaintext highlighter-rouge">Event</code> 构造函数可以用来生成实例对象。他接受两参数，第一个参数 <code class="language-plaintext highlighter-rouge">type</code> 是字符串，表示事件的名称；第二个参数 <code class="language-plaintext highlighter-rouge">options</code> 是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">bubbles</code>：布尔值，可选，默认为 <code class="language-plaintext highlighter-rouge">false</code>（即生成的事件只在“捕获阶段”触发监听函数），表示事件对象是否冒泡。</li> <li><code class="language-plaintext highlighter-rouge">cancelable</code>：布尔值，可选，默认为 <code class="language-plaintext highlighter-rouge">false</code>，表示事件是否可以被取消，即能否用 <code class="language-plaintext highlighter-rouge">Event.preventDefault()</code> 取消这个事件。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">ev</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Event</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">look</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="dl">'</span><span class="s1">bubbles</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="dl">'</span><span class="s1">cancelable</span><span class="dl">'</span><span class="p">:</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">ev</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码新建一个 <code class="language-plaintext highlighter-rouge">look</code> 事件实例，然后使用 <code class="language-plaintext highlighter-rouge">dispatchEvent()</code> 方法触发该事件。</p> <h3 id="2-实例属性">2. 实例属性</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Event.bubbles</code> 属性返回一个布尔值，表示当前事件是否会冒泡。该属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">Event.eventPhase</code> 属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p> <p><code class="language-plaintext highlighter-rouge">Event.eventPhase</code> 的返回值有四种可能。</p> <ul> <li><code class="language-plaintext highlighter-rouge">0</code>，事件目前没有发生。</li> <li><code class="language-plaintext highlighter-rouge">1</code>，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li> <li><code class="language-plaintext highlighter-rouge">2</code>，事件到达目标节点，即 Event.target 属性指向的那个节点。</li> <li><code class="language-plaintext highlighter-rouge">3</code>，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">Event.cancelable</code> 属性返回一个布尔值，表示事件是否可以取消。</li> <li><code class="language-plaintext highlighter-rouge">Event.cancelBubble</code> 属性是一个布尔值，如果设为 <code class="language-plaintext highlighter-rouge">true</code>，相当于执行 <code class="language-plaintext highlighter-rouge">Event.stopPropagation()</code>，可以阻止事件的传播。</li> <li><code class="language-plaintext highlighter-rouge">Event.defaultPrevented</code> 属性返回一个布尔值，表示该事件是否调用过 <code class="language-plaintext highlighter-rouge">Event.preventDefault()</code> 方法。该属性只读。</li> <li><code class="language-plaintext highlighter-rouge">Event.target</code> 属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</li> <li> <p><code class="language-plaintext highlighter-rouge">Event.currentTarget</code> 属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;p id="para"&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;</span>
<span class="kd">function</span> <span class="nf">hide</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 不管点击 Hello 或 World，总是返回 true</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">e</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">);</span>

  <span class="c1">// 点击 Hello，返回 true</span>
  <span class="c1">// 点击 World，返回 false</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">).</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">hide</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code> 是 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 的子节点，点击 <code class="language-plaintext highlighter-rouge">&lt;em&gt;</code> 或者点击 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>，都会导致监听函数执行。这时，<code class="language-plaintext highlighter-rouge">e.target</code> 总是指向原始点击位置的那个节点，而 <code class="language-plaintext highlighter-rouge">e.currentTarget</code> 指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以 <code class="language-plaintext highlighter-rouge">e.currentTarget</code> 总是等同于监听函数内部的 <code class="language-plaintext highlighter-rouge">this</code>。</p> </li> <li><code class="language-plaintext highlighter-rouge">Event.type</code> 属性返回一个字符串，表示事件类型。</li> <li><code class="language-plaintext highlighter-rouge">Event.timeStamp</code> 属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</li> <li><code class="language-plaintext highlighter-rouge">Event.isTrusted</code> 属性返回一个布尔值，表示该事件是否由真实的用户行为产生。</li> <li><code class="language-plaintext highlighter-rouge">Event.detail</code> 属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于 <code class="language-plaintext highlighter-rouge">click</code> 和 <code class="language-plaintext highlighter-rouge">dblclick</code> 事件，<code class="language-plaintext highlighter-rouge">Event.detail</code> 是鼠标按下的次数（<code class="language-plaintext highlighter-rouge">1</code> 表示单击，<code class="language-plaintext highlighter-rouge">2</code> 表示双击，<code class="language-plaintext highlighter-rouge">3</code> 表示三击）；对于鼠标滚轮事件，<code class="language-plaintext highlighter-rouge">Event.detail</code> 是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是 <code class="language-plaintext highlighter-rouge">3</code> 的倍数。</li> </ul> <h3 id="3-实例方法">3. 实例方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Event.preventDefault()</code> 方法用于取消浏览器对当前事件的默认行为。该方法生效的前提是，事件对象的 <code class="language-plaintext highlighter-rouge">cancelable</code> 属性为 <code class="language-plaintext highlighter-rouge">true</code>，如果为 <code class="language-plaintext highlighter-rouge">false</code>，调用该方法没有任何效果。注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用 <code class="language-plaintext highlighter-rouge">stopPropagation()</code> 或 <code class="language-plaintext highlighter-rouge">stopImmediatePropagation()</code> 方法。</li> <li><code class="language-plaintext highlighter-rouge">Event.stopPropagation()</code> 方法用于阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</li> <li> <p><code class="language-plaintext highlighter-rouge">Event.stopImmediatePropagation()</code> 方法方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比 <code class="language-plaintext highlighter-rouge">Event.stopPropagation()</code> 更彻底。</p> <p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了 <code class="language-plaintext highlighter-rouge">Event.stopImmediatePropagation()</code> 方法，其他的监听函数就不会再执行了。</p> </li> <li><code class="language-plaintext highlighter-rouge">Event.composedPath()</code> 方法返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div&gt;</span>
<span class="c1">//   &lt;p&gt;Hello&lt;/p&gt;</span>
<span class="c1">// &lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">composedPath</span><span class="p">());</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
<span class="c1">// [p, div, body, html, document, Window]</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">click</code> 事件的最底层节点是 <code class="language-plaintext highlighter-rouge">p</code>，向上依次是 <code class="language-plaintext highlighter-rouge">div</code>、<code class="language-plaintext highlighter-rouge">body</code>、<code class="language-plaintext highlighter-rouge">html</code>、<code class="language-plaintext highlighter-rouge">document</code>、<code class="language-plaintext highlighter-rouge">Window</code>。</p> <h2 id="四鼠标事件">四、鼠标事件</h2> <h3 id="1-鼠标事件的种类">1. 鼠标事件的种类</h3> <p>鼠标事件主要有下面这些，所有事件都继承了 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 接口。</p> <h4 id="11-点击事件">1.1 点击事件</h4> <p>鼠标点击相关的有四个事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">mousedown</code>：按下鼠标键时触发。</li> <li><code class="language-plaintext highlighter-rouge">mouseup</code>：释放按下的鼠标键时触发。</li> <li><code class="language-plaintext highlighter-rouge">click</code>：按下鼠标（通常是按下主按钮）时触发。</li> <li><code class="language-plaintext highlighter-rouge">dblclick</code>：在同一个元素上双击鼠标时触发。</li> </ul> <p><code class="language-plaintext highlighter-rouge">click</code> 事件可以看成是两个事件组成的：用户在同一个位置先触发 <code class="language-plaintext highlighter-rouge">mousedown</code>，再触发 <code class="language-plaintext highlighter-rouge">mouseup</code>。因此，触发顺序是，<code class="language-plaintext highlighter-rouge">mousedown</code> 首先触发，<code class="language-plaintext highlighter-rouge">mouseup</code> 接着触发，<code class="language-plaintext highlighter-rouge">click</code> 最后触发。</p> <p>双击时，<code class="language-plaintext highlighter-rouge">dblclick</code> 事件则会在 <code class="language-plaintext highlighter-rouge">mousedown</code>、<code class="language-plaintext highlighter-rouge">mouseup</code>、<code class="language-plaintext highlighter-rouge">click</code> 之后触发。</p> <h4 id="12-移动事件">1.2 移动事件</h4> <p>鼠标移动相关的有五个事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">mousemove</code>：当鼠标在一个<strong>节点内部移动</strong>时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li> <li><code class="language-plaintext highlighter-rouge">mouseenter</code>：鼠标<strong>进入</strong>一个节点时触发，进入子节点<strong>不会</strong>触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">mouseleave</code>：鼠标<strong>离开</strong>一个节点时触发，离开父节点<strong>不会</strong>触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">mouseover</code>：鼠标<strong>进入</strong>一个节点时触发，进入子节点会<strong>再次</strong>触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">mouseout</code>：鼠标<strong>离开</strong>一个节点时触发，离开父节点也会<strong>再次</strong>触发这个事件。</li> </ul> <h4 id="13-其他事件">1.3 其他事件</h4> <ul> <li><code class="language-plaintext highlighter-rouge">contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文”菜单键时触发。</li> <li><code class="language-plaintext highlighter-rouge">wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是 <code class="language-plaintext highlighter-rouge">WheelEvent</code> 接口。</li> </ul> <h3 id="2-mouseevent-接口">2. MouseEvent 接口</h3> <p><code class="language-plaintext highlighter-rouge">MouseEvent</code> 接口代表了鼠标相关的事件，按下鼠标键（<code class="language-plaintext highlighter-rouge">mousedown</code>）、松开鼠标键（<code class="language-plaintext highlighter-rouge">mouseup</code>）、单击（<code class="language-plaintext highlighter-rouge">click</code>）、双击（<code class="language-plaintext highlighter-rouge">dblclick</code>）等动作，所产生的事件对象都是 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 实例。此外，滚轮事件和拖拉事件也是 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 实例。</p> <p><code class="language-plaintext highlighter-rouge">MouseEvent</code> 接口继承了 <code class="language-plaintext highlighter-rouge">Event</code> 接口，所以拥有 <code class="language-plaintext highlighter-rouge">Event</code> 的所有属性和方法，并且还提供鼠标独有的属性和方法。</p> <p>浏览器原生提供一个 <code class="language-plaintext highlighter-rouge">MouseEvent()</code> 构造函数，用于新建一个 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MouseEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">MouseEvent()</code> 构造函数接受两个参数。第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。除了 <code class="language-plaintext highlighter-rouge">Event</code> 接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p> <ul> <li><code class="language-plaintext highlighter-rouge">screenX</code>：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为 <code class="language-plaintext highlighter-rouge">0</code>，设置该属性不会移动鼠标。</li> <li><code class="language-plaintext highlighter-rouge">screenY</code>：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与 <code class="language-plaintext highlighter-rouge">screenX</code> 相同。</li> <li><code class="language-plaintext highlighter-rouge">clientX</code>：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为 <code class="language-plaintext highlighter-rouge">0</code>，设置该属性不会移动鼠标。</li> <li><code class="language-plaintext highlighter-rouge">clientY</code>：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与 <code class="language-plaintext highlighter-rouge">clientX</code> 相同。</li> <li><code class="language-plaintext highlighter-rouge">shiftKey</code>：布尔值，是否同时按下了 <code class="language-plaintext highlighter-rouge">Shift</code> 键，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>：布尔值，是否同时按下了 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">altKey</code>：布尔值，是否同时按下 <code class="language-plaintext highlighter-rouge">Alt</code> 键，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">metaKey</code>：布尔值，是否同时按下 <code class="language-plaintext highlighter-rouge">Meta</code> 键，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">button</code>：数值，表示按下了哪个鼠标按键，默认值为 <code class="language-plaintext highlighter-rouge">0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code class="language-plaintext highlighter-rouge">1</code> 表示按下辅助键（通常是鼠标的中间键），<code class="language-plaintext highlighter-rouge">2</code> 表示按下次要键（通常是鼠标的右键）。</li> <li><code class="language-plaintext highlighter-rouge">buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为 <code class="language-plaintext highlighter-rouge">0</code>（没有按下任何键）。<code class="language-plaintext highlighter-rouge">1</code>（二进制 <code class="language-plaintext highlighter-rouge">001</code>）表示按下主键（通常是左键），<code class="language-plaintext highlighter-rouge">2</code>（二进制 <code class="language-plaintext highlighter-rouge">010</code>）表示按下次要键（通常是右键），<code class="language-plaintext highlighter-rouge">4</code>（二进制 <code class="language-plaintext highlighter-rouge">100</code>）表示按下辅助键（通常是中间键）。因此，如果返回 <code class="language-plaintext highlighter-rouge">3</code>（二进制 <code class="language-plaintext highlighter-rouge">011</code>）就表示同时按下了左键和右键。</li> <li><code class="language-plaintext highlighter-rouge">relatedTarget</code>：节点对象，表示事件的相关节点，默认为 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">mouseenter</code> 和 <code class="language-plaintext highlighter-rouge">mouseover</code> 事件时，表示鼠标刚刚离开的那个元素节点；<code class="language-plaintext highlighter-rouge">mouseleave</code> 和 <code class="language-plaintext highlighter-rouge">mouseout</code> 事件时，表示鼠标正在进入的那个元素节点。</li> </ul> <h3 id="3-mouseevent-接口的实例属性">3. MouseEvent 接口的实例属性</h3> <h4 id="31-mouseeventshiftkeymouseeventctrlkeymouseeventaltkeymouseeventmetakey">3.1 MouseEvent.shiftKey，MouseEvent.ctrlKey，MouseEvent.altKey，MouseEvent.metaKey</h4> <p><code class="language-plaintext highlighter-rouge">MouseEvent.shiftKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.ctrlKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.altKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.metaKey</code> 这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">shiftKey</code> 属性：<code class="language-plaintext highlighter-rouge">Shift</code> 键</li> <li><code class="language-plaintext highlighter-rouge">ctrlKey</code> 属性：<code class="language-plaintext highlighter-rouge">Ctrl</code> 键</li> <li><code class="language-plaintext highlighter-rouge">altKey</code> 属性：<code class="language-plaintext highlighter-rouge">Alt</code> 键</li> <li><code class="language-plaintext highlighter-rouge">metaKey</code> 属性：<code class="language-plaintext highlighter-rouge">Meta</code> 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 <code class="language-plaintext highlighter-rouge">Windows</code> 键）</li> </ul> <h4 id="32-mouseeventbuttonmouseeventbuttons">3.2 MouseEvent.button，MouseEvent.buttons</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">MouseEvent.button</code> 属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。</p> <ul> <li><code class="language-plaintext highlighter-rouge">0</code>：按下主键（通常是左键），或者该事件没有初始化这个属性（比如 <code class="language-plaintext highlighter-rouge">mousemove</code> 事件）。</li> <li><code class="language-plaintext highlighter-rouge">1</code>：按下辅助键（通常是中键或者滚轮键）。</li> <li><code class="language-plaintext highlighter-rouge">2</code>：按下次键（通常是右键）。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">MouseEvent.buttons</code> 属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。</p> <ul> <li><code class="language-plaintext highlighter-rouge">1</code>：二进制为 <code class="language-plaintext highlighter-rouge">001</code>（十进制的 <code class="language-plaintext highlighter-rouge">1</code>），表示按下左键。</li> <li><code class="language-plaintext highlighter-rouge">2</code>：二进制为 <code class="language-plaintext highlighter-rouge">010</code>（十进制的 <code class="language-plaintext highlighter-rouge">2</code>），表示按下右键。</li> <li><code class="language-plaintext highlighter-rouge">4</code>：二进制为 <code class="language-plaintext highlighter-rouge">100</code>（十进制的 <code class="language-plaintext highlighter-rouge">4</code>），表示按下中键或滚轮键。</li> </ul> </li> </ul> <p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回 <code class="language-plaintext highlighter-rouge">3</code>（二进制为 <code class="language-plaintext highlighter-rouge">011</code>）。</p> <h4 id="33-mouseeventscreenxmouseeventscreeny">3.3 MouseEvent.screenX，MouseEvent.screenY</h4> <ul> <li><code class="language-plaintext highlighter-rouge">MouseEvent.screenX</code> 属性返回鼠标位置相对于<strong>屏幕左上角</strong>的水平坐标（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">MouseEvent.screenY</code> 属性返回垂直坐标。</li> </ul> <p>这两个都是只读属性。</p> <h4 id="34-mouseeventclientxmouseeventclienty">3.4 MouseEvent.clientX，MouseEvent.clientY</h4> <ul> <li><code class="language-plaintext highlighter-rouge">MouseEvent.clientX</code> 属性返回鼠标位置相对于<strong>浏览器窗口左上角</strong>的水平坐标（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">MouseEvent.clientY</code> 属性返回垂直坐标。</li> </ul> <p>这两个都是只读属性。</p> <h4 id="35-mouseeventpagexmouseeventpagey">3.5 MouseEvent.pageX，MouseEvent.pageY</h4> <ul> <li><code class="language-plaintext highlighter-rouge">MouseEvent.pageX</code> 属性返回鼠标位置与文档左侧边缘的距离（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">MouseEvent.pageY</code> 属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。</li> </ul> <p>这两个都是只读属性。</p> <h4 id="36-mouseeventoffsetxmouseeventoffsety">3.6 MouseEvent.offsetX，MouseEvent.offsetY</h4> <ul> <li><code class="language-plaintext highlighter-rouge">MouseEvent.offsetX</code> 属性返回鼠标位置与目标节点左侧的 <code class="language-plaintext highlighter-rouge">padding</code> 边缘的水平距离（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">MouseEvent.offsetY</code> 属性返回与目标节点上方的 <code class="language-plaintext highlighter-rouge">padding</code> 边缘的垂直距离。</li> </ul> <p>这两个都是只读属性。</p> <h4 id="37-mouseeventmovementxmouseeventmovementy">3.7 MouseEvent.movementX，MouseEvent.movementY</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">MouseEvent.movementX</code> 属性返回当前位置与上一个 <code class="language-plaintext highlighter-rouge">mousemove</code> 事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">currentEvent</span><span class="p">.</span><span class="nx">movementX</span> <span class="o">=</span> <span class="nx">currentEvent</span><span class="p">.</span><span class="nx">screenX</span> <span class="o">-</span> <span class="nx">previousEvent</span><span class="p">.</span><span class="nx">screenX</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">MouseEvent.movementY</code> 属性返回当前位置与上一个 <code class="language-plaintext highlighter-rouge">mousemove</code> 事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">currentEvent</span><span class="p">.</span><span class="nx">movementY</span> <span class="o">=</span> <span class="nx">currentEvent</span><span class="p">.</span><span class="nx">screenY</span> <span class="o">-</span> <span class="nx">previousEvent</span><span class="p">.</span><span class="nx">screenY</span><span class="err">。</span>
</code></pre></div> </div> </li> </ul> <h4 id="38-mouseeventrelatedtarget">3.8 MouseEvent.relatedTarget</h4> <p><code class="language-plaintext highlighter-rouge">MouseEvent.relatedTarget</code> 属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。该属性只读。</p> <h3 id="4-mouseevent-接口的实例方法">4. MouseEvent 接口的实例方法</h3> <p><code class="language-plaintext highlighter-rouge">MouseEvent.getModifierState(key)</code> 方法返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示功能键的字符串。</p> <h3 id="5-wheelevent-接口">5. WheelEvent 接口</h3> <h4 id="51-概述">5.1 概述</h4> <p><code class="language-plaintext highlighter-rouge">WheelEvent</code> 接口继承了 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 实例，代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有一个 <code class="language-plaintext highlighter-rouge">wheel</code> 事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">WheelEvent()</code> 构造函数，用来生成 <code class="language-plaintext highlighter-rouge">WheelEvent</code> 实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">wheelEvent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WheelEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">WheelEvent()</code> 构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是 <code class="language-plaintext highlighter-rouge">wheel</code>。第二个参数是事件的配置对象。该对象的属性除了 <code class="language-plaintext highlighter-rouge">Event</code>、<code class="language-plaintext highlighter-rouge">UIEvent</code> 的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p> <ul> <li><code class="language-plaintext highlighter-rouge">deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 <code class="language-plaintext highlighter-rouge">0.0</code>。</li> <li><code class="language-plaintext highlighter-rouge">deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 <code class="language-plaintext highlighter-rouge">0.0</code>。</li> <li><code class="language-plaintext highlighter-rouge">deltaZ</code>：数值，表示滚轮的 <code class="language-plaintext highlighter-rouge">Z</code> 轴滚动量，默认值是 <code class="language-plaintext highlighter-rouge">0.0</code>。</li> <li><code class="language-plaintext highlighter-rouge">deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code class="language-plaintext highlighter-rouge">0</code> 表示滚动单位为像素，<code class="language-plaintext highlighter-rouge">1</code> 表示单位为行，<code class="language-plaintext highlighter-rouge">2</code> 表示单位为页，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> </ul> <h4 id="52-实例属性">5.2 实例属性</h4> <p><code class="language-plaintext highlighter-rouge">WheelEvent</code> 事件实例除了具有 <code class="language-plaintext highlighter-rouge">Event</code> 和 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p> <p>下面的属性都是只读属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li> <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li> <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaZ</code>：数值，表示滚轮的 <code class="language-plaintext highlighter-rouge">Z</code> 轴滚动量。</li> <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code class="language-plaintext highlighter-rouge">0</code> 是像素，<code class="language-plaintext highlighter-rouge">1</code> 是行，<code class="language-plaintext highlighter-rouge">2</code> 是页。</li> </ul> <h2 id="五键盘事件">五、键盘事件</h2> <h3 id="1-键盘事件的种类">1. 键盘事件的种类</h3> <p>键盘事件由用户击打键盘触发，主要有 <code class="language-plaintext highlighter-rouge">keydown</code>、<code class="language-plaintext highlighter-rouge">keypress</code>、<code class="language-plaintext highlighter-rouge">keyup</code> 三个事件，它们都继承了 <code class="language-plaintext highlighter-rouge">KeyboardEvent</code> 接口。</p> <ul> <li><code class="language-plaintext highlighter-rouge">keydown</code>：按下键盘时触发。</li> <li><code class="language-plaintext highlighter-rouge">keypress</code>：按下有值的键时触发，即按下 <code class="language-plaintext highlighter-rouge">Shift</code>、<code class="language-plaintext highlighter-rouge">Ctrl</code>、<code class="language-plaintext highlighter-rouge">Alt</code>、<code class="language-plaintext highlighter-rouge">Meta</code> 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发 <code class="language-plaintext highlighter-rouge">keydown</code> 事件，再触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">keyup</code>：松开键盘时触发该事件。</li> </ul> <p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p> <ol> <li><code class="language-plaintext highlighter-rouge">keydown</code></li> <li><code class="language-plaintext highlighter-rouge">keypress</code></li> <li><code class="language-plaintext highlighter-rouge">keydown</code></li> <li><code class="language-plaintext highlighter-rouge">keypress</code></li> <li>…（重复以上过程）</li> <li><code class="language-plaintext highlighter-rouge">keyup</code></li> </ol> <h3 id="2-keyboardevent-接口概述">2. KeyboardEvent 接口概述</h3> <p><code class="language-plaintext highlighter-rouge">KeyboardEvent</code> 接口用来描述用户与键盘的互动。这个接口继承了 <code class="language-plaintext highlighter-rouge">Event</code> 接口，并且定义了自己的实例属性和实例方法。</p> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">KeyboardEvent</code> 构造函数，用来新建键盘事件的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">KeyboardEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">KeyboardEvent</code> 构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了 <code class="language-plaintext highlighter-rouge">Event</code> 接口提供的属性，还可以配置以下字段，它们都是可选。</p> <ul> <li><code class="language-plaintext highlighter-rouge">key</code>：字符串，当前按下的键，默认为空字符串。</li> <li><code class="language-plaintext highlighter-rouge">code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li> <li><code class="language-plaintext highlighter-rouge">location</code>：整数，当前按下的键的位置，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>：布尔值，是否按下 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">shiftKey</code>：布尔值，是否按下 <code class="language-plaintext highlighter-rouge">Shift</code> 键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">altKey</code>：布尔值，是否按下 <code class="language-plaintext highlighter-rouge">Alt</code> 键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">metaKey</code>：布尔值，是否按下 <code class="language-plaintext highlighter-rouge">Meta</code> 键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">repeat</code>：布尔值，是否重复按键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <h3 id="3-keyboardevent-的实例属性">3. KeyboardEvent 的实例属性</h3> <ul> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.shiftKey</code> 表示是否按下 <code class="language-plaintext highlighter-rouge">Shift</code> 键</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.ctrlKey</code> 表示是否按下 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.altKey</code> 表示是否按下 <code class="language-plaintext highlighter-rouge">Alt</code> 键</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.metaKey</code> 表示是否按下 <code class="language-plaintext highlighter-rouge">meta</code> 键（Mac 系统是一个四瓣的小花，Windows 系统是 <code class="language-plaintext highlighter-rouge">windows</code> 键）</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.code</code> 属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.key</code> 属性返回一个字符串，表示按下的键名。该属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">KeyboardEvent.location</code> 属性返回一个整数，表示按下的键处在键盘的哪个区域。它可能取以下值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">0</code>：处在键盘的主区域，或者无法判断处于哪个区域。</li> <li><code class="language-plaintext highlighter-rouge">1</code>：处在键盘的左侧，只适用那些有两个位置的键（比如 <code class="language-plaintext highlighter-rouge">Ctrl</code> 和 <code class="language-plaintext highlighter-rouge">Shift</code> 键）。</li> <li><code class="language-plaintext highlighter-rouge">2</code>：处在键盘的右侧，只适用那些有两个位置的键（比如 <code class="language-plaintext highlighter-rouge">Ctrl</code> 和 <code class="language-plaintext highlighter-rouge">Shift</code> 键）。</li> <li><code class="language-plaintext highlighter-rouge">3</code>：处在数字小键盘。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.repeat</code> 返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发 <code class="language-plaintext highlighter-rouge">keydown</code> 和 <code class="language-plaintext highlighter-rouge">keypress</code> 事件，直到用户松开手为止。</li> </ul> <h3 id="4-keyboardevent-的实例方法">4. KeyboardEvent 的实例方法</h3> <p><code class="language-plaintext highlighter-rouge">KeyboardEvent.getModifierState(key)</code> 方法返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Shift</code>：<code class="language-plaintext highlighter-rouge">Shift</code> 键</li> <li><code class="language-plaintext highlighter-rouge">Control</code>：<code class="language-plaintext highlighter-rouge">Ctrl</code> 键</li> <li><code class="language-plaintext highlighter-rouge">Alt</code>：<code class="language-plaintext highlighter-rouge">Alt</code> 键</li> <li><code class="language-plaintext highlighter-rouge">Meta</code>：<code class="language-plaintext highlighter-rouge">Meta</code> 键</li> <li><code class="language-plaintext highlighter-rouge">CapsLock</code>：大写锁定键</li> <li><code class="language-plaintext highlighter-rouge">NumLock</code>：数字键盘开关键</li> </ul> <h2 id="六进度事件">六、进度事件</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="七表单事件">七、表单事件</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="八触摸事件">八、触摸事件</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="九拖拉事件">九、拖拉事件</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十其他常见事件">十、其他常见事件</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十一globaleventhandlers-接口">十一、GlobalEventHandlers 接口</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十二参考">十二、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/events/">JavaScript 教程 - 事件</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><category term="events"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 事件》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/async/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-12T00:00:00+00:00</published><updated>2024-10-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/async</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/async/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/async/">《JavaScript 教程 - 异步操作》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一概述">一、概述</h2> <h3 id="1-单线程模型">1. 单线程模型</h3> <p>JavaScript 采用单线程设计，原因是不想让浏览器变得太复杂。多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这无疑增加了复杂性。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征。</p> <p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p> <h3 id="2-同步任务和异步任务">2. 同步任务和异步任务</h3> <p>程序里面所有的任务，可以分成两类：<strong>同步任务</strong>（synchronous）和<strong>异步任务</strong>（asynchronous）。</p> <ul> <li>同步任务是那些没有被引擎挂起、在<strong>主线程</strong>上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</li> <li>异步任务是那些被引擎放在一边，不进入主线程、而进入<strong>任务队列</strong>的任务。只有引擎认为某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入主线程执行。</li> </ul> <h3 id="3-任务队列和事件循环">3. 任务队列和事件循环</h3> <p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供<strong>任务队列</strong>（task queue），里面是各种需要当前程序处理的异步任务。</p> <p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p> <p>JavaScript 引擎会不停地检查，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做<strong>事件循环</strong>（Event Loop）。</p> <h3 id="4-异步操作的模式">4. 异步操作的模式</h3> <h4 id="41-回调函数">4.1 回调函数</h4> <p><strong>回调函数</strong>是异步操作最基本的方法。</p> <ul> <li>回调函数的优点是简单、容易理解和实现。</li> <li>缺点是不利于代码的阅读和维护，各个部分之间高度<strong>耦合</strong>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</li> </ul> <h4 id="42-事件监听">4.2 事件监听</h4> <p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p> <ul> <li>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<strong>去耦合</strong>”（decoupling），有利于实现模块化。</li> <li>缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</li> </ul> <h4 id="43-发布订阅">4.3 发布/订阅</h4> <p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“<strong>发布</strong>”（publish）一个信号，其他任务可以向信号中心“<strong>订阅</strong>”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<strong>发布/订阅模式</strong>”（publish-subscribe pattern），又称“<strong>观察者模式</strong>”（observer pattern）。</p> <p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p> <h3 id="5-异步操作的流程控制">5. 异步操作的流程控制</h3> <h4 id="51-串行执行">5.1 串行执行</h4> <p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫<strong>串行执行</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">];</span>
<span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kd">function</span> <span class="nf">async</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">参数为 </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">arg</span> <span class="o">+</span><span class="dl">'</span><span class="s1"> , 1 秒后返回结果</span><span class="dl">'</span><span class="p">);</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">callback</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">final</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">完成: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">series</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">async</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">results</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
      <span class="k">return</span> <span class="nf">series</span><span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">());</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">final</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">series</span><span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">());</span>
</code></pre></div></div> <p>上面代码中，函数 <code class="language-plaintext highlighter-rouge">series()</code> 就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行 <code class="language-plaintext highlighter-rouge">final()</code> 函数。<code class="language-plaintext highlighter-rouge">items</code> 数组保存每个异步任务的参数，<code class="language-plaintext highlighter-rouge">results</code> 数组保存每个异步任务的运行结果。</p> <h4 id="52-并行执行">5.2 并行执行</h4> <p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行 <code class="language-plaintext highlighter-rouge">final()</code> 函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">];</span>
<span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kd">function</span> <span class="nf">async</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">参数为 </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">arg</span> <span class="o">+</span><span class="dl">'</span><span class="s1"> , 1 秒后返回结果</span><span class="dl">'</span><span class="p">);</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">callback</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">final</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">完成: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">items</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">async</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">){</span>
    <span class="nx">results</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">final</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">});</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">forEach()</code> 方法会同时发起六个异步任务，等到它们全部完成以后，才会执行 <code class="language-plaintext highlighter-rouge">final()</code> 函数。</p> <p>并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p> <h4 id="53-并行与串行的结合">5.3 并行与串行的结合</h4> <p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行 <code class="language-plaintext highlighter-rouge">n</code> 个异步任务，这样就避免了过分占用系统资源。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">];</span>
<span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">var</span> <span class="nx">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">limit</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">async</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">参数为 </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">arg</span> <span class="o">+</span><span class="dl">'</span><span class="s1"> , 1秒后返回结果</span><span class="dl">'</span><span class="p">);</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">callback</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">final</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">完成: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">launcher</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">running</span> <span class="o">&lt;</span> <span class="nx">limit</span> <span class="o">&amp;&amp;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
    <span class="k">async</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">results</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
      <span class="nx">running</span><span class="o">--</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">launcher</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">running</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">final</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
    <span class="nx">running</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">launcher</span><span class="p">();</span>
</code></pre></div></div> <p>上面代码中，最多只能同时运行两个异步任务。变量 <code class="language-plaintext highlighter-rouge">running</code> 记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于 <code class="language-plaintext highlighter-rouge">0</code>，就表示所有任务都执行完了，这时就执行 <code class="language-plaintext highlighter-rouge">final()</code> 函数。</p> <h2 id="二定时器">二、定时器</h2> <h3 id="1-settimeout">1. setTimeout()</h3> <p><code class="language-plaintext highlighter-rouge">setTimeout()</code> 函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p> <p><code class="language-plaintext highlighter-rouge">setTimeout()</code> 函数接受两个参数，第一个参数 <code class="language-plaintext highlighter-rouge">func|code</code> 是将要推迟执行的函数名或者一段代码，第二个参数 <code class="language-plaintext highlighter-rouge">delay</code> 是推迟执行的毫秒数。除了前两个参数，<code class="language-plaintext highlighter-rouge">setTimeout()</code> 还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p> <h3 id="2-setinterval">2. setInterval()</h3> <p><code class="language-plaintext highlighter-rouge">setInterval()</code> 函数的用法与 <code class="language-plaintext highlighter-rouge">setTimeout()</code> 完全一致，区别仅仅在于 <code class="language-plaintext highlighter-rouge">setInterval()</code> 指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p> <p><code class="language-plaintext highlighter-rouge">setInterval()</code> 指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会<strong>小于</strong>指定的时间。</p> <p>为了确保两次执行之间有固定的间隔，可以不用 <code class="language-plaintext highlighter-rouge">setInterval()</code>，而是每次执行结束后，使用 <code class="language-plaintext highlighter-rouge">setTimeout()</code> 指定下一次执行的具体时间。</p> <h3 id="3-cleartimeoutclearinterval">3. clearTimeout()，clearInterval()</h3> <p><code class="language-plaintext highlighter-rouge">clearTimeout()</code> 和 <code class="language-plaintext highlighter-rouge">clearInterval()</code> 函数用来取消对应的定时器。</p> <h3 id="4-实例debounce-函数">4. 实例：debounce 函数</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">delay</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 声明计时器</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
    <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="nx">timer</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，只要在 2500ms 之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是 2500ms。</p> <h3 id="5-运行机制">5. 运行机制</h3> <p><code class="language-plaintext highlighter-rouge">setTimeout()</code> 和 <code class="language-plaintext highlighter-rouge">setInterval()</code> 的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p> <p>这意味着，<code class="language-plaintext highlighter-rouge">setTimeout()</code> 和 <code class="language-plaintext highlighter-rouge">setInterval()</code> 指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code class="language-plaintext highlighter-rouge">setTimeout()</code> 和 <code class="language-plaintext highlighter-rouge">setInterval()</code> 指定的任务，一定会按照预定时间执行。</p> <h3 id="6-settimeoutf-0">6. setTimeout(f, 0)</h3> <h4 id="61-含义">6.1 含义</h4> <p><code class="language-plaintext highlighter-rouge">setTimeout(f, 0)</code> 会在下一轮事件循环一开始就执行。<code class="language-plaintext highlighter-rouge">setTimeout(f, 0)</code> 这种写法的目的是，尽可能早地执行 <code class="language-plaintext highlighter-rouge">f</code>，但是并不能保证立刻就执行 <code class="language-plaintext highlighter-rouge">f</code>。</p> <h4 id="62-应用">6.2 应用</h4> <ul> <li> <p>调整事件的发生顺序。</p> <p>比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到 <code class="language-plaintext highlighter-rouge">setTimeout(f, 0)</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type="button" id="myButton" value="click"&gt;</span>

<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myButton</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">input</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nf">B</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span><span class="dl">'</span><span class="s1"> input</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">};</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">C</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1"> body</span><span class="dl">'</span>
<span class="p">};</span>
</code></pre></div> </div> <p>上面代码在点击按钮后，先触发回调函数 <code class="language-plaintext highlighter-rouge">A</code>，然后触发函数 <code class="language-plaintext highlighter-rouge">C</code>。函数 <code class="language-plaintext highlighter-rouge">A</code> 中，<code class="language-plaintext highlighter-rouge">setTimeout(f, 0)</code> 将函数 <code class="language-plaintext highlighter-rouge">B</code> 推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数 <code class="language-plaintext highlighter-rouge">C</code> 的目的了。</p> </li> <li> <p>用户自定义的回调函数，通常在浏览器的默认动作之前触发。</p> <p>比如，用户在输入框输入文本，keypress 事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type="text" id="input-box"&gt;</span>

<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">input-box</span><span class="dl">'</span><span class="p">).</span><span class="nx">onkeypress</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以 <code class="language-plaintext highlighter-rouge">this.value</code> 取不到最新输入的那个字符。只有用 <code class="language-plaintext highlighter-rouge">setTimeout(f, 0)</code> 改写，上面的代码才能发挥作用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">input-box</span><span class="dl">'</span><span class="p">).</span><span class="nx">onkeypress</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">();</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> </li> </ul> <p>由于 <code class="language-plaintext highlighter-rouge">setTimeout(f, 0)</code> 实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到 <code class="language-plaintext highlighter-rouge">setTimeout(f, 0)</code> 里面执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// 写法一</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mh">0xA00000</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0xFFFFFF</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">i</span><span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 写法二</span>
<span class="kd">var</span> <span class="nx">timer</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mh">0x100000</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">timer</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">i</span><span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">i</span><span class="o">++</span> <span class="o">==</span> <span class="mh">0xFFFFFF</span><span class="p">)</span> <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">timer</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是 <code class="language-plaintext highlighter-rouge">setTimeout(f, 0)</code> 的好处。</p> <p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成 <code class="language-plaintext highlighter-rouge">setTimeout(highlightNext, 50)</code> 的样子，性能压力就会减轻。</p> <h2 id="三promise-对象">三、Promise 对象</h2> <p>参考 <a href="https://es6.ruanyifeng.com/#docs/promise">ES6 标准入门 - Promise 对象</a>。</p> <h2 id="四参考">四、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/async/">JavaScript 教程 - 异步操作</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><category term="async"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 异步操作》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/dom/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-12T00:00:00+00:00</published><updated>2024-10-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/dom</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/dom/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/dom/">《JavaScript 教程 - DOM》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一概述">一、概述</h2> <p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p> <p>DOM 的最小组成单位叫做<strong>节点</strong>（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p> <p>节点的类型有七种。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Document</code>：整个文档树的顶层节点</li> <li><code class="language-plaintext highlighter-rouge">DocumentType</code>：<code class="language-plaintext highlighter-rouge">doctype</code> 标签（比如 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>）</li> <li><code class="language-plaintext highlighter-rouge">Element</code>：网页的各种 HTML 标签（比如 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 等）</li> <li><code class="language-plaintext highlighter-rouge">Attr</code>：网页元素的属性（比如 <code class="language-plaintext highlighter-rouge">class="right"</code>）</li> <li><code class="language-plaintext highlighter-rouge">Text</code>：标签之间或标签包含的文本</li> <li><code class="language-plaintext highlighter-rouge">Comment</code>：注释</li> <li><code class="language-plaintext highlighter-rouge">DocumentFragment</code>：文档的片段</li> </ul> <p>浏览器提供一个原生的节点对象 <code class="language-plaintext highlighter-rouge">Node</code>，上面这七种节点都继承了 <code class="language-plaintext highlighter-rouge">Node</code>，因此具有一些共同的属性和方法。</p> <p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 <strong>DOM 树</strong>。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，又像一棵树。</p> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">document</code> 节点，代表整个文档。</p> <p>文档的第一层有两个节点，第一个是文档类型节点（<code class="language-plaintext highlighter-rouge">&lt;!doctype html&gt;</code>），第二个是 HTML 网页的顶层容器标签 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code>。后者构成了树结构的<strong>根节点</strong>（root node），其他 HTML 标签节点都是它的下级节点。除了根节点，其他节点都有三种层级关系。</p> <ul> <li>父节点关系（parentNode）：直接的那个上级节点</li> <li>子节点关系（childNodes）：直接的下级节点</li> <li>同级节点关系（sibling）：拥有同一个父节点的节点</li> </ul> <p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括 <code class="language-plaintext highlighter-rouge">firstChild</code>（第一个子节点）和 <code class="language-plaintext highlighter-rouge">lastChild</code>（最后一个子节点）等属性，同级节点接口包括 <code class="language-plaintext highlighter-rouge">nextSibling</code>（紧邻在后的那个同级节点）和 <code class="language-plaintext highlighter-rouge">previousSibling</code>（紧邻在前的那个同级节点）属性。</p> <h2 id="二node-接口">二、Node 接口</h2> <p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。</p> <h3 id="1-属性">1. 属性</h3> <h4 id="11-nodeprototypenodetype">1.1 Node.prototype.nodeType</h4> <p><code class="language-plaintext highlighter-rouge">nodeType</code> 属性返回一个整数值，表示节点的<strong>类型</strong>。Node 对象定义了几个常量，对应这些类型值。不同节点的 <code class="language-plaintext highlighter-rouge">nodeType</code> 属性值和对应的常量如下。</p> <ul> <li>文档节点（document）：<code class="language-plaintext highlighter-rouge">9</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code></li> <li>文档类型节点（DocumentType）：<code class="language-plaintext highlighter-rouge">10</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_TYPE_NODE</code></li> <li>元素节点（element）：<code class="language-plaintext highlighter-rouge">1</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.ELEMENT_NODE</code></li> <li>属性节点（attr）：<code class="language-plaintext highlighter-rouge">2</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.ATTRIBUTE_NODE</code></li> <li>文本节点（text）：<code class="language-plaintext highlighter-rouge">3</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.TEXT_NODE</code></li> <li>注释节点（Comment）：<code class="language-plaintext highlighter-rouge">8</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.COMMENT_NODE</code></li> <li>文档片断节点（DocumentFragment）：<code class="language-plaintext highlighter-rouge">11</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_FRAGMENT_NODE</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">nodeType</span> <span class="c1">// 9</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">DOCUMENT_NODE</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="12-nodeprototypenodename">1.2 Node.prototype.nodeName</h4> <p><code class="language-plaintext highlighter-rouge">nodeName</code> 属性返回节点的<strong>名称</strong>。不同节点的 <code class="language-plaintext highlighter-rouge">nodeName</code> 属性值如下。</p> <ul> <li>文档节点（document）：<code class="language-plaintext highlighter-rouge">#document</code></li> <li>文档类型节点（DocumentType）：文档的类型</li> <li>元素节点（element）：大写的标签名</li> <li>属性节点（attr）：属性的名称</li> <li>文本节点（text）：<code class="language-plaintext highlighter-rouge">#text</code></li> <li>注释节点（Comment）：<code class="language-plaintext highlighter-rouge">#comment</code></li> <li>文档片断节点（DocumentFragment）：<code class="language-plaintext highlighter-rouge">#document-fragment</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">nodeName</span> <span class="c1">// "DIV"</span>
</code></pre></div></div> <p>上面代码中，元素节点 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> 的 <code class="language-plaintext highlighter-rouge">nodeName</code> 属性就是大写的标签名 <code class="language-plaintext highlighter-rouge">DIV</code>。</p> <h4 id="13-nodeprototypenodevalue">1.3 Node.prototype.nodeValue</h4> <p><code class="language-plaintext highlighter-rouge">nodeValue</code> 属性返回一个字符串，表示当前节点本身的<strong>文本值</strong>，该属性<strong>可读写</strong>。</p> <p>只有<strong>文本节点</strong>（text）、<strong>注释节点</strong>（comment）和<strong>属性节点</strong>（attr）有文本值，因此这三类节点的 <code class="language-plaintext highlighter-rouge">nodeValue</code> 可以返回结果，其他类型的节点一律返回 <code class="language-plaintext highlighter-rouge">null</code>。也只有这三类节点可以设置 <code class="language-plaintext highlighter-rouge">nodeValue</code> 属性的值，其他类型的节点设置无效。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="c1">// null</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="c1">// "hello world"</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">div</code> 是元素节点，<code class="language-plaintext highlighter-rouge">nodeValue</code> 属性返回 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">div.firstChild</code> 是文本节点，所以可以返回文本值。</p> <h4 id="14-nodeprototypetextcontent">1.4 Node.prototype.textContent</h4> <p><code class="language-plaintext highlighter-rouge">textContent</code> 属性返回<strong>当前节点和它的所有后代节点</strong>的<strong>文本内容</strong>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">textContent</code> 属性自动忽略当前节点内部的 HTML 标签，返回所有<strong>文本内容</strong>。</li> <li>该属性<strong>可读写</strong>，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它会自动对 HTML 标签转义。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;div id="divA"&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span>

<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">divA</span><span class="dl">'</span><span class="p">).</span><span class="nx">textContent</span>
<span class="c1">// This is some text</span>
</code></pre></div></div> <h4 id="15-nodeprototypebaseuri">1.5 Node.prototype.baseURI</h4> <p><code class="language-plaintext highlighter-rouge">baseURI</code> 属性返回一个字符串，表示当前网页的<strong>绝对路径</strong>。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为<strong>只读</strong>。</p> <p>该属性的值一般由当前网址的 URL（即 <code class="language-plaintext highlighter-rouge">window.location</code> 属性）决定，但是可以使用 HTML 的 <code class="language-plaintext highlighter-rouge">&lt;base&gt;</code> 标签，改变该属性的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 当前网页的网址为</span>
<span class="c1">// http://www.example.com/index.html</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">baseURI</span>
<span class="c1">// "http://www.example.com/index.html"</span>

<span class="o">&lt;</span><span class="nx">base</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">http://www.example.com/page.html</span><span class="dl">"</span><span class="o">&gt;</span>
</code></pre></div></div> <h4 id="16-nodeprototypeownerdocument">1.6 Node.prototype.ownerDocument</h4> <p><code class="language-plaintext highlighter-rouge">Node.ownerDocument</code> 属性返回当前节点所在的顶层文档对象，即 <code class="language-plaintext highlighter-rouge">document</code> 对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ownerDocument</span><span class="p">;</span>
<span class="nx">d</span> <span class="o">===</span> <span class="nb">document</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="17-nodeprototypeprevioussiblingnodeprototypenextsibling">1.7 Node.prototype.previousSibling，Node.prototype.nextSibling</h4> <ul> <li><code class="language-plaintext highlighter-rouge">previousSibling</code> 属性返回当前节点<strong>前面的</strong>、<strong>距离最近的一个同级节点</strong>。如果当前节点前面没有同级节点，则返回 <code class="language-plaintext highlighter-rouge">null</code>。 <code class="language-plaintext highlighter-rouge">nextSibling</code> 属性返回紧跟在当前节点<strong>后面的第一个同级节点</strong>。如果当前节点后面没有同级节点，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d2</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d2</span><span class="p">.</span><span class="nx">previousSibling</span> <span class="o">===</span> <span class="nx">d1</span> <span class="c1">// true</span>

<span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d2</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d1</span><span class="p">.</span><span class="nx">nextSibling</span> <span class="o">===</span> <span class="nx">d2</span> <span class="c1">// true</span>
</code></pre></div></div> <p>注意，这两个属性还包括文本节点和注释节点（）。因此如果当前节点前面/后面有空格，他们都会返回一个文本节点，内容为空格。</p> <h4 id="18-nodeprototypeparentnode">1.8 Node.prototype.parentNode</h4> <ul> <li><code class="language-plaintext highlighter-rouge">parentNode</code> 属性返回当前节点的<strong>父节点</strong>。对于一个节点来说，它的父节点只可能是三种类型：<strong>元素节点</strong>（element）、<strong>文档节点</strong>（document）和<strong>文档片段节点</strong>（documentfragment）。文档节点（document）和文档片段节点（documentfragment）的父节点都是 <code class="language-plaintext highlighter-rouge">null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">parentElement</code> 属性返回当前节点的<strong>父元素节点</strong>。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回 <code class="language-plaintext highlighter-rouge">null</code>。由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code class="language-plaintext highlighter-rouge">parentElement</code> 属性相当于把后两种父节点都排除了。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="19-nodeprototypefirstchildnodeprototypelastchild">1.9 Node.prototype.firstChild，Node.prototype.lastChild</h4> <ul> <li><code class="language-plaintext highlighter-rouge">firstChild</code> 属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">firstChild</code> 返回的除了元素节点，还可能是文本节点或注释节点。</li> <li><code class="language-plaintext highlighter-rouge">lastChild</code> 属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回 <code class="language-plaintext highlighter-rouge">null</code>。用法与 <code class="language-plaintext highlighter-rouge">firstChild</code> 属性相同。</li> </ul> <h4 id="110-nodeprototypechildnodes">1.10 Node.prototype.childNodes</h4> <p><code class="language-plaintext highlighter-rouge">childNodes</code> 属性返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">NodeList</code> 集合），成员包括当前节点的所有子节点。</p> <p><code class="language-plaintext highlighter-rouge">childNodes</code> 属性的返回值包括<strong>元素节点</strong>、<strong>文本节点</strong>和<strong>注释节点</strong>。如果当前节点不包括任何子节点，则返回一个空的 <code class="language-plaintext highlighter-rouge">NodeList</code> 集合。由于 <code class="language-plaintext highlighter-rouge">NodeList</code> 对象是一个<strong>动态集合</strong>，一旦子节点发生变化，立刻会反映在返回结果之中。</p> <h4 id="111-nodeprototypeisconnected">1.11 Node.prototype.isConnected</h4> <p><code class="language-plaintext highlighter-rouge">isConnected</code> 属性返回一个布尔值，表示当前节点是否在文档之中。</p> <h3 id="2-方法">2. 方法</h3> <h4 id="21-nodeprototypeappendchild">2.1 Node.prototype.appendChild()</h4> <p><code class="language-plaintext highlighter-rouge">appendChild()</code> 方法接受一个节点对象作为参数，将其作为<strong>最后一个</strong>子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</code></pre></div></div> <p>如果参数节点是 DOM 已经存在的节点，<code class="language-plaintext highlighter-rouge">appendChild()</code> 方法会将其从原来的位置，<strong>移动</strong>到新位置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">div</span><span class="p">);</span>
</code></pre></div></div> <h4 id="22-nodeprototypehaschildnodes">2.2 Node.prototype.hasChildNodes()</h4> <p><code class="language-plaintext highlighter-rouge">hasChildNodes()</code> 方法返回一个布尔值，表示当前节点是否有子节点（子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code class="language-plaintext highlighter-rouge">hasChildNodes()</code> 方法也会返回 <code class="language-plaintext highlighter-rouge">true</code>。）。</p> <h4 id="23-nodeprototypeclonenode">2.3 Node.prototype.cloneNode()</h4> <p><code class="language-plaintext highlighter-rouge">cloneNode()</code> 方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">cloneUL</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">).</span><span class="nf">cloneNode</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>克隆一个节点，会拷贝该节点的所有属性，但是会丧失 <code class="language-plaintext highlighter-rouge">addEventListener()</code> 方法和 <code class="language-plaintext highlighter-rouge">on-属性</code>（即 <code class="language-plaintext highlighter-rouge">node.onclick = fn</code>），添加在这个节点上的事件回调函数。</li> <li>该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如 <code class="language-plaintext highlighter-rouge">Node.appendChild()</code> 这样的方法添加到文档之中。</li> <li>克隆一个节点之后，DOM 有可能出现两个有相同 <code class="language-plaintext highlighter-rouge">id</code> 属性的网页元素，这时应该修改其中一个元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性。如果原节点有 <code class="language-plaintext highlighter-rouge">name</code> 属性，可能也需要修改。</li> </ul> <h4 id="24-nodeprototypeinsertbefore">2.4 Node.prototype.insertBefore()</h4> <p><code class="language-plaintext highlighter-rouge">insertBefore()</code> 方法用于将某个节点插入父节点内部的指定位置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">insertBefore</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，新建一个 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 节点，插在 <code class="language-plaintext highlighter-rouge">document.body.firstChild</code> 的前面，也就是成为 <code class="language-plaintext highlighter-rouge">document.body</code> 的第一个子节点。</p> <p><code class="language-plaintext highlighter-rouge">insertBefore()</code> 方法接受两个参数：</p> <ul> <li>第一个参数是所要插入的节点 <code class="language-plaintext highlighter-rouge">newNode</code>。</li> <li>第二个参数是父节点 <code class="language-plaintext highlighter-rouge">parentNode</code> 内部的一个子节点 <code class="language-plaintext highlighter-rouge">referenceNode</code>。如果第二个参数为 <code class="language-plaintext highlighter-rouge">null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</li> </ul> <p>由于不存在 <code class="language-plaintext highlighter-rouge">insertAfter</code> 方法，如果新节点要插在父节点的某个子节点后面，可以用 <code class="language-plaintext highlighter-rouge">insertBefore()</code> 方法结合 <code class="language-plaintext highlighter-rouge">nextSibling</code> 属性模拟。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parent</span><span class="p">.</span><span class="nf">insertBefore</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">parent</code> 是父节点，<code class="language-plaintext highlighter-rouge">s1</code> 是一个全新的节点，<code class="language-plaintext highlighter-rouge">s2</code> 是可以将 <code class="language-plaintext highlighter-rouge">s1</code> 节点，插在 <code class="language-plaintext highlighter-rouge">s2</code> 节点的后面。如果 <code class="language-plaintext highlighter-rouge">s2</code> 是当前节点的最后一个子节点，则 <code class="language-plaintext highlighter-rouge">s2.nextSibling</code> 返 回 <code class="language-plaintext highlighter-rouge">null</code>，这时 <code class="language-plaintext highlighter-rouge">s1</code> 节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在 <code class="language-plaintext highlighter-rouge">s2</code> 的后面。</p> <h4 id="25-nodeprototyperemovechild">2.5 Node.prototype.removeChild()</h4> <p><code class="language-plaintext highlighter-rouge">removeChild()</code> 方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">divA</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">divA</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">divA</span><span class="p">);</span>
</code></pre></div></div> <h4 id="26-nodeprototypereplacechild">2.6 Node.prototype.replaceChild()</h4> <p><code class="language-plaintext highlighter-rouge">replaceChild()</code> 方法用于将一个新的节点，替换当前节点的某一个子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">replacedNode</span> <span class="o">=</span> <span class="nx">parentNode</span><span class="p">.</span><span class="nf">replaceChild</span><span class="p">(</span><span class="nx">newChild</span><span class="p">,</span> <span class="nx">oldChild</span><span class="p">);</span>
</code></pre></div></div> <h4 id="27-nodeprototypecontains">2.7 Node.prototype.contains()</h4> <p><code class="language-plaintext highlighter-rouge">contains()</code> 方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p> <ul> <li>参数节点为<strong>当前节点</strong>。</li> <li>参数节点为当前节点的<strong>子节点</strong>。</li> <li>参数节点为当前节点的<strong>后代节点</strong>。</li> </ul> <h4 id="28-nodeprototypecomparedocumentposition">2.8 Node.prototype.compareDocumentPosition()</h4> <p><code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 方法的用法，与 <code class="language-plaintext highlighter-rouge">contains()</code> 方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的<strong>关系</strong>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">000000</code>：十进制的 0，表示两个节点<strong>相同</strong></li> <li><code class="language-plaintext highlighter-rouge">000001</code>：十进制的 1，表示两个节点不在同一个文档（即有一个节点不在当前文档）</li> <li><code class="language-plaintext highlighter-rouge">000010</code>：十进制的 2，表示参数节点在当前节点的<strong>前面</strong></li> <li><code class="language-plaintext highlighter-rouge">000100</code>：十进制的 4，表示参数节点在当前节点的<strong>后面</strong></li> <li><code class="language-plaintext highlighter-rouge">001000</code>：十进制的 8，表示参数节点<strong>包含</strong>当前节点</li> <li><code class="language-plaintext highlighter-rouge">010000</code>：十进制的 16，表示当前节点<strong>包含</strong>参数节点</li> <li><code class="language-plaintext highlighter-rouge">100000</code>：十进制的 32，表示浏览器内部使用</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="mydiv"&gt;</span>
<span class="c1">//   &lt;form&gt;&lt;input id="test" /&gt;&lt;/form&gt;</span>
<span class="c1">// &lt;/div&gt;</span>

<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">mydiv</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="c1">// 20</span>
<span class="nx">input</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">div</span><span class="p">)</span> <span class="c1">// 10</span>
</code></pre></div></div> <p>上面代码中，节点 <code class="language-plaintext highlighter-rouge">div</code> 包含节点 <code class="language-plaintext highlighter-rouge">input</code>（二进制 <code class="language-plaintext highlighter-rouge">010000</code>），而且节点 <code class="language-plaintext highlighter-rouge">input</code> 在节点 <code class="language-plaintext highlighter-rouge">div</code> 的后面（二进制 <code class="language-plaintext highlighter-rouge">000100</code>），所以第一个 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 方法返回 <code class="language-plaintext highlighter-rouge">20</code>（二进制 <code class="language-plaintext highlighter-rouge">010100</code>，即 <code class="language-plaintext highlighter-rouge">010000</code> + <code class="language-plaintext highlighter-rouge">000100</code>），第二个 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 方法返回 <code class="language-plaintext highlighter-rouge">10</code>（二进制 <code class="language-plaintext highlighter-rouge">001010</code>）。</p> <p>由于 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 返回值的含义，定义在每个比特位上，所以如果要检查某种特定的含义，就需要使用比特位运算符。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">head</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">文档结构正确</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;body&gt; 不能在 &lt;head&gt; 前面</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 的返回值与 <code class="language-plaintext highlighter-rouge">4</code>（又称掩码）进行与运算（<code class="language-plaintext highlighter-rouge">&amp;</code>），得到一个布尔值，表示 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 是否在 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 前面。</p> <h4 id="29-nodeprototypeisequalnodenodeprototypeissamenode">2.9 Node.prototype.isEqualNode()，Node.prototype.isSameNode()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">isEqualNode()</code> 方法返回一个布尔值，用于检查两个节点是否<strong>相等</strong>。所谓相等的节点，指的是两个节点的<strong>类型</strong>相同、<strong>属性</strong>相同、<strong>子节点</strong>相同。</li> <li><code class="language-plaintext highlighter-rouge">isSameNode()</code> 方法返回一个布尔值，表示两个节点是否为<strong>同一个</strong>节点。</li> </ul> <h4 id="210-nodeprototypenormalize">2.10 Node.prototype.normalize()</h4> <p><code class="language-plaintext highlighter-rouge">normalize()</code> 方法用于清理当前节点内部的所有<strong>文本节点</strong>（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。该方法是 <code class="language-plaintext highlighter-rouge">Text.splitText()</code> 的逆方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">wrapper</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">Part 1 </span><span class="dl">'</span><span class="p">));</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">Part 2 </span><span class="dl">'</span><span class="p">));</span>

<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nf">normalize</span><span class="p">();</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>上面代码使用 <code class="language-plaintext highlighter-rouge">normalize()</code> 方法之前，<code class="language-plaintext highlighter-rouge">wrapper</code> 节点有两个毗邻的文本子节点。使 <code class="language-plaintext highlighter-rouge">normalize()</code> 方法之后，两个文本子节点被合并成一个。</p> <h4 id="211-nodeprototypegetrootnode">2.11 Node.prototype.getRootNode()</h4> <p><code class="language-plaintext highlighter-rouge">getRootNode()</code> 方法返回当前节点所在文档的根节点 <code class="language-plaintext highlighter-rouge">document</code>，与 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性的作用相同。</p> <h2 id="三nodelist-接口htmlcollection-接口">三、NodeList 接口，HTMLCollection 接口</h2> <p>DOM 提供两种节点集合，用于容纳多个节点：<code class="language-plaintext highlighter-rouge">NodeList</code> 和 <code class="language-plaintext highlighter-rouge">HTMLCollection</code>。<code class="language-plaintext highlighter-rouge">NodeList</code> 可以包含各种类型的节点，<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 只能包含 HTML 元素节点。</p> <h3 id="1-nodelist-接口">1. NodeList 接口</h3> <h4 id="11-概述">1.1 概述</h4> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Node.childNodes</code></li> <li><code class="language-plaintext highlighter-rouge">document.querySelectorAll()</code> 等节点搜索方法</li> </ul> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 是对象不是数组，但可以使用 <code class="language-plaintext highlighter-rouge">length</code> 属性和 <code class="language-plaintext highlighter-rouge">forEach()</code> 方法。如果要使用数组的其他方法，应先将其转为数组。</p> <p>注意，<code class="language-plaintext highlighter-rouge">NodeList</code> 实例可能是<strong>动态集合</strong>，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例。目前，只有 <code class="language-plaintext highlighter-rouge">Node.childNodes</code> 返回的是一个动态集合，其他的 <code class="language-plaintext highlighter-rouge">NodeList</code> 都是静态集合。</p> <h4 id="12-nodelistprototypelength">1.2 NodeList.prototype.length</h4> <p><code class="language-plaintext highlighter-rouge">length</code> 属性返回 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例包含的节点数量。</p> <h4 id="13-nodelistprototypeforeach">1.3 NodeList.prototype.forEach()</h4> <p><code class="language-plaintext highlighter-rouge">forEach()</code> 方法用于遍历 <code class="language-plaintext highlighter-rouge">NodeList</code> 的所有成员。</p> <h4 id="14-nodelistprototypeitem">1.4 NodeList.prototype.item()</h4> <p><code class="language-plaintext highlighter-rouge">item()</code> 方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（<code class="language-plaintext highlighter-rouge">[]</code>），而不使用 <code class="language-plaintext highlighter-rouge">item()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div> <h4 id="15-nodelistprototypekeysnodelistprototypevaluesnodelistprototypeentries">1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h4> <p>这三个方法都返回一个 ES6 的<strong>遍历器对象</strong>，可以通过 <code class="language-plaintext highlighter-rouge">for...of</code> 循环遍历获取每一个成员的信息。区别在于，<code class="language-plaintext highlighter-rouge">keys()</code> 返回键名的遍历器，<code class="language-plaintext highlighter-rouge">values()</code> 返回键值的遍历器，<code class="language-plaintext highlighter-rouge">entries()</code> 返回的遍历器同时包含键名和键值的信息。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>

<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">children</span><span class="p">.</span><span class="nf">keys</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 0</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
<span class="c1">// ...</span>

<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">children</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// #text</span>
<span class="c1">// &lt;script&gt;</span>
<span class="c1">// ...</span>

<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">entry</span> <span class="k">of</span> <span class="nx">children</span><span class="p">.</span><span class="nf">entries</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Array [ 0, #text ]</span>
<span class="c1">// Array [ 1, &lt;script&gt; ]</span>
<span class="c1">// ...</span>
</code></pre></div></div> <h3 id="2-htmlcollection-接口">2. HTMLCollection 接口</h3> <h4 id="21-概述">2.1 概述</h4> <p><code class="language-plaintext highlighter-rouge">HTMLCollection</code> 是一个只包含<strong>元素节点</strong>（element）对象的集合，，不包含其他类型的节点。它的返回值是一个类似数组的对象，<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 只能使用 <code class="language-plaintext highlighter-rouge">for</code> 循环遍历。</p> <p>返回 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例的，主要是一些 <code class="language-plaintext highlighter-rouge">Document</code> 对象的集合属性，比如 <code class="language-plaintext highlighter-rouge">document.links</code>、<code class="language-plaintext highlighter-rouge">document.forms</code>、<code class="language-plaintext highlighter-rouge">document.images</code> 等。</p> <p>如果元素节点有 <code class="language-plaintext highlighter-rouge">id</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 属性，那么 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例上面，可以使用 <code class="language-plaintext highlighter-rouge">id</code> 属性或 <code class="language-plaintext highlighter-rouge">name</code> 属性引用该节点元素。如果没有对应的节点，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span>

<span class="kd">var</span> <span class="nx">pic</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">.</span><span class="nx">pic</span> <span class="o">===</span> <span class="nx">pic</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">document.images</code> 是一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，可以通过 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性值，从 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例上取到这个元素。</p> <h4 id="22-htmlcollectionprototypelength">2.2 HTMLCollection.prototype.length</h4> <p><code class="language-plaintext highlighter-rouge">length</code> 属性返回 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例包含的成员数量。</p> <h4 id="23-htmlcollectionprototypeitem">2.3 HTMLCollection.prototype.item()</h4> <p><code class="language-plaintext highlighter-rouge">item()</code> 方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（<code class="language-plaintext highlighter-rouge">[]</code>），而不使用 <code class="language-plaintext highlighter-rouge">item()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">img0</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div> <h4 id="24-htmlcollectionprototypenameditem">2.4 HTMLCollection.prototype.namedItem()</h4> <p><code class="language-plaintext highlighter-rouge">namedItem()</code> 方法的参数是一个字符串，表示 <code class="language-plaintext highlighter-rouge">id</code> 属性或 <code class="language-plaintext highlighter-rouge">name</code> 属性的值，返回当前集合中对应的元素节点。如果没有对应的节点，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span>

<span class="kd">var</span> <span class="nx">pic</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">.</span><span class="nf">namedItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">)</span> <span class="o">===</span> <span class="nx">pic</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Collection.namedItem('value')</code> 等同于 <code class="language-plaintext highlighter-rouge">Collection['value']</code>。</p> <h2 id="四parentnode-接口childnode-接口">四、ParentNode 接口，ChildNode 接口</h2> <p>节点对象除了继承 <code class="language-plaintext highlighter-rouge">Node</code> 接口以外，还拥有其他接口。<code class="language-plaintext highlighter-rouge">ParentNode</code> 接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code class="language-plaintext highlighter-rouge">ChildNode</code> 接口表示当前节点是一个子节点，提供一些相关方法。</p> <h3 id="1-parentnode-接口">1. ParentNode 接口</h3> <p>如果当前节点是父节点，就会混入（mixin）<code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。只有<strong>元素节点</strong>（element）、<strong>文档节点</strong>（document）和<strong>文档片段节点</strong>（documentFragment）拥有 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。</p> <h4 id="11-parentnodechildren">1.1 ParentNode.children</h4> <p><code class="language-plaintext highlighter-rouge">children</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是当前节点的<strong>所有元素子节点</strong>。该属性只读。</p> <h4 id="12-parentnodefirstelementchildparentnodelastelementchild">1.2 ParentNode.firstElementChild，ParentNode.lastElementChild</h4> <ul> <li><code class="language-plaintext highlighter-rouge">firstElementChild</code> 属性返回当前节点的<strong>第一个元素子节点</strong>。</li> <li><code class="language-plaintext highlighter-rouge">lastElementChild</code> 属性返回当前节点的<strong>最后一个元素子节点</strong>。</li> </ul> <h4 id="13-parentnodechildelementcount">1.3 ParentNode.childElementCount</h4> <p><code class="language-plaintext highlighter-rouge">childElementCount</code> 属性返回一个整数，表示当前节点的所有元素子节点的数目。</p> <h4 id="14-parentnodeappendparentnodeprepend">1.4 ParentNode.append()，ParentNode.prepend()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">append()</code> 方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。该方法可以添加<strong>元素节点</strong>（参数为元素节点）和<strong>文本节点</strong>（参数为字符串）。</li> <li><code class="language-plaintext highlighter-rouge">prepend()</code> 方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与 <code class="language-plaintext highlighter-rouge">append()</code> 方法完全一致，也是没有返回值。</li> </ul> <p>注意，<code class="language-plaintext highlighter-rouge">append()</code> 方法与 <code class="language-plaintext highlighter-rouge">Node.prototype.appendChild()</code> 方法有三点不同。</p> <ul> <li><code class="language-plaintext highlighter-rouge">append()</code> 允许字符串作为参数，<code class="language-plaintext highlighter-rouge">appendChild()</code> 只允许子节点作为参数。</li> <li><code class="language-plaintext highlighter-rouge">append()</code> 没有返回值，而 <code class="language-plaintext highlighter-rouge">appendChild()</code> 返回添加的子节点。</li> <li><code class="language-plaintext highlighter-rouge">append()</code> 可以添加多个子节点和字符串（即允许多个参数），<code class="language-plaintext highlighter-rouge">appendChild()</code> 只能添加一个节点（即只允许一个参数）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>

<span class="c1">// 添加元素子节点</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

<span class="c1">// 添加文本子节点</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 添加多个元素子节点</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">);</span>

<span class="c1">// 添加元素子节点和文本子节点</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span> <span class="nx">p</span><span class="p">);</span>
</code></pre></div></div> <h3 id="2-childnode-接口">2. ChildNode 接口</h3> <p>如果一个节点有父节点，那么该节点就拥有了 <code class="language-plaintext highlighter-rouge">ChildNode</code> 接口。</p> <h4 id="21-childnoderemove">2.1 ChildNode.remove()</h4> <p><code class="language-plaintext highlighter-rouge">remove()</code> 方法用于从父节点移除当前节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nf">remove</span><span class="p">()</span>
</code></pre></div></div> <h4 id="22-childnodebeforechildnodeafter">2.2 ChildNode.before()，ChildNode.after()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">before()</code> 方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。该方法可以插入<strong>元素节点</strong>和<strong>文本节点</strong>。</li> <li><code class="language-plaintext highlighter-rouge">after()</code> 方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与 <code class="language-plaintext highlighter-rouge">before()</code> 方法完全相同。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 插入元素节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

<span class="c1">// 插入文本节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 插入多个元素节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">p1</span><span class="p">);</span>

<span class="c1">// 插入元素节点和文本节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <h4 id="23-childnodereplacewith">2.3 ChildNode.replaceWith()</h4> <p><code class="language-plaintext highlighter-rouge">replaceWith()</code> 方法使用参数节点，替换当前节点。参数可以是<strong>元素节点</strong>，也可以是<strong>文本节点</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">span</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">span</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">replaceWith</span><span class="p">(</span><span class="nx">span</span><span class="p">);</span>
</code></pre></div></div> <h2 id="五document-节点">五、Document 节点</h2> <h3 id="1-概述">1. 概述</h3> <p><code class="language-plaintext highlighter-rouge">document</code> 节点对象代表整个文档，每张网页都有自己的 <code class="language-plaintext highlighter-rouge">document</code> 对象。<code class="language-plaintext highlighter-rouge">window.document</code> 属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p> <p><code class="language-plaintext highlighter-rouge">document</code> 对象有不同的办法可以获取。</p> <ul> <li>正常的网页，直接使用 <code class="language-plaintext highlighter-rouge">document</code> 或 <code class="language-plaintext highlighter-rouge">window.document</code>。</li> <li><code class="language-plaintext highlighter-rouge">iframe</code> 框架里面的网页，使用 iframe 节点的 <code class="language-plaintext highlighter-rouge">contentDocument</code> 属性。</li> <li>Ajax 操作返回的文档，使用 <code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> 对象的 <code class="language-plaintext highlighter-rouge">responseXML</code> 属性。</li> <li>内部节点的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document</code> 对象继承了 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口和 <code class="language-plaintext highlighter-rouge">Node</code> 接口，并且混入（mixin）了 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。这意味着，这些接口的方法都可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象上调用。除此之外，<code class="language-plaintext highlighter-rouge">document</code> 对象还有很多自己的属性和方法。</p> <h3 id="2-属性">2. 属性</h3> <h4 id="21-快捷方式属性">2.1 快捷方式属性</h4> <p>以下属性是指向文档内部的某个节点的快捷方式。</p> <ul> <li><code class="language-plaintext highlighter-rouge">document.defaultView</code>：返回 <code class="language-plaintext highlighter-rouge">document</code> 对象所属的 <code class="language-plaintext highlighter-rouge">window</code> 对象。如果当前文档不属于 <code class="language-plaintext highlighter-rouge">window</code> 对象，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">document.doctype</code>：<code class="language-plaintext highlighter-rouge">document</code> 对象一般有两个子节点。第一个子节点是 <code class="language-plaintext highlighter-rouge">document.doctype</code>，指向 <code class="language-plaintext highlighter-rouge">&lt;DOCTYPE&gt;</code> 节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>。</li> <li><code class="language-plaintext highlighter-rouge">document.documentElement</code>：返回当前文档的<strong>根元素节点</strong>（root）。它通常是 <code class="language-plaintext highlighter-rouge">document</code> 节点的第二个子节点，紧跟在 <code class="language-plaintext highlighter-rouge">document.doctype</code> 节点后面。HTML 网页的该属性，一般是 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 节点。</li> <li><code class="language-plaintext highlighter-rouge">document.head</code>：指向 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 节点，该属性<strong>可读写</strong>。</li> <li><code class="language-plaintext highlighter-rouge">document.body</code>：指向 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 节点，该属性<strong>可读写</strong>。</li> <li><code class="language-plaintext highlighter-rouge">document.scrollingElement</code>：返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。标准模式下，这个属性返回的文档的根元素 <code class="language-plaintext highlighter-rouge">document.documentElement</code>（即 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code>）。兼容（quirk）模式下，返回的是 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素，如果该元素不存在，返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">document.activeElement</code>：返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;textarea&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;select&gt;</code> 等表单元素，如果当前没有焦点元素，返回 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素或 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">document.fullscreenElement</code>：返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> </ul> <h4 id="22-节点集合属性">2.2 节点集合属性</h4> <p>以下属性（除 <code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性外）返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，表示文档内部特定元素的集合。这些集合都是<strong>动态的</strong>，原节点有任何变化，立刻会反映在集合中。</p> <ul> <li><code class="language-plaintext highlighter-rouge">document.links</code>：返回当前文档所有设定了 href 属性的 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 及 <code class="language-plaintext highlighter-rouge">&lt;area&gt;</code> 节点。</li> <li><code class="language-plaintext highlighter-rouge">document.forms</code>：返回所有 <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> 表单节点。</li> <li><code class="language-plaintext highlighter-rouge">document.images</code>：返回页面所有 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 图片节点。</li> <li><code class="language-plaintext highlighter-rouge">document.embeds</code>，<code class="language-plaintext highlighter-rouge">document.plugins</code>：所有 <code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 节点。</li> <li><code class="language-plaintext highlighter-rouge">document.scripts</code>：返回所有 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 节点。</li> <li><code class="language-plaintext highlighter-rouge">document.styleSheets</code>：返回网页内嵌或引入的 CSS 样式表集合。</li> </ul> <p>除了 <code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性，以上的其他集合属性返回的都是 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例。<code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性返回的是 <code class="language-plaintext highlighter-rouge">StyleSheetList</code> 实例。</p> <h4 id="23-文档静态信息属性">2.3 文档静态信息属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.documentURI</code>，<code class="language-plaintext highlighter-rouge">document.URL</code>：返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code class="language-plaintext highlighter-rouge">documentURI</code> 继承自 <code class="language-plaintext highlighter-rouge">Document</code> 接口，可用于所有文档；<code class="language-plaintext highlighter-rouge">URL</code> 继承自 <code class="language-plaintext highlighter-rouge">HTMLDocument</code> 接口，只能用于 HTML 文档。</li> <li><code class="language-plaintext highlighter-rouge">document.domain</code>：返回当前文档的<strong>域名</strong>，不包含协议和端口。</li> <li><code class="language-plaintext highlighter-rouge">document.location</code>：<code class="language-plaintext highlighter-rouge">Location</code> 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 <code class="language-plaintext highlighter-rouge">window.location</code> 和 <code class="language-plaintext highlighter-rouge">document.location</code> 属性，可以拿到这个对象。</li> <li><code class="language-plaintext highlighter-rouge">document.lastModified</code>：返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</li> <li><code class="language-plaintext highlighter-rouge">document.title</code>：返回当前文档的标题。默认情况下，返回 <code class="language-plaintext highlighter-rouge">&lt;title&gt;</code> 节点的值。该属性<strong>可读写</strong>。</li> <li><code class="language-plaintext highlighter-rouge">document.characterSet</code>：返回当前文档的编码，比如 UTF-8 等等。</li> <li><code class="language-plaintext highlighter-rouge">document.referrer</code>：返回一个字符串，表示当前文档的访问者来自哪里。<code class="language-plaintext highlighter-rouge">document.referrer</code> 的值，总是与 HTTP 头信息的 <code class="language-plaintext highlighter-rouge">Referer</code> 字段保持一致。</li> <li><code class="language-plaintext highlighter-rouge">document.dir</code>：返回一个字符串，表示文字方向。它有两个可能的值：<code class="language-plaintext highlighter-rouge">rtl</code> 表示文字从右到左，阿拉伯文是这种方式；<code class="language-plaintext highlighter-rouge">ltr</code> 表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</li> <li><code class="language-plaintext highlighter-rouge">document.compatMode</code>：返回浏览器处理文档的模式，可能的值为 <code class="language-plaintext highlighter-rouge">BackCompat</code>（向后兼容模式）和 <code class="language-plaintext highlighter-rouge">CSS1Compat</code>（严格模式）。一般来说，如果网页代码的第一行设置了明确的 <code class="language-plaintext highlighter-rouge">DOCTYPE</code>（比如 <code class="language-plaintext highlighter-rouge">&lt;!doctype html&gt;</code>），<code class="language-plaintext highlighter-rouge">document.compatMode</code> 的值都为 <code class="language-plaintext highlighter-rouge">CSS1Compat</code>。</li> </ul> <h4 id="24-文档状态属性">2.4 文档状态属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.hidden</code>：返回一个布尔值，表示当前页面<strong>是否可见</strong>。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得 <code class="language-plaintext highlighter-rouge">document.hidden</code> 返回 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.visibilityState</code>：返回文档的<strong>可见状态</strong>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li> <li><code class="language-plaintext highlighter-rouge">hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li> <li><code class="language-plaintext highlighter-rouge">prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li> <li><code class="language-plaintext highlighter-rouge">unloaded</code>：页面从内存里面卸载了。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">document.readyState</code>：返回当前文档的<strong>状态</strong>，共有三种可能的值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">loading</code>：加载 HTML 代码阶段（尚未完成解析）。</li> <li><code class="language-plaintext highlighter-rouge">interactive</code>：加载外部资源阶段。</li> <li><code class="language-plaintext highlighter-rouge">complete</code>：加载完成。</li> </ul> </li> </ul> <p><code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变化的过程如下。</p> <ol> <li>浏览器开始解析 HTML 文档，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性等于 <code class="language-plaintext highlighter-rouge">loading</code>。</li> <li>浏览器遇到 HTML 文档中的 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，并且没有 <code class="language-plaintext highlighter-rouge">async</code> 或 <code class="language-plaintext highlighter-rouge">defer</code> 属性，就暂停解析，开始执行脚本，这时 <code class="language-plaintext highlighter-rouge">document.readyState</code> 属性还是 <code class="language-plaintext highlighter-rouge">loading</code>。</li> <li>HTML 文档解析完成，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变成 <code class="language-plaintext highlighter-rouge">interactive</code>。</li> <li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变成 <code class="language-plaintext highlighter-rouge">complete</code>。</li> </ol> <h4 id="25-documentcookie">2.5 document.cookie</h4> <p><code class="language-plaintext highlighter-rouge">document.cookie</code> 属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。</p> <h4 id="26-documentdesignmode">2.6 document.designMode</h4> <p><code class="language-plaintext highlighter-rouge">document.designMode</code> 属性控制当前文档是否可编辑。该属性只有两个值 <code class="language-plaintext highlighter-rouge">on</code> 和 <code class="language-plaintext highlighter-rouge">off</code>，默认值为 <code class="language-plaintext highlighter-rouge">off</code>。</p> <h4 id="27-documentcurrentscript">2.7 document.currentScript</h4> <p><code class="language-plaintext highlighter-rouge">document.currentScript</code> 属性只用在 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素的 DOM 节点。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">id=</span><span class="s">"foo"</span><span class="nt">&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">currentScript</span> <span class="o">===</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">);</span> <span class="c1">// true</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">document.currentScript</code> 就是 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素节点。</p> <h4 id="28-documentimplementation">2.8 document.implementation</h4> <p><code class="language-plaintext highlighter-rouge">document.implementation</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">DOMImplementation</code> 对象。该对象有三个方法，主要用于创建独立于当前文档的新的 <code class="language-plaintext highlighter-rouge">Document</code> 对象。</p> <ul> <li><code class="language-plaintext highlighter-rouge">DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li> <li><code class="language-plaintext highlighter-rouge">DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li> <li><code class="language-plaintext highlighter-rouge">DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li> </ul> <p>下面是创建 HTML 文档的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">implementation</span><span class="p">.</span><span class="nf">createHTMLDocument</span><span class="p">(</span><span class="dl">'</span><span class="s1">Title</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

<span class="nb">document</span><span class="p">.</span><span class="nf">replaceChild</span><span class="p">(</span>
  <span class="nx">doc</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span>
<span class="p">);</span>
</code></pre></div></div> <p>上面代码中，第一步生成一个新的 HTML 文档 <code class="language-plaintext highlighter-rouge">doc</code>，然后用它的根元素 <code class="language-plaintext highlighter-rouge">doc.documentElement</code> 替换掉 <code class="language-plaintext highlighter-rouge">document.documentElement</code>。这会使得当前文档的内容全部消失，变成 <code class="language-plaintext highlighter-rouge">hello world</code>。</p> <h3 id="3-方法">3. 方法</h3> <h4 id="31-documentopendocumentclose">3.1 document.open()，document.close()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.open()</code> 方法清除当前文档所有内容，使得文档处于<strong>可写状态</strong>，供 <code class="language-plaintext highlighter-rouge">document.write</code> 方法写入内容。</li> <li><code class="language-plaintext highlighter-rouge">document.close()</code> 方法用来关闭 <code class="language-plaintext highlighter-rouge">document.open()</code> 打开的文档。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">open</span><span class="p">();</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
</code></pre></div></div> <h4 id="32-documentwritedocumentwriteln">3.2 document.write()，document.writeln()</h4> <p><code class="language-plaintext highlighter-rouge">document.write()</code> 方法用于向当前文档写入内容。<code class="language-plaintext highlighter-rouge">document.write</code> 是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对 <code class="language-plaintext highlighter-rouge">innerHTML</code> 属性赋值）。所以，除了某些特殊情况，应该尽量<strong>避免使用</strong> <code class="language-plaintext highlighter-rouge">document.write()</code> 这个方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">document.write()</code> 会当作 HTML 代码解析，不会转义。</li> <li>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行 <code class="language-plaintext highlighter-rouge">document.close()</code>），<code class="language-plaintext highlighter-rouge">document.write()</code> 写入的内容就会追加在已有内容的后面。</li> <li>如果页面已经解析完成（<code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件发生之后），再调用 <code class="language-plaintext highlighter-rouge">write()</code> 方法，它会先调用 <code class="language-plaintext highlighter-rouge">open()</code> 方法，擦除当前文档所有内容，然后再写入。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document.writeln()</code> 方法与 <code class="language-plaintext highlighter-rouge">write()</code> 方法完全一致，除了会在输出内容的尾部添加换行符。注意，<code class="language-plaintext highlighter-rouge">document.writeln()</code> 方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入 <code class="language-plaintext highlighter-rouge">&lt;br&gt;</code>。</p> <h4 id="33-documentqueryselectordocumentqueryselectorall">3.3 document.querySelector()，document.querySelectorAll()</h4> <p><code class="language-plaintext highlighter-rouge">document.querySelector()</code> 方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回<strong>第一个</strong>匹配的节点。 <code class="language-plaintext highlighter-rouge">document.querySelectorAll()</code> 方法与 <code class="language-plaintext highlighter-rouge">querySelector()</code> 用法类似，区别是返回一个 <code class="language-plaintext highlighter-rouge">NodeList</code> 对象，包含所有匹配给定选择器的节点。</p> <p>这两个方法不支持 CSS 伪元素的选择器（比如 <code class="language-plaintext highlighter-rouge">:first-line</code> 和 <code class="language-plaintext highlighter-rouge">:first-letter</code>）和伪类的选择器（比如 <code class="language-plaintext highlighter-rouge">:link</code> 和 <code class="language-plaintext highlighter-rouge">:visited</code>），即无法选中伪元素和伪类。</p> <p>这两个方法都可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</p> <h4 id="34-documentgetelementbyiddocumentgetelementsbynamedocumentgetelementsbyclassnamedocumentgetelementsbytagname">3.4 document.getElementById()，document.getElementsByName()，document.getElementsByClassName()，document.getElementsByTagName()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.getElementById()</code> 方法返回匹配指定 <code class="language-plaintext highlighter-rouge">id</code> 属性的元素节点。该方法的参数大小写敏感且只能在 <code class="language-plaintext highlighter-rouge">document</code> 对象上使用。</li> <li><code class="language-plaintext highlighter-rouge">document.getElementsByTagName()</code> 方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），可以<strong>实时</strong>反映 HTML 文档的变化。该方法可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</li> <li><code class="language-plaintext highlighter-rouge">document.getElementsByClassName()</code> 方法返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），包括了所有 <code class="language-plaintext highlighter-rouge">class</code> 名字符合指定条件的元素，元素的变化<strong>实时</strong>反映在返回结果中。该方法可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</li> <li><code class="language-plaintext highlighter-rouge">document.getElementsByName()</code> 方法用于选择拥有 <code class="language-plaintext highlighter-rouge">name</code> 属性的 HTML 元素（比如 <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;radio&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;frame&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;object&gt;</code> 等），返回一个类似数组的的对象（<code class="language-plaintext highlighter-rouge">NodeList</code> 实例），因为 <code class="language-plaintext highlighter-rouge">name</code> 属性相同的元素可能不止一个。</li> </ul> <h4 id="35-documentelementfrompointdocumentelementsfrompoint">3.5 document.elementFromPoint()，document.elementsFromPoint()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.elementFromPoint()</code> 方法返回位于页面指定位置<strong>最上层</strong>的元素节点。该方法的两个参数，依次是相对于当前视口<strong>左上角</strong>的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。</li> <li><code class="language-plaintext highlighter-rouge">document.elementsFromPoint()</code> 返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">elementFromPoint</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码选中在 <code class="language-plaintext highlighter-rouge">(50, 50)</code> 这个坐标位置的最上层的那个 HTML 元素。</p> <h4 id="36-documentcreateelementdocumentcreatetextnodedocumentcreateattributedocumentcreatecommentdocumentcreatedocumentfragmentdocumentcreateevent">3.6 document.createElement()，document.createTextNode()，document.createAttribute()，document.createComment()，document.createDocumentFragment()，document.createEvent()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.createElement()</code> 方法用来生成元素节点，并返回该节点。参数为元素的标签名（不包含 <code class="language-plaintext highlighter-rouge">&lt;</code> 和 <code class="language-plaintext highlighter-rouge">&gt;</code>，否则会报错）。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.createTextNode()</code> 方法用来生成<strong>文本节点</strong>（Text 实例），并返回该节点。它的参数是文本节点的内容。</p> <ul> <li>该方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</li> <li> <p>该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;span&gt;Foo &amp; bar&lt;/span&gt;</span><span class="dl">'</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">)</span>
<span class="c1">// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt;</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">createTextNode()</code> 方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p> </li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">document.createAttribute()</code> 方法生成一个新的属性节点（Attr 实例），并返回它。参数是属性的名称。</li> <li><code class="language-plaintext highlighter-rouge">document.createComment()</code> 方法生成一个新的注释节点，并返回该节点。参数是一个字符。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.createDocumentFragment()</code> 方法生成一个空的文档片段对象（<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 实例）。</p> <p><code class="language-plaintext highlighter-rouge">DocumentFragment</code> 是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">document.createEvent()</code> 方法生成一个事件对象（<code class="language-plaintext highlighter-rouge">Event</code> 实例），该对象可以被 <code class="language-plaintext highlighter-rouge">element.dispatchEvent()</code> 方法使用，触发指定事件。</p> <p><code class="language-plaintext highlighter-rouge">document.createEvent()</code> 方法的参数是事件类型，比如 <code class="language-plaintext highlighter-rouge">UIEvents</code>、<code class="language-plaintext highlighter-rouge">MouseEvents</code>、<code class="language-plaintext highlighter-rouge">MutationEvents</code>、<code class="language-plaintext highlighter-rouge">HTMLEvents</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">Event</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">event</span><span class="p">.</span><span class="nf">initEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">build</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">build</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span> <span class="c1">// "build"</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码新建了一个名为 <code class="language-plaintext highlighter-rouge">build</code> 的事件实例，然后触发该事件。</p> </li> </ul> <h4 id="37-documentaddeventlistenerdocumentremoveeventlistenerdocumentdispatchevent">3.7 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h4> <p>这三个方法用于处理 <code class="language-plaintext highlighter-rouge">document</code> 节点的事件。它们都继承自 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口，详细介绍参见《EventTarget 接口》一章。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 添加事件监听函数</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="c1">// 移除事件监听函数</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="c1">// 触发事件</span>
<span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
</code></pre></div></div> <h4 id="38-documenthasfocus">3.8 document.hasFocus()</h4> <p><code class="language-plaintext highlighter-rouge">document.hasFocus()</code> 方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p> <p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p> <h4 id="39-documentadoptnodedocumentimportnode">3.9 document.adoptNode()，document.importNode()</h4> <p><code class="language-plaintext highlighter-rouge">document.adoptNode()</code> 方法将某个节点及其子节点，从原来所在的文档或 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 里面移除，归属当前 <code class="language-plaintext highlighter-rouge">document</code> 对象，返回插入后的新节点。插入的节点对象的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性，会变成当前的 <code class="language-plaintext highlighter-rouge">document</code> 对象，而 <code class="language-plaintext highlighter-rouge">parentNode</code> 属性是 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">adoptNode</span><span class="p">(</span><span class="nx">externalNode</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
</code></pre></div></div> <p>注意，<code class="language-plaintext highlighter-rouge">document.adoptNode()</code> 方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用 <code class="language-plaintext highlighter-rouge">appendChild()</code> 方法或 <code class="language-plaintext highlighter-rouge">insertBefore()</code> 方法，将新节点插入当前文档树。</p> <p><code class="language-plaintext highlighter-rouge">document.importNode()</code> 方法从原来所在的文档或 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 里面，<strong>拷贝</strong>某个节点及其子节点，让它们归属当前 <code class="language-plaintext highlighter-rouge">document</code> 对象。拷贝的节点对象的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性，会变成当前的 <code class="language-plaintext highlighter-rouge">document</code> 对象，而 <code class="language-plaintext highlighter-rouge">parentNode</code> 属性是 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">importNode</span><span class="p">(</span><span class="nx">externalNode</span><span class="p">,</span> <span class="nx">deep</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">document.importNode()</code> 方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（<code class="language-plaintext highlighter-rouge">false</code>）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">document.importNode()</code> 方法只是拷贝外部节点，这时该节点的父节点是 <code class="language-plaintext highlighter-rouge">null</code>。下一步还必须将这个节点插入当前文档树。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">iframe</span><span class="dl">'</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">oldNode</span> <span class="o">=</span> <span class="nx">iframe</span><span class="p">.</span><span class="nx">contentWindow</span><span class="p">.</span><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myNode</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">importNode</span><span class="p">(</span><span class="nx">oldNode</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">container</span><span class="dl">"</span><span class="p">).</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码从 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口，拷贝一个指定节点 <code class="language-plaintext highlighter-rouge">myNode</code>，插入当前文档。</p> <h4 id="310-documentcreatenodeiteratordocumentcreatetreewalker">3.10 document.createNodeIterator()，document.createTreeWalker()</h4> <p><code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 方法返回一个子节点遍历器。<code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型。几种主要的节点类型写法如下。</p> <ul> <li>所有节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_ALL</code></li> <li>元素节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_ELEMENT</code></li> <li>文本节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_TEXT</code></li> <li>评论节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_COMMENT</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nodeIterator</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createNodeIterator</span><span class="p">(</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
  <span class="nx">NodeFilter</span><span class="p">.</span><span class="nx">SHOW_ELEMENT</span>
<span class="p">);</span>
</code></pre></div></div> <p>上面代码返回 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素子节点的遍历器。</p> <p><code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 方法返回一个“遍历器”对象（<code class="language-plaintext highlighter-rouge">NodeFilter</code> 实例）。该实例的 <code class="language-plaintext highlighter-rouge">nextNode()</code> 方法和 <code class="language-plaintext highlighter-rouge">previousNode()</code> 方法，可以用来遍历所有子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nodeIterator</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createNodeIterator</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">pars</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">var</span> <span class="nx">currentNode</span><span class="p">;</span>

<span class="k">while </span><span class="p">(</span><span class="nx">currentNode</span> <span class="o">=</span> <span class="nx">nodeIterator</span><span class="p">.</span><span class="nf">nextNode</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">pars</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">currentNode</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，使用遍历器的 <code class="language-plaintext highlighter-rouge">nextNode()</code> 方法，将根节点的所有子节点，依次读入一个数组。<code class="language-plaintext highlighter-rouge">nextNode()</code> 方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">previousNode()</code> 方法则是先将指针移向上一个节点，然后返回该节点。</p> <p>注意，遍历器返回的第一个节点，总是<strong>根节点</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">document.createTreeWalker()</code> 方法返回一个 DOM 的子树遍历器。它与 <code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 方法基本类似，区别在于它返回的是 <code class="language-plaintext highlighter-rouge">TreeWalker</code> 实例且第一个节点不是根节点。</p> <h4 id="311-documentexeccommanddocumentquerycommandsupporteddocumentquerycommandenabled">3.11 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()</h4> <h5 id="1documentexeccommand">（1）document.execCommand()</h5> <p>如果 <code class="language-plaintext highlighter-rouge">document.designMode</code> 属性设为 <code class="language-plaintext highlighter-rouge">on</code>，那么整个文档用户可编辑；如果元素的 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性设为 <code class="language-plaintext highlighter-rouge">true</code>，那么该元素可编辑。这两种情况下，可以使用 <code class="language-plaintext highlighter-rouge">document.execCommand()</code> 方法，改变内容的样式，比如 <code class="language-plaintext highlighter-rouge">document.execCommand('bold')</code> 会使得字体加粗。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">execCommand</span><span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="nx">showDefaultUI</span><span class="p">,</span> <span class="nx">input</span><span class="p">)</span>
</code></pre></div></div> <p>该方法接受三个参数。</p> <ul> <li><code class="language-plaintext highlighter-rouge">command</code>：字符串，表示所要实施的样式。</li> <li><code class="language-plaintext highlighter-rouge">showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为 <code class="language-plaintext highlighter-rouge">true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的返回值是一个布尔值。如果为 <code class="language-plaintext highlighter-rouge">false</code>，表示这个方法无法生效。</p> <p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p> <h5 id="2documentquerycommandsupported">（2）document.queryCommandSupported()</h5> <p><code class="language-plaintext highlighter-rouge">document.queryCommandSupported()</code> 方法返回一个布尔值，表示浏览器是否支持 <code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的某个命令。</p> <h5 id="3documentquerycommandenabled">（3）document.queryCommandEnabled()</h5> <p><code class="language-plaintext highlighter-rouge">document.queryCommandEnabled()</code> 方法返回一个布尔值，表示当前是否可用 <code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的某个命令。比如，<code class="language-plaintext highlighter-rouge">bold</code>（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;input type="button" value="Copy" onclick="doCopy()"&gt;</span>

<span class="kd">function</span> <span class="nf">doCopy</span><span class="p">(){</span>
  <span class="c1">// 浏览器是否支持 copy 命令（选中内容复制到剪贴板）</span>
  <span class="k">if </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">queryCommandSupported</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
    <span class="nf">copyText</span><span class="p">(</span><span class="dl">'</span><span class="s1">你好</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">浏览器不支持</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">copyText</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">textarea</span><span class="dl">'</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
  <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">text</span><span class="p">;</span>
  <span class="nx">input</span><span class="p">.</span><span class="nf">focus</span><span class="p">();</span>
  <span class="nx">input</span><span class="p">.</span><span class="nf">select</span><span class="p">();</span>

  <span class="c1">// 当前是否有选中文字</span>
  <span class="k">if </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">queryCommandEnabled</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">success</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">execCommand</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">input</span><span class="p">.</span><span class="nf">remove</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Copy Ok</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">queryCommandEnabled is false</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，先判断浏览器是否支持 <code class="language-plaintext highlighter-rouge">copy</code> 命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。</p> <h4 id="312-documentgetselection">3.12 document.getSelection()</h4> <p>这个方法指向 <code class="language-plaintext highlighter-rouge">window.getSelection()</code>，参见 <code class="language-plaintext highlighter-rouge">window</code> 对象一节的介绍。</p> <h2 id="六element-节点">六、Element 节点</h2> <h3 id="1-简介">1. 简介</h3> <p><code class="language-plaintext highlighter-rouge">Element</code> 节点对象对应网页的 HTML 元素。每个 HTML 元素，在 DOM 树上都会转化成一个 <code class="language-plaintext highlighter-rouge">Element</code> 节点对象。不同的 HTML 元素对应不同的的元素节点，浏览器使用不同的构造函数，生成不同的元素节点，比如 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 元素的构造函数是<code class="language-plaintext highlighter-rouge">HTMLAnchorElement()</code>，<code class="language-plaintext highlighter-rouge">&lt;button&gt;</code> 是 <code class="language-plaintext highlighter-rouge">HTMLButtonElement()</code>。因此，元素节点不是一种对象，而是许多种对象，这些对象除了继承 <code class="language-plaintext highlighter-rouge">Element</code> 对象的属性和方法，还有各自独有的属性和方法。</p> <h3 id="2-实例属性">2. 实例属性</h3> <h4 id="21-元素特性的相关属性">2.1 元素特性的相关属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.id</code>：返回指定元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性，该属性可读写。</li> <li><code class="language-plaintext highlighter-rouge">Element.tagName</code>：返回指定元素的大写标签名，与 <code class="language-plaintext highlighter-rouge">nodeName</code> 属性的值相等。</li> <li><code class="language-plaintext highlighter-rouge">Element.dir</code>：用于读写当前元素的文字方向，可能是从左到右（”<code class="language-plaintext highlighter-rouge">ltr</code>“），也可能是从右到左（”<code class="language-plaintext highlighter-rouge">rtl</code>“）。</li> <li><code class="language-plaintext highlighter-rouge">Element.accessKey</code>：用于读写分配给当前元素的快捷键。</li> <li><code class="language-plaintext highlighter-rouge">Element.draggable</code>：返回一个布尔值，表示当前元素是否可拖动。该属性<strong>可读写</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Element.lang</code>：返回当前元素的语言设置。该属性<strong>可读写</strong>。</li> <li> <p><code class="language-plaintext highlighter-rouge">Element.tabIndex</code>：返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性<strong>可读写</strong>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">tabIndex</code> 属性值如果是负值（通常是 <code class="language-plaintext highlighter-rouge">-1</code>），则 Tab 键不会遍历到该元素。</li> <li>如果是正整数，则按照顺序，从小到大遍历。</li> <li>如果两个元素的 <code class="language-plaintext highlighter-rouge">tabIndex</code> 属性的正整数值相同，则按照出现的顺序遍历。</li> <li>遍历完所有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 为正整数的元素以后，再遍历所有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 等于 <code class="language-plaintext highlighter-rouge">0</code>、或者属性值是非法值、或者没有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 属性的元素，顺序为它们在网页中出现的顺序。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">Element.title</code>：用来读写当前元素的 HTML 属性 <code class="language-plaintext highlighter-rouge">title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</li> </ul> <h4 id="22-元素状态的相关属性">2.2 元素状态的相关属性</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.hidden</code>：返回一个布尔值，表示当前 HTML 元素的 <code class="language-plaintext highlighter-rouge">hidden</code> 属性的值。该属性<strong>可读写</strong>，用来控制当前元素<strong>是否可见</strong>。</p> <ul> <li>该属性与 CSS 设置互相独立。CSS 对当前元素可见性的设置，<code class="language-plaintext highlighter-rouge">Element.hidden</code> 并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</li> <li>CSS 设置的优先级高于 <code class="language-plaintext highlighter-rouge">Element.hidden</code>。如果 CSS 指定了该元素不可见（<code class="language-plaintext highlighter-rouge">display: none</code>）或可见（<code class="language-plaintext highlighter-rouge">visibility: visible</code>），那么 <code class="language-plaintext highlighter-rouge">Element.hidden</code> 并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.contentEditable</code>：返回一个字符串，表示是否设置了 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性，HTML 元素可以设置 <code class="language-plaintext highlighter-rouge">contentEditable</code> 属性，使得元素的内容可以编辑。有三种可能的值。该属性可写。</p> <ul> <li><code class="language-plaintext highlighter-rouge">"true"</code>：元素内容可编辑；</li> <li><code class="language-plaintext highlighter-rouge">"false"</code>：元素内容不可编辑；</li> <li><code class="language-plaintext highlighter-rouge">"inherit"</code>：元素是否可编辑，继承了父元素的设置。</li> </ul> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">contenteditable</span><span class="nt">&gt;</span>123<span class="nt">&lt;/div&gt;</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.isContentEditable</code>：返回一个布尔值，同样表示是否设置了 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性。该属性只读。</p> </li> </ul> <h4 id="23-elementattributes">2.3 Element.attributes</h4> <p><code class="language-plaintext highlighter-rouge">Element.attributes</code> 属性返回一个类似数组的对象，成员是当前元素节点的所有<strong>属性节点</strong>。</p> <h4 id="24-elementclassnameelementclasslist">2.4 Element.className，Element.classList</h4> <ul> <li><code class="language-plaintext highlighter-rouge">className</code> 属性用来读写当前元素节点的 <code class="language-plaintext highlighter-rouge">class</code> 属性。它的值是一个字符串，每个 <code class="language-plaintext highlighter-rouge">class</code> 之间用空格分割。</li> <li><code class="language-plaintext highlighter-rouge">classList</code> 属性返回一个类似数组的<strong>对象</strong>，当前元素节点的每个 <code class="language-plaintext highlighter-rouge">class</code> 就是这个对象的一个成员。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码 &lt;div class="one two three" id="myDiv"&gt;&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">className</span>
<span class="c1">// "one two three"</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span>
<span class="c1">// {</span>
<span class="c1">//   0: "one"</span>
<span class="c1">//   1: "two"</span>
<span class="c1">//   2: "three"</span>
<span class="c1">//   length: 3</span>
<span class="c1">// }</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">classList</code> 对象有下列方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">add()</code>：增加一个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li><code class="language-plaintext highlighter-rouge">remove()</code>：移除一个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li><code class="language-plaintext highlighter-rouge">contains()</code>：检查当前元素是否包含某个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li><code class="language-plaintext highlighter-rouge">toggle()</code>：将某个 <code class="language-plaintext highlighter-rouge">class</code> 移入或移出当前元素，该方法可以接受一个布尔值，作为第二个参数。如果为 <code class="language-plaintext highlighter-rouge">true</code>，则添加该属性；如果为 <code class="language-plaintext highlighter-rouge">false</code>，则去除该属性。。</li> <li><code class="language-plaintext highlighter-rouge">item()</code>：返回指定索引位置的 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li><code class="language-plaintext highlighter-rouge">toString()</code>：将 <code class="language-plaintext highlighter-rouge">class</code> 的列表转为字符串。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">toggle</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 如果 myCssClass 不存在就加入，否则移除</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 返回 true 或者 false</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 返回第一个 Class</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">toString</span><span class="p">();</span>
</code></pre></div></div> <h4 id="25-elementdataset">2.5 Element.dataset</h4> <p>网页元素可以自定义 <code class="language-plaintext highlighter-rouge">data-</code> 属性，用来添加数据。<code class="language-plaintext highlighter-rouge">Element.dataset</code> 属性返回一个对象，可以从这个对象读写 <code class="language-plaintext highlighter-rouge">data-</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &lt;article</span>
<span class="c1">//   id="foo"</span>
<span class="c1">//   data-columns="3"</span>
<span class="c1">//   data-index-number="12314"</span>
<span class="c1">//   data-parent="cars"&gt;</span>
<span class="c1">//   ...</span>
<span class="c1">// &lt;/article&gt;</span>
<span class="kd">var</span> <span class="nx">article</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">columns</span> <span class="c1">// "3"</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">indexNumber</span> <span class="c1">// "12314"</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">parent</span> <span class="c1">// "cars"</span>
</code></pre></div></div> <p>HTML 代码中，<code class="language-plaintext highlighter-rouge">data-</code> 属性的属性名，只能包含英文字母、数字、连词线（<code class="language-plaintext highlighter-rouge">-</code>）、点（<code class="language-plaintext highlighter-rouge">.</code>）、冒号（<code class="language-plaintext highlighter-rouge">:</code>）和下划线（<code class="language-plaintext highlighter-rouge">_</code>）。它们转成 JavaScript 对应的 <code class="language-plaintext highlighter-rouge">dataset</code> 属性名，规则如下。</p> <ul> <li>开头的 <code class="language-plaintext highlighter-rouge">data-</code> 会省略。</li> <li>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</li> <li>其他字符不变。</li> </ul> <p>因此，<code class="language-plaintext highlighter-rouge">data-abc-def</code> 对应 <code class="language-plaintext highlighter-rouge">dataset.abcDef</code>，<code class="language-plaintext highlighter-rouge">data-abc-1</code> 对应 <code class="language-plaintext highlighter-rouge">dataset["abc-1"]</code>。</p> <p>除了使用 <code class="language-plaintext highlighter-rouge">dataset</code> 读写 <code class="language-plaintext highlighter-rouge">data-</code> 属性，也可以使用 <code class="language-plaintext highlighter-rouge">Element.getAttribute()</code> 和 <code class="language-plaintext highlighter-rouge">Element.setAttribute()</code>，通过完整的属性名读写这些属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mydiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">mydiv</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">mydiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">mydiv</span><span class="p">.</span><span class="nf">getAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">data-foo</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "bar"</span>
</code></pre></div></div> <h4 id="26-elementinnerhtmelementouterhtml">2.6 Element.innerHTM，Element.outerHTML</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.innerHTML</code> 属性返回一个字符串，表示该元素<strong>包含的</strong>所有 HTML 代码。该属性<strong>可读写</strong>，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括 <code class="language-plaintext highlighter-rouge">&lt;HTML&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素。</p> <ul> <li>如果将 <code class="language-plaintext highlighter-rouge">innerHTML</code> 属性设为空，等于删除所有它包含的所有节点。</li> <li>读取属性值的时候，如果文本节点包含 <code class="language-plaintext highlighter-rouge">&amp;</code>、小于号（<code class="language-plaintext highlighter-rouge">&lt;</code>）和大于号（<code class="language-plaintext highlighter-rouge">&gt;</code>），<code class="language-plaintext highlighter-rouge">innerHTML</code> 属性会将它们转为实体形式 <code class="language-plaintext highlighter-rouge">&amp;amp;</code>、<code class="language-plaintext highlighter-rouge">&amp;lt;</code>、<code class="language-plaintext highlighter-rouge">&amp;gt;</code>。</li> <li>如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签，虽然可以生成 <code class="language-plaintext highlighter-rouge">script</code> 节点，但是插入的代码不会执行。</li> <li>如果想得到原文，或者为了安全考虑，如果插入的是文本，最好用 <code class="language-plaintext highlighter-rouge">Element.textContent</code> 属性代替 <code class="language-plaintext highlighter-rouge">innerHTML</code>。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML代码如下 &lt;p id="para"&gt; 5 &gt; 3 &lt;/p&gt;</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span>
<span class="c1">// 5 &amp;gt; 3</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.outerHTML</code> 属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括<strong>该元素</strong>本身和<strong>所有子元素</strong>，该属性<strong>可读写</strong>。如果一个节点没有父节点，设置 <code class="language-plaintext highlighter-rouge">outerHTML</code> 属性会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d</span><span class="p">.</span><span class="nx">outerHTML</span>
<span class="c1">// '&lt;div id="d"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;'</span>
</code></pre></div> </div> </li> </ul> <h4 id="27-elementclientwidthelementclientheightelementclientleftelementclienttop">2.7 Element.clientWidth，Element.clientHeight，Element.clientLeft，Element.clientTop</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.clientWidth</code> 属性返回元素节点的 <strong>CSS 宽度</strong>（单位像素），只对<strong>块级元素</strong>有效，包括元素本身的宽度和 <code class="language-plaintext highlighter-rouge">padding</code>（不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code>），如果有垂直滚动条，还要减去垂直滚动条的宽度。</li> <li> <p><code class="language-plaintext highlighter-rouge">Element.clientHeight</code> 属性返回元素节点的 <strong>CSS 高度</strong>（单位像素），只对<strong>块级元素</strong>生效，包括元素本身的高度和 <code class="language-plaintext highlighter-rouge">padding</code>（不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code>），对于行内元素返回 <code class="language-plaintext highlighter-rouge">0</code>。如果块级元素没有设置 CSS 高度，则返回实际高度。</p> <ul> <li><code class="language-plaintext highlighter-rouge">document.documentElement</code> 的 <code class="language-plaintext highlighter-rouge">clientHeight</code> 属性，返回当前<strong>视口</strong>的高度（即浏览器窗口的高度），等同于 <code class="language-plaintext highlighter-rouge">window.innerHeight</code> 属性减去水平滚动条的高度（如果有的话）。</li> <li><code class="language-plaintext highlighter-rouge">document.body</code> 的高度返回<strong>网页</strong>的<strong>实际高度</strong>。</li> </ul> <p>一般来说，<code class="language-plaintext highlighter-rouge">document.body.clientHeight</code> 大于 <code class="language-plaintext highlighter-rouge">document.documentElement.clientHeight</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">clientHeight</span> <span class="c1">// 视口高度</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">clientHeight</span> <span class="c1">// 网页总高度</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">Element.clientLeft</code> 属性等于元素节点<strong>左边框</strong>（left border）的<strong>宽度</strong>（单位像素），不包括左侧的 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">margin</code>。如果没有设置左边框，或者是行内元素（<code class="language-plaintext highlighter-rouge">display: inline</code>），该属性返回 <code class="language-plaintext highlighter-rouge">0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</li> <li><code class="language-plaintext highlighter-rouge">Element.clientTop</code> 属性等于网页元素<strong>顶部边框</strong>的<strong>宽度</strong>（单位像素），其他特点都与 <code class="language-plaintext highlighter-rouge">clientLeft</code> 相同。</li> </ul> <h4 id="28-elementscrollwidthelementscrollheightelementscrollleftelementscrolltop">2.8 Element.scrollWidth，Element.scrollHeight，Element.scrollLeft，Element.scrollTop</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.scrollWidth</code> 属性返回一个<strong>整数值</strong>（小数会四舍五入），表示当前元素的<strong>总宽度</strong>（单位像素）。</li> <li> <p><code class="language-plaintext highlighter-rouge">Element.scrollHeight</code> 属性返回一个<strong>整数值</strong>（小数会四舍五入），表示当前元素的<strong>总高度</strong>（单位像素）。</p> <p>整张网页的总高度可以从 <code class="language-plaintext highlighter-rouge">document.documentElement</code> 或 <code class="language-plaintext highlighter-rouge">document.body</code> 上读取。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 返回网页的总高度</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollHeight</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">scrollHeight</span>
</code></pre></div> </div> </li> </ul> <p>这两个属性都包括溢出容器部分、当前不可见的部分、<code class="language-plaintext highlighter-rouge">padding</code> 和伪元素（<code class="language-plaintext highlighter-rouge">::before</code> 或 <code class="language-plaintext highlighter-rouge">::after</code>）的高度，但是不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code> 以及水平滚动条的高度（如果有水平滚动条的话）。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Element.scrollLeft</code> 属性表示当前元素的<strong>水平滚动条</strong>向右侧滚动的像素数量。</li> <li><code class="language-plaintext highlighter-rouge">Element.scrollTop</code> 属性表示当前元素的<strong>垂直滚动条</strong>向下滚动的像素数量。</li> </ul> <p>对于那些没有滚动条的网页元素，这两个属性总是等于 <code class="language-plaintext highlighter-rouge">0</code>。如果要查看整张网页的水平的和垂直的滚动距离，要从 <code class="language-plaintext highlighter-rouge">document.documentElement</code> 元素上读取。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollLeft</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollTop</span>
</code></pre></div></div> <h4 id="29-elementoffsetwidthelementoffsetheightelementoffsetleftelementoffsettopelementoffsetparent">2.9 Element.offsetWidth，Element.offsetHeight，Element.offsetLeft，Element.offsetTop，Element.offsetParent</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.offsetWidth</code> 属性表示元素的 CSS <strong>水平宽度</strong>（单位像素），包括元素本身的宽度、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>，以及垂直滚动条的宽度（如果存在滚动条）。</li> <li><code class="language-plaintext highlighter-rouge">Element.offsetHeight</code> 属性表示元素的 CSS <strong>垂直高度</strong>（单位像素），包括元素本身的高度、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>，以及水平滚动条的高度（如果存在滚动条）。</li> </ul> <p>这两个属性都是<strong>只读</strong>属性，只比 <code class="language-plaintext highlighter-rouge">Element.clientHeight</code> 和 <code class="language-plaintext highlighter-rouge">Element.clientWidth</code> 多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如 <code class="language-plaintext highlighter-rouge">display: none;</code>），则返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.offsetParent</code> 属性返回最靠近当前元素的、并且 CSS 的 <code class="language-plaintext highlighter-rouge">position</code> 属性不等于 <code class="language-plaintext highlighter-rouge">static</code> 的上层元素。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">style</span><span class="o">=</span><span class="dl">"</span><span class="s2">position: absolute;</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">span</code> 元素的 <code class="language-plaintext highlighter-rouge">offsetParent</code> 属性是 <code class="language-plaintext highlighter-rouge">div</code> 元素。</p> </li> <li><code class="language-plaintext highlighter-rouge">Element.offsetLeft</code> 返回当前元素左上角相对于 <code class="language-plaintext highlighter-rouge">Element.offsetParent</code> 节点的水平位移。</li> <li><code class="language-plaintext highlighter-rouge">Element.offsetTop</code> 返回垂直位移，单位为像素。</li> </ul> <p>通常，<code class="language-plaintext highlighter-rouge">Element.offsetLeft</code> 和 <code class="language-plaintext highlighter-rouge">Element.offsetTop</code> 是指相对于父节点的位移。</p> <h4 id="210-elementstyle">2.10 Element.style</h4> <p><code class="language-plaintext highlighter-rouge">style</code> 属性用来读写该元素的行内样式信息。</p> <h4 id="211-elementchildrenelementchildelementcountelementfirstelementchildelementlastelementchild">2.11 Element.children，Element.childElementCount，Element.firstElementChild，Element.lastElementChild</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.children</code> 属性返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），包括当前<strong>元素节点</strong>的所有子元素。</li> <li><code class="language-plaintext highlighter-rouge">Element.childElementCount</code> 属性返回当前元素节点包含的子元素节点的个数，与 <code class="language-plaintext highlighter-rouge">Element.children.length</code> 的值相同。</li> <li><code class="language-plaintext highlighter-rouge">Element.firstElementChild</code> 属性返回当前元素的第一个元素子节点。</li> <li><code class="language-plaintext highlighter-rouge">Element.lastElementChild</code> 属性返回当前元素的最后一个元素子节点。</li> </ul> <h4 id="212-elementnextelementsiblingelementpreviouselementsibling">2.12 Element.nextElementSibling，Element.previousElementSibling</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.previousElementSibling</code> 属性返回当前元素节点的前一个同级元素节点。</li> <li><code class="language-plaintext highlighter-rouge">Element.nextElementSibling</code> 属性返回当前元素节点的后一个同级元素节点。</li> </ul> <h3 id="3-实例方法">3. 实例方法</h3> <h4 id="31-属性相关方法">3.1 属性相关方法</h4> <p>元素节点提供六个方法，用来操作属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getAttribute()</code>：读取某个属性的值。</li> <li><code class="language-plaintext highlighter-rouge">getAttributeNames()</code>：返回当前元素的所有属性名。</li> <li><code class="language-plaintext highlighter-rouge">setAttribute()</code>：写入属性值。</li> <li><code class="language-plaintext highlighter-rouge">hasAttribute()</code>：某个属性是否存在。</li> <li><code class="language-plaintext highlighter-rouge">hasAttributes()</code>：当前元素是否有属性。</li> <li><code class="language-plaintext highlighter-rouge">removeAttribute()</code>：删除属性。</li> </ul> <h4 id="31-elementqueryselectorelementqueryselectorall">3.1 Element.querySelector()，Element.querySelectorAll()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.querySelector()</code> 方法接受 CSS 选择器作为参数（多个选择器之间用逗号分隔），返回父元素的<strong>第一个</strong>匹配的子元素。该方法可以接受复杂的 CSS 选择器。</p> <p>浏览器执行 <code class="language-plaintext highlighter-rouge">querySelector()</code> 方法时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码</span>
<span class="c1">// &lt;div&gt;</span>
<span class="c1">// &lt;blockquote id="outer"&gt;</span>
<span class="c1">//   &lt;p&gt;Hello&lt;/p&gt;</span>
<span class="c1">//   &lt;div id="inner"&gt;</span>
<span class="c1">//     &lt;p&gt;World&lt;/p&gt;</span>
<span class="c1">//   &lt;/div&gt;</span>
<span class="c1">// &lt;/blockquote&gt;</span>
<span class="c1">// &lt;/div&gt;</span>

<span class="kd">var</span> <span class="nx">outer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">outer</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">outer</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// &lt;p&gt;Hello&lt;/p&gt;</span>
</code></pre></div> </div> <p>上面代码实际上返回的是第一个 <code class="language-plaintext highlighter-rouge">p</code> 元素，而不是第二个。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.querySelectorAll()</code> 方法接受 CSS 选择器作为参数多个选择器之间用逗号分隔），返回一个 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例，包含所有匹配的子元素。该方法的执行机制与querySelector方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。</p> </li> </ul> <h4 id="32-elementgetelementsbyclassnameelementgetelementsbytagname">3.2 Element.getElementsByClassName()，Element.getElementsByTagName()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.getElementsByClassName()</code> 方法返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是<strong>当前节点</strong>的所有具有指定 <code class="language-plaintext highlighter-rouge">class</code> 的子元素节点。</li> <li><code class="language-plaintext highlighter-rouge">Element.getElementsByTagName()</code> 方法返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是<strong>当前节点</strong>的所有匹配指定标签名的子元素节点。</li> </ul> <p>这两个方法与 <code class="language-plaintext highlighter-rouge">document.getElementsByClassName()</code> 方法的用法类似，只是搜索范围不是整个文档，而是<strong>当前</strong>元素节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nf">getElementsByClassName</span><span class="p">(</span><span class="dl">'</span><span class="s1">red test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">table</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">td</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <h4 id="33-elementclosest">3.3 Element.closest()</h4> <p><code class="language-plaintext highlighter-rouge">Element.closest()</code> 方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个<strong>祖先节点</strong>（包括当前节点本身）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;article&gt;</span>
<span class="c1">//   &lt;div id="div-01"&gt;Here is div-01</span>
<span class="c1">//     &lt;div id="div-02"&gt;Here is div-02</span>
<span class="c1">//       &lt;div id="div-03"&gt;Here is div-03&lt;/div&gt;</span>
<span class="c1">//     &lt;/div&gt;</span>
<span class="c1">//   &lt;/div&gt;</span>
<span class="c1">// &lt;/article&gt;</span>

<span class="kd">var</span> <span class="nx">div03</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">div-03</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// div-03 最近的祖先节点</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">#div-02</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// div-02</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">div div</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// div-03</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">article &gt; div</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//div-01</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">:not(div)</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// article</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">closest()</code> 方法将当前节点也考虑在内，所以第二个 <code class="language-plaintext highlighter-rouge">closest()</code> 方法返回 <code class="language-plaintext highlighter-rouge">div-03</code>。</p> <h4 id="34-elementmatches">3.4 Element.matches()</h4> <p><code class="language-plaintext highlighter-rouge">Element.matches()</code> 方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p> <h4 id="35-事件相关方法">3.5 事件相关方法</h4> <p>以下三个方法与 <code class="language-plaintext highlighter-rouge">Element</code> 节点的事件相关。这些方法都继承自 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口，详见相关章节。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Element.addEventListener()</code>：添加事件的回调函数</li> <li><code class="language-plaintext highlighter-rouge">Element.removeEventListener()</code>：移除事件监听函数</li> <li><code class="language-plaintext highlighter-rouge">Element.dispatchEvent()</code>：触发事件</li> </ul> <h4 id="36-elementscrollintoview">3.6 Element.scrollIntoView()</h4> <p><code class="language-plaintext highlighter-rouge">Element.scrollIntoView()</code> 方法滚动当前元素，进入浏览器的可见区域，类似于设置 <code class="language-plaintext highlighter-rouge">window.location.hash</code> 的效果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nf">scrollIntoView</span><span class="p">();</span> <span class="c1">// 等同于 el.scrollIntoView(true)</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">scrollIntoView</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p>该方法可以接受一个布尔值作为参数。如果为 <code class="language-plaintext highlighter-rouge">true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为 <code class="language-plaintext highlighter-rouge">false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <h4 id="37-elementgetboundingclientrectelementgetclientrects">3.7 Element.getBoundingClientRect()，Element.getClientRects()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 方法返回一个<strong>对象</strong>，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p> <p><code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 方法返回的 <code class="language-plaintext highlighter-rouge">rect</code> 对象，具有以下属性（全部为只读）。</p> <ul> <li><code class="language-plaintext highlighter-rouge">x</code>：元素左上角相对于视口的横坐标</li> <li><code class="language-plaintext highlighter-rouge">y</code>：元素左上角相对于视口的纵坐标</li> <li><code class="language-plaintext highlighter-rouge">left</code>：元素左上角相对于视口的横坐标，与x属性相等</li> <li><code class="language-plaintext highlighter-rouge">right</code>：元素右边界相对于视口的横坐标（等于 <code class="language-plaintext highlighter-rouge">x + width</code>）</li> <li><code class="language-plaintext highlighter-rouge">top</code>：元素顶部相对于视口的纵坐标，与y属性相等</li> <li><code class="language-plaintext highlighter-rouge">bottom</code>：元素底部相对于视口的纵坐标（等于 <code class="language-plaintext highlighter-rouge">y + height</code>）</li> <li><code class="language-plaintext highlighter-rouge">width</code>：元素宽度</li> <li><code class="language-plaintext highlighter-rouge">height</code>：元素高度</li> </ul> <p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将 <code class="language-plaintext highlighter-rouge">left</code> 属性加上 <code class="language-plaintext highlighter-rouge">window.scrollX</code>，<code class="language-plaintext highlighter-rouge">top</code> 属性加上 <code class="language-plaintext highlighter-rouge">window.scrollY</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 方法的所有属性，都把边框（<code class="language-plaintext highlighter-rouge">border</code> 属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，<code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code> 包括了元素本身 + <code class="language-plaintext highlighter-rouge">padding</code> + <code class="language-plaintext highlighter-rouge">border</code>。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.getClientRects()</code> 方法返回一个类似数组的<strong>对象</strong>，里面是当前元素在页面上形成的所有<strong>矩形</strong>（所以方法名中的 Rect 用的是复数）。每个矩形都有 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">bottom</code>、<code class="language-plaintext highlighter-rouge">left</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code> 六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p> <p>对于盒状元素（比如 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和 <code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 方法的主要区别，后者对于行内元素总是返回一个矩形。</p> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">inline</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">().</span><span class="nx">length</span> <span class="c1">// 3</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">left</span> <span class="c1">// 8</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">right</span> <span class="c1">// 113.908203125</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">bottom</span> <span class="c1">// 31.200000762939453</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">height</span> <span class="c1">// 23.200000762939453</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">width</span> <span class="c1">// 105.908203125</span>
</code></pre></div></div> <p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p> <h4 id="38-elementinsertadjacentelementelementinsertadjacenthtmlelementinsertadjacenttext">3.8 Element.insertAdjacentElement()，Element.insertAdjacentHTML()，Element.insertAdjacentText()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.insertAdjacentElement()</code> 方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点。</li> <li><code class="language-plaintext highlighter-rouge">Element.insertAdjacentHTML()</code> 方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</li> <li><code class="language-plaintext highlighter-rouge">Element.insertAdjacentText()</code> 方法在相对于当前节点的指定位置，插入一个文本节点。</li> </ul> <p>这三个方法都可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点/待解析的 HTML 字符串/将要插入的文本内容。第一个参数只可以取如下的值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">beforebegin</code>：当前元素之前</li> <li><code class="language-plaintext highlighter-rouge">afterbegin</code>：当前元素内部的第一个子节点前面</li> <li><code class="language-plaintext highlighter-rouge">beforeend</code>：当前元素内部的最后一个子节点后面</li> <li><code class="language-plaintext highlighter-rouge">afterend</code>：当前元素之后</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码：&lt;div id="one"&gt;one&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">one</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d1</span><span class="p">.</span><span class="nf">insertAdjacentHTML</span><span class="p">(</span><span class="dl">'</span><span class="s1">afterend</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&lt;div id="two"&gt;two&lt;/div&gt;</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 执行后的 HTML 代码：</span>
<span class="c1">// &lt;div id="one"&gt;one&lt;/div&gt;&lt;div id="two"&gt;two&lt;/div&gt;</span>
</code></pre></div></div> <h4 id="39-elementremove">3.9 Element.remove()</h4> <p><code class="language-plaintext highlighter-rouge">Element.remove()</code> 方法继承自 <code class="language-plaintext highlighter-rouge">ChildNode</code> 接口，用于将当前元素节点从它的父节点移除。</p> <h4 id="310-elementfocuselementblur">3.10 Element.focus()，Element.blur()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.focus()</code> 方法用于将当前页面的焦点，转移到指定元素上。<code class="language-plaintext highlighter-rouge">document.activeElement</code> 属性可以得到当前获得焦点的元素。</li> <li><code class="language-plaintext highlighter-rouge">Element.blur()</code> 方法用于将焦点从指定元素移除。</li> </ul> <p><code class="language-plaintext highlighter-rouge">Element.focus()</code> 方法可以接受一个对象作为参数。参数对象的 <code class="language-plaintext highlighter-rouge">preventScroll</code> 属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getFocus</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">btn</span><span class="dl">'</span><span class="p">).</span><span class="nf">focus</span><span class="p">({</span> <span class="na">preventScroll</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码会让 <code class="language-plaintext highlighter-rouge">btn</code> 元素获得焦点，并滚动到可见区域。</p> <h4 id="311-elementclick">3.11 Element.click()</h4> <p><code class="language-plaintext highlighter-rouge">Element.click()</code> 方法用于在当前元素上模拟一次鼠标点击，相当于触发了 <code class="language-plaintext highlighter-rouge">click</code> 事件。</p> <h2 id="七属性的操作">七、属性的操作</h2> <h3 id="1-elementattributes-属性">1. Element.attributes 属性</h3> <p><code class="language-plaintext highlighter-rouge">attributes</code> 属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的<strong>实时</strong>变化都会反映在这个节点对象上。</p> <h3 id="2-元素的标准属性">2. 元素的标准属性</h3> <p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。这些属性都是可写的。</p> <p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如 <code class="language-plaintext highlighter-rouge">onClick</code>。</p> <h3 id="3-属性操作的标准方法">3. 属性操作的标准方法</h3> <h4 id="31-概述">3.1 概述</h4> <p>元素节点提供六个方法，用来操作属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">getAttributeNames()</code></li> <li><code class="language-plaintext highlighter-rouge">setAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">hasAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">hasAttributes()</code></li> <li><code class="language-plaintext highlighter-rouge">removeAttribute()</code></li> </ul> <h4 id="32-elementgetattribute">3.2 Element.getAttribute()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.getAttribute(property)</code> 方法返回当前元素节点的指定属性。</li> <li><code class="language-plaintext highlighter-rouge">Element.getAttributeNames()</code> 返回一个数组，成员是当前元素的所有属性的名字。</li> <li><code class="language-plaintext highlighter-rouge">Element.setAttribute(property, value)</code> 方法用于为当前元素节点新增属性。</li> <li><code class="language-plaintext highlighter-rouge">Element.hasAttribute(property)</code> 方法返回一个布尔值，表示当前元素节点是否包含指定属性。</li> <li><code class="language-plaintext highlighter-rouge">Element.hasAttributes()</code> 方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回 <code class="language-plaintext highlighter-rouge">false</code>，否则返回 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">Element.removeAttribute(property)</code> 方法移除指定属性。该方法没有返回值。</li> </ul> <h3 id="4-dataset-属性">4. dataset 属性</h3> <p>参考 <a href="#25-elementdataset">Element.dataset</a>。</p> <h2 id="八text-节点和-documentfragment-节点">八、Text 节点和 DocumentFragment 节点</h2> <h3 id="1-text-节点的概念">1. Text 节点的概念</h3> <p>文本节点（<code class="language-plaintext highlighter-rouge">Text</code>）代表元素节点（<code class="language-plaintext highlighter-rouge">Element</code>）和属性节点（<code class="language-plaintext highlighter-rouge">Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p> <p>通常我们使用父节点的 <code class="language-plaintext highlighter-rouge">firstChild</code>、<code class="language-plaintext highlighter-rouge">nextSibling</code> 等属性获取文本节点，或者使用 <code class="language-plaintext highlighter-rouge">Document</code> 节点的 <code class="language-plaintext highlighter-rouge">createTextNode()</code> 方法创造一个文本节点。</p> <p>浏览器原生提供一个 <code class="language-plaintext highlighter-rouge">Text</code> 构造函数。它返回一个文本节点实例，参数是该文本节点的文本内容。</p> <p>文本节点除了继承 <code class="language-plaintext highlighter-rouge">Node</code> 接口，还继承了 <code class="language-plaintext highlighter-rouge">CharacterData</code> 接口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">text1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Text</span><span class="p">();</span> <span class="c1">// 空字符串</span>
<span class="kd">var</span> <span class="nx">text2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Text</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is a text node</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 非空字符串</span>
</code></pre></div></div> <p>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code class="language-plaintext highlighter-rouge">&lt;p&gt; &lt;/p&gt;</code>包含一个空格，它的子节点就是一个文本节点。</p> <h3 id="2-text-节点的属性">2. Text 节点的属性</h3> <ul> <li><code class="language-plaintext highlighter-rouge">data</code> 属性等同于 <code class="language-plaintext highlighter-rouge">nodeValue</code> 属性，用来设置或读取文本节点的内容。</li> <li><code class="language-plaintext highlighter-rouge">length</code> 属性返回当前文本节点的文本长度。</li> <li><code class="language-plaintext highlighter-rouge">previousElementSibling</code> 属性返回当前文本节点前面最近的同级元素节点。</li> <li><code class="language-plaintext highlighter-rouge">nextElementSibling</code> 属性返回紧跟在当前文本节点后面的那个同级元素节点。</li> <li> <p><code class="language-plaintext highlighter-rouge">wholeText</code> 属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，<code class="language-plaintext highlighter-rouge">wholeText</code> 属性的返回值，与 <code class="language-plaintext highlighter-rouge">data</code> 属性和 <code class="language-plaintext highlighter-rouge">textContent</code> 属性相同。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &lt;p id="para"&gt;A &lt;em&gt;B&lt;/em&gt; C&lt;/p&gt;</span>

<span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">wholeText</span> <span class="c1">// "A "</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">data</span> <span class="c1">// "A "</span>
</code></pre></div> </div> <p>但是，一旦移除 <code class="language-plaintext highlighter-rouge">&lt;em&gt;</code> 节点，<code class="language-plaintext highlighter-rouge">wholeText</code> 属性与 <code class="language-plaintext highlighter-rouge">data</code> 属性就会有差异，因为这时其实 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 节点下面包含了两个毗邻的文本节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">para</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">wholeText</span> <span class="c1">// "A C"</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">data</span> <span class="c1">// "A "</span>
</code></pre></div> </div> </li> </ul> <h3 id="3-text-节点的方法">3. Text 节点的方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">appendData(str)</code>：在 <code class="language-plaintext highlighter-rouge">Text</code> 节点尾部追加字符串。</li> <li><code class="language-plaintext highlighter-rouge">deleteData(startIndex, str)</code>：删除 <code class="language-plaintext highlighter-rouge">Text</code> 节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li> <li><code class="language-plaintext highlighter-rouge">insertData(index, str)</code>：在 <code class="language-plaintext highlighter-rouge">Text</code> 节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</li> <li><code class="language-plaintext highlighter-rouge">replaceData(startIndex, replacedStr, str)</code>：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li> <li> <p><code class="language-plaintext highlighter-rouge">subStringData(startIndex, length)</code>：用于获取子字符串，第一个参数为子字符串在 <code class="language-plaintext highlighter-rouge">Text</code> 节点中的开始位置，第二个参数为子字符串长度。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">remove()</code> 方法用于移除当前 <code class="language-plaintext highlighter-rouge">Text</code> 节点。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">splitText(offset)</code> 方法将 <code class="language-plaintext highlighter-rouge">Text</code> 节点一分为二，变成两个毗邻的 <code class="language-plaintext highlighter-rouge">Text</code> 节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。分割后，该方法返回分割位置后方的字符串，而原 <code class="language-plaintext highlighter-rouge">Text</code> 节点变成只包含分割位置前方的字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// html 代码为 &lt;p id="p"&gt;foobar&lt;/p&gt;</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">textnode</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">newText</span> <span class="o">=</span> <span class="nx">textnode</span><span class="p">.</span><span class="nf">splitText</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">newText</span> <span class="c1">// "bar"</span>
<span class="nx">textnode</span> <span class="c1">// "foo"</span>
</code></pre></div> </div> <p>父元素节点的 <code class="language-plaintext highlighter-rouge">normalize()</code> 方法可以将毗邻的两个 <code class="language-plaintext highlighter-rouge">Text</code> 节点合并。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">p</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>

<span class="c1">// 将毗邻的两个 Text 节点合并</span>
<span class="nx">p</span><span class="p">.</span><span class="nf">normalize</span><span class="p">();</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1</span>
</code></pre></div> </div> </li> </ul> <h3 id="4-documentfragment-节点">4. DocumentFragment 节点</h3> <p><code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，<code class="language-plaintext highlighter-rouge">parentNode</code> 返回 <code class="language-plaintext highlighter-rouge">null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点，要比直接操作 DOM 树快得多。</p> <p>它一般用于构建一个 DOM 结构，然后插入当前文档。<code class="language-plaintext highlighter-rouge">document.createDocumentFragment()</code> 方法，以及浏览器原生的 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 构造函数，可以创建一个空的 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点。然后再使用其他 DOM 方法，向其添加子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">docFrag</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createDocumentFragment</span><span class="p">();</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">docFrag</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DocumentFragment</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">li</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">li</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">li</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello World</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">docFrag</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">li</span><span class="p">);</span>

<span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">).</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">docFrag</span><span class="p">);</span>
</code></pre></div></div> <p>注意，<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点<strong>本身不能被插入当前文档</strong>。当它作为 <code class="language-plaintext highlighter-rouge">appendChild()</code>、<code class="language-plaintext highlighter-rouge">insertBefore()</code>、<code class="language-plaintext highlighter-rouge">replaceChild()</code> 等方法的参数时，是它的所有<strong>子节点</strong>插入当前文档，而不是它自身。一旦 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点被添加进当前文档，它自身就变成了空节点（<code class="language-plaintext highlighter-rouge">textContent</code> 属性为空字符串），可以被再次使用。如果想要保存 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点的内容，可以使用 <code class="language-plaintext highlighter-rouge">cloneNode</code> 方法。</p> <p><code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点对象没有自己的属性和方法，全部继承自 <code class="language-plaintext highlighter-rouge">Node</code> 节点和 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。也就是说，<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点比 <code class="language-plaintext highlighter-rouge">Node</code> 节点多出以下四个属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">children</code>：返回一个动态的 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 集合对象，包括当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的所有子元素节点。</li> <li><code class="language-plaintext highlighter-rouge">firstElementChild</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的第一个子元素节点。</li> <li><code class="language-plaintext highlighter-rouge">lastElementChild</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的最后一个子元素节点。</li> <li><code class="language-plaintext highlighter-rouge">childElementCount</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的所有子元素数量。</li> </ul> <h2 id="九">九、</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h2 id="十mutation-observer-api">十、Mutation Observer API</h2> <h3 id="1-概述-1">1. 概述</h3> <p>Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p> <p>概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是<strong>异步触发</strong>，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</p> <p>这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入 1000 个 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 元素，就会连续触发 1000 个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在 1000 个段落都插入结束后才会触发，而且只触发一次。</p> <p>Mutation Observer 有以下特点。</p> <ul> <li>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</li> <li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li> <li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li> </ul> <h3 id="2-mutationobserver-构造函数">2. MutationObserver 构造函数</h3> <p>MutationObserver 构造函数会创建一个观察器实例，它接受一个回调函数，回调函数会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">mutations</span><span class="p">,</span> <span class="nx">observer</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mutations</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">mutation</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">mutation</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <h3 id="3-mutationobserver-的实例方法">3. MutationObserver 的实例方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">disconnect()</code> 方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。</li> <li><code class="language-plaintext highlighter-rouge">takeRecords()</code> 方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</li> <li> <p><code class="language-plaintext highlighter-rouge">observe()</code> 方法用来启动监听，它接受两个参数。</p> <ul> <li>第一个参数：所要观察的 DOM 节点</li> <li>第二个参数：一个配置对象，指定所要观察的特定变动</li> </ul> <p>观察器所能观察的 DOM 变动类型（即 <code class="language-plaintext highlighter-rouge">options</code> 配置对象），有以下几种。</p> <ul> <li><code class="language-plaintext highlighter-rouge">childList</code>：子节点的变动（指新增，删除或者更改）。</li> <li><code class="language-plaintext highlighter-rouge">attributes</code>：属性的变动。</li> <li><code class="language-plaintext highlighter-rouge">characterData</code>：节点内容或节点文本的变动。</li> </ul> <p>想要观察哪一种变动类型，就在 <code class="language-plaintext highlighter-rouge">option</code> 对象中指定它的值为 <code class="language-plaintext highlighter-rouge">true</code>。需要注意的是，至少必须同时指定这三种观察的一种，若均未指定将报错。</p> <p>除了变动类型，<code class="language-plaintext highlighter-rouge">options</code> 对象还可以设定以下属性：</p> <ul> <li><code class="language-plaintext highlighter-rouge">subtree</code>：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li> <li><code class="language-plaintext highlighter-rouge">attributeOldValue</code>：布尔值，表示观察 <code class="language-plaintext highlighter-rouge">attributes</code> 变动时，是否需要记录变动前的属性值。</li> <li><code class="language-plaintext highlighter-rouge">characterDataOldValue</code>：布尔值，表示观察 <code class="language-plaintext highlighter-rouge">characterData</code> 变动时，是否需要记录变动前的值。</li> <li><code class="language-plaintext highlighter-rouge">attributeFilter</code>：数组，表示需要观察的特定属性（比如[‘class’,’src’]）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 开始监听文档根节点（即 &lt;html&gt; 标签）的变动</span>
<span class="nx">mutationObserver</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">attributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">characterData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">attributeOldValue</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">characterDataOldValue</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div> </div> </li> </ul> <h3 id="4-mutationrecord-对象">4. MutationRecord 对象</h3> <p>DOM 每次发生变化，就会生成一条变动记录（<code class="language-plaintext highlighter-rouge">MutationRecord</code> 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个 <code class="language-plaintext highlighter-rouge">MutationRecord</code> 实例所组成的数组。</p> <p><code class="language-plaintext highlighter-rouge">MutationRecord</code> 对象包含了 DOM 的相关信息，有如下属性：</p> <ul> <li><code class="language-plaintext highlighter-rouge">type</code>：观察的变动类型（<code class="language-plaintext highlighter-rouge">childList</code>、<code class="language-plaintext highlighter-rouge">attributes</code> 或者 <code class="language-plaintext highlighter-rouge">characterData</code>）。</li> <li><code class="language-plaintext highlighter-rouge">target</code>：发生变动的 DOM 节点。</li> <li><code class="language-plaintext highlighter-rouge">previousSibling</code>：前一个同级节点，如果没有则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">nextSibling</code>：下一个同级节点，如果没有则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">attributeName</code>：发生变动的属性。如果设置了 <code class="language-plaintext highlighter-rouge">attributeFilter</code>，则只返回预先指定的属性。</li> <li><code class="language-plaintext highlighter-rouge">oldValue</code>：变动前的值。这个属性只对 <code class="language-plaintext highlighter-rouge">attribute</code> 和 <code class="language-plaintext highlighter-rouge">characterData</code> 变动有效，如果发生 <code class="language-plaintext highlighter-rouge">childList</code> 变动，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">addedNodes</code>：新增的 DOM 节点。</li> <li><code class="language-plaintext highlighter-rouge">removedNodes</code>：删除的 DOM 节点。</li> </ul> <h3 id="5-应用示例">5. 应用示例</h3> <h4 id="51-子元素的变动">5.1 子元素的变动</h4> <p>下面的例子说明如何读取变动记录。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">records</span><span class="p">){</span>
  <span class="nx">records</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">record</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mutation type: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mutation target: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="nx">mo</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">childList</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">subtree</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="52-属性的变动">5.2 属性的变动</h4> <p>下面的例子说明如何追踪属性的变动。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">records</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">record</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Previous attribute value: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">oldValue</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="nx">mo</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">#my_element</span><span class="dl">'</span><span class="p">),</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">attributes</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">attributeOldValue</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="53-取代-domcontentloaded-事件">5.3 取代 DOMContentLoaded 事件</h4> <p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
<span class="nx">observer</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <p>上面代码中，监听 <code class="language-plaintext highlighter-rouge">document.documentElement</code>（即网页的 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> HTML 节点）的子节点的变动，<code class="language-plaintext highlighter-rouge">subtree</code> 属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。</p> <p>下面的代码，使用 MutationObserver 对象封装一个监听 DOM 生成的函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">win</span><span class="p">){</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">listeners</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">win</span><span class="p">.</span><span class="nb">document</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">MutationObserver</span> <span class="o">=</span> <span class="nx">win</span><span class="p">.</span><span class="nx">MutationObserver</span> <span class="o">||</span> <span class="nx">win</span><span class="p">.</span><span class="nx">WebKitMutationObserver</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">observer</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">fn</span><span class="p">){</span>
    <span class="c1">// 储存选择器和回调函数</span>
    <span class="nx">listeners</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span>
      <span class="na">selector</span><span class="p">:</span> <span class="nx">selector</span><span class="p">,</span>
      <span class="na">fn</span><span class="p">:</span> <span class="nx">fn</span>
    <span class="p">});</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">observer</span><span class="p">){</span>
      <span class="c1">// 监听document变化</span>
      <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nx">check</span><span class="p">);</span>
      <span class="nx">observer</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="c1">// 检查该节点是否已经在DOM中</span>
    <span class="nf">check</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nf">check</span><span class="p">(){</span>
  <span class="c1">// 检查是否匹配已储存的节点</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">listeners</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">listener</span> <span class="o">=</span> <span class="nx">listeners</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="c1">// 检查指定节点是否有匹配</span>
      <span class="kd">var</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="nx">listener</span><span class="p">.</span><span class="nx">selector</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
        <span class="c1">// 确保回调函数只会对该元素调用一次</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">element</span><span class="p">.</span><span class="nx">ready</span><span class="p">){</span>
          <span class="nx">element</span><span class="p">.</span><span class="nx">ready</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="c1">// 对该节点调用回调函数</span>
          <span class="nx">listener</span><span class="p">.</span><span class="nx">fn</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 对外暴露ready</span>
  <span class="nx">win</span><span class="p">.</span><span class="nx">ready</span> <span class="o">=</span> <span class="nx">ready</span><span class="p">;</span>

<span class="p">})(</span><span class="k">this</span><span class="p">);</span>

<span class="c1">// 使用方法</span>
<span class="nf">ready</span><span class="p">(</span><span class="dl">'</span><span class="s1">.foo</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">){</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div></div> <h2 id="十一参考">十一、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/dom/">JavaScript 教程 - DOM</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><category term="dom"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - DOM》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/oop/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-11T00:00:00+00:00</published><updated>2024-10-11T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/oop</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/oop/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/oop/">《JavaScript 教程 - 面向对象编程》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一实例对象与-new-命令">一、实例对象与 new 命令</h2> <h3 id="1-对象是什么">1. 对象是什么</h3> <ul> <li>对象是单个实物的<strong>抽象</strong>。</li> <li>对象是一个<strong>容器</strong>，封装了属性（property）和方法（method）。</li> </ul> <h3 id="2-构造函数">2. 构造函数</h3> <p>JavaScript 语言的对象体系，不是基于“类”的，而是基于<strong>构造函数</strong>（constructor）和<strong>原型链</strong>（prototype）。</p> <p>构造函数（constructor）是用来生成实例对象的函数，作为对象的模板。构造函数的特点有两个。</p> <ul> <li>函数体内部使用了 <code class="language-plaintext highlighter-rouge">this</code> 关键字，代表了所要生成的对象实例。</li> <li>生成对象的时候，必须使用 <code class="language-plaintext highlighter-rouge">new</code> 命令。</li> </ul> <h3 id="3-new-命令">3. new 命令</h3> <h4 id="31-基本用法">3.1 基本用法</h4> <p><code class="language-plaintext highlighter-rouge">new</code> 命令用于执行构造函数，返回实例对象。</p> <p>如果忘记使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，直接调用构造函数，此时构造函数就变成了<strong>普通函数</strong>，并不会生成实例对象。此时 <code class="language-plaintext highlighter-rouge">this</code> 代表全局对象，将造成一些意想不到的结果。</p> <ul> <li> <p>一个解决办法是，构造函数内部使用严格模式，即第一行加上 <code class="language-plaintext highlighter-rouge">use strict</code>。这样的话，一旦忘了使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，直接调用构造函数就会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">){</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">Fubar</span><span class="p">()</span>
<span class="c1">// TypeError: Cannot set property '_foo' of undefined</span>
</code></pre></div> </div> </li> <li> <p>另一个解决办法，构造函数内部判断是否使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，如果发现没有使用，则直接返回一个实例对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Fubar</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">Fubar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="nx">_foo</span> <span class="c1">// 1</span>
<span class="p">(</span><span class="k">new</span> <span class="nc">Fubar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)).</span><span class="nx">_foo</span> <span class="c1">// 1</span>
</code></pre></div> </div> </li> </ul> <h4 id="32-new-命令的原理">3.2 new 命令的原理</h4> <p>使用 new 命令时，它后面的函数依次执行下面的步骤。</p> <ol> <li>创建一个<strong>空对象</strong>，作为将要返回的对象实例。</li> <li>将这个空对象的<strong>原型</strong>，指向构造函数的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性。</li> <li>将这个空对象赋值给函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 关键字。</li> <li>开始执行构造函数内部的代码。</li> </ol> <p>也就是说，构造函数内部，<code class="language-plaintext highlighter-rouge">this</code> 指的是一个新生成的空对象，所有针对 <code class="language-plaintext highlighter-rouge">this</code> 的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即 <code class="language-plaintext highlighter-rouge">this</code> 对象），将其“构造”为需要的样子。</p> <ul> <li>如果构造函数内部有 <code class="language-plaintext highlighter-rouge">return</code> 语句，而且 <code class="language-plaintext highlighter-rouge">return</code> 后面跟着一个<strong>对象</strong>，<code class="language-plaintext highlighter-rouge">new</code> 命令会返回 <code class="language-plaintext highlighter-rouge">return</code> 语句指定的<strong>对象</strong>；否则，就会不管 <code class="language-plaintext highlighter-rouge">return</code> 语句，返回 <code class="language-plaintext highlighter-rouge">this</code> 对象。</li> <li>如果 <code class="language-plaintext highlighter-rouge">return</code> 语句返回的是一个跟 <code class="language-plaintext highlighter-rouge">this</code> 无关的<strong>新对象</strong>，<code class="language-plaintext highlighter-rouge">new</code> 命令会返回这个<strong>新对象</strong>，而不是 <code class="language-plaintext highlighter-rouge">this</code> 对象。</li> <li> <p>如果对普通函数（内部没有 <code class="language-plaintext highlighter-rouge">this</code> 关键字的函数）使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，则会返回一个<strong>空对象</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getMessage</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">this is a message</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">getMessage</span><span class="p">();</span>

<span class="nx">msg</span> <span class="c1">// {}</span>
<span class="k">typeof</span> <span class="nx">msg</span> <span class="c1">// "object"</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">getMessage()</code> 是一个普通函数，返回一个字符串。对它使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，会得到一个<strong>空对象</strong>。这是因为 <code class="language-plaintext highlighter-rouge">new</code> 命令总是返回一个对象，要么是实例对象，要么是 <code class="language-plaintext highlighter-rouge">return</code> 语句指定的对象。本例中，<code class="language-plaintext highlighter-rouge">return</code> 语句返回的是字符串，所以 <code class="language-plaintext highlighter-rouge">new</code> 命令就忽略了该语句。</p> </li> </ul> <p><code class="language-plaintext highlighter-rouge">new</code> 命令简化的内部流程，可以用下面的代码表示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">_new</span><span class="p">(</span><span class="cm">/* 构造函数 */</span> <span class="kd">constructor</span><span class="p">,</span> <span class="cm">/* 构造函数参数 */</span> <span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 将 arguments 对象转为数组</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="c1">// 取出构造函数</span>
  <span class="kd">var</span> <span class="kd">constructor</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
  <span class="c1">// 创建一个空对象，继承构造函数的 prototype 属性</span>
  <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="c1">// 执行构造函数</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="kd">constructor</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="c1">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span>
  <span class="k">return </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">result</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">?</span> <span class="nx">result</span> <span class="p">:</span> <span class="nx">context</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 实例</span>
<span class="kd">var</span> <span class="nx">actor</span> <span class="o">=</span> <span class="nf">_new</span><span class="p">(</span><span class="nx">Person</span><span class="p">,</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
</code></pre></div></div> <h4 id="33-newtarget">3.3 new.target</h4> <p>函数内部可以使用 <code class="language-plaintext highlighter-rouge">new.target</code> 属性。如果当前函数是 <code class="language-plaintext highlighter-rouge">new</code> 命令调用，<code class="language-plaintext highlighter-rouge">new.target</code> 指向当前函数，否则为 <code class="language-plaintext highlighter-rouge">undefined</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">()</span> <span class="c1">// false</span>
<span class="k">new</span> <span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>
</code></pre></div></div> <p><strong>使用这个属性，可以判断函数调用的时候，是否使用 <code class="language-plaintext highlighter-rouge">new</code> 命令</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">请使用 new 命令调用！</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">()</span> <span class="c1">// Uncaught Error: 请使用 new 命令调用！</span>
</code></pre></div></div> <h3 id="4-objectcreate-创建实例对象">4. Object.create() 创建实例对象</h3> <p>如果希望以某个现有的对象作为模板，生成新的实例对象，可以使用 <code class="language-plaintext highlighter-rouge">Object.create()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">38</span><span class="p">,</span>
  <span class="na">greeting</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hi! I</span><span class="se">\'</span><span class="s1">m </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">person1</span><span class="p">);</span>

<span class="nx">person2</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// 张三</span>
<span class="nx">person2</span><span class="p">.</span><span class="nf">greeting</span><span class="p">()</span> <span class="c1">// Hi! I'm 张三.</span>
</code></pre></div></div> <h2 id="二this-关键字">二、this 关键字</h2> <h3 id="1-涵义">1. 涵义</h3> <p><code class="language-plaintext highlighter-rouge">this</code> 是属性或方法“当前”所在的对象。由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即 <code class="language-plaintext highlighter-rouge">this</code> 的指向是<strong>可变的</strong>。</p> <h3 id="2-实质">2. 实质</h3> <p>JavaScript 语言之所以有 <code class="language-plaintext highlighter-rouge">this</code> 的设计，跟内存里面的数据结构有关系。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span>  <span class="mi">5</span> <span class="p">};</span>
</code></pre></div></div> <p>上面的代码将一个对象赋值给变量 <code class="language-plaintext highlighter-rouge">obj</code>。JavaScript 引擎会先在内存里面，生成一个对象 <code class="language-plaintext highlighter-rouge">{ foo: 5 }</code>，然后把这个对象的内存地址赋值给变量 <code class="language-plaintext highlighter-rouge">obj</code>。也就是说，变量 <code class="language-plaintext highlighter-rouge">obj</code> 是一个地址（reference）。后面如果要读取 <code class="language-plaintext highlighter-rouge">obj.foo</code>，引擎先从 <code class="language-plaintext highlighter-rouge">obj</code> 拿到内存地址，然后再从该地址读出原始的对象，返回它的 <code class="language-plaintext highlighter-rouge">foo</code> 属性。</p> <p>原始的对象以字典结构保存，每个属性名都对应一个属性描述对象。举例来说，上面例子的 <code class="language-plaintext highlighter-rouge">foo</code> 属性，实际上是以下面的形式保存的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[[</span><span class="nx">value</span><span class="p">]]:</span> <span class="mi">5</span>
    <span class="p">[[</span><span class="nx">writable</span><span class="p">]]:</span> <span class="kc">true</span>
    <span class="p">[[</span><span class="nx">enumerable</span><span class="p">]]:</span> <span class="kc">true</span>
    <span class="p">[[</span><span class="nx">configurable</span><span class="p">]]:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 <code class="language-plaintext highlighter-rouge">foo</code> 属性的 <code class="language-plaintext highlighter-rouge">value</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[[</span><span class="nx">value</span><span class="p">]]:</span> <span class="nx">函数的地址</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">f</span><span class="p">:</span> <span class="nx">f</span> <span class="p">};</span>

<span class="c1">// 单独执行</span>
<span class="nf">f</span><span class="p">()</span>

<span class="c1">// obj 环境执行</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span>
</code></pre></div></div> <p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得<strong>当前的运行环境</strong>（context）。所以，<code class="language-plaintext highlighter-rouge">this</code> 就出现了，它的设计目的就是<strong>在函数体内部，指代函数当前的运行环境</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，函数体里面的 <code class="language-plaintext highlighter-rouge">this.x</code> 就是指当前运行环境的 <code class="language-plaintext highlighter-rouge">x</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 单独执行</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 1</span>

<span class="c1">// obj 环境执行</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面代码中，函数 <code class="language-plaintext highlighter-rouge">f</code> 在全局环境执行，<code class="language-plaintext highlighter-rouge">this.x</code> 指向全局环境的 <code class="language-plaintext highlighter-rouge">x</code>；在 <code class="language-plaintext highlighter-rouge">obj</code> 环境执行，<code class="language-plaintext highlighter-rouge">this.x</code> 指向 <code class="language-plaintext highlighter-rouge">obj.x</code>。</p> <h3 id="3-使用场合">3. 使用场合</h3> <ul> <li>全局环境：全局环境使用 <code class="language-plaintext highlighter-rouge">this</code>，指向顶层对象 <code class="language-plaintext highlighter-rouge">window</code>。</li> <li>构造函数：构造函数中使用 <code class="language-plaintext highlighter-rouge">this</code>，指向实例对象。</li> <li> <p>对象的方法：此时 <code class="language-plaintext highlighter-rouge">this</code> 指向方法运行时所在的对象。该方法赋值给另一个对象，就会改变 <code class="language-plaintext highlighter-rouge">this</code> 的指向。</p> <ul> <li> <p>如果 <code class="language-plaintext highlighter-rouge">this</code> 所在的方法不在对象的第一层，这时 <code class="language-plaintext highlighter-rouge">this</code> 只是指向当前层的对象，而不会继承更上面的层。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">m</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nf">m</span><span class="p">()</span> <span class="c1">// undefined</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">this</code> 指向 <code class="language-plaintext highlighter-rouge">a.b</code>。</p> </li> <li> <p>如果这时将嵌套对象内部的方法赋值给一个变量，<code class="language-plaintext highlighter-rouge">this</code> 依然会指向全局对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">b</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">m</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">hello</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span>
<span class="nf">hello</span><span class="p">()</span> <span class="c1">// undefined</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <h3 id="4-使用注意点">4. 使用注意点</h3> <h4 id="41-避免多层-this">4.1 避免多层 this</h4> <p>由于 <code class="language-plaintext highlighter-rouge">this</code> 的指向是不确定的，所以切勿在函数中包含多层的 <code class="language-plaintext highlighter-rouge">this</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f1</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f1</span><span class="p">()</span>
<span class="c1">// Object</span>
<span class="c1">// Window</span>
</code></pre></div></div> <p>上面代码包含两层 <code class="language-plaintext highlighter-rouge">this</code>，结果运行后，第一层指向对象 <code class="language-plaintext highlighter-rouge">o</code>，第二层指向全局对象。</p> <ul> <li> <p>一个解决方法是在第二层改用一个指向外层 <code class="language-plaintext highlighter-rouge">this</code> 的变量。使用一个变量固定 <code class="language-plaintext highlighter-rouge">this</code> 的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f1</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">that</span><span class="p">);</span>
    <span class="p">}();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f1</span><span class="p">()</span>
<span class="c1">// Object</span>
<span class="c1">// Object</span>
</code></pre></div> </div> </li> <li> <p>JavaScript 提供了<strong>严格模式</strong>，也可以硬性避免这种问题。严格模式下，如果函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 指向顶层对象，就会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">count</span><span class="p">:</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span><span class="p">;</span>
<span class="nf">f</span><span class="p">()</span>
<span class="c1">// TypeError: Cannot read property 'count' of undefined</span>
</code></pre></div> </div> </li> </ul> <h4 id="42-避免数组处理方法中的-this">4.2 避免数组处理方法中的 this</h4> <p>数组的 <code class="language-plaintext highlighter-rouge">map()</code> 和 <code class="language-plaintext highlighter-rouge">forEach()</code> 方法，允许提供一个函数作为参数。这个函数内部不应该使用 <code class="language-plaintext highlighter-rouge">this</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">v</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">p</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">a1</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a2</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">f</span><span class="p">:</span> <span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">v</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">item</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span>
<span class="c1">// undefined a1</span>
<span class="c1">// undefined a2</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">forEach()</code> 方法的回调函数中的 <code class="language-plaintext highlighter-rouge">this</code>，其实是指向 <code class="language-plaintext highlighter-rouge">window</code> 对象，因此取不到 <code class="language-plaintext highlighter-rouge">o.v</code> 的值。原因跟上一段的多层 <code class="language-plaintext highlighter-rouge">this</code> 是一样的，就是内层的 <code class="language-plaintext highlighter-rouge">this</code> 不指向外部，而指向顶层对象。</p> <h4 id="43-避免回调函数中的-this">4.3 避免回调函数中的 this</h4> <p>回调函数中的 <code class="language-plaintext highlighter-rouge">this</code> 往往会改变指向，最好避免使用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// jQuery 的写法</span>
<span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">#button</span><span class="dl">'</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，点击按钮以后，控制台会显示 <code class="language-plaintext highlighter-rouge">false</code>。原因是此时 <code class="language-plaintext highlighter-rouge">this</code> 不再指向 <code class="language-plaintext highlighter-rouge">o</code> 对象，而是指向按钮的 DOM 对象，因为 <code class="language-plaintext highlighter-rouge">f</code> 方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p> <h3 id="5-绑定-this-的方法">5. 绑定 this 的方法</h3> <h4 id="51-functionprototypecall">5.1 Function.prototype.call()</h4> <p>函数实例的 <code class="language-plaintext highlighter-rouge">call()</code> 方法可以指定函数内部 <code class="language-plaintext highlighter-rouge">this</code> 的指向。第一个参数是 <code class="language-plaintext highlighter-rouge">this</code> 所要指向的那个对象，后面的参数是函数调用时所需的参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">func</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">thisValue</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">call()</code> 方法的一个应用是<strong>调用对象的原生方法</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// 覆盖掉继承的 hasOwnProperty 方法</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">hasOwnProperty()</code> 是 <code class="language-plaintext highlighter-rouge">obj</code> 对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code class="language-plaintext highlighter-rouge">call()</code> 方法可以解决这个问题，它将 <code class="language-plaintext highlighter-rouge">hasOwnProperty()</code> 方法的原始定义放到 <code class="language-plaintext highlighter-rouge">obj</code> 对象上执行，这样无论 <code class="language-plaintext highlighter-rouge">obj</code> 上有没有同名方法，都不会影响结果。</p> <h4 id="52-functionprototypeapply">5.2 Function.prototype.apply()</h4> <p><code class="language-plaintext highlighter-rouge">apply()</code> 方法的作用与 <code class="language-plaintext highlighter-rouge">call()</code> 方法类似，也是改变 <code class="language-plaintext highlighter-rouge">this</code> 指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">func</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">thisValue</span><span class="p">,</span> <span class="p">[</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...])</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">apply()</code> 方法的一个常见的应用，就是利用数组对象的 <code class="language-plaintext highlighter-rouge">slice()</code> 方法，可以将一个类似数组的对象（比如 <code class="language-plaintext highlighter-rouge">arguments</code> 对象）转为真正的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">length</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// [1]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// []</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">length</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">// [1, undefined]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="na">length</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// [undefined]</span>
</code></pre></div></div> <h4 id="53-functionprototypebind">5.3 Function.prototype.bind()</h4> <p><code class="language-plaintext highlighter-rouge">bind()</code> 方法用于将函数体内的 <code class="language-plaintext highlighter-rouge">this</code> 绑定到某个对象，然后返回一个<strong>新函数</strong>。<code class="language-plaintext highlighter-rouge">bind()</code> 方法有一些使用注意点。</p> <ul> <li>每次返回一个新函数</li> <li>结合回调函数使用</li> <li>结合 <code class="language-plaintext highlighter-rouge">call()</code> 方法使用：利用 <code class="language-plaintext highlighter-rouge">bind()</code> 方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的 <code class="language-plaintext highlighter-rouge">slice()</code> 方法为例。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span>
<span class="c1">// 等同于</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span>
</code></pre></div></div> <h2 id="三对象的继承">三、对象的继承</h2> <h3 id="1-objectgetprototypeof">1. Object.getPrototypeOf()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法返回参数对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <p>下面是几种特殊对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 空对象的原型是 Object.prototype</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">({})</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>

<span class="c1">// Object.prototype 的原型是 null</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span> <span class="c1">// true</span>

<span class="c1">// 函数的原型是 Function.prototype</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="2-objectsetprototypeof">2. Object.setPrototypeOf()</h3> <p><code class="language-plaintext highlighter-rouge">Object.setPrototypeOf()</code> 方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">setPrototypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">===</span> <span class="nx">b</span> <span class="c1">// true</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// 1</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">new</code> 命令可以使用 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf()</code> 方法模拟。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">setPrototypeOf</span><span class="p">({},</span> <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nx">F</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">new</code> 命令新建实例对象，其实可以分成两步。</p> <ul> <li>第一步，将一个空对象的原型设为构造函数的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性（上例是 <code class="language-plaintext highlighter-rouge">F.prototype</code>）；</li> <li>第二步，将构造函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 绑定这个空对象，然后执行构造函数，使得定义在 <code class="language-plaintext highlighter-rouge">this</code> 上面的方法和属性（上例是 <code class="language-plaintext highlighter-rouge">this.foo</code>），都转移到这个空对象上。</li> </ul> <h3 id="3-objectcreate">3. Object.create()</h3> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 原型对象</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">print</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 实例对象</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span> <span class="o">===</span> <span class="nx">A</span> <span class="c1">// true</span>
<span class="nx">B</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// hello</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法可以用下面的代码代替。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码表明，<code class="language-plaintext highlighter-rouge">Object.create()</code> 方法的实质是新建一个空的构造函数 <code class="language-plaintext highlighter-rouge">F</code>，然后让 <code class="language-plaintext highlighter-rouge">F.prototype</code> 属性指向参数对象 <code class="language-plaintext highlighter-rouge">obj</code>，最后返回一个 <code class="language-plaintext highlighter-rouge">F</code> 的实例，从而实现让该实例继承 <code class="language-plaintext highlighter-rouge">obj</code> 的属性。</p> <p>下面三种方式生成的新对象是等价的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({});</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">obj3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
</code></pre></div></div> <p>如果想要生成一个不继承任何属性（比如没有 <code class="language-plaintext highlighter-rouge">toString()</code> 和 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法）的对象，可以将 <code class="language-plaintext highlighter-rouge">Object.create()</code> 的参数设为 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// TypeError: Object [object Object] has no method 'valueOf'</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">obj1</span><span class="p">);</span>

<span class="nx">obj1</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 2</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法可以接受第二个参数。该参数是一个<strong>属性描述对象</strong>，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({},</span> <span class="p">{</span>
  <span class="na">p1</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">p2</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({});</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p2</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法生成的对象，继承了它的原型对象的构造函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">A</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>

<span class="nx">b</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">A</span> <span class="c1">// true</span>
<span class="nx">b</span> <span class="k">instanceof</span> <span class="nx">A</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="4-objectprototypeisprototypeof">4. Object.prototype.isPrototypeOf()</h3> <p>实例对象的 <code class="language-plaintext highlighter-rouge">isPrototypeOf()</code> 方法，用来判断该对象是否为参数对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">o1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">o3</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">o2</span><span class="p">);</span>

<span class="nx">o2</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nx">o3</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">o1</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nx">o3</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">o1</code> 和 <code class="language-plaintext highlighter-rouge">o2</code> 都是 <code class="language-plaintext highlighter-rouge">o3</code> 的原型。这表明只要实例对象处在参数对象的<strong>原型链</strong>上，<code class="language-plaintext highlighter-rouge">isPrototypeOf()</code> 方法都返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="sr">/xyz/</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">))</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 处于原型链的最顶端，所以对各种实例都返回 <code class="language-plaintext highlighter-rouge">true</code>，只有直接继承自 <code class="language-plaintext highlighter-rouge">null</code> 的对象除外。</p> <h3 id="5-objectprototypeproto">5. Object.prototype.<strong>proto</strong></h3> <p>实例对象的 <code class="language-plaintext highlighter-rouge">__proto__</code> 属性，返回该对象的<strong>原型</strong>。该属性<strong>可读写</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// true</span>
</code></pre></div></div> <p>根据语言标准，<code class="language-plaintext highlighter-rouge">__proto__</code> 属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 和 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p> <p>原型链可以用 <code class="language-plaintext highlighter-rouge">__proto__</code> 很直观地表示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">李四</span><span class="dl">'</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">print</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>

<span class="nx">A</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// 张三</span>
<span class="nx">B</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// 李四</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">A</code> 对象和 <code class="language-plaintext highlighter-rouge">B</code> 对象的原型都是 <code class="language-plaintext highlighter-rouge">proto</code> 对象，它们都共享 <code class="language-plaintext highlighter-rouge">proto</code> 对象的 <code class="language-plaintext highlighter-rouge">print</code> 方法。也就是说，<code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 的 <code class="language-plaintext highlighter-rouge">print</code> 方法，都是在调用 <code class="language-plaintext highlighter-rouge">proto</code> 对象的 <code class="language-plaintext highlighter-rouge">print</code> 方法。</p> <h3 id="6-获取原型对象方法的比较">6. 获取原型对象方法的比较</h3> <p>获取实例对象 obj 的原型对象，有三种方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">obj.__proto__</code></li> <li><code class="language-plaintext highlighter-rouge">obj.constructor.prototype</code></li> <li><code class="language-plaintext highlighter-rouge">Object.getPrototypeOf(obj)</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面三种方法之中，前两种都不是很可靠。<code class="language-plaintext highlighter-rouge">__proto__</code> 属性只有浏览器才需要部署，其他环境可以不部署。而 <code class="language-plaintext highlighter-rouge">obj.constructor.prototype</code> 在手动改变原型对象时，可能会失效。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">P</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">P</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">C</span><span class="p">();</span>

<span class="nx">c</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，构造函数 <code class="language-plaintext highlighter-rouge">C</code> 的原型对象被改成了 <code class="language-plaintext highlighter-rouge">p</code>，但是实例对象的 <code class="language-plaintext highlighter-rouge">c.constructor.prototype</code> 却没有指向 <code class="language-plaintext highlighter-rouge">p</code>。所以，在改变原型对象时，一般要同时设置 <code class="language-plaintext highlighter-rouge">constructor</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">C</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">C</span><span class="p">();</span>
<span class="nx">c</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// true</span>
</code></pre></div></div> <p>因此，推荐使用第三种 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法，获取原型对象。</p> <h3 id="7-objectgetownpropertynames">7. Object.getOwnPropertyNames()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyNames()</code> 方法返回一个数组，成员是参数对象<strong>自身的</strong>所有属性（包括<strong>可枚举的属性</strong>、<strong>不可枚举的</strong>属性）的键名，不包含继承的属性键名。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nb">Date</span><span class="p">)</span>
<span class="c1">// ["parse", "arguments", "UTC", "caller", "name", "prototype", "now", "length"]</span>
</code></pre></div></div> <h3 id="8-objectprototypehasownproperty">8. Object.prototype.hasOwnProperty()</h3> <p>对象实例的 <code class="language-plaintext highlighter-rouge">hasOwnProperty()</code> 方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Date</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">length</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h3 id="9-in-运算符和-forin-循环">9. in 运算符和 for…in 循环</h3> <ul> <li><code class="language-plaintext highlighter-rouge">in</code> 运算符返回一个布尔值，表示一个对象是否具有某个属性。包括对象<strong>自身的</strong>和<strong>继承的</strong>属性。<code class="language-plaintext highlighter-rouge">in</code> 运算符常用于检查一个属性是否存在。</li> <li><code class="language-plaintext highlighter-rouge">for...in</code> 循环用于获取对象<strong>自身的</strong>和<strong>继承的</strong>所有可遍历属性。</li> </ul> <p>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">inheritedPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">props</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">props</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="10-对象的拷贝">10. 对象的拷贝</h3> <p>如果要拷贝一个对象，需要做到下面两件事情。</p> <ul> <li>确保拷贝后的对象，与原对象具有同样的<strong>原型</strong>。</li> <li>确保拷贝后的对象，与原对象具有同样的<strong>实例属性</strong>。</li> </ul> <p>下面就是根据上面两点，实现的对象拷贝函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">copyObject</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">copy</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">orig</span><span class="p">));</span>
  <span class="nf">copyOwnPropertiesFrom</span><span class="p">(</span><span class="nx">copy</span><span class="p">,</span> <span class="nx">orig</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">copy</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">copyOwnPropertiesFrom</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span>
    <span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">propKey</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">desc</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">);</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">desc</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="k">return</span> <span class="nx">target</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>另一种更简单的写法，是利用 ES2017 才引入标准的 <code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptors()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">copyObject</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">orig</span><span class="p">),</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="四object-对象的相关方法">四、Object 对象的相关方法</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="五严格模式">五、严格模式</h2> <h3 id="1-设计目的">1. 设计目的</h3> <p>ES5 引入了严格模式，主要目的有以下几个。</p> <ul> <li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li> <li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li> <li>提高编译器效率，提升运行速度。</li> <li>为未来新版本的 JavaScript 语法做好铺垫。</li> </ul> <h3 id="2-启用方法">2. 启用方法</h3> <p>进入严格模式的标志，是一行字符串 <code class="language-plaintext highlighter-rouge">use strict</code>。老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p> <ul> <li>整个脚本文件：<code class="language-plaintext highlighter-rouge">use strict</code> 放在脚本文件的第一行，整个脚本都将以严格模式运行。</li> <li>单个函数：<code class="language-plaintext highlighter-rouge">use strict</code> 放在函数体的第一行，则整个函数以严格模式运行。</li> </ul> <h3 id="3-显式报错">3. 显式报错</h3> <h4 id="31-只读属性不可写">3.1 只读属性不可写</h4> <p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 对只读属性赋值会报错</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="c1">// TypeError: Cannot assign to read only property 'a' of object #&lt;Object&gt;</span>

<span class="c1">// 删除不可配置的属性会报错</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>
<span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">p</span>
<span class="c1">// TypeError: Cannot delete property 'p' of #&lt;Object&gt;</span>
</code></pre></div></div> <h4 id="32-只设置了取值器的属性不可写">3.2 只设置了取值器的属性不可写</h4> <p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nf">v</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">v</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span>
</code></pre></div></div> <h4 id="33-禁止扩展的对象不可扩展">3.3 禁止扩展的对象不可扩展</h4> <p>严格模式下，对禁止扩展的对象添加新属性会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// Uncaught TypeError: Cannot add property v, object is not extensible</span>
</code></pre></div></div> <h4 id="34-evalarguments-不可用作标识名">3.4 eval、arguments 不可用作标识名</h4> <p>严格模式下，使用 <code class="language-plaintext highlighter-rouge">eval</code> 或者 <code class="language-plaintext highlighter-rouge">arguments</code> 作为标识名会报错。下面的语句都会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nb">eval</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">arguments</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="kd">set</span> <span class="nf">p</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">};</span>
<span class="k">try</span> <span class="p">{</span> <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nf">x</span><span class="p">(</span><span class="nb">eval</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nf">arguments</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">eval</span><span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Function</span><span class="p">(</span><span class="dl">'</span><span class="s1">arguments</span><span class="dl">'</span><span class="p">,</span> <span class="dl">"</span><span class="s2">'use strict'; return 17;</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// SyntaxError: Unexpected eval or arguments in strict mode</span>
</code></pre></div></div> <h4 id="35-函数不能有重名的参数">3.5 函数不能有重名的参数</h4> <p>正常模式下，如果函数有多个重名的参数，可以用 <code class="language-plaintext highlighter-rouge">arguments[i]</code> 读取。严格模式下，这属于语法错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre></div></div> <h4 id="36-禁止八进制的前缀-0-表示法">3.6 禁止八进制的前缀 0 表示法</h4> <p>正常模式下，整数的第一位如果是 <code class="language-plaintext highlighter-rouge">0</code>，表示这是八进制数，比如 <code class="language-plaintext highlighter-rouge">0100</code> 等于十进制的 <code class="language-plaintext highlighter-rouge">64</code>。严格模式禁止这种表示法，整数第一位为 <code class="language-plaintext highlighter-rouge">0</code>，将报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0100</span><span class="p">;</span>
<span class="c1">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span>
</code></pre></div></div> <h3 id="4-增强的安全措施">4. 增强的安全措施</h3> <h4 id="41-全局变量显式声明">4.1 全局变量显式声明</h4> <p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 报错，v 未声明</span>

<span class="k">for </span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 报错，i 未声明</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 报错，未声明就创建一个全局变量</span>
</code></pre></div></div> <h4 id="42-禁止-this-关键字指向全局对象">4.2 禁止 this 关键字指向全局对象</h4> <p>正常模式下，函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正常模式</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>

<span class="c1">// 严格模式</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>
</code></pre></div></div> <p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 <code class="language-plaintext highlighter-rouge">new</code>，这时 <code class="language-plaintext highlighter-rouge">this</code> 不再指向全局对象，而是报错。</p> <h4 id="43-禁止使用-fncalleefncaller">4.3 禁止使用 fn.callee、fn.caller</h4> <p>函数内部不得使用 <code class="language-plaintext highlighter-rouge">fn.caller</code>、<code class="language-plaintext highlighter-rouge">fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">f1</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>    <span class="c1">// 报错</span>
  <span class="nx">f1</span><span class="p">.</span><span class="nx">arguments</span><span class="p">;</span> <span class="c1">// 报错</span>
<span class="p">}</span>

<span class="nf">f1</span><span class="p">();</span>
</code></pre></div></div> <h4 id="44-禁止使用-argumentscalleeargumentscaller">4.4 禁止使用 arguments.callee、arguments.caller</h4> <p><code class="language-plaintext highlighter-rouge">arguments.callee</code> 和 <code class="language-plaintext highlighter-rouge">arguments.caller</code> 是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用 <code class="language-plaintext highlighter-rouge">arguments.callee</code>、<code class="language-plaintext highlighter-rouge">arguments.caller</code> 将会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">;</span>
<span class="p">};</span>

<span class="nf">f</span><span class="p">();</span> <span class="c1">// 报错</span>
</code></pre></div></div> <h4 id="45-禁止删除变量">4.5 禁止删除变量</h4> <p>严格模式下无法删除变量，如果使用 <code class="language-plaintext highlighter-rouge">delete</code> 命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的 <code class="language-plaintext highlighter-rouge">configurable: true</code>，才能被 <code class="language-plaintext highlighter-rouge">delete</code> 命令删除。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// 语法错误</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// 删除成功</span>
</code></pre></div></div> <h3 id="5-静态绑定">5. 静态绑定</h3> <h4 id="51-禁止使用-with-语句">5.1 禁止使用 with 语句</h4> <p>严格模式下，使用 <code class="language-plaintext highlighter-rouge">with</code> 语句将报错。因为 <code class="language-plaintext highlighter-rouge">with</code> 语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nf">with </span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Uncaught SyntaxError: Strict mode code may not include a with statement</span>
</code></pre></div></div> <h4 id="52-创设-eval-作用域">5.2 创设 eval 作用域</h4> <p>正常模式下，JavaScript 语言有两种变量作用域（scope）：<strong>全局作用域</strong>和<strong>函数作用域</strong>。严格模式创设了第三种作用域：<strong>eval 作用域</strong>。</p> <p>正常模式下，<code class="language-plaintext highlighter-rouge">eval</code> 语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code class="language-plaintext highlighter-rouge">eval</code> 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code class="language-plaintext highlighter-rouge">eval</code> 所生成的变量只能用于 <code class="language-plaintext highlighter-rouge">eval</code> 内部。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="dl">'</span><span class="s1">var x = 5; x</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// 5</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="p">})()</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">eval</code> 语句内部是一个独立作用域，所以内部的变量 <code class="language-plaintext highlighter-rouge">x</code> 不会泄露到外部。</p> <h4 id="53-arguments-不再追踪参数的变化">5.3 arguments 不再追踪参数的变化</h4> <p>变量 <code class="language-plaintext highlighter-rouge">arguments</code> 代表函数的参数。严格模式下，函数内部改变参数与 <code class="language-plaintext highlighter-rouge">arguments</code> 的联系被切断了，两者不再存在联动关系。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 正常模式为[2, 2]</span>

<span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 严格模式为[2, 1]</span>
</code></pre></div></div> <h3 id="6-保留字">6. 保留字</h3> <p>严格模式新增了一些保留字（<code class="language-plaintext highlighter-rouge">implements</code>、<code class="language-plaintext highlighter-rouge">interface</code>、<code class="language-plaintext highlighter-rouge">let</code>、<code class="language-plaintext highlighter-rouge">package</code>、<code class="language-plaintext highlighter-rouge">private</code>、<code class="language-plaintext highlighter-rouge">protected</code>、<code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">static</code>、<code class="language-plaintext highlighter-rouge">yield</code> 等）。使用这些词作为变量名将会报错。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/oop/">JavaScript 教程 - 面向对象编程</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><category term="oop"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 面向对象编程》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/features/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/features</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/features/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/features/">《JavaScript 教程 - 语法专题》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一数据类型的转换">一、数据类型的转换</h2> <h3 id="1-强制转换">1. 强制转换</h3> <p>强制转换主要指使用 <code class="language-plaintext highlighter-rouge">Boolean()</code>、<code class="language-plaintext highlighter-rouge">Number()</code> 和 <code class="language-plaintext highlighter-rouge">String()</code> 三个函数，手动转换成布尔值、数字或者字符串。</p> <h4 id="11-boolean">1.1 Boolean()</h4> <p><code class="language-plaintext highlighter-rouge">Boolean()</code> 函数将任意类型的值转为布尔值。除了以下五个值的转换结果为 <code class="language-plaintext highlighter-rouge">false</code>，其他的值全部为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">undefined</code></li> <li><code class="language-plaintext highlighter-rouge">null</code></li> <li><code class="language-plaintext highlighter-rouge">0</code>（包含 <code class="language-plaintext highlighter-rouge">-0</code> 和 <code class="language-plaintext highlighter-rouge">+0</code>）</li> <li><code class="language-plaintext highlighter-rouge">NaN</code></li> <li><code class="language-plaintext highlighter-rouge">''</code>（空字符串）</li> </ul> <p>所有对象的布尔值都是 <code class="language-plaintext highlighter-rouge">true</code>，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于 <code class="language-plaintext highlighter-rouge">obj1</code> &amp;&amp; <code class="language-plaintext highlighter-rouge">obj2</code> 这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Boolean</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="12-number">1.2 Number()</h4> <p><code class="language-plaintext highlighter-rouge">Number()</code> 函数将任意类型的值转化成数值。</p> <h5 id="1原始类型值">（1）原始类型值</h5> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数值：转换后还是原来的值</span>
<span class="nc">Number</span><span class="p">(</span><span class="mi">324</span><span class="p">)</span> <span class="c1">// 324</span>

<span class="c1">// 字符串：如果可以被解析为数值，则转换为相应的数值</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">324</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 324</span>

<span class="c1">// 字符串：如果不可以被解析为数值，返回 NaN</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">324abc</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// NaN</span>

<span class="c1">// 空字符串转为0</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">''</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="c1">// 布尔值：true 转成 1，false 转成 0</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="c1">// undefined：转成 NaN</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// NaN</span>

<span class="c1">// null：转成 0</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 0</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Number()</code> 函数将字符串转为数值，要比 <code class="language-plaintext highlighter-rouge">parseInt()</code> 函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为 <code class="language-plaintext highlighter-rouge">NaN</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 42</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// NaN</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">parseInt()</code> 逐个解析字符，而 <code class="language-plaintext highlighter-rouge">Number()</code> 函数整体转换字符串的类型。</p> <p><code class="language-plaintext highlighter-rouge">parseInt()</code> 和 <code class="language-plaintext highlighter-rouge">Number()</code> 函数都会自动过滤一个字符串前导和后缀的空格。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="se">\t\</span><span class="s1">v</span><span class="se">\r</span><span class="s1">12.34</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 12</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="se">\t\</span><span class="s1">v</span><span class="se">\r</span><span class="s1">12.34</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 12.34</span>
</code></pre></div></div> <h5 id="2对象">（2）对象</h5> <p><code class="language-plaintext highlighter-rouge">Number()</code> 方法的参数是对象时，将返回 <code class="language-plaintext highlighter-rouge">NaN</code>，除非是包含单个数值的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// NaN</span>
<span class="nc">Number</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// NaN</span>
<span class="nc">Number</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// 5</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Number()</code> 方法的参数是对象时的转换规则是这样。</p> <ol> <li>调用对象自身的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。如果返回原始类型的值，则直接对该值使用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数，不再进行后续步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回的还是对象，则改为调用对象自身的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数，不再进行后续步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回的是对象，就报错。</li> </ol> <p>默认情况下，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回对象本身，所以一般总是会调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，而 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回对象的类型字符串（比如 <code class="language-plaintext highlighter-rouge">[object Object]</code>）。当然，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，都是可以自定义的。</p> <h4 id="13-string">1.3 String()</h4> <p><code class="language-plaintext highlighter-rouge">String()</code> 函数可以将任意类型的值转化成字符串。</p> <h5 id="1原始类型值-1">（1）原始类型值</h5> <ul> <li><strong>数值</strong>：转为相应的字符串。</li> <li><strong>字符串</strong>：转换后还是原来的值。</li> <li><strong>布尔值</strong>：<code class="language-plaintext highlighter-rouge">true</code> 转为字符串 <code class="language-plaintext highlighter-rouge">"true"</code>，<code class="language-plaintext highlighter-rouge">false</code> 转为字符串 <code class="language-plaintext highlighter-rouge">"false"</code>。</li> <li><strong>undefined</strong>：转为字符串 <code class="language-plaintext highlighter-rouge">"undefined"</code>。</li> <li><strong>null</strong>：转为字符串 <code class="language-plaintext highlighter-rouge">"null"</code>。</li> </ul> <h5 id="2对象-1">（2）对象</h5> <p><code class="language-plaintext highlighter-rouge">String()</code> 方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// "[object Object]"</span>
<span class="nc">String</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// "1,2,3"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">String()</code> 方法的参数是对象时的转换规则跟 <code class="language-plaintext highlighter-rouge">Number()</code> 类似，只是互换了 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法和 <code class="language-plaintext highlighter-rouge">toString()</code> 方法的执行顺序。</p> <ul> <li>先调用对象自身的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。如果返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">String()</code> 函数，不再进行以下步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回的是对象，再调用原对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">String()</code> 函数，不再进行以下步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回的是对象，就报错。</li> </ul> <h3 id="2-自动转换">2. 自动转换</h3> <p>自动转换发生在三种情况：不同类型的数据互相运算、对非布尔值类型的数据求布尔值以及对非数值类型的值使用一元运算符（即 <code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">123</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span> <span class="c1">// "123abc"</span>

<span class="k">if </span><span class="p">(</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>  <span class="c1">// "hello"</span>

<span class="o">+</span> <span class="p">{</span><span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">}</span> <span class="c1">// NaN</span>
<span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1">// NaN</span>
</code></pre></div></div> <h4 id="21-自动转换为布尔值">2.1 自动转换为布尔值</h4> <p>预期为布尔值的地方（比如 <code class="language-plaintext highlighter-rouge">if</code> 语句的条件部分），系统内部会自动调用 <code class="language-plaintext highlighter-rouge">Boolean()</code> 函数将非布尔值的参数自动转换为布尔值。</p> <h4 id="22-自动转换为字符串">2.2 自动转换为字符串</h4> <p>预期为字符串的地方，就会将非字符串的值自动转为字符串。主要发生在字符串的加法运算时，当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p> <h4 id="23-自动转换为数值">2.3 自动转换为数值</h4> <p>预期为数值的地方，系统内部会自动调用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数将参数值自动转换为数值。除了加法运算符（<code class="language-plaintext highlighter-rouge">+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p> <h2 id="二错误处理机制">二、错误处理机制</h2> <h3 id="1-error-实例对象">1. Error 实例对象</h3> <p>JavaScript 抛出的错误都是 <code class="language-plaintext highlighter-rouge">Error</code> 构造函数的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">err</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">出错了</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">err</span><span class="p">.</span><span class="nx">message</span> <span class="c1">// "出错了"</span>
</code></pre></div></div> <p>JavaScript 语言标准只提到，<code class="language-plaintext highlighter-rouge">Error</code> 实例对象必须有 <code class="language-plaintext highlighter-rouge">message</code> 属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对 <code class="language-plaintext highlighter-rouge">Error</code> 实例还提供 <code class="language-plaintext highlighter-rouge">name</code> 和 <code class="language-plaintext highlighter-rouge">stack</code> 属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p> <ul> <li><code class="language-plaintext highlighter-rouge">message</code>：错误提示信息</li> <li><code class="language-plaintext highlighter-rouge">name</code>：错误名称（非标准属性）</li> <li><code class="language-plaintext highlighter-rouge">stack</code>：错误的堆栈（非标准属性）</li> </ul> <h3 id="2-原生错误类型">2. 原生错误类型</h3> <p>JavaScript 在 <code class="language-plaintext highlighter-rouge">Error</code> 对象的基础上，定义了其他 6 种派生对象。</p> <h4 id="21-syntaxerror-对象">2.1 SyntaxError 对象</h4> <p><code class="language-plaintext highlighter-rouge">SyntaxError</code> 对象是解析代码时发生的语法错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 变量名错误</span>
<span class="kd">var</span> <span class="mi">1</span><span class="nx">a</span><span class="p">;</span>
<span class="c1">// Uncaught SyntaxError: Invalid or unexpected token</span>

<span class="c1">// 缺少括号</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Uncaught SyntaxError: Unexpected string</span>
</code></pre></div></div> <h4 id="22-referenceerror-对象">2.2 ReferenceError 对象</h4> <p><code class="language-plaintext highlighter-rouge">ReferenceError</code> 对象是引用一个不存在的变量时发生的错误。</p> <h4 id="23-rangeerror-对象">2.3 RangeError 对象</h4> <p><code class="language-plaintext highlighter-rouge">RangeError</code> 对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是 <code class="language-plaintext highlighter-rouge">Number</code> 对象的方法参数超出范围，以及函数堆栈超过最大值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组长度不得为负数</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Uncaught RangeError: Invalid array length</span>
</code></pre></div></div> <h4 id="24-typeerror-对象">2.4 TypeError 对象</h4> <p><code class="language-plaintext highlighter-rouge">TypeError</code> 对象是变量或参数不是预期类型时发生的错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="mi">123</span>
<span class="c1">// Uncaught TypeError: 123 is not a constructor</span>
</code></pre></div></div> <h4 id="25-urierror-对象">2.5 URIError 对象</h4> <p><code class="language-plaintext highlighter-rouge">URIError</code> 对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及 <code class="language-plaintext highlighter-rouge">encodeURI()</code>、<code class="language-plaintext highlighter-rouge">decodeURI()</code>、<code class="language-plaintext highlighter-rouge">encodeURIComponent()</code>、<code class="language-plaintext highlighter-rouge">decodeURIComponent()</code>、<code class="language-plaintext highlighter-rouge">escape()</code> 和 <code class="language-plaintext highlighter-rouge">unescape()</code> 这六个函数。</p> <h4 id="26-evalerror-对象">2.6 EvalError 对象</h4> <p><code class="language-plaintext highlighter-rouge">eval</code> 函数没有被正确执行时，会抛出 <code class="language-plaintext highlighter-rouge">EvalError</code> 错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p> <h3 id="3-自定义错误">3. 自定义错误</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">UserError</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">默认信息</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">UserError</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">UserError</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">();</span>
<span class="nx">UserError</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">UserError</span><span class="p">;</span>

<span class="k">new</span> <span class="nc">UserError</span><span class="p">(</span><span class="dl">'</span><span class="s1">这是自定义的错误！</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码自定义一个错误对象 <code class="language-plaintext highlighter-rouge">UserError</code>，让它<strong>继承</strong> <code class="language-plaintext highlighter-rouge">Error</code> 对象。然后，就可以生成这种自定义类型的错误了。</p> <h3 id="4-throw-语句">4. throw 语句</h3> <p><code class="language-plaintext highlighter-rouge">throw</code> 语句用于手动中断程序执行，抛出一个错误。可以是系统错误，也可以是自定义错误。实际上，<code class="language-plaintext highlighter-rouge">throw</code> 可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p> <h3 id="5-trycatch-和-trycatchfinally-结构">5. try…catch 和 try…catch…finally 结构</h3> <p><code class="language-plaintext highlighter-rouge">catch</code> 代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p> <p>下面的例子反映了 <code class="language-plaintext highlighter-rouge">try...catch...finally</code> 三者之间的执行顺序。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">throw</span> <span class="dl">'</span><span class="s1">bug</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 这句原本会延迟到 finally 代码块结束再执行</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 不会运行</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 这句会覆盖掉前面那句 return</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 不会运行</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 不会运行</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nf">f</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="c1">// 1</span>
<span class="c1">// 3</span>

<span class="nx">result</span>
<span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">catch</code> 代码块结束执行之前，会先执行 <code class="language-plaintext highlighter-rouge">finally</code> 代码块。</p> <h2 id="三编程风格">三、编程风格</h2> <h3 id="1-缩进">1. 缩进</h3> <p>不管是空格和 Tab 键，坚持使用一种方式。</p> <h3 id="2-区块">2. 区块</h3> <p>总是使用<strong>大括号</strong>表示区块。区块起首的大括号跟在关键字的后面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">block</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="3-圆括号">3. 圆括号</h3> <p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。建议可以用空格，区分这两种不同的括号。</p> <ul> <li>表示函数调用和定义时，函数名与左括号之间没有空格。</li> <li>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</li> </ul> <h3 id="5-行尾的分号">5. 行尾的分号</h3> <h4 id="51-不使用分号的情况">5.1 不使用分号的情况</h4> <ul> <li><code class="language-plaintext highlighter-rouge">for</code> 和 <code class="language-plaintext highlighter-rouge">while</code> 循环</li> <li>分支语句：<code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">switch</code> 和 <code class="language-plaintext highlighter-rouge">try</code></li> <li>函数的声明语句</li> </ul> <h4 id="52-分号的自动添加">5.2 分号的自动添加</h4> <p>除了上边三种情况，所有语句都应该使用分号（即使如果没有使用分号，大多数情况下，JavaScript 会自动添加）。</p> <h3 id="6-全局变量">6. 全局变量</h3> <p>避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如 <code class="language-plaintext highlighter-rouge">UPPER_CASE</code>。</p> <h3 id="7-变量声明">7. 变量声明</h3> <p>变量最好放在代码块的头部。所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</p> <h3 id="8-with-语句">8. with 语句</h3> <p><code class="language-plaintext highlighter-rouge">with</code> 可以减少代码的书写，但是会造成混淆。因此，不要使用 <code class="language-plaintext highlighter-rouge">with</code> 语句。</p> <h3 id="9-相等和严格相等">9. 相等和严格相等</h3> <p>相等运算符会自动转换变量类型，造成很多意想不到的情况。建议不要使用相等运算符（<code class="language-plaintext highlighter-rouge">==</code>），只使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）。</p> <h3 id="10-语句的合并">10. 语句的合并</h3> <p>建议不要将不同目的的语句，合并成一行。</p> <h3 id="11-自增和自减运算符">11. 自增和自减运算符</h3> <p>建议自增（<code class="language-plaintext highlighter-rouge">++</code>）和自减（<code class="language-plaintext highlighter-rouge">--</code>）运算符尽量使用 <code class="language-plaintext highlighter-rouge">+=</code> 和 <code class="language-plaintext highlighter-rouge">-=</code> 代替。</p> <h3 id="12-switchcase-结构">12. switch…case 结构</h3> <p><code class="language-plaintext highlighter-rouge">switch...case</code> 结构要求，在每个 <code class="language-plaintext highlighter-rouge">case</code> 的最后一行必须是 <code class="language-plaintext highlighter-rouge">break</code> 语句，否则会接着运行下一个 <code class="language-plaintext highlighter-rouge">case</code>。这样不仅容易忘记，还会造成代码的冗长。</p> <p>而且，<code class="language-plaintext highlighter-rouge">switch...case</code> 不使用大括号，不利于代码形式的统一。此外，这种结构类似于 <code class="language-plaintext highlighter-rouge">goto</code> 语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch </span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid action.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码建议改写成对象结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">actions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">actions</span><span class="p">[</span><span class="nx">action</span><span class="p">]</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid action.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">actions</span><span class="p">[</span><span class="nx">action</span><span class="p">]();</span>
<span class="p">}</span>
</code></pre></div></div> <p>因此，建议 <code class="language-plaintext highlighter-rouge">switch...case</code> 结构可以用对象结构代替。</p> <h2 id="四console-对象与控制台">四、console 对象与控制台</h2> <h3 id="1-console-对象">1. console 对象</h3> <p><code class="language-plaintext highlighter-rouge">console</code> 对象可以输出各种信息到控制台。<code class="language-plaintext highlighter-rouge">console</code> 的常见用途有两个。</p> <ul> <li>调试程序，显示网页代码运行时的错误信息。</li> <li>提供了一个命令行接口，用来与网页代码互动。</li> </ul> <h3 id="2-console-对象的静态方法">2. console 对象的静态方法</h3> <h4 id="21-consolelogconsoleinfoconsoledebug">2.1 console.log()，console.info()，console.debug()</h4> <p><code class="language-plaintext highlighter-rouge">console.log</code> 方法用于在控制台输出信息。它可以接受一个或多个参数，不同类型的数据必须使用对应的占位符。</p> <ul> <li><code class="language-plaintext highlighter-rouge">%s</code> 字符串</li> <li><code class="language-plaintext highlighter-rouge">%d</code> 整数</li> <li><code class="language-plaintext highlighter-rouge">%i</code> 整数</li> <li><code class="language-plaintext highlighter-rouge">%f</code> 浮点数</li> <li><code class="language-plaintext highlighter-rouge">%o</code> 对象的链接</li> <li><code class="language-plaintext highlighter-rouge">%c</code> CSS 格式字符串</li> </ul> <p>使用 <code class="language-plaintext highlighter-rouge">%c</code> 占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">%cThis text is styled!</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">color: red; background: yellow; font-size: 24px;</span><span class="dl">'</span>
<span class="p">)</span>
</code></pre></div></div> <p>上面代码运行后，输出的内容将显示为黄底红字。</p> <p><code class="language-plaintext highlighter-rouge">console.info</code> 是 <code class="language-plaintext highlighter-rouge">console.log</code> 方法的别名，用法完全一样。只不过 <code class="language-plaintext highlighter-rouge">console.info</code> 方法会在输出信息的前面，加上一个蓝色图标。</p> <p><code class="language-plaintext highlighter-rouge">console.debug</code> 方法与 <code class="language-plaintext highlighter-rouge">console.log</code> 方法类似，会在控制台输出调试信息。但是，默认情况下，<code class="language-plaintext highlighter-rouge">console.debug</code> 输出的信息不会显示，只有在打开显示级别在 <code class="language-plaintext highlighter-rouge">verbose</code> 的情况下，才会显示。</p> <p><code class="language-plaintext highlighter-rouge">console</code> 对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义 <code class="language-plaintext highlighter-rouge">console.log</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">log</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">info</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">warn</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span> <span class="o">=</span> <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nf">bind</span><span class="p">(</span>
    <span class="nx">console</span><span class="p">,</span>
    <span class="k">new</span> <span class="nc">Date</span><span class="p">().</span><span class="nf">toISOString</span><span class="p">()</span>
  <span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">出错了！</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// 2014-05-18T09:00.000Z 出错了！</span>
</code></pre></div></div> <p>上面代码表示，使用自定义的 <code class="language-plaintext highlighter-rouge">console.log</code> 方法，可以在显示结果添加当前时间。</p> <h4 id="22-consolewarnconsoleerror">2.2 console.warn()，console.error()</h4> <p><code class="language-plaintext highlighter-rouge">warn</code> 方法和 <code class="language-plaintext highlighter-rouge">error</code> 方法也是在控制台输出信息，它们与 <code class="language-plaintext highlighter-rouge">log</code> 方法的不同之处在于，<code class="language-plaintext highlighter-rouge">warn</code> 方法输出信息时，在最前面加一个黄色三角，表示警告；<code class="language-plaintext highlighter-rouge">error</code> 方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p> <h4 id="23-consoletable">2.3 console.table()</h4> <p>对于某些复合类型的数据，<code class="language-plaintext highlighter-rouge">console.table</code> 方法可以将其转为表格显示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">languages</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">JavaScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.js</span><span class="dl">"</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TypeScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.ts</span><span class="dl">"</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">CoffeeScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.coffee</span><span class="dl">"</span> <span class="p">}</span>
<span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">table</span><span class="p">(</span><span class="nx">languages</span><span class="p">);</span>
</code></pre></div></div> <table> <thead> <tr> <th>-(index)-</th> <th>-name-</th> <th>-fileExtension-</th> </tr> </thead> <tbody> <tr> <td>0 -</td> <td>“JavaScript”</td> <td>“.js”</td> </tr> <tr> <td>1 -</td> <td>“TypeScript”</td> <td>“.ts”</td> </tr> <tr> <td>2 -</td> <td>“CoffeeScript”</td> <td>“.coffee”</td> </tr> </tbody> </table> <h4 id="24-consolecount">2.4 console.count()</h4> <p><code class="language-plaintext highlighter-rouge">count</code> 方法用于计数，输出它被调用了多少次。该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p> <h4 id="25-consoledirconsoledirxml">2.5 console.dir()，console.dirxml()</h4> <p><code class="language-plaintext highlighter-rouge">dir</code> 方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">({</span><span class="na">f1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="na">f2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">})</span>
<span class="c1">// Object {f1: "foo", f2: "bar"}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">dir</span><span class="p">({</span><span class="na">f1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="na">f2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">})</span>
<span class="c1">// Object</span>
<span class="c1">//   f1: "foo"</span>
<span class="c1">//   f2: "bar"</span>
<span class="c1">//   __proto__: Object</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">dirxml</code> 方法主要用于以目录树的形式，显示 DOM 节点。如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code class="language-plaintext highlighter-rouge">console.dirxml</code> 等同于 <code class="language-plaintext highlighter-rouge">console.dir</code>。</p> <h4 id="26-consoleassert">2.6 console.assert()</h4> <p><code class="language-plaintext highlighter-rouge">console.assert</code> 方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p> <p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为 <code class="language-plaintext highlighter-rouge">false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">assert</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="dl">'</span><span class="s1">判断条件不成立</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Assertion failed: 判断条件不成立</span>
</code></pre></div></div> <h4 id="27-consoletimeconsoletimeend">2.7 console.time()，console.timeEnd()</h4> <p>这两个方法用于计时，可以算出一个操作所花费的准确时间。<code class="language-plaintext highlighter-rouge">time</code> 方法表示计时开始，<code class="language-plaintext highlighter-rouge">timeEnd</code> 方法表示计时结束。它们的参数是计时器的名称。调用 <code class="language-plaintext highlighter-rouge">timeEnd</code> 方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">time</span><span class="p">(</span><span class="dl">'</span><span class="s1">Array initialize</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">array</span><span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">timeEnd</span><span class="p">(</span><span class="dl">'</span><span class="s1">Array initialize</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Array initialize: 1914.481ms</span>
</code></pre></div></div> <h4 id="28-consolegroupconsolegroupendconsolegroupcollapsed">2.8 console.group()，console.groupEnd()，console.groupCollapsed()</h4> <p><code class="language-plaintext highlighter-rouge">console.group</code> 和 <code class="language-plaintext highlighter-rouge">console.groupEnd</code> 这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p> <p><code class="language-plaintext highlighter-rouge">console.groupCollapsed</code> 方法与 <code class="language-plaintext highlighter-rouge">console.group</code> 方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p> <h4 id="29-consoletraceconsoleclear">2.9 console.trace()，console.clear()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">console.trace</code> 方法显示当前执行的代码在堆栈中的调用路径。</li> <li><code class="language-plaintext highlighter-rouge">console.clear</code> 方法用于清除当前控制台的所有输出，将光标回置到第一行。</li> </ul> <h3 id="3-控制台命令行-api">3. 控制台命令行 API</h3> <p>浏览器控制台中，除了使用 <code class="language-plaintext highlighter-rouge">console</code> 对象，还可以使用一些控制台自带的命令行方法。</p> <p>（1）<code class="language-plaintext highlighter-rouge">$_</code></p> <p><code class="language-plaintext highlighter-rouge">$_</code> 属性返回上一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="c1">// 4</span>
<span class="nx">$_</span>
<span class="c1">// 4</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">$0</code> - <code class="language-plaintext highlighter-rouge">$4</code></p> <p>控制台保存了最近 5 个在 Elements 面板选中的 DOM 元素，<code class="language-plaintext highlighter-rouge">$0</code> 代表倒数第一个（最近一个），<code class="language-plaintext highlighter-rouge">$1</code> 代表倒数第二个，以此类推直到 <code class="language-plaintext highlighter-rouge">$4</code>。</p> <p>（3）<code class="language-plaintext highlighter-rouge">$(selector)</code></p> <p><code class="language-plaintext highlighter-rouge">$(selector)</code> 返回第一个匹配的元素，等同于 <code class="language-plaintext highlighter-rouge">document.querySelector()</code>。注意，如果页面脚本对 <code class="language-plaintext highlighter-rouge">$</code> 有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行 <code class="language-plaintext highlighter-rouge">$(selector)</code> 就会采用 jQuery 的实现，返回一个数组。</p> <p>（4）<code class="language-plaintext highlighter-rouge">$$(selector)</code></p> <p><code class="language-plaintext highlighter-rouge">$$(selector)</code> 返回选中的 DOM 对象，等同于 <code class="language-plaintext highlighter-rouge">document.querySelectorAll</code>。</p> <p>（5）<code class="language-plaintext highlighter-rouge">$x(path)</code></p> <p><code class="language-plaintext highlighter-rouge">$x(path)</code> 方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">$x</span><span class="p">(</span><span class="dl">"</span><span class="s2">//p[a]</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div> <p>上面代码返回所有包含a元素的p元素。</p> <p>（6）<code class="language-plaintext highlighter-rouge">inspect(object)</code></p> <p><code class="language-plaintext highlighter-rouge">inspect(object)</code> 方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在 Elements 面板中显示，比如 <code class="language-plaintext highlighter-rouge">inspect(document)</code> 会在 Elements 面板显示 <code class="language-plaintext highlighter-rouge">document</code> 元素。JavaScript 对象在控制台面板 Profiles 面板中显示，比如 <code class="language-plaintext highlighter-rouge">inspect(window)</code>。</p> <p>（7）<code class="language-plaintext highlighter-rouge">getEventListeners(object)</code></p> <p><code class="language-plaintext highlighter-rouge">getEventListeners(object)</code> 方法返回一个对象，该对象的成员为 <code class="language-plaintext highlighter-rouge">object</code> 登记了回调函数的各种事件（比如 <code class="language-plaintext highlighter-rouge">click</code> 或 <code class="language-plaintext highlighter-rouge">keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p> <p>（8）<code class="language-plaintext highlighter-rouge">keys(object)</code>，<code class="language-plaintext highlighter-rouge">values(object)</code></p> <p><code class="language-plaintext highlighter-rouge">keys(object)</code> 方法返回一个数组，包含 <code class="language-plaintext highlighter-rouge">object</code> 的所有键名。</p> <p><code class="language-plaintext highlighter-rouge">values(object)</code> 方法返回一个数组，包含 <code class="language-plaintext highlighter-rouge">object</code> 的所有键值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="dl">'</span><span class="s1">p1</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p2</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">};</span>

<span class="nf">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
<span class="c1">// ["p1", "p2"]</span>
<span class="nf">values</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
<span class="c1">// ["a", "b"]</span>
</code></pre></div></div> <p>（9）<code class="language-plaintext highlighter-rouge">monitorEvents(object[, events])</code>，<code class="language-plaintext highlighter-rouge">unmonitorEvents(object[, events])</code></p> <p><code class="language-plaintext highlighter-rouge">monitorEvents(object[, events])</code> 方法监听特定对象上发生的特定事件。事件发生时，会返回一个 <code class="language-plaintext highlighter-rouge">Event</code> 对象，包含该事件的相关信息。<code class="language-plaintext highlighter-rouge">unmonitorEvents</code> 方法用于停止监听。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="dl">"</span><span class="s2">resize</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">monitorEvents</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">resize</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">scroll</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div> <p>上面代码分别表示单个事件和多个事件的监听方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nx">$0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">mouse</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">unmonitorEvents</span><span class="p">(</span><span class="nx">$0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码表示如何停止监听。</p> <p>monitorEvents 允许监听同一大类的事件。所有事件可以分成四个大类。</p> <ul> <li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li> <li>key：”keydown”, “keyup”, “keypress”, “textInput”</li> <li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li> <li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#msg</span><span class="dl">"</span><span class="p">),</span> <span class="dl">"</span><span class="s2">key</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码表示监听所有 <code class="language-plaintext highlighter-rouge">key</code> 大类的事件。</p> <p>（10）其他方法</p> <p>命令行 API 还提供以下方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">clear()</code>：清除控制台的历史。</li> <li><code class="language-plaintext highlighter-rouge">copy(object)</code>：复制特定 DOM 元素到剪贴板。</li> <li><code class="language-plaintext highlighter-rouge">dir(object)</code>：显示特定对象的所有属性，是 <code class="language-plaintext highlighter-rouge">console.dir</code> 方法的别名。</li> <li><code class="language-plaintext highlighter-rouge">dirxml(object)</code>：显示特定对象的 XML 形式，是 <code class="language-plaintext highlighter-rouge">console.dirxml</code> 方法的别名。</li> </ul> <h3 id="4-debugger-语句">4. debugger 语句</h3> <p><code class="language-plaintext highlighter-rouge">debugger</code> 语句主要用于除错，作用是设置断点。</p> <h2 id="五参考">五、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/features/">JavaScript 教程 - 语法专题</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 语法专题》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/stdlib/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/stdlib</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/stdlib/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/stdlib/">《JavaScript 教程 - 标准库》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一object-对象">一、Object 对象</h2> <h3 id="1-object">1. Object()</h3> <p><code class="language-plaintext highlighter-rouge">Object</code> 本身是一个函数，可以当作工具方法使用，<strong>将任意值转为对象</strong>。</p> <p>（1）如果参数是对象，它总是返回该对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">isObject</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">===</span> <span class="nc">Object</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">isObject</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nf">isObject</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>（2）如果参数是原始类型的值，<code class="language-plaintext highlighter-rouge">Object</code> 方法将其转为对应的<strong>包装对象</strong>的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Number</span> <span class="c1">// true</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">String</span> <span class="c1">// true</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Boolean</span> <span class="c1">// true</span>
</code></pre></div></div> <p>（3）如果参数为空（或者为 <code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code>），<code class="language-plaintext highlighter-rouge">Object()</code> 返回一个空对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">();</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="2-object-构造函数">2. Object 构造函数</h3> <p><code class="language-plaintext highlighter-rouge">Object</code> 前面使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，可以当作构造函数使用。</p> <p><code class="language-plaintext highlighter-rouge">Object</code> 构造函数的首要用途，是直接通过它来生成新对象。通过 <code class="language-plaintext highlighter-rouge">var obj = new Object()</code> 的写法生成新对象，与字面量的写法 <code class="language-plaintext highlighter-rouge">var obj = {}</code> 是等价的。或者说，后者只是前者的一种简便写法。</p> <p><code class="language-plaintext highlighter-rouge">Object</code> 构造函数的用法与工具方法的行为相似，但两者语义不同。<code class="language-plaintext highlighter-rouge">Object(value)</code> 表示将 <code class="language-plaintext highlighter-rouge">value</code> 转成一个对象，<code class="language-plaintext highlighter-rouge">new Object(value)</code> 则表示新生成一个对象，它的值是 <code class="language-plaintext highlighter-rouge">value</code>。</p> <h3 id="3-object-的静态方法">3. Object 的静态方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Object.keys()</code>：返回一个数组，其包含给定对象中所有<strong>自身的</strong>（不包括继承的）、所有<strong>可枚举的</strong>属性名。</li> <li><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyNames()</code>：返回一个数组，其包含给定对象中所有<strong>自身的</strong>属性名（包括<strong>不可枚举</strong>的属性，但不包括使用 <code class="language-plaintext highlighter-rouge">symbol</code> 值作为名称的属性）。</li> <li><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li> <li><code class="language-plaintext highlighter-rouge">Object.defineProperty()</code>：通过描述对象，定义某个属性。</li> <li><code class="language-plaintext highlighter-rouge">Object.defineProperties()</code>：通过描述对象，定义多个属性。</li> <li><code class="language-plaintext highlighter-rouge">Object.preventExtensions()</code>：防止对象扩展。</li> <li><code class="language-plaintext highlighter-rouge">Object.isExtensible()</code>：判断对象是否可扩展。</li> <li><code class="language-plaintext highlighter-rouge">Object.seal()</code>：禁止对象配置。</li> <li><code class="language-plaintext highlighter-rouge">Object.isSealed()</code>：判断一个对象是否可配置。</li> <li><code class="language-plaintext highlighter-rouge">Object.freeze()</code>：冻结一个对象。</li> <li><code class="language-plaintext highlighter-rouge">Object.isFrozen()</code>：判断一个对象是否被冻结。</li> </ul> <h3 id="4-object-的实例方法">4. Object 的实例方法</h3> <p><code class="language-plaintext highlighter-rouge">Object</code> 的实例方法定义在 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 对象上，所有 <code class="language-plaintext highlighter-rouge">Object</code> 的实例对象都继承了这些方法。</p> <p><code class="language-plaintext highlighter-rouge">Object</code> 实例对象的方法，主要有以下 6 个。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Object.prototype.valueOf()</code>：返回当前对象对应的值。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code>：返回当前对象对应的字符串形式。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li> </ul> <h4 id="41-objectprototypevalueof">4.1 Object.prototype.valueOf()</h4> <p><code class="language-plaintext highlighter-rouge">valueOf()</code> 方法的用于返回对象的“<strong>值</strong>”，默认返回对象本身。<code class="language-plaintext highlighter-rouge">valueOf()</code> 方法的主要用途是，JavaScript <strong>自动类型转换</strong>时会默认调用这个方法。</p> <p>可以自定义对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。</p> <h4 id="42-objectprototypetostring">4.2 Object.prototype.toString()</h4> <p><code class="language-plaintext highlighter-rouge">toString()</code> 方法用于返回对象的字符串形式，默认返回类型字符串。</p> <p>字符串、数组、函数、<code class="language-plaintext highlighter-rouge">Date</code> 对象都分别部署了自定义的 <code class="language-plaintext highlighter-rouge">toString</code> 方法，覆盖了 <code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "1,2,3"</span>

<span class="dl">'</span><span class="s1">123</span><span class="dl">'</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "123"</span>

<span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">123</span><span class="p">;</span>
<span class="p">}).</span><span class="nf">toString</span><span class="p">()</span>
<span class="c1">// "function () {</span>
<span class="c1">//   return 123;</span>
<span class="c1">// }"</span>

<span class="p">(</span><span class="k">new</span> <span class="nc">Date</span><span class="p">()).</span><span class="nf">toString</span><span class="p">()</span>
<span class="c1">// "Tue May 10 2016 09:11:31 GMT+0800 (CST)"</span>
</code></pre></div></div> <p>可以自定义对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。</p> <h3 id="43-tostring-的应用判断数据类型">4.3 toString() 的应用：判断数据类型</h3> <p><code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code> 方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "[object Object]"</span>
</code></pre></div></div> <p>由于实例对象可能会自定义 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，覆盖掉 <code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code> 方法，所以为了得到类型字符串，最好直接使用 <code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code> 方法。通过函数的 <code class="language-plaintext highlighter-rouge">call()</code> 方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
</code></pre></div></div> <p>不同数据类型的 Object.prototype.toString 方法返回值如下。</p> <ul> <li>数值：返回 <code class="language-plaintext highlighter-rouge">[object Number]</code>。</li> <li>字符串：返回 <code class="language-plaintext highlighter-rouge">[object String]</code>。</li> <li>布尔值：返回 <code class="language-plaintext highlighter-rouge">[object Boolean]</code>。</li> <li><code class="language-plaintext highlighter-rouge">undefined</code>：返回 <code class="language-plaintext highlighter-rouge">[object Undefined]</code>。</li> <li><code class="language-plaintext highlighter-rouge">null</code>：返回 <code class="language-plaintext highlighter-rouge">[object Null]</code>。</li> <li>数组：返回 <code class="language-plaintext highlighter-rouge">[object Array]</code>。</li> <li><code class="language-plaintext highlighter-rouge">arguments</code> 对象：返回 <code class="language-plaintext highlighter-rouge">[object Arguments]</code>。</li> <li>函数：返回 <code class="language-plaintext highlighter-rouge">[object Function]</code>。</li> <li><code class="language-plaintext highlighter-rouge">Error</code> 对象：返回 <code class="language-plaintext highlighter-rouge">[object Error]</code>。</li> <li><code class="language-plaintext highlighter-rouge">Date</code> 对象：返回 <code class="language-plaintext highlighter-rouge">[object Date]</code>。</li> <li><code class="language-plaintext highlighter-rouge">RegExp</code> 对象：返回 <code class="language-plaintext highlighter-rouge">[object RegExp]</code>。</li> <li>其他对象：返回 <code class="language-plaintext highlighter-rouge">[object Object]</code>。</li> </ul> <p>利用这个特性，可以写出一个比 <code class="language-plaintext highlighter-rouge">typeof</code> 运算符更准确的类型判断函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\[</span><span class="sr">object </span><span class="se">(</span><span class="sr">.*</span><span class="se">?)\]</span><span class="sr">/</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="nf">toLowerCase</span><span class="p">();</span>
<span class="p">};</span>

<span class="nf">type</span><span class="p">({});</span> <span class="c1">// "object"</span>
<span class="nf">type</span><span class="p">([]);</span> <span class="c1">// "array"</span>
<span class="nf">type</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// "number"</span>
<span class="nf">type</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// "null"</span>
<span class="nf">type</span><span class="p">();</span> <span class="c1">// "undefined"</span>
<span class="nf">type</span><span class="p">(</span><span class="sr">/abcd/</span><span class="p">);</span> <span class="c1">// "regex"</span>
<span class="nf">type</span><span class="p">(</span><span class="k">new</span> <span class="nc">Date</span><span class="p">());</span> <span class="c1">// "date"</span>
</code></pre></div></div> <p>在上面这个 <code class="language-plaintext highlighter-rouge">type</code> 函数的基础上，还可以加上专门判断某种类型数据的方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\[</span><span class="sr">object </span><span class="se">(</span><span class="sr">.*</span><span class="se">?)\]</span><span class="sr">/</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="nf">toLowerCase</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">[</span><span class="dl">'</span><span class="s1">Null</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Undefined</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Object</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Array</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">String</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Number</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Boolean</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Function</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">RegExp</span><span class="dl">'</span>
<span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">type</span><span class="p">[</span><span class="dl">'</span><span class="s1">is</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">t</span><span class="p">]</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">type</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="o">===</span> <span class="nx">t</span><span class="p">.</span><span class="nf">toLowerCase</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">});</span>

<span class="nx">type</span><span class="p">.</span><span class="nf">isObject</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nx">type</span><span class="p">.</span><span class="nf">isNumber</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">type</span><span class="p">.</span><span class="nf">isRegExp</span><span class="p">(</span><span class="sr">/abc/</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="44-objectprototypetolocalestring">4.4 Object.prototype.toLocaleString()</h3> <p><code class="language-plaintext highlighter-rouge">Object.prototype.toLocaleString()</code> 方法与 <code class="language-plaintext highlighter-rouge">toString()</code> 的返回结果相同，也是返回一个值的字符串形式。这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的 <code class="language-plaintext highlighter-rouge">toLocaleString()</code>，用来返回针对某些地域的特定的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">toString</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Henry Norman Bethune</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="na">toLocaleString</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">白求恩</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// Henry Norman Bethune</span>
<span class="nx">person</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">()</span> <span class="c1">// 白求恩</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">toString()</code> 方法返回对象的一般字符串形式，<code class="language-plaintext highlighter-rouge">toLocaleString()</code> 方法返回本地的字符串形式。</p> <p>目前，主要有三个对象自定义了 <code class="language-plaintext highlighter-rouge">toLocaleString()</code> 方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Number.prototype.toLocaleString()</code></li> <li><code class="language-plaintext highlighter-rouge">Array.prototype.toLocaleString()</code></li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toLocaleString()</code></li> </ul> <p>举例来说，日期的实例对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 和 <code class="language-plaintext highlighter-rouge">toLocaleString()</code> 返回值就不一样，而且 <code class="language-plaintext highlighter-rouge">toLocaleString()</code> 的返回值跟用户设定的所在地域相关。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">date</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"</span>
<span class="nx">date</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">()</span> <span class="c1">// "1/01/2018, 12:01:33 PM"</span>
</code></pre></div></div> <h3 id="45-objectprototypehasownproperty">4.5 Object.prototype.hasOwnProperty()</h3> <p><code class="language-plaintext highlighter-rouge">Object.prototype.hasOwnProperty()</code> 方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象<strong>自身</strong>是否具有该属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="mi">123</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h2 id="二属性描述对象">二、属性描述对象</h2> <h3 id="1-概述">1. 概述</h3> <p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“<strong>属性描述对象</strong>”（attributes object）。<strong>每个属性</strong>都有自己对应的属性描述对象，保存该属性的一些元信息。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="nx">writable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">configurable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="kd">get</span><span class="p">:</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="kd">set</span><span class="p">:</span> <span class="kc">undefined</span>
<span class="p">}</span>
</code></pre></div></div> <p>属性描述对象提供 6 个元属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code>：该属性的属性值，默认为 <code class="language-plaintext highlighter-rouge">undefined</code>。</li> <li><code class="language-plaintext highlighter-rouge">writable</code>：布尔值，表示属性值（value）是否可改变（即是否可写），默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">enumerable</code>：布尔值，表示该属性是否可遍历，默认为 <code class="language-plaintext highlighter-rouge">true</code>。如果设为 <code class="language-plaintext highlighter-rouge">false</code>，会使得某些操作（比如 <code class="language-plaintext highlighter-rouge">for...in</code> 循环、<code class="language-plaintext highlighter-rouge">Object.keys()</code>）跳过该属性。</li> <li><code class="language-plaintext highlighter-rouge">configurable</code>：布尔值，表示属性的可配置性，默认为 <code class="language-plaintext highlighter-rouge">true</code>。如果设为 <code class="language-plaintext highlighter-rouge">false</code>，将阻止某些操作改写属性描述对象，比如无法删除该属性，也不得改变各种元属性（<code class="language-plaintext highlighter-rouge">value</code> 属性除外）。也就是说，<code class="language-plaintext highlighter-rouge">configurable</code> 属性控制了属性描述对象的可写性。</li> <li><code class="language-plaintext highlighter-rouge">get</code>：函数，表示该属性的取值函数（getter），默认为 <code class="language-plaintext highlighter-rouge">undefined</code>。</li> <li><code class="language-plaintext highlighter-rouge">set</code>：函数，表示该属性的存值函数（setter），默认为 <code class="language-plaintext highlighter-rouge">undefined</code>。</li> </ul> <h3 id="2-objectgetownpropertydescriptor">2. Object.getOwnPropertyDescriptor()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor()</code> 方法可以获取某个属性的描述对象。此方法只能用于对象<strong>自身</strong>的属性，不能用于继承的属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Object { value: "a",</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true</span>
<span class="c1">// }</span>
</code></pre></div></div> <h3 id="3-objectgetownpropertynames">3. Object.getOwnPropertyNames()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyNames()</code> 方法返回一个数组，其包含给定对象中所有自身的属性名（包括<strong>不可枚举的</strong>属性，但不包括使用 <code class="language-plaintext highlighter-rouge">symbol</code> 值作为名称的属性）。</p> <h3 id="4-objectdefinepropertyobjectdefineproperties">4. Object.defineProperty()，Object.defineProperties()</h3> <p><code class="language-plaintext highlighter-rouge">Object.defineProperty()</code> 方法用于通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。如果属性已经存在，<code class="language-plaintext highlighter-rouge">Object.defineProperty()</code> 方法相当于更新该属性的属性描述对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 123</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">246</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 123</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.defineProperties()</code> 方法用于一次性定义或修改多个属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperties</span><span class="p">({},</span> <span class="p">{</span>
  <span class="na">p1</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">p2</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">p3</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span>
    <span class="na">get</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">;</span>
    <span class="p">},</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p1</span> <span class="c1">// 123</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p2</span> <span class="c1">// "abc"</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p3</span> <span class="c1">// "123abc"</span>
</code></pre></div></div> <p>注意，一旦定义了取值函数 <code class="language-plaintext highlighter-rouge">get</code>（或存值函数 <code class="language-plaintext highlighter-rouge">set</code>），就不能将 <code class="language-plaintext highlighter-rouge">writable</code> 属性设为 <code class="language-plaintext highlighter-rouge">true</code>，或者同时定义 <code class="language-plaintext highlighter-rouge">value</code> 属性，否则会报错。</p> <h3 id="5-objectprototypepropertyisenumerable">5. Object.prototype.propertyIsEnumerable()</h3> <p>实例对象的 <code class="language-plaintext highlighter-rouge">propertyIsEnumerable()</code> 方法返回一个布尔值，用来判断某个属性是否<strong>可遍历</strong>。注意，这个方法只能用于判断对象<strong>自身的</strong>属性，对于继承的属性一律返回 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nf">propertyIsEnumerable</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">propertyIsEnumerable</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h3 id="6-元属性">6. 元属性</h3> <p>属性描述对象的各个属性称为“<strong>元属性</strong>”，因为它们可以看作是控制属性的属性。</p> <h4 id="61-value">6.1 value</h4> <p><code class="language-plaintext highlighter-rouge">value</code> 属性是目标属性的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">value</span>
<span class="c1">// 123</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="mi">246</span> <span class="p">});</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 246</span>
</code></pre></div></div> <h4 id="62-configurable">6.2 configurable</h4> <p><code class="language-plaintext highlighter-rouge">configurable</code>（可配置性）返回一个布尔值，用于是否可以修改属性描述对象。</p> <ul> <li><code class="language-plaintext highlighter-rouge">configurable</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 时，<code class="language-plaintext highlighter-rouge">enumerable</code>、<code class="language-plaintext highlighter-rouge">configurable</code> 和 <code class="language-plaintext highlighter-rouge">writable</code> 都不能被修改。</li> <li> <p>只要 <code class="language-plaintext highlighter-rouge">writable</code> 和 <code class="language-plaintext highlighter-rouge">configurable</code> 有一个为 <code class="language-plaintext highlighter-rouge">true</code>，就允许改动 <code class="language-plaintext highlighter-rouge">value</code>，<code class="language-plaintext highlighter-rouge">writable</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 时，直接对目标属性赋值，不报错，但不会成功。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 1</span>
</code></pre></div> </div> </li> <li>可配置性决定目标属性是否可以被删除（<code class="language-plaintext highlighter-rouge">delete</code>）。</li> </ul> <h4 id="63-enumerable">6.3 enumerable</h4> <p><code class="language-plaintext highlighter-rouge">enumerable</code>（可遍历性）返回一个布尔值，表示目标属性是否可遍历。如果一个属性的 <code class="language-plaintext highlighter-rouge">enumerable</code> 为 <code class="language-plaintext highlighter-rouge">false</code>，下面三个操作不会取到该属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">for..in</code></li> <li><code class="language-plaintext highlighter-rouge">Object.keys()</code></li> <li><code class="language-plaintext highlighter-rouge">JSON.stringify()</code></li> </ul> <p>因此，<code class="language-plaintext highlighter-rouge">enumerable</code> 可以用来设置“<strong>秘密</strong>”属性。</p> <h4 id="64-writable">6.4 writable</h4> <p><code class="language-plaintext highlighter-rouge">writable</code> 属性是布尔值，决定了目标属性<strong>值</strong>（value）是否可以被改变。正常模式下，对 <code class="language-plaintext highlighter-rouge">writable</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 的属性赋值不会报错，只会失败。但是，严格模式下会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">37</span><span class="p">;</span>
<span class="c1">// Uncaught TypeError: Cannot assign to read only property 'a' of object</span>
</code></pre></div></div> <p>如果原型对象的某个属性的 <code class="language-plaintext highlighter-rouge">writable</code> 为 <code class="language-plaintext highlighter-rouge">false</code>，那么子对象将无法自定义这个属性。但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">proto</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// "b"</span>
</code></pre></div></div> <h3 id="7-存取器">7. 存取器</h3> <p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">get</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">getter</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="na">set</span><span class="p">:</span> <span class="nf">function </span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setter: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// "getter"</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">123</span> <span class="c1">// "setter: 123"</span>
</code></pre></div></div> <p>JavaScript 还提供了存取器的另一种写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 写法二</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nf">p</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">getter</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="kd">set</span> <span class="nf">p</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setter: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面两种写法，虽然属性 <code class="language-plaintext highlighter-rouge">p</code> 的读取和赋值行为是一样的，但是有一些细微的区别。</p> <ul> <li>第一种写法，属性 <code class="language-plaintext highlighter-rouge">p</code> 的 <code class="language-plaintext highlighter-rouge">configurable</code> 和 <code class="language-plaintext highlighter-rouge">enumerable</code> 都为 <code class="language-plaintext highlighter-rouge">false</code>，从而导致属性 <code class="language-plaintext highlighter-rouge">p</code> 是不可遍历的；</li> <li>第二种写法，属性 <code class="language-plaintext highlighter-rouge">p</code> 的 <code class="language-plaintext highlighter-rouge">configurable</code> 和 <code class="language-plaintext highlighter-rouge">enumerable</code> 都为 <code class="language-plaintext highlighter-rouge">true</code>，因此属性 <code class="language-plaintext highlighter-rouge">p</code> 是可遍历的。</li> </ul> <p>实际开发中，写法二更常用。</p> <h3 id="8-对象的拷贝">8. 对象的拷贝</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">property</span> <span class="k">in</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">to</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">=</span> <span class="k">from</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">to</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">extend</span><span class="p">({},</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">})</span>
<span class="c1">// {a: 1}</span>

<span class="nf">extend</span><span class="p">({},</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">})</span>
<span class="c1">// {a: 1}</span>
</code></pre></div></div> <p>上面是一个对象的拷贝方法，它的问题在于，如果遇到存取器定义的属性，会只拷贝值。为了解决这个问题，可以通过 <code class="language-plaintext highlighter-rouge">Object.defineProperty()</code> 方法来拷贝属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">property</span> <span class="k">in</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">from</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="nx">property</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span>
      <span class="nx">to</span><span class="p">,</span>
      <span class="nx">property</span><span class="p">,</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">property</span><span class="p">)</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">to</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">extend</span><span class="p">({},</span> <span class="p">{</span> <span class="kd">get</span> <span class="nf">a</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">})</span>
<span class="c1">// { get a(){ return 1 } })</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">hasOwnProperty</code> 那一行用来过滤掉继承的属性，否则可能会报错，因为 <code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor()</code> 读不到继承属性的属性描述对象。</p> <h3 id="9-控制对象状态">9. 控制对象状态</h3> <p>JavaScript 提供了三种冻结方法，最弱的一种是 <code class="language-plaintext highlighter-rouge">Object.preventExtensions()</code>，其次是 <code class="language-plaintext highlighter-rouge">Object.seal()</code>，最强的是 <code class="language-plaintext highlighter-rouge">Object.freeze()</code>。</p> <h4 id="91-objectpreventextensionsobjectisextensible">9.1 Object.preventExtensions()，Object.isExtensible()</h4> <p><code class="language-plaintext highlighter-rouge">Object.preventExtensions()</code> 方法可以使得一个对象<strong>无法再添加新属性</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
<span class="p">});</span>
<span class="c1">// TypeError: Cannot define property:p, object is not extensible.</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// undefined</span>

</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.isExtensible()</code> 方法用于检查一个对象是否使用了 <code class="language-plaintext highlighter-rouge">Object.preventExtensions()</code> 方法。也就是说，检查是否可以为一个对象添加属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">isExtensible</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">isExtensible</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="92-objectsealobjectissealed">9.2 Object.seal()，Object.isSealed()</h4> <p><code class="language-plaintext highlighter-rouge">Object.seal()</code> 方法用于禁止对象<strong>添加新属性和删除旧属性</strong>。注意，它只禁止添加或删除属性，并<strong>不影响修改某个属性的值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">seal</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">p</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// "hello"</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// undefined</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.seal()</code> 实质是把属性描述对象的 <code class="language-plaintext highlighter-rouge">configurable</code> 属性设为 <code class="language-plaintext highlighter-rouge">false</code>，因此属性描述对象不再能改变了。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span>
<span class="p">};</span>

<span class="c1">// seal方法之前</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Object {</span>
<span class="c1">//   value: "a",</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true</span>
<span class="c1">// }</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">seal</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="c1">// seal方法之后</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Object {</span>
<span class="c1">//   value: "a",</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: false</span>
<span class="c1">// }</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">})</span>
<span class="c1">// TypeError: Cannot redefine property: p</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.isSealed()</code> 方法用于检查一个对象是否使用了 <code class="language-plaintext highlighter-rouge">Object.seal()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">seal</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">isSealed</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// true</span>

<span class="c1">// 这时，Object.isExtensible() 方法也返回 false。</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">isExtensible</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="93-objectfreezeobjectisfrozen">9.3 Object.freeze()，Object.isFrozen()</h4> <p><code class="language-plaintext highlighter-rouge">Object.freeze()</code> 方法可以使得一个对象<strong>无法添加新属性</strong>、<strong>无法删除旧属性</strong>、也<strong>无法改变属性的值</strong>，使得这个对象实际上变成了<strong>常量</strong>。</p> <p><code class="language-plaintext highlighter-rouge">Object.isFrozen()</code> 方法用于检查一个对象是否使用了 <code class="language-plaintext highlighter-rouge">Object.freeze()</code> 方法。<code class="language-plaintext highlighter-rouge">Object.isFrozen()</code> 的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p> <p>注意，使用 <code class="language-plaintext highlighter-rouge">Object.freeze()</code> 方法以后，<code class="language-plaintext highlighter-rouge">Object.isSealed()</code> 将会返回 <code class="language-plaintext highlighter-rouge">true</code>，<code class="language-plaintext highlighter-rouge">Object.isExtensible()</code> 返回 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">freeze</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">isSealed</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">isExtensible</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="94-局限性">9.4 局限性</h4> <p>上面三个方法锁定对象的可写性有两个局限性。</p> <p>（1）可以通过改变原型对象，来为对象增加属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">proto</span><span class="p">.</span><span class="nx">t</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">t</span>
<span class="c1">// hello</span>
</code></pre></div></div> <p>一种解决方案是，把 <code class="language-plaintext highlighter-rouge">obj</code> 的原型也冻结住。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">proto</span><span class="p">);</span>

<span class="nx">proto</span><span class="p">.</span><span class="nx">t</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">t</span> <span class="c1">// undefined</span>
</code></pre></div></div> <p>（2）如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">bar</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">]</span>
<span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">freeze</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span> <span class="c1">// ["a", "b", "c"]</span>
</code></pre></div></div> <h2 id="三array-对象">三、Array 对象</h2> <h3 id="1-构造函数">1. 构造函数</h3> <p><code class="language-plaintext highlighter-rouge">Array</code> 是 JavaScript 的原生对象，同时也是一个<strong>构造函数</strong>，可以用它生成新的数组。注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回 <code class="language-plaintext highlighter-rouge">undefined</code>，但实际上该位置没有任何值。虽然这时可以读取到 <code class="language-plaintext highlighter-rouge">length</code> 属性，但是取不到键名。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="nx">arr</span> <span class="c1">// [ empty x 2 ]</span>

<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Array()</code> 构造函数有一个很大的缺陷，不同的参数个数会导致不一致的行为。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 无参数时，返回一个空数组</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">()</span> <span class="c1">// []</span>

<span class="c1">// 单个正整数参数，表示返回的新数组的长度</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// [ empty ]</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// [ empty x 2 ]</span>

<span class="c1">// 非正整数的数值作为参数，会报错</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span> <span class="c1">// RangeError: Invalid array length</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// RangeError: Invalid array length</span>

<span class="c1">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span>
<span class="c1">// 则该参数是返回的新数组的成员</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ['abc']</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// [Array[1]]</span>

<span class="c1">// 多参数时，所有参数都是返回的新数组的成员</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// [1, 2]</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ['a', 'b', 'c']</span>
</code></pre></div></div> <p>不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bad</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// good</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</code></pre></div></div> <h3 id="2-静态方法">2. 静态方法</h3> <p><code class="language-plaintext highlighter-rouge">Array.isArray()</code> 方法返回一个布尔值，表示参数是否为数组。它可以弥补 <code class="language-plaintext highlighter-rouge">typeof</code> 运算符的不足。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="k">typeof</span> <span class="nx">arr</span> <span class="c1">// "object"</span>
<span class="nb">Array</span><span class="p">.</span><span class="nf">isArray</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="3-实例方法">3. 实例方法</h3> <h4 id="31-valueoftostring">3.1 valueOf()，toString()</h4> <p>数组的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回数组本身。数组的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回数组的字符串形式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">arr</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// [1, 2, 3]</span>
<span class="nx">arr</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "1,2,3"</span>
</code></pre></div></div> <h4 id="32-pushpop">3.2 push()，pop()</h4> <p><code class="language-plaintext highlighter-rouge">push()</code> 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的<strong>数组长度</strong>。该方法会改变原数组。<code class="language-plaintext highlighter-rouge">pop()</code> 方法用于删除数组的<strong>最后一个</strong>元素，并返回<strong>该元素</strong>。该方法会改变原数组。</p> <h4 id="33-shiftunshift">3.3 shift()，unshift()</h4> <p><code class="language-plaintext highlighter-rouge">shift()</code> 方法用于删除数组的<strong>第一个</strong>元素，并返回<strong>该元素</strong>。该方法会改变原数组。<code class="language-plaintext highlighter-rouge">unshift()</code> 方法用于在数组的<strong>第一个位置</strong>添加元素，并返回添加新元素后的<strong>数组长度</strong>。该方法会改变原数组。<code class="language-plaintext highlighter-rouge">unshift()</code> 方法可以接受多个参数，这些参数都会添加到目标数组头部。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>

<span class="nx">a</span><span class="p">.</span><span class="nf">unshift</span><span class="p">(</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 4</span>
<span class="nx">a</span> <span class="c1">// ['x', 'a', 'b', 'c']</span>
</code></pre></div></div> <h4 id="34-join">3.4 join()</h4> <p><code class="language-plaintext highlighter-rouge">join()</code> 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用<strong>逗号</strong>分隔。</p> <h4 id="35-concat">3.5 concat()</h4> <p><code class="language-plaintext highlighter-rouge">concat()</code> 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。<code class="language-plaintext highlighter-rouge">concat()</code> 接受任何类型的值作为参数，添加到目标数组尾部。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">].</span><span class="nf">concat</span><span class="p">([</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">])</span>
<span class="c1">// ["hello", "world"]</span>

<span class="p">[</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">].</span><span class="nf">concat</span><span class="p">([</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">!</span><span class="dl">'</span><span class="p">])</span>
<span class="c1">// ["hello", "world", "!"]</span>

<span class="p">[].</span><span class="nf">concat</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="c1">// [{ a: 1 }, { b: 2 }]</span>

<span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">concat</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="c1">// [2, {a: 1}]</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">concat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="c1">// [1, 2, 3, 4, 5, 6]</span>
</code></pre></div></div> <p>对于对象成员，<code class="language-plaintext highlighter-rouge">concat()</code> 方法执行的是<strong>浅拷贝</strong>。</p> <h4 id="36-reverse">3.6 reverse()</h4> <p><code class="language-plaintext highlighter-rouge">reverse()</code> 方法用于颠倒排列数组元素，返回改变后的数组。该方法将改变原数组。</p> <h4 id="37-slice">3.7 slice()</h4> <p><code class="language-plaintext highlighter-rouge">slice()</code> 方法用于<strong>提取</strong>目标数组的一部分，返回一个新数组，<strong>原数组不变</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">arr</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">);</span>
</code></pre></div></div> <p>它的第一个参数为起始位置（从 <code class="language-plaintext highlighter-rouge">0</code> 开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>

<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// ["a", "b", "c"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// ["b", "c"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// ["b"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// ["c"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">()</span> <span class="c1">// ["a", "b", "c"]</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">slice()</code> 方法的参数是负数，则表示倒数计算的位置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// ["b", "c"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// ["b"]</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">slice()</code> 方法的一个重要应用，是将类似数组的对象转为真正的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">({</span> <span class="mi">0</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="na">length</span><span class="p">:</span> <span class="mi">2</span> <span class="p">})</span>
<span class="c1">// ['a', 'b']</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">));</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
</code></pre></div></div> <h4 id="38-splice">3.8 splice()</h4> <p><code class="language-plaintext highlighter-rouge">splice()</code> 方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是<strong>被删除的元素</strong>。该方法会改变原数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">arr</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">addElement1</span><span class="p">,</span> <span class="nx">addElement2</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">splice()</code> 的第一个参数是删除的起始位置（从 <code class="language-plaintext highlighter-rouge">0</code> 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。起始位置如果是负数，就表示从倒数位置开始删除。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">e</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// ["e", "f"]</span>
<span class="nx">a</span> <span class="c1">// ["a", "b", "c", "d", 1, 2]</span>
</code></pre></div></div> <p>如果只是单纯地插入元素，<code class="language-plaintext highlighter-rouge">splice()</code> 方法的第二个参数可以设为 <code class="language-plaintext highlighter-rouge">0</code>。</p> <p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// [3, 4]</span>
<span class="nx">a</span> <span class="c1">// [1, 2]</span>
</code></pre></div></div> <h4 id="39-sort">3.9 sort()</h4> <p><code class="language-plaintext highlighter-rouge">sort()</code> 方法对数组成员进行排序，默认是按照<strong>字典顺序</strong>排序。排序后，原数组将被改变。<code class="language-plaintext highlighter-rouge">sort()</code> 方法不是按照大小排序，而是按照字典顺序。也就是说，<strong>数值会被先转成字符串</strong>，再按照字典顺序进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">].</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// ['a', 'b', 'c', 'd']</span>

<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [1, 2, 3, 4]</span>

<span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">101</span><span class="p">].</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [101, 11]</span>

<span class="p">[</span><span class="mi">10111</span><span class="p">,</span> <span class="mi">1101</span><span class="p">,</span> <span class="mi">111</span><span class="p">].</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [10111, 1101, 111]</span>
</code></pre></div></div> <p>如果想让 <code class="language-plaintext highlighter-rouge">sort()</code> 方法按照自定义方式排序，可以传入一个函数作为参数。自定义的排序函数应该返回<strong>数值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">10111</span><span class="p">,</span> <span class="mi">1101</span><span class="p">,</span> <span class="mi">111</span><span class="p">].</span><span class="nf">sort</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">})</span>
<span class="c1">// [111, 1101, 10111]</span>
</code></pre></div></div> <h4 id="310-foreachmap">3.10 forEach()，map()</h4> <p><code class="language-plaintext highlighter-rouge">forEach()</code> 方法用来历数组遍，没有返回值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">forEach()</code> 方法的第一个参数是一个回调函数，该函数接受三个参数：当前值、当前位置、整个数组。</li> <li><code class="language-plaintext highlighter-rouge">forEach()</code> 方法也可接受第二个参数，绑定参数函数的 <code class="language-plaintext highlighter-rouge">this</code> 变量。</li> </ul> <p><code class="language-plaintext highlighter-rouge">forEach()</code> 方法无法中断执行且会跳过数组的空位（但不会跳过 <code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code>）。</p> <p><code class="language-plaintext highlighter-rouge">map()</code> 方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p> <ul> <li><code class="language-plaintext highlighter-rouge">map()</code> 方法的第一个参数是一个回调函数，该函数接受三个参数：当前值、当前位置、整个数组。</li> <li><code class="language-plaintext highlighter-rouge">map()</code> 方法也可接受第二个参数，绑定参数函数的 <code class="language-plaintext highlighter-rouge">this</code> 变量。</li> </ul> <p><code class="language-plaintext highlighter-rouge">map()</code> 会跳过数组的空位。</p> <h4 id="311-filter">3.11 filter()</h4> <p><code class="language-plaintext highlighter-rouge">filter()</code> 方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 <code class="language-plaintext highlighter-rouge">true</code> 的成员组成一个新数组返回。该方法不会改变原数组。</p> <ul> <li><code class="language-plaintext highlighter-rouge">filter()</code> 方法的第一个参数是一个回调函数，该函数接受三个参数：当前值、当前位置、整个数组。</li> <li><code class="language-plaintext highlighter-rouge">filter()</code> 方法也可接受第二个参数，绑定参数函数的 <code class="language-plaintext highlighter-rouge">this</code> 变量。</li> </ul> <h4 id="312-someevery">3.12 some()，every()</h4> <p><code class="language-plaintext highlighter-rouge">some()</code> 和 <code class="language-plaintext highlighter-rouge">every()</code> 方法都接受一个函数作为参数，所有数组成员依次执行该函数。它们也可接受第二个参数，绑定参数函数的 <code class="language-plaintext highlighter-rouge">this</code> 变量。</p> <ul> <li><code class="language-plaintext highlighter-rouge">some()</code> 方法是只要一个成员的返回值是 <code class="language-plaintext highlighter-rouge">true</code>，则整个 <code class="language-plaintext highlighter-rouge">some()</code> 方法的返回值就是 <code class="language-plaintext highlighter-rouge">true</code>，否则返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">every()</code> 方法是所有成员的返回值都是 <code class="language-plaintext highlighter-rouge">true</code>，整个 <code class="language-plaintext highlighter-rouge">every()</code> 方法才返回 <code class="language-plaintext highlighter-rouge">true</code>，否则返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <h4 id="313-reducereduceright">3.13 reduce()，reduceRight()</h4> <p><code class="language-plaintext highlighter-rouge">reduce()</code> 方法和 <code class="language-plaintext highlighter-rouge">reduceRight()</code> 方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code class="language-plaintext highlighter-rouge">reduce()</code> 是从左到右处理（从第一个成员到最后一个成员），<code class="language-plaintext highlighter-rouge">reduceRight()</code> 则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nf">reduce</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">})</span>
<span class="c1">// 1 2</span>
<span class="c1">// 3 3</span>
<span class="c1">// 6 4</span>
<span class="c1">// 10 5</span>
<span class="c1">//最后结果：15</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">reduce()</code> 方法和 <code class="language-plaintext highlighter-rouge">reduceRight()</code> 方法的第一个参数都是一个函数。该函数接受以下四个参数。</p> <ul> <li>累积变量（必须）。第一次执行时，默认为数组的第一个成员；以后每次执行时，都是上一轮的返回值。</li> <li>当前变量（必须）。第一次执行时，默认为数组的第二个成员；以后每次执行时，都是下一个成员。</li> <li>当前位置（可选）。一个整数，表示第二个参数（当前变量）的位置，默认为 <code class="language-plaintext highlighter-rouge">1</code>。</li> <li>原数组（可选）。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">reduce()</code> 方法和 <code class="language-plaintext highlighter-rouge">reduceRight()</code> 方法的第二个参数，用于对累积变量指定初值。建议总是加上第二个参数，因为它可以防止空数组报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nf">reduce</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">10</span><span class="p">);</span>
<span class="c1">// 25</span>
</code></pre></div> </div> </li> </ul> <h4 id="314-indexoflastindexof">3.14 indexOf()，lastIndexOf()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">indexOf()</code> 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回 <code class="language-plaintext highlighter-rouge">-1</code>。<code class="language-plaintext highlighter-rouge">indexOf()</code> 方法还可以接受第二个参数，表示搜索的开始位置。</li> <li><code class="language-plaintext highlighter-rouge">lastIndexOf()</code> 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回 <code class="language-plaintext highlighter-rouge">-1</code>。</li> </ul> <p>注意，这两个方法不能用来搜索 <code class="language-plaintext highlighter-rouge">NaN</code> 的位置，即它们无法确定数组成员是否包含 <code class="language-plaintext highlighter-rouge">NaN</code>。这是因为这两个方法内部，使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）进行比较，而 <code class="language-plaintext highlighter-rouge">NaN</code> 是唯一一个不等于自身的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nf">indexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// -1</span>
<span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nf">lastIndexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// -1</span>
</code></pre></div></div> <h4 id="315-链式使用">3.15 链式使用</h4> <p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p> <h2 id="四包装对象">四、包装对象</h2> <h3 id="1-定义">1. 定义</h3> <p>“<strong>包装对象</strong>”指的是与数值、字符串、布尔值分别相对应的 <code class="language-plaintext highlighter-rouge">Boolean</code>、<code class="language-plaintext highlighter-rouge">Number</code>、<code class="language-plaintext highlighter-rouge">String</code> 三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">v1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Number</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="p">(</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">v3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="k">typeof</span> <span class="nx">v1</span> <span class="c1">// "object"</span>
<span class="k">typeof</span> <span class="nx">v2</span> <span class="c1">// "object"</span>
<span class="k">typeof</span> <span class="nx">v3</span> <span class="c1">// "object"</span>

<span class="nx">v1</span> <span class="o">===</span> <span class="mi">123</span> <span class="c1">// false</span>
<span class="nx">v2</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="nx">v3</span> <span class="o">===</span> <span class="kc">true</span> <span class="c1">// false</span>
</code></pre></div></div> <p>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。</p> <p>这三种包装对象作为构造函数使用（带有 <code class="language-plaintext highlighter-rouge">new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有 <code class="language-plaintext highlighter-rouge">new</code>），可以将任意类型的值，转为原始类型的值。</p> <h3 id="2-实例方法">2. 实例方法</h3> <p>三种包装对象共有方法：<code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code>。</p> <h3 id="3-原始类型与实例对象的自动转换">3. 原始类型与实例对象的自动转换</h3> <p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。</p> <p>比如，字符串可以调用 <code class="language-plaintext highlighter-rouge">length</code> 属性，返回字符串的长度。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">abc</code> 是一个字符串，本身不是对象，不能调用 <code class="language-plaintext highlighter-rouge">length</code> 属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用 <code class="language-plaintext highlighter-rouge">length</code> 属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</p> <p>自动转换生成的包装对象是<strong>只读的</strong>，无法修改。所以，字符串无法添加新属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello World</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// undefined</span>
</code></pre></div></div> <h3 id="4-自定义方法">4. 自定义方法</h3> <p>包装对象还可以自定义方法和属性，供原始类型的值直接调用。比如，我们可以新增一个 <code class="language-plaintext highlighter-rouge">double()</code> 方法，使得字符串和数字翻倍。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">double</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">();</span>
<span class="p">};</span>

<span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">.</span><span class="nf">double</span><span class="p">()</span>
<span class="c1">// abcabc</span>

<span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">double</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">double</span><span class="p">()</span> <span class="c1">// 246</span>
</code></pre></div></div> <h2 id="五boolean-对象">五、Boolean 对象</h2> <p><code class="language-plaintext highlighter-rouge">Boolean</code> 对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。<code class="language-plaintext highlighter-rouge">false</code> 对应的包装对象实例，布尔运算结果也是 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// true</span>

<span class="k">if </span><span class="p">(</span><span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">).</span><span class="nf">valueOf</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// 无输出</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Boolean</code> 对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时 <code class="language-plaintext highlighter-rouge">Boolean</code> 就是一个单纯的工具方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Boolean</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="dl">''</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// false</span>

<span class="nc">Boolean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="dl">'</span><span class="s1">false</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{})</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="sr">/foo/</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <p>使用双重的否运算符（<code class="language-plaintext highlighter-rouge">!</code>）也可以将任意值转为对应的布尔值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!!</span><span class="kc">undefined</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="kc">null</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="mi">0</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="dl">''</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="kc">NaN</span> <span class="c1">// false</span>

<span class="o">!!</span><span class="mi">1</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="dl">'</span><span class="s1">false</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="p">[]</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="p">{}</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="kd">function</span><span class="p">(){}</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="sr">/foo/</span> <span class="c1">// true</span>
</code></pre></div></div> <h2 id="六number-对象">六、Number 对象</h2> <p>Number 对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p> <h3 id="1-静态属性">1. 静态属性</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Number.POSITIVE_INFINITY</code>：正的无限，指向 <code class="language-plaintext highlighter-rouge">Infinity</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.NEGATIVE_INFINITY</code>：负的无限，指向 <code class="language-plaintext highlighter-rouge">-Infinity</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.NaN</code>：表示非数值，指向 <code class="language-plaintext highlighter-rouge">NaN</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.MIN_VALUE</code>：表示最小的正数（即最接近 <code class="language-plaintext highlighter-rouge">0</code> 的正数，在 64 位浮点数体系中为 <code class="language-plaintext highlighter-rouge">5e-324</code>），相应的，最接近 <code class="language-plaintext highlighter-rouge">0</code> 的负数为 <code class="language-plaintext highlighter-rouge">-Number.MIN_VALUE</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即 <code class="language-plaintext highlighter-rouge">9007199254740991</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即 <code class="language-plaintext highlighter-rouge">-9007199254740991</code>。\</li> </ul> <h3 id="2-实例方法-1">2. 实例方法</h3> <h4 id="21--numberprototypetostring">2.1 Number.prototype.toString()</h4> <p><code class="language-plaintext highlighter-rouge">Number()</code> 对象部署了自己的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，用来将一个数值转为字符串形式。</p> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toString()</code> 方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "1010"</span>
<span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1">// "12"</span>
<span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// "a"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">toString()</code> 方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用 <code class="language-plaintext highlighter-rouge">parseInt()</code> 方法。</p> <h4 id="22-numberprototypetofixed">2.2 Number.prototype.toFixed()</h4> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toFixed()</code> 方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "10.00"</span>
<span class="mf">10.005</span><span class="p">.</span><span class="nf">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "10.01"</span>
</code></pre></div></div> <h4 id="23-numberprototypetoexponential">2.3 Number.prototype.toExponential()</h4> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toExponential()</code> 方法用于将一个数转为科学计数法形式。<code class="language-plaintext highlighter-rouge">toExponential()</code> 方法的参数是小数点后有效数字的位数，范围为 0 到 100，超出这个范围，会抛出一个 <code class="language-plaintext highlighter-rouge">RangeError</code> 错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">()</span>  <span class="c1">// "1e+1"</span>
<span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// "1.0e+1"</span>
<span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "1.00e+1"</span>

<span class="p">(</span><span class="mi">1234</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">()</span>  <span class="c1">// "1.234e+3"</span>
<span class="p">(</span><span class="mi">1234</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// "1.2e+3"</span>
<span class="p">(</span><span class="mi">1234</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "1.23e+3"</span>
</code></pre></div></div> <h4 id="24-numberprototypetoprecision">2.4 Number.prototype.toPrecision()</h4> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toPrecision()</code> 方法用于将一个数转为指定位数的有效数字。该方法的参数为有效数字的位数，范围是 1 到 100，超出这个范围会抛出 <code class="language-plaintext highlighter-rouge">RangeError</code> 错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// "1e+1"</span>
<span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "12"</span>
<span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// "12.3"</span>
<span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// "12.34"</span>
<span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// "12.340"</span>
</code></pre></div></div> <h4 id="25-numberprototypetolocalestring">2.5 Number.prototype.toLocaleString()</h4> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toLocaleString()</code> 方法返回一个字符串，表示当前数字在该地区的当地书写形式。</p> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toLocaleString()</code> 方法接受两个可选的参数。</p> <ul> <li>第一个参数是一个字符串形式的地区码。</li> <li> <p>第二个参数是一个配置对象，用来定制指定用途的返回字符串。该对象的 style 属性指定输出样式，默认值是 decimal，表示输出十进制形式。</p> <ul> <li>如果 <code class="language-plaintext highlighter-rouge">style</code> 属性值为 <code class="language-plaintext highlighter-rouge">percent</code>，表示输出百分数。</li> <li>如果 <code class="language-plaintext highlighter-rouge">style</code> 属性值为 <code class="language-plaintext highlighter-rouge">currency</code>，则可以搭配 <code class="language-plaintext highlighter-rouge">currency</code> 属性，输出指定格式的货币字符串形式。</li> </ul> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-Hans-CN-u-nu-hanidec</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// "一二三"</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-Hans-CN</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">style</span><span class="p">:</span> <span class="dl">'</span><span class="s1">percent</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// "12,300%"</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-Hans-CN</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">style</span><span class="p">:</span> <span class="dl">'</span><span class="s1">currency</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">currency</span><span class="p">:</span> <span class="dl">'</span><span class="s1">CNY</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// "￥123.00"</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">de-DE</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">style</span><span class="p">:</span> <span class="dl">'</span><span class="s1">currency</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">currency</span><span class="p">:</span> <span class="dl">'</span><span class="s1">EUR</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// "123,00 €"</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">style</span><span class="p">:</span> <span class="dl">'</span><span class="s1">currency</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">currency</span><span class="p">:</span> <span class="dl">'</span><span class="s1">USD</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// "$123.00"</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">Number.prototype.toLocaleString()</code> 省略了参数，则由浏览器自行决定如何处理，通常会使用操作系统的地区设定。</p> <h3 id="3-自定义方法">3. 自定义方法</h3> <p><code class="language-plaintext highlighter-rouge">Number.prototype</code> 对象上面可以自定义方法，被 <code class="language-plaintext highlighter-rouge">Number</code> 的实例继承。</p> <h2 id="七string-对象">七、String 对象</h2> <h3 id="1-概述-1">1. 概述</h3> <p><code class="language-plaintext highlighter-rouge">String</code> 可以用作构造函数，还可以当作工具方法使用，将任意类型的值转为字符串。<code class="language-plaintext highlighter-rouge">String</code> 对象是一个类似数组的对象（很像数组，但不是数组）。</p> <h3 id="2-静态方法-stringfromcharcode">2. 静态方法 String.fromCharCode()</h3> <p><code class="language-plaintext highlighter-rouge">String.fromCharCode()</code> 方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。该方法不支持 Unicode 码点大于 <code class="language-plaintext highlighter-rouge">0xFFFF</code> 的字符，即传入的参数不能大于 <code class="language-plaintext highlighter-rouge">0xFFFF</code>（即十进制的 <code class="language-plaintext highlighter-rouge">65535</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mh">0x20BB7</span><span class="p">)</span>
<span class="c1">// "ஷ"</span>
<span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mh">0x20BB7</span><span class="p">)</span> <span class="o">===</span> <span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mh">0x0BB7</span><span class="p">)</span>
<span class="c1">// true</span>
</code></pre></div></div> <p>这种现象的根本原因在于，码点大于 <code class="language-plaintext highlighter-rouge">0xFFFF</code> 的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把 <code class="language-plaintext highlighter-rouge">0x20BB7</code> 拆成两个字符表示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mh">0xD842</span><span class="p">,</span> <span class="mh">0xDFB7</span><span class="p">)</span>
<span class="c1">// "𠮷"</span>
</code></pre></div></div> <h3 id="3-实例属性-stringprototypelength">3. 实例属性 String.prototype.length</h3> <p><code class="language-plaintext highlighter-rouge">length</code> 属性返回字符串的长度。</p> <h3 id="4-实例方法">4. 实例方法</h3> <h4 id="41-stringprototypecharatstringprototypecharcodeat">4.1 String.prototype.charAt()，String.prototype.charCodeAt()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">charAt()</code> 方法返回指定位置的字符。</li> <li><code class="language-plaintext highlighter-rouge">charCodeAt()</code> 方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于 <code class="language-plaintext highlighter-rouge">String.fromCharCode()</code> 的逆操作。</li> </ul> <h4 id="42-stringprototypeconcat">4.2 String.prototype.concat()</h4> <p><code class="language-plaintext highlighter-rouge">concat()</code> 方法用于连接两个字符串，返回一个新字符串，不改变原字符串。该方法可以接受多个参数。如果参数不是字符串，<code class="language-plaintext highlighter-rouge">concat()</code> 方法会将其先转为字符串，然后再连接。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">.</span><span class="nf">concat</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "abc"</span>
<span class="dl">''</span><span class="p">.</span><span class="nf">concat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "123"</span>
</code></pre></div></div> <h4 id="43-stringprototypeslicestringprototypesubstringstringprototypesubstr">4.3 String.prototype.slice()，String.prototype.substring()，String.prototype.substr()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">slice()</code> 方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">JavaScript</span><span class="dl">'</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// "Java"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">substring()</code> 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice() 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。不建议使用 <code class="language-plaintext highlighter-rouge">substring()</code> 方法，因为如果第一个参数大于第二个参数，或者当参数是负数时，其行为表现很怪异。应该优先使用 <code class="language-plaintext highlighter-rouge">slice()</code>。</li> <li><code class="language-plaintext highlighter-rouge">substr()</code> 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 <code class="language-plaintext highlighter-rouge">slice()</code> 和 <code class="language-plaintext highlighter-rouge">substring()</code> 方法的作用相同。</li> </ul> <p>字符串的截取，应该优先使用 <code class="language-plaintext highlighter-rouge">slice()</code>。</p> <h4 id="44-stringprototypeindexofstringprototypelastindexof">4.4 String.prototype.indexOf()，String.prototype.lastIndexOf()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">indexOf()</code> 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回 -1，就表示不匹配。该方法还可以接受第二个参数，表示从该位置开始向后匹配。</li> <li><code class="language-plaintext highlighter-rouge">lastIndexOf()</code> 方法的用法跟 <code class="language-plaintext highlighter-rouge">indexOf()</code> 方法一致，主要的区别是 <code class="language-plaintext highlighter-rouge">lastIndexOf()</code> 从尾部开始匹配，<code class="language-plaintext highlighter-rouge">indexOf()</code> 则是从头部开始匹配。</li> </ul> <h4 id="45-stringprototypetrim">4.5 String.prototype.trim()</h4> <p><code class="language-plaintext highlighter-rouge">trim()</code> 方法用于去除字符串<strong>两端</strong>的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（<code class="language-plaintext highlighter-rouge">\t</code>、<code class="language-plaintext highlighter-rouge">\v</code>）、换行符（<code class="language-plaintext highlighter-rouge">\n</code>）和回车符（<code class="language-plaintext highlighter-rouge">\r</code>）。</p> <h4 id="46-stringprototypetolowercasestringprototypetouppercase">4.6 String.prototype.toLowerCase()，String.prototype.toUpperCase()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">toLowerCase()</code> 方法将字符串<strong>全部</strong>转为小写。</li> <li><code class="language-plaintext highlighter-rouge">toUpperCase()</code> 方法将字符串<strong>全部</strong>转为大写。</li> </ul> <p>它们都返回一个新字符串，不改变原字符串。</p> <h4 id="47-stringprototypematchstringprototypesearchstringprototypereplace">4.7 String.prototype.match()，String.prototype.search()，String.prototype.replace()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">match()</code> 方法用于确定原字符串是否匹配某个子字符串，返回一个<strong>数组</strong>，成员为匹配的<strong>第一个字符串</strong>。如果没有找到匹配，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">cat, bat, sat, fat</span><span class="dl">'</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="dl">'</span><span class="s1">at</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ["at"]</span>
<span class="dl">'</span><span class="s1">cat, bat, sat, fat</span><span class="dl">'</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="dl">'</span><span class="s1">xt</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// null</span>
</code></pre></div> </div> <p>返回的数组还有 <code class="language-plaintext highlighter-rouge">index</code> 属性和 <code class="language-plaintext highlighter-rouge">input</code> 属性，分别表示匹配字符串开始的位置和原始字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">matches</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">cat, bat, sat, fat</span><span class="dl">'</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="dl">'</span><span class="s1">at</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">matches</span><span class="p">.</span><span class="nx">index</span> <span class="c1">// 1</span>
<span class="nx">matches</span><span class="p">.</span><span class="nx">input</span> <span class="c1">// "cat, bat, sat, fat"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">search()</code> 方法的用法基本等同于 <code class="language-plaintext highlighter-rouge">match()</code>，但是返回值为匹配的<strong>第一个位置</strong>。如果没有找到匹配，则返回 <code class="language-plaintext highlighter-rouge">-1</code>。</li> <li><code class="language-plaintext highlighter-rouge">replace()</code> 方法用于替换匹配的子字符串，一般情况下只替换<strong>第一个</strong>匹配（除非使用带有g修饰符的正则表达式）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">cat, bat, sat, fat</span><span class="dl">'</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="dl">'</span><span class="s1">at</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="dl">'</span><span class="s1">aaa</span><span class="dl">'</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "baa"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">match()</code>、<code class="language-plaintext highlighter-rouge">search()</code> 和 <code class="language-plaintext highlighter-rouge">replace()</code> 方法都可以使用正则表达式作为参数。</p> <h4 id="48-stringprototypesplit">4.8 String.prototype.split()</h4> <p><code class="language-plaintext highlighter-rouge">split()</code> 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的<strong>数组</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ["a", "b", "c"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">''</span><span class="p">)</span> <span class="c1">// ["a", "|", "b", "|", "c"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span> <span class="c1">// ["a|b|c"]</span>
<span class="dl">'</span><span class="s1">a||c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ['a', '', 'c']</span>
<span class="dl">'</span><span class="s1">|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ["", "b", "c"]</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">split()</code> 方法还可以接受第二个参数，限定返回数组的最大成员数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// []</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// ["a"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// ["a", "b"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// ["a", "b", "c"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// ["a", "b", "c"]</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">split()</code> 方法还可以使用正则表达式作为参数。</p> <h4 id="49-stringprototypelocalecompare">4.9 String.prototype.localeCompare()</h4> <p><code class="language-plaintext highlighter-rouge">localeCompare()</code> 方法用于比较两个字符串。它返回一个整数：</p> <ul> <li>如果小于 <code class="language-plaintext highlighter-rouge">0</code>，表示第一个字符串小于第二个字符串。</li> <li>如果等于 <code class="language-plaintext highlighter-rouge">0</code>，表示两者相等。</li> <li>如果大于 <code class="language-plaintext highlighter-rouge">0</code>，表示第一个字符串大于第二个字符串。</li> </ul> <p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">B</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，字母 <code class="language-plaintext highlighter-rouge">B</code> 小于字母 <code class="language-plaintext highlighter-rouge">a</code>。因为 JavaScript 采用的是 Unicode 码点比较，<code class="language-plaintext highlighter-rouge">B</code> 的码点是 <code class="language-plaintext highlighter-rouge">66</code>，而 <code class="language-plaintext highlighter-rouge">a</code> 的码点是 <code class="language-plaintext highlighter-rouge">97</code>。</p> <p>但是，<code class="language-plaintext highlighter-rouge">localeCompare()</code> 方法会考虑自然语言的排序情况，将 <code class="language-plaintext highlighter-rouge">B</code> 排在 <code class="language-plaintext highlighter-rouge">a</code> 的前面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">.</span><span class="nf">localeCompare</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">localeCompare()</code> 方法返回整数 <code class="language-plaintext highlighter-rouge">1</code>，表示 <code class="language-plaintext highlighter-rouge">B</code> 较大。</p> <p><code class="language-plaintext highlighter-rouge">localeCompare()</code> 还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</p> <h2 id="八math-对象">八、Math 对象</h2> <p><code class="language-plaintext highlighter-rouge">Math</code> 是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在 <code class="language-plaintext highlighter-rouge">Math</code> 对象上调用。</p> <h3 id="1-静态属性-1">1. 静态属性</h3> <p>Math 对象的静态属性，提供以下一些数学常数。这些属性都是只读的，不能修改。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Math.E</code>：常数 <code class="language-plaintext highlighter-rouge">e</code>。</li> <li><code class="language-plaintext highlighter-rouge">Math.LN2</code>：2 的自然对数。</li> <li><code class="language-plaintext highlighter-rouge">Math.LN10</code>：10 的自然对数。</li> <li><code class="language-plaintext highlighter-rouge">Math.LOG2E</code>：以 2 为底的 <code class="language-plaintext highlighter-rouge">e</code> 的对数。</li> <li><code class="language-plaintext highlighter-rouge">Math.LOG10E</code>：以 10 为底的 <code class="language-plaintext highlighter-rouge">e</code> 的对数。</li> <li><code class="language-plaintext highlighter-rouge">Math.PI</code>：常数 <code class="language-plaintext highlighter-rouge">π</code>。</li> <li><code class="language-plaintext highlighter-rouge">Math.SQRT1_2</code>：0.5 的平方根。</li> <li><code class="language-plaintext highlighter-rouge">Math.SQRT2</code>：2 的平方根。</li> </ul> <h3 id="2-静态方法-1">2. 静态方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Math.abs()</code>：返回参数值的<strong>绝对值</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.ceil()</code>：返回大于或等于参数值的最小整数（天花板值，即向上取整）。</li> <li><code class="language-plaintext highlighter-rouge">Math.floor()</code>：返回小于或等于参数值的最大整数（地板值，即向下取整）。</li> <li><code class="language-plaintext highlighter-rouge">Math.min()</code>：返回参数中的<strong>最小值</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.max()</code>：返回参数中的<strong>最大值</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.pow()</code>：返回以第一个参数为底数、第二个参数为指数的<strong>幂运算</strong>值。</li> <li><code class="language-plaintext highlighter-rouge">Math.sqrt()</code>：返回参数值的<strong>平方根</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.log()</code>：返回以 <code class="language-plaintext highlighter-rouge">e</code> 为底的<strong>自然对数</strong>值。</li> <li><code class="language-plaintext highlighter-rouge">Math.exp()</code>：返回常数 <code class="language-plaintext highlighter-rouge">e</code> 的参数次方。</li> <li><code class="language-plaintext highlighter-rouge">Math.round()</code>：用于<strong>四舍五入</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.random()</code>：返回 0 到 1 之间的一个伪随机数，可能等于 0，但是一定小于 1。</li> </ul> <p><code class="language-plaintext highlighter-rouge">Math</code> 对象还提供一系列三角函数方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Math.sin()</code>：返回参数的正弦（参数为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.cos()</code>：返回参数的余弦（参数为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.tan()</code>：返回参数的正切（参数为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.asin()</code>：返回参数的反正弦（返回值为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.acos()</code>：返回参数的反余弦（返回值为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.atan()</code>：返回参数的反正切（返回值为弧度值）</li> </ul> <h2 id="九date-对象">九、Date 对象</h2> <h3 id="1-普通函数的用法">1. 普通函数的用法</h3> <p><code class="language-plaintext highlighter-rouge">Date</code> 对象可以作为普通函数直接调用，不管是否带有参数，返回的都是代表<strong><em>当前时间</em></strong>的字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Date</span><span class="p">()</span> <span class="c1">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span>
<span class="nc">Date</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span>
</code></pre></div></div> <h3 id="2-构造函数的用法">2. 构造函数的用法</h3> <p><code class="language-plaintext highlighter-rouge">Date</code> 作为构造函数使用，返回 Date 对象的实例。如果不加参数，实例代表的是当前时间。</p> <p>其他对象求值的时候，都是默认调用 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法，但是 <code class="language-plaintext highlighter-rouge">Date</code> 实例求值的时候，默认调用的是 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。这导致对 <code class="language-plaintext highlighter-rouge">Date</code> 实例求值，返回的是一个字符串，代表该实例对应的时间。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">today</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">today</span> <span class="c1">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span>

<span class="c1">// 等同于</span>
<span class="nx">today</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span>
</code></pre></div></div> <p>作为构造函数时，<code class="language-plaintext highlighter-rouge">Date</code> 对象可以接受多种格式的参数，返回该参数对应的时间实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 参数为时间零点开始计算的毫秒数</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">1378218728000</span><span class="p">)</span>
<span class="c1">// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</span>

<span class="c1">// 参数为日期字符串</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span>

<span class="c1">// 参数为多个整数，</span>
<span class="c1">// 代表年、月、日、小时、分钟、秒、毫秒</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <p>关于 <code class="language-plaintext highlighter-rouge">Date</code> 构造函数的参数，有几点说明。</p> <ul> <li>第一点，参数可以是负整数，代表 1970 年元旦之前的时间。</li> <li> <p>第二点，只要是能被 <code class="language-plaintext highlighter-rouge">Date.parse()</code> 方法解析的字符串，都可以当作参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">2013-2-15</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">2013/2/15</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">02/15/2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">2013-FEB-15</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">FEB, 15, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">FEB 15, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">February, 15, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">February 15, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">15 Feb 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">15, February, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)</span>
</code></pre></div> </div> </li> <li>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，<code class="language-plaintext highlighter-rouge">Date</code> 会将其解释为毫秒数。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">)</span> <span class="c1">// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)</span>

<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <p>各个参数的取值范围如下。 - 年：使用四位数年份，比如 <code class="language-plaintext highlighter-rouge">2000</code>。如果写成两位数或个位数，则加上 <code class="language-plaintext highlighter-rouge">1900</code>，即 <code class="language-plaintext highlighter-rouge">10</code> 代表 <code class="language-plaintext highlighter-rouge">1910</code> 年。如果是负数，表示公元前。 - 月：<code class="language-plaintext highlighter-rouge">0</code> 表示一月，依次类推，<code class="language-plaintext highlighter-rouge">11</code> 表示 <code class="language-plaintext highlighter-rouge">12</code> 月。 - 日：<code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">31</code>。 - 小时：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">23</code>。 - 分钟：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">59</code>。 - 秒：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">59</code>。 - 毫秒：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">999</code>。</p> <p>注意，月份从 <code class="language-plaintext highlighter-rouge">0</code> 开始计算，但是，天数从 <code class="language-plaintext highlighter-rouge">1</code> 开始计算。另外，除了日期的默认值为 <code class="language-plaintext highlighter-rouge">1</code>，小时、分钟、秒钟和毫秒的默认值都是 <code class="language-plaintext highlighter-rouge">0</code>。</p> <p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为 <code class="language-plaintext highlighter-rouge">15</code>，就折算为下一年的 <code class="language-plaintext highlighter-rouge">4</code> 月。</p> <p>参数还可以使用负数，表示<strong>扣去</strong>的时间。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)</span>
  <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <h3 id="3-日期的运算">3. 日期的运算</h3> <p>类型自动转换时：</p> <ul> <li><code class="language-plaintext highlighter-rouge">Date</code> 实例如果转为数值，则等于对应的<strong>毫秒数</strong>。两个日期实例对象进行<strong>减法</strong>运算时，返回的是它们<strong>间隔的毫秒数</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Date</code> 实例如果转为字符串，则等于对应的<strong>日期字符串</strong>。两个日期实例对象进行<strong>加法</strong>运算时，返回的是两个字符串<strong>连接而成的新字符串</strong>。</li> </ul> <h3 id="4-静态方法">4. 静态方法</h3> <h4 id="41-datenow">4.1 Date.now()</h4> <p><code class="language-plaintext highlighter-rouge">Date.now()</code> 方法返回当前时间距离时间零点（1970 年 1 月 1 日 00:00:00 UTC）的<strong>毫秒数</strong>，相当于 Unix 时间戳乘以 1000。</p> <h4 id="42-dateparse">4.2 Date.parse()</h4> <p><code class="language-plaintext highlighter-rouge">Date.parse()</code> 方法用来解析日期字符串，返回该时间距离时间零点（1970 年 1 月 1 日 00:00:00）的<strong>毫秒数</strong>。</p> <p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即 <code class="language-plaintext highlighter-rouge">YYYY-MM-DDTHH:mm:ss.sssZ</code> 格式，其中最后的 <code class="language-plaintext highlighter-rouge">Z</code> 表示时区。但是，其他格式也可以被解析。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Aug 9, 1995</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">January 26, 2011 13:51:50</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mon, 25 Dec 1995 13:30:00 GMT</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mon, 25 Dec 1995 13:30:00 +0430</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">2011-10-10</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">2011-10-10T14:48:00</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div> <h4 id="43-dateutc">4.3 Date.UTC()</h4> <p><code class="language-plaintext highlighter-rouge">Date.UTC()</code> 方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970 年 1 月 1 日 00:00:00 UTC）的<strong>毫秒数</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 格式</span>
<span class="nb">Date</span><span class="p">.</span><span class="nc">UTC</span><span class="p">(</span><span class="nx">year</span><span class="p">,</span> <span class="nx">month</span><span class="p">[,</span> <span class="nx">date</span><span class="p">[,</span> <span class="nx">hrs</span><span class="p">[,</span> <span class="nx">min</span><span class="p">[,</span> <span class="nx">sec</span><span class="p">[,</span> <span class="nx">ms</span><span class="p">]]]]])</span>

<span class="c1">// 用法</span>
<span class="nb">Date</span><span class="p">.</span><span class="nc">UTC</span><span class="p">(</span><span class="mi">2011</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">567</span><span class="p">)</span> <span class="c1">// 1293847384567</span>
</code></pre></div></div> <p>该方法的参数用法与 <code class="language-plaintext highlighter-rouge">Date</code> 构造函数完全一致，比如月从 <code class="language-plaintext highlighter-rouge">0</code> 开始计算，日期从 <code class="language-plaintext highlighter-rouge">1</code> 开始计算。区别在于 <code class="language-plaintext highlighter-rouge">Date.UTC()</code> 方法的参数，会被解释为 <strong>UTC 时间</strong>（世界标准时间），<code class="language-plaintext highlighter-rouge">Date</code> 构造函数的参数会被解释为<strong>当前时区</strong>的时间。</p> <h3 id="5-实例方法">5. 实例方法</h3> <p><code class="language-plaintext highlighter-rouge">Date</code> 的实例对象，有几十个自己的方法，除了 <code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code>，可以分为以下三类。</p> <ul> <li>to 类：从 <code class="language-plaintext highlighter-rouge">Date</code> 对象返回一个字符串，表示指定的时间。</li> <li>get 类：获取 <code class="language-plaintext highlighter-rouge">Date</code> 对象的日期和时间。</li> <li>set 类：设置 <code class="language-plaintext highlighter-rouge">Date</code> 对象的日期和时间。</li> </ul> <h4 id="51-dateprototypevalueof">5.1 Date.prototype.valueOf()</h4> <p><code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回实例对象距离时间零点（1970 年 1 月 1 日 00:00:00 UTC）对应的<strong>毫秒数</strong>，该方法等同于 <code class="language-plaintext highlighter-rouge">getTime()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// 1362790014817</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">getTime</span><span class="p">()</span> <span class="c1">// 1362790014817</span>
</code></pre></div></div> <p>预期为数值的场合，<code class="language-plaintext highlighter-rouge">Date</code> 实例会自动调用该方法，所以可以用下面的方法计算时间的间隔。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="kd">var</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">elapsed</span> <span class="o">=</span> <span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span><span class="p">;</span>
</code></pre></div></div> <h4 id="52-to-类方法">5.2 to 类方法</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Date.prototype.toString()</code>：返回一个完整的日期字符串。<code class="language-plaintext highlighter-rouge">toString()</code> 是默认的调用方法，如果直接读取 <code class="language-plaintext highlighter-rouge">Date</code> 实例，就相当于调用这个方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span>
<span class="nx">d</span> <span class="c1">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toUTCString()</code>：返回对应的 UTC 时间，也就是比北京时间晚 8 个小时。</li> <li> <p><code class="language-plaintext highlighter-rouge">Date.prototype.toISOString()</code>：返回对应时间的 ISO8601 写法。此方法返回的总是 UTC 时区的时间。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toISOString</span><span class="p">()</span><span class="c1">// "2012-12-31T16:00:00.000Z"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toJSON()</code>：返回一个符合 JSON 格式的 ISO 日期字符串，与 toISOString 方法的返回结果完全相同。</li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toDateString()</code>：返回日期字符串（不含小时、分和秒）。</li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toTimeString()</code>：返回时间字符串（不含年月日）。</li> </ul> <p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toLocaleString([locales[, options]])</code>：完整的本地时间。</li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toLocaleDateString([locales[, options]])</code>：本地日期（不含小时、分和秒）。</li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toLocaleTimeString([locales[, options]])</code>：本地时间（不含年月日）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">()</span>
<span class="c1">// 中文版浏览器为"2013/1/1 00:00:00"</span>
<span class="c1">// 英文版浏览器为"1/1/2013 12:00:00 AM"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">()</span>
<span class="c1">// 中文版浏览器为"2013/1/1"</span>
<span class="c1">// 英文版浏览器为"1/1/2013"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">()</span>
<span class="c1">// 中文版浏览器为"00:00:00"</span>
<span class="c1">// 英文版浏览器为"12:00:00 AM"</span>
</code></pre></div></div> <p>这三个方法的两个参数中，<code class="language-plaintext highlighter-rouge">locales</code> 是一个指定所用语言的字符串，<code class="language-plaintext highlighter-rouge">options</code> 是一个配置对象。下面是 <code class="language-plaintext highlighter-rouge">locales</code> 的例子，分别采用 <code class="language-plaintext highlighter-rouge">en-US</code> 和 <code class="language-plaintext highlighter-rouge">zh-CN</code> 语言设定。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "1/1/2013, 12:00:00 AM"</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-CN</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "2013/1/1 00:00:00"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "1/1/2013"</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-CN</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "2013/1/1"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "12:00:00 AM"</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-CN</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "00:00:00"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">options</code> 配置对象有以下属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">dateStyle</code>：可能的值为 <code class="language-plaintext highlighter-rouge">full</code>、<code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">medium</code>、<code class="language-plaintext highlighter-rouge">short</code>。</li> <li><code class="language-plaintext highlighter-rouge">timeStyle</code>：可能的值为 <code class="language-plaintext highlighter-rouge">full</code>、<code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">medium</code>、<code class="language-plaintext highlighter-rouge">short</code>。</li> <li><code class="language-plaintext highlighter-rouge">month</code>：可能的值为 <code class="language-plaintext highlighter-rouge">numeric</code>、<code class="language-plaintext highlighter-rouge">2-digit</code>、<code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">short</code>、<code class="language-plaintext highlighter-rouge">narrow</code>。</li> <li><code class="language-plaintext highlighter-rouge">year</code>：可能的值为 <code class="language-plaintext highlighter-rouge">numeric</code>、<code class="language-plaintext highlighter-rouge">2-digit</code>。</li> <li><code class="language-plaintext highlighter-rouge">weekday</code>：可能的值为 <code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">short</code>、<code class="language-plaintext highlighter-rouge">narrow</code>。</li> <li><code class="language-plaintext highlighter-rouge">day</code>、<code class="language-plaintext highlighter-rouge">hour</code>、<code class="language-plaintext highlighter-rouge">minute</code>、<code class="language-plaintext highlighter-rouge">second</code>：可能的值为 <code class="language-plaintext highlighter-rouge">numeric</code>、<code class="language-plaintext highlighter-rouge">2-digit</code>。</li> <li><code class="language-plaintext highlighter-rouge">timeZone</code>：可能的值为 IANA 的时区数据库。</li> <li><code class="language-plaintext highlighter-rouge">timeZoneName</code>：可能的值为 <code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">short</code>。</li> <li><code class="language-plaintext highlighter-rouge">hour12</code>：24 小时周期还是 12 小时周期，可能的值为 <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">weekday</span><span class="p">:</span> <span class="dl">'</span><span class="s1">long</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">year</span><span class="p">:</span> <span class="dl">'</span><span class="s1">numeric</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">month</span><span class="p">:</span> <span class="dl">'</span><span class="s1">long</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">day</span><span class="p">:</span> <span class="dl">'</span><span class="s1">numeric</span><span class="dl">'</span>
<span class="p">})</span>
<span class="c1">// "Tuesday, January 1, 2013"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">day</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2-digit</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">month</span><span class="p">:</span> <span class="dl">"</span><span class="s2">long</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">year</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2-digit</span><span class="dl">"</span>
<span class="p">});</span>
<span class="c1">// "January 01, 13"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">timeZone</span><span class="p">:</span> <span class="dl">'</span><span class="s1">UTC</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">timeZoneName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">short</span><span class="dl">'</span>
<span class="p">})</span>
<span class="c1">// "4:00:00 PM UTC"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">timeZone</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Asia/Shanghai</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">timeZoneName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">long</span><span class="dl">'</span>
<span class="p">})</span>
<span class="c1">// "12:00:00 AM China Standard Time"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">hour12</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">})</span>
<span class="c1">// "00:00:00"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">hour12</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">})</span>
<span class="c1">// "12:00:00 AM"</span>
</code></pre></div></div> <h4 id="53-get-类方法">5.3 get 类方法</h4> <p><code class="language-plaintext highlighter-rouge">Date</code> 对象提供了一系列 <code class="language-plaintext highlighter-rouge">get*</code> 方法，用来获取实例对象某个方面的值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getTime()</code>：返回实例距离 1970 年 1 月 1 日 00:00:00 的毫秒数，等同于 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。</li> <li><code class="language-plaintext highlighter-rouge">getDate()</code>：返回实例对象对应每个月的几号（从 1 开始）。</li> <li><code class="language-plaintext highlighter-rouge">getDay()</code>：返回星期几，星期日为0，星期一为 1，以此类推。</li> <li><code class="language-plaintext highlighter-rouge">getFullYear()</code>：返回四位的年份。</li> <li><code class="language-plaintext highlighter-rouge">getMonth()</code>：返回月份（0 表示 1 月，11 表示 12月）。</li> <li><code class="language-plaintext highlighter-rouge">getHours()</code>：返回小时（0-23）。</li> <li><code class="language-plaintext highlighter-rouge">getMilliseconds()</code>：返回毫秒（0-999）。</li> <li><code class="language-plaintext highlighter-rouge">getMinutes()</code>：返回分钟（0-59）。</li> <li><code class="language-plaintext highlighter-rouge">getSeconds()</code>：返回秒（0-59）。</li> <li><code class="language-plaintext highlighter-rouge">getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。</li> </ul> <p>所有这些 get* 方法返回的都是整数，不同方法返回值的范围不一样。</p> <ul> <li>分钟和秒：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">59</code></li> <li>小时：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">23</code></li> <li>星期：<code class="language-plaintext highlighter-rouge">0</code>（星期天）到 <code class="language-plaintext highlighter-rouge">6</code>（星期六）</li> <li>日期：<code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">31</code></li> <li>月份：<code class="language-plaintext highlighter-rouge">0</code>（一月）到 <code class="language-plaintext highlighter-rouge">11</code>（十二月）</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">getDate</span><span class="p">()</span> <span class="c1">// 6</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">getMonth</span><span class="p">()</span> <span class="c1">// 0</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">getFullYear</span><span class="p">()</span> <span class="c1">// 2013</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">getTimezoneOffset</span><span class="p">()</span> <span class="c1">// -480</span>
</code></pre></div></div> <p>上面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getUTCDate()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCFullYear()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCMonth()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCDay()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCHours()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCMinutes()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCSeconds()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCMilliseconds()</code></li> </ul> <h4 id="54-set-类方法">5.4 set 类方法</h4> <p><code class="language-plaintext highlighter-rouge">Date</code> 对象提供了一系列 <code class="language-plaintext highlighter-rouge">set*</code> 方法，用来设置实例对象的各个方面。</p> <ul> <li><code class="language-plaintext highlighter-rouge">setDate(date)</code>：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。</li> <li><code class="language-plaintext highlighter-rouge">setFullYear(year [, month, date])</code>：设置四位年份。</li> <li><code class="language-plaintext highlighter-rouge">setHours(hour [, min, sec, ms])</code>：设置小时（0-23）。</li> <li><code class="language-plaintext highlighter-rouge">setMilliseconds(ms)</code>：设置毫秒（0-999）。</li> <li><code class="language-plaintext highlighter-rouge">setMinutes(min [, sec, ms])</code>：设置分钟（0-59）。</li> <li><code class="language-plaintext highlighter-rouge">setMonth(month [, date])</code>：设置月份（0-11）。</li> <li><code class="language-plaintext highlighter-rouge">setSeconds(sec [, ms])</code>：设置秒（0-59）。</li> <li><code class="language-plaintext highlighter-rouge">setTime(milliseconds)</code>：设置毫秒时间戳。</li> </ul> <p>这些方法基本是跟 <code class="language-plaintext highlighter-rouge">get*</code> 方法一一对应的，但是没有 <code class="language-plaintext highlighter-rouge">setDay</code> 方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从 <code class="language-plaintext highlighter-rouge">0 开始算的，即 </code>0<code class="language-plaintext highlighter-rouge"> 是 </code>1<code class="language-plaintext highlighter-rouge"> 月，</code>11<code class="language-plaintext highlighter-rouge"> 是 </code>12` 月。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date </span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d</span> <span class="c1">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">setDate</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="c1">// 1357660800000</span>
<span class="nx">d</span> <span class="c1">// Wed Jan 09 2013 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">set*</code> 方法的参数都会自动折算。以 <code class="language-plaintext highlighter-rouge">setDate()</code> 为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d1</span><span class="p">.</span><span class="nf">setDate</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="c1">// 1359648000000</span>
<span class="nx">d1</span> <span class="c1">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span>

<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date </span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d2</span><span class="p">.</span><span class="nf">setDate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 1356796800000</span>
<span class="nx">d2</span> <span class="c1">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">d1.setDate(32)</code> 将日期设为 <code class="language-plaintext highlighter-rouge">1</code> 月份的 <code class="language-plaintext highlighter-rouge">32</code> 号，因为 <code class="language-plaintext highlighter-rouge">1</code> 月份只有 <code class="language-plaintext highlighter-rouge">31</code> 号，所以自动折算为 <code class="language-plaintext highlighter-rouge">2</code> 月 <code class="language-plaintext highlighter-rouge">1</code> 日。<code class="language-plaintext highlighter-rouge">d2.setDate(-1)</code> 表示设为上个月的倒数第二天，即 <code class="language-plaintext highlighter-rouge">12</code> 月 <code class="language-plaintext highlighter-rouge">30</code> 日。</p> <p>set 类方法和 get 类方法，可以结合使用，得到相对时间。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>

<span class="c1">// 将日期向后推1000天</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">setDate</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">getDate</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">);</span>
<span class="c1">// 将时间设为6小时后</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">setHours</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">getHours</span><span class="p">()</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
<span class="c1">// 将年份设为去年</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">setFullYear</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">getFullYear</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">set*</code> 系列方法除了 <code class="language-plaintext highlighter-rouge">setTime()</code>，都有对应的 UTC 版本，即设置 UTC 时区的时间。</p> <ul> <li><code class="language-plaintext highlighter-rouge">setUTCDate()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCFullYear()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCHours()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCMilliseconds()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCMinutes()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCMonth()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCSeconds()</code></li> </ul> <h2 id="十regexp-对象">十、RegExp 对象</h2> <h2 id="十一json-对象">十一、JSON 对象</h2> <h2 id="十二参考">十二、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/stdlib/">JavaScript 教程 - 标准库</a></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 标准库》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/operators/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-08T00:00:00+00:00</published><updated>2024-10-08T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/operators</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/operators/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/operators/">《JavaScript 教程 - 运算符》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一算术运算符">一、算术运算符</h2> <h3 id="11-概述">1.1 概述</h3> <p>JavaScript 共提供 10 个算术运算符，用来完成基本的算术运算。包括 <code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">**</code>（指数运算符）、<code class="language-plaintext highlighter-rouge">%</code>（余数运算符）、<code class="language-plaintext highlighter-rouge">++x</code>（或者 <code class="language-plaintext highlighter-rouge">x++</code>，即自增运算符）、<code class="language-plaintext highlighter-rouge">--x</code>（或者 <code class="language-plaintext highlighter-rouge">x--</code>，即）自减运算符、<code class="language-plaintext highlighter-rouge">+x</code>（数值运算符） 和 <code class="language-plaintext highlighter-rouge">-x</code>（负数值运算符）。</p> <h3 id="12-加法运算符">1.2 加法运算符</h3> <h4 id="1基本规则">（1）基本规则</h4> <p>加法运算符（<code class="language-plaintext highlighter-rouge">+</code>）即可当作算数运算符，又可对字符串进行连接操作。</p> <p>只要有一个是运算子是字符串，进行的就是字符串的连接操作（此时，如果另一个运算子不是字符串，会被转为字符串）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// "1a"</span>
<span class="kc">false</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// "falsea"</span>
</code></pre></div></div> <p>加法运算符是在<strong>运行时</strong>决定，到底是执行相加，还是执行连接。运算子的不同，会导致不同的语法行为，这种现象称为“<strong>重载</strong>”（overload）。除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：<strong>所有运算子一律转为数值，再进行相应的数学运算</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1">// "345"</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span> <span class="c1">// "75"</span>

<span class="mi">1</span> <span class="o">-</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">*</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// 2</span>
<span class="mi">1</span> <span class="o">/</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// 0.5</span>
</code></pre></div></div> <h4 id="2对象的相加">（2）对象的相加</h4> <p>如果运算子是对象，必须先转成原始类型的值，然后再相加。它的规则是：首先自动调用对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法，如果此时返回的是原始类型的值，则进行相应的操作，如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法得到的是对象类型，再自动调用对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，将对象转为字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "[object Object]2"</span>
</code></pre></div></div> <p>上面代码中，对象 <code class="language-plaintext highlighter-rouge">obj</code> 转成原始类型的值是 <code class="language-plaintext highlighter-rouge">[object Object]</code>，再加 <code class="language-plaintext highlighter-rouge">2</code> 就得到了上面的结果。</p> <p>（1）首先，自动调用对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// { p: 1 }</span>
</code></pre></div></div> <p>（2）一般来说，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法总是返回对象自身，这时再自动调用对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，将其转为字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">().</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "[object Object]"</span>
</code></pre></div></div> <p>对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法默认返回 <code class="language-plaintext highlighter-rouge">[object Object]</code>，所以就得到了最前面那个例子的结果。</p> <p>注意，如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回的是原始类型的值，就不再调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，否则会调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，尝试将对象转为字符串。</p> <p>可以自己定义 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法或 <code class="language-plaintext highlighter-rouge">toString()</code> 方法的返回值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">valueOf</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// 3</span>

<span class="kd">var</span> <span class="nx">anotherObj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">toString</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">anotherObj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "hello2"</span>
</code></pre></div></div> <p>这里有一个特例，如果运算子是一个 <code class="language-plaintext highlighter-rouge">Date</code> 对象的实例，那么会优先执行 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "hello2"</span>
</code></pre></div></div> <p>上面代码中，对象 <code class="language-plaintext highlighter-rouge">obj</code> 是一个 <code class="language-plaintext highlighter-rouge">Date</code> 对象的实例，并且自定义了 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法和 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，结果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法优先执行。</p> <h3 id="13-余数运算符">1.3 余数运算符</h3> <p>余数运算符（<code class="language-plaintext highlighter-rouge">%</code>）运算结果的正负号由<strong>第一个</strong>运算子的正负号决定。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="mi">1</span> <span class="o">%</span> <span class="mi">2</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">%</span> <span class="o">-</span><span class="mi">2</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>所以，为了得到负数的正确余数值，可以先使用绝对值函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 错误的写法</span>
<span class="kd">function</span> <span class="nf">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// 正确的写法</span>
<span class="kd">function</span> <span class="nf">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">6.5</span> <span class="o">%</span> <span class="mf">2.1</span>
<span class="c1">// 0.19999999999999973</span>
</code></pre></div></div> <h3 id="14-自增和自减运算符">1.4 自增和自减运算符</h3> <p>对于自增和自减运算符，运算之后，变量的值发生变化，这种效应叫做运算的<strong>副作用</strong>（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。</p> <ul> <li>如果运算符放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。</li> <li>如果运算符放在变量之后，会先返回变量操作前的值，再进行自增/自减操作。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">x</span><span class="o">++</span> <span class="c1">// 1</span>
<span class="o">++</span><span class="nx">y</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">x</code> 是先返回当前值，然后自增，所以得到 <code class="language-plaintext highlighter-rouge">1</code>；<code class="language-plaintext highlighter-rouge">y</code> 是先自增，然后返回新的值，所以得到 <code class="language-plaintext highlighter-rouge">2</code>。</p> <h3 id="15-数值运算符负数值运算符">1.5 数值运算符，负数值运算符</h3> <p>数值运算符（<code class="language-plaintext highlighter-rouge">+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。数值运算符的作用在于可以将任何值转为数值（与 <code class="language-plaintext highlighter-rouge">Number</code> 函数的作用相同）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span><span class="kc">true</span> <span class="c1">// 1</span>
<span class="o">+</span><span class="p">[]</span> <span class="c1">// 0</span>
<span class="o">+</span><span class="p">{}</span> <span class="c1">// NaN</span>
</code></pre></div></div> <p>负数值运算符（<code class="language-plaintext highlighter-rouge">-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。</p> <h3 id="16-指数运算符">1.6 指数运算符</h3> <p>指数运算符（<code class="language-plaintext highlighter-rouge">**</code>）完成指数运算，前一个运算子是<strong>底数</strong>，后一个运算子是<strong>指数</strong>。注意，指数运算符是<strong>右结合</strong>。即多个指数运算符连用时，先进行最右边的计算。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="c1">// 16</span>

<span class="c1">// 相当于 2 ** (3 ** 2)</span>
<span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">**</span> <span class="mi">2</span>
<span class="c1">// 512</span>
</code></pre></div></div> <h2 id="二比较运算符">二、比较运算符</h2> <h3 id="21-概述">2.1 概述</h3> <p>JavaScript 提供了 8 个比较运算符，他们是：<code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;=</code>、<code class="language-plaintext highlighter-rouge">&lt;=</code>、<code class="language-plaintext highlighter-rouge">==</code>、<code class="language-plaintext highlighter-rouge">===</code>、<code class="language-plaintext highlighter-rouge">!=</code> 和 <code class="language-plaintext highlighter-rouge">!==</code>。</p> <p>这八个比较运算符分成两类：相等比较和非相等比较。对于非相等（<code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;=</code> 和 <code class="language-plaintext highlighter-rouge">&lt;=</code>）的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照<strong>字典顺序</strong>比较（实际上是比较 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p> <h3 id="22-非相等运算符字符串的比较">2.2 非相等运算符：字符串的比较</h3> <p>字符串按照字典顺序进行比较。首先比较首字符的 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点。如果相等，再比较第二个字符的 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点，以此类推。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">dog</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">Cat</span><span class="dl">'</span> <span class="c1">// true' c 的 Unicode 码点是 99，C 的 Unicode 码点是 67</span>
<span class="dl">'</span><span class="s1">大</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">小</span><span class="dl">'</span> <span class="c1">// false “大”的 Unicode 码点是 22823，“小”是23567</span>
</code></pre></div></div> <h3 id="23-非相等运算符非字符串的比较">2.3 非相等运算符：非字符串的比较</h3> <p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。</p> <h4 id="1原始类型值">（1）原始类型值</h4> <p>如果两个运算子都是原始类型的值，则先转成数值再比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">4</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="c1">// 等同于 5 &gt; Number('4')</span>
<span class="c1">// 即 5 &gt; 4</span>

<span class="kc">true</span> <span class="o">&gt;</span> <span class="kc">false</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number(true) &gt; Number(false)</span>
<span class="c1">// 即 1 &gt; 0</span>

<span class="mi">2</span> <span class="o">&gt;</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 2 &gt; Number(true)</span>
<span class="c1">// 即 2 &gt; 1</span>
</code></pre></div></div> <p>任何值（包括 <code class="language-plaintext highlighter-rouge">NaN</code> 本身）与 <code class="language-plaintext highlighter-rouge">NaN</code> 使用非相等运算符进行比较，返回的都是 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="mi">1</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="2对象">（2）对象</h4> <p>如果运算子是对象，会转为<strong>原始类型</strong>的值，再进行比较。对象转换成原始类型的值，算法是先调用 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法；如果返回的还是对象，再接着调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">11</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; '11'</span>
<span class="c1">// 即 '2' &gt; '11'</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">11</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="c1">// 等同于 (function () { return '1' })() &gt; '11'</span>
<span class="c1">// 即 '1' &gt; '11'</span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span>
<span class="c1">// 即 '2' &gt; '1'</span>
</code></pre></div></div> <h3 id="24-严格相等运算符">2.4 严格相等运算符</h3> <ul> <li>相等运算符（<code class="language-plaintext highlighter-rouge">==</code>）比较两个值是否<strong>相等</strong>。如果两个值不是同一类型，相等运算符会将它们转换成同一个类型，再用严格相等运算符进行比较。</li> <li>严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）比较两个值是否为“<strong>同一个值</strong>”。如果两个值不是同一类型，严格相等运算符直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <p>对于严格相等运算符：</p> <ul> <li>如果两个值的类型不同，直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回 <code class="language-plaintext highlighter-rouge">true</code>，值不同就返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li>复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向<strong>同一个地址</strong>。</li> <li><code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 与自身严格相等。</li> </ul> <h3 id="25-严格不相等运算符">2.5 严格不相等运算符</h3> <p>严格不相等运算符（<code class="language-plaintext highlighter-rouge">!==</code>）先求严格相等运算符的结果，然后取相反值。</p> <h3 id="26-相等运算符">2.6 相等运算符</h3> <p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。比较不同类型的数据时，相等运算符会先将数据进行<strong>类型转换</strong>，然后再用严格相等运算符比较。</p> <ul> <li> <p>原始类型的值会转换成数值再进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 1 === Number(true)</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="c1">// 等同于 2 === Number(false)</span>

<span class="dl">'</span><span class="s1">true</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
<span class="c1">// 等同于 Number('true') === Number(true)</span>
<span class="c1">// 等同于 NaN === 1</span>

<span class="dl">''</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number('') === 0</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="dl">''</span> <span class="o">==</span> <span class="kc">false</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number('') === Number(false)</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number('1') === Number(true)</span>
<span class="c1">// 等同于 1 === 1</span>

<span class="dl">'</span><span class="se">\n</span><span class="s1">  123  </span><span class="se">\t</span><span class="dl">'</span> <span class="o">==</span> <span class="mi">123</span> <span class="c1">// true</span>
<span class="c1">// 因为字符串转为数字时，省略前置和后置的空格</span>
</code></pre></div> </div> </li> <li> <p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。先调用对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，得到字符串形式，再进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组与数值的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">// true</span>

<span class="c1">// 数组与字符串的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1,2</span><span class="dl">'</span> <span class="c1">// true</span>

<span class="c1">// 对象与布尔值的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 只有与自身比较，或者互相比较时，才会返回 <code class="language-plaintext highlighter-rouge">true</code>；与其他类型的值比较时，结果都为 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">undefined</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="c1">// true</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
<span class="kc">undefined</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
</code></pre></div> </div> </li> <li> <p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">==</span> <span class="dl">''</span>             <span class="c1">// true</span>
<span class="mi">0</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span>            <span class="c1">// true</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">true</span>           <span class="c1">// false</span>
<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span>          <span class="c1">// false</span>

<span class="kc">false</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">false</span><span class="dl">'</span>    <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span>        <span class="c1">// true</span>

<span class="kc">false</span> <span class="o">==</span> <span class="kc">undefined</span>  <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="kc">null</span>       <span class="c1">// false</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">undefined</span>   <span class="c1">// true</span>

<span class="dl">'</span><span class="s1"> </span><span class="se">\t\r\n</span><span class="s1"> </span><span class="dl">'</span> <span class="o">==</span> <span class="mi">0</span>     <span class="c1">// true</span>
</code></pre></div> </div> </li> </ul> <p>建议不要使用相等运算符（<code class="language-plaintext highlighter-rouge">==</code>），最好只使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）。</p> <h3 id="27-不相等运算符">2.7 不相等运算符</h3> <p>不相等运算符（<code class="language-plaintext highlighter-rouge">!=</code>）先求相等运算符的结果，然后取相反值。</p> <h2 id="三布尔运算符">三、布尔运算符</h2> <h3 id="31-概述">3.1 概述</h3> <p>布尔运算符用于将表达式转为布尔值，共包含四个运算符：<code class="language-plaintext highlighter-rouge">||</code>（或运算符）、<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>（且运算符）、<code class="language-plaintext highlighter-rouge">!</code>（取反运算符）和 <code class="language-plaintext highlighter-rouge">?:</code>（三元运算符）。</p> <h3 id="32-取反运算符">3.2 取反运算符（!）</h3> <ul> <li><code class="language-plaintext highlighter-rouge">undefined</code>、<code class="language-plaintext highlighter-rouge">null</code>、<code class="language-plaintext highlighter-rouge">false</code>、<code class="language-plaintext highlighter-rouge">0</code>、<code class="language-plaintext highlighter-rouge">NaN</code> 和空字符串（<code class="language-plaintext highlighter-rouge">''</code>）取反后为 <code class="language-plaintext highlighter-rouge">true</code>，其他值都为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li> <p>对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 <code class="language-plaintext highlighter-rouge">Boolean()</code> 函数的作用相同。这是一种常用的类型转换的写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!!</span><span class="nx">x</span>
<span class="c1">// 等同于</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> <h3 id="33-且运算符">3.3 且运算符（&amp;&amp;）</h3> <p>且运算符（<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>）的运算规则是：如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>，则返回第二个运算子的<strong>值</strong>（注意是值，不是布尔值）；如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">false</code>，则直接返回第一个运算子的<strong>值</strong>，且不再对第二个运算子求值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">''</span> <span class="c1">// ""</span>
<span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "f"</span>
<span class="dl">''</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// ""</span>
</code></pre></div></div> <p>这种跳过第二个运算子的机制，被称为“<strong>短路</strong>”。有时候可以用它取代 <code class="language-plaintext highlighter-rouge">if</code> 结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 等价于</span>
<span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nf">doSomething</span><span class="p">();</span>
</code></pre></div></div> <p>且运算符可以多个连用，这时返回<strong>第一个</strong>布尔值为 <code class="language-plaintext highlighter-rouge">false</code> 的表达式的<strong>值</strong>。如果所有表达式的布尔值都为 <code class="language-plaintext highlighter-rouge">true</code>，则返回<strong>最后一个</strong>表达式的<strong>值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">''</span> <span class="o">&amp;&amp;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
<span class="c1">// ''</span>

<span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="mi">3</span>
<span class="c1">// 3</span>
</code></pre></div></div> <h3 id="34-或运算符">3.4 或运算符（||）</h3> <p>或运算符（<code class="language-plaintext highlighter-rouge">||</code>）的运算规则是：如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>，则返回第一个运算子的<strong>值</strong>，且不再对第二个运算子求值；如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">false</code>，则返回第二个运算子的<strong>值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">||</span> <span class="dl">''</span> <span class="c1">// "t"</span>
<span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "t"</span>
<span class="dl">''</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "f"</span>
<span class="dl">''</span> <span class="o">||</span> <span class="dl">''</span> <span class="c1">// ""</span>
</code></pre></div></div> <p>或运算符可以多个连用，这时返回<strong>第一个</strong>布尔值为 <code class="language-plaintext highlighter-rouge">true</code> 的表达式的<strong>值</strong>。如果所有表达式都为 <code class="language-plaintext highlighter-rouge">false</code>，则返回<strong>最后一个</strong>表达式的<strong>值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="dl">''</span> <span class="o">||</span> <span class="mi">4</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">||</span> <span class="kc">true</span>
<span class="c1">// 4</span>

<span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="dl">''</span>
<span class="c1">// ''</span>
</code></pre></div></div> <h2 id="四二进制位运算符">四、二进制位运算符</h2> <h3 id="41-概述">4.1 概述</h3> <p>二进制位运算符用于直接对二进制位进行计算，共有 7 个。</p> <ul> <li>二进制<strong>与</strong>运算符（and）：符号为 <code class="language-plaintext highlighter-rouge">&amp;</code>，表示若两个二进制位都为 <code class="language-plaintext highlighter-rouge">1</code>，则结果为 <code class="language-plaintext highlighter-rouge">1</code>，否则为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li>二进制<strong>或</strong>运算符（or）：符号为 <code class="language-plaintext highlighter-rouge">|</code>，表示若两个二进制位都为 <code class="language-plaintext highlighter-rouge">0</code>，则结果为 <code class="language-plaintext highlighter-rouge">0</code>，否则为 <code class="language-plaintext highlighter-rouge">1</code>。</li> <li>二进制<strong>否</strong>运算符（not）：符号为 <code class="language-plaintext highlighter-rouge">~</code>，表示对一个二进制位取反。</li> <li><strong>异或</strong>运算符（xor）：符号为 <code class="language-plaintext highlighter-rouge">^</code>，表示若两个二进制位不相同，则结果为 <code class="language-plaintext highlighter-rouge">1</code>，否则为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><strong>左移</strong>运算符（left shift）：符号为 <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>。</li> <li><strong>右移</strong>运算符（right shift）：符号为 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>。</li> <li><strong>头部补零的右移</strong>运算符（zero filled right shift）：符号为 <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>。</li> </ul> <p><strong>这些位运算符直接处理每个比特位（bit）</strong>。</p> <p>位运算符只对<strong>整数</strong>起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是以 <strong>32 位带符号的整数</strong>进行运算的，并且返回值也是一个 32 位带符号的整数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div> <p>上面这行代码的意思，就是将 <code class="language-plaintext highlighter-rouge">i</code>（不管是整数或小数）转为 32 位整数。</p> <p>利用这个特性，可以写出一个函数，将任意数值转为 32 位整数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">toInt32</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">toInt32</span><span class="p">(</span><span class="mf">1.001</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="mf">1.999</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// -1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// -1</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">toInt32()</code> 方法将任意值与 <code class="language-plaintext highlighter-rouge">0</code> 进行一次<strong>或</strong>运算，这个位运算会自动将一个值转为 32 位整数。上面代码中，<code class="language-plaintext highlighter-rouge">toInt32()</code> 用于将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于 2 的 32 次方的整数，大于 32 位的数位都会被舍去。</p> <h3 id="42-二进制或运算符">4.2 二进制或运算符</h3> <p>二进制或运算符（<code class="language-plaintext highlighter-rouge">|</code>）<strong>逐位</strong>比较两个运算子，两个二进制位之中只要有一个为 <code class="language-plaintext highlighter-rouge">1</code>，就返回 <code class="language-plaintext highlighter-rouge">1</code>，否则返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">|</span> <span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">3</code> 的二进制形式分别是 <code class="language-plaintext highlighter-rouge">00</code> 和 <code class="language-plaintext highlighter-rouge">11</code>，所以进行二进制或运算会得到 <code class="language-plaintext highlighter-rouge">11</code>（即 <code class="language-plaintext highlighter-rouge">3</code>）。</p> <p>位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，<strong>将一个小数与 <code class="language-plaintext highlighter-rouge">0</code> 进行二进制或运算，等同于对该数去除小数部分，即取整数位</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">2.9</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// 2</span>
<span class="o">-</span><span class="mf">2.9</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// -2</span>
</code></pre></div></div> <h3 id="43-二进制与运算符">4.3 二进制与运算符</h3> <p>二进制与运算符（<code class="language-plaintext highlighter-rouge">&amp;</code>）<strong>逐位</strong>比较两个运算子，两个二进制位之中只要有一个位为 <code class="language-plaintext highlighter-rouge">0</code>，就返回 <code class="language-plaintext highlighter-rouge">0</code>，否则返回 <code class="language-plaintext highlighter-rouge">1</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="c1">// 0</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">0</code>（二进制 <code class="language-plaintext highlighter-rouge">00</code>）和 <code class="language-plaintext highlighter-rouge">3</code>（二进制 <code class="language-plaintext highlighter-rouge">11</code>）进行二进制与运算会得到 <code class="language-plaintext highlighter-rouge">00</code>（即 <code class="language-plaintext highlighter-rouge">0</code>）。</p> <h3 id="44-二进制否运算符">4.4 二进制否运算符</h3> <p>二进制否运算符（<code class="language-plaintext highlighter-rouge">~</code>）将每个二进制位都变为相反值（<code class="language-plaintext highlighter-rouge">0</code> 变为 <code class="language-plaintext highlighter-rouge">1</code>，<code class="language-plaintext highlighter-rouge">1</code> 变为 <code class="language-plaintext highlighter-rouge">0</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~</span> <span class="mi">3</span> <span class="c1">// -4</span>
</code></pre></div></div> <p>上面表达式对 <code class="language-plaintext highlighter-rouge">3</code> 进行二进制否运算，得到 <code class="language-plaintext highlighter-rouge">-4</code>。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为 32 位的二进制整数再进行运算。其计算过程如下。</p> <ol> <li>首先计算 <code class="language-plaintext highlighter-rouge">3</code> 的 32 位整数形式是 <code class="language-plaintext highlighter-rouge">00000000000000000000000000000011</code>；</li> <li>进行二进制<strong>否</strong>运算后得到 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111100</code>；</li> <li>由于第一位（符号位）是 1，所以这个数是一个负数。JavaScript 内部采用<strong>补码</strong>形式表示负数，即需要将这个数减去 <code class="language-plaintext highlighter-rouge">1</code>，再取一次反，然后加上负号，才能得到这个负数对应的 10 进制值。也就是，<code class="language-plaintext highlighter-rouge">11111111111111111111111111111100 - 1 = 11111111111111111111111111111011</code>，再取一次反得到 <code class="language-plaintext highlighter-rouge">00000000000000000000000000000100</code>，由于第 2 步得到的是个负数，所以加上负号就是 <code class="language-plaintext highlighter-rouge">-4</code>。</li> </ol> <p>考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于 <code class="language-plaintext highlighter-rouge">-1</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~</span> <span class="o">-</span><span class="mi">3</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面表达式可以这样算，<code class="language-plaintext highlighter-rouge">-3</code> 的取反值等于 <code class="language-plaintext highlighter-rouge">-1</code> 减去 <code class="language-plaintext highlighter-rouge">-3</code>，结果为 <code class="language-plaintext highlighter-rouge">2</code>。</p> <p>对一个整数连续两次二进制否运算，得到它自身。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~~</span><span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，<strong>对一个小数连续进行两次二进制否运算，能达到取整效果</strong>。<strong>使用二进制否运算取整，是所有取整方法中最快的一种</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~~</span><span class="mf">2.9</span> <span class="c1">// 2</span>
<span class="o">~~</span><span class="mf">47.11</span> <span class="c1">// 47</span>
<span class="o">~~</span><span class="mf">1.9999</span> <span class="c1">// 1</span>
<span class="o">~~</span><span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>对字符串和其他类型的值进行二进制否运算，JavaScript 引擎会先调用 <code class="language-plaintext highlighter-rouge">Number</code> 函数，将其转为数值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于 ~Number('011')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">011</span><span class="dl">'</span>  <span class="c1">// -12</span>

<span class="c1">// 相当于 ~Number('42 cats')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number('0xcafebabe')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">0xcafebabe</span><span class="dl">'</span> <span class="c1">// 889275713</span>

<span class="c1">// 相当于 ~Number('deadbeef')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">deadbeef</span><span class="dl">'</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number([])</span>
<span class="o">~</span><span class="p">[]</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number(NaN)</span>
<span class="o">~</span><span class="kc">NaN</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number(null)</span>
<span class="o">~</span><span class="kc">null</span> <span class="c1">// -1</span>
</code></pre></div></div> <h3 id="45-异或运算符">4.5 异或运算符</h3> <p>异或运算（<code class="language-plaintext highlighter-rouge">^</code>）在两个二进制位不同时返回 <code class="language-plaintext highlighter-rouge">1</code>，相同时返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">^</span> <span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面表达式中，<code class="language-plaintext highlighter-rouge">0</code>（二进制 <code class="language-plaintext highlighter-rouge">00</code>）与 <code class="language-plaintext highlighter-rouge">3</code>（二进制 <code class="language-plaintext highlighter-rouge">11</code>）进行异或运算，它们每一个二进制位都不同，所以得到 <code class="language-plaintext highlighter-rouge">11</code>（即 <code class="language-plaintext highlighter-rouge">3</code>）。</p> <p>“异或运算”有一个特殊运用，连续对两个数 <code class="language-plaintext highlighter-rouge">a</code> 和 <code class="language-plaintext highlighter-rouge">b</code> 进行三次异或运算，<code class="language-plaintext highlighter-rouge">a^=b; b^=a; a^=b;</code>，可以<strong>互换</strong>它们的值。这意味着，<strong>“异或运算”可以在不引入临时变量的前提下，互换两个变量的值</strong>。这是互换两个变量的值的最快方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>

<span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">b</span> <span class="o">^=</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">;</span>

<span class="nx">a</span> <span class="c1">// 99</span>
<span class="nx">b</span> <span class="c1">// 10</span>
</code></pre></div></div> <p><strong>异或运算也可以用来取整</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">12.9</span> <span class="o">^</span> <span class="mi">0</span> <span class="c1">// 12</span>
</code></pre></div></div> <h3 id="46-左移运算符">4.6 左移运算符</h3> <p>左移运算符（<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>）表示将一个数的二进制值向左移动指定的位数，尾部补 <code class="language-plaintext highlighter-rouge">0</code>，即乘以 <code class="language-plaintext highlighter-rouge">2</code> 的指定次方。向左移动的时候，最高位的符号位是一起移动的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 4 的二进制形式为100，</span>
<span class="c1">// 左移一位为1000（即十进制的8）</span>
<span class="c1">// 相当于乘以2的1次方</span>
<span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1">// 8</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1">// -8</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">-4</code> 左移一位得到 <code class="language-plaintext highlighter-rouge">-8</code>，是因为 -4 的二进制形式是 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111100</code>，左移一位后得到 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111000</code>，该数转为十进制（减去 <code class="language-plaintext highlighter-rouge">1</code> 后取反，再加上负号）即为 <code class="language-plaintext highlighter-rouge">-8</code>。</p> <p><strong>如果左移 <code class="language-plaintext highlighter-rouge">0</code> 位，就相当于将该数值转为 32 位整数，等同于取整，对于正数和负数都有效</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">13.5</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="c1">// 13</span>

<span class="o">-</span><span class="mf">13.5</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="c1">// -13</span>
</code></pre></div></div> <p>左移运算符用于二进制数值非常方便。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">color</span> <span class="o">=</span> <span class="p">{</span><span class="na">r</span><span class="p">:</span> <span class="mi">186</span><span class="p">,</span> <span class="na">g</span><span class="p">:</span> <span class="mi">218</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">85</span><span class="p">};</span>

<span class="c1">// RGB to HEX</span>
<span class="c1">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span>
<span class="kd">var</span> <span class="nx">rgb2hex</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">r</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">g</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// 先转成十六进制，然后返回字符串</span>
    <span class="p">.</span><span class="nf">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">// 去除字符串的最高位，返回后面六个字符串</span>
<span class="p">}</span>

<span class="nf">rgb2hex</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">r</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
<span class="c1">// "#bada55"</span>
</code></pre></div></div> <p>上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。</p> <h3 id="47-右移运算符">4.7 右移运算符</h3> <p>右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补 <code class="language-plaintext highlighter-rouge">0</code>；如果是负数，头部全部补 <code class="language-plaintext highlighter-rouge">1</code>。右移运算符基本上相当于除以 <code class="language-plaintext highlighter-rouge">2</code> 的指定次方（最高位即符号位参与移动）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>
<span class="cm">/*
// 因为 4 的二进制形式为 00000000000000000000000000000100
// 右移一位得到 00000000000000000000000000000010
// 即为十进制的 2
*/</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// -2</span>
<span class="cm">/*
// 因为 -4 的二进制形式为 11111111111111111111111111111100
// 右移一位，头部补 1，得到 11111111111111111111111111111110
// 即为十进制的 -2
*/</span>
</code></pre></div></div> <p>右移运算可以模拟 2 的整除运算。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>
<span class="c1">// 相当于 5 / 2 = 2</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>
<span class="c1">// 5</span>
<span class="c1">// 相当于 21 / 4 = 5</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
<span class="c1">// 2</span>
<span class="c1">// 相当于 21 / 8 = 2</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
<span class="c1">// 1</span>
<span class="c1">// 相当于 21 / 16 = 1</span>
</code></pre></div></div> <h3 id="48-头部补零的右移运算符">4.8 头部补零的右移运算符</h3> <p>头部补零的右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>）与右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补 <code class="language-plaintext highlighter-rouge">0</code>，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）完全一致，区别主要在于负数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2147483646</span>
<span class="cm">/*
// 因为 -4 的二进制形式为11111111111111111111111111111100
// 带符号位的右移一位，得到 01111111111111111111111111111110
// 即为十进制的 2147483646
*/</span>
</code></pre></div></div> <p>这个运算实际上将一个值转为 32 位无符号整数。</p> <p><strong>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">0</span> <span class="c1">// 4294967295</span>
</code></pre></div></div> <p>上面代码表示，<code class="language-plaintext highlighter-rouge">-1</code> 作为 32 位整数时，内部的储存形式使用无符号整数格式解读，值为 <code class="language-plaintext highlighter-rouge">4294967295</code>（即 <code class="language-plaintext highlighter-rouge">(2^32)-1</code>，等于 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111111</code>）。</p> <h3 id="49-开关作用">4.9 开关作用</h3> <p>位运算符可以用作设置对象属性的<strong>开关</strong>。</p> <p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">FLAG_A</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 0001</span>
<span class="kd">var</span> <span class="nx">FLAG_B</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 0010</span>
<span class="kd">var</span> <span class="nx">FLAG_C</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 0100</span>
<span class="kd">var</span> <span class="nx">FLAG_D</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// 1000</span>
</code></pre></div></div> <p>上面代码设置 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">C</code>、<code class="language-plaintext highlighter-rouge">D</code> 四个开关，每个开关分别占有一个二进制位。</p> <ul> <li> <p>可以用二进制<strong>与</strong>运算，检查当前设置是否打开了指定开关。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">flags</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 二进制的0101</span>

<span class="k">if </span><span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">FLAG_C</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span>
</code></pre></div> </div> <p>上面代码检验是否打开了开关 <code class="language-plaintext highlighter-rouge">C</code>。如果打开，会返回 <code class="language-plaintext highlighter-rouge">true</code>，否则返回 <code class="language-plaintext highlighter-rouge">false</code>。</p> </li> <li> <p>现在假设需要打开 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">D</code> 三个开关，我们可以构造一个掩码变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mask</span> <span class="o">=</span> <span class="nx">FLAG_A</span> <span class="o">|</span> <span class="nx">FLAG_B</span> <span class="o">|</span> <span class="nx">FLAG_D</span><span class="p">;</span>
<span class="c1">// 0001 | 0010 | 1000 =&gt; 1011</span>
</code></pre></div> </div> <p>上面代码对 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">D</code> 三个变量进行二进制或运算，得到掩码值为二进制的 <code class="language-plaintext highlighter-rouge">1011</code>。</p> <p>有了掩码，二进制<strong>或</strong>运算可以确保打开指定的开关。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags | mask;
</code></pre></div> </div> <p>上面代码中，计算后得到的 <code class="language-plaintext highlighter-rouge">flags</code> 变量，代表三个开关的二进制位都打开了。</p> </li> <li> <p>二进制<strong>与</strong>运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags &amp; mask;
</code></pre></div> </div> </li> <li> <p>异或运算可以<strong>切换</strong>（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags ^ mask;
</code></pre></div> </div> </li> <li> <p>二进制<strong>否</strong>运算可以翻转当前设置，即原设置为 <code class="language-plaintext highlighter-rouge">0</code>，运算后变为 <code class="language-plaintext highlighter-rouge">1</code>；原设置为 <code class="language-plaintext highlighter-rouge">1</code>，运算后变为 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = ~flags;
</code></pre></div> </div> </li> </ul> <h2 id="五其他运算符运算顺序">五、其他运算符，运算顺序</h2> <h3 id="51-void-运算符">5.1 void 运算符</h3> <p><code class="language-plaintext highlighter-rouge">void</code> 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 <code class="language-plaintext highlighter-rouge">undefined</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="mi">0</span> <span class="c1">// undefined</span>
<span class="k">void</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// undefined</span>
</code></pre></div></div> <p>上面是 <code class="language-plaintext highlighter-rouge">void</code> 运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为 <code class="language-plaintext highlighter-rouge">void</code> 运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，<code class="language-plaintext highlighter-rouge">void 4 + 7</code> 实际上等同于 <code class="language-plaintext highlighter-rouge">(void 4) + 7</code>。</p> <p><code class="language-plaintext highlighter-rouge">void</code> 运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"javascript: void(document.form.submit())"</span><span class="nt">&gt;</span>
  提交
<span class="nt">&lt;/a&gt;</span>
</code></pre></div></div> <p>上面的代码中，用户点击链接提交表单，但是不产生页面跳转。</p> <h3 id="52-逗号运算符">5.2 逗号运算符</h3> <p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span> <span class="c1">// "b"</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="o">++</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 10</span>
</code></pre></div></div> <p>上面代码中，逗号运算符返回后一个表达式的值。</p> <p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hi!</span><span class="dl">'</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
<span class="c1">// Hi!</span>

<span class="nx">value</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，先执行逗号之前的操作，然后返回逗号后面的值。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/operators/">JavaScript 教程 - 运算符</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 运算符》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">webpack 构建流程</title><link href="https://feng-zhang0712.github.io//blog/2024/build-flow/" rel="alternate" type="text/html" title="webpack 构建流程"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/build-flow</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/build-flow/"><![CDATA[<p>webpack 的构建流程，主要包括初始化、编译、打包、优化和生成输出五个阶段。</p> <h3 id="41-初始化阶段">4.1 初始化阶段</h3> <p>在初始化阶段，webpack 根据配置文件和命令行参数进行初始化工作。包括以下步骤。</p> <ul> <li><strong>读取配置</strong>：读取 webpack 配置文件（<code class="language-plaintext highlighter-rouge">webpack.config.js</code>）并解析配置项。</li> <li><strong>注册插件</strong>：根据配置文件中的 <code class="language-plaintext highlighter-rouge">plugins</code> 项注册所有插件。</li> <li><strong>创建编译器对象</strong>：初始化 <code class="language-plaintext highlighter-rouge">Compiler</code> 对象，这是 webpack 构建的核心引擎，负责整个构建过程的协调工作。</li> <li><strong>应用插件</strong>：调用每个插件的 <code class="language-plaintext highlighter-rouge">apply</code> 方法，将插件挂载到 webpack 的钩子上。</li> <li><strong>触发环境钩子</strong>：触发 <code class="language-plaintext highlighter-rouge">environment</code> 和 <code class="language-plaintext highlighter-rouge">afterEnvironment</code> 等初始化阶段的钩子。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./webpack.config.js</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">webpack</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">webpack</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">compiler</span> <span class="o">=</span> <span class="nf">webpack</span><span class="p">(</span><span class="nx">config</span><span class="p">);</span>

<span class="nx">compiler</span><span class="p">.</span><span class="nf">run</span><span class="p">((</span><span class="nx">err</span><span class="p">,</span> <span class="nx">stats</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">stats</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></div></div> <p>初始化阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">initialize</code>：初始化 webpack。</li> <li><code class="language-plaintext highlighter-rouge">environment</code>：设置环境变量。</li> <li><code class="language-plaintext highlighter-rouge">afterEnvironment</code>：环境变量设置完成。</li> <li><code class="language-plaintext highlighter-rouge">entryOption</code>：处理入口选项。</li> </ul> <h3 id="42-编译阶段">4.2 编译阶段</h3> <p>编译阶段主要负责将源代码转换为 webpack 的模块化表示形式。</p> <ul> <li><strong>确定入口点</strong>：根据配置中的 <code class="language-plaintext highlighter-rouge">entry</code> 项确定入口模块。</li> <li><strong>递归解析模块</strong>：从入口点出发，递归解析依赖的模块。每个模块都会经过相应的 Loader 处理，转换为 webpack 能够理解的模块。</li> <li><strong>生成模块依赖图</strong>：构建模块与模块之间的依赖关系图。</li> </ul> <p>以下是编译阶段的详细流程。</p> <ol> <li><strong>创建 Compilation 对象</strong>：<code class="language-plaintext highlighter-rouge">Compiler</code> 对象会创建一个新的 <code class="language-plaintext highlighter-rouge">Compilation</code> 对象，用来存储当前编译的状态和结果。</li> <li><strong>触发 Compilation 钩子</strong>：触发 <code class="language-plaintext highlighter-rouge">thisCompilation</code> 和 <code class="language-plaintext highlighter-rouge">compilation</code> 钩子，通知插件开始编译。</li> <li><strong>构建模块</strong>： <ul> <li><strong>从入口开始</strong>：从入口模块开始，使用 <code class="language-plaintext highlighter-rouge">loader</code> 对模块进行转换。</li> <li><strong>递归解析</strong>：解析模块的依赖（如 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 语句）并递归处理依赖的模块。</li> <li><strong>生成抽象语法树（AST）</strong>：解析模块代码并生成 AST。</li> <li><strong>应用 Loader</strong>：按照配置的 <code class="language-plaintext highlighter-rouge">loader</code> 对模块进行处理。</li> <li><strong>添加模块到依赖图</strong>：将处理后的模块添加到依赖图中。</li> </ul> </li> </ol> <p>编译阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">beforeCompile</code>：编译开始前。</li> <li><code class="language-plaintext highlighter-rouge">compile</code>：编译阶段开始。</li> <li><code class="language-plaintext highlighter-rouge">thisCompilation</code>：新的 Compilation 创建前。</li> <li><code class="language-plaintext highlighter-rouge">compilation</code>：新的 Compilation 创建后。</li> </ul> <h3 id="43-打包阶段">4.3 打包阶段</h3> <p>打包阶段负责将编译后的模块根据依赖图进行打包，生成一个或多个 Chunk。</p> <ul> <li><strong>生成 Chunk</strong>：根据入口和依赖关系生成 Chunk，每个 Chunk 代表一个输出文件。</li> <li><strong>添加 Chunk 到 Compilation</strong>：将生成的 Chunk 添加到 <code class="language-plaintext highlighter-rouge">Compilation</code> 对象中。</li> </ul> <p>打包阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">make</code>：从入口点开始构建模块。</li> <li><code class="language-plaintext highlighter-rouge">afterCompile</code>：编译完成。</li> </ul> <h3 id="44-优化阶段">4.4 优化阶段</h3> <p>在优化阶段，webpack 会对生成的 Chunk 进行优化，如代码压缩、提取公共模块等。</p> <ul> <li><strong>代码拆分</strong>：提取公共模块、动态导入模块等。</li> <li><strong>压缩代码</strong>：根据配置对代码进行压缩和混淆。</li> <li><strong>其他优化</strong>：如 Tree Shaking、Scope Hoisting 等。</li> </ul> <h3 id="45-生成输出阶段">4.5 生成输出阶段</h3> <p>生成输出阶段负责将优化后的代码输出到指定的目录。</p> <ul> <li><strong>生成输出资源</strong>：根据 Chunk 生成最终的输出文件（如 JavaScript、CSS、HTML 等）。</li> <li><strong>写入文件系统</strong>：将生成的文件写入到输出目录（通常是 <code class="language-plaintext highlighter-rouge">dist</code> 目录）。</li> </ul> <p>以下是生成输出阶段的详细流程。</p> <ol> <li><strong>触发 <code class="language-plaintext highlighter-rouge">emit</code> 钩子</strong>：在写入文件前触发 <code class="language-plaintext highlighter-rouge">emit</code> 钩子，通知插件进行最后的修改或添加额外的文件。</li> <li><strong>写入文件到输出目录</strong>：将生成的文件写入到输出目录。</li> <li><strong>触发 <code class="language-plaintext highlighter-rouge">afterEmit</code> 钩子</strong>：写入文件后触发 <code class="language-plaintext highlighter-rouge">afterEmit</code> 钩子，通知插件输出过程已完成。</li> </ol> <p>生成输出阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">emit</code>：生成资源到输出目录前。</li> <li><code class="language-plaintext highlighter-rouge">afterEmit</code>：生成资源到输出目录后。</li> </ul> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 的构建流程，主要包括初始化、编译、打包、优化和生成输出五个阶段。]]></summary></entry><entry><title type="html">webpack 常用配置项</title><link href="https://feng-zhang0712.github.io//blog/2024/concepts/" rel="alternate" type="text/html" title="webpack 常用配置项"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/concepts</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/concepts/"><![CDATA[<p>webpack 是一个静态模块（比如各种资源文件）打包工具。webpack 会从一个或多个入口点构建依赖图(dependency graph)，然后将项目中所需的每个模块组合成一个或多个 bundles。</p> <h3 id="11-module">1.1 Module</h3> <p>Module（模块） 是 webpack 构建系统的基本单位。在 webpack 中，几乎所有的文件都被视为模块，包括 JavaScript、CSS、HTML、图片、字体等。模块是代码的最小单元，通过导入和导出实现代码的复用和分离。</p> <p>模块封装了特定功能，独立于其他模块。模块之间可以相互依赖，通过 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 引入其他模块。不仅限于 JavaScript 文件，任何资源文件都可以作为模块。</p> <h3 id="12-chunk">1.2 Chunk</h3> <p>Chunk（代码块） 是 webpack 在打包过程中生成的中间产物。每个 Chunk 包含一组紧密相关的模块。最终，一个或多个 Chunk 会被合并成一个 Bundle。</p> <p>Chunk 是 webpack 在打包过程中动态生成的。它使得代码拆分成为可能，可以根据不同的策略（如按需加载）生成多个 Chunk。Chunk 可以通过懒加载或动态导入的方式按需加载，以优化应用的加载性能。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/index.js</span>
<span class="k">import</span><span class="p">(</span><span class="cm">/* webpackChunkName: "moduleA" */</span> <span class="dl">'</span><span class="s1">./moduleA</span><span class="dl">'</span><span class="p">).</span><span class="nf">then</span><span class="p">(({</span> <span class="nx">greeting</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">greeting</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <h3 id="13-bundle">1.3 Bundle</h3> <p>Bundle（包） 是 webpack 打包后的输出文件，它包含了应用程序的所有模块代码。Bundle 是浏览器可以执行的最终文件，通常是一个或多个 JavaScript 文件。</p> <p>Bundle 是 webpack 打包的最终结果。在小型项目中，所有模块可能会被打包成一个单一的 Bundle 文件。在大型项目中，可以使用代码拆分（code splitting）将模块打包成多个 Bundle 文件，以优化加载性能。</p> <h3 id="14-webpack-中的占位符">1.4 webpack 中的占位符</h3> <ol> <li><strong><code class="language-plaintext highlighter-rouge">[name]</code></strong>：表示模块的名称。通常用于多入口配置中，根据入口名称生成文件名。</li> <li><strong><code class="language-plaintext highlighter-rouge">[id]</code></strong>：表示模块的 ID。用于生成文件名中的模块 ID，适用于需要唯一标识模块的场景。</li> <li><strong><code class="language-plaintext highlighter-rouge">[hash]</code></strong>：表示编译时的哈希值。常用于生成具有唯一性的文件名，防止缓存问题。</li> <li><strong><code class="language-plaintext highlighter-rouge">[chunkhash]</code></strong>：表示代码块的哈希值。用于根据代码块内容生成哈希值，适用于代码分割和缓存优化。</li> <li><strong><code class="language-plaintext highlighter-rouge">[contenthash]</code></strong>：表示文件内容的哈希值。适用于根据文件内容生成哈希值，通常用于生成 CSS 文件名。</li> <li><strong><code class="language-plaintext highlighter-rouge">[ext]</code></strong>：表示文件的扩展名。用于保持文件的原始扩展名，适用于文件处理和加载。</li> <li><strong><code class="language-plaintext highlighter-rouge">[path]</code></strong>：表示包含文件的路径。用于生成包含文件路径的文件名，适用于文件管理和组织。</li> <li><strong><code class="language-plaintext highlighter-rouge">[query]</code></strong>：表示文件请求中的查询字符串。用于生成包含查询字符串的文件名，适用于动态加载和参数传递。</li> </ol> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 是一个静态模块（比如各种资源文件）打包工具。webpack 会从一个或多个入口点构建依赖图(dependency graph)，然后将项目中所需的每个模块组合成一个或多个 bundles。]]></summary></entry></feed>