<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-08T15:53:20+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/operator/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-08T00:00:00+00:00</published><updated>2024-10-08T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/operator</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/operator/"><![CDATA[<p>本文是对<a href="https://wangdoc.com/javascript/operators/">《JavaScript 教程 - 运算符》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> <h2 id="一算术运算符">一、算术运算符</h2> <h3 id="11-概述">1.1 概述</h3> <p>JavaScript 共提供 10 个算术运算符，用来完成基本的算术运算。包括 <code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">**</code>（指数运算符）、<code class="language-plaintext highlighter-rouge">%</code>（余数运算符）、<code class="language-plaintext highlighter-rouge">++x</code>（或者 <code class="language-plaintext highlighter-rouge">x++</code>，即自增运算符）、<code class="language-plaintext highlighter-rouge">--x</code>（或者 <code class="language-plaintext highlighter-rouge">x--</code>，即）自减运算符、<code class="language-plaintext highlighter-rouge">+x</code>（数值运算符） 和 <code class="language-plaintext highlighter-rouge">-x</code>（负数值运算符）。</p> <h3 id="12-加法运算符">1.2 加法运算符</h3> <h4 id="基本规则">基本规则</h4> <p>相比于其他运算符，加法运算符（<code class="language-plaintext highlighter-rouge">+</code>）比较特殊，即可当作算数运算符，又可对字符串进行连接操作。</p> <p>只要有一个是运算子是字符串，进行的就是字符串的连接操作（此时，如果另一个运算子不是字符串，会被转为字符串）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// "1a"</span>
<span class="kc">false</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// "falsea"</span>
</code></pre></div></div> <p>加法运算符是在<strong>运行时</strong>决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“<strong>重载</strong>”（overload）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1">// "345"</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span> <span class="c1">// "75"</span>
</code></pre></div></div> <p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：<strong>所有运算子一律转为数值，再进行相应的数学运算</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">-</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">*</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// 2</span>
<span class="mi">1</span> <span class="o">/</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// 0.5</span>
</code></pre></div></div> <h4 id="对象的相加">对象的相加</h4> <p>如果运算子是对象，必须先转成原始类型的值，然后再相加。它的规则是：首先自动调用对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法，如果此时返回的是原始类型的值，则进行相应的操作，如果 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法得到的是对象类型，再自动调用对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法，将对象转为字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "[object Object]2"</span>
</code></pre></div></div> <p>上面代码中，对象 <code class="language-plaintext highlighter-rouge">obj</code> 转成原始类型的值是 <code class="language-plaintext highlighter-rouge">[object Object]</code>，再加 <code class="language-plaintext highlighter-rouge">2</code> 就得到了上面的结果。</p> <p>（1）首先，自动调用对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// { p: 1 }</span>
</code></pre></div></div> <p>（2）一般来说，对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法总是返回对象自身，这时再自动调用对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法，将其转为字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">().</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "[object Object]"</span>
</code></pre></div></div> <p>对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法默认返回 <code class="language-plaintext highlighter-rouge">[object Object]</code>，所以就得到了最前面那个例子的结果。</p> <p>注意，如果 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法返回的是原始类型的值，就不再调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法，否则会调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法，尝试将对象转为字符串。</p> <p>知道了这个规则以后，就可以自己定义 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法或 <code class="language-plaintext highlighter-rouge">toString</code> 方法，得到想要的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">valueOf</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，我们定义 <code class="language-plaintext highlighter-rouge">obj</code> 对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法返回 <code class="language-plaintext highlighter-rouge">1</code>，于是 <code class="language-plaintext highlighter-rouge">obj + 2</code> 就得到了 <code class="language-plaintext highlighter-rouge">3</code>。这个例子中，由于 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法直接返回一个原始类型的值，所以不再调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <p>下面是自定义 <code class="language-plaintext highlighter-rouge">toString</code> 方法的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">toString</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "hello2"</span>
</code></pre></div></div> <p>上面代码中，对象 obj 的 <code class="language-plaintext highlighter-rouge">toString</code> 方法返回字符串 <code class="language-plaintext highlighter-rouge">hello</code>。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。</p> <p>这里有一个特例，如果运算子是一个 <code class="language-plaintext highlighter-rouge">Date</code> 对象的实例，那么会优先执行 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "hello2"</span>
</code></pre></div></div> <p>上面代码中，对象 <code class="language-plaintext highlighter-rouge">obj</code> 是一个 <code class="language-plaintext highlighter-rouge">Date</code> 对象的实例，并且自定义了 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法和 <code class="language-plaintext highlighter-rouge">toString</code> 方法，结果 <code class="language-plaintext highlighter-rouge">toString</code> 方法优先执行。</p> <h3 id="13-余数运算符">1.3 余数运算符</h3> <p>对于余数运算符（<code class="language-plaintext highlighter-rouge">%</code>）来说，运算结果的正负号由第一个运算子的正负号决定。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="mi">1</span> <span class="o">%</span> <span class="mi">2</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">%</span> <span class="o">-</span><span class="mi">2</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>所以，为了得到负数的正确余数值，可以先使用绝对值函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 错误的写法</span>
<span class="kd">function</span> <span class="nf">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// 正确的写法</span>
<span class="kd">function</span> <span class="nf">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">6.5</span> <span class="o">%</span> <span class="mf">2.1</span>
<span class="c1">// 0.19999999999999973</span>
</code></pre></div></div> <h3 id="14-自增和自减运算符">1.4 自增和自减运算符</h3> <p>对于自增和自减运算符，运算之后，变量的值发生变化，这种效应叫做运算的<strong>副作用</strong>（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。</p> <p>自增和自减运算符放置的位置不同，会导致不同的行为。</p> <ul> <li>如果放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。</li> <li>如果放在变量之后，会先返回变量操作前的值，再进行自增/自减操作。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">x</span><span class="o">++</span> <span class="c1">// 1</span>
<span class="o">++</span><span class="nx">y</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">x</code> 是先返回当前值，然后自增，所以得到 <code class="language-plaintext highlighter-rouge">1</code>；<code class="language-plaintext highlighter-rouge">y</code> 是先自增，然后返回新的值，所以得到 <code class="language-plaintext highlighter-rouge">2</code>。</p> <h3 id="15-数值运算符负数值运算符">1.5 数值运算符，负数值运算符</h3> <p>数值运算符（<code class="language-plaintext highlighter-rouge">+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。</p> <p>数值运算符的作用在于可以将任何值转为数值（与 <code class="language-plaintext highlighter-rouge">Number</code> 函数的作用相同）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span><span class="kc">true</span> <span class="c1">// 1</span>
<span class="o">+</span><span class="p">[]</span> <span class="c1">// 0</span>
<span class="o">+</span><span class="p">{}</span> <span class="c1">// NaN</span>
</code></pre></div></div> <p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行 <code class="language-plaintext highlighter-rouge">NaN</code> 也是数值）。</p> <p>负数值运算符（<code class="language-plaintext highlighter-rouge">-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。</p> <h3 id="16-指数运算符">1.6 指数运算符</h3> <p>指数运算符（<code class="language-plaintext highlighter-rouge">**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="c1">// 16</span>
</code></pre></div></div> <p>注意，指数运算符是<strong>右结合</strong>。即多个指数运算符连用时，先进行最右边的计算。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于 2 ** (3 ** 2)</span>
<span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">**</span> <span class="mi">2</span>
<span class="c1">// 512</span>
</code></pre></div></div> <p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。</p> <h2 id="二比较运算符">二、比较运算符</h2> <h3 id="21-概述">2.1 概述</h3> <p>JavaScript 提供了 8 个比较运算符，他们是：<code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;=</code>、<code class="language-plaintext highlighter-rouge">&lt;=</code>、<code class="language-plaintext highlighter-rouge">==</code>、<code class="language-plaintext highlighter-rouge">===</code>、<code class="language-plaintext highlighter-rouge">!=</code> 和 <code class="language-plaintext highlighter-rouge">!==</code>。</p> <p>这八个比较运算符分成两类：相等比较和非相等比较。对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p> <h3 id="22-非相等运算符字符串的比较">2.2 非相等运算符：字符串的比较</h3> <p>字符串按照字典顺序进行比较。首先比较首字符的 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点。如果相等，再比较第二个字符的 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点，以此类推。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">dog</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">Cat</span><span class="dl">'</span> <span class="c1">// true' c 的 Unicode 码点是 99，C 的 Unicode 码点是 67</span>
<span class="dl">'</span><span class="s1">大</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">小</span><span class="dl">'</span> <span class="c1">// false “大”的 Unicode 码点是 22823，“小”是23567</span>
</code></pre></div></div> <h3 id="23-非相等运算符非字符串的比较">2.3 非相等运算符：非字符串的比较</h3> <p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。</p> <h4 id="1原始类型值">（1）原始类型值</h4> <p>如果两个运算子都是原始类型的值，则先转成数值再比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">4</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="c1">// 等同于 5 &gt; Number('4')</span>
<span class="c1">// 即 5 &gt; 4</span>

<span class="kc">true</span> <span class="o">&gt;</span> <span class="kc">false</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number(true) &gt; Number(false)</span>
<span class="c1">// 即 1 &gt; 0</span>

<span class="mi">2</span> <span class="o">&gt;</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 2 &gt; Number(true)</span>
<span class="c1">// 即 2 &gt; 1</span>
</code></pre></div></div> <p>任何值（包括 <code class="language-plaintext highlighter-rouge">NaN</code> 本身）与 <code class="language-plaintext highlighter-rouge">NaN</code> 使用非相等运算符进行比较，返回的都是 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="mi">1</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="2对象">（2）对象</h4> <p>如果运算子是对象，会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法；如果返回的还是对象，再接着调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">11</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; '11'</span>
<span class="c1">// 即 '2' &gt; '11'</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">11</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="c1">// 等同于 (function () { return '1' })() &gt; '11'</span>
<span class="c1">// 即 '1' &gt; '11'</span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span>
<span class="c1">// 即 '2' &gt; '1'</span>
</code></pre></div></div> <h3 id="24-严格相等运算符">2.4 严格相等运算符</h3> <ul> <li>相等运算符（<code class="language-plaintext highlighter-rouge">==</code>）比较两个值是否<strong>相等</strong>。如果两个值不是同一类型，相等运算符会将它们转换成同一个类型，再用严格相等运算符进行比较。</li> <li>严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）比较两个值是否为“<strong>同一个值</strong>”。如果两个值不是同一类型，严格相等运算符直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <p>对于严格相等运算符：</p> <ul> <li>如果两个值的类型不同，直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回 <code class="language-plaintext highlighter-rouge">true</code>，值不同就返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li>复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向<strong>同一个地址</strong>。</li> <li><code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 与自身严格相等。</li> </ul> <h3 id="25-严格不相等运算符">2.5 严格不相等运算符</h3> <p>严格不相等运算符（<code class="language-plaintext highlighter-rouge">!==</code>）先求严格相等运算符的结果，然后取相反值。</p> <h3 id="26-相等运算符">2.6 相等运算符</h3> <p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。比较不同类型的数据时，相等运算符会先将数据进行<strong>类型转换</strong>，然后再用严格相等运算符比较。</p> <ul> <li> <p>原始类型的值会转换成数值再进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 1 === Number(true)</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="c1">// 等同于 2 === Number(false)</span>

<span class="dl">'</span><span class="s1">true</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
<span class="c1">// 等同于 Number('true') === Number(true)</span>
<span class="c1">// 等同于 NaN === 1</span>

<span class="dl">''</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number('') === 0</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="dl">''</span> <span class="o">==</span> <span class="kc">false</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number('') === Number(false)</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number('1') === Number(true)</span>
<span class="c1">// 等同于 1 === 1</span>

<span class="dl">'</span><span class="se">\n</span><span class="s1">  123  </span><span class="se">\t</span><span class="dl">'</span> <span class="o">==</span> <span class="mi">123</span> <span class="c1">// true</span>
<span class="c1">// 因为字符串转为数字时，省略前置和后置的空格</span>
</code></pre></div> </div> </li> <li> <p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。先调用对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，得到字符串形式，再进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组与数值的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">// true</span>

<span class="c1">// 数组与字符串的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1,2</span><span class="dl">'</span> <span class="c1">// true</span>

<span class="c1">// 对象与布尔值的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 只有与自身比较，或者互相比较时，才会返回 <code class="language-plaintext highlighter-rouge">true</code>；与其他类型的值比较时，结果都为 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">undefined</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="c1">// true</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
<span class="kc">undefined</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
</code></pre></div> </div> </li> <li> <p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">==</span> <span class="dl">''</span>             <span class="c1">// true</span>
<span class="mi">0</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span>            <span class="c1">// true</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">true</span>           <span class="c1">// false</span>
<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span>          <span class="c1">// false</span>

<span class="kc">false</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">false</span><span class="dl">'</span>    <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span>        <span class="c1">// true</span>

<span class="kc">false</span> <span class="o">==</span> <span class="kc">undefined</span>  <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="kc">null</span>       <span class="c1">// false</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">undefined</span>   <span class="c1">// true</span>

<span class="dl">'</span><span class="s1"> </span><span class="se">\t\r\n</span><span class="s1"> </span><span class="dl">'</span> <span class="o">==</span> <span class="mi">0</span>     <span class="c1">// true</span>
</code></pre></div> </div> </li> </ul> <p>建议不要使用相等运算符（<code class="language-plaintext highlighter-rouge">==</code>），最好只使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）。</p> <h3 id="27-不相等运算符">2.7 不相等运算符</h3> <p>不相等运算符（<code class="language-plaintext highlighter-rouge">!=</code>）先求相等运算符的结果，然后取相反值。</p> <h2 id="三布尔运算符">三、布尔运算符</h2> <h3 id="31-概述">3.1 概述</h3> <p>布尔运算符用于将表达式转为布尔值，共包含四个运算符：<code class="language-plaintext highlighter-rouge">!</code>（取反运算符）、<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>（且运算符）、<code class="language-plaintext highlighter-rouge">||</code>（或运算符）和 <code class="language-plaintext highlighter-rouge">?:</code>（三元运算符）。</p> <h3 id="32-取反运算符">3.2 取反运算符（!）</h3> <ul> <li><code class="language-plaintext highlighter-rouge">undefined</code>、<code class="language-plaintext highlighter-rouge">null</code>、<code class="language-plaintext highlighter-rouge">false</code>、<code class="language-plaintext highlighter-rouge">0</code>、<code class="language-plaintext highlighter-rouge">NaN</code> 和空字符串（<code class="language-plaintext highlighter-rouge">''</code>）取反后为 <code class="language-plaintext highlighter-rouge">true</code>，其他值都为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li> <p>对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 <code class="language-plaintext highlighter-rouge">Boolean()</code> 函数的作用相同。这是一种常用的类型转换的写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!!</span><span class="nx">x</span>
<span class="c1">// 等同于</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> <h3 id="33-且运算符">3.3 且运算符（&amp;&amp;）</h3> <p>且运算符（<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>）的运算规则是：如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>，则返回第二个运算子的<strong>值</strong>（注意是值，不是布尔值）；如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">false</code>，则直接返回第一个运算子的<strong>值</strong>，且不再对第二个运算子求值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">''</span> <span class="c1">// ""</span>
<span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "f"</span>
<span class="dl">''</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// ""</span>
</code></pre></div></div> <p>这种跳过第二个运算子的机制，被称为“<strong>短路</strong>”。有时候可以用它取代 if 结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 等价于</span>
<span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nf">doSomething</span><span class="p">();</span>
</code></pre></div></div> <p>且运算符可以多个连用，这时返回第一个布尔值为 <code class="language-plaintext highlighter-rouge">false</code> 的表达式的值。如果所有表达式的布尔值都为 <code class="language-plaintext highlighter-rouge">true</code>，则返回最后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">''</span> <span class="o">&amp;&amp;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
<span class="c1">// ''</span>

<span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="mi">3</span>
<span class="c1">// 3</span>
</code></pre></div></div> <h3 id="34-或运算符">3.4 或运算符（||）</h3> <p>或运算符（<code class="language-plaintext highlighter-rouge">||</code>）的运算规则是：如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>，则返回第一个运算子的<strong>值</strong>，且不再对第二个运算子求值；如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">false</code>，则返回第二个运算子的<strong>值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">||</span> <span class="dl">''</span> <span class="c1">// "t"</span>
<span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "t"</span>
<span class="dl">''</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "f"</span>
<span class="dl">''</span> <span class="o">||</span> <span class="dl">''</span> <span class="c1">// ""</span>
</code></pre></div></div> <p>或运算符可以多个连用，这时返回第一个布尔值为 <code class="language-plaintext highlighter-rouge">true</code> 的表达式的值。如果所有表达式都为 <code class="language-plaintext highlighter-rouge">false</code>，则返回最后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="dl">''</span> <span class="o">||</span> <span class="mi">4</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">||</span> <span class="kc">true</span>
<span class="c1">// 4</span>

<span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="dl">''</span>
<span class="c1">// ''</span>
</code></pre></div></div> <h2 id="四二进制位运算符">四、二进制位运算符</h2> <h2 id="五其他运算符运算顺序">五、其他运算符，运算顺序</h2>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 运算符》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">webpack 构建流程</title><link href="https://feng-zhang0712.github.io//blog/2024/build-flow/" rel="alternate" type="text/html" title="webpack 构建流程"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/build-flow</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/build-flow/"><![CDATA[<p>webpack 的构建流程，主要包括初始化、编译、打包、优化和生成输出五个阶段。</p> <h3 id="41-初始化阶段">4.1 初始化阶段</h3> <p>在初始化阶段，webpack 根据配置文件和命令行参数进行初始化工作。包括以下步骤。</p> <ul> <li><strong>读取配置</strong>：读取 webpack 配置文件（<code class="language-plaintext highlighter-rouge">webpack.config.js</code>）并解析配置项。</li> <li><strong>注册插件</strong>：根据配置文件中的 <code class="language-plaintext highlighter-rouge">plugins</code> 项注册所有插件。</li> <li><strong>创建编译器对象</strong>：初始化 <code class="language-plaintext highlighter-rouge">Compiler</code> 对象，这是 webpack 构建的核心引擎，负责整个构建过程的协调工作。</li> <li><strong>应用插件</strong>：调用每个插件的 <code class="language-plaintext highlighter-rouge">apply</code> 方法，将插件挂载到 webpack 的钩子上。</li> <li><strong>触发环境钩子</strong>：触发 <code class="language-plaintext highlighter-rouge">environment</code> 和 <code class="language-plaintext highlighter-rouge">afterEnvironment</code> 等初始化阶段的钩子。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./webpack.config.js</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">webpack</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">webpack</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">compiler</span> <span class="o">=</span> <span class="nf">webpack</span><span class="p">(</span><span class="nx">config</span><span class="p">);</span>

<span class="nx">compiler</span><span class="p">.</span><span class="nf">run</span><span class="p">((</span><span class="nx">err</span><span class="p">,</span> <span class="nx">stats</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">stats</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></div></div> <p>初始化阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">initialize</code>：初始化 webpack。</li> <li><code class="language-plaintext highlighter-rouge">environment</code>：设置环境变量。</li> <li><code class="language-plaintext highlighter-rouge">afterEnvironment</code>：环境变量设置完成。</li> <li><code class="language-plaintext highlighter-rouge">entryOption</code>：处理入口选项。</li> </ul> <h3 id="42-编译阶段">4.2 编译阶段</h3> <p>编译阶段主要负责将源代码转换为 webpack 的模块化表示形式。</p> <ul> <li><strong>确定入口点</strong>：根据配置中的 <code class="language-plaintext highlighter-rouge">entry</code> 项确定入口模块。</li> <li><strong>递归解析模块</strong>：从入口点出发，递归解析依赖的模块。每个模块都会经过相应的 Loader 处理，转换为 webpack 能够理解的模块。</li> <li><strong>生成模块依赖图</strong>：构建模块与模块之间的依赖关系图。</li> </ul> <p>以下是编译阶段的详细流程。</p> <ol> <li><strong>创建 Compilation 对象</strong>：<code class="language-plaintext highlighter-rouge">Compiler</code> 对象会创建一个新的 <code class="language-plaintext highlighter-rouge">Compilation</code> 对象，用来存储当前编译的状态和结果。</li> <li><strong>触发 Compilation 钩子</strong>：触发 <code class="language-plaintext highlighter-rouge">thisCompilation</code> 和 <code class="language-plaintext highlighter-rouge">compilation</code> 钩子，通知插件开始编译。</li> <li><strong>构建模块</strong>： <ul> <li><strong>从入口开始</strong>：从入口模块开始，使用 <code class="language-plaintext highlighter-rouge">loader</code> 对模块进行转换。</li> <li><strong>递归解析</strong>：解析模块的依赖（如 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 语句）并递归处理依赖的模块。</li> <li><strong>生成抽象语法树（AST）</strong>：解析模块代码并生成 AST。</li> <li><strong>应用 Loader</strong>：按照配置的 <code class="language-plaintext highlighter-rouge">loader</code> 对模块进行处理。</li> <li><strong>添加模块到依赖图</strong>：将处理后的模块添加到依赖图中。</li> </ul> </li> </ol> <p>编译阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">beforeCompile</code>：编译开始前。</li> <li><code class="language-plaintext highlighter-rouge">compile</code>：编译阶段开始。</li> <li><code class="language-plaintext highlighter-rouge">thisCompilation</code>：新的 Compilation 创建前。</li> <li><code class="language-plaintext highlighter-rouge">compilation</code>：新的 Compilation 创建后。</li> </ul> <h3 id="43-打包阶段">4.3 打包阶段</h3> <p>打包阶段负责将编译后的模块根据依赖图进行打包，生成一个或多个 Chunk。</p> <ul> <li><strong>生成 Chunk</strong>：根据入口和依赖关系生成 Chunk，每个 Chunk 代表一个输出文件。</li> <li><strong>添加 Chunk 到 Compilation</strong>：将生成的 Chunk 添加到 <code class="language-plaintext highlighter-rouge">Compilation</code> 对象中。</li> </ul> <p>打包阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">make</code>：从入口点开始构建模块。</li> <li><code class="language-plaintext highlighter-rouge">afterCompile</code>：编译完成。</li> </ul> <h3 id="44-优化阶段">4.4 优化阶段</h3> <p>在优化阶段，webpack 会对生成的 Chunk 进行优化，如代码压缩、提取公共模块等。</p> <ul> <li><strong>代码拆分</strong>：提取公共模块、动态导入模块等。</li> <li><strong>压缩代码</strong>：根据配置对代码进行压缩和混淆。</li> <li><strong>其他优化</strong>：如 Tree Shaking、Scope Hoisting 等。</li> </ul> <h3 id="45-生成输出阶段">4.5 生成输出阶段</h3> <p>生成输出阶段负责将优化后的代码输出到指定的目录。</p> <ul> <li><strong>生成输出资源</strong>：根据 Chunk 生成最终的输出文件（如 JavaScript、CSS、HTML 等）。</li> <li><strong>写入文件系统</strong>：将生成的文件写入到输出目录（通常是 <code class="language-plaintext highlighter-rouge">dist</code> 目录）。</li> </ul> <p>以下是生成输出阶段的详细流程。</p> <ol> <li><strong>触发 <code class="language-plaintext highlighter-rouge">emit</code> 钩子</strong>：在写入文件前触发 <code class="language-plaintext highlighter-rouge">emit</code> 钩子，通知插件进行最后的修改或添加额外的文件。</li> <li><strong>写入文件到输出目录</strong>：将生成的文件写入到输出目录。</li> <li><strong>触发 <code class="language-plaintext highlighter-rouge">afterEmit</code> 钩子</strong>：写入文件后触发 <code class="language-plaintext highlighter-rouge">afterEmit</code> 钩子，通知插件输出过程已完成。</li> </ol> <p>生成输出阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">emit</code>：生成资源到输出目录前。</li> <li><code class="language-plaintext highlighter-rouge">afterEmit</code>：生成资源到输出目录后。</li> </ul> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 的构建流程，主要包括初始化、编译、打包、优化和生成输出五个阶段。]]></summary></entry><entry><title type="html">webpack 常用配置项</title><link href="https://feng-zhang0712.github.io//blog/2024/concepts/" rel="alternate" type="text/html" title="webpack 常用配置项"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/concepts</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/concepts/"><![CDATA[<p>webpack 是一个静态模块（比如各种资源文件）打包工具。webpack 会从一个或多个入口点构建依赖图(dependency graph)，然后将项目中所需的每个模块组合成一个或多个 bundles。</p> <h3 id="11-module">1.1 Module</h3> <p>Module（模块） 是 webpack 构建系统的基本单位。在 webpack 中，几乎所有的文件都被视为模块，包括 JavaScript、CSS、HTML、图片、字体等。模块是代码的最小单元，通过导入和导出实现代码的复用和分离。</p> <p>模块封装了特定功能，独立于其他模块。模块之间可以相互依赖，通过 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 引入其他模块。不仅限于 JavaScript 文件，任何资源文件都可以作为模块。</p> <h3 id="12-chunk">1.2 Chunk</h3> <p>Chunk（代码块） 是 webpack 在打包过程中生成的中间产物。每个 Chunk 包含一组紧密相关的模块。最终，一个或多个 Chunk 会被合并成一个 Bundle。</p> <p>Chunk 是 webpack 在打包过程中动态生成的。它使得代码拆分成为可能，可以根据不同的策略（如按需加载）生成多个 Chunk。Chunk 可以通过懒加载或动态导入的方式按需加载，以优化应用的加载性能。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/index.js</span>
<span class="k">import</span><span class="p">(</span><span class="cm">/* webpackChunkName: "moduleA" */</span> <span class="dl">'</span><span class="s1">./moduleA</span><span class="dl">'</span><span class="p">).</span><span class="nf">then</span><span class="p">(({</span> <span class="nx">greeting</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">greeting</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <h3 id="13-bundle">1.3 Bundle</h3> <p>Bundle（包） 是 webpack 打包后的输出文件，它包含了应用程序的所有模块代码。Bundle 是浏览器可以执行的最终文件，通常是一个或多个 JavaScript 文件。</p> <p>Bundle 是 webpack 打包的最终结果。在小型项目中，所有模块可能会被打包成一个单一的 Bundle 文件。在大型项目中，可以使用代码拆分（code splitting）将模块打包成多个 Bundle 文件，以优化加载性能。</p> <h3 id="14-webpack-中的占位符">1.4 webpack 中的占位符</h3> <ol> <li><strong><code class="language-plaintext highlighter-rouge">[name]</code></strong>：表示模块的名称。通常用于多入口配置中，根据入口名称生成文件名。</li> <li><strong><code class="language-plaintext highlighter-rouge">[id]</code></strong>：表示模块的 ID。用于生成文件名中的模块 ID，适用于需要唯一标识模块的场景。</li> <li><strong><code class="language-plaintext highlighter-rouge">[hash]</code></strong>：表示编译时的哈希值。常用于生成具有唯一性的文件名，防止缓存问题。</li> <li><strong><code class="language-plaintext highlighter-rouge">[chunkhash]</code></strong>：表示代码块的哈希值。用于根据代码块内容生成哈希值，适用于代码分割和缓存优化。</li> <li><strong><code class="language-plaintext highlighter-rouge">[contenthash]</code></strong>：表示文件内容的哈希值。适用于根据文件内容生成哈希值，通常用于生成 CSS 文件名。</li> <li><strong><code class="language-plaintext highlighter-rouge">[ext]</code></strong>：表示文件的扩展名。用于保持文件的原始扩展名，适用于文件处理和加载。</li> <li><strong><code class="language-plaintext highlighter-rouge">[path]</code></strong>：表示包含文件的路径。用于生成包含文件路径的文件名，适用于文件管理和组织。</li> <li><strong><code class="language-plaintext highlighter-rouge">[query]</code></strong>：表示文件请求中的查询字符串。用于生成包含查询字符串的文件名，适用于动态加载和参数传递。</li> </ol> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 是一个静态模块（比如各种资源文件）打包工具。webpack 会从一个或多个入口点构建依赖图(dependency graph)，然后将项目中所需的每个模块组合成一个或多个 bundles。]]></summary></entry><entry><title type="html">webpack 常用配置项</title><link href="https://feng-zhang0712.github.io//blog/2024/configuration/" rel="alternate" type="text/html" title="webpack 常用配置项"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/configuration</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/configuration/"><![CDATA[<h3 id="21-entry">2.1 Entry</h3> <p><code class="language-plaintext highlighter-rouge">entry</code> 指定 webpack 构建的入口。webpack 会从入口文件开始构建依赖图。在书写形式上，分为单入口、多入口和数组入口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 单入口文件写法</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/index.js</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 多个入口文件写法，它们将分别生成各自的打包文件</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">app</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/app.js</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">admin</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/admin.js</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 数组入口文件写法，表示多个入口文件将被打包到一个文件中</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">./src/index.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">./src/vendor.js</span><span class="dl">'</span><span class="p">],</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="22-output">2.2 Output</h3> <p><code class="language-plaintext highlighter-rouge">output</code> 指定打包文件的输出位置和文件名。</p> <h3 id="23-module">2.3 Module</h3> <p><code class="language-plaintext highlighter-rouge">module</code> 定义处理不同类型文件模块的规则。即如何处理除 <code class="language-plaintext highlighter-rouge">.js</code> 文件以外的其他资源，例如 CSS、图片、字体等。<code class="language-plaintext highlighter-rouge">module</code> 配置项主要包含 <code class="language-plaintext highlighter-rouge">rules</code> 和 <code class="language-plaintext highlighter-rouge">noParse</code> 两个属性。</p> <h4 id="1-modulerules">(1) <code class="language-plaintext highlighter-rouge">module.rules</code></h4> <p><code class="language-plaintext highlighter-rouge">module.rules</code> 属性是 <code class="language-plaintext highlighter-rouge">module</code> 配置项的核心部分，它是一个数组，每个元素都是一个规则对象，用于定义如何使用 Loader 加载和转换不同类型的模块。<code class="language-plaintext highlighter-rouge">module.rules</code> 对象的主要属性如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">test</code>：一个正则表达式，用于匹配文件路径。</li> <li><code class="language-plaintext highlighter-rouge">exclude</code>：排除的文件路径，通常用于排除 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录。</li> <li><code class="language-plaintext highlighter-rouge">include</code>：包含的文件路径，通常用于指定处理哪些目录下的文件。</li> <li><code class="language-plaintext highlighter-rouge">use</code>：指定使用的加载器（详细方式），可以是单个加载器或加载器数组。</li> <li><code class="language-plaintext highlighter-rouge">loader</code>：指定使用的加载器（简写方式）。</li> <li><code class="language-plaintext highlighter-rouge">options</code>：加载器的选项参数。</li> <li><code class="language-plaintext highlighter-rouge">type</code>：指定模块的类型，例如 <code class="language-plaintext highlighter-rouge">json</code> 等。</li> </ul> <p>以下是一个 <code class="language-plaintext highlighter-rouge">module.rules</code> 配置项的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">png|jpg|gif</span><span class="se">)</span><span class="sr">$/</span><span class="p">,</span> <span class="c1">// 匹配图片文件</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 保持文件名和扩展名</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">images/</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 输出路径</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">woff|woff2|eot|ttf|otf</span><span class="se">)</span><span class="sr">$/</span><span class="p">,</span> <span class="c1">// 匹配字体文件</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 保持文件名和扩展名</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">fonts/</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 输出路径</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>Loader 本质上是一个函数，主要用于在 webpack 构建过程中，将不同类型的文件转换为模块。Loader 可以处理 JavaScript 以外的资源文件，例如 CSS、SCSS、TypeScript、图片等。它们允许你在 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 模块时预处理文件。以下是一些 webpack 中常见的 Loader。</p> <ul> <li><code class="language-plaintext highlighter-rouge">babel-loader</code>：用于将最新的 ES 语法转换为浏览器是别的 JavaScript。</li> <li><code class="language-plaintext highlighter-rouge">style-loader</code>：将 css 添加到样式标签 <code class="language-plaintext highlighter-rouge">style</code> 中。</li> <li><code class="language-plaintext highlighter-rouge">css-loader</code>：允许将 css 文件通过 require 的方式引入，并返回 css 代码。</li> <li><code class="language-plaintext highlighter-rouge">sass-loader:</code>：处理 sass 文件。</li> <li><code class="language-plaintext highlighter-rouge">postcss-loader</code>：用 postcss 来处理 CSS。</li> <li><code class="language-plaintext highlighter-rouge">file-loader</code>：分发文件到 output 目录并返回相对路径。</li> <li><code class="language-plaintext highlighter-rouge">url-loader</code>：和 <code class="language-plaintext highlighter-rouge">file-loader</code> 类似，可以选择性的把图片转成 base64 格式的字符串，并打包到 js 中，比较合适对小图片的处理。</li> <li><code class="language-plaintext highlighter-rouge">html-minify-loader</code>：压缩 HTML。</li> </ul> <p>注意，大部分 Loader 在使用之前要先下载。</p> <h4 id="2modulenoparse">（2）<code class="language-plaintext highlighter-rouge">module.noParse</code></h4> <p><code class="language-plaintext highlighter-rouge">module.noParse</code> 用于配置哪些模块文件不需要解析。通过 <code class="language-plaintext highlighter-rouge">noParse</code>，可以跳过对大型库或文件的解析。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">noParse</span><span class="p">:</span> <span class="sr">/jquery|lodash/</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，告诉 webpack 在进行代码解析式，不解析 <code class="language-plaintext highlighter-rouge">jquery</code> 和 <code class="language-plaintext highlighter-rouge">lodash</code> 库。</p> <h3 id="24-plugins">2.4 Plugins</h3> <p>Plugin 用于扩展 webpack 的功能。它们可以在整个编译生命周期的不同阶段执行更广泛的任务，如 <strong>打包优化</strong>、<strong>环境变量注入</strong>、<strong>代码压缩</strong> 等。Plugin 可以比 Loader 处理更加复杂和多样化的任务。</p> <p>Plugin 是具有 <code class="language-plaintext highlighter-rouge">apply</code> 方法的 JavaScript 对象。这个 <code class="language-plaintext highlighter-rouge">apply</code> 方法在 webpack 启动时被调用，并且插件可以通过 webpack 的钩子机制（hooks）在编译过程的各个阶段插入自己的逻辑。</p> <p>以下是一些 webpack 中常见的 Plugin。</p> <ul> <li><code class="language-plaintext highlighter-rouge">DefinePlugin</code>：允许在编译时创建配置的全局对象，它是一个 webpack 内置的插件，不需要安装。</li> <li><code class="language-plaintext highlighter-rouge">html-webpack-plugin</code>：用于简化 HTML 文件的创建、管理以及注入打包后的 JavaScript 文件。</li> <li><code class="language-plaintext highlighter-rouge">mini-css-extract-plugin</code>：将 CSS 从 JavaScript 中提取出来，生成独立的 CSS 文件。</li> <li><code class="language-plaintext highlighter-rouge">css-minimizer-webpack-plugin</code></li> <li><code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code></li> </ul> <h3 id="25-mode">2.5 Mode</h3> <p><code class="language-plaintext highlighter-rouge">mode</code> 用于设置构建模式，影响 webpack 内置的优化功能。webpack 提供了三种模式。</p> <ul> <li><code class="language-plaintext highlighter-rouge">development</code>：用于开发环境。在这个模式下， 主要侧重于提升构建速度和开发体验。在此模式下， webpack 不会压缩代码，并且会启用 Source Map、HMR（热模块替换）和详细的日志。</li> <li><code class="language-plaintext highlighter-rouge">production</code>：用于生产环境。在这个模式下， 主要侧重于优化代码体积和运行性能。在此模式下， webpack 会启用代码压缩和混淆、自动移除未使用的代码（Tree Shaking）和启用各种优化（如代码拆分、作用域提升）等。</li> <li><code class="language-plaintext highlighter-rouge">none</code>：不应用任何默认优化或配置。在这个模式下，只会按照配置文件中的指示进行打包，而不进行额外的优化和处理。</li> </ul> <h3 id="26-resolve">2.6 Resolve</h3> <p><code class="language-plaintext highlighter-rouge">resolve</code> 控制模块解析的行为。包括定义模块路径的查找方式、文件扩展名的解析顺序、别名等。<code class="language-plaintext highlighter-rouge">resolve</code> 的主要配置项如下。</p> <h4 id="1resolvealias">（1）<code class="language-plaintext highlighter-rouge">resolve.alias</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.alias</code> 用于为模块路径创建别名。通过别名，可以简化模块引用的路径。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">alias</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">@components</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/components/</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">import</span> <span class="nx">Button</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@components/Button</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p>上面的代码中，我们为 <code class="language-plaintext highlighter-rouge">src/components/</code> 目录指定了一个别名 <code class="language-plaintext highlighter-rouge">@components</code>，这样在导入模块时，就可以使用 <code class="language-plaintext highlighter-rouge">import xxx from '@components/xxx'</code> 的形式，而不必每次都写前边的路径。</p> <h4 id="2resolveextensions">（2）<code class="language-plaintext highlighter-rouge">resolve.extensions</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.extensions</code> 定义在解析模块时可以省略的文件扩展名。默认值是 <code class="language-plaintext highlighter-rouge">['.js', '.json']</code>。</p> <h4 id="3resolvemodules">（3）<code class="language-plaintext highlighter-rouge">resolve.modules</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.modules</code> 指定解析模块时要搜索的目录。默认值是 [‘node_modules’]。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">modules</span><span class="p">:</span> <span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">import</span> <span class="nx">Util</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">utils/util</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 实际引入的是 'src/utils/util.js'</span>
</code></pre></div></div> <p>上面的代码，我们指定了 <code class="language-plaintext highlighter-rouge">resolve.modules</code> 的目录为 <code class="language-plaintext highlighter-rouge">src</code> 和 <code class="language-plaintext highlighter-rouge">node_modules</code>。这样，在导入模块时，webpack 会首先去 <code class="language-plaintext highlighter-rouge">src</code> 目录下寻找，如果找不到，就去 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录下寻找。</p> <h4 id="4resolvefallback">（4）<code class="language-plaintext highlighter-rouge">resolve.fallback</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.fallback</code> 指定当模块在指定目录中找不到时，应该回退到哪个目录进行查找。常用于处理某些模块在特定环境下的缺失问题。</p> <h4 id="5resolveplugins">（5）<code class="language-plaintext highlighter-rouge">resolve.plugins</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.plugins</code> 用于配置一些自定义的解析插件。可以定义自己的解析规则或使用现成的解析插件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">alias</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">@components</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/components/</span><span class="dl">'</span><span class="p">),</span>
      <span class="dl">'</span><span class="s1">@utils</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/utils/</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
    <span class="na">extensions</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.jsx</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.json</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.ts</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.tsx</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">modules</span><span class="p">:</span> <span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">fallback</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">:</span> <span class="nx">require</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">path-browserify</span><span class="dl">'</span><span class="p">),</span>
      <span class="dl">'</span><span class="s1">crypto</span><span class="dl">'</span><span class="p">:</span> <span class="nx">require</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">crypto-browserify</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
     <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
      <span class="c1">// 在此添加解析插件</span>
    <span class="p">],</span>

    <span class="c1">// 其他配置...</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="27-devtool">2.7 Devtool</h3> <p><code class="language-plaintext highlighter-rouge">devtool</code> 用于控制生成 source map 的方式。source map 用于将编译后的代码映射回源代码，有助于调试和错误追踪。常见的 <code class="language-plaintext highlighter-rouge">devtool</code> 配置有如下几个。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">cheap-module-source-map</code></strong>：类似于 cheap-source-map，对 loader 处理后的代码也生成 source map。优点是构建速度较快，适合调试经过 loader 处理的代码。缺点是调试时无法准确定位到列，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">source-map</code></strong>：生成独立的 <code class="language-plaintext highlighter-rouge">.map</code> 文件，提供完整的 source map。优点是可以查看源文件及其位置。缺点是构建速度慢，适合生产环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">eval</code></strong>：使用 <code class="language-plaintext highlighter-rouge">eval</code> 生成每个模块的 source map。优点是构建速度最快，缺点是生成的 source map 不支持断点调试，适合快速开发和调试。</li> <li><strong><code class="language-plaintext highlighter-rouge">inline-source-map</code></strong>：将 source map 作为 Data URL 内嵌在编译后的代码中。优点是调试体验好，构建速度较快。缺点是会增加文件体积，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">cheap-source-map</code></strong>：生成独立的 source map 文件，但不包含列信息。优点是构建速度较快，适合开发环境。缺点是调试时无法准确定位到列，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">eval-source-map</code></strong>：每个模块使用 eval 生成 source map，并将 source map 作为 Data URL 内嵌。优点是构建速度快，调试体验好。适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">hidden-source-map</code></strong>：生成独立的 source map 文件，但不在编译后的代码中引用。优点是保护源代码，但仍然可以使用 source map 进行调试。缺点是需要手动关联 source map 文件，适合生产环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">nosources-source-map</code></strong>：生成独立的 source map 文件，但隐藏源文件内容。优点是保护源代码内容，但提供错误信息的映射。缺点是不能查看源代码，适合生产环境。</li> </ul> <p>多数情况下，在开发中主要使用 <code class="language-plaintext highlighter-rouge">cheap-module-source-map</code>；而在生产环境中，主要使用 <code class="language-plaintext highlighter-rouge">source-map</code>。</p> <h3 id="28-devserver">2.8 DevServer</h3> <p><code class="language-plaintext highlighter-rouge">devServer</code> 用于配置开发服务器。即设置开发环境中的本地服务器，以便进行实时预览、热模块替换（HMR）、代理请求等操作。<code class="language-plaintext highlighter-rouge">devServer</code> 常见的配置项如下。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">contentBase</code></strong>：指定开发服务器的根目录，即服务器将从哪个目录提供文件。</li> <li><strong><code class="language-plaintext highlighter-rouge">https</code></strong>：是否启用 HTTPS 协议。</li> <li><strong><code class="language-plaintext highlighter-rouge">host</code></strong>：指定开发服务器的主机名。</li> <li><strong><code class="language-plaintext highlighter-rouge">port</code></strong>：指定开发服务器的端口号。</li> <li><strong><code class="language-plaintext highlighter-rouge">open</code></strong>：是否自动打开浏览器。</li> <li><strong><code class="language-plaintext highlighter-rouge">hot</code></strong>：是否启用模块热替换（HMR）。</li> <li><strong><code class="language-plaintext highlighter-rouge">proxy</code></strong>：配置代理，将特定请求转发到其他服务器。</li> <li><strong><code class="language-plaintext highlighter-rouge">compress</code></strong>：是否启用 gzip 压缩。</li> <li><strong><code class="language-plaintext highlighter-rouge">before</code></strong> 和 <strong><code class="language-plaintext highlighter-rouge">after</code></strong>：在开发服务器启动之前或之后执行特定的中间件函数。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">devServer</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">contentBase</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">dist</span><span class="dl">'</span><span class="p">),</span> <span class="c1">// 指定根目录</span>
    <span class="na">https</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">// 使用 HTTP 协议</span>
    <span class="na">host</span><span class="p">:</span> <span class="dl">'</span><span class="s1">0.0.0.0</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 指定主机名</span>
    <span class="na">port</span><span class="p">:</span> <span class="mi">3000</span><span class="p">,</span> <span class="c1">// 指定端口号</span>
    <span class="na">open</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 自动打开浏览器</span>
    <span class="na">hot</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用模块热替换</span>
    <span class="na">proxy</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">/api</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">target</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http://localhost:3000</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">changeOrigin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">},</span>
    <span class="na">compress</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用 gzip 压缩</span>
    <span class="na">before</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">server</span><span class="p">,</span> <span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/some/path</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">({</span> <span class="na">custom</span><span class="p">:</span> <span class="dl">'</span><span class="s1">response</span><span class="dl">'</span> <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">},</span>
    <span class="na">after</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">server</span><span class="p">,</span> <span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Dev server is running!</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="c1">// 其他配置项...</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="29-optimization">2.9 Optimization</h3> <p><code class="language-plaintext highlighter-rouge">optimization</code> 控制构建过程中的优化行为。以下是常见的 <code class="language-plaintext highlighter-rouge">optimization</code> 配置项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">splitChunks</code></strong>：用于将代码拆分成更小的块，以实现代码的按需加载和更好的缓存策略。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimize</code></strong>：是否启用代码压缩。一般在生产环境中使用。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimizer</code></strong>：自定义代码压缩工具和压缩选项。默认使用 TerserPlugin 进行 JavaScript 代码压缩。</li> <li><strong><code class="language-plaintext highlighter-rouge">providedExports</code></strong>：用于告诉 webpack 是否分析每个模块提供的导出内容。默认值为 true。</li> <li><strong><code class="language-plaintext highlighter-rouge">usedExports</code></strong>：用于启用 Tree Shaking，去除未使用的导出。默认值为 true。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TerserPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">terser-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">splitChunks</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 对所有类型的代码进行分离</span>
    <span class="p">},</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用代码压缩</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span><span class="k">new</span> <span class="nc">TerserPlugin</span><span class="p">({</span>
      <span class="na">terserOptions</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">compress</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">drop_console</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除 console 语句</span>
        <span class="p">},</span>
      <span class="p">},</span>
    <span class="p">})],</span>
    <span class="na">runtimeChunk</span><span class="p">:</span> <span class="dl">'</span><span class="s1">single</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 提取运行时代码到单独的 chunk</span>
    <span class="na">moduleIds</span><span class="p">:</span> <span class="dl">'</span><span class="s1">deterministic</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 使用确定性的模块 ID</span>
    <span class="na">chunkIds</span><span class="p">:</span> <span class="dl">'</span><span class="s1">deterministic</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 使用确定性的 chunk ID</span>
    <span class="na">mangleWasmImports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 压缩 WebAssembly 导入名称</span>
    <span class="na">removeAvailableModules</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除可用的模块</span>
    <span class="na">removeEmptyChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除空的 chunk</span>
    <span class="na">mergeDuplicateChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 合并重复的 chunk</span>
    <span class="na">flagIncludedChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 标记包含的 chunk</span>
    <span class="na">providedExports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">usedExports</span><span class="p">:</span> <span class="kc">true</span>
    <span class="na">sideEffects</span><span class="p">:</span> <span class="kc">true</span>
    <span class="na">nodeEnv</span><span class="p">:</span> <span class="dl">'</span><span class="s1">production</span><span class="dl">'</span>
    <span class="na">realContentHash</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[2.1 Entry]]></summary></entry><entry><title type="html">webpack 项目优化</title><link href="https://feng-zhang0712.github.io//blog/2024/optimization/" rel="alternate" type="text/html" title="webpack 项目优化"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/optimization</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/optimization/"><![CDATA[<h3 id="61-启用代码压缩">6.1 启用代码压缩</h3> <h4 id="1压缩-html-代码">（1）压缩 HTML 代码</h4> <p><code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 用于简化 HTML 文件的创建、管理以及注入打包后的 JavaScript 文件。下面列出了一些 <code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 常用的配置项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">title</code></strong>：页面的标题，会被插入到 <code class="language-plaintext highlighter-rouge">&lt;title&gt;</code> 标签中。</li> <li><strong><code class="language-plaintext highlighter-rouge">filename</code></strong>：生成的 HTML 文件的名称，默认是 <code class="language-plaintext highlighter-rouge">index.html</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">template</code></strong>：指定模板文件的路径。</li> <li><strong><code class="language-plaintext highlighter-rouge">inject</code></strong>：注入选项，默认为 <code class="language-plaintext highlighter-rouge">true</code>，表示将打包的资源注入到生成的 HTML 文件中。它可以是 <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code>、<code class="language-plaintext highlighter-rouge">'head'</code> 或者 <code class="language-plaintext highlighter-rouge">'body'</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">favicon</code></strong>：指定 favicon 文件的路径。</li> <li><strong><code class="language-plaintext highlighter-rouge">meta</code></strong>：注入页面的 <code class="language-plaintext highlighter-rouge">meta</code> 标签，可以是一个对象。</li> <li><strong><code class="language-plaintext highlighter-rouge">hash</code></strong>：如果为 <code class="language-plaintext highlighter-rouge">true</code>，则会在所有的资源文件后面加一个唯一的 hash，防止缓存。</li> <li><strong><code class="language-plaintext highlighter-rouge">minify</code></strong>：用于控制生成的 HTML 文件的代码压缩。这个属性接受一个对象，内含多个配置选项，分别控制不同的压缩行为。</li> </ul> <p>通过配置 <code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 的 <code class="language-plaintext highlighter-rouge">minify</code> 属性来压缩 HTML 代码。以下是 <code class="language-plaintext highlighter-rouge">minify</code> 属性的常用选项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">collapseWhitespace</code></strong>：压缩 HTML 中的空白。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeComments</code></strong>：移除 HTML 中的注释。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeRedundantAttributes</code></strong>：移除多余的属性（如 <code class="language-plaintext highlighter-rouge">&lt;input type="text"&gt;</code> 中的 <code class="language-plaintext highlighter-rouge">type="text"</code>）。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeScriptTypeAttributes</code></strong>：移除 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签中的 <code class="language-plaintext highlighter-rouge">type="text/javascript"</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeStyleLinkTypeAttributes</code></strong>：移除 <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;style&gt;</code> 标签中的 <code class="language-plaintext highlighter-rouge">type="text/css"</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">useShortDoctype</code></strong>：将文档类型简化为 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">minifyCSS</code></strong>：压缩内联的 CSS。</li> <li><strong><code class="language-plaintext highlighter-rouge">minifyJS</code></strong>：压缩内联的 JavaScript。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HtmlWebpackPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">html-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nc">HtmlWebpackPlugin</span><span class="p">({</span>
      <span class="na">template</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/index.html</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">minify</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">collapseWhitespace</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeComments</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeRedundantAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeScriptTypeAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeStyleLinkTypeAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">useShortDoctype</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minifyCSS</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minifyJS</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">]</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="2压缩-css-代码">（2）压缩 CSS 代码</h4> <p><code class="language-plaintext highlighter-rouge">css-minimizer-webpack-plugin</code> 是一个用于压缩 CSS 代码的 Webpack 插件，它基于 cssnano 提供的优化功能，能够有效地减少 CSS 文件的体积，从而提升加载性能。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">test</code></strong>：匹配需要压缩的文件，默认值是 <code class="language-plaintext highlighter-rouge">/\.css$/i</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">parallel</code></strong>：启用并行压缩以提升构建速度，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimizerOptions</code></strong>：传递给 cssnano 的配置选项。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">CssMinimizerPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">css-minimizer-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">`...`</span><span class="p">,</span>
      <span class="k">new</span> <span class="nc">CssMinimizerPlugin</span><span class="p">({</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.</span><span class="sr">css$/i</span><span class="p">,</span>
        <span class="na">parallel</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minimizerOptions</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">preset</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">'</span><span class="s1">default</span><span class="dl">'</span><span class="p">,</span>
            <span class="p">{</span>
              <span class="na">discardComments</span><span class="p">:</span> <span class="p">{</span> <span class="na">removeAll</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span> <span class="c1">// 移除所有注释</span>
            <span class="p">},</span>
          <span class="p">],</span>
        <span class="p">},</span>
      <span class="p">}),</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="3压缩-javascript-代码">（3）压缩 JavaScript 代码</h4> <p><code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code> 用于压缩和优化 JavaScript 代码。它基于 Terser，一个 JavaScript 解析器、压缩器、美化器和 AST 工具包。<code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code> 是 Webpack 内置的 JavaScript 压缩插件，在生产环境下默认使用，可以通过自定义配置优化其行为。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">test</code></strong>：匹配需要压缩的文件，默认值是 <code class="language-plaintext highlighter-rouge">/\.m?js(\?.*)?$/i</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">parallel</code></strong>：启用并行压缩以提升构建速度，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">extractComments</code></strong>：提取注释到单独的文件中，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">terserOptions</code></strong>：传递给 Terser 的配置选项，详细配置见 Terser Options。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TerserPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">terser-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span>
      <span class="k">new</span> <span class="nc">TerserPlugin</span><span class="p">({</span>
        <span class="na">parallel</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">extractComments</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">terserOptions</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">compress</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">drop_console</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="p">},</span>
          <span class="na">format</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">comments</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="p">},</span>
        <span class="p">},</span>
      <span class="p">}),</span>
    <span class="p">],</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="62-图片压缩">6.2 图片压缩</h3> <p><code class="language-plaintext highlighter-rouge">file-loader</code> 的主要作用是将文件导出到输出目录，并返回文件的 URL。它可以处理各种类型的文件，包括图片、字体、音频、视频等。以下是几个常用的 <code class="language-plaintext highlighter-rouge">file-loader</code> 配置项。</p> <ul> <li><code class="language-plaintext highlighter-rouge">name</code>：设置文件的命名格式，可以使用占位符（如 <code class="language-plaintext highlighter-rouge">[name]</code>、<code class="language-plaintext highlighter-rouge">[ext]</code>、<code class="language-plaintext highlighter-rouge">[hash]</code> 等）。</li> <li><code class="language-plaintext highlighter-rouge">outputPath</code>：设置文件输出目录，可以是相对于输出路径的相对路径。</li> <li><code class="language-plaintext highlighter-rouge">publicPath</code>：设置文件的公共路径（通常用于 CDN）。</li> <li><code class="language-plaintext highlighter-rouge">emitFile</code>：是否输出文件，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> </ul> <p><code class="language-plaintext highlighter-rouge">image-webpack-loader</code> 是一个图片压缩加载器，可以结合 <code class="language-plaintext highlighter-rouge">file-loader</code> 使用，处理后的图片会自动进行压缩优化，从而减少文件体积，提高加载性能。以下是几个常用的 <code class="language-plaintext highlighter-rouge">image-webpack-loader</code> 配置项。</p> <ul> <li><code class="language-plaintext highlighter-rouge">mozjpeg</code>：配置 <code class="language-plaintext highlighter-rouge">mozjpeg</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">progressive</code>：是否开启渐进式 JPEG。</li> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量，范围是 0-100。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">optipng</code>：配置 <code class="language-plaintext highlighter-rouge">optipng</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">enabled</code>：是否开启 <code class="language-plaintext highlighter-rouge">optipng</code> 压缩。</li> <li><code class="language-plaintext highlighter-rouge">optimizationLevel</code>：优化级别，范围是 0-7。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">pngquant</code>：配置 <code class="language-plaintext highlighter-rouge">pngquant</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量范围，如 [0.65, 0.90]。</li> <li><code class="language-plaintext highlighter-rouge">speed</code>：压缩速度，范围是 1-11。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">gifsicle</code>：配置 <code class="language-plaintext highlighter-rouge">gifsicle</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">interlaced</code>：是否开启交错模式。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">webp</code>：配置 <code class="language-plaintext highlighter-rouge">webp</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量，范围是 0-100。</li> </ul> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HtmlWebpackPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">html-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">png|jpe</span><span class="se">?</span><span class="sr">g|gif|svg</span><span class="se">)</span><span class="sr">$/i</span><span class="p">,</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">images/</span><span class="dl">'</span><span class="p">,</span>
            <span class="p">},</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">image-webpack-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">mozjpeg</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">progressive</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
                <span class="na">quality</span><span class="p">:</span> <span class="mi">65</span><span class="p">,</span>
              <span class="p">},</span>
              <span class="na">optipng</span><span class="p">:</span> <span class="p">{</span> <span class="na">enabled</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span>
              <span class="na">pngquant</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">quality</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.90</span><span class="p">],</span>
                <span class="na">speed</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
              <span class="p">},</span>
              <span class="na">gifsicle</span><span class="p">:</span> <span class="p">{</span> <span class="na">interlaced</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
              <span class="na">webp</span><span class="p">:</span> <span class="p">{</span> <span class="na">quality</span><span class="p">:</span> <span class="mi">75</span> <span class="p">},</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="63-tree-shaking">6.3 Tree Shaking</h3> <p>Tree Shaking 通过在编译时分析模块的依赖关系，移除那些没有被引用的代码，从而减少最终打包文件的体积。为了启用 Tree Shaking，需要使用 ES6 模块语法（import/export）并配置 optimization。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">usedExports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用 Tree Shaking</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="64-代码分离code-splitting">6.4 代码分离（Code Splitting）</h3> <p>将代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件。默认情况下，所有的 JavaScript 代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度。代码分离可以分出出更小的 bundle，以及控制资源加载优先级，提供代码的加载性能。</p> <p>SplitChunksPlugin 是 Webpack 提供的一个内置插件，可以用于实现代码分离（code splitting）。SplitChunksPlugin 的常用配置如下。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">chunks</code></strong>：可以是 <code class="language-plaintext highlighter-rouge">'all'</code>、<code class="language-plaintext highlighter-rouge">'async'</code> 或 <code class="language-plaintext highlighter-rouge">'initial'</code>。指定要分离的块类型。</li> <li><strong><code class="language-plaintext highlighter-rouge">minSize</code></strong>：生成块的最小大小（以字节为单位），默认值为 30000。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxSize</code></strong>：生成块的最大大小（以字节为单位），超过此大小会进一步分离。</li> <li><strong><code class="language-plaintext highlighter-rouge">minChunks</code></strong>：最少引用次数，文件被引用次数超过此值时才会被分离，默认值为 1。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxAsyncRequests</code></strong>：按需加载时的最大并行请求数，默认值为 6。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxInitialRequests</code></strong>：入口点的最大并行请求数，默认值为 4。</li> <li><strong><code class="language-plaintext highlighter-rouge">automaticNameDelimiter</code></strong>：生成名称时的分隔符，默认值为 ~。</li> <li><strong><code class="language-plaintext highlighter-rouge">name</code></strong>：指定分离块的名称，可以是 <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code> 或者一个函数。</li> <li><strong><code class="language-plaintext highlighter-rouge">cacheGroups</code></strong>：指定缓存组，为不同的分离规则定义不同的缓存组。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">splitChunks</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">minSize</span><span class="p">:</span> <span class="mi">20000</span><span class="p">,</span>
      <span class="na">maxSize</span><span class="p">:</span> <span class="mi">70000</span><span class="p">,</span>
      <span class="na">minChunks</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">maxAsyncRequests</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
      <span class="na">maxInitialRequests</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="na">automaticNameDelimiter</span><span class="p">:</span> <span class="dl">'</span><span class="s1">~</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">cacheGroups</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">vendors</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">[\\/]</span><span class="sr">node_modules</span><span class="se">[\\/]</span><span class="sr">/</span><span class="p">,</span>
          <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">vendors</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="na">default</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">minChunks</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
          <span class="na">priority</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
          <span class="na">reuseExistingChunk</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="p">},</span>
      <span class="p">},</span>
    <span class="p">},</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，我们定义了两个缓存组。<code class="language-plaintext highlighter-rouge">vendors</code> 缓存组用来将所有来自 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录的模块分离到一个名为 <code class="language-plaintext highlighter-rouge">vendors</code> 的块中。<code class="language-plaintext highlighter-rouge">default</code> 缓存组用来将被至少两次引用的模块分离到一个默认块中，并且优先级较低。</p> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[6.1 启用代码压缩]]></summary></entry><entry><title type="html">webpack 的发布-订阅模式</title><link href="https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model/" rel="alternate" type="text/html" title="webpack 的发布-订阅模式"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model/"><![CDATA[<h3 id="31-什么是发布-订阅模式">3.1 什么是发布-订阅模式？</h3> <p><strong>发布-订阅模式</strong> 是一种设计模式，其中一个主体（发布者）维护一系列依赖其状态的观察者（订阅者）。发布者在状态变化时向观察者发送通知，而观察者可以选择性地对这些通知做出响应。</p> <p>webpack 的插件系统基于发布-订阅模式。这个模式允许 webpack 在构建过程的不同阶段广播事件，插件可以订阅这些事件并在适当的时机执行特定的任务。</p> <p>在 webpack 中，发布者是 webpack 本身，它在构建过程的不同阶段广播事件。订阅者是 webpack 插件，它们订阅感兴趣的事件并在这些事件触发时执行特定逻辑。</p> <h3 id="32-webpack-生命周期广播事件">3.2 webpack 生命周期广播事件</h3> <p>webpack 在其构建生命周期的不同阶段会广播一系列事件。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">initialize</code></strong>：初始化阶段，webpack 构建过程开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">environment</code></strong>：设置环境变量。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterEnvironment</code></strong>：环境变量设置完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">entryOption</code></strong>：处理入口选项。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterPlugins</code></strong>：插件初始化完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterResolvers</code></strong>：解析器初始化完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">beforeRun</code></strong>：构建过程开始前。</li> <li><strong><code class="language-plaintext highlighter-rouge">run</code></strong>：构建过程开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">beforeCompile</code></strong>：编译前准备阶段。</li> <li><strong><code class="language-plaintext highlighter-rouge">compile</code></strong>：编译阶段开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">thisCompilation</code></strong>：新的 Compilation 创建前。</li> <li><strong><code class="language-plaintext highlighter-rouge">compilation</code></strong>：新的 Compilation 创建后。</li> <li><strong><code class="language-plaintext highlighter-rouge">make</code></strong>：从入口点开始构建模块。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterCompile</code></strong>：编译完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">emit</code></strong>：生成资源到输出目录前。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterEmit</code></strong>：生成资源到输出目录后。</li> <li><strong><code class="language-plaintext highlighter-rouge">done</code></strong>：构建过程完成。</li> </ul> <h3 id="33-插件如何与广播事件协调工作">3.3 插件如何与广播事件协调工作</h3> <p>webpack 插件通过订阅这些事件来协调工作。插件在注册时将其逻辑挂载到特定的事件上，当事件被触发时，插件的逻辑会自动执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyPlugin</span> <span class="p">{</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 插件的逻辑</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is my plugin!</span><span class="dl">'</span><span class="p">);</span>
      <span class="nf">callback</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">MyPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>上面代码是一个自定义的插件，其中：</p> <ul> <li><code class="language-plaintext highlighter-rouge">apply</code> 方法用于注册插件。</li> <li><code class="language-plaintext highlighter-rouge">compiler</code> 对象是 webpack 编译器实例，提供了绑定事件的钩子（hooks）。</li> <li><code class="language-plaintext highlighter-rouge">compiler.hooks.emit</code> 表示 <code class="language-plaintext highlighter-rouge">emit</code> 事件的钩子。<code class="language-plaintext highlighter-rouge">tapAsync</code> 方法用于异步钩子，注册一个回调函数，该函数将在 <code class="language-plaintext highlighter-rouge">emit</code> 事件被触发时执行。</li> </ul> <h3 id="34-webpack-插件与生命周期事件的工作流程">3.4 webpack 插件与生命周期事件的工作流程</h3> <ol> <li>插件注册：插件通过 <code class="language-plaintext highlighter-rouge">apply</code> 方法注册到 webpack 编译器。在 <code class="language-plaintext highlighter-rouge">apply</code> 方法中，插件通过 <code class="language-plaintext highlighter-rouge">compiler</code> 对象的钩子（hooks）订阅感兴趣的事件。</li> <li>事件触发：webpack 在构建过程的不同阶段触发事件。当事件被触发时，所有订阅了该事件的插件都将依次执行其注册的回调函数。</li> <li>回调执行：插件的回调函数执行其特定的逻辑。例如，修改编译资源、生成额外的文件、优化输出等。</li> </ol> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">class</span> <span class="nc">MyPlugin</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">options</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 生成一个额外的文件</span>
      <span class="kd">const</span> <span class="nx">content</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">This is a generated file</span><span class="dl">'</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">outputPath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nx">compiler</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">output</span><span class="p">.</span><span class="nx">path</span><span class="p">,</span> <span class="dl">'</span><span class="s1">generated-file.txt</span><span class="dl">'</span><span class="p">);</span>

      <span class="nx">compilation</span><span class="p">.</span><span class="nx">assets</span><span class="p">[</span><span class="dl">'</span><span class="s1">generated-file.txt</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">source</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">content</span><span class="p">,</span>
        <span class="na">size</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">content</span><span class="p">.</span><span class="nx">length</span>
      <span class="p">};</span>

      <span class="c1">// 写入文件到输出目录</span>
      <span class="nx">fs</span><span class="p">.</span><span class="nf">writeFile</span><span class="p">(</span><span class="nx">outputPath</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">The file has been saved!</span><span class="dl">'</span><span class="p">);</span>
        <span class="nf">callback</span><span class="p">();</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">MyPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>上面的代码，是一个自定义的插件，它会在 <code class="language-plaintext highlighter-rouge">emit</code> 阶段生成一个额外的文件。</p> <ul> <li>插件在 <code class="language-plaintext highlighter-rouge">emit</code> 阶段生成一个名为 <code class="language-plaintext highlighter-rouge">generated-file.txt</code> 的文件，并将其内容设置为 <code class="language-plaintext highlighter-rouge">"This is a generated file"</code>。</li> <li>通过 <code class="language-plaintext highlighter-rouge">compilation.assets</code> 将生成的文件添加到 webpack 的资源管理中。</li> <li>异步写入文件到输出目录，当写入完成后调用 <code class="language-plaintext highlighter-rouge">callback</code> 以通知 webpack 继续构建过程。</li> </ul> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[3.1 什么是发布-订阅模式？]]></summary></entry><entry><title type="html">webpack 中的 Loader</title><link href="https://feng-zhang0712.github.io//blog/2024/loader/" rel="alternate" type="text/html" title="webpack 中的 Loader"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/loader</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/loader/"><![CDATA[<p>loader 本质上是导出为函数的 JavaScript 模块。<a href="https://github.com/webpack/loader-runner">loader runner</a> 会调用此函数，然后将上一个 loader 产生的结果或者资源文件传入进去。函数中的 <code class="language-plaintext highlighter-rouge">this</code> 作为上下文会被 webpack 填充，并且 loader runner 中包含一些实用的方法，比如可以使 loader 调用方式变为异步，或者获取 <code class="language-plaintext highlighter-rouge">query</code> 参数。</p> <p>如果是单个处理结果，可以在 <a href="#1同步-loader">同步模式</a> 中直接返回。如果有多个处理结果，则必须调用 <code class="language-plaintext highlighter-rouge">this.callback()</code>。在 <a href="#2异步-loader">异步模式</a> 中，必须调用 <code class="language-plaintext highlighter-rouge">this.async()</code> 来告知 loader runner 等待异步结果，它会返回 <code class="language-plaintext highlighter-rouge">this.callback()</code> 回调函数。随后 loader 必须返回 <code class="language-plaintext highlighter-rouge">undefined</code> 并且调用该回调函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *
 * @param {string|Buffer} content 源文件的内容
 * @param {object} [map] 可以被 https://github.com/mozilla/source-map 使用的 SourceMap 数据
 * @param {any} [meta] meta 数据，可以是任何内容
 */</span>
<span class="kd">function</span> <span class="nf">webpackLoader</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>loader 分为几种不同的类型，他们是同步 Loader、异步 Loader、Raw Loader 和 Pitching Loader。</p> <h2 id="loader-分类">Loader 分类</h2> <h3 id="1同步-loader">（1）同步 Loader</h3> <p>通过 <code class="language-plaintext highlighter-rouge">return</code> 或者 <code class="language-plaintext highlighter-rouge">this.callback()</code> 同步地返回处理后的 <code class="language-plaintext highlighter-rouge">content</code> 值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">return</code> 返回处理之后的 <code class="language-plaintext highlighter-rouge">content</code>，然后交由 webpack 或者之后的 <code class="language-plaintext highlighter-rouge">loader</code> 继续处理。</p> <p>除了使用 <code class="language-plaintext highlighter-rouge">return</code> 关键词，还可以使用 <code class="language-plaintext highlighter-rouge">this.callback()</code>，后者的优点是更灵活，因为它允许传递多个参数，而不仅仅是 <code class="language-plaintext highlighter-rouge">content</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">),</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">);</span>

  <span class="c1">// 当调用 callback() 函数时，总是返回 undefined</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="2异步-loader">（2）异步 Loader</h3> <p>异步 loader 使用 <code class="language-plaintext highlighter-rouge">this.async()</code> 来获取 callback 函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="k">async</span><span class="p">();</span>
  <span class="nf">someAsyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nf">callback</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="3raw-loader">（3）Raw Loader</h3> <p>默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。通过设置 <code class="language-plaintext highlighter-rouge">raw</code> 为 <code class="language-plaintext highlighter-rouge">true</code>，loader 可以接收原始的 Buffer。每个 loader 都可以用 String 或者 Buffer 的形式传递它的处理结果。complier 会把它们在 loader 之间相互转换。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">assert</span><span class="p">(</span><span class="nx">content</span> <span class="k">instanceof</span> <span class="nx">Buffer</span><span class="p">);</span>

  <span class="c1">// 返回值也可以是一个 `Buffer`</span>
  <span class="c1">// 即使不是 "raw"，loader 也没问题</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">raw</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div> <h3 id="4pitching-loader">（4）Pitching Loader</h3> <p>loader <strong>总是</strong>从右到左被调用。有些情况下，loader 只关心 request 后面的<strong>元数据</strong>（metadata），并且忽略前一个 loader 的结果。在实际（从右到左）执行 loader 之前，会先<strong>从左到右</strong>调用 loader 上的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>假如我们有以下配置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">//...</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a-loader</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b-loader</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c-loader</span><span class="dl">'</span><span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，会按照下面的顺序执行。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|- a-loader `pitch`
  |- b-loader `pitch`
    |- c-loader `pitch`
      |- requested module is picked up as a dependency
    |- c-loader normal execution
  |- b-loader normal execution
|- a-loader normal execution
</code></pre></div></div> <p>从上面代码可以看出，在同一组 loader 配置中，<code class="language-plaintext highlighter-rouge">pitch()</code> 方法会优先执行。loader 模块中引入 “pitching” 阶段，主要是基于以下两个原因。</p> <ol> <li> <p>传递给 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法的 <code class="language-plaintext highlighter-rouge">data</code>，在执行阶段也会暴露在 <code class="language-plaintext highlighter-rouge">this.data</code> 之下，并且可以用于在循环时，捕获并共享前面的信息。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
 <span class="p">};</span>

 <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">data</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
 <span class="p">};</span>
</code></pre></div> </div> </li> <li> <p>如果某个 loader 在 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法中给出一个结果，那么这个过程会回过身来，并跳过剩下的 loader。在我们上面的例子中，如果 <code class="language-plaintext highlighter-rouge">b-loader</code> 的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法返回了一些东西，<code class="language-plaintext highlighter-rouge">b-loader</code> 之后的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法以及所有的 loader 方法，都将不再执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
 <span class="p">};</span>

 <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if </span><span class="p">(</span><span class="nf">someCondition</span><span class="p">())</span> <span class="p">{</span>
     <span class="k">return </span><span class="p">(</span>
       <span class="dl">'</span><span class="s1">module.exports = require(</span><span class="dl">'</span> <span class="o">+</span>
       <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="dl">'</span><span class="s1">-!</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">remainingRequest</span><span class="p">)</span> <span class="o">+</span>
       <span class="dl">'</span><span class="s1">);</span><span class="dl">'</span>
     <span class="p">);</span>
   <span class="p">}</span>
 <span class="p">};</span>
</code></pre></div> </div> <p>上面的代码，将会按照下面的顺序执行。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> |- a-loader `pitch`
   |- b-loader `pitch` returns a module
 |- a-loader normal execution
</code></pre></div> </div> </li> </ol> <h2 id="loader-context">Loader Context</h2> <p>loader context 表示在 loader 内使用 <code class="language-plaintext highlighter-rouge">this</code> 可以访问的一些方法或属性。</p> <h3 id="thisasync">this.async()</h3> <p>用于告诉 loader-runner 这个 loader 将会异步地回调。返回 <code class="language-plaintext highlighter-rouge">this.callback()</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="k">async</span><span class="p">();</span>
</code></pre></div></div> <h3 id="thiscallback">this.callback()</h3> <p>用于同步或异步调用，并返回多个结果。预期的参数是：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nf">callback</span><span class="p">(</span>
  <span class="nx">err</span><span class="p">:</span> <span class="nb">Error</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">content</span><span class="p">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">Buffer</span><span class="p">,</span>
  <span class="nx">sourceMap</span><span class="p">?:</span> <span class="nx">SourceMap</span><span class="p">,</span> <span class="c1">// 表示一个可以被 this module 解析的 source map</span>
  <span class="nx">meta</span><span class="p">?:</span> <span class="nx">any</span> <span class="c1">// 此参数会被 webpack 忽略，可以是任何东西（例如一些元数据）</span>
<span class="p">);</span>
</code></pre></div></div> <p>注意，在使用了 <code class="language-plaintext highlighter-rouge">this.callback()</code> 的情况下，就不应该在使用 <code class="language-plaintext highlighter-rouge">return</code> 返回 <code class="language-plaintext highlighter-rouge">content</code>，而是应该返回 <code class="language-plaintext highlighter-rouge">undefined</code>，从而避免含糊的 loader 结果。</p> <h3 id="thisemitfile">this.emitFile()</h3> <p>用于产生一个文件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">emitFile</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">content</span><span class="p">:</span> <span class="nx">Buffer</span><span class="o">|</span><span class="nx">string</span><span class="p">,</span> <span class="nx">sourceMap</span><span class="p">:</span> <span class="p">{...})</span>
</code></pre></div></div> <h3 id="thisgetoptionsschema">this.getOptions(schema)</h3> <p>用于提取给定的 loader 选项，接受一个可选的 JSON schema 作为参数。</p> <h3 id="thisutils">this.utils</h3> <p>用于访问 <code class="language-plaintext highlighter-rouge">contextify</code> 与 <code class="language-plaintext highlighter-rouge">absolutify</code> 功能。</p> <ul> <li><code class="language-plaintext highlighter-rouge">contextify</code>：返回一个新的请求字符串，尽可能避免使用绝对路径。</li> <li><code class="language-plaintext highlighter-rouge">absolutify</code>：尽可能使用相对路径返回一个新的请求字符串。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">contextify</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">absolutify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span> <span class="dl">'</span><span class="s1">./index.js</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">absolutify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">resourcePath</span><span class="p">);</span>
  <span class="c1">// …</span>
  <span class="k">return</span> <span class="nx">content</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>这里只是列举出了几个常用的 Loader Context API，更多方法请参考 <a href="https://webpack.docschina.org/api/loaders/">Loader Interface</a>。</p> <h2 id="编写-loader">编写 Loader</h2> <h3 id="用法准则">用法准则</h3> <p>编写 loader 时应该遵循以下准则。它们按重要程度排序，有些仅适用于某些场景。</p> <h4 id="1保持简单">（1）保持<strong>简单</strong></h4> <p>loaders 应该只做单一任务。这不仅使每个 loader 易维护，也可以在更多场景链式调用。</p> <h4 id="2使用链式传递">（2）使用<strong>链式</strong>传递</h4> <p>利用 loader 可以链式调用的优势。写五个简单的 loader 实现五项任务，而不是一个 loader 实现五项任务。功能隔离不仅使 loader 更简单，可能还可以将它们用于你原先没有想到的功能。</p> <h4 id="3模块化的输出">（3）<strong>模块化</strong>的输出</h4> <p>保证输出模块化。loader 生成的模块与普通模块遵循相同的设计原则。</p> <h4 id="4确保无状态">（4）确保<strong>无状态</strong></h4> <p>确保 loader 在不同模块转换之间不保存状态。每次运行都应该独立于其他编译模块以及相同模块之前的编译结果。</p> <h4 id="5使用-loader-utilities">（5）使用 <strong>loader utilities</strong></h4> <p>充分利用 <code class="language-plaintext highlighter-rouge">loader-utils</code> 包。它提供了许多有用的工具，但最常用的一种工具是获取传递给 loader 的选项。<code class="language-plaintext highlighter-rouge">schema-utils</code> 包配合 <code class="language-plaintext highlighter-rouge">loader-utils</code>，用于保证 loader 选项，进行与 JSON Schema 结构一致的校验。</p> <h4 id="6记录-loader-的依赖">（6）记录 <strong>loader 的依赖</strong></h4> <p>如果一个 loader 使用外部资源（例如，从文件系统读取），必须声明它。这些信息用于使缓存 loaders 无效，以及在观察模式(watch mode)下重编译。</p> <h4 id="7解析模块依赖关系">（7）解析<strong>模块依赖关系</strong></h4> <p>根据模块类型，可能会有不同的模式指定依赖关系。例如在 CSS 中，使用 <code class="language-plaintext highlighter-rouge">@import</code> 和 <code class="language-plaintext highlighter-rouge">url(...)</code> 语句来声明依赖。这些依赖关系应该由模块系统解析。</p> <p>可以通过以下两种方式中的一种来实现：</p> <ul> <li>通过把它们转化成 <code class="language-plaintext highlighter-rouge">require</code> 语句。</li> <li>使用 <code class="language-plaintext highlighter-rouge">this.resolve</code> 函数解析路径。</li> </ul> <p><code class="language-plaintext highlighter-rouge">css-loader</code> 是第一种方式的一个例子。它将 <code class="language-plaintext highlighter-rouge">@import</code> 语句替换为 <code class="language-plaintext highlighter-rouge">require</code> 其他样式文件，将 <code class="language-plaintext highlighter-rouge">url(...)</code> 替换为 <code class="language-plaintext highlighter-rouge">require</code> 引用文件，从而实现将依赖关系转化为 <code class="language-plaintext highlighter-rouge">require</code> 声明。</p> <p>对于 <code class="language-plaintext highlighter-rouge">less-loader</code>，无法将每个 <code class="language-plaintext highlighter-rouge">@import</code> 转化为 <code class="language-plaintext highlighter-rouge">require</code>，因为所有 <code class="language-plaintext highlighter-rouge">.less</code> 的文件中的变量和混合跟踪必须一次编译。因此，<code class="language-plaintext highlighter-rouge">less-loader</code> 将 less 编译器进行了扩展，自定义路径解析逻辑。然后，利用第二种方式，通过 webpack 的 <code class="language-plaintext highlighter-rouge">this.resolve</code> 解析依赖。</p> <h4 id="8提取通用代码">（8）提取<strong>通用代码</strong></h4> <p>避免在 loader 处理的每个模块中生成通用代码。相反，你应该在 loader 中创建一个运行时文件，并生成 <code class="language-plaintext highlighter-rouge">require</code> 语句以引用该共享模块：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/loader-runtime.js</span>

<span class="kd">const</span> <span class="p">{</span> <span class="nx">someOtherModule</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./some-other-module</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">runtime</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">someOtherModule</span><span class="p">(</span><span class="nx">params</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// src/loader.js</span>
<span class="k">import</span> <span class="nx">runtime</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./loader-runtime.js</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">loader</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nf">runtime</span><span class="p">({</span>
    <span class="nx">source</span><span class="p">,</span>
    <span class="na">y</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">(),</span>
  <span class="p">})}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="9避免绝对路径">（9）避免<strong>绝对路径</strong></h4> <p>不要在模块代码中插入绝对路径，因为当项目根路径变化时，文件绝对路径也会变化。<code class="language-plaintext highlighter-rouge">loader-utils</code> 中的 <a href="https://github.com/webpack/loader-utils#stringifyrequest">stringifyRequest</a> 方法，可以将绝对路径转化为相对路径。</p> <h4 id="10使用-peer-dependencies">（10）使用 <strong>peer dependencies</strong></h4> <p>如果你的 loader 简单包裹另外一个包，你应该把这个包作为一个 peerDependency 引入。这种方式允许应用程序开发者在必要情况下，在 <code class="language-plaintext highlighter-rouge">package.json</code> 中指定所需的确定版本。</p> <p>例如，<code class="language-plaintext highlighter-rouge">sass-loader</code> 指定 <code class="language-plaintext highlighter-rouge">node-sass</code> 作为同等依赖，引用如下：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"peerDependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"node-sass"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.0.0"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[loader 本质上是导出为函数的 JavaScript 模块。loader runner 会调用此函数，然后将上一个 loader 产生的结果或者资源文件传入进去。函数中的 this 作为上下文会被 webpack 填充，并且 loader runner 中包含一些实用的方法，比如可以使 loader 调用方式变为异步，或者获取 query 参数。]]></summary></entry><entry><title type="html">webpack 中的 Plugin</title><link href="https://feng-zhang0712.github.io//blog/2024/plugin/" rel="alternate" type="text/html" title="webpack 中的 Plugin"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/plugin</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/plugin/"><![CDATA[<p>webpack 在代码编译过程中，会触发一系列 Tapable 钩子事件，插件所做的，就是在相应的钩子上注册事件，执行不同的任务。当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行。</p> <h2 id="一钩子">一、钩子</h2> <p>钩子（hooks）的本质是事件。webpack 把编译过程中触发的各类关键事件封装成事件接口暴露了出来。这些接口就被称为钩子，钩子是 webpack 插件中的关键概念。</p> <p><a href="https://github.com/webpack/tapable">Tapable</a> 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。</p> <p>Tapable 统一暴露了三个方法给插件，用于注册不同的钩子事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">tap()</code>：可以注册同步钩子和异步钩子。</li> <li> <p><code class="language-plaintext highlighter-rouge">tapAsync()</code>：回调方式注册异步钩子。</p> <p>使用 <code class="language-plaintext highlighter-rouge">tapAsync()</code> 方法来绑定插件时，<strong>必须</strong>调用函数的最后一个参数 <code class="language-plaintext highlighter-rouge">callback()</code> 指定的回调函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">HelloAsyncPlugin</span> <span class="p">{</span>
    <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span>
        <span class="dl">'</span><span class="s1">HelloAsyncPlugin</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="c1">// 执行某些异步操作...</span>
          <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">异步任务完成...</span><span class="dl">'</span><span class="p">);</span>
            <span class="nf">callback</span><span class="p">();</span>
          <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloAsyncPlugin</span><span class="p">;</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">tapPromise()</code>：Promise 方式注册异步钩子。</p> <p>使用 <code class="language-plaintext highlighter-rouge">tapPromise()</code> 方法来绑定插件时，<strong>必须</strong>返回一个 Promise，异步任务完成后调用 Promise 的 <code class="language-plaintext highlighter-rouge">resolve()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">HelloAsyncPlugin</span> <span class="p">{</span>
    <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapPromise</span><span class="p">(</span><span class="dl">'</span><span class="s1">HelloAsyncPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 返回一个 pormise ，异步任务完成后 resolve</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">异步任务完成...</span><span class="dl">'</span><span class="p">);</span>
            <span class="nf">resolve</span><span class="p">();</span>
          <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloAsyncPlugin</span><span class="p">;</span>
</code></pre></div> </div> </li> </ul> <p>目前，<a href="https://github.com/webpack/tapable/blob/master/lib/index.js">Tapable</a> 中定义了十种 Hooks。</p> <ul> <li>SyncHook</li> <li>SyncBailHook</li> <li>SyncWaterfallHook</li> <li>SyncLoopHook</li> <li>AsyncParallelHook</li> <li>AsyncParallelBailHook</li> <li>AsyncSeriesHook</li> <li>AsyncSeriesBailHook</li> <li>AsyncSeriesLoopHook</li> <li>AsyncSeriesWaterfallHook</li> </ul> <p>上面的钩子，按照执行方式，分为<strong>同步钩子</strong>和<strong>异步钩子</strong>，他们的名称分别以前缀 <code class="language-plaintext highlighter-rouge">Sync</code> 和 <code class="language-plaintext highlighter-rouge">Async</code> 开头。<a href="https://webpack.docschina.org/">webpack 文档中</a>列出的所有的 <a href="https://webpack.docschina.org/api/compiler-hooks/">compiler 钩子</a> 和 <a href="https://webpack.docschina.org/api/compilation-hooks/">compilation 钩子</a>，都继承自这些 Hooks。</p> <p>下面，分别对这些 Hooks 进行介绍。</p> <h3 id="synchook">SyncHook</h3> <h3 id="asyncparallelhook">AsyncParallelHook</h3> <h3 id="asyncserieshook">AsyncSeriesHook</h3> <h2 id="二compiler-对象">二、Compiler 对象</h2> <p><code class="language-plaintext highlighter-rouge">compiler</code> 对象中保存着完整的 webpack 环境配置，每次启动 webpack 构建时它都是一个独一无二、仅仅会创建一次的对象。这个对象会在首次启动 webpack 时创建，我们可以通过 <code class="language-plaintext highlighter-rouge">compiler</code> 对象上访问到 webapck 的主环境配置，比如 loader、plugin 等等配置信息。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-object-structure-480.webp 480w,/assets/images/webpack/compiler-object-structure-800.webp 800w,/assets/images/webpack/compiler-object-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-object-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler 对象的结构 </div> <p>webpack 中的很多<a href="https://webpack.docschina.org/api/compiler-hooks/#hooks">生命周期函数钩子</a>，由 <code class="language-plaintext highlighter-rouge">compiler</code> 暴露，可以通过以下方式注册监听。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">someHook</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
<span class="p">});</span>
</code></pre></div></div> <p>compiler 对象有以下主要属性。</p> <h3 id="compileroptions">compiler.options</h3> <p><code class="language-plaintext highlighter-rouge">compiler.options</code>：用于访问本次启动 webpack 时候所有的配置文件，比如 <code class="language-plaintext highlighter-rouge">loaders</code>、<code class="language-plaintext highlighter-rouge">entry</code> 、<code class="language-plaintext highlighter-rouge">output</code>、<code class="language-plaintext highlighter-rouge">plugin</code> 等等完整配置信息。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-options-structure-480.webp 480w,/assets/images/webpack/compiler-options-structure-800.webp 800w,/assets/images/webpack/compiler-options-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-options-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler.options 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler.options 对象的结构 </div> <h3 id="compilerhooks">compiler.hooks</h3> <p><code class="language-plaintext highlighter-rouge">compiler.hooks</code>：用于注册 tapable 的不同种类 Hook，从而可以在 <code class="language-plaintext highlighter-rouge">compiler</code> 生命周期中植入不同的逻辑。</p> <div class="row justify-content-center"> <div class="col-10"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-hooks-structure-480.webp 480w,/assets/images/webpack/compiler-hooks-structure-800.webp 800w,/assets/images/webpack/compiler-hooks-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-hooks-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler.hooks 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler.hooks 对象的结构 </div> <h3 id="compilerinputfilesystem-和-compileroutputfilesystem">compiler.inputFileSystem 和 compiler.outputFileSystem</h3> <p><code class="language-plaintext highlighter-rouge">compiler.inputFileSystem</code> 和 <code class="language-plaintext highlighter-rouge">compiler.outputFileSystem</code>：用于进行文件操作，相当于 Nodejs 中 <code class="language-plaintext highlighter-rouge">fs</code>。</p> <h2 id="三compilation-对象">三、Compilation 对象</h2> <p><code class="language-plaintext highlighter-rouge">compilation</code> 对象代表一次资源的构建，<code class="language-plaintext highlighter-rouge">compilation</code> 实例能够访问所有的模块和它们的依赖。一个 <code class="language-plaintext highlighter-rouge">compilation</code> 对象会对构建依赖图中所有模块进行编译。在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、分块(chunk)、哈希(hash)和重新创建(restore)。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compilation-object-structure-480.webp 480w,/assets/images/webpack/compilation-object-structure-800.webp 800w,/assets/images/webpack/compilation-object-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compilation-object-structure.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compilation 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compilation 对象的结构 </div> <p>Compilation 类扩展自 Tapable，并提供了很多<a href="https://webpack.docschina.org/api/compilation-hooks/">生命周期钩子</a>。他们的使用方式，跟使用 <code class="language-plaintext highlighter-rouge">compiler</code> 注册监听钩子的方式相同。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">compilation</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">someHook</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
<span class="p">});</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">compilation</code> 对象有以下主要属性。</p> <h3 id="compilationmodules">compilation.modules</h3> <p><code class="language-plaintext highlighter-rouge">compilation.modules</code> 用于访问所有模块，打包的每一个文件都是一个模块。</p> <h3 id="compilationchunks">compilation.chunks</h3> <p><code class="language-plaintext highlighter-rouge">compilation.chunks</code> chunk 即是多个 modules 组成而来的一个代码块。入口文件引入的资源组成一个 chunk，通过代码分割的模块又是另外的 chunk。</p> <h3 id="compilationassets">compilation.assets</h3> <p><code class="language-plaintext highlighter-rouge">compilation.assets</code> 用于访问本次打包生成所有文件的结果。</p> <h3 id="compilationhooks">compilation.hooks</h3> <p><code class="language-plaintext highlighter-rouge">compilation.hooks</code> 用于注册 tapable 的不同种类 Hook，用于在 <code class="language-plaintext highlighter-rouge">compilation</code> 编译模块阶段进行逻辑添加以及修改。</p> <h2 id="四自定义-plugin">四、自定义 Plugin</h2> <p>webpack 插件由以下几个部分组成。</p> <ul> <li>一个 JavaScript 命名<strong>函数</strong>或<strong>类</strong>。</li> <li>在插件函数的 prototype 上定义一个 <code class="language-plaintext highlighter-rouge">apply</code> 方法。</li> <li>指定一个绑定到 webpack 自身的事件钩子。</li> <li>处理 webpack 内部实例的特定数据。</li> <li>功能完成后调用 webpack 提供的回调。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyExampleWebpackPlugin</span> <span class="p">{</span>
  <span class="c1">// 在插件函数的 prototype 上定义一个 `apply` 方法，以 compiler 为参数。</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 指定一个挂载到 webpack 自身的事件钩子。</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span>
      <span class="dl">'</span><span class="s1">MyExampleWebpackPlugin</span><span class="dl">'</span><span class="p">,</span>
      <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">这是一个示例插件！</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
          <span class="dl">'</span><span class="s1">这里表示了资源的单次构建的 `compilation` 对象：</span><span class="dl">'</span><span class="p">,</span>
          <span class="nx">compilation</span>
        <span class="p">);</span>

        <span class="c1">// 用 webpack 提供的插件 API 处理构建过程</span>
        <span class="nx">compilation</span><span class="p">.</span><span class="nf">addModule</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>

        <span class="nf">callback</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>插件是由「具有 <code class="language-plaintext highlighter-rouge">apply</code> 方法的 prototype 对象」所实例化出来的。这个 <code class="language-plaintext highlighter-rouge">apply</code> 方法在安装插件时，会被 <code class="language-plaintext highlighter-rouge">compiler</code> 调用一次。apply 方法可以接收一个 <code class="language-plaintext highlighter-rouge">compiler</code> 对象的引用，从而可以在回调函数中访问到 <code class="language-plaintext highlighter-rouge">compiler</code> 对象。一个插件结构如下。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HelloWorldPlugin</span> <span class="p">{</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span>
      <span class="dl">'</span><span class="s1">Hello World Plugin</span><span class="dl">'</span><span class="p">,</span>
      <span class="p">(</span>
        <span class="nx">stats</span> <span class="cm">/* 绑定 done 钩子后，stats 会作为参数传入。 */</span>
      <span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloWorldPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>然后就可以在 webpack 配置文件中使用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HelloWorldPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello-world</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span><span class="k">new</span> <span class="nc">HelloWorldPlugin</span><span class="p">({</span> <span class="na">options</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})],</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="五参考">五、参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 在代码编译过程中，会触发一系列 Tapable 钩子事件，插件所做的，就是在相应的钩子上注册事件，执行不同的任务。当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行。]]></summary></entry><entry><title type="html">HTTP 缓存</title><link href="https://feng-zhang0712.github.io//blog/2024/07-caching/" rel="alternate" type="text/html" title="HTTP 缓存"/><published>2024-10-03T00:00:00+00:00</published><updated>2024-10-03T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/07-caching</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/07-caching/"><![CDATA[<blockquote> <p>本文节选自《HTTP 权威指南 - 第4章 连接管理》。</p> </blockquote> <p>Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存有下列优点。</p> <ul> <li><strong>减少了冗余的数据传输</strong>，节省了你的网络费用。</li> <li><strong>缓解了网络瓶颈的问题</strong>。不需要更多的带宽就能够更快地加载页面。</li> <li><strong>降低了对原始服务器的要求</strong>。服务器可以更快地响应，避免过载的出现。</li> <li><strong>降低了距离时延</strong>，因为从较远的地方加载页面会更慢一些。</li> </ul> <h2 id="一冗余的数据传输">一、冗余的数据传输</h2> <p>有很多客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传送给一个客户端。一些相同的字节会在网络中一遍遍地传输。这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重 Web 服务器的负载。有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少那些流入/流出原始服务器的、被浪费掉了的重复流量。</p> <h2 id="二带宽瓶颈">二、带宽瓶颈</h2> <p>缓存还可以<strong>缓解网络的瓶颈</strong>问题。很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽（参见图 7-1）。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能 —— 尤其是要传输比较大的文件时。</p> <p>在图 7-1 中，Joe 的五金商店旧金山分店的用户通过 1.4Mbit/s 的 T1 因特网连接，从亚特兰大总店下载一个 5MB 的库存文件要花 30 秒的时间。如果在旧金山分店里缓存了这个文档，本地用户通过以太网连接只要花费不到 1 秒的时间就可以获得同一份文档了。表 7-1 说明了在几种不同的网速下，传输几种不同大小的文档时，带宽会对传输速度产生什么样的影响。带宽会给较大的文档带来显而易见的时延，不同类型网络的速度差异会非常明显。’一个 54kbit/s 的 Modem 传输一个 5MB 的文件需要 749 秒（超过 12 分钟），而在快速以太网 LAN 中，只要不到一秒的时间。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="缓存可以改善由有限广域带宽造成的网络瓶颈" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-1 缓存可以改善由有限广域带宽造成的网络瓶颈 </div> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="带宽造成的传输时延，理想化情况（以秒为时间单位）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 7-1 带宽造成的传输时延，理想化情况（以秒为时间单位） </div> <h2 id="三瞬间拥塞">三、瞬间拥塞</h2> <p>缓存在破坏<strong>瞬间拥塞</strong>（Flash Crowds）时显得非常重要。突发事件（比如爆炸性新闻、批量 E-mail 公告，或者某个名人事件）使很多人几乎同时去访问一个 Web 文档时，就会出现瞬间拥塞（参见图 7-2）。由此造成的过多流量峰值可能会使网络和 Web 服务器产生灾难性的崩溃。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="瞬间拥塞会使 Web 服务器过载" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-2 瞬间拥塞会使 Web 服务器过载 </div> <h2 id="四距离时延">四、距离时延</h2> <p>即使带宽不是问题，距离也可能成为问题。每台网络路由器都会增加因特网流量的时延。即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著的时延。将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="即便使用的是并行的持久连接，光速也会造成显著的时延" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-3 即便使用的是并行的持久连接，光速也会造成显著的时延 </div> <h2 id="五命中和未命中的">五、命中和未命中的</h2> <p>缓存无法保存世界上每份文档的副本。可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存<strong>命中</strong>（cache hit），参见图 7-4a。其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为缓存<strong>未命中</strong>（cache miss），参见图 7-4b。</p> <h3 id="51-再验证">5.1 再验证</h3> <p>原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本。这些“新鲜度检测”被称为 HTTP <strong>再验证</strong>（revalidation）（参见图 7-4c）。为了有效地进行再验证，HTTP 定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="缓存命中、未命中以及再验证" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-4 缓存命中、未命中以及再验证 </div> <p>缓存中通常会包含数百万的文档，而且网络带宽是很珍贵的，所以大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行再验证。</p> <p>缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 进行响应。只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端（参见图 7-5a）这被称作<strong>再验证命中</strong>（revalidate hit）或<strong>缓慢命中</strong>（slow hit）。这种方式要与原始服务器进行核对，所以会比单纯的缓存命中要慢， 但它没有从服务器中获取对象数据，所以要比缓存未命中快一些。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="成功的再验证比缓存未命中要快，失败的再验证几乎和未命中的速度一样" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-5 成功的再验证比缓存未命中要快，失败的再验证几乎和未命中的速度一样 </div> <p>HTTP 为我们提供了几个用来对已缓存对象进行再验证的工具，但最常用的是 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 首部。将这个首部添加到 <code class="language-plaintext highlighter-rouge">GET</code> 请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。</p> <p>这里列出了在 3 种情况下（服务器内容未被修改，服务器内容已被修改，或者服务器上的对象被删除了）服务器收到 <code class="language-plaintext highlighter-rouge">GET</code> <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 请求时会发生的情况：</p> <ul> <li>再验证命中：如果服务器对象未被修改，服务器会向客户端发送 HTTP <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应。图 7-6 对此进行了描述。</li> <li>再验证未命中：如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的 HTTP <code class="language-plaintext highlighter-rouge">200 OK</code> 响应。</li> <li>对象被删除：如果服务器对象已经被删除了，服务器就回送一个 <code class="language-plaintext highlighter-rouge">404 Not Found</code> 响应，缓存也会将其副本删除。</li> </ul> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP 使用 If-Modified-Since 首部进行再验证" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-6 HTTP 使用 If-Modified-Since 首部进行再验证 </div> <h3 id="52-命中率">5.2 命中率</h3> <p>由<strong>缓存提供服务的请求所占的比例</strong>被称为<strong>缓存命中率</strong>（cache hit rate，或称为缓存命中比例），有时也被称为文档命中率（document hit rate）。命中率通常用百分数来描述，<code class="language-plaintext highlighter-rouge">0%</code> 表示每次请求都未命中（要通过网络来获取文档），<code class="language-plaintext highlighter-rouge">100%</code> 表示每次请求都命中了（在缓存中有一份副本）。</p> <p>缓存的管理者希望缓存命中率接近 100%。而实际得到的命中率则与缓存的大小、缓存用户兴趣点的相似性、缓存数据的变化或个性化频率，以及如何配置缓存有关。命中率很难预测，但对现在中等规模的 Web 缓存来说，<code class="language-plaintext highlighter-rouge">40%</code> 的命中率是很合理的。缓存的好处是，即使是中等规模的缓存，其所包含的常见文档也足以显著地提高性能、减少流量了。缓存会努力确保将有用的内容保存在缓存中。</p> <h3 id="53-字节命中率">5.3 字节命中率</h3> <p>由于文档并不全是同一尺寸的，所以文档命中率并不能说明一切。有些大型对象被访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大。因此，有些人更愿意使用<strong>字节命中率</strong>（byte hit rate）作为度量值（尤其那些按流量字节付费的人!）。</p> <p>字节命中率表示的是<strong>缓存提供的字节在传输的所有字节中所占的比例</strong>。通过这种度量方式，可以得知节省流量的程度。<code class="language-plaintext highlighter-rouge">100%</code> 的字节命中率说明每个字节都来自缓存，没有流量流到因特网上去。</p> <p>文档命中率和字节命中率对缓存性能的评估都是很有用的。文档命中率说明阻止了多少通往外部网络的 Web 事务。事务有一个通常都很大的固定时间成分（比如，建立一条到服务器的 TCP 连接）， 提高文档命中率对降低整体延迟（时延）很有好处。字节命中率说明阻止了多少字节传向因特网。提高字节命中率对节省带宽很有利。</p> <h3 id="54-区分命中和未命中的情况">5.4 区分命中和未命中的情况</h3> <p>不幸的是，HTTP 没有为用户提供一种手段来区分响应是缓存命中的，还是访问原始服务器得到的。在这两种情况下，响应码都是 <code class="language-plaintext highlighter-rouge">200 OK</code>，说明响应有主体部分。有些商业代理缓存会在 <code class="language-plaintext highlighter-rouge">Via</code> 首部附加一些额外信息，以描述缓存中发生的情况。客户端有一种方法可以判断响应是否来自缓存，就是使用 <code class="language-plaintext highlighter-rouge">Date</code> 首部。将响应中 <code class="language-plaintext highlighter-rouge">Date</code> 首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存的响应。客户端也可以通过 <code class="language-plaintext highlighter-rouge">Age</code> 首部来检测缓存的响应，通过这个首部可以分辨出这条响应的使用期。</p> <h2 id="六缓存的拓扑结构">六、缓存的拓扑结构</h2> <p>缓存可以是单个用户专用的，也可以是数千名用户共享的。专用缓存被称为<strong>私有缓存</strong>（private cache）。私有缓存是个人的缓存，包含了单个用户最常用的页面（参见图 7-7a）。共享的缓存被称为<strong>公有缓存</strong>（public cache）。公有缓存中包含了某个用户团体的常用页面（参见图 7-7b）。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="公有和私有缓存" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-7 公有和私有缓存 </div> <h3 id="61-私有缓存">6.1 私有缓存</h3> <p>私有缓存不需要很大的动力或存储空间，这样就可以将其做得很小，很便宜。Web 浏览器中有内建的私有缓存 —— 大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的大小和各种设置。还可以去看看浏览器的缓存中有些什么内容。</p> <h3 id="62-公有代理缓存">6.2 公有代理缓存</h3> <p>公有缓存是特殊的共享代理服务器，被称为<strong>缓存代理服务器</strong>（caching proxy server），或者更常见地被称为<strong>代理缓存</strong>（proxy cache）。代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。</p> <p>在图 7-8a 中，每个客户端都会重复地访问一个（还不在私有缓存中的）新的“热门”文档。每个私有缓存都要获取同一份文档，这样它就会多次穿过网络。而如图 7-8b 所示，使用共享的公有缓存时，对于这个流行的对象，缓存只要取一次就行了，它会用共享的副本为所有的请求服务，以降低网络流量。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="共享的公有缓存可以降低网络流量" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图7-8 共享的公有缓存可以降低网络流量 </div> <h3 id="63-代理缓存的层次结构">6.3 代理缓存的层次结构</h3> <p>在实际中，实现<strong>层次化</strong>（hierarchy）的缓存是很有意义的，在这种结构中，在较小缓存中未命中的请求会被导向较大的<strong>父缓存</strong>（parent cache），由它来为剩下的那些“提炼过的”流量提供服务。图 7-9 显示了一个两级的缓存层次结构。其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="在两级的缓存层次结构中访问文档" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-9 在两级的缓存层次结构中访问文档 </div> <p>我们希望大部分用户都能在附近的第一级缓存中命中（参见图 7-9a）。如果没有命中，较大的父缓存可能能够处理它们的请求（参见图 7-9b）。在缓存层次结构很深的情况下，请求可能要穿过很长一溜缓存，但每个拦截代理都会添加一些性能损耗，当代理链路变得很长的时候，这种性能损耗会变得非常明显。</p> <h3 id="64-网状缓存内容路由以及对等缓存">6.4 网状缓存、内容路由以及对等缓存</h3> <p>有些网络结构会构建复杂的<strong>网状缓存</strong>（cache mesh），而不是简单的缓存层次结构。网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为<strong>内容路由器</strong>（content router）。</p> <p>网状缓存中为内容路由设计的缓存（除了其他任务之外）要完成下列所有功能。</p> <ul> <li>根据 URL 在父缓存或原始服务器之间进行动态选择。</li> <li>根据 URL 动态地选择一个特定的父缓存。</li> <li>前往父缓存之前，在本地缓存中搜索已缓存的副本。</li> <li>允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的缓存。</li> </ul> <p>缓存之间这些更为复杂的关系允许不同的组织互为<strong>对等</strong>（peer）实体，将它们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为<strong>兄弟缓存</strong>（sibling cache）（参见图 7-10）。HTTP 并不支持兄弟缓存，所以人们通过一些协议对 HTTP 进行了扩展，比如<strong>因特网缓存协议</strong>（Internet Cache Protocol，ICP）和<strong>超文本缓存协议</strong>（HyperText Caching Protocol，HTCP）。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="兄弟缓存" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 7-10 兄弟缓存 </div> <h2 id="七缓存的处理步骤">七、缓存的处理步骤</h2> <p>现代的商业化代理缓存相当地复杂。这些缓存构建得非常高效，可以支持 HTTP 和其他一些技术的各种高级特性。但除了一些微妙的细节之外，Web 缓存的基本工作原理大多很简单。对一条 HTTP <code class="language-plaintext highlighter-rouge">GET</code> 报文的基本缓存处理过程包括 7 个步骤（参见图 7-11）。</p> <ol> <li>接收 —— 缓存从网络中读取抵达的请求报文。缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。</li> <li>解析 —— 缓存对报文进行解析，提取出 URL 和各种首部。缓存将请求报文解析为片断，将首部的各个部分放入易于操作的数据结构中。这样，缓存软件就更容易处理首部字段并修改它们了。</li> <li>查询 —— 缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）。缓存获取了 URL，查找本地副本。本地副本可能存储在内存、本地磁盘，甚至附近的另一台计算机中。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。如果本地没有这个文档，它可以根据情形和配置，到原始服务器或父代理中去取，或者返回一条错误信息。已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。已缓存对象中还包含了一些<strong>元数据</strong>（metadata），用来记录对象在缓存中停留了多长时间，以及它被用过多少次等。</li> <li>新鲜度检测 —— 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。HTTP 通过缓存将服务器文档的副本保留一段时间。在这段时间里，都认为文档是“新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但一旦已缓存副本停留的时间太长，超过了文档的<strong>新鲜度限值</strong>（freshness limit），就认为对象“过时”了，在提供该文档之前，缓存要再次与服务器进行确认，以查看文档是否发生了变化。客户端发送给缓存的所有请求首部自身都可以强制缓存进行再验证，或者完全避免验证，这使得事情变得更加复杂了。HTTP 有一组非常复杂的新鲜度检测规则，缓存产品支持的大量配置选项，以及与非 HTTP 新鲜度标准进行互通的需要则使问题变得更加严重了。</li> <li>创建响应 —— 缓存会用新的首部和已缓存的主体来构建一条响应报文。我们希望缓存的响应看起来就像来自原始服务器的一样，缓存将已缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础首部进行了修改和扩充。缓存负责对这些首部进行改造，以便与客户端的要求相匹配。比如，服务器返回的可能是一条 HTTP/1.0 响应（甚至是 HTTP/0.9 响应），而客户端期待的是一条HTTP/1.1 响应，在这种情况下，缓存必须对首部进行相应的转换。缓存还会向其中插入新鲜度信息（<code class="language-plaintext highlighter-rouge">Cache-Control</code>、<code class="language-plaintext highlighter-rouge">Age</code> 以及 <code class="language-plaintext highlighter-rouge">Expires</code> 首部），而且通常会包含一个 <code class="language-plaintext highlighter-rouge">Via</code> 首部来说明请求是由一个代理缓存提供的。注意，缓存不应该调整 <code class="language-plaintext highlighter-rouge">Date</code> 首部。<code class="language-plaintext highlighter-rouge">Date</code> 首部表示的是原始服务器最初产生这个对象的日期。</li> <li>发送 —— 缓存通过网络将响应发回给客户端。一旦响应首部准备好了，缓存就将响应回送给客户端。和所有代理服务器一样，代理缓存要管理与客户端之间的连接。高性能的缓存会尽力高效地发送数据，通常可以避免在本地缓存和网络 I/O 缓冲区之间进行文档内容的复制。</li> <li>日志 —— 缓存可选地创建一个日志文件条目来描述这个事务。大多数缓存都会保存日志文件以及与缓存的使用有关的一些统计数据。每个缓存事务结束之后，缓存都会更新缓存命中和未命中数目的统计数据（以及其他相关的度量值），并将条目插入一个用来显示请求类型、URL 和所发生事件的日志文件。最常见的缓存日志格式为 Squid 日志格式和网景的可扩展通用日志格式，但很多缓存产品都允许用户创建自定义的日志文件。</li> </ol> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="处理一个新鲜的缓存命中" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-11 处理一个新鲜的缓存命中 </div> <p>图 7-12 以简化形式显示了缓存是如何处理请求，以 <code class="language-plaintext highlighter-rouge">GET</code> 一个 URL 的。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="缓存 GET 请求的流程图" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-12 缓存 GET 请求的流程图 </div> <h2 id="八保持副本的新鲜">八、保持副本的新鲜</h2> <p>HTTP 有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP 将这些简单的机制称为<strong>文档过期</strong>（document expiration）和服<strong>务器再验证</strong>（server revalidation）。</p> <h3 id="81-文档过期">8.1 文档过期</h3> <p>通过特殊的 HTTP <code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部和 <code class="language-plaintext highlighter-rouge">Expires</code> 首部， HTTP 让原始服务器向每个文档附加了一个“过期日期”（参见图 7-13）。这些首部说明了在多长时间内可以将这些内容视为新鲜的。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Expires 首部和 Cache-Control 首部" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-13 Expires 首部和 Cache-Control 首部 </div> <p>在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系 —— 当然，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果被修改过，就要获取一份新鲜（带有新的过期日期）的副本。</p> <h3 id="82-过期日期和使用期">8.2 过期日期和使用期</h3> <p>服务器用 HTTP/1.0+ 的 <code class="language-plaintext highlighter-rouge">Expires</code> 首部或HTTP/1.1 的 <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 响应首部来指定过期日期，同时还会带有响应主体。<code class="language-plaintext highlighter-rouge">Expires</code> 首部和 <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 首部所做的事情本质上是一样的，<code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部。绝对日期依赖于计算机时钟的正确设置（注：而本地计算机时钟有可能被恶意篡改）。表 7-2 列出了各种过期响应首部。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="过期响应首部" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 7-2 过期响应首部 </div> <h3 id="83-服务器再验证">8.3 服务器再验证</h3> <p>仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别；这只是意味着到了要进行核对的时间了。这种情况被称为“<strong>服务器再验证</strong>”，说明<strong>缓存需要询问原始服务器文档是否发生了变化</strong>。</p> <ul> <li>如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。</li> <li>如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。</li> </ul> <p>HTTP 协议要求行为正确的缓存返回下列内容之一：</p> <ul> <li>“足够新鲜”的已缓存副本;</li> <li>与服务器进行过再验证，确认其仍然新鲜的已缓存副本;</li> <li>如果需要与之进行再验证的原始服务器出故障了， 就返回一条错误报文“;</li> <li>附有警告信息说明内容可能不正确的已缓存副本。</li> </ul> <h3 id="84-用条件方法进行再验证">8.4 用条件方法进行再验证</h3> <p>HTTP 的条件方法可以高效地实现再验证。HTTP 允许缓存向原始服务器发送一个“条件 <code class="language-plaintext highlighter-rouge">GET</code>”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。通过这种方式，将新鲜度检测和对象获取结合成了单个条件 <code class="language-plaintext highlighter-rouge">GET</code>。向 <code class="language-plaintext highlighter-rouge">GET</code> 请求报文中添加一些特殊的条件首部，就可以发起条件 <code class="language-plaintext highlighter-rouge">GET</code>。只有条件为真时，Web 服务器才会返回对象。</p> <p>HTTP 定义了 5 个条件请求首部。对缓存再验证来说最有用的 2 个首部是 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 和 <code class="language-plaintext highlighter-rouge">If-None-Match</code>。所有的条件首部都以前缀 <code class="language-plaintext highlighter-rouge">If-</code> 开头。表 7-3 列出了在缓存再验证中使用的条件请求首部。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="缓存再验证中使用的两个条件首部" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 7-3 缓存再验证中使用的两个条件首部 </div> <h3 id="85-if-modified-since-date-再验证">8.5 If-Modified-Since: Date 再验证</h3> <p>最常见的缓存再验证首部是 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code>。<code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 再验证请求通常被称为 IMS 请求。只有自某个日期之后资源发生了变化的时候，IMS 请求才会指示服务器执行请求：</p> <ul> <li>如果自指定日期后，文档被修改了，<code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 条件就为真，通常 <code class="language-plaintext highlighter-rouge">GET</code> 就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。</li> <li>如果自指定日期后，文档没被修改过，条件就为假，会向客户端返回 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应报文，为了提高有效性，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如，<code class="language-plaintext highlighter-rouge">Content-Type</code> 首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。</li> </ul> <p><code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 首部可以与 <code class="language-plaintext highlighter-rouge">Last-Modified</code> 服务器响应首部配合工作。原始服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行再验证时，就会包含一个 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 首部，其中携带有最后修改已缓存副本的日期：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">If-Modified-Since: &lt;cached last-modified date&gt;
</span></code></pre></div></div> <p>如果在此期间内容被修改了，最后的修改日期就会有所不同，原始服务器就会回送新的文档。否则，服务器会注意到缓存的最后修改日期与服务器文档当前的最后修改日期相符，会返回一个 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="如果未发生变化，If-Modified-Since 再验证会返回 304 响应，如果发生了变化，就返回带有新主体的 200 响应" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-14 如果未发生变化，If-Modified-Since 再验证会返回 304 响应，如果发生了变化，就返回带有新主体的 200 响应 </div> <p>注意，有些 Web 服务器并没有将 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 作为真正的日期来进行比对。相反，它们在 IMS 日期和最后修改日期之间进行了字符串匹配。这样得到的语义就是“如果最后的修改不是在这个确定的日期进行的”，而不是“如果在这个日期之后没有被修改过”。将最后修改日期作为某种序列号使用时，这种替代语义能够很好地识别出缓存是否过期，但这会妨碍客户端将 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 首部用于真正基于时间的一些目的。</p> <h3 id="86-if-none-match-实体标签再验证">8.6 If-None-Match: 实体标签再验证</h3> <p>有些情况下仅使用最后修改日期进行再验证是不够的。</p> <ul> <li>有些文档可能会被周期性地重写（比如，从一个后台进程中写入），但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。</li> <li>有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据（比如对拼写或注释的修改）。</li> <li>有些服务器无法准确地判定其页面的最后修改日期。</li> <li>有些服务器提供的文档会在亚秒间隙发生变化（比如，实时监视器），对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。</li> </ul> <p>为了解决这些问题，HTTP 允许用户对被称为实体标签 <code class="language-plaintext highlighter-rouge">ETag</code> 的“版本标识符”进行比较。实体标签是附加到文档上的任意标签（引用字符串）。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用 <code class="language-plaintext highlighter-rouge">If-None-Match</code> 条件首部来 <code class="language-plaintext highlighter-rouge">GET</code> 文档的新副本了。</p> <p>在图 7-15 中，缓存中有一个实体标签为 <code class="language-plaintext highlighter-rouge">v2.6</code> 的文档。它会与原始服务器进行再验证，如果标签 <code class="language-plaintext highlighter-rouge">v2.6</code> 不再匹配，就会请求一个新对象。在图 7-15 中，标签仍然与之匹配，因此会返回一条 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="因为实体标签仍然匹配，If-None-Match 再验证成功" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-15 因为实体标签仍然匹配，If-None-Match 再验证成功 </div> <p>如果服务器上的实体标签已经发生了变化（可能变成了 <code class="language-plaintext highlighter-rouge">v3.0</code>），服务器会在一个 <code class="language-plaintext highlighter-rouge">200 OK</code> 响应中返回新的内容以及相应的新 <code class="language-plaintext highlighter-rouge">Etag</code>。</p> <p>可以在 <code class="language-plaintext highlighter-rouge">If-None-Match</code> 首部包含几个实体标签，告诉服务器，缓存中已经存在带有这些实体标签的对象副本：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">If-None-Match: "v2.6"
If-None-Match: "v2.4", "v2.5", "v2.6"
If-None-Match: "foobar", "A34FAC0095", "Profiles in Courage"
</span></code></pre></div></div> <h3 id="87-强弱验证器">8.7 强弱验证器</h3> <p>缓存可以用实体标签来判断，与服务器相比，已缓存版本是不是最新的（与使用最近修改日期的方式很像）。从这个角度来看，实体标签和最近修改日期都是<strong>缓存验证器</strong>（cache validator）。</p> <p>有时，服务器希望在对文档进行一些非实质性或不重要的修改时，不要使所有的已缓存副本都失效。HTTP/1.1 支持“弱验证器”，如果只对内容进行了少量修改，就允许服务器声明那是“足够好”的等价体。</p> <p>只要内容发生了变化，强验证器就会变化。弱验证器允许对一些内容进行修改，但内容的主要含义发生变化时，通常它还是会变化的。有些操作不能用弱验证器来实现（比如有条件地获取部分内容），所以，服务器会用前缀 <code class="language-plaintext highlighter-rouge">W/</code> 来标识弱验证器。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">ETag: W/"v2.6"
If-None-Match: W/"v2.6"
</span></code></pre></div></div> <p>不管相关的实体值以何种方式发生了变化，强实体标签都要发生变化。而相关实体在语义上发生了比较重要的变化时，弱实体标签也应该发生变化。</p> <p>注意，原始服务器一定不能为两个不同的实体重用一个特定的强实体标签值，或者为两个语义不同的实体重用一个特定的弱实体标签值。缓存条目都可能会留存任意长的时间，与过期时间无关， 有人可能希望当缓存验证条目时，绝对不会再次使用在过去某一时刻获得的验证器，这种愿望可能不太现实。</p> <h3 id="88-什么时候应该使用实体标签和最近修改日期">8.8 什么时候应该使用实体标签和最近修改日期</h3> <p>如果服务器回送了一个实体标签，HTTP/1.1 客户端就必须使用实体标签验证器。如果服务器只回送了一个 <code class="language-plaintext highlighter-rouge">Last-Modified</code> 值，客户端就可以使用 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 验证。如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样 HTTP/1.0 和 HTTP/1.1 缓存就都可以正确响应了。</p> <p>除非 HTTP/1.1 原始服务器无法生成实体标签验证器，否则就应该发送一个出去，如果使用弱实体标签有优势的话，发送的可能就是个弱实体标签，而不是强实体标签。而且，最好同时发送一个最近修改值。</p> <p>如果 HTTP/1.1 缓存或服务器收到的请求既带有 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code>，又带有实体标签条件首部，那么只有这两个条件都满足时，才能返回 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应。</p> <h2 id="九控制缓存的能力">九、控制缓存的能力</h2> <p>服务器可以通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以：</p> <ul> <li>附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: no-store</code> 首部到响应中去。</li> <li>附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: no-cache</code> 首部到响应中去。</li> <li>附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: must-revalidate</code> 首部到响应中去。</li> <li>附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 首部到响应中去。</li> <li>附加一个 <code class="language-plaintext highlighter-rouge">Expires</code> 日期首部到响应中去。</li> <li>不附加过期信息，让缓存确定自己的过期日期。</li> </ul> <h3 id="91-no-store-与-no-cache-响应首部">9.1 no-Store 与 no-Cache 响应首部</h3> <p>HTTP/1.1 提供了几种限制对象缓存，或限制提供已缓存对象的方式，以维持对象的新鲜度。<code class="language-plaintext highlighter-rouge">no-store</code> 首部和 <code class="language-plaintext highlighter-rouge">no-cache</code> 首部可以防止缓存提供未经证实的已缓存对象：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Pragma: no-cache
Cache-Control: no-store
Cache-Control: no-cache
</span></code></pre></div></div> <p>标识为 <code class="language-plaintext highlighter-rouge">no-store</code> 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条 <code class="language-plaintext highlighter-rouge">no-store</code> 响应，然后删除对象。</p> <p>标识为 <code class="language-plaintext highlighter-rouge">no-cache</code> 的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。这个首部使用 do-not-serve-from-cache-without-revalidation 这个名字会更恰当一些。</p> <p>HTTP/1.1 中提供 <code class="language-plaintext highlighter-rouge">Pragma: no-cache</code> 首部是为了兼容于 HTTP/1.0+。除了与只理解 <code class="language-plaintext highlighter-rouge">Pragma: no-cache</code> 的 HTTP/1.0 应用程序进行交互时，HTTP 1.1 应用程序都应该使用 <code class="language-plaintext highlighter-rouge">Cache-Control: no-cache</code>。</p> <h3 id="92-max-age-响应首部">9.2 max-age 响应首部</h3> <p><code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。还有一个 <code class="language-plaintext highlighter-rouge">s-maxage</code> 首部，其行为与 <code class="language-plaintext highlighter-rouge">max-age</code> 类似，但仅适用于共享（公有）缓存：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
</span></code></pre></div></div> <p>服务器可以请求缓存不要缓存文档，或者将最大使用期设置为零，从而在每次访问的时候都进行刷新：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Cache-Control: max-age=0
Cache-Control: s-maxage=0
</span></code></pre></div></div> <h3 id="93-expires-响应首部">9.3 Expires 响应首部</h3> <p>不推荐使用 <code class="language-plaintext highlighter-rouge">Expires</code> 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。可以通过计算过期值和日期值之间的秒数差来计算类似的新鲜生存期：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Expires: Fri, 05 Jul 2002, 05:00:00 GMT
</span></code></pre></div></div> <p>有些服务器还会回送一个 <code class="language-plaintext highlighter-rouge">Expires: 0</code> 响应首部，试图将文档置于永远过期的状态，但这种语法是非法的，可能给某些软件带来问题。应该试着支持这种结构的输入，但不应该产生这种结构的输出。</p> <h3 id="94-must-revalidate-响应首部">9.4 must-revalidate 响应首部</h3> <p>可以配置缓存，使其提供一些陈旧（过期）的对象，以提高性能。如果原始服务器希望缓存严格遵守过期信息，可以在原始响应中附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: must-revalidate</code> 首部。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Cache-Control: must-revalidate
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Cache-Control: must-revalidate</code> 响应首部告诉缓存，在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本。缓存仍然可以随意提供新鲜的副本。如果在缓存进行 <code class="language-plaintext highlighter-rouge">must-revalidate</code> 新鲜度检查时，原始服务器不可用，缓存就必须返回一条 <code class="language-plaintext highlighter-rouge">504 Gateway Timeout</code> 错误。</p> <h3 id="95-试探性过期">9.5 试探性过期</h3> <p>如果响应中没有 <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 首部，也没有 <code class="language-plaintext highlighter-rouge">Expires</code> 首部，缓存可以计算出一个试探性最大使用期。可以使用任意算法，但如果得到的最大使用期大于 24 小时，就应该向响应首部添加一个 Heuristic Expiration Warning（试探性过期警告，警告 13）首部。据我们所知，很少有浏览器会为用户提供这种警告信息。LM-Factor 算法是一种很常用的试探性过期算法，如果文档中包含了最后修改日期，就可以使用这种算法。LM-Factor 算法将最后修改日期作为依据，来估计文档有多么易变。算法的逻辑如下所示。</p> <ul> <li>如果已缓存文档最后一次修改发生在很久以前，它可能会是一份稳定的文档，不太会突然发生变化，因此将其继续保存在缓存中会比较安全。</li> <li>如果已缓存文挡最近被修改过，就说明它很可能会频繁地发生变化，因此在与服务器进行再验证之前，只应该将其缓存很短一段时间。</li> </ul> <p>实际的 LM-Factor 算法会计算缓存与服务器对话的时间跟服务器声明文档最后被修改的时间之间的差值，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时间。下面是 LM-factor 算法的 Perl 伪代码：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$time_since_modify</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$server_Date</span> <span class="o">-</span> <span class="nv">$server_Last_Modified</span><span class="p">);</span>
<span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nv">$time_since_modify</span> <span class="o">*</span> <span class="nv">$lm_factor</span><span class="p">);</span>
</code></pre></div></div> <p>图 7-16 以图形方式给出了 LM-factor 的新鲜周期。图中用交叉线画出的阴影表示的是将 LM-factor 设置为 0.2 计算出的新鲜周期。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="用 LM-factor 算法计算新鲜周期" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-16 用 LM-factor 算法计算新鲜周期 </div> <p>通常人们会为试探性新鲜周期设置上限，这样它们就不会变得太大了。尽管比较保守的站点会将这个值设置为一天，但通常站点会将其设置为一周。</p> <p>如果最后修改日期也没有的话，缓存就没什么信息可利用了。缓存通常会为没有任何新鲜周期线索的文档分配一个默认的新鲜周期（通常是一个小时或一天）。有时，比较保守的缓存会将这种试探性新鲜生存期设置为 0，强制缓存在每次将其提供给客户端之前，都去验证一下这些数据仍然是新鲜的。</p> <p>与试探性新鲜计算有关的最后一点是 —— 它们可能比你想象的要常见得多。很多原始服务器仍然不会产生 <code class="language-plaintext highlighter-rouge">Expires</code> 和 <code class="language-plaintext highlighter-rouge">max-age</code> 首部。选择缓存过期的默认时间时要特别小心!</p> <h3 id="96-客户端的新鲜度限制">9.6 客户端的新鲜度限制</h3> <p>Web 浏览器都有 Refresh（刷新）或 Reload（重载）按钮，可以强制对浏览器或代理缓存中可能过期的内容进行刷新。Refresh 按钮会发布一个附加了 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 请求首部的 <code class="language-plaintext highlighter-rouge">GET</code> 请求，这个请求会强制进行再验证，或者无条件地从服务器获取文档。Refresh 的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。客户端可以用 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 请求首部来强化或放松对过期时间的限制。有些应用程序对文档的新鲜度要求很高（比如人工刷新按钮），对这些应用程序来说，客户端可以用 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部使过期时间更严格。另一方面，作为提高性能、可靠性或开支的一种折衷方式，客户端可能会放松新鲜度要求。表 7-4 对 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 请求指令进行了总结。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Cache-Control 请求指令" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 7-4 Cache-Control 请求指令 </div> <h3 id="97-注意事项">9.7 注意事项</h3> <p>文档过期系统并不是一个完美的系统。如果发布者不小心分配了一个很久之后的过期日期，在文档过期之前，她要对文档做的任何修改都不一定能显示在所有缓存中。</p> <p>因此，很多发布者都不会使用很长的过期日期。而且，很多发布者甚至都不使用过期日期，这样缓存就很难确定文档会在多长时间内保持新鲜了。</p> <h2 id="十设置缓存控制">十、设置缓存控制</h2> <p>不同的 Web 服务器为 HTTP Cache-Control 和 Expiration 首部的设置提供了一些不同的机制。本节简要介绍了流行的 Apache Web 服务器是怎样支持缓存控制的。</p> <h3 id="101-控制-apache-的-http-首部">10.1 控制 Apache 的 HTTP 首部</h3> <p>Apache Web 服务器提供了几种设置 HTTP 缓存控制首部的机制。其中很多机制在默认情况下都没有启动——你要启动它们（有些情况下先要获取 Apache 的扩展模块）。下面是对某些 Apache 特性的简要描述。</p> <ul> <li>mod_headers：通过 mod_headers 模块可以对单独的首部进行设置。装载了这个模块，就可以用设置单个 HTTP 首部的指令来扩充 Apache 的配置文件了。还可以将这些设置与 Apache 的常用表达式以及过滤器结合在一起使用，将这些首部与个别内容关联起来。这里有一个配置实例，这个例子将某目录下所有的 HTML 文件都标识为非缓存的：</li> </ul> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Files *。html&gt;
Header set Cache-control no-cache
&lt;/Files&gt;
</code></pre></div></div> <ul> <li>mod_expires：mod_expires 模块提供的程序逻辑可以自动生成带有正确过期日期的 Expires 首部。通过这个模块，就可以将文档的过期日期设置为对其最后一次被访问之后或者其最近修改日期之后的某一时间段。通过这个模块可以为不同的文件类型设置不同的过期日期，还可以使用便捷的详尽描述信息来描述其缓存能力，比如 “access plus 1 month（自访问之后起1个月）”。这里有几个例子：</li> </ul> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"
</code></pre></div></div> <ul> <li>mod_cern_meta：通过 mod_cern_meta 模块可以将一个包含 HTTP 首部的文件与特定的对象联系起来。启动这个模块时，就创建了一组“元文件”，每个需要控制的文档一个，而且还会为每个元文件添加所期望的首部。</li> </ul> <h3 id="102-通过-http-equiv-控制-html-缓存">10.2 通过 HTTP-EQUIV 控制 HTML 缓存</h3> <p>HTTP 服务器响应首部用于回送文档的到期信息以及缓存控制信息。Web 服务器与配置文件进行交互，为所提供的文档分配正确的 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部。为了让作者在无需与 Web 服务器的配置文件进行交互的情况下，能够更容易地为所提供的 HTML 文档分配 HTTP 首部信息，HTML 2.0 定义了 <code class="language-plaintext highlighter-rouge">&lt;META HTTP-EQUIV&gt;</code> 标签。这个可选的标签位于 HTML 文档的顶部，定义了应该与文档有所关联的 HTTP 首部。这里有一个 <code class="language-plaintext highlighter-rouge">&lt;META HTTP-EQUIV&gt;</code> 标签设置的例子，它将 HTML 文档标记为非缓冲的：</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;HTML&gt;</span>
<span class="nt">&lt;HEAD&gt;</span>
<span class="nt">&lt;TITLE&gt;</span>My Document<span class="nt">&lt;/TITLE&gt;</span>
<span class="nt">&lt;META</span> <span class="na">HTTP-EQUIV=</span><span class="s">"Cache-control"</span> <span class="na">CONTENT=</span><span class="s">"no-cache"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/HEAD&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
</code></pre></div></div> <p>最初，HTTP-EQUIV标签是给 Web 服务器使用的。如 HTML RFC 1866 所述，Web 服务器应该为 HTML 解析 <code class="language-plaintext highlighter-rouge">&lt;META HTTP-EQUIV&gt;</code> 标签，并将规定的首部插入 HTTP 响应中：</p> <p>HTTP 服务器可以用此信息来处理文档。特别是，它可以在为请求此文档的报文所发送的响应中包含一个首部字段：首部名称是从 <code class="language-plaintext highlighter-rouge">HTTP-EQUIV</code> 属性值中获取的，首部值是从 <code class="language-plaintext highlighter-rouge">CONTENT</code> 属性值中获取的。</p> <p>不幸的是，支持这个可选特性会增加服务器的额外负载，这些值也只是静态的，而且它只支持 HTML，不支持很多其他的文件类型，所以很少有 Web 服务器和代理支持此特性。</p> <p>但是，有些浏览器确实会解析并在 HTML 内容中使用 <code class="language-plaintext highlighter-rouge">HTTP-EQUIV</code> 标签，像对待真的 HTTP 首部那样来处理嵌入式首部（参见图 7-17）。这样的效果并不好，因为支持 <code class="language-plaintext highlighter-rouge">HTTP-EQUIV</code> 标签的 HTML 浏览器使用的 <code class="language-plaintext highlighter-rouge">Cache-control</code> 规则可能会与拦截代理缓存所用的规则有所不同。这样会使缓存的过期处理行为发生混乱。</p> <p>总之，<code class="language-plaintext highlighter-rouge">&lt;META HTTP-EQUIV&gt;</code> 标签并不是控制文档缓存特性的好方法。通过配置正确的服务器发出 HTTP 首部，是传送文档缓存控制请求的唯一可靠的方法。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="大多数软件都会忽略 HTTP-EQUIV 标签，所以这些标签可能会带来一些问题" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-17 大多数软件都会忽略 HTTP-EQUIV 标签，所以这些标签可能会带来一些问题 </div> <h2 id="十一详细算法">十一、详细算法</h2> <p>HTTP 规范提供了一个详细，但有点儿含糊不清而且经常会让人混淆的算法，来计算文档的使用期以及缓存的新鲜度。本节会对 HTTP 的新鲜度计算算法进行详细的讨论（参见图 7-12 中那个“足够新鲜？”菱形框），并对此算法的动机进行解释。本节最适用于那些研究缓存内部机制的人。为了便于说明 HTTP 规范中的内容，我们使用了 Perl 伪代码。</p> <h3 id="111-使用期和新鲜生存期">11.1 使用期和新鲜生存期</h3> <p>为了分辨已缓存文档是否足够新鲜，缓存只需要计算两个值：已缓存副本的使用期（age），和已缓存副本的新鲜生存期（freshness lifetime）。如果已缓存副本的时长小于新鲜生存期，就说明副本足够新鲜，可以使用。用 Perl 表示为：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$is_fresh_enough</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$age</span> <span class="o">&lt;</span> <span class="nv">$freshness_lifetime</span><span class="p">);</span>
</code></pre></div></div> <p>文档的使用期就是自从服务器将其发送出来（或者最后一次被服务器再验证）之后“老去”的总时间。”缓存可能不知道文档响应是来自上游缓存，还是来自服务器的，所以它不能假设文档是最新的。它必须根据显式的 <code class="language-plaintext highlighter-rouge">Age</code> 首部（优先），或者通过对服务器生成的 <code class="language-plaintext highlighter-rouge">Date</code> 首部的处理，来确定文档的使用期。</p> <p>文档的新鲜生存期表明，已缓存副本在经过多长时间之后，就会因新鲜度不足而无法再向客户端提供了。新鲜生存期考虑了文档的过期日期，以及客户端可能请求的任何新鲜度覆盖范围。</p> <p>有些客户端可能愿意接受稍微有些过期的文档（使用 <code class="language-plaintext highlighter-rouge">Cache-Control: max-stale</code> 首部）。有些客户端可能无法接受会在近期过期的文档（使用 <code class="language-plaintext highlighter-rouge">Cache-Control: min-fresh</code> 首部）。缓存将服务器过期信息与客户端的新鲜度要求结合在一起，以确定最大的新鲜生存期。</p> <h3 id="112-使用期的计算">11.2 使用期的计算</h3> <p>响应的使用期就是服务器发布响应（或服务器对其进行了再验证）之后经过的总时间。使用期包含了响应在因特网路由器和网关中游荡的时间，在中间节点缓存中存储的时间，以及响应在你的缓存中停留的时间。例 7-1 给出了使用期计算的伪代码。</p> <p>例 7-1 HTTP/1.1 使用期计算算法计算了已缓存文档的总体使用期</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$time_got_response</span> <span class="o">-</span> <span class="nv">$Date_header_value</span><span class="p">);</span>
<span class="nv">$corrected_apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="nv">$apparent_age</span><span class="p">,</span> <span class="nv">$Age_header_value</span><span class="p">);</span>
<span class="nv">$response_delay_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$time_got_response</span> <span class="o">-</span> <span class="nv">$time_issued_request</span><span class="p">);</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">=</span> <span class="nv">$corrected_apparent_age</span> <span class="o">+</span> <span class="nv">$response_delay_estimate</span><span class="p">;</span>
<span class="nv">$how_long_copy_has_been_in_our_cache</span> <span class="o">=</span> <span class="nv">$current_time</span> <span class="o">-</span> <span class="nv">$time_got_response</span><span class="p">;</span>
<span class="nv">$age</span> <span class="o">=</span> <span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">+</span> <span class="nv">$how_long_copy_has_been_in_our_cache</span><span class="p">;</span> 
</code></pre></div></div> <p>HTTP 使用期计算的细节有点儿棘手，但其基本概念很简单。响应到达缓存时，缓存可以通过查看 <code class="language-plaintext highlighter-rouge">Date</code> 首部或 <code class="language-plaintext highlighter-rouge">Age</code> 首部来判断响应已使用的时间。缓存还能记录下文档在本地缓存中的停留时间。把这些值加在一起，就是响应的总使用期。HTTP 用一些魔法对时钟偏差和网络时延进行了补偿，但基本计算非常简单：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$age</span> <span class="o">=</span> <span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">+</span> <span class="nv">$how_long_copy_has_been_in_our_cache</span><span class="p">;</span> 
</code></pre></div></div> <p>缓存可以很方便地判断出已缓存副本已经在本地缓存了多长时间（这就是简单的簿记问题），但很难确定响应抵达缓存时的使用期，因为不是所有服务器的时钟都是同步的，而且我们也不知道响应到过哪里。完善的使用期计算算法会试着对此进行补偿。</p> <h4 id="1表面使用期是基于-date-首部的">（1）表面使用期是基于 Date 首部的</h4> <p>如果所有的计算机都共享同样的、完全精确的时钟，已缓存文档的使用期就可以是文档的“表面使用期”——当前时间减去服务器发送文档的时间。服务器发送时间就是 <code class="language-plaintext highlighter-rouge">Date</code> 首部的值。最简单的起始时间计算可以直接使用表面时间：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">$time_got_response</span> <span class="o">-</span> <span class="nv">$Date_header_value</span><span class="p">;</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">=</span> <span class="nv">$apparent_age</span><span class="p">;</span>
</code></pre></div></div> <p>但并不是所有的时钟都实现了良好的同步。客户端和服务器时钟之间可能有数分钟的差别，如果时钟没有设置好的话，甚至会有数小时或数天的区别。</p> <p>Web 应用程序，尤其是缓存代理，要做好与时间值有很大差异的服务器进行交互的准备。这种问题被称为时钟偏差（clock skew）——两台计算机时钟设置的不同。由于时钟偏差的存在， 表面使用期有时会不太准确，而且有时会是负的。</p> <p>如果使用期是负的，就将其设置为零。我们还可以对表面使用期进行完整性检查，以确定它没有大得令人不可思议，不过，实际上，表面使用期可能并没错。我们可能在与一个将文档缓存了很久的父缓存对话（缓存可能还存储了原始的 <code class="language-plaintext highlighter-rouge">Date</code> 首部）：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$time_got_response</span> <span class="o">-</span> <span class="nv">$Date_header_value</span><span class="p">);</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">=</span> <span class="nv">$apparent_age</span><span class="p">;</span>
</code></pre></div></div> <p>要明确 <code class="language-plaintext highlighter-rouge">Date</code> 首部描述的是原始服务器的日期。代理和缓存一定不能修改这个日期!</p> <h4 id="2逐跳使用期的计算">（2）逐跳使用期的计算</h4> <p>这样就可以去除时钟偏差造成的负数使用期了，但对时钟偏差给精确性带来的整体偏差，我们能做的工作很少。文档经过代理和缓存时，HTTP/1.1 会让每台设备都将相对使用期累加到 <code class="language-plaintext highlighter-rouge">Age</code> 首部中去，以此来解决缺乏通用同步时钟的问题。这种方式并不需要进行跨服务器的、端到端的时钟对比。</p> <p>文档经过代理时，<code class="language-plaintext highlighter-rouge">Age</code> 首部值会随之增加。使用 HTTP/1.1 的应用程序应该在 <code class="language-plaintext highlighter-rouge">Age</code> 首部值中加上文档在每个应用程序和网络传输过程中停留的时间。每个中间应用程序都可以很容易地用本地时钟计算出文档的停留时间。</p> <p>但响应链中所有的非 HTTP/1.1 设备都无法识别 <code class="language-plaintext highlighter-rouge">Age</code> 首部，它们会将首部未经修改地转发出去，或者将其删除掉。因此，在 HTTP/1.1 得到普遍应用之前，<code class="language-plaintext highlighter-rouge">Age</code> 首部都将是低估了的相对使用期。</p> <p>除了基于 <code class="language-plaintext highlighter-rouge">Date</code> 计算出来的 <code class="language-plaintext highlighter-rouge">Age</code> 之外，还使用了相对 <code class="language-plaintext highlighter-rouge">Age</code> 值，而且不论是跨服务器的 <code class="language-plaintext highlighter-rouge">Date</code> 值，还是计算出来的 <code class="language-plaintext highlighter-rouge">Age</code> 值都可能被低估，所以会选择使用估计出的两个 <code class="language-plaintext highlighter-rouge">Age</code> 值中最保守的那个（最保守的值就是最老的 <code class="language-plaintext highlighter-rouge">Age</code> 值）。使用这种方式，HTTP 就能容忍 <code class="language-plaintext highlighter-rouge">Age</code> 首部存在的错误，尽管这样可能会搞错究竟哪边更新鲜：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="err">（</span><span class="mi">0</span><span class="err">，</span> <span class="nv">$time_got_response</span> <span class="nv">$Date_header_value</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$corrected_apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="err">（</span><span class="nv">$apparent_age</span><span class="err">，</span> <span class="nv">$Age_header_value</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$corrected_apparent_age</span><span class="p">;</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span>
</code></pre></div></div> <h4 id="3对网络时延的补偿">（3）对网络时延的补偿</h4> <p>事务处理可能会很慢。这是使用缓存的主要动因。但对速度非常慢的网络，或者那些过载的服务器来说，如果文档在网络或服务器中阻塞了很长时间，相对使用期的计算可能会极大地低估文档的使用期。</p> <p><code class="language-plaintext highlighter-rouge">Date</code> 首部说明了文档是在什么时候离开原始服务器的，但并没有说明文档在到缓存的传输过程中花费了多长时间。如果文档的传输经过了一长串的代理和父缓存，网络时延可能会相当大。</p> <p>没有什么简便的方法可以用来测量从服务器到缓存的单向网络时延，但往返时延则比较容易测量。缓存知道它请求文档的时间，以及文档抵达的时间。HTTP/1.1 会在这些网络时延上加上整个往返时延，以便对其进行保守地校正。这个从缓存到服务</p> <p>器再到缓存的时延高估了从服务器到缓存的时延，但它是保守的。如果出错了，它只会使文档看起来比实际使用期要老，并引发不必要的再验证。计算是这样进行的：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="err">（</span><span class="mi">0</span><span class="err">，</span> <span class="nv">$time_got_response</span> <span class="nv">$Date_header_value</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$corrected_apparent_age</span> <span class="o">=</span> <span class="nv">max</span> <span class="err">（</span><span class="nv">$apparent_age</span><span class="err">，</span> <span class="nv">$Age_header_value</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$response_delay_estimate</span> <span class="o">=</span> <span class="err">（</span><span class="nv">$time_got_response</span> <span class="nv">$time_issued_request</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span>
<span class="o">=</span>
<span class="nv">$corrected_apparent_age</span> <span class="o">+</span> <span class="nv">$response_delay_estimate</span><span class="p">;</span>
</code></pre></div></div> <h3 id="113-完整的使用期计算算法">11.3 完整的使用期计算算法</h3> <p>上一节说明了当HTTP 所承载的文档抵达缓存时，如何计算其使用期。只要将这条响应存储到缓存中去，它就会进一步老化。当对缓存中文档的请求到达时，我们需要知道文档在缓存中停留了多长的时间，这样才能计算文档现在的使用期：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$age</span> <span class="o">=</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">+</span>
<span class="nv">$how_long_copy_has_been_in_our_cache</span><span class="p">;</span>
</code></pre></div></div> <p>嗒嗒!这样就有了例 7-1 中给出的完整的 HTTP/1.1 使用期计算算法。这就是简单的簿记问题了——我们知道了文档是什么时候到达缓存的（$time_got_reponse），也知道当前请求是什么时候到达的（刚才），这样停留时间就是两者之差了。所有这些都以图形方式显示在图 7-18 中了。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="已缓存文档的使用期包括在网络和缓存中停留的时间" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-18 已缓存文档的使用期包括在网络和缓存中停留的时间 </div> <h3 id="114-新鲜生存期计算">11.4 新鲜生存期计算</h3> <p>回想一下，我们是在想办法弄清楚已缓存文档是否足够新鲜，是否可以提供给客户端。要回答这个问题，就必须确定已缓存文档的使用期，并根据服务器和客户端限制来计算新鲜生存期。我们刚刚解释了如何计算使用期;现在我们来看看新鲜生存期的计算。</p> <p>文档的新鲜生存期说明了在文档不再新鲜，无法提供给某个特定的客户端之前能够停留多久。新鲜生存期取决于服务器和客户端的限制。服务器上可能有一些与文档的出版变化率有关的信息。那些非常稳定的已归档报告可能会在数年内保持新鲜。期刊可能只在下一期的出版物出来之前的剩余时间内有效——下一周，或是明早6点。</p> <p>客户端可能有些其他指标。如果稍微有些过期的内容速度更快的话，它们可能也愿意接受，或者它们可能希望接收最新的内容。缓存是为用户服务的。必须要满足他们的要求。</p> <h3 id="115-完整的服务器---新鲜度算法">11.5 完整的服务器 - 新鲜度算法</h3> <p>例 7-2 给出了一个用于计算服务器新鲜度限制的 Perl 算法。它会返回文档仍由服务器提供时所能到达的最大使用期。</p> <p>例 7-2 服务器新鲜度限制的计算</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sub </span><span class="nf">server_freshness_limit</span>
<span class="p">{</span> 
 <span class="nb">local</span><span class="p">(</span><span class="nv">$heuristic</span><span class="p">,</span><span class="nv">$server_freshness_limit</span><span class="p">,</span><span class="nv">$time_since_last_modify</span><span class="p">);</span>
 <span class="nv">$heuristic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Max_Age_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$Max_Age_value</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="nv">elseif</span> <span class="p">(</span><span class="nv">$Expires_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$Expires_value</span> <span class="o">-</span> <span class="nv">$Date_value</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="nv">elseif</span> <span class="p">(</span><span class="nv">$Last_Modified_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$time_since_last_modify</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$Date_value</span> <span class="o">-</span> 
<span class="err">　　　　　　　　</span><span class="nv">$Last_Modified_value</span><span class="p">);</span>
 <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nv">$time_since_last_modify</span> <span class="o">*</span>
<span class="err">　　　　　　　　</span><span class="nv">$lm_factor</span><span class="p">);</span>
 <span class="nv">$heuristic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">else</span>
 <span class="p">{</span>
  <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$default_cache_min_lifetime</span><span class="p">;</span>
 <span class="nv">$heuristic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$heuristic</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$server_freshness_limit</span> <span class="o">&gt;</span> <span class="nv">$default_cache_max_lifetime</span><span class="p">)</span>
 <span class="p">{</span> <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$default_cache_max_lifetime</span><span class="p">;</span> <span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$server_freshness_limit</span> <span class="o">&lt;</span> <span class="nv">$default_cache_min_lifetime</span><span class="p">)</span>
 <span class="p">{</span> <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$default_cache_min_lifetime</span><span class="p">;</span> <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span><span class="p">(</span><span class="nv">$server_freshness_limit</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>现在，我们来看看客户端怎样修正服务器为文档指定的使用期限制。例 7-3 显示了一个 Perl 算法，此算法获取了服务器的新鲜度限制并根据客户端的限制对其进行修改。它会返回一个最大使用期，这是在无需再次验证，仍由缓存提供文档的前提下，文档的最大生存时间。</p> <p>例 7-3 客户端新鲜度限制的计算</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sub </span><span class="nf">client_modified_freshness_limit</span>
<span class="p">{</span>
 <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">server_freshness_limit</span><span class="p">(</span> <span class="p">);</span> <span class="c1">## From Example 7-2</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Max_Stale_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Max_Stale_value</span> <span class="o">==</span> <span class="nv">$INT_MAX</span><span class="p">)</span>
 <span class="p">{</span> <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">$INT_MAX</span><span class="p">;</span> <span class="p">}</span>
 <span class="k">else</span>
 <span class="p">{</span> <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">server_freshness_limit</span><span class="p">(</span> <span class="p">)</span> <span class="o">+</span> <span class="nv">$Max_Stale_value</span><span class="p">;</span> <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Min_Fresh_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">min</span><span class="p">(</span><span class="nv">$age_limit</span><span class="p">,</span> <span class="nv">server_freshness_limit</span><span class="p">(</span> <span class="p">)</span> <span class="o">-</span> 
<span class="err">　　　　　　　</span><span class="nv">$Min_Fresh_value_set</span><span class="p">);</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Max_Age_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">min</span><span class="p">(</span><span class="nv">$age_limit</span><span class="p">,</span> <span class="nv">$Max_Age_value</span><span class="p">);</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>整个进程中包含两个变量：文档的使用期及其新鲜度限制。如果使用期小于新鲜度限制，就说明文档“足够新鲜”。例 7-3 中的算法只是考虑了服务器的新鲜度限制，并根据附加的客户端限制对其进行了调整。希望通过本节的介绍能使在 HTTP 规范中描述的比较微妙的过期算法更清晰一些。</p> <h2 id="十二缓存和广告">十二、缓存和广告</h2> <p>读到这里，你一定已经意识到缓存可以提高性能并减少流量。知道缓存可以帮助用户，并为用户提供更好的使用体验，而且缓存也可以帮助网络运营商减少流量。</p> <h3 id="121-发布广告者的两难处境">12.1 发布广告者的两难处境</h3> <p>你可能认为内容提供商会喜欢缓存。毕竟，如果到处都是缓存的话，内容提供商就不需要购买大型的多处理器 Web 服务器来满足用户需求了——他们不需要付过高的网络服务费，一遍一遍地向用户发送同样的数据。更好的一点是，缓存可以将那些漂亮的文章和广告以更快，甚至更好看的方式显示在用户的显示器上，鼓励他们去浏览更多的内容，看更多的广告。这就是内容提供商所希望的!吸引更多的眼球和更多的广告!</p> <p>但这就是困难所在。很多内容提供商的收益都是通过广告实现的 具体来说，每向用户显示一次广告内容，内容提供商就会得到相应的收益。（可能还不到一两便士，但如果一天显示数百万条广告的话，这些钱就会叠加起来!）这就是缓存的问题——它们会向原始服务器隐藏实际的访问次数。如果缓存工作得很好，原始服务器可能根本收不到任何 HTTP 访问，因为这些访问都被因特网缓存吸收了。但如果你的收益是基于访问次数的话，你就高兴不起来了。</p> <h3 id="122-发布者的响应">12.2 发布者的响应</h3> <p>现在，广告商会使用各种类型的“缓存清除”技术来确保缓存不会窃取他们的命中流量。他们会在内容上加上 <code class="language-plaintext highlighter-rouge">no-cache</code> 首部。他们会通过 CGI 网关提供广告。还会在每次访问时重写广告 URL。</p> <p>这些缓存清除技术并不仅用于代理缓存。实际上，现在主要将其用于每个 Web 浏览器中都启用了的缓存。但是，如果某些内容提供商维护其命中率的行为太过火了，就会降低缓存为其站点带来的积极作用。</p> <p>理想情况下，内容提供商会让缓存吸收其流量，而缓存会告诉内容提供商它们拦截了多少次命中。现在，缓存有好几种方式可以做到这一点。</p> <p>一种解决方案就是配置缓存，每次访问时都与原始服务器进行再验证。这样，每次访问时都会将命中推向原始服务器，但通常不会传送任何主体数据。当然，这样会降低事务处理的速度。</p> <h3 id="123-日志迁移">12.3 日志迁移</h3> <p>理想的解决方案是不需要将命中传递给服务器的。毕竟，缓存就可以记录下所有的命中。缓存只要将命中日志发送给服务器就行了。实际上，为了保持内容提供商们的满意度， 有些大型缓存的提供商已经在对缓存日志进行人工处理，并将其传送给受影响的内容提供商了。</p> <p>但是，命中日志很大，很难移动。而缓存日志并没有被标准化或被组织成独立的日志，以传送给单独的内容提供商。而且，这里面还存在着认证和隐私问题。已经有一些高效（和不那么高效的）日志分发策略的建议了。但还没有哪个建议成熟到足以为 Web 软件厂商采用。很多建议都非常复杂，需要联合商业伙伴才能实现。“有几家联合厂商已经开始开发广告收入改造工程的支撑框架了。</p> <h3 id="124-命中计数和使用限制">12.4 命中计数和使用限制</h3> <p>RFC 2227，“HTTP 的简单命中计数和使用限制”中定义了一种简单得多的方案。这个协议向 HTTP 中添加了一个称为 Meter 的首部，这个首部会周期性地将对特定URL 的命中次数回送给服务器。通过这种方式，服务器可以从缓存周期性地获取对已缓存文档命中次数的更新。</p> <p>而且，服务器还能控制在缓存必须向服务器汇报之前，其中的文档还可以使用多少次，或者为缓存文档设置一个时钟超时值。这种控制方式被称为使用限制;通过这种方式，服务器可以对缓存向原始服务器汇报之前，已缓存资源的使用次数进行控制。</p> <h2 id="十三参考">十三、参考</h2> <ul> <li><a href="https：//www.oreilly.com/library/view/http-the-definitive/1565925092/">HTTP 权威指南</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="computer"/><category term="networks"/><category term="http"/><summary type="html"><![CDATA[本文节选自《HTTP 权威指南 - 第4章 连接管理》。]]></summary></entry><entry><title type="html">HTTP 连接管理</title><link href="https://feng-zhang0712.github.io//blog/2024/04-connection-management/" rel="alternate" type="text/html" title="HTTP 连接管理"/><published>2024-10-02T00:00:00+00:00</published><updated>2024-10-02T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/04-connection-management</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/04-connection-management/"><![CDATA[<blockquote> <p>本文节选自《HTTP 权威指南 - 第4章 连接管理》。</p> </blockquote> <p>通过本章，可以了解到：</p> <ul> <li>HTTP 是如何使用 TCP 连接的；</li> <li>TCP 连接的时延、瓶颈以及存在的障碍；</li> <li>HTTP 的优化，包括并行连接、keep-alive（持久连接）和管道化连接；</li> <li>管理连接时应该以及不应该做的事情。</li> </ul> <h2 id="一tcp-连接">一、TCP 连接</h2> <p>客户端应用程序可以打开一条 TCP/IP 连接，连接到可能运行在世界任何地方的服务器应用程序。如图 4-1 展示了当访问 <code class="language-plaintext highlighter-rouge">http：//www.joes-hardware.com：80/power-tools.html</code> 时，浏览器所执行的步骤。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-Web-browser-interacts-with-the-Web-server-over-a-TCP-connection-480.webp 480w,/assets/images/http-the-definitive-guide/the-Web-browser-interacts-with-the-Web-server-over-a-TCP-connection-800.webp 800w,/assets/images/http-the-definitive-guide/the-Web-browser-interacts-with-the-Web-server-over-a-TCP-connection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-Web-browser-interacts-with-the-Web-server-over-a-TCP-connection.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Web 浏览器通过 TCP 连接与 Web 服务器进行交互" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-1 Web 浏览器通过 TCP 连接与 Web 服务器进行交互 </div> <h3 id="11-tcp-的可靠数据管道">1.1 TCP 的可靠数据管道</h3> <p>HTTP 连接实际上就是 TCP 连接及其使用规则。TCP 连接是因特网上的可靠连接。TCP 为 HTTP 提供了一条可靠的比特传输管道。从 TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来（参见图 4-2）。</p> <div class="row justify-content-center"> <div class="col-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-carries-HTTP-data-sequentially-and-error-free-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-carries-HTTP-data-sequentially-and-error-free-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-carries-HTTP-data-sequentially-and-error-free-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-carries-HTTP-data-sequentially-and-error-free.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 会按序、无差错地承载 HTTP 数据" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-2 TCP 会按序、无差错地承载 HTTP 数据 </div> <h3 id="12-tcp-流是分段的由-ip-分组传送">1.2 TCP 流是分段的、由 IP 分组传送</h3> <p>TCP 的数据通过名为 <strong>IP 分组</strong>（或 <strong>IP 数据报</strong>）的小数据块来发送。如图 4-3a 所示，HTTP 就是 “HTTP over TCP over IP” 这个“协议栈”中的最顶层。其安全版本 HTTPS 就是在 HTTP 和 TCP 之间插入了一个（称为 TLS 或 SSL 的）密码加密层（图 4-3b）。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/HTTP-and-HTTPS-network-protocol-stacks-480.webp 480w,/assets/images/http-the-definitive-guide/HTTP-and-HTTPS-network-protocol-stacks-800.webp 800w,/assets/images/http-the-definitive-guide/HTTP-and-HTTPS-network-protocol-stacks-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/HTTP-and-HTTPS-network-protocol-stacks.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP 和 HTTPS 网络协议栈" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-3 HTTP 和 HTTPS 网络协议栈 </div> <p>HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输（参见图 4-4）。所有这些工作都由 TCP/IP 软件来处理，程序员什么都看不到。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-IP-packet-that-carries-the-TCP-segment-480.webp 480w,/assets/images/http-the-definitive-guide/the-IP-packet-that-carries-the-TCP-segment-800.webp 800w,/assets/images/http-the-definitive-guide/the-IP-packet-that-carries-the-TCP-segment-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-IP-packet-that-carries-the-TCP-segment.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="承载 TCP 段的 IP 分组，它承载了 TCP 数据流中的小块数据" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-4 承载 TCP 段的 IP 分组，它承载了 TCP 数据流中的小块数据 </div> <p>每个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址。每个 IP 分组中都包括：</p> <ul> <li>一个 IP 分组首部（通常为20 字节），包含了源和目的 IP 地址、长度和其他一些标记。</li> <li>一个 TCP 段首部（通常为 20 字节），包含了 TCP 端口号、TCP 控制标记，以及用于数据排序和完整性检查的一些数字值</li> <li>一个 TCP 数据块（0 个或多个字节）。</li> </ul> <h3 id="13-保持-tcp-连接持续不断地运行">1.3 保持 TCP 连接持续不断地运行</h3> <p>在任意时刻计算机都可以有几条 TCP 连接处于打开状态。TCP 通过端口号来保持所有这些连接持续不断地运行。</p> <p>IP 地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去。TCP 连接通过 4 个值来识别：</p> \[&lt;源 IP 地址、源端口号、目的 IP 地址、目的端口号&gt;\] <p>这 4 个值一起唯一地定义了一条连接。两条不同的 TCP 连接不能拥有 4 个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。在图 4-5 中，有 4 条连接：<code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">C</code> 和 <code class="language-plaintext highlighter-rouge">D</code>。表 4-1 列出了每个端口的相关信息。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-connection-value-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-connection-value-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-connection-value-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-connection-value.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 连接值" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 4-1 TCP 连接值 </div> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-different-TCP-connections-480.webp 480w,/assets/images/http-the-definitive-guide/4-different-TCP-connections-800.webp 800w,/assets/images/http-the-definitive-guide/4-different-TCP-connections-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-different-TCP-connections.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个不同的 TCP 连接" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-5 4 个不同的 TCP 连接 </div> <p>注意，有些连接共享了相同的目的端口号（<code class="language-plaintext highlighter-rouge">C</code> 和 <code class="language-plaintext highlighter-rouge">D</code> 都使用目的端口号 <code class="language-plaintext highlighter-rouge">80</code>）。有些连接使用了相同的源 IP 地址（<code class="language-plaintext highlighter-rouge">B</code> 和 <code class="language-plaintext highlighter-rouge">C</code>）。有些使用了相同的目的 IP 地址（<code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code>，<code class="language-plaintext highlighter-rouge">C</code> 和 <code class="language-plaintext highlighter-rouge">D</code>）。但没有两个不同连接所有的 4 个值都一样。</p> <h3 id="14-用-tcp-套接字编程">1.4 用 TCP 套接字编程</h3> <p>操作系统提供了一些操纵其 TCP 连接的工具。表 4-2 显示了<a href="https://en.wikipedia.org/wiki/Network_socket">套接字</a> API 提供的一些主要接口。这个套接字 API 向 HTTP 程序员隐藏了 TCP 和 IP 的所有细节。套接字 API 最初是为 Unix 操作系统开发的，但现在几乎所有的操作系统和语言中都有其变体存在。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/common-socket-interface-functions-needed-to-program-TCP-connections-480.webp 480w,/assets/images/http-the-definitive-guide/common-socket-interface-functions-needed-to-program-TCP-connections-800.webp 800w,/assets/images/http-the-definitive-guide/common-socket-interface-functions-needed-to-program-TCP-connections-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/common-socket-interface-functions-needed-to-program-TCP-connections.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="对 TCP 连接进行编程所需的常见套接字接口函数" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 4-2 对 TCP 连接进行编程所需的常见套接字接口函数 </div> <p>套接字 API 允许用户创建 TCP 的端点数据结构，将这些端点与远程服务器的 TCP 端点进行连接，并对数据流进行读写。TCP API 隐藏了所有底层网络协议的握手细节，以及 TCP 数据流与 IP 分组之间的分段和重装细节。</p> <p>图 4-1 显示了 Web 浏览器是如何用 HTTP 从 Joe 的五金商店下载 <code class="language-plaintext highlighter-rouge">power-tools.html</code> 页面的。图 4-6 中的伪代码说明了可以怎样通过套接字 API 来凸显客户端和服务器在实现 HTTP 事务时所应执行的步骤。</p> <div class="row justify-content-center"> <div class="col-7"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-clients-and-servers-communicate-through-TCP-socket-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-clients-and-servers-communicate-through-TCP-socket-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-clients-and-servers-communicate-through-TCP-socket-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-clients-and-servers-communicate-through-TCP-socket.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 客户端和服务器是如何通过 TCP 套接字接口进行通信的" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-6 TCP 客户端和服务器是如何通过 TCP 套接字接口进行通信的 </div> <p>我们从 Web 服务器等待连接（参见图 4-6，<code class="language-plaintext highlighter-rouge">S4</code>）开始。客户端根据 URL 判定出 IP 地址和端口号，并建立一条到服务器的 TCP 连接（参见图 4-6，<code class="language-plaintext highlighter-rouge">C3</code>）。建立连接可能要花费一些时间，时间长短取决于服务器距离的远近、服务器的负载情况，以及因特网的拥挤程度。</p> <p>一旦建立了连接，客户端就会发送 HTTP 请求（参见图4-6，<code class="language-plaintext highlighter-rouge">C5</code>），服务器则会读取请求（参见图 4-6，<code class="language-plaintext highlighter-rouge">S6</code>）。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作（参见图4-6，<code class="language-plaintext highlighter-rouge">S7</code>），并将数据写回客户端。客户端读取数据（参见图 4-6，<code class="language-plaintext highlighter-rouge">C6</code>），并对响应数据进行处理（参见图4-6，<code class="language-plaintext highlighter-rouge">C7</code>）。</p> <h2 id="二对-tcp-性能的考虑">二、对 TCP 性能的考虑</h2> <p>HTTP 紧挨着 TCP，位于其上层，所以 HTTP 事务的性能在很大程度上取决于底层 TCP 通道的性能。本节重点介绍了一些很重要的、对这些 TCP 连接的性能考虑。</p> <h3 id="21-http-事务的时延">2.1 HTTP 事务的时延</h3> <p>图 4-7 描绘了 HTTP 事务主要的连接、传输以及处理时延。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/a-timeline-of-serial-HTTP-transactions-480.webp 480w,/assets/images/http-the-definitive-guide/a-timeline-of-serial-HTTP-transactions-800.webp 800w,/assets/images/http-the-definitive-guide/a-timeline-of-serial-HTTP-transactions-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/a-timeline-of-serial-HTTP-transactions.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="串行 HTTP 事务的时间线" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-7 串行 HTTP 事务的时间线 </div> <p>注意，与建立 TCP 连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。除非客户端或服务器超载，或正在处理复杂的动态资源，否则 HTTP 时延就是由 TCP 网络时延构成的。</p> <p>HTTP 事务的时延有以下几种主要原因。</p> <ol> <li>客户端首先需要根据 URI 确定 Web 服务器的 IP 地址和端口号。如果最近没有对 URI 中的主机名进行访问，通过 DNS 解析系统将 URI 中的主机名转换成一个 IP 地址可能要花费数十秒的时间。</li> <li>接下来，客户端会向服务器发送一条 TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的 TCP 连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个 HTTP 事务的话，这个值会快速地叠加上去。</li> <li>一旦连接建立起来了，客户端就会通过新建立的 TCP 管道来发送 HTTP 请求。数据到达时，Web 服务器会从 TCP 连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。</li> <li>然后，Web 服务器会回送 HTTP 响应，这也需要花费时间。这些 TCP 网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。</li> </ol> <h3 id="22-性能聚焦区域">2.2 性能聚焦区域</h3> <p>本节其余部分列出了一些会对 HTTP 程序员产生影响的、最常见的 TCP 相关时延，其中包括：</p> <ul> <li>TCP 连接建立握手；</li> <li>TCP 慢启动拥塞控制；</li> <li>数据聚集的 Nagle 算法；</li> <li>用于捎带确认的 TCP 延迟确认算法；</li> <li>TIME_WAIT 时延和端口耗尽。</li> </ul> <p>要编写高性能的 HTTP 软件，就应该理解上面的每个因素。</p> <h3 id="23-tcp-连接的握手时延">2.3 TCP 连接的握手时延</h3> <p>建立一条新的 TCP 连接时，甚至是在发送任意数据之前，TCP 软件之间会交换一系列的 IP 分组，对连接的有关参数进行沟通（参见图 4-8）。如果连接只用来传送少量数据，这些交换过程就会严重降低 HTTP 的性能。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-sends-two-packets-to-establish-a-connection-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-sends-two-packets-to-establish-a-connection-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-sends-two-packets-to-establish-a-connection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-sends-two-packets-to-establish-a-connection.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="在发送数据之前，TCP 要传送两个分组来建立连接" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-8 在发送数据之前，TCP 要传送两个分组来建立连接 </div> <p>TCP 连接握手需要经过以下几个步骤。</p> <ol> <li>请求新的 TCP 连接时，客户端要向服务器发送一个小的 TCP 分组（通常是 40 ~ 60 个字节）。这个分组中设置了一个特殊的 <code class="language-plaintext highlighter-rouge">SYN</code> 标记，说明这是一个连接请求。（参见图 4-8a）。</li> <li>如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个 TCP 分组，这个分组中的 <code class="language-plaintext highlighter-rouge">SYN</code> 和 <code class="language-plaintext highlighter-rouge">ACK</code> 标记都被置位，说明连接请求已被接受（参见图 4-8b）。</li> <li>最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（参见图 4-8c）。现代的 TCP 栈都允许客户端在这个确认分组中发送数据。</li> </ol> <p>HTTP 程序员永远不会看到这些分组——这些分组都由 TCP/IP 软件管理，对其是不可见的。HTTP 程序员看到的只是创建 TCP 连接时存在的时延。</p> <p>通常 HTTP 事务都不会交换太多数据，此时，<code class="language-plaintext highlighter-rouge">SYN</code>/<code class="language-plaintext highlighter-rouge">SYN+ACK</code> 握手（参见图 4-8a 和图 4-8b）会产生一个可测量的时延。TCP 连接的 <code class="language-plaintext highlighter-rouge">ACK</code> 分组（参见图4-8c）通常都足够大，可以承载整个 HTTP 请求报文，而且很多 HTTP 服务器响应报文都可以放入一个 IP 分组中去（比如，响应是包含了装饰性图片的小型 HTML 文件，或者是对浏览器高速缓存请求产生的 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应）。</p> <p>最后的结果是，小的 HTTP 事务可能会在 TCP 建立上花费 50%，或更多的时间。</p> <h3 id="24-延迟确认">2.4 延迟确认</h3> <p>由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以 TCP 实现了自己的确认机制来确保数据的成功传输。</p> <p>每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。</p> <p>由于确认报文很小，所以 TCP 允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP 将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多 TCP 栈都实现了一种“延迟确认”算法。延迟确认算法会在一个特定的窗口时间（通常是 100 ~ 200 毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p> <p>但是，HTTP 具有双峰特征的请求-应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p> <p>在对 TCP 栈的任何参数进行修改之前，一定要对自己在做什么有清醒的认识。TCP 中引入这些算法的目的是防止设计欠佳的应用程序对因特网造成破坏。对 TCP 配置进行的任意修改，都要绝对确保应用程序不会引发这些算法所要避免的问题。</p> <h3 id="25-tcp-慢启动">2.5 TCP 慢启动</h3> <p>TCP 数据传输的性能还取决于 TCP 连接的使用期（age）。TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为 TCP <strong>慢启动</strong>（slow start），用于防止因特网的突然过载和拥塞。</p> <p>TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个 HTTP 事务有大量数据要发送，是不能一次将所有分组都发送出去的。必须发送一个分组，等待确认；然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了，以此类推。这种方式被称为“打开拥塞窗口”。</p> <p>由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。由于已调谐连接要更快一些，所以 HTTP 中有一些可以重用现存连接的工具。</p> <h3 id="26-nagle-算法与-tcp_nodelay">2.6 Nagle 算法与 TCP_NODELAY</h3> <p>TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 TCP 栈中-即使一次只放一个字节也可以!但是，每个 TCP 段中都至少装载了 40 个字节的标记和首部，所以如果 TCP 发送了大量包含少量数据的分组，网络的性能就会严重下降。”</p> <p>Nagle 算法（根据其发明者 John Nagle 命名）试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。RFC 896 “IP/TCP 互连网络中的拥塞控制”对此算法进行了描述。</p> <p>Nagle 算法鼓励发送全尺寸（LAN 上最大尺寸的分组大约是 1500 字节，在因特网上是几百字节）的段。只有当所有其他分组都被确认之后，Nagle 算法才允许发送非全尺寸的分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。</p> <p>Nagle 算法会引发几种 HTTP 性能问题。首先，小的 HTTP 报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle 算法与延迟确认之间的交互存在问题 —— Nagle 算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟 100 ~ 200 毫秒。</p> <p>HTTP 应用程序常常会在自己的栈中设置参数 TCP_NODELAY，禁用 Nagle 算法，提高性能。如果要这么做的话，一定要确保会向 TCP 写入大块的数据，这样就不会产生一堆小分组了。</p> <h3 id="27-time_wait-累积与端口耗尽">2.7 TIME_WAIT 累积与端口耗尽</h3> <p>TIME_WAIT 端口耗尽是很严重的性能问题，会影响到性能基准，但在现实中相对较少出现。大多数遇到性能基准问题的人最终都会碰到这个问题，而且性能都会变得出乎意料地差，所以这个问题值得特别关注。</p> <p>当某个 TCP 端点关闭 TCP 连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是<strong>所估计的最大分段使用期的两倍</strong>（称为 <code class="language-plaintext highlighter-rouge">2MSL</code>，通常为 2 分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。实际上，<strong>这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同 IP 地址和端口号的连接</strong>。</p> <p>现在高速路由器的使用，使得重复分组几乎不可能在连接关闭的几分钟之后，出现在服务器上。有些操作系统会将 <code class="language-plaintext highlighter-rouge">2MSL</code> 设置为一个较小的值，但修改此值时要特别小心。分组确实会被复制，如果来自之前连接的复制分组插入了具有相同连接值的新 TCP 流，会破坏 TCP 数据。</p> <p><code class="language-plaintext highlighter-rouge">2MSL</code> 的连接关闭延迟通常不是什么问题，但在性能基准环境下就可能会成为一个问题。进行性能基准测试时，通常只有一台或几台用来产生流量的计算机连接到某系统中去，这样就限制了连接到服务器的客户端 IP 地址数。而且，服务器通常会在 HTTP 的默认 TCP 端口 <code class="language-plaintext highlighter-rouge">80</code> 上进行监听。用 TIME_WAIT 防止端口号重用时，这些情况也限制了可用的连接值组合。</p> <p>在只有一个客户端和一台 Web 服务器的异常情况下，构建一条 TCP 连接的 4 个值：</p> \[&lt;source-IP-address，source-port，destination-IP-address，destination-port&gt;\] <p>其中的 3 个都是固定的——只有源端口号可以随意改变：</p> \[&lt;client-IP，source-port，server-IP，80&gt;\] <p>客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限（比如，60000 个），而且在 <code class="language-plaintext highlighter-rouge">2MSL</code> 秒（比如，120 秒）内连接是无法重用的， 连接率就被限制在了 <code class="language-plaintext highlighter-rouge">60 000/120 = 500 次/秒</code>。如果再不断进行优化，并且服务器的连接率不高于 500 次/秒，就可确保不会遇到 TIME_WAIT 端口耗尽问题。要修正这个问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟 IP 地址以增加更多的连接组合。</p> <p>即使没有遇到端口耗尽问题，也要特别小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。在有大量打开连接或控制块的情况下，有些操作系统的速度会严重减缓。</p> <h2 id="三http-连接的处理">三、HTTP 连接的处理</h2> <h3 id="31-常被误解的-connection-首部">3.1 常被误解的 Connection 首部</h3> <p>HTTP 允许在客户端和最终的源端服务器之间存在一串 HTTP 中间实体（代理、高速缓存等）。可以从客户端开始，逐跳地将 HTTP 报文经过这些中间设备，转发到源端服务器上去（或者进行反向传输）。</p> <p>在某些情况下，两个相邻的 HTTP 应用程序会为它们共享的连接应用一组选项。HTTP 的 <code class="language-plaintext highlighter-rouge">Connection</code> 首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。比如，可以用 <code class="language-plaintext highlighter-rouge">Connection: close</code> 来说明发送完下一条报文之后必须关闭的连接。</p> <p>Connection 首部可以承载3种不同类型的标签， 因此有时会很令人费解：</p> <ul> <li>HTTP 首部字段名，列出了只与此连接有关的首部；</li> <li>任意标签值，用于描述此连接的非标准选项；</li> <li>值 <code class="language-plaintext highlighter-rouge">close</code>，说明操作完成之后需关闭这条持久连接。</li> </ul> <p>如果连接标签中包含了一个 HTTP 首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，<strong>必须删除 <code class="language-plaintext highlighter-rouge">Connection</code> 首部列出的所有首部字段</strong>。由于 <code class="language-plaintext highlighter-rouge">Connection</code> 首部可以防止无意中对本地首部的转发，因此将逐跳首部名放入 <code class="language-plaintext highlighter-rouge">Connection</code> 首部被称为“对首部的保护”。图 4-9 显示了一个这样的例子。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-Connection-header-allows-the-sender-to-specify-options-related-to-the-connection-480.webp 480w,/assets/images/http-the-definitive-guide/the-Connection-header-allows-the-sender-to-specify-options-related-to-the-connection-800.webp 800w,/assets/images/http-the-definitive-guide/the-Connection-header-allows-the-sender-to-specify-options-related-to-the-connection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-Connection-header-allows-the-sender-to-specify-options-related-to-the-connection.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Connection 首部允许发送端指定与连接有关的选项" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-9 Connection 首部允许发送端指定与连接有关的选项 </div> <p>HTTP 应用程序收到一条带有 <code class="language-plaintext highlighter-rouge">Connection</code> 首部的报文时，接收端会解析发送端请求的所有选项，并将其应用。然后会在将此报文转发给下一跳地址之前，删除 <code class="language-plaintext highlighter-rouge">Connection</code> 首部以及 <code class="language-plaintext highlighter-rouge">Connection</code> 中列出的所有首部。而且，可能还会有少量没有作为 <code class="language-plaintext highlighter-rouge">Connection</code> 首部值列出，但一定不能被代理转发的逐跳首部。其中包括 <code class="language-plaintext highlighter-rouge">Prxoy-Authenticate</code>、<code class="language-plaintext highlighter-rouge">Proxy-Connection</code>、<code class="language-plaintext highlighter-rouge">Transfer-Encoding</code> 和 <code class="language-plaintext highlighter-rouge">Upgrade</code>。</p> <h3 id="32-串行事务处理时延">3.2 串行事务处理时延</h3> <p>如果只对连接进行简单的管理，TCP 的性能时延可能会叠加起来。比如，假设有一个包含了 3 个嵌入图片的 Web 页面。浏览器需要发起 4 个 HTTP 事务来显示此页面：1 个用于顶层的 HTML 页面，3 个用于嵌入的图片。如果每个事务都需要（串行地建立）一条新的连接，那么连接时延和慢启动时延就会叠加起来（参见图 4-10）。”</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-serial-transactions-480.webp 480w,/assets/images/http-the-definitive-guide/4-serial-transactions-800.webp 800w,/assets/images/http-the-definitive-guide/4-serial-transactions-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-serial-transactions.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个事务（串行）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-10 4 个事务（串行） </div> <p>除了串行加载引入的实际时延之外，加载一幅图片时，页面上其他地方都没有动静也会让人觉得速度很慢。用户更希望能够同时加载多幅图片。IO 串行加载的另一个缺点是，有些浏览器在对象加载完毕之前无法获知对象的尺寸，而且它们可能需要尺寸信息来决定将对象放在屏幕的什么位置上，所以在加载了足够多的对象之前，无法在屏幕上显示任何内容。在这种情况下，可能浏览器串行装载对象的进度很正常， 但用户面对的却是一个空白的屏幕，对装载的进度一无所知。</p> <p>还有几种现存和新兴的方法可以提高 HTTP 的连接性能。</p> <ul> <li>并行连接：通过多条 TCP 连接发起并发的 HTTP 请求。</li> <li>持久连接：重用 TCP 连接，以消除连接及关闭时延。</li> <li>管道化连接：通过共享的 TCP 连接发起并发的 HTTP 请求。</li> <li>复用的连接：交替传送请求和响应报文（实验阶段）。</li> </ul> <h2 id="四并行连接">四、并行连接</h2> <p>如图 4-11 所示，HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。在这个例子中，并行加载了四幅嵌入式图片， 每个事务都有自己的 TCP 连接。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/each-component-on-the-page-contains-a-separate-HTTP-transaction-480.webp 480w,/assets/images/http-the-definitive-guide/each-component-on-the-page-contains-a-separate-HTTP-transaction-800.webp 800w,/assets/images/http-the-definitive-guide/each-component-on-the-page-contains-a-separate-HTTP-transaction-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/each-component-on-the-page-contains-a-separate-HTTP-transaction.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="页面上的每个组件都包含一个独立的 HTTP 事务" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-11 页面上的每个组件都包含一个独立的 HTTP 事务 </div> <h3 id="41-并行连接可能会提高页面的加载速度">4.1 并行连接可能会提高页面的加载速度</h3> <p>包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。</p> <p>图 4-12 显示了并行连接的时间线，比图 4-10 要快得多。首先装载的是封闭的 HTML 页面，然后并行处理其余的 3 个事务，每个事务都有自己的连接。”图片的装载是并行的，连接的时延也是重叠的。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-parallel-transactions-480.webp 480w,/assets/images/http-the-definitive-guide/4-parallel-transactions-800.webp 800w,/assets/images/http-the-definitive-guide/4-parallel-transactions-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-parallel-transactions.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个事务（并行）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-12 4 个事务（并行） </div> <h3 id="42-并行连接不一定更快">4.2 并行连接不一定更快</h3> <p>即使并行连接的速度可能会更快，但并不一定总是更快。客户端的网络带宽不足（比如，浏览器是通过一个 28.8 kbps 的 Modem 连接到因特网上去的）时，大部分的时间可能都是用来传送数据的。在这种情况下，一个连接到速度较快服务器上的 HTTP 事务就会很容易地耗尽所有可用的 Modem 带宽。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。</p> <p>而且，打开大量连接会消耗很多内存资源，从而引发自身的性能问题。复杂的 Web 页面可能会有数十或数百个内嵌对象。客户端可能可以打开数百个连接，但 Web 服务器通常要同时处理很多其他用户的请求，所以很少有 Web 服务器希望出现这样的情况。一百个用户同时发出申请，每个用户打开 100 个连接，服务器就要负责处理 10 000 个连接。这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。实际上，浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值（通常是 4 个）。服务器可以随意关闭来自特定客户端的超量连接。</p> <h2 id="五持久连接">五、持久连接</h2> <p>Web 客户端经常会打开到同一个站点的连接。比如，一个 Web 页面上的大部分内嵌图片通常都来自同一个 Web 站点，而且相当一部分指向其他对象的超链通常都指向同一个站点。因此，初始化了对某服务器 HTTP 请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求（比如，获取在线图片）。这种性质被称为<strong>站点局部性</strong>（site locality）。</p> <p>因此，HTTP/1.1（以及 HTTP/1.0 的各种增强版本）允许 HTTP 设备在事务处理结束之后将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求<strong>重用</strong>现存的连接。<strong>在事务处理结束之后仍然保持在打开状态的 TCP 连接被称为持久连接</strong>。非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。</p> <p>重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。</p> <h3 id="51-持久以及并行连接">5.1 持久以及并行连接</h3> <p>我们看到， 并行连接可以提高复合页面的传输速度。但并行连接也有一些缺点。</p> <ul> <li>每个事务都会打开/关闭一条新的连接，会耗费时间和带宽。</li> <li>由于 TCP 慢启动特性的存在，每条新连接的性能都会有所降低。</li> <li>可打开的并行连接数量实际上是有限的。</li> </ul> <p>持久连接有一些比并行连接更好的地方。持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。但是，管理持久连接时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。</p> <p>持久连接与并行连接配合使用可能是最高效的方式。现在，很多 Web 应用程序都会打开少量的并行连接，其中的每个都是持久连接。持久连接有两种类型：比较老的 HTTP/1.0+ <strong>keep-alive 连接</strong>，以及现代的 HTTP/1.1 <strong>persistent 连接</strong>。</p> <h3 id="52-http10-keep-alive-连接">5.2 HTTP/1.0+ keep-alive 连接</h3> <p>大约从 1996 年开始，很多 HTTP/1.0 浏览器和服务器都进行了扩展，以支持一种被称为 keep-alive 连接的早期实验型持久连接。这些早期的持久连接受到了一些互操作性设计方面问题的困扰，这些问题在后期的 HTTP/1.1 版本中都得到了修正，但很多客户端和服务器仍然在使用这些早期的 keep-alive 连接。</p> <p>图 4-13 显示了 keep-alive 连接的一些性能优点，图中将在串行连接上实现 4 个 HTTP 事务的时间线与在一条持久连接上实现同样事务所需的时间线进行了比较。由于去除了进行连接和关闭连接的开销，所以时间线有所缩减。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-serial-and-persistent-connection-transactions-480.webp 480w,/assets/images/http-the-definitive-guide/4-serial-and-persistent-connection-transactions-800.webp 800w,/assets/images/http-the-definitive-guide/4-serial-and-persistent-connection-transactions-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-serial-and-persistent-connection-transactions.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个事务（串行与持久连接）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-13 4 个事务（串行与持久连接） </div> <h3 id="53-keep-alive-操作">5.3 Keep-Alive 操作</h3> <p>keep-alive 已经不再使用了，而且在当前的 HTTP/1.1 规范中也没有对它的说明了。但浏览器和服务器对 keep-alive 握手的使用仍然相当广泛，因此，HTTP 的实现者应该做好与之进行交互操作的准备。现在我们来快速浏览一下 keep-alive 的操作（对keep-alive 握手更详细的解释请参见较早的 HTTP/1.1 规范版本（比如 RFC 2068））。实现 HTTP/1.0 keep-alive 连接的客户端可以通过包含 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部请求将一条连接保持在打开状态。</p> <p>如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部（参见图 4-14）。如果响应中没有 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，客户端就认为服务器不支持 keep-alive，会在发回响应报文之后关闭连接。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-handshake-of-a-keep-alive-transaction-480.webp 480w,/assets/images/http-the-definitive-guide/the-handshake-of-a-keep-alive-transaction-800.webp 800w,/assets/images/http-the-definitive-guide/the-handshake-of-a-keep-alive-transaction-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-handshake-of-a-keep-alive-transaction.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP/1.0 keep-alive 事务首部的握手过程" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-14 HTTP/1.0 keep-alive 事务首部的握手过程 </div> <h3 id="54-keep-alive-选项">5.4 Keep-Alive 选项</h3> <p>注意， <code class="language-plaintext highlighter-rouge">keep-Alive</code> 首部只是请求将连接保持在活跃状态。发出 keep-alive 请求之后，客户端和服务器并不一定会同意进行 keep-alive 会话。它们可以在任意时刻关闭空闲的 keep-alive 连接，并可随意限制 keep-alive 连接所处理事务的数量。可以用 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 通用首部中指定的、由逗号分隔的选项来调节 keep-alive 的行为。</p> <ul> <li>参数 <code class="language-plaintext highlighter-rouge">timeout</code> 是在 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 响应首部发送的。它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。</li> <li>参数 <code class="language-plaintext highlighter-rouge">max</code> 是在 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 响应首部发送的。它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。</li> <li><code class="language-plaintext highlighter-rouge">Keep-Alive</code> 首部还可支持任意未经处理的属性，这些属性主要用于诊断和调试。语法为 <code class="language-plaintext highlighter-rouge">name [=value]</code>。</li> </ul> <p><code class="language-plaintext highlighter-rouge">Keep-Alive</code> 首部完全是可选的，但只有在提供 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 时才能使用它。这里有个 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 响应首部的例子，这个例子说明服务器最多还会为另外 5 个事务保持连接的打开状态，或者将打开状态保持到连接空闲了 2 分钟之后。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
</span></code></pre></div></div> <h3 id="55-keep-alive-连接的限制和规则">5.5 Keep-Alive 连接的限制和规则</h3> <p>使用 keep-alive 连接时有一些限制和一些需要澄清的地方。</p> <ul> <li>在 HTTP/1.0 中，keep-alive 并不是默认使用的。客户端必须发送一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 请求首部来激活 keep-alive 连接。</li> <li><code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部必须随<strong>所有</strong>希望保持持久连接的报文一起发送。如果客户端没有发送 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，服务器就会在那条请求之后关闭连接。</li> <li>通过检测响应中是否包含 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 响应首部，客户端可以判断服务器是否会在发出响应之后关闭连接。</li> <li><strong>只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态</strong> - 也就是说实体的主体部分必须有正确的 <code class="language-plaintext highlighter-rouge">Content-Length</code>，有多部件媒体类型，或者用分块传输编码的方式进行了编码。在一条 keep-alive 信道中回送错误的 <code class="language-plaintext highlighter-rouge">Content-Length</code> 是很糟糕的事，这样的话，事务处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了。</li> <li>代理和网关必须执行 <code class="language-plaintext highlighter-rouge">Connection</code> 首部的规则。代理或网关必须在将报文转发出去或将其高速缓存之前，删除在 <code class="language-plaintext highlighter-rouge">Connection</code> 首部中命名的所有首部字段以及 <code class="language-plaintext highlighter-rouge">Connection</code> 首部自身。</li> <li>严格来说，不应该与无法确定是否支持 <code class="language-plaintext highlighter-rouge">Connection</code> 首部的代理服务器建立 keep-alive 连接，以防止出现下面要介绍的<strong>哑代理</strong>问题。在实际应用中不是总能做到这一点的。</li> <li>从技术上来讲，应该忽略所有来自 HTTP/1.0 设备的 <code class="language-plaintext highlighter-rouge">Connection</code> 首部字段（包括 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code>），因为它们可能是由比较老的代理服务器误转发的。但实际上，尽管可能会有在老代理上挂起的危险，有些客户端和服务器还是会违反这条规则。</li> <li>除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备。</li> </ul> <h3 id="56-keep-alive和哑代理">5.6 Keep-Alive和哑代理</h3> <p>我们来仔细看看 keep-alive 和<strong>哑代理</strong>中一些比较微妙的问题。Web 客户端的 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部应该只会对这条离开客户端的 TCP 链路产生影响。这就是将其称作“连接”首部的原因。如果客户端正在与一台 Web 服务器对话，客户端可以发送一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部来告知服务器希望保持连接的活跃状态。如果服务器支持 keep-alive，就回送一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，否则就不回送。</p> <h4 id="1connection-首部和盲中继">（1）Connection 首部和盲中继</h4> <p>问题出在代理上——尤其是那些不理解 <code class="language-plaintext highlighter-rouge">Connection</code> 首部，而且不知道在沿着转发链路将其发送出去之前，应该将该首部删除的代理。很多老的或简单的代理都是<strong>盲中继</strong>（blind relay），它们只是将字节从一个连接转发到另一个连接中去，不对 <code class="language-plaintext highlighter-rouge">Connection</code> 首部进行特殊的处理。</p> <p>假设有一个 Web 客户端正通过一个作为盲中继使用的哑代理与Web服务器进行对话。图 4-15 显示的就是这种情形。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/keep-alive-cannot-interoperate-with-agents-that-do-not-support-Connection-headers-480.webp 480w,/assets/images/http-the-definitive-guide/keep-alive-cannot-interoperate-with-agents-that-do-not-support-Connection-headers-800.webp 800w,/assets/images/http-the-definitive-guide/keep-alive-cannot-interoperate-with-agents-that-do-not-support-Connection-headers-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/keep-alive-cannot-interoperate-with-agents-that-do-not-support-Connection-headers.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="keep-alive 无法与不支持 Connection 首部的代理进行互操作" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-15 keep-alive 无法与不支持 Connection 首部的代理进行互操作 </div> <p>这幅图中发生的情况如下所示。</p> <ol> <li>在图 4-15a 中，Web 客户端向代理发送了一条报文，其中包含了 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，如果可能的话请求建立一条 keep-alive 连接。客户端等待响应，以确定对方是否认可它对 keep-alive 信道的请求。</li> <li>哑代理收到了这条 HTTP 请求，但它并不理解 <code class="language-plaintext highlighter-rouge">Connection</code> 首部（只是将其作为一个扩展首部对待）。代理不知道 keep-alive 是什么意思，因此只是沿着转发链路将报文一字不漏地发送给服务器（图 4-15b）。但 connection 首部是个逐跳首部，只适用于单条传输链路，不应该沿着传输链路向下传输。接下来，就要发生一些很糟糕的事情了。</li> <li>在图 4-15b 中，经过中继的 HTTP 请求抵达了 Web 服务器。当 Web 服务器收到经过代理转发的 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部时，会误以为代理（对服务器来说，这个代理看起来就和所有其他客户端一样）希望进行 keep-alive 对话!对 Web 服务器来说这没什么问题 —— 它同意进行 keep-alive 对话，并在图 4-15c 中回送了一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 响应首部。所以，此时 Web 服务器认为它在与代理进行 keep-alive 对话，会遵循 keep-alive 的规则。但代理却对 keep-alive 一无所知。不妙。</li> <li>在图 4-15d 中，哑代理将 Web 服务器的响应报文回送给客户端，并将来自 Web 服务器的 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部一起传送过去。客户端看到这个首部，就会认为代理同意进行 keep-alive 对话。所以，此时客户端和服务器都认为它们在进行 keep-alive 对话，但与它们进行对话的代理却对 keep-alive 一无所知。</li> <li>由于代理对 keep-alive 一无所知，所以会将收到的所有数据都回送给客户端，然后<strong>等待源端服务器关闭连接</strong>。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了，所以不会去关闭连接。这样，代理就会挂在那里等待连接的关闭。</li> <li>客户端在图 4-15d 中收到了回送的响应报文时，会立即转向下一条请求，在 keep-alive 连接上向代理发送另一条请求（参见图 4-15e）。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。</li> <li>这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时，并将其关闭为止。</li> </ol> <h4 id="2代理和逐跳首部">（2）代理和逐跳首部</h4> <p>为避免此类代理通信问题的发生，现代的代理都绝不能转发 <code class="language-plaintext highlighter-rouge">Connection</code> 首部和所有名字出现在 <code class="language-plaintext highlighter-rouge">Connection</code> 值中的首部。因此，如果一个代理收到了一个 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部，是不应该转发 <code class="language-plaintext highlighter-rouge">Connection</code> 首部，或所有名为 Keep-Alive 的首部的。</p> <p>另外，还有几个不能作为 <code class="language-plaintext highlighter-rouge">Connection</code> 首部值列出，也不能被代理转发或作为缓存响应使用的首部。其中包括 <code class="language-plaintext highlighter-rouge">Proxy-Authenticate</code>、<code class="language-plaintext highlighter-rouge">Proxy-Connection</code>、<code class="language-plaintext highlighter-rouge">Transfer-Encoding</code> 和 <code class="language-plaintext highlighter-rouge">Upgrade</code>。</p> <h3 id="57-插入-proxy-connection">5.7 插入 Proxy-Connection</h3> <p>Netscape 的浏览器及代理实现者们提出了一个对盲中继问题的变通做法，这种做法并不要求所有的 Web 应用程序支持高版本的 HTTP。这种变通做法引入了一个名为 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 的新首部，解决了在客户端后面紧跟着一个盲中继所带来的问题 —— 但并没有解决所有其他情况下存在的问题。在显式配置了代理的情况下，现代浏览器都实现了 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code>，很多代理都能够理解它。</p> <p>问题是哑代理盲目地转发 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 之类的逐跳首部惹出了麻烦。逐跳首部只与一条特定的连接有关，不能被转发。当下游服务器误将转发来的首部作为来自代理自身的请求解释，用它来控制自己的连接时，就会引发问题。</p> <p>在网景的变通做法是，浏览器会向代理发送非标准的 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 扩展首部，而不是官方支持的著名的 <code class="language-plaintext highlighter-rouge">Connection</code> 首部。如果代理是盲中继，它会将无意义的 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部转发给 Web 服务器，服务器会忽略此首部，不会带来任何问题。但如果代理是个聪明的代理（能够理解持久连接的握手动作），就用一个 <code class="language-plaintext highlighter-rouge">Connection</code> 首部取代无意义的 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部，然后将其发送给服务器，以收到预期的效果。</p> <p>图 4-16a ~ 图 4-16d 显示了盲中继是如何向 Web 服务器转发 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部，而不带来任何问题的，Web 服务器忽略了这个首部，这样在客户端和代理，或者代理和服务器之间就不会建立起 keep-alive 连接了。图 4-16e ~ 图 4-16h 中那个聪明的代理知道 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部是对 keep-alive 对话的请求，它会发送自己的 <code class="language-plaintext highlighter-rouge">Connection: Keep-Alive</code> 首部来建立 keep-alive 连接。</p> <p>在客户端和服务器之间只有一个代理时可以用这种方案来解决问题。但如图 4-17 所示，如果在哑代理的任意一侧还有一个聪明的代理，这个问题就会再次露头了。而且，网络中出现“不可见”代理的情况现在变得很常见了，这些代理可以是防火墙、拦截缓存，或者是反向代理服务器的加速器。这些设备对浏览器是不可见的，所以浏览器不会向它们发送 <code class="language-plaintext highlighter-rouge">Proxy-Connection</code> 首部。透明的 Web 应用程序正确地实现持久连接是非常重要的。</p> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/the-Proxy-Connection-header-fixes-an-issue-caused-by-a-single-blind-relay-480.webp 480w,/assets/images/http-the-definitive-guide/the-Proxy-Connection-header-fixes-an-issue-caused-by-a-single-blind-relay-800.webp 800w,/assets/images/http-the-definitive-guide/the-Proxy-Connection-header-fixes-an-issue-caused-by-a-single-blind-relay-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/the-Proxy-Connection-header-fixes-an-issue-caused-by-a-single-blind-relay.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="proxy-Connection 首部修正了单个盲中继带来的问题" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-16 Proxy-Connection 首部修正了单个盲中继带来的问题 </div> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/Proxy-Connection-does-not-resolve-the-case-of-multiple-proxies-480.webp 480w,/assets/images/http-the-definitive-guide/Proxy-Connection-does-not-resolve-the-case-of-multiple-proxies-800.webp 800w,/assets/images/http-the-definitive-guide/Proxy-Connection-does-not-resolve-the-case-of-multiple-proxies-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/Proxy-Connection-does-not-resolve-the-case-of-multiple-proxies.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="对有多层次代理的情况，Proxy-Connection 仍然无法解决问题" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-17 对有多层次代理的情况，Proxy-Connection 仍然无法解决问题 </div> <h3 id="58-http11-持久连接">5.8 HTTP/1.1 持久连接</h3> <p>HTTP/1.1 逐渐停止了对 keep-alive 连接的支持，用一种名为<strong>持久连接</strong>（persistent connection）的改进型设计取代了它。持久连接的目的与 keep-alive 连接的目的相同，但工作机制更优一些。</p> <p>与 HTTP/1.0+ 的 keep-alive 连接不同，HTTP/1.1 持久连接在<strong>默认情况下是激活的</strong>。除非特别指明，否则 HTTP/1.1 假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文中显式地添加一个 <code class="language-plaintext highlighter-rouge">Connection: close</code> 首部。这是与以前的 HTTP 协议版本很重要的区别，在以前的版本中，keep-alive 连接要么是可选的，要么根本就不支持。</p> <p>HTTP/1.1 客户端假定在收到响应后，除非响应中包含了 <code class="language-plaintext highlighter-rouge">Connection: close</code> 首部，不然 HTTP/1.1 连接就仍维持在打开状态。但是，客户端和服务器仍然可以随时关闭空闲的连接。不发送 <code class="language-plaintext highlighter-rouge">Connection: close</code> 并不意味着服务器承诺永远将连接保持在打开状态。</p> <h3 id="59-持久连接的限制和规则">5.9 持久连接的限制和规则</h3> <p>在持久连接的使用中有以下限制和需要澄清的问题。</p> <ul> <li>发送了 <code class="language-plaintext highlighter-rouge">Connection: close</code> 请求首部之后，客户端就无法在那条连接上发送更多的请求了。</li> <li>如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个 <code class="language-plaintext highlighter-rouge">Connection: close</code> 请求首部。</li> <li>只有当连接上所有的报文都有正确的、自定义报文长度时 - 也就是说，实体主体部分的长度都和相应的 <code class="language-plaintext highlighter-rouge">Content-Length</code> 一致，或者是用分块传输编码方式编码的 —— 连接才能持久保持。</li> <li>HTTP/1.1 的代理必须能够分别管理与客户端和服务器的持久连接 —— 每个持久连接都只适用于一跳传输。</li> <li>（由于较老的代理会转发 <code class="language-plaintext highlighter-rouge">Connection</code> 首部，所以）HTTP/1.1 的代理服务器不应该与 HTTP/1.0 客户端建立持久连接，除非它们了解客户端的处理能力。实际上，这一点是很难做到的，很多厂商都违背了这一原则。</li> <li>尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求，但不管 <code class="language-plaintext highlighter-rouge">Connection</code> 首部取了什么值，HTTP/1.1 设备都可以在任意时刻关闭连接。</li> <li>HTTP/1.1 应用程序必须能够从异步的关闭中恢复出来。只要不存在可能会累积起来的副作用，客户端都应该重试这条请求。</li> <li>除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭了，客户端就必须要重新发起请求。</li> <li>一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。代理可能需要更多到服务器的连接来支持并发用户的通信，所以，如果有 <code class="language-plaintext highlighter-rouge">N</code> 个用户试图访问服务器的话，代理最多要维持 <code class="language-plaintext highlighter-rouge">2N</code> 条到任意服务器或父代理的连接。</li> </ul> <h2 id="六管道化连接">六、管道化连接</h2> <p>HTTP/1.1 允许在持久连接上可选地使用<strong>请求管道</strong>。这是相对于 keep-alive 连接的又一性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。图 4-18 a-c 显示了持久连接是怎样消除 TCP 连接时延，以及管道化请求（参见图 4-18c）是如何消除传输时延的。</p> <p>对管道化连接有几条限制。</p> <ul> <li>如果 HTTP 客户端无法确认连接是持久的，就不应该使用管道。</li> <li>必须按照与请求相同的顺序回送 HTTP 响应。HTTP 报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li> <li>HTTP 客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了 10 条请求，服务器可能在只处理了，比方说，5 条请求之后关闭连接。剩下的 5 条请求会失败，客户端必须能够应对这些过早关闭连接的情况，重新发出这些请求。</li> <li>HTTP 客户端不应该用管道化的方式发送会产生副作用的请求（比如 POST）。总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试 POST 这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险。</li> </ul> <div class="row justify-content-center"> <div class="col-9"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/4-pipes-connect-the-transaction-480.webp 480w,/assets/images/http-the-definitive-guide/4-pipes-connect-the-transaction-800.webp 800w,/assets/images/http-the-definitive-guide/4-pipes-connect-the-transaction-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/4-pipes-connect-the-transaction.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="4 个事务（管道连接）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-18 4 个事务（管道连接） </div> <h2 id="七关闭连接的奥秘">七、关闭连接的奥秘</h2> <h3 id="71-任意解除连接">7.1 “任意”解除连接</h3> <p>所有 HTTP 客户端、服务器或代理都可以在任意时刻关闭一条 TCP 传输连接。通常会在一条报文结束时关闭连接，但出错的时候，也可能在首部行的中间，或其他奇怪的地方关闭连接。对管道化持久连接来说，这种情形是很常见的。HTTP 应用程序可以在经过任意一段时间之后，关闭持久连接。比如，在持久连接空闲一段时间之后，服务器可能会决定将其关闭。</p> <p>但是，服务器永远都无法确定在它关闭“空闲”连接的那一刻，在线路那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现了连接错误。</p> <h3 id="72-content-length-及截尾操作">7.2 Content-Length 及截尾操作</h3> <p>每条 HTTP 响应都应该有精确的 <code class="language-plaintext highlighter-rouge">Content-Length</code> 首部，用以描述响应主体的尺寸。一些老的 HTTP 服务器会省略 <code class="language-plaintext highlighter-rouge">Content-Length</code> 首部，或者包含错误的长度指示，这样就要依赖服务器发出的连接关闭来说明数据的真实末尾。</p> <p>客户端或代理收到一条随连接关闭而结束的 HTTP 响应，且实际传输的实体长度与 <code class="language-plaintext highlighter-rouge">Content-Length</code> 并不匹配（或没有 <code class="language-plaintext highlighter-rouge">Content-Length</code>）时，接收端就应该质疑长度的正确性。</p> <p>如果接收端是个缓存代理，接收端就不应该缓存这条响应（以降低今后将潜在的错误报文混合起来的可能）。代理应该将有问题的报文原封不动地转发出去，而不应该试图去“校正” <code class="language-plaintext highlighter-rouge">Content-Length</code>，以维护语义的透明性。</p> <h3 id="73-连接关闭容限重试以及幂等性">7.3 连接关闭容限、重试以及幂等性</h3> <p>即使在非错误情况下，连接也可以在任意时刻关闭。HTTP 应用程序要做好正确处理非预期关闭的准备。如果在客户端执行事务的过程中，传输连接关闭了，那么，除非事务处理会带来一些副作用，否则客户端就应该重新打开连接，并重试一次。对管道化连接来说，这种情况更加严重一些。客户端可以将大量请求放入队列中排队，但源端服务器可以关闭连接，这样就会留下大量未处理的请求，需要重新调度。副作用是很重要的问题。如果在发送出一些请求数据之后，收到返回结果之前，连接关闭了，客户端就无法百分之百地确定服务器端实际激活了多少事务。有些事务，比如 <code class="language-plaintext highlighter-rouge">GET</code> 一个静态的 HTML 页面，可以反复执行多次，也不会有什么变化。而其他一些事务，比如向一个在线书店 <code class="language-plaintext highlighter-rouge">POST</code> 一张订单，就不能重复执行，不然会有下多张订单的危险。</p> <p><strong>如果一个事务，不管是执行一次还是很多次，得到的结果都相同，这个事务就是幂等的</strong>。实现者们可以认为 <code class="language-plaintext highlighter-rouge">GET</code>、<code class="language-plaintext highlighter-rouge">HEAD</code>、<code class="language-plaintext highlighter-rouge">PUT</code>、<code class="language-plaintext highlighter-rouge">DELETE</code>、<code class="language-plaintext highlighter-rouge">TRACE</code> 和 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 方法都共享这一特性。”客户端不应该以管道化方式传送<strong>非幂等请求</strong>（比如 <code class="language-plaintext highlighter-rouge">POST</code>）。否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条请求的响应状态。</p> <p>尽管用户 Agent 代理可能会让操作员来选择是否对请求进行重试，但一定不能自动重试非幂等方法或序列。比如，大多数浏览器都会在重载一个缓存的 <code class="language-plaintext highlighter-rouge">POST</code> 响应时提供一个对话框，询问用户是否希望再次发起事务处理。</p> <h3 id="74-正常关闭连接">7.4 正常关闭连接</h3> <p>如图 4-19 所示，TCP 连接是双向的。TCP 连接的每一端都有一个输入队列和一个输出队列，用于数据的读或写。放入一端输出队列中的数据最终会出现在另一端的输入队列中。</p> <div class="row justify-content-center"> <div class="col-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/TCP-connections-are-bidirectional-480.webp 480w,/assets/images/http-the-definitive-guide/TCP-connections-are-bidirectional-800.webp 800w,/assets/images/http-the-definitive-guide/TCP-connections-are-bidirectional-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/TCP-connections-are-bidirectional.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="TCP 连接是双向的" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-19 TCP 连接是双向的 </div> <h4 id="1完全关闭与半关闭">（1）完全关闭与半关闭</h4> <p>应用程序可以关闭 TCP 输入和输出信道中的任意一个，或者将两者都关闭了。套接字调用 <code class="language-plaintext highlighter-rouge">close()</code> 会将 TCP 连接的输入和输出信道都关闭了。这被称作“<strong>完全关闭</strong>”，如图 4-20a 所示。还可以用套接字调用 <code class="language-plaintext highlighter-rouge">shutdown()</code> 单独关闭输入或输出信道。这被称为“<strong>半关闭</strong>”，如图 4-20b 所示。</p> <h4 id="2tcp-关闭及重置错误">（2）TCP 关闭及重置错误</h4> <p>简单的 HTTP 应用程序可以只使用完全关闭。但当应用程序开始与很多其他类型的 HTTP 客户端、服务器和代理进行对话且开始使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误就变得很重要了。</p> <div class="row justify-content-center"> <div class="col-5"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/full-off-and-half-off-480.webp 480w,/assets/images/http-the-definitive-guide/full-off-and-half-off-800.webp 800w,/assets/images/http-the-definitive-guide/full-off-and-half-off-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/full-off-and-half-off.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="完全关闭和半关闭" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-20 完全关闭和半关闭 </div> <p>总之，关闭连接的输出信道总是很安全的。连接另一端的对等实体会在从其缓冲区中读出所有数据之后收到一条通知，说明流结束了，这样它就知道你将连接关闭了。关闭连接的输入信道比较危险，除非你知道另一端不打算再发送其他数据了。如果另一端向你已关闭的输入信道发送数据，操作系统就会向另一端的机器回送一条 TCP “连接被对端重置”的报文，如图 4-21 所示。大部分操作系统都会将这种情况作为很严重的错误来处理，删除对端还未读取的所有缓存数据。对管道化连接来说，这是非常糟糕的事情。</p> <div class="row justify-content-center"> <div class="col-5"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/connection-reset-by-peer-error-480.webp 480w,/assets/images/http-the-definitive-guide/connection-reset-by-peer-error-800.webp 800w,/assets/images/http-the-definitive-guide/connection-reset-by-peer-error-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/connection-reset-by-peer-error.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="将数据传送到已关闭连接时会产生“连接被对端重置”错误" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4-21 将数据传送到已关闭连接时会产生“连接被对端重置”错误 </div> <p>比如你已经在一条持久连接上发送了 10 条管道式请求了，响应也已经收到了，正在操作系统的缓冲区中存着呢（但应用程序还未将其读走）。现在，假设你发送了第 11 条请求，但服务器认为你使用这条连接的时间已经够长了，决定将其关闭。那么你的第 11 条请求就会被发送到一条已关闭的连接上去，并会向你回送一条重置信息。这个重置信息会清空你的输入缓冲区。</p> <p>当你最终要去读取数据的时候，会得到一个连接被对端重置的错误，已缓存的未读 响应数据都丟失了， 尽管其中的大部分都已经成功抵达你的机器了。</p> <h4 id="3正常关闭">（3）正常关闭</h4> <p>HTTP 规范建议，当客户端或服务器突然要关闭一条连接时，应该“正常地关闭传输连接”，但它并没有说明应该如何去做。</p> <p>总之，实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待连接另一端的对等实体关闭它的输出信道。当两端都告诉对方它们不会再发送任何数据（比如关闭输出信道）之后，连接就会被完全关闭，而不会有重置的危险。</p> <p>但不幸的是，无法确保对等实体会实现半关闭，或对其进行检查。因此，想要正常关闭连接的应用程序应该先关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</p> <h2 id="八参考">八、参考</h2> <ul> <li><a href="https://www.oreilly.com/library/view/http-the-definitive/1565925092/">HTTP 权威指南</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="computer"/><category term="networks"/><category term="http"/><summary type="html"><![CDATA[本文节选自《HTTP 权威指南 - 第4章 连接管理》。]]></summary></entry></feed>