<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-21T08:55:57+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html"></title><link href="https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer/" rel="alternate" type="text/html" title=""/><published>2024-09-21T08:55:57+00:00</published><updated>2024-09-21T08:55:57+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer/"><![CDATA[<h2 id="一介绍">一、介绍</h2> <p>数据链路层属于计算机网络的低层。数据链路层使用的信道主要有以下两种类型：</p> <ul> <li><strong>点对点信道</strong>。这种信道使用一对一的点对点通信方式。</li> <li><strong>广播信道</strong>。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li> </ul> <p>本章中我们研究的是在同一个局域网中，分组怎样从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，局域网仍属于数据链路层的范围。</p> <p>下面看一下两台主机通过互联网进行通信时数据链路层所处的地位（图 3-1）。图 3-1（a）表示用户主机 $H_1$ 通过电话线上网，中间经过三个路由器（$R_1$，$R_1$ 和 $R_1$）连接到远程主机 $H_2$。所经过的网络可以是多种的，如电话网、局域网和广域网。当主机 $H_1$ 向 $H_2$ 发送数据时，从协议的层次上看，数据的流动如图 3-1（b）所示。主机 $H_1$ 和 $H_2$ 都有完整的五层协议栈，但路由器在转发分组时使用的协议栈只有下面的三层。数据进入路由器后要先从物理层上到网络层，在转发表中找到下一跳的地址后，再下到物理层转发出去。因此，数据从主机 $H_1$ 传送到主机 $H_2$ 需要在路径中的各结点的协议栈向上和向下流动多次，如图中的浅灰色箭头所示。</p> <p>然而当我们专门研究数据链路层的问题时，在许多情况下我们可以只关心在协议栈中水平方向的各数据链路层。于是，当主机 $H_1$ 向主机 $H_2$ 发送数据时，我们可以想象数据就是在数据链路层从左向右沿水平方向传送的，如图3 -2 中从左到右的粗箭头所示，即通过以下这样的链路：</p> <p>$H_1$ 的链路层 → $R_1$ 的链路层 → $R_2$ 的链路层 → $R_3$ 的链路层 → $H_2$ 的链路层</p> <p><img src="/assets/images/computer-networks/data-flow-at-the-data-link-layer.png" alt="数据在数据链路层的流动"/> <em>图 3-2 只考虑数据在数据链路层的流动</em></p> <p>图 3-2 指出，从数据链路层来看，$H_1$ 到 $H_2$ 的通信可以看成由四段不同的链路层通信组成，即：$H_1$ → $R_1$，$R_1$ → $R_2$，$R_2$ → $R_3$ 和 $R_3$ → $H_2$。这四段不同的链路层可能采用不同的数据链路层协议。</p> <h2 id="二使用点对点信道的数据链路层">二、使用点对点信道的数据链路层</h2> <h3 id="21-数据链路和帧">2.1 数据链路和帧</h3> <p>“链路”和“数据链路”并不是一回事。</p> <ul> <li><strong>链路</strong>（link）：指从一个结点到相邻结点的一段物理线路（有线或无线），中间没有任何其他的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。</li> <li><strong>数据链路</strong>（data link）：是另一个概念。这是因为当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用<strong>网络适配器</strong>（既有硬件，也包括软件）来实现这些协议。一般的适配器都包括了数据链路层和物理层这两层的功能。</li> </ul> <p>数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是 <strong>IP 数据报</strong>（或简称为数据报、分组或包）。</p> <p>为了把主要精力放在点对点信道的数据链路层协议上，可以采用如图 3-3（a）所示的三层模型。在这种三层模型中，不管在哪段链路上的通信（主机和路由器之间或两个路由器之间），我们都看成是结点和结点的通信（如图中的结点 A 和 B），而每个结点只有下三层：网络层、数据链路层和物理层。</p> <p><img src="/assets/images/computer-networks/data-link-layer-using-point-to-point-channel.png" alt="使用点对点信道的数据链路层"/> <em>图 3-3 使用点对点信道的数据链路层</em></p> <p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p> <ol> <li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。</li> <li>结点 A 把封装好的帧发送给结点 B 的数据链路层。</li> <li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。</li> </ol> <p>数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方，如图 3-3（b）所示。</p> <h3 id="22-三个基本问题">2.2 三个基本问题</h3> <p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：<strong>封装成帧</strong>、<strong>透明传输</strong>和<strong>差错检测</strong>。</p> <h4 id="1封装成帧">（1）封装成帧</h4> <p><strong>封装成帧</strong>（framing）就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束（图 3-4 表示用帧首部和帧尾部封装成帧的一般概念）。我们知道，分组交换的一个重要概念就是：所有在互联网上传送的数据都以分组（即 IP 数据报）为传送单位。网络层的 IP 数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行<strong>帧定界</strong>（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限</strong> —— <strong>最大传送单元 MTU</strong>（Maximum Transfer Unit）。图 3-4 给出了帧的首部和尾部的位置，以及帧的数据部分与 MTU 的关系。</p> <p><img src="/assets/images/computer-networks/encapsulate-frames-with-frame-headers-and-tails.png" alt="用帧首部和尾部封装成帧"/> <em>图 3-4 用帧首部和尾部封装成帧</em></p> <p>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的<strong>帧定界符</strong>。我们知道，ASCII 码是 7 位编码，一共可组合成 128 个不同的 ASCII 码，其中可打印的有 95 个，而不可打印的控制字符有 33 个。图 3-5 的例子可说明帧定界的概念。控制字符 SOH（Start Of Header）放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT （End Of Transmission）表示帧的结束。请注意，SOH 和 EOT 都是控制字符的名称。它们的十六进制编码分别是 01（二进制是 00000001）和 04（二进制是 00000100）。</p> <p><img src="/assets//images/computer-networks/method-of-delimiting-frames-with-control-characters.png" alt="用控制字符进行帧定界的方法举例"/> <em>图 3-5 用控制字符进行帧定界的方法举例</em></p> <p>当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧（只有首部开始符 SOH 而没有传输结束符 EOT），必须丢弃。而后面收到的数据有明确的帧定界符（SOH 和 EOT），因此这是一个完整的帧，应当收下。</p> <h4 id="2透明传输">（2）透明传输</h4> <p>由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。</p> <p>当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现像 SOH 或 EOT 这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p> <p>但当数据部分是非 ASCII 码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 这种控制字符一样（见图 3-6），数据链路层就会错误地“找到帧的边界”，把部分帧收下（误认为是个完整的帧），而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符 SOH）。</p> <p><img src="/assets/images/computer-networks/the-data-section-happens-to-have-the-same-code-as-the-eot.png" alt="数据部分恰好出现与 EOT 一样的代码"/> <em>图 3-6 数据部分恰好出现与EOT 一样的代码</em></p> <p>像图 3-6 所示的帧的传输显然就不是“透明传输”，因为当遇到数据中碰巧出现字符“EOT”时就传不过去了。数据中的“EOT”将被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端当作无效帧而丢弃。但实际上在数据中出现的字符“EOT”并非控制字符而仅仅是二进制数据 00000100。</p> <p>前面提到的“透明”是一个很重要的术语。它表示：<strong>某个实际存在的事物看起来却好像不存在一样</strong>（例如，你看不见在你前面有块 100%透明的玻璃的存在）。“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。</p> <p>为了解决透明传输问题，必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。具体的方法是：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个<strong>转义字符</strong>“ESC”（其十六进制编码是 1B，二进制是 00011011）。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为<strong>字节填充</strong>（byte stuffing）或<strong>字符填充</strong>（character stuffing）。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。图 3-7 表示用字节填充法解决透明传输的问题。</p> <p><img src="/assets/images/computer-networks/using-byte-filling-method-to-solve-the-problem-of-transparent-transmission.png" alt="用字节填充法解决透明传输的问题"/> <em>图 3-7 用字节填充法解决透明传输的问题</em></p> <h4 id="4差错检测">（4）差错检测</h4> <p>现实的通信链路都不会是理想的。这就是说，比特在传输过程中可能会产生差错：1 可能会变成 0，而 0 也可能变成 1。这就叫做<strong>比特差错</strong>。比特差错是传输差错中的一种。在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率 BER</strong> （Bit Error Rate）。例如，误码率为 $10^{-10}$ 时，表示平均每传送 $10_{10}$ 个比特就会出现一个比特的差错。误码率与信噪比有很大的关系。如果设法提高信噪比，就可以使误码率减小。实际的通信链路并不是理想的，它不可能使误码率下降到零。因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了<strong>循环冗余检验 CRC</strong>（Cyclic Redundancy Check）的检错技术。</p> <p>下面我们通过一个简单的例子来说明循环冗余检验的原理。</p> <p>在发送端，先把数据划分为组，假定每组 k 个比特。现假定待传送的数据 M = 101001（k = 6）。CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位<strong>冗余码</strong>，然后构成一个帧发送出去，一共发送（k + n）位。在所要发送的数据后面增加 n 位的冗余码，虽然增大了数据传输的开销，但却可以进行差错检测。当传输可能出现差错时，付出这种代价往往是很值得的。</p> <p>这 n 位冗余码可用以下方法得出。用二进制的<strong>模 2 运算</strong>进行 $2^n$ 乘 M 的运算，这相当于在 M 后面添加 n 个 O。得到的（k + n）位的数除以收发双方事先商定的长度为（n + 1）位的除数 P，得出商是 Q 而余数是 R（n 位，比 P 少一位）（关于除数 P 下面还要介绍）。在图 3-8 所示的例子中，M = 101001（即 k = 6）。假定除数P = 1101（即 n = 3）。经模 2 除法运算后的结果是：商 Q = 110101 （这个商并没有什么用处），而余数 R = 001。这个余数 R 就作为冗余码拼接在数据 M 的后面发送出去。这种为了进行检错而添加的冗余码常称为<strong>帧检验序列 FCS</strong>（Frame Check Sequence）。因此加上 FCS 后发送的帧是 101001001（即 $2^nM$ + FCS），共有（k + n）位。</p> <p>顺便说一下，循环冗余检验 CRC 和帧检验序列 FCS 并不是同一个概念。CRC 是一种检错方法，而 FCS 是添加在数据后面的冗余码，在检错方法上可以选用 CRC，但也可不选用 CRC。</p> <p><img src="/assets/images/computer-networks/examples-that-illustrate-the-principle-of-cyclic-redundancy-checking.png" alt="说明循环冗余检验原理的例子"/> <em>图 3-8 说明循环冗余检验原理的例子</em></p> <p>在接收端把接收到的数据帧为单位进行 CRC 检验：把收到的每个帧都除以同样的除数 P（模 2 运算），然后检查得到的余数 R。</p> <p>如果在传输过程中无差错，那么经过 CRC 检验后得出的余数 R 肯定是 0（读者可以自己验算一下。被除数现在是 101001001，而除数是 P = 1101，看余数 R 是否为 0）。</p> <p>但如果出现误码，那么余数 R 仍等于零的概率是非常非常小的（这可以通过不太复杂的概率计算得出，例如，可参考[TANE11]）。</p> <p>总之，在接收端对收到的每一帧经过 CRC 检验后，有以下两种情况：</p> <ul> <li>若得出的余数 R = 0，则判定这个帧没有差错，就接受（accept）。</li> <li>若余数 R ≠ 0，则判定这个帧有差错（但无法确定究竟是哪一位或哪几位出现了差错），就丢弃。</li> </ul> <p>一种较方便的方法是用多项式来表示循环冗余检验过程。在上面的例子中，用多项式 P(X) = $X_3$ + $X_2$ + 1 表示上面的除数 P = 1101（最高位对应于 $X_3$，最低位对应于 $X_0$）。多项式 P(X) 称为<strong>生成多项式</strong>。现在广泛使用的生成多项式 P(X) 有以下几种：</p> <p>\(CRC-16 = X_{16} + X_{15} + X_2 + 1\) \(CRC-CCITT = X_{16} + X_{12} + X_5 + 1\) \(CRC-32 = X_{32} + X_{26} + X_{23} + X_{22} + X_{16} + X_{12} + X_{11} + X_{10} + X_8 + X_7 + X_5 + X_4 + X_2 + X + 1\)</p> <p>在数据链路层，发送端帧检验序列 FCS 的生成和接收端的 CRC 检验都是用硬件完成的，处理很迅速，因此并不会延误数据的传输。</p> <p>从以上的讨论不难看出，如果我们在传送数据时不以帧为单位来传送，那么就无法加入冗余码以进行差错检验。因此，如果要在数据链路层进行差错检验，就必须把数据划分为帧，每一帧都加上冗余码，一帧接一帧地传送，然后在接收方逐帧进行差错检验。</p> <p>最后再强调一下，在数据链路层若<strong>仅仅</strong>使用循环冗余检验 CRC 差错检测技术，则只能做到对帧的<strong>无差错接受</strong>，即：“<strong>凡是接收端数据链路层接受的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错</strong>”。接收端丢弃的帧虽然曾<strong>收到</strong>了，但最终还是因为有差错被丢弃，即没有被<strong>接受</strong>。以上所述的可以近似地表述为（通常都是这样认为）：“<strong>凡是接收端数据链路层接受的帧均无差错</strong>”。</p> <p>注意，我们现在并没有要求数据链路层向网络层提供“<strong>可靠传输</strong>”的服务。所谓“可靠传输”就是：数据链路层的发送端发送什么，在接收端就收到什么。传输差错可分为两大类：一类就是前面所说的最基本的比特差错，而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了<strong>帧丢失</strong>、<strong>帧重复</strong>或<strong>帧失序</strong>。例如，发送方连续传送三个帧：[#1]-[#2]-[#3]。假定接收端收到的每个帧都没有比特差错，但却出现下面的几种情况：</p> <ul> <li><strong>帧丢失</strong>：收到[#1]-[#3]（丢失[#2]）。</li> <li><strong>帧重复</strong>：收到[#1]-[#2]-[#2]-[#3]（收到两个[#2]）。</li> <li><strong>帧失序</strong>：收到[#1]-[#3]-[#2]（后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样）。</li> </ul> <p>以上三种情况都属于“<strong>出现传输差错</strong>”，但都不是这些帧里有“比特差错”。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂。</p> <p>总之，我们应当明确，“无比特差错”与“无传输差错”并不是同样的概念。在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</p> <p>我们知道，过去 OSI 的观点是：必须让数据链路层向上提供可靠传输。因此在 CRC 检错的基础上，增加了<strong>帧编号</strong>、<strong>确认</strong>和<strong>重传机制</strong>。收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。这种方法在历史上曾经起到很好的作用。但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。因此，现在互联网就采取了区别对待的方法：</p> <ul> <li>对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，运输层的 TCP 协议）来完成。</li> <li>对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</li> </ul> <p>实践证明，这样做可以提高通信效率。</p> <h2 id="二点对点协议-ppp">二、点对点协议 PPP</h2> <p>在通信线路质量较差的年代，在数据链路层使用可靠传输协议曾经是一种好办法。因此，能实现可靠传输的<strong>高级数据链路控制 HDLC</strong>（High-level Data Link Control）就成为当时比较流行的数据链路层协议。但现在 HDLC 已很少使用了。对于点对点的链路，简单得多的<strong>点对点协议 PPP</strong>（Point-to-Point Protocol）则是目前使用得最广泛的数据链路层协议。</p> <h3 id="21-ppp-协议的特点">2.1 PPP 协议的特点</h3> <p>我们知道，互联网用户通常都要连接到某个 ISP 才能接入到互联网。PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议（图 3-9）。</p> <p><img src="/assets/images/computer-networks/the-link-between-the-user-and-the-isp-uses-ppp.png" alt="用户到 ISP 的链路使用 PPP 协议"/> <em>图 3-9 用户到 ISP 的链路使用 PPP 协议</em></p> <p>PPP 协议是 IETF 在 1992 年制定的。经过 1993 年和 1994 年的修订，现在的 PPP 协议在 1994 年就已成为互联网的正式标准[RFC 1661]。</p> <h4 id="1ppp-协议应满足的需求">（1）PPP 协议应满足的需求</h4> <p>IETF 认为，在设计 PPP 协议时必须考虑以下多方面的需求[RFC 1547]：</p> <ol> <li><strong>简单</strong>：IETF 在设计互联网体系结构时把其中最复杂的部分放在 TCP 协议中，而网际协议 IP 则相对比较简单，它提供的是不可靠的数据报服务。在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。IETF 把“简单”作为<strong>首要的需求</strong>。简单的设计还可使协议在实现时不容易出错，从而使不同厂商在协议的不同实现上的互操作性提高了。我们知道，协议标准化的一个主要目的就是提高协议的互操作性。总之，这种数据链路层的协议非常简单：接收方每收到一个帧，就进行 CRC 检验。如 CRC 检验正确，就收下这个帧；反之，就丢弃这个帧，<strong>其他什么也不做</strong>。</li> <li><strong>封装成帧</strong>：PPP 协议必须规定特殊的字符作为帧定界符（即标志一个帧的开始和结束的字符），以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</li> <li><strong>透明性</strong>：PPP 协议必须保证数据传输的透明性。这就是说，如果数据中碰巧出现了和帧定界符一样的比特组合时，就要采取有效的措施来解决这个问题。</li> <li><strong>多种网络层协议</strong>：PPP 协议必须能够<strong>在同一条物理链路上同时支持多种网络层协议</strong>（如 IP 和 IPX 等）的运行。当点对点链路所连接的是局域网或路由器时，PPP 协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。</li> <li><strong>多种类型链路</strong>：除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。例如，串行的（一次只发送一个比特）或并行的（一次并行地发送多个比特），同步的或异步的，低速的或高速的，电的或光的，交换的动态的）或非交换的（静态的）点对点链路。</li> <li><strong>差错检测</strong>：PPP 协议必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong>。若在数据链路层不进行差错检测，那么已出现差错的无用帧就还要在网络中继续向前转发，因而会白白浪费许多的网络资源。</li> <li><strong>检测连接状态</strong>：PPP 协议必须具有一种机制能够及时（不超过几分钟）自动检测出链路是否处于正常工作状态。当出现故障的链路隔了一段时间后又重新恢复正常工作时，就特别需要有这种及时检测功能。</li> <li><strong>最大传送单元</strong>：PPP 协议必须对每种类型的点对点链路设置<strong>最大传送单元 MTU</strong> 的标准默认值。这样做是为了促进各种实现之间的互操作性。如果高层协议发送的分组过长并超过 MTU 的数值，PPP 就要丢弃这样的帧，并返回差错。需要强调的是，MTU 是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，而不是帧的总长度。</li> <li><strong>网络层地址协商</strong>：PPP 协议必须提供一种机制使通信的两个网络层（例如，两个 IP 层）的实体能够通过协商知道或能够配置彼此的网络层地址。协商的算法应尽可能简单，并且能够在所有的情况下得出协商结果。这对拨号连接的链路特别重要，因为如果仅仅在链路层建立了连接而不知道对方网络层地址，则还不能够保证网络层可以传送分组。</li> <li><strong>数据压缩协商</strong>：PPP 协议必须提供一种方法来协商使用数据压缩算法。但PPP协议并不要求将数据压缩算法进行标准化。</li> </ol> <p>在 TCP/IP 协议族中，可靠传输运输层的 TCP 协议负责，因此数据链路层的 PPP 协议不需要进行纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路（即一个主站轮流和链路上的多个从站进行通信），而只支持点对点的链路通信。此外，PPP 协议只支持全双工链路。</p> <h4 id="2ppp-协议的组成">（2）PPP 协议的组成</h4> <p>PPP 协议有三个组成部分：</p> <ol> <li>一个将 IP 数据报封装到串行链路的方法。PPP 既支持异步链路（无奇偶检验的 8 比特数据），也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。</li> <li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议 LCP</strong>（Link Control Protocol）。通信的双方可协商一些选项。在 RFC 1661 中定义了11种类型的 LCP 分组。</li> <li>一套<strong>网络控制协议 NCP</strong>（Network Control Protocol），其中的每个协议支持不同的网络层协议，如 IP、OSI 的网络层、DECnet，以及 AppleTalk 等。</li> </ol> <h3 id="22-ppp-协议的帧格式">2.2 PPP 协议的帧格式</h3> <h4 id="1各字段的意义">（1）各字段的意义</h4> <p>PPP 的帧格式如图 3-10 所示。PPP 帧的首部和尾部分别为四个字段和两个字段。首部的第一个字段和尾部的第二个字段都是标志字段 <strong>F</strong>（Flag），规定为 0x7E（符号“0x”表示它后面的字符是用十六进制表示的。十六进制的 7E 的二进制表示是 01111110）。标志字段表示一个帧的开始或结束。因此标志字段就是 PPP 帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃。</p> <p><img src="/assets/images/computer-networks/ppp-frame-format.png" alt="PPP 帧的格式"/> <em>图 3-10 PPP 帧的格式</em></p> <ul> <li>首部中的地址字段 A 规定为 0xFF（即 11111111）。</li> <li>控制字段 C 规定为 0x03 （即 00000011）（最初曾考虑以后再对这 A 和 C 两个字段的值进行其他定义，但至今也没有给出。可见这两个字段实际上并没有携带 PPP 帧的信息）。</li> <li>PPP 首部的第四个字段是 2 字节的协议字段。 <ul> <li>当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。</li> <li>若为 0xC021，则信息字段是 PPP 链路控制协议 LCP 的数据。</li> <li>而 0x8021 表示这是网络层的控制数据。</li> </ul> </li> <li>信息字段的长度是可变的，不超过 1500 字节。</li> <li>尾部中的第一个字段（2 字节）是使用 CRC 的帧检验序列 FCS。</li> </ul> <h4 id="2字节填充">（2）字节填充</h4> <p>当信息字段中出现和标志字段一样的比特（0x7E）组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。当 PPP 使用异步传输时，它把转义符定义为 0x7D（即 01111101），并使用<strong>字节填充</strong>，填充方法如下：</p> <ol> <li>把信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列（0x7D， 0x5E）。</li> <li>若信息字段中出现一个 0x7D 的字节（即出现了和转义字符一样的比特组合），则把 0x7D 转变成为 2 字节序列（0x7D， 0x5D）。</li> <li>若信息字段中出现 ASCII 码的控制字符（即数值小于0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。例如，出现 0x03 就要把它转变为2字节序列（0x7D， 0x23）。</li> </ol> <p>由于在发送端进行了字节填充，因此在链路上传送的信息字节数就超过了原来的信息字节数。但接收端在收到数据后再进行与发送端字节填充相反的变换，就可以正确地恢复出原来的信息。</p> <h4 id="3零比特填充">（3）零比特填充</h4> <p>PPP 协议用在使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符地传送）时。在这种情况下，PPP 协议采用零比特填充方法来实现透明传输。</p> <p>零比特填充的具体做法是：在发送端，先扫描整个信息字段。只要发现有 5 个连续 1，则立即填入一个 0。因此经过这种零比特填充后的数据，就可以保证在信息字段中不会出现 6 个连续 1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除，以还原成原来的信息比特流（图 3-11）。这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</p> <p><img src="/assets/images/computer-networks/fill-and-deletion-of-zero-bits.png" alt="零比特的填充与删除"/> <em>图 3-11 零比特的填充与删除</em></p> <h3 id="23-ppp-协议的工作状态">2.3 PPP 协议的工作状态</h3> <p>当用户拨号接入 ISP 后，就建立了一条从用户个人电脑到 ISP 的物理连接。这时，用户个人电脑向 ISP 发送一系列的链路控制协议 LCP 分组（封装成多个 PPP 帧），以便建立 LCP 连接。这些分组及其响应选择了将要使用的一些 PPP 参数。接着还要进行网络层配置，网络控制协议 NCP 给新接入的用户个人电脑分配一个临时的 IP 地址。这样，用户个人电脑就成为互联网上的一个有 IP 地址的主机了。</p> <p>当用户通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p> <p>上述过程可用图 3-12 的状态图来描述。</p> <p>PPP 链路的起始和终止状态永远是图 3-12 中的“<strong>链路静止</strong>”（Link Dead）状态，这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接。</p> <p>当用户个人电脑通过调制解调器呼叫路由器时（通常是在屏幕上用鼠标点击一个连接按钮），路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP 就进入“<strong>链路建立</strong>”（Link Establish）状态，其目的是建立链路层的 LCP 连接。这时 LCP 开始协商一些<strong>配置选项</strong>，即发送 LCP 的<strong>配置请求帧</strong>（Configure-Request）。这是个 PPP 帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：</p> <ul> <li>配置确认帧（Configure-Ack）：所有选项都接受。</li> <li>配置否认帧（Configure-Nak）：所有选项都理解但不能接受。</li> <li>配置拒绝帧（Configure-Reject）：选项有的无法识别或不能接受，需要协商。</li> </ul> <p><img src="/assets/images/computer-networks/ppp-status-diagram.png" alt="PPP 协议的状态图"/> <em>图 3-12 PPP 协议的状态图</em></p> <p>LCP 配置选项包括链路上的最大帧长、所使用的鉴别协议（authentication protocol）的规约（如果有的话），以及不使用 PPP 帧中的地址和控制字段（因为这两个字段的值是固定的，没有任何信息量，可以在 PPP 帧的首部中省略这两个字节）。</p> <p>协商结束后双方就建立了 LCP 链路，接着就进入“<strong>鉴别</strong>”（Authenticate）状态。在这一状态，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用<strong>口令鉴别协议 PAP</strong>（Password Authentication Protocol），则需要发起通信的一方发送身份标识符和口令。系统可允许用户若干次。如果需要有更好的安全性，则可使用更加复杂的<strong>口令握手鉴别协议 CHAP</strong>（Challenge-Handshake Authentication Protocol）。若鉴别身份失败，则转到“<strong>链路终止</strong>”（Link Terminate）状态。若鉴别成功，则进入“<strong>网络层协议</strong>”（Network-Layer Protocol）状态。</p> <p>在“<strong>网络层协议</strong>”状态，PPP 链路的两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP 协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个 PPP 协议进行通信。</p> <p>如果在 PPP 链路上运行的是 IP 协议，则对 PPP 链路的每一端配置 IP 协议模块（如分配IP地址）时就要使用 NCP 中支持 IP 的协议 —— <strong>IP 控制协议 IPCP</strong>（IP Control Protocol）。IPCP 分组也封装成 PPP 帧（其中的协议字段为 0x8021）在 PPP 链路上传送。在低速链路上运行时，双方还可以协商使用压缩的 TCP 和 IP 首部，以减少在链路上发送的比特数。</p> <p>当网络层配置完毕后，链路就进入可进行数据通信的“<strong>链路打开</strong>”（Link Open）状态。链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可发送<strong>回送请求</strong> LCP 分组（Echo-Request）和<strong>回送回答</strong> LCP 分组（Echo-Reply），以检查链路的状态。</p> <p>数据传输结束后，可以由链路的一端发出<strong>终止请求</strong> LCP 分组（Terminate-Request）请求终止链路连接，在收到对方发来的<strong>终止确认</strong> LCP 分组（Terminate-Ack）后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，也会从“链路打开”<strong>状态转到</strong>“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”状态。</p> <p>图 3-12 右方的灰色方框给出了对 PPP 协议的几个状态的说明。从设备之间无链路开始，到先建立物理链路，再建立链路控制协议 LCP 链路。经过鉴别后再建立网络控制协议 NCP 链路，然后才能交换数据。由此可见，PPP协 议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p> <h2 id="三使用广播信道的数据链路层">三、使用广播信道的数据链路层</h2> <p>广播信道可以进行一对多的通信。下面要讨论的局域网使用的就是广播信道。</p> <h3 id="31-局域网的数据链路层">3.1 局域网的数据链路层</h3> <p>局域网最主要的特点是：<strong>网络为一个单位所拥有，且地理范围和站点数目均有限</strong>。在局域网刚刚出现时，局域网比广域网具有较高的数据率、较低的时延和较小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率。</p> <p>局域网可按网络拓扑进行分类。</p> <ul> <li><strong>星形网</strong>：集线器（hub）的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了非常广泛的应用。</li> <li><strong>环形网</strong>。</li> <li><strong>总线网</strong>：各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。总线网以传统以太网最为著名。</li> </ul> <p><img src="/assets/images/computer-networks/lan-topology.png" alt="局域网的拓扑"/> <em>图 3-13 局域网的拓扑</em></p> <p>局域网工作的层次跨越了数据链路层和物理层。</p> <p>共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法：</p> <ul> <li><strong>静态划分信道</strong>：如频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价较高，不适合于局域网使用。</li> <li> <p><strong>动态媒体接入控制</strong>：又称为<strong>多点接入</strong>（multiple access），其特点是信道并非在用户通信时固定分配给用户。这里又分为以下两类：</p> <ul> <li><strong>随机接入</strong>：所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生<strong>碰撞</strong>（即发生了冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</li> <li><strong>受控接入</strong>：用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询</strong>（polling），或称为<strong>轮询</strong>。</li> </ul> </li> </ul> <h4 id="适配器的作用">适配器的作用</h4> <p>计算机与外界局域网的连接是通过<strong>通信适配器</strong>（adapter，简称为“<strong>网卡</strong>”）进行的。在这种通信适配器上面装有处理器和存储器（包括 RAM 和 ROM）。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。</p> <p>适配器所实现的功能包含了数据链路层及物理层这两个层次的功能。现在的芯片的集成度都很高，以致很难把一个适配器的功能严格按照层次的关系精确划分开。</p> <p>当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。当计算机要发送 IP 数据报时，就由协议栈把 IP 数据报向下交给适配器，组装成帧后发送到局域网。图 3-15 表示适配器的作用。注意，计算机的硬件地址就在适配器的 ROM 中，而计算机的软件地址 —— IP 地址，则在计算机的存储器中。</p> <p><img src="/assets/images/computer-networks/computers-communicate-with-local-area-networks-through-adapters.png" alt="计算机通过适配器和局域网进行通信"/> <em>图 3-15 计算机通过适配器和局域网进行通信</em></p> <h3 id="32-csmacd-协议">3.2 CSMA/CD 协议</h3> <p>为了通信的简便，以太网采取了以下两种措施：</p> <p>第一，采用较为灵活的<strong>无连接</strong>的工作方式，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编号，也不要求对方发回确认。这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，<strong>以太网提供的服务是尽最大努力的交付</strong>，即<strong>不可靠的交付</strong>。当目的站收到有差错的数据帧时（例如，用 CRC 查出有差错），就把帧丢弃，其他什么也不做。<strong>对有差错帧是否需要重传则由高层来决定</strong>。例如，如果高层使用 TCP 协议，那么 TCP 就会发现丢失了一些数据。于是经过一定的时间后，TCP 就把这些数据重新传递给以太网进行重传。但<strong>以太网并不知道这是重传帧，而是当作新的数据帧来发送</strong>。</p> <p>我们知道，总线上只要有一台计算机在发送数据，总线的传输资源就被占用。因此，<strong>在同一时间只能允许一台计算机发送数据</strong>，否则各计算机之间就会互相干扰，使得所发送数据被破坏。因此，如何协调总线上各计算机的工作就是以太网要解决的一个重要问题。以太 网采用最简单的随机接入，但有很好的协议用来减少冲突发生的概率。这好比有一屋子的人在开讨论会，没有会议主持人控制发言。想发言的随时可发言，不需要举手示意。但我们还必须有个协议来协调大家的发言。这就是：如果你听见有人在发言，那么你就必须等别人讲完了才能发言（否则就干扰了别人的发言）。但有时碰巧两个或更多的人同时发言了，那么一旦发现冲突，大家都必须立即停止发言，等听到没有人发言了你再发言。以太网采用的协调方法和上面的办法非常像，它使用的协议是 CSMA/CD，意思是<strong>载波监听多点接入</strong>/<strong>碰撞检测</strong>（Carrier Sense Multiple Access with Collision Detection）。</p> <p>第二，以太网发送的数据都使用<strong>曼彻斯特编码</strong>的信号。我们知道，二进制基带数字信号通常就是高、低电压交替出现的信号。使用这种信号的最大问题就是当出现一长串的连 1 或 0 时，接收端就无法从收到的比特流中提取位同步（即比特同步）信号。如图 3-16 所示，曼彻斯特编码的编码方法是把每个码元再分成两个相等的间隔。码元 1 是前一个间隔为低电压而后一个间隔为高电压。码 0 则正好相反，从高电压变到低电压（也可采用相反的约定，即 1 是“前高后低”而 0 是“前低后高”）。这样就保证了在每个码元的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来。但是从曼彻斯特编码的波形图也不难看出其缺点，这就是它所占的频带宽度比原始的基带信号增加了一倍（因为每秒传送的码数加倍了）。</p> <p><img src="/assets/images/computer-networks/manchester-encoding.png" alt="曼彻斯特编码"/> <em>图 3-16 曼彻斯特编码</em></p> <p>下面介绍 CSMA/CD 协议的要点。</p> <ul> <li>“<strong>多点接入</strong>”就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。</li> <li>“<strong>载波监听</strong>”就是用电子技术检测总线上有没有其他计算机也在发送。其实总线上并没有什么“载波”，这里只不过借用一下“载波”这个名词而已。因此载波监听就是<strong>检测信道</strong>，这是个很重要的措施。<strong>不管在发送前，还是在发送中，每个站都必须不停地检测信道</strong>。在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。这就称为碰撞检测。</li> <li>“<strong>碰撞检测</strong>”也就是“<strong>边发送边监听</strong>”，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大（互相叠加）。当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“<strong>冲突检测</strong>”。这时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。因此，任何一个正在发送数据的站，一旦发现总线上出现了碰撞，其适配器就要立即停止发送，免得继续进行无效的发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</li> </ul> <p>既然每个站在发送数据前已经监听到信道为“空闲”，那么为什么还会出现数据在总线上的碰撞呢？这是因为电磁波在总线上总是以有限的速率传播。这和我们开讨论会时相似。一听见会场安静，我们就立即发言，但偶尔也会发生几个人同时抢着发言而产生冲突的情况。图 3-17 所示的例子可以说明这种情况。设图中的局域网两端的站 A 和 B 相距 1km，用同轴电缆相连。<strong>电磁波在 1km 电缆的传播时延约为 $5\mu s$</strong>（这个数字应当记住）。因此，A 向 B 发出的数据，在约 $5\mu s$ 后才能传送到 B。换言之，B 若在 A 发送的数据到达 B 之前发送自己的帧（因为这时 B 的载波监听检测不到 A 所发送的信息），则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。在局域网的分析中，常把总线上的<strong>单程端到端传播时延</strong>记为 $\tau$ 。发送数据的站希望尽早知道是否发生了碰撞。那么，A 发送数据后，最迟要经过<strong>两倍的总线端到端的传播时延</strong>（$2\tau$）(或总线的端到端往返传播时延)才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延（这两个站之间的距离最大）为端到端传播时延。</p> <p><img src="/assets/images/computer-networks/influence-of-propagation-delay-on-carrier-monitoring.png" alt="传播时延对载波监听的影响"/> <em>图 3-17 传播时延对载波监听的影响</em></p> <p>显然，在使用 CSMA/CD 协议时，一个站<strong>不可能同时进行发送和接收</strong>（<strong>但必须边发送边监听信道</strong>）。因此使用 CSMA/CD 协议的以太网不可能进行全双工通信而只能进行<strong>双向交替通信</strong>（<strong>半双工通信</strong>）。</p> <p>下面是图 3-17 中的一些重要的时刻。</p> <ul> <li>在 t = 0 时，A 发送数据。B 检测到信道为空闲。</li> <li>在t = $\tau$ - $\delta$ 时（这里），A 发送的数据还没有到达 B 时，由于 B 检测到信道是空闲的，因此 B 发送数据。</li> <li>经过时间 $\delta$/2 后，即在 t = $\tau$ - $\delta$/2 时，A 发送的数据和 B 发送的数据发生了碰撞。但这时 A 和 B 都不知道发生了碰撞。</li> <li>在 t = $\tau$ 时，B 检测到发生了碰撞，于是停止发送数据。</li> <li>在 t = 2$\tau$ - $\delta$ 时，A 也检测到发生了碰撞，因而也停止发送数据。</li> </ul> <p>A 和 B 发送数据均失败，它们都要推迟一段时间再重新发送。</p> <p>由此可见，<strong>每个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性</strong>。这一小段时间是<strong>不确定的</strong>，它取决于另一个发送数据的站到本站的距离。因此，以太网<strong>不能保证</strong>某一时间内一定能够把自己的数据帧成功地发送出去（因为存在产生碰撞的可能）。以太网的这一特点称为<strong>发送的不确定性</strong>。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</p> <p>从图 3-17 可看出，最先发送数据帧的 A 站，在发送数据帧后至多经过时间 $2\tau$ 就可知道所发送的数据帧是否遭受了碰撞。这就是 $\delta$ → 0 的情况。因此以太网的端到端往返时间 $2\tau$ 称为<strong>争用期</strong>（contention period），它是一个很重要的参数。争用期又称为<strong>碰撞窗口</strong>（collision window）。这是因为一个站在发送完数据后，只有通过争用期的“考验”，即<strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。这时，就可以放心把这一帧数据顺利发送完毕。</p> <p>以太网使用<strong>截断二进制指数退避</strong>（truncated binary exponential backoff）算法来确定碰撞后重传的时机。截断二进制指数退避算法并不复杂。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是<strong>推迟</strong>（这叫做<strong>退避</strong>）一个随机的时间。这点很容易理解，因为如果几个发生碰撞的站都在监听信道，那么都会同时发现信道变成了空闲。如果大家都同时再重新发送，那么肯定又会发生碰撞。为了使各站进行重传时再次发生冲突的概率减小，具体的退避算法如下：</p> <ol> <li>协议规定了基本退避时间为争用期 $2\tau$，具体的<strong>争用期时间是 $51.2\mu s$</strong>。对于 10 Mbit/s 以太网，在争用期内可发送 512 bit，即 64 字节。也可以说争用期是 <strong>512 比特时间</strong>。1 比特时间就是发送 1 比特所需的时间。所以这种时间单位与数据密切相关。为了方便，也可以<strong>直接使用比特作为争用期的单位</strong>。争用期是 512 bit，即争用期是发送 512 bit 所需的时间。 （2） 从离散的整数集合[0, 1, …, ($2^k -1$)]中随机取出一个数，记为 r。重传应推后的时间就是 r 倍的争用期。上面的参数 k 按下面的公式计算：</li> </ol> \[k = Min[重传次数，10]\] <p>可见当重传次数不超过 10 时，参数等于重传次数；但当重传次数超过 10 时，k 就不再增大而一直等于 10。 （3） 当重传达 16 次仍不能成功时（这表明同时打算发送数据的站太多，以致连续发生冲突），则丢弃该帧，并向高层报告。</p> <p>例如，在第 1 次重传时，k = 1，随机数 r 从整数 {0，1} 中选一个数。因此重传的站可选择的重传推迟时间是 0 或 $2\tau$，在这两个时间中随机选择一个。</p> <p>若再发生碰撞，则在第 2 次重传时，k = 2，随机数 r 就从整数 {0, 1, 2, 3} 中选一个数。因此重传推迟的时间是在 0，$2\tau$，$4\tau$ 和 $6\tau$ 这 4 个时间中随机选取一个。</p> <p>同样，若再发生碰撞，则重传时 k = 3，随机数 r 就从整数 {0, 1, 2, 3, 4, 5, 6, 7} 中选一个数。依此类推。</p> <p>若连续多次发生冲突，就表明可能有较多的站参与争用信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为<strong>动态退避</strong>），因而减小发生碰撞的概率，有利于整个系统的稳定。</p> <p>我们还应注意到，适配器每发送一个新的帧，就要执行一次 CSMA/CD 算法。适配器对过去发生过的碰撞并无记忆功能。因此，当好几个适配器正在执行指数退避算法时，很可能有某个适配器发送的新帧能够碰巧立即成功地插入到信道中，得到了发送权，而已经推迟好几次发送的站，有可能很不巧，还要继续执行退避算法，继续等待。</p> <p>现在考虑一种情况。某个站发送了一个很短的帧，但在发送完毕之前并没有检测出碰撞。假定这个帧在继续向前传播到达目的站之前和别的站发送的帧发生了碰撞，因而目的站将收到有差错的帧（当然会把它丢弃）。可是发送站却不知道这个帧发生了碰撞，因而不会重传这个帧。这种情况显然是我们所不希望的。为了避免发生这种情况，以太网规定了一个最短帧长 64 字节，即 512 bit。如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于 64 字节。对于 10 Mbit/s 以太网，发送 512 bit 的时间需要 $51.2\mu s$**，也就是上面提到的争用期。</p> <p>由此可见，以太网在发送数据时，如果在争用期（共发送了 64 字节）没有发生碰撞，那么后续发送的数据就一定不会发生冲突。换句话说，如果发生碰撞，就一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节，因此<strong>凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧</strong>。只要收到了这种无效帧，就应当立即将其丢弃。</p> <p>前面已经讲过，信号在以太网上传播1 km 大约需要 $5\mu s$。以太网上最大的端到端时延必须小于争用期的一半（即 $25.6\mu s$），这相当于以太网的最大端到端长度约为 5km。实际上的以太网覆盖范围远远没有这样大。因此，实用的以太网都能在争用期 $51.2\mu s$ 内检测到可能发生的碰撞。以太网的争用期确定为 $51.2\mu s$，不仅考虑到以太网的端到端时延，而且还包括其他的许多因素，如存在的转发器所增加的时延，以及下面要讲到的强化碰撞的干扰信号的持续时间等。</p> <p><strong>强化碰撞</strong>指当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送 32 比特或 48 比特的人为干扰信号（jamming signal），以便让所有用户都知道现在已经发生了碰撞（图 3-18）。对于 10 Mbit/s 以太网，发送 32（或 48） 比特只需要 3.2（或 4.8）$\mu s$。</p> <p><img src="/assets/images/computer-networks/the-addition-of-artificial-interference-signals.png" alt="人为干扰信号的加入"/> <em>图 3-18 人为干扰信号的加入</em></p> <p>从图 3-18 可以看出，A 站从发送数据开始到发现碰撞并停止发送的时间间隔是 $T_B$。A 站得知碰撞已经发生时所发送的强化碰撞的干扰信号的持续时间是 $T_J$。图中的 B 站在得知发生碰撞后，也要发送人为干扰信号，但为简单起见，图 3-18 没有画出 B 站所发送的人为干扰信号。发生碰撞使 A 浪费时间 $T_B + T_J$。可是整个信道被占用的时间还要增加一个单程端到端的传播时延 $\tau$。因此总线被占用的时间是 $T_B + T_J + \tau$。</p> <p>以太网还规定了帧间最小间隔为 $9.6\mu s$，相当于 96 比特时间。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p> <p>根据以上所讨论的，可以把 CSMA/CD 协议的要点归纳如下：</p> <ol> <li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须<strong>先检测信道</strong>。</li> <li>检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。</li> <li> <p>在发送过程中仍不停地检测信道，即网络适配器要<strong>边发送边监听</strong>。这里只有两种可能性：</p> <ul> <li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到（1）。</li> <li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤（2），继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。</li> </ul> </li> </ol> <p>以太网每发送完一帧，一定要把已发送的帧暂时保留一下。如果在争用期内检测出发生了碰撞，那么还要在推迟一段时间后再把这个暂时保留的帧重传一次。</p> <h3 id="33-使用集线器的星形拓扑">3.3 使用集线器的星形拓扑</h3> <p>传统以太网使用更便宜和更灵活的双绞线。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong>（hub），如图 3-19 所示。双绞线以太网总是和集线器配合使用。每个站需要用两对无屏蔽双绞线（放在一根电缆内），分别用于发送和接收。双绞线的两端使用 RJ-45 插头。由于集线器使用了大规模集成电路芯片，因此集线器的可靠性就大大提高了。1990 年 IEEE 制定出星形以太网 10BASE-T 的标准 802.3i。“10”代表 10 Mbit/s 的数据率，BASE 表示连接线上的信号是基带信号，T 代表双绞线。</p> <p><img src="/assets/images/computer-networks/twisted-pair-ethernet-using-a-hub.png" alt="使用集线器的双绞线以太网"/> <em>图 3-19 使用集线器的双绞线以太网</em></p> <p>但 10BASE-T 以太网的通信距离稍短，每个站到集线器的距离不超过 100m。这种性价比很高的 10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，从此以太网的拓扑就从总线型变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。</p> <p>使双绞线能够传送高速数据的主要措施是把双绞线的绞合度做得非常精确。这样不仅可使特性阻抗均匀以减少失真，而且大大减少了电磁波辐射和无线电频率的干扰。在多对双绞线的电缆中，还要使用更加复杂的绞合方法。集线器的一些特点如下：</p> <ul> <li>从表面上看，使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一个传统以太网那样运行。也就是说，<strong>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD 协议</strong>（更具体些说，是各站中的适配器执行 CSMA/CD 协议）。网络中的各站必须竞争对传输媒体的控制，并且<strong>在同一时刻至多只允许一个站发送数据</strong>。</li> <li>一个集线器有许多<strong>接口</strong>，例如 8 至 16 个，每个接口通过 RJ-45 插头（与电话机使用的插头 RJ-11 相似，但略大一些）用两对双绞线与一台计算机上的适配器相连（这种插座可连接 4 对双绞线，实际上只用 2 对，即发送和接收各使用一对双绞线）。因此，一个集线器很像一个多接口的转发器。</li> <li><strong>集线器工作在物理层</strong>，它的每个接口仅仅<strong>简单地转发比特</strong> —- 收到 1 就转发 1，收到 0 就转发 0，不进行碰撞检测。若两个接口同时有信号输入（即发生碰撞），那么所有的接口都将收不到正确的帧。图 3-20 是具有三个接口的集线器的示意图。</li> <li>集线器采用了专门的芯片，进行自适应串音回波抵消。这样就可使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰（这种干扰即近端串音）。每个比特在转发之前还要进行再生整形并重新定时。</li> </ul> <p><img src="/assets/images/computer-networks/a-hub-with-three-interfaces.png" alt="具有三个接口的集线器"/> <em>图 3-20 具有三个接口的集线器</em></p> <h3 id="34-以太网的信道利用率">3.4 以太网的信道利用率</h3> <p>假定一个 10 Mbit/s 以太网同时有 10 个站在工作，那么每个站所能发送数据的平均速率似乎应当是总数据率的 1/10（即 1Mbit/s）。其实不然，因为多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到 100%。</p> <p>图 3-21 的例子是以太网的信道被占用的情况。一个站在发送帧时出现了碰撞。经过一个争用期 $2\tau$ 后（$\tau$ 是以太网单程端到端传播时延），可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 $T_0$。它等于帧长（bit）除以发送速率（10 Mbit/s）。</p> <p><img src="/assets/images/computer-networks/the-ethernet-channel-is-occupied.png" alt="以太网的信道被占用的情况"/> <em>图 3-21 以太网的信道被占用的情况</em></p> <p>我们应当注意到，成功发送一个帧需要占用信道的时间是 $T_0 + \tau$，比这个帧的发送时间要多一个单程端到端时延。这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是 $\tau$。因此，必须在经过时间 $T_o + \tau$ 后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</p> <p>从图 3-21 可看出，要提高以太网的信道利用率，就必须减小 $\tau$ 与 $T_0$ 之比。在以太网中定义了参数 a，它是以太网单<strong>程端到端时延 $\tau$ 与帧的发送时间 $T_0$ 之比</strong>：</p> \[a = \frac{\tau}{T_0}\] <p>当 a → 0 时，表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常非常少。反之，参数 a 越大，表明争用期所占的比例越大，这就使得每发生一次碰撞就浪费了不少的信道资源，使得信道利用率明显降低。因此，以太网的参数 a 的值应当尽可能小些。从（3-2）式可看出，这就要求（3-2）式分子 $\tau$ 的数值要小些，而分母 $T_0$ 的数值要大些。这就是说，当数据率一定时，以太网的连线的长度受到限制（否则 $\tau$ 的数值会太大），同时以太网的帧长不能太短（否则 $T_0$ 的值会太小，使 a 值太大）。</p> <p>现在考虑一种理想化的情况。假定以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），并且能够非常有效地利用网络的传输资源，即总线一旦空闲就有某一个站立即发送数据。这样，发送一帧占用线路的时间是 $T_0 + \tau$，而帧本身的发送时间是 $T_0$。于是我们可计算出极限信道利用率 $S_{max}$ 为：</p> \[S{max} = \frac{T_o}{T_0 + \tau} = \frac{1}{1 + a}\] <p>上式的意义是：虽然实际的以太网不可能有这样高的极限信道利用率，但上式指出了<strong>只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率</strong>。反之，若参数 a 远大于 1（即每发生一次碰撞，就要浪费相对较多的传输数据的时间），则极限信道利用率就远小于 1，而这时实际的信道利用率就更小了。据统计，当以太网的利用率达到 30% 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p> <h3 id="35-以太网的-mac-层">3.5 以太网的 MAC 层</h3> <h4 id="1mac-层的硬件地址">（1）MAC 层的硬件地址</h4> <p>在局域网中，硬件地址又称为物理地址或 MAC 地址（因为这种地址用在 MAC 帧中）。</p> <p>IEEE 802 标准为局域网规定了一种 48 位的全球地址（一般都简称为“地址”），是指局域网上的每台计算机中<strong>固化在适配器的 ROM 中的地址</strong>。</p> <p>严格地讲，局域网的“地址”应当是每个站的“<strong>名字</strong>”或<strong>标识符</strong>[PERL00]。人们习惯于把这种 48 位的“名字”称为“地址”。</p> <p>请注意，如果连接在局域网上的主机或路由器安装有多个适配器，那么这样的主机或 路由器就有多个“地址”。更准确些说，这种48位“地址”应当是某个接口的标识符。</p> <p>现在 IEEE 的<strong>注册管理机构 RA</strong>（Registration Authority）是局域网全球地址的法定管理机构[W-IEEERA]，它负责分配地址字段的 6 个字节中的前三个字节（即高位 24 位）。世界上凡要生产局域网适配器的厂家都必须向 IEEE 购买由这三个字节构成的这个号（即地址块），这个号的正式名称是<strong>组织唯一标识符 OUI</strong>（Organizationally Unique Identifier），通常也叫做<strong>公司标识符</strong>（company_id）。地址字段中的后三个字节（即低位 24位）则由厂家自行指派，称为<strong>扩展标识符</strong>（extended identifier），只要保证生产出的适配器没有重复地址即可。可见用一个地址块可以生成 $2^{24}$ 个不同的地址。用这种方式得到的 48 位地址称为 EUI-48，这里 EUI 表示<strong>扩展的唯一标识符</strong>（Extended Unique Identifier）。EUI-48 的使用范围并不局限于局域网的硬件地址，而是可以用于软件接口。但应注意，24 位的 OUI 不能够单独用来标志一个公司，因为一个公司可能有几个 OUI，也可能有几个小公司合起来购买一个 OUI。在生产适配器时，这种 6 字节的 MAC 地址已被固化在适配器的 ROM 中。因此，MAC 地址也叫做<strong>硬件地址</strong>（hardware address）或<strong>物理地址</strong>。可见“MAC 地址”实际上就是<strong>适配器地址</strong>或<strong>适配器标识符 EUI-48</strong>。当这块适配器插入（或嵌入）到某台计算机后，适配器上的标识符 EUI-48 就成为这台计算机的 MAC 地址了。</p> <p>IEEE 规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual/Group。当 I/G 位为 0 时，地址字段表示一个<strong>单个站地址</strong>。当 I/G 位为 1 时表示组地址，用来进行多播。因此，IEEE 只分配地址字段前三个字节中的 23 位。当 I/G 位分别为 0 和 1 时，一个地址块可分别生成 $2^{24}$ 个单个站地址和 $2^{24}$ 个组地址。</p> <p>IEEE 还考虑到可能有人并不愿意向 IEEE 的 RA 购买 OUI。为此，IEEE 把地址字段第 1 字节的最低第二位规定为 G/L 位，表示 Global/Local。当 G/L 位为 0 时是全球管理（保证在全球没有相同的地址），厂商向 IEEE 购买的 OUI 都属于<strong>全球管理</strong>。当地址字段的 G/L 位为 1 时是<strong>本地管理</strong>，这时用户可任意分配网络上的地址。采用 2 字节地址字段时全都是本地管理。但应当指出，以太网几乎不理会这个 G/L 位。</p> <p>这样，在全球管理时，对每个站的地址可用 46 位的二进制数字来表示（最低位和最低第 2 位均为 0 时）。剩下的 46 位组成的地址空间可以有 $2^{46}$ 个地址，已经超过 70 万亿个，可保证世界上的每一个适配器都可有一个唯一的地址。</p> <p>当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。</p> <p>我们知道适配器有过滤功能。但适配器从网络上每收到一个 MAC 帧就先用硬件检查 MAC 帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。这里“发往本站的帧”包括以下三种帧：</p> <ul> <li><strong>单播</strong>（unicast）帧 （一对一），即收到的帧的 MAC 地址与本站的硬件地址相同。</li> <li><strong>广播</strong>（broadcast）帧（一对全体），即发送给本局域网上所有站点的帧（全 1 地址）。</li> <li><strong>多播</strong>（multicast）帧（一对多），即发送给本局域网上一部分站点的帧。</li> </ul> <p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。有的适配器可用编程方法识别多播地址。当操作系统启动时，它就把适配器初始化，使适配器能够识别某些多播地址。显然，只有目的地址才能使用广播地址和多播地址。</p> <p>以太网适配器还可设置为一种特殊的工作方式，即<strong>混杂方式</strong>（promiscuous mode）。工作在混杂方式的适配器只要“听到”有帧在以太网上传输就都悄悄地接收下来，而不管这些帧是发往哪个站。请注意，这样做实际上是“窃听”其他站点的通信而并不中断其他站点的通信。网络上的黑客（hacker 或 cracker）常利用这种方法非法获取网上用户的口令。因此，以太网上的用户不愿意网络上有工作在混杂方式的适配器。</p> <p>但混杂方式有时却非常有用。例如，网络维护和管理人员需要用这种方式来监视和分析以太网上的流量，以便找出提高网络性能的具体措施。有一种很有用的网络工具叫做<strong>嗅探器</strong>（Sniffer）就使用了设置为混杂方式的网络适配器。此外，这种嗅探器还可帮助学习网络的人员更好地理解各种网络协议的工作原理。因此，混杂方式就像一把双刃剑，是利是弊要看你怎样使用它。</p> <h4 id="2mac-帧的格式">（2）MAC 帧的格式</h4> <p>常用的以太网 MAC 帧格式有两种标准，一种是 DIX Ethernet V2 标准（即以太网 V2 标准），另一种是 IEEE 的 802.3 标准。这里只介绍使用得最多的以太网 V2 的 MAC 帧格式（图 3-22）。图中假定网络层使用的是 IP 协议。实际上使用其他的协议也是可以的。</p> <p><img src="/assets/images/computer-networks/mac-frame-format-of-ethernet-v2.png" alt="以太网 V2 的 MAC 帧格式"/> <em>图 3-22 以太网 V2 的 MAC 帧格式</em></p> <p>以太网 V2 的 MAC 帧较为简单，由五个字段组成。</p> <ol> <li>第一个字段为 6 字节长的<strong>目的地址</strong>字段。</li> <li>第二个字段为 6 字节长的<strong>源地址</strong>字段。</li> <li>第三个字段是 2 字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。例如，当类型字段的值是 0x0800 时，就表示上层使用的是 IP 数据报。若类型字段的值为 0x8137，则表示该帧是由 Novell IPX 发过来的。</li> <li>第四个字段是数据字段，其长度在 46 到 1500 字节之间（46 字节是这样得出的：最小长度 64 字节减去 18 字节的首部和尾部就得出数据字段的最小长度）。</li> <li>最后一个字段是 4 字节的帧检验序列 FCS（使用 CRC 检验）。当传输媒体的误码率为 $1 x 10^{-8}$ 时，MAC 子层可使未检测到的差错小于 $1 x 10^{-14}$。</li> </ol> <p>这里我们要指出，在以太网 V2 的 MAC 帧格式中，其首部并没有一个帧长度（或数据长度）字段。那么，MAC 子层又怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议呢？我们在前面讲述图 3-16 的曼彻斯特编码时已经讲过，这种曼彻斯特编码的一个重要特点就是：在曼彻斯特编码的每个码元（不管码元是 1 或 0）的正中间一定有一次电压的转换（从高到低或从低到高）。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了（既不发送 1，也不发送 0）。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数 4 字节（FCS 字段长度是4字节），就能确定数据字段的结束位置。</p> <p>当数据字段的长度小于 46 字节时，MAC 子层就会在数据字段的后面加入一个整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。我们应当注意到，MAC 帧的首部并没有指出数据字段的长度是多少。在有填充字段的情况下，接收端的 MAC 子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。现在的问题是：上层协议如何知道填充字段的长度呢?（IP 层应当丢弃没有用处的填充字段。可见，上层协议必须具有识别有效的数据字段长度的功能。我们知道，当上层使用 IP 协议时，其首部就有一个“总长度”字段。因此，“总长度”加上填充字段的长度，应当等于 MAC 帧数据字段的长度。例如，当 IP 数据报的总长度为 42 字节时，填充字段共有 4 字节。当 MAC 帧把 46 字节的数据上交给 IP 层后，IP 层就把其中最后 4 字节的填充字段丢弃。</p> <p>从图 3-22 可看出，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节。这是因为当一个站在刚开始接收 MAC 帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此 MAC 帧的最前面的若干位就无法接收，结果使整个的 MAC 成为无用的帧。为了接收端迅速实现同步，从 MAC 子层向下传到物理层时还要在帧的前面插入 8 字节（由硬件生成），它由两个字段构成。</p> <ul> <li>第一个字段是 7 个字节的前同步码（1 和 0 交替码），它的作用是使接收端的适配器在接收 MAC 帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现同步”（同步就是比特同步的意思）。</li> <li>第二个字段是帧开始定界符，定义为 10101011。它的前六位的作用和前同步码一样，最后的两个连续的就是告诉接收端适配器：“MAC 帧的信息马上就要来了，请适配器注意接收”。</li> </ul> <p>MAC 帧的 FCS 字段的检验范围不包括前同步码和帧开始定界符。顺便指出，在使用 SONET/SDH 进行同步传输时则不需要用前同步码，因为在同步传输时收发双方的位同步总是一直保持着的。</p> <p>还需注意，在以太网上传送数据时是以帧为单位传送的。以太网在传送帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个 MAC 帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。</p> <p>IEEE 802.3 标准规定凡出现下列情况之一的即为无效的 MAC 帧：</p> <ul> <li>帧的长度不是整数个字节。</li> <li>用收到的帧检验序列 FCS 查出有差错。</li> <li>收到的帧的 MAC 客户数据字段的长度不在 46~1500 字节之间。考虑到 MAC 帧首部和尾部的长度共有 18 字节，可以得出有效的 MAC 帧长度为 64~1518 字节之间。</li> </ul> <p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p> <p>最后要提一下，IEEE 802.3 标准规定的 MAC 帧格式与上面所讲的以太网 V2 MAC 帧格式的区别就是两个地方。</p> <p>第一，IEEE 802.3 规定的 MAC 帧的第三个字段是“长度/类型”。当这个字段值大于 0x0600 时（相当于十进制的 1536），就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。只有当这个字段值小于 0x0600 时才表示“长度”，即 MAC 帧的数据部分长度。显然，在这种情况下，若数据字段的长度与长度字段的值不一致，则该帧为无效的 MAC 帧。实际上，前面我们已经讲过，由于以太网采用了曼彻斯特编码，长度字段并无实际意义。</p> <p>第二，当“长度/类型”字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</p> <p>由于现在广泛使用的局域网只有以太网，因此 LLC 帧已经失去了原来的意义。现在市场上流行的都是以太网 V2 的 MAC 帧，但大家也常常把它称为 IEEE 802.3 标准的 MAC 帧。</p> <h2 id="四扩展的以太网">四、扩展的以太网</h2> <p>在许多情况下，我们希望对以太网的覆盖范围进行扩展。本节先讨论在物理层对以太网扩 展，然后讨论在数据链路层对以太网扩展。这种扩展的以太网在网络层看来仍然是一个网络。</p> <h3 id="41-在物理层扩展以太网">4.1 在物理层扩展以太网</h3> <p>以太网上的主机之间的距离不能太远（例如，10BASE-T 以太网的两台主机之间的距离 不超过200 米），否则主机发送的信号经过铜线的传输就会衰减到使 CSMA/CD 协议无法正 常工作。在过去广泛使用粗缆或细缆以太网时，常使用工作在物理层的转发器来扩展以太网 的地理覆盖范围。那时，两个网段可用一个转发器连接起来。IEEE 802。3 标准还规定，任意 两个站之间最多可以经过三个电缆网段。但随着双绞线以太网成为以太网的主流类型，扩展 以太网的覆盖范围已很少使用转发器了。 现在，扩展主机和集线器之间的距离的一种简单方法就是使用光纤（通常是一对光 纤）和一对光纤调制解调器，如图3-23所示。</p> <p><img src="" alt=""/> <em>图 3-23 主机使用光纤和一对光纤调制解调器连接到集线器</em></p> <p>光纤调制解调器的作用就是进行电信号和光信号的转换。由于光纤带来的时延很小， 并且带宽很宽，因此使用这种方法可以很容易地使主机和几公里以外的集线器相连接。 如果使用多个集线器，就可以连接成覆盖更大范围的多级星形结构的以太网。例如， 一个学院的三个系各有一个 10BASE-T 以太网（图3-24（a）），可通过一个主干集线器把各系 的以太网连接起来，成为一个更大的以太网（图3-24（b））。</p> <p><img src="" alt=""/> <em>图 3-24 用多个集线器连成更大的以太网</em></p> <p>这样做可以有以下两个好处。第一，使这个学院不同系的以太网上的计算机能够进行 跨系的通信。第二，扩大了以太网覆盖的地理范围。例如，在一个系的 10BASE-T 以太网 中，主机与集线器的最大距离是100m，因而两台主机之间的最大距离是200 m。但在通过 主干集线器相连接后，不同系的主机之间的距离就可扩展了，因为集线器之间的距离可以是 100m（使用双绞线）或甚至更远（如使用光纤）。 但这种多级结构的集线器以太网也带来了一些缺点。 （1） 如图 3-24（a）所示的例子，在三个系的以太网互连起来之前，每一个系的 10BASE-T 以太网是一个独立的碰撞域（collision domain，又称为冲突域），即在任一时刻，在每一个 碰撞域中只能有一个站在发送数据。每一个系的以太网的最大吞吐量是10 Mbit/s，因此三 个系总的最大吞吐量共有 30 Mbit/s。在三个系的以太网通过集线器互连起来后就把三个碰 撞域变成一个碰撞域（范围扩大到三个系），如图3-24（b）所示，而这时的最大吞吐量仍然是 一个系的吞吐量 10 Mbit/s。这就是说，当某个系的两个站在通信时所传送的数据会通过所 有的集线器进行转发，使得其他系的内部在这时都不能通信（一发送数据就会碰撞）。 （2） 如果不同的系使用不同的以太网技术（如数据率不同），那么就不可能用集线器将 它们互连起来。如果在图 3-24 中，一个系使用 10 Mbit/s 的适配器，而另外两个系使用 10/100Mbit/s 的适配器，那么用集线器连接起来后，大家都只能工作在10 Mbit/s 的速率。 集线器基本上是个多接口（即多端口）的转发器，它并不能把帧进行缓存。</p> <h3 id="42-在数据链路层扩展以太网">4.2 在数据链路层扩展以太网</h3> <p>扩展以太网更常用的方法是在数据链路层进行。最初人们使用的是网桥（bridge）。网桥 对收到的帧根据其 MAC 帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所 有的接口转发此帧，而是根据此帧的目的 MAC 地址，查找网桥中的地址表，然后确定将该 帧转发到哪一个接口，或者是把它丢弃（即过滤）。 1990 年问世的交换式集线器（switching hub），很快就淘汰了网桥。交换式集线器常称为 以太网交换机（switch）或第二层交换机（L2 switch），强调这种交换机工作在数据链路层。 “交换机”并无准确的定义和明确的概念。著名网络专家 Perlman认为：“交换机”应 当是一个市场名词，而交换机的出现的确使数据的转发更加快速了[PERL00]。本书也使用 这个广泛被接受的名词——以太网交换机。下面简单地介绍以太网交换机的特点。 1。以太网交换机的特点 以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口，和工作 在物理层的转发器、集线器有很大的差别。以太网交换机的每个接口都直接与一个单台主机 或另一个以太网交换机相连，并且一般都工作在全双工方式。以太网交换机还具有并行性， 即能同时连通多对接口，使多对主机能同时通信（而网桥只能一次分析和转发一个帧）。相 互通信的主机都是独占传输媒体，无碰撞地传输数据。 以太网交换机的接口还有存储器，能在输出端口繁忙时把到来的帧进行缓存。因此， 如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的接口 繁忙时，发送帧的这两台主机的接口会把收到的帧暂存一下，以后再发送出去。 以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过自学 习算法自动地逐渐建立起来的。以太网交换机由于使用了专用的交换结构芯片，用硬件转 发，其转发速率要比使用软件转发的网桥快很多。 以太网交换机的性能远远超过普通的集线器，而且价格并不贵，这就使工作在物理层 的集线器逐渐地退出了市场。 对于传统的 10 Mbit/s 的共享式以太网，若共有10 个用户，则每个用户占有的平均带宽 只有1Mbit/s。若使用以太网交换机来连接这些主机，虽然在每个接口到主机的带宽还是 10 Mbit/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此 对于拥有 10 个接口的交换机的总容量则为100 Mbit/s。这正是交换机的最大优点。 从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不 需要作任何改动。 以太网交换机一般都具有多种速率的接口，例如，可以具有 10 Mbit/s、100 Mbit/s 和 1 Gbit/s 的接口的各种组合，这就大大方便了各种不同情况的用户。 虽然许多以太网交换机对收到的帧采用存储转发方式进行转发，但也有一些交换机采 用直通（cut-through）的交换方式。直通交换不必把整个数据帧先缓存后再进行处理，而是在 接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的 转发速度。如果在这种交换机的内部采用基于硬件的交叉矩阵，交换时延就非常小。直通交 换的一个缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他 的站。在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线 路速率匹配、协议转换或差错检测时。现在有的厂商已生产出能支持两种交换方式的以太网 交换机。以太网交换机的发展与建筑物结构化布线系统的普及应用密切相关。在结构化布线 系统中，广泛地使用了以太网交换机。 2。以太网交换机的自学习功能 我们用一个简单例子来说明以太网交换机是怎样进行自学习的。 假定在图 3-25 中的以太网交换机有4个接口，各连接一台计算机，其MAC地址分别 是 A，B，C 和 D。在一开始，以太网交换机里面的交换表是空的（图3-25（a））。</p> <p><img src="" alt=""/> <em>图 3-25 以太网交换机中的交换表</em></p> <p>A 先向 B 发送一帧，从接口进入到交换机。交换机收到帧后，先查找交换表，没有 查到应从哪个接口转发这个帧（在 MAC 地址这一列中，找不到目的地址为 B 的项目）。接 着，交换机把这个帧的源地址 A和接口1写入交换表中，并向除接口 1 以外的所有接口广 播这个帧（这个帧就是从接口1进来的，当然不应当把它再从接口1转发出去）。 C 和 D 将丢弃这个帧，因为目的地址不对。只 B 才收下这个目的地址正确的帧。这也 称为过滤。 从新写入交换表的项目（A， 1）可以看出，以后不管从哪一个接口收到帧，只要其目的地 址是 A，就应当把收到的帧从接口 1 转发出去。这样做的依据是：既然 A 发出的帧是从接 口1进入到交换机的，那么从交换机的接口1转发出的帧也应当可以到达 A。 假定接下来 B 通过接口 3 向 A 发送一帧。交换机查找交换表，发现交换表中的 MAC 地址有 A。表明要发送给A 的帧（即目的地址为A 的帧）应从接口1转发。于是就把这个 帧传送到接口1转发给A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的 项目（B， 3），表明今后如有发送给B的帧，就应当从接口3转发出去。 经过一段时间后，只要主机 C 和 D 也向其他主机发送帧，以太网交换机中的交换表就 会把转发到C或D应当经过的接口号（24）写入到交换表中。这样，交换表中的项目就 齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口。 考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需 要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就 自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。 以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配 置，因此非常方便。 但有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的 链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈 子。我们用图 3-26 的简单例子来说明这个问题。</p> <p><img src="" alt=""/> <em>图 3-26 在两个交换机之间兜圈子的帧</em></p> <p>在图 3-26 中，假定一开始主机A通过接口交换机#1 向主机B发送一帧。交换机#1 收 到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向：离开交换机#1 的 接口 3→ 交换机#2的接口→ 接口2→ 交换机#1 的接口4→ 接口3→ 交换机#2的接口 1 这样就无限制地循环圈子下去，白白消耗了网络资源。 为了解决这种兜圈子问题，IEEE 802。1D 标准制定了一个生成树协议 STP （Spanning Tree Protocol）。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一 台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。 3。从总线以太网到星形以太网 大家知道，传统的电话网是星形结构，其中心就是电话交换机。那么在20世纪70 年 代中期出现的局域网，为什么不采用这种星形结构呢?这是因为在当时的技术条件下，还很 难用廉价的方法制造出高可靠性的以太网交换机。所以那时的以太网就采用无源的总线结 构。这种总线式以太网一问世就受到广大用户的欢迎，并获得了很快的发展。 然而随着以太网上站点数目的增多，使得总线结构以太网的可靠性下降。与此同时， 大规模集成电路以及专用芯片的发展，使得星形结构的以太网交换机可以做得既便宜又可 靠。在这种情况下，采用以太网交换机的星形结构又成为以太网的首选拓扑，而传统的总线 以太网也很快从市场上消失了。 总线以太网使用 CSMA/CD 协议，以半双工方式工作。但以太网交换机不使用共享总 线，没有碰撞问题，因此不使用CSMA/CD 协议，而是以全双工方式工作。既然连以太网的 重要协议 CSMA/CD 都不使用了（相关的“争用期”也没有了），为什么还叫做以太网呢? 原因就是它的帧结构未改变，仍然采用以太网的帧结构。</p> <h3 id="43-虚拟局域网">4.3 虚拟局域网</h3> <p>利用以太网交换机可以很方便地实现虚拟局域网VLAN （Virtual LAN）。在IEEE 802。1Q 标准中，对虚拟局域网 VLAN 是这样定义的： 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段 具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算 机属于哪一个 VLAN。 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。 图 3-27 画的是使用了四个交换机的网络拓扑。设有10台计算机分配在三个楼层中，构 成了三个局域网，即： LANı： （A1， A2， B1， Cı），LAN2： （A3， B2， Cz），LAN3： （A4，B3， C3） 但这 10 个用户划分为三个工作组，也就是说划分为三个虚拟局域网 VLAN。即： VLANı： （A1，A2，A3， A4）， VLAN2： （B1， B2， B3）; VLAN3： （C1，C2，C3）。</p> <p>图 3-27 三个虚拟局域网 VLAN、VLAN 和 VLAN 的构成</p> <p>从图 3-27 可看出，每一个VLAN 的计算机可处在不同的局域网中，也可以不在同一层 利用以太网交换机可以很方便地将这10台计算机划分为三个虚拟局域网：VLAN， VLAN， 和VLAN，。在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他成员 所发出的广播。例如，计算机 B1~B，同属于虚拟局域网 VLANz。当B，向工作组内成员发 送数据时，计算机B2和B;将会收到广播的信息，虽然它们没有和B，连在同一个以太网交 换机上。相反，B，向工作组内成员发送数据时，计算机A1，A2和C都不会收到B，发出的 广播信息，虽然他们都与B连接在同一个以太网交换机上。以太网交换机不向虚拟局域网 以外的计算机传送B的广播信息。这样，虚拟局域网限制了接收广播信息的计算机数，使 得网络不会因传播过多的广播信息（即所谓的“广播风暴”而引起性能恶化。 由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非 常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。 以太网交换机的种类很多。例如，“具有第三层特性的第二层交换机”和“多层交换 机”。前者具有某些第三层的功能，如数据报的分片和对多播通信量的管理，而后者可根据 第三层的IP 地址对分组进行过滤。 1988 年 IEEE 批准了 802。3ac标准，这个标准定义了以太网的帧格式的扩展，以便支 持虚拟局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符（见 图 3-28），称为 VLAN 标记（tag），用来指明发送该帧的计算机属于哪一个虚拟局域网。插入 VLAN 标记得出的帧称为 802。1Q 帧。显然，如果还使用原来的以太网帧格式，那么就无法 区分是否划分了虚拟局域网。图3-27 标注出在几个粗线链路上传输的帧是 802。1Q 帧。在其 他链路上传输的仍然是普通的以太网帧。 802。1Q帧 字节 6 以太网 6 4 2 46-1500 4 MAC帧目的地址 源地址 VLAN标记 类型 数据 FCS 802。1Q 标记类型 标记控制信息 10000001 00000000 VID 2 字节 2 字节 用户优先级 CFI 图 3-28 插入 VLAN 标记后变成了 802。1Q 帧 VLAN 标记字段的长度是4字节，插入在以太网 MAC 帧的源地址字段和类型字段之 间。VLAN 标记的前两个字节总是设置为0x8100（即二进制的 10000001 00000000），称为 IEEE 802。1Q 标记类型。 当数据链路层检测到 MAC 帧的源地址字段后面的两个字节的值是0x8100时，就知道 现在插入了 4 字节的 VLAN 标记。于是就接着检查后面两个字节的内容。在后面的两个字 节中，前 3 位是用户优先级字段，接着的一位是规范格式指示符 CFI （Canonical Format Indicator），最后的12位是该虚拟局域网 VLAN 标识符 VID （VLAN ID），它唯一地标志了 这个以太网帧属于哪一个 VLAN。 由于用于 VLAN 的以太网帧的首部增加了4个字节，因此以太网的最大帧长从原来的 1518 字节（1500字节的数据加上18字节的首部）变为1522 字节。</p> <h2 id="五高速以太网">五、高速以太网</h2> <p>下面简单介绍几种高速以太网技术。</p> <h3 id="51-100base-t-以太网">5.1 100BASE-T 以太网</h3> <p>100BASE-T 是在双绞线上传送 100 Mbit/s 基带信号的星形拓扑以太网，仍使用 IEEE 802。3 的 CSMA/CD 协议，它又称为快速以太网（Fast Ethernet）。用户只要使用 100 Mbit 的适 配器和 100 Mbit/s 的集线器或交换机，就可很方便地由 10BASE-T 以太网直接升级到 100 Mbit/s，而不必改变网络的拓扑结构。所有在 10BASE-T 上的应用软件和网络软件都可保持 不变。100BASE-T 的适配器有很强的自适应性，能够自动识别 10 Mbit/s 和 100 Mbit/s。 1995 年 IEEE已把100BASE-T的快速以太网定为正式标准，其代号为IEEE 802。3u，是对现 行的 IEEE 802。3 标准的补充。 100BASE-T 可使用以太网交换机提供很好的服务质量，可在全双工方式下工作而无冲 突发生。因此，CSMA/CD 协议对全双工方式工作的快速以太网是不起作用的（但在半双工 方式工作时则一定要使用 CSMA/CD 协议）。快速以太网使用的 MAC 帧格式仍然是IEEE 802。3 标准规定的帧格式。 然而 IEEE 802。3u 的标准未包括对同轴电缆的支持。这意味着想从细缆以太网升级到快速 以太网的用户必须重新布线。因此，现在 10/100 Mbit/s 以太网都使用无屏蔽双绞线布线。 100 Mbit/s 以太网的新标准改动了原 10 Mbit/s 以太网的某些规定。我们知道，以太网有 一个重要的参数 a，它必须保持为很小的数值。在3。3。4 节曾给出了参数a的公式（3-2）： τ a = T。 （3-2） 这里要是以太网单程端到端时延，是帧的发送时间。我们知道，To是帧长与发送速率 之比，可见为了保持参数a不变，可以使与发送速率的乘积不变。在帧长一定的条件下， 若数据率提高到10倍，可把网络电缆长度（因而使z）减小到原有数值的十分之一。 在 100 Mbit/s 的以太网中采用的方法是保持最短帧长不变，对于铜缆 100 Mbit/s 以太 网，一个网段的最大长度是100m，其最短帧长仍为64字节，即 512 比特。因此 100 Mbit/s 以太网的争用期是5。12 us，帧间最小间隔现在是0。96 us，都是10Mbit/s 以太网的1/10。 表 3-1 是 100 Mbit/s 以太网的新标准规定的三种不同的物理层标准。 表 3-1 100 Mbit/s 以太网的物理层标准 名称 媒体 网段最大长度 特点 100BASE-TX 铜缆 100m 两对UTP5类线或屏蔽双绞线 STP 100BASE-T4 铜缆 100m 4 对UTP 3类线或5类线 100BASE-FX 光缆 2000m 两根光纤，发送和接收各用一根 在标准中把上述的100BASE-TX 和 100BASE-FX 合在一起称为100BASE-X。 100BASE-T4 使用4对UTP3类线或5类线时，使用3对线同时传送数据（每一对线以 33号 Mbit/s 的速率传送数据），用1对线作为碰撞检测的接收信道。</p> <h3 id="52-吉比特以太网">5.2 吉比特以太网</h3> <p>吉比特以太网的产品已在1996年夏季间市。IEEE 在1997年通过了吉比特以太网的标 准 802。3z，并在1998年成为正式标准。几年来，吉比特以太网迅速占领了市场，成为以太 网的主流产品。 吉比特以太网的标准 IEEE 802。3z 有以下几个特点： （1） 允许在 1 Gbit/s 下以全双工和半双工两种方式工作。 （2） 使用 IEEE 802。3协议规定的帧格式。 （3）在半双工方式下使用CSMA/CD 协议，而在全双工方式不使用CSMA/CD 协议。 （4）与10BASE-T 和 100BASE-T 技术向后兼容。 吉比特以太网可用作现有网络的主干网，也可在高带宽（高速率）的应用场合中（如 医疗图像或CAD的图形等）用来连接计算机和服务器。 吉比特以太网的物理层使用两种成熟的技术：一种来自现有的以太网，另一种则是美 国国家标准协会ANSI 制定的光纤通道FC（Fibre Channel）。采用成熟技术就能大大缩短吉比 特以太网标准的开发时间。 表3-2 是吉比特以太网的物理层的标准。 表3-2 吉比特以太网物理层标准 名称 媒体 网段最大长度 特点 1000BASE-SX 光缆 550 m 多模光纤（50和62。5m） 1000BASE-LX 光缆 5000m 单模光纤（10um）多模光纤（50和62。5 um） 1000BASE-CX 铜缆 25 m 使用2对屏蔽双绞线电缆 STP 1000BASE-T 铜缆 100m 使用4对UTP5类线 现在 1000BASE-X（包括表3-2 中的前三项）的标准是IEEE 802。3z，而 1000BASE-T 的标准是IEEE 802。3ab。 吉比特以太网工作在半双工方式时，就必须进行碰撞检测。由于数据率提高了，因此 只有减小最大电缆长度或增大帧的最小长度，才能使参数a保持为较小的数值。若将吉比特 以太网最大电缆长度减小到10m，那么网络的实际价值就大大减小。而若将最短帧长提高 到640 字节，则在发送短数据时开销又嫌太大。因此，吉比特以太网仍然保持一个网段的最 大长度为100m，但采用了“载波延伸”（carrier extension）的办法，使最短帧长仍为64字节 （这样可以保持兼容性），同时将争用期增大为512字节。凡发送的 MAC 帧长不足 512 字 节时，就用一些特殊字符填充在帧的后面，使MAC 帧的发送长度增大到512字节，这对有 效载荷 并无影响。接收端在收到以太网的 MAC 帧后，要把所填充的特殊字符删除后才向 高层交付。当原来仅64字节长的短帧填充到512字节时，所填充的448字节就造成了很大 的开销。 为此，吉比特以太网还增加了一种功能称为分组突发（packet bursting）。这就是当很多短 帧要发送时，第一个短帧要采用上面所说的载波延伸的方法进行填充。但随后的一些短帧则 可一个接一个地发送，它们之间只需留有必要的帧间最小间隔即可。这样就形成一串分组的 突发，直到达到1500字节或稍多一些为止。当吉比特以太网工作在全双工方式时（即通信 双方可同时进行发送和接收数据），不使用载波延伸和分组突发。 吉比特以太网交换机可以直接与多个图形工作站相连。也可用作百兆以太网的主干网， 与百兆比特或吉比特交换机相连，然后再和大型服务器连接在一起。图3-29 是吉比特以太 网的一种配置举例。</p> <p><img src="" alt=""/> <em>图 3-29 吉比特以太网的配置举例</em></p> <h3 id="53-10-吉比特以太网10ge和更快的以太网">5.3 10 吉比特以太网（10GE）和更快的以太网</h3> <p>10GE 并非把吉比特以太网的速率简单地提高到10倍，因为还有许多技术上的问题要 解决。顺便指出，10吉比特就是10×10°比特，有人愿意称之为“万兆比特”。虽然“万” 是中国的一种常用的计量单位，但这与国际上通用的表示方法不一致，因此本书不予采用。 10GE 的帧格式与10Mbit/s，100 Mbit/s 和1Gbit/s 以太网的帧格式完全相同，并保留 了 802。3 标准规定的以太网最小帧长和最大帧长。这就使用户在将其已有的以太网进行升级 时，仍能和较低速率的以太网很方便地通信。 10GE 只工作在全双工方式，因此不存在争用问题，当然也不使用 CSMA/CD 协议。这 就使得 10GE 的传输距离大大提高了（因为不再受必须进行碰撞检测的限制）。 表3-3是10GE 的物理层标准。 表 3-3 10GE 的物理层标准 名称 媒体 网段最大长度 特点 10GBASE-SR 光缆 300m 多模光纤（0。85 um） 10GBASE-LR 光缆 10 km 单模光纤（1。3um） 10GBASE-ER 光缆 40 km 单模光纤（1。5um） 10GBASE-CX4 铜缆 15 m 10GBASE-T 铜缆 100m 使用 4 对双芯同轴电缆（twinax） 使用 46A 类 UTP 双绞线 表 3-3 中的前三项的标准是IEEE 802。3ae，在2002年6月完成。第四项的标准是 IEEE 802。3ak，完成于2004年。最后一项的标准是IEEE 802。3an，完成于2006年。 以太网的技术发展得很快。在10GE 之后又制定了 40GE/100GE（即40吉比特以太网 和 100 吉比特以太网）的标准 IEEE 802。3ba-2010 和 802。3bm-2015。表3-4是40GE 和 100GE 的物理层名称及传输距离，其中有两项带*号的是802。3bm 提出的。 需要指出的是，40GE/100GE 只工作在全双工的传输方式（因而不使用CSMA/CD 协 议），并且仍然保持了以太网的帧格式以及 802。3 标准规定的以太网最小和最大帧长。 100GE 在使用单模光纤传输时，仍然可以达到 40 km 的传输距离，但这需要波分复用（使 用4个波长复用一根光纤，每一个波长的有效传输速率是25Gbit/s）。</p> <p>物理层 表 3-4 40GB/100GB 以太网的物理层标准 40GB 以太网 100GB 以太网 在背板上传输至少超过1m 在铜缆上传输至少超过7m 在多模光纤上传输至少100m 在单模光纤上传输至少10km 在单模光纤上传输至少40km 40GBASE-KR4 40GBASE-CR4 40GBASE-SR4 40GBASE-LR4 *40GBASE-ER4 100GBASE-CR10 100GBASE-SR10， *100GBASE-SR4 100GBASE-LR4 100GBASE-ER4 现在以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从 而实现了端到端的以太网传输。这种工作方式的好处是： （1） 以太网是一种经过实践证明的成熟技术，无论是互联网服务提供者ISP还是端用户 都很愿意使用以太网。当然对ISP来说，使用以太网还需要在更大的范围进行试验。 （2） 以太网的互操作性也很好，不同厂商生产的以太网都能可靠地进行互操作。 （3） 在广域网中使用以太网时，其价格大约只有同步光纤网 SONET 的五分之一和异步 传递方式 ATM 的十分之一。以太网还能够适应多种传输媒体，如铜缆、双绞线以及各种光 缆。这就使具有不同传输媒体的用户在进行通信时不必重新布线。 （4） 端到端的以太网连接使帧的格式全都是以太网的格式，而不需要再进行帧的格式转 换，这就简化了操作和管理。但是，以太网和现有的其他网络，如帧中继或 ATM 网络，仍 然需要有相应的接口才能进行互连。 以太网从 10 Mbit/s 到 10 Gbit/s 甚至到100 Gbit/s 的演进，证明了以太网是： （1） 可扩展的速率从10Mbit/s 到 100 Gbit/s）。 （2） 灵活的（多种媒体、全/半双工、共享、交换）。 （3） 易于安装。 （4） 稳健性好。</p> <h3 id="54-使用以太网进行宽带接入">5.4 使用以太网进行宽带接入</h3> <p>现在人们也在使用以太网进行宽带接入互联网。为此，IEEE 在2001 年初成立了 802。3EFM 工作组，专门研究高速以太网的宽带接入技术问题。 以太网接入的一个重要特点是它可以提供双向的宽带通信，并且可以根据用户对带宽 的需求灵活地进行带宽升级（例如，把10兆的以太网交换机更新为吉比特的以太网交换 机）。当城域网和广域网都采用吉比特以太网或10 吉比特以太网时，采用以太网接入可以实 现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率且降 低了传输的成本。 然而以太网的帧格式标准中，在地址字段部分并没有用户名字段，也没有让用户键入 密码来鉴别用户身份的过程。如果网络运营商要利用以太网接入到互联网，就必须解决这个 问题。</p>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https://feng-zhang0712.github.io//blog/2024/2024-09-13-network-layer/" rel="alternate" type="text/html" title=""/><published>2024-09-21T08:55:57+00:00</published><updated>2024-09-21T08:55:57+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/2024-09-13-network-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/2024-09-13-network-layer/"><![CDATA[<p>本章的核心内容——网际协议 IP 是本书的一个重点内容。本章还要讨论网际控制报文协议 ICMP，几种常用的路由选择协议，IPv6 的主要特点，IP 多播的概念。本章最重要的内容是：</p> <ul> <li>虚拟互连网络的概念。</li> <li>IP 地址与物理地址的关系。</li> <li>传统的分类的 IP 地址（包括子网掩码）和无分类域间路由选择 CIDR。</li> <li>路由选择协议的工作原理。</li> </ul> <h2 id="一网络层提供的两种服务">一、网络层提供的两种服务</h2> <p>计算机网络发展的早期，人们曾认为，计算机网络应模仿打电话所使用的面向连接的通信方式。当两台计算机进行通信时，应当先建立连接（但在分组交换中是建立一条<strong>虚电路</strong> VC（Virtual Circuit）），以预留双方通信所需的一切网络资源。然后双方就沿着已建立的虚电路发送分组。图 4-1（a）是网络提供虚电路服务的示意图。主机 $H_1$ 和 $H_2$ 之间交换的分组都必须在事先建立的虚电路上传送。</p> <p>但互联网的先驱者却提出一种崭新的网络设计思路。他们认为，电信网提供的端到端可靠传输的服务对电话业务无疑是很合适的，因为电信网的终端（电话机）非常简单，没有智能，也没有差错处理能力。因此电信网必须负责把用户电话机产生的话音信号可靠地传送到对方的电话机，使还原后的话音质量符合技术规范的要求。但计算机网络的端系统是有智能的计算机。计算机有很强的差错处理能力（这点和传统的电话机有本质上的差别）。因此，互联网在设计上就采用了和电信网完全不同的思路。</p> <p>互联网采用的设计思路是这样的：<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong>。这里的“数据报”（datagram）指我们经常使用的“分组”。</p> <p>网络在发送分组时不需要先建立连接。每个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。<strong>网络层不提供服务质量的承诺</strong>。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器比较简单，且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。</p> <p>图 4-1（b）给出了网络提供数据报服务的示意图。主机 $H_1$ 向 $H_2$ 发送的分组各自独立地选择路由，并且在传送的过程中还可能丢失。</p> <p><img src="/assets/images/computer-networks/two-types-of-services-provided-by-the-network-layer.png" alt="网络层提供的两种服务"/> <em>图 4-1 网络层提供的两种服务</em></p> <p>| 对比的方面 | 虚电路服务 | 数据报服务 | | — | — | — | | 思路 | 可靠通信应当由网络来保证 | 可靠通信应当由用户主机来保证 | | 连接的建立 | 必须有 | 不需要 | | 终点地址 | 仅在连接建立阶段使用，每个分组使用短的虚电路号 | 每个分组都有终点的完整地址 | | 分组的转发 | 属于同一条虚电路的分组均按照同一路由进行转发 | 每个分组独立选择路由进行转发 | | 当结点出故障时 | 所有通过出故障的结点的虚电路均不能工作 | 出故障的结点可能会丢失分组，一些路由可能会发生变化 | | 分组的顺序 | 总是按发送顺序到达终点 | 到达终点的时间不一定按发送顺序 | | 端到端的差错处理和流量控制 | 可以由网络负责，也可以由用户主机负责 | 由用户主机负责 | <em>表 4-1 虚电路服务与数据报服务的对比</em></p> <h2 id="二网际协议-ip">二、网际协议 IP</h2> <p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一[STEV94][COME06][FORO10]，也是最重要的互联网标准协议之一（注意，这里所讲的 IP 是 IP 的第 4 个版本（IPv4）。但在讲述 IP 协议的各种原理时，往往不在 IP 后面加上版本号。在后面的 <a href="#六ipv6">第六节</a> 会介绍较新的版本 IPv6）。</p> <p>与 IP 协议配套使用的还有三个协议：</p> <ul> <li><strong>地址解析协议 ARP</strong>（Address Resolution Protocol）</li> <li><strong>网际控制报文协议 ICMP</strong>（Internet Control Message Protocol）</li> <li><strong>网际组管理协议 IGMP</strong>（Internet Group Management Protocol）</li> </ul> <p>图 4-2 画出了这三个协议和网际协议 IP 的关系。在这一层中，ARP 画在最下面，因为 IP 经常要使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层常常被称为<strong>网际层</strong>（internet layer），或 <strong>IP 层</strong>。</p> <p><img src="/assets/images/computer-networks/internet-protocol-ip-and-its-supporting-protocols.png" alt="网际协议 IP 及其配套协议"/> <em>图 4-2 网际协议 IP及其配套协议</em></p> <h3 id="21-虚拟互连网络">2.1 虚拟互连网络</h3> <p>将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p> <ul> <li>物理层使用的中间设备叫做<strong>转发器</strong>（repeater）。</li> <li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>（bridge）。</li> <li>网络层使用的中间设备叫做<strong>路由器</strong>（router）。</li> <li>在网络层以上使用的中间设备叫做<strong>网关</strong>（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li> </ul> <p>当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称之为网络互连。网关由于比较复杂，目前使用得较少。因此现在我们讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。注意，由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关（本书有时也这样用）。</p> <p>图 4-3（a）表示有许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的<strong>网际协议 IP</strong>（Internet Protocol），因此可以把互连以后的计算机网络看成如图 4-3（b）所示的一个<strong>虚拟互连网络</strong>（internet）。所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。这种使用 IP协 议的虚拟互连网络可简称为 IP 网。使用 IP 网的好处是：当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节（如具体的编址方案、路由选择协议，等等）。如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网（Internet）。</p> <p><img src="/assets/images/computer-networks/the-concept-of-ip-network.png" alt="IP 网的概念"/> <em>图 4-3 IP 网的概念</em></p> <p>在图 4-4 所示的互联网中的源主机 $H_1$ 要把一个 IP 数据报发送给目的主机 $H_2$。根据之前讲过的分组交换的存储转发概念，主机 $H_1$ 先要查找自己的路由表，看目的主机是否就在本网络上。如是，则不需要经过任何路由器而是<strong>直接交付</strong>，任务就完成了。如不是，则必须把 IP 数据报发送给某个路由器（图中的 $R_1$）。$R_1$ 在查找了自己的路由表后，知道应当把数据报转发给 $R_2$ 进行<strong>间接交付</strong>。这样一直转发下去，最后由路由器 $R_5$ 知道自己是和 $H_2$ 连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报直接交付目的主机 $H_2$。图中画出了源主机、目的主机以及各路由器的协议栈。我们注意到，主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向（用黑色粗线表示）。我们还可注意到，在 $R_4$ 和 $R_5$ 之间使用了卫星链路，而 $R_5$ 所连接的是个无线局域网。在 $R_1$ 到 $R_4$ 之间的三个网络则可以是任意类型的网络。总之，这里强调的是：<strong>互联网可以由多种异构网络互连组成</strong>。</p> <p>如果我们只从网络层考虑问题，那么IP 数据报就可以想象是在网络层中传送，其传送路径是：</p> \[H_1 → R_1 → R_2 → R_3 → R_4 → R_5 → H_2\] <p><img src="/assets/images/computer-networks/transmission-of-packets-over-the-internet.png" alt="分组在互联网中的传送"/> <em>图 4-4 分组在互联网中的传送</em></p> <h3 id="22-分类的-ip-地址">2.2 分类的 IP 地址</h3> <p>在 TCP/IP 体系中，IP 地址是一个最基本的概念。有关 IP 最重要的文档就是互联网的正式标准 RFC 791。</p> <h4 id="1ip-地址及其表示方法">（1）IP 地址及其表示方法</h4> <p>整个的互联网就是一个<strong>单一的、抽象的网络</strong>。IP 地址就是给互联网上的每台主机（或路由器）的每个接口分配一个在全世界范围内是唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上很方便地进行寻址。IP 地址现在由<strong>互联网名字和数字分配机构 ICANN</strong>（Internet Corporation for Assigned Names and Numbers）进行分配。</p> <p>IP 地址的编址方法共经过了三个历史阶段。</p> <ol> <li><strong>分类的 IP 地址</strong>：这是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li> <li><strong>子网的划分</strong>：这是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</li> <li><strong>构成超网</strong>：这是比较新的无分类编址方法。1993 年提出后很快就得到推广应用。</li> </ol> <p>所谓“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每类地址都由两个固定长度的字段组成。</p> <ol> <li><strong>网络号</strong>（net-id）：第一个字段。它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。</li> <li><strong>主机号</strong>（host-id）：第二个字段。它标志该主机（或路由器）。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li> </ol> <p>由此可见，一个 IP 地址<strong>在整个互联网范围内是唯一的</strong>。这种两级的 IP 地址可以记为：</p> \[IP 地址 ::= {&lt;网络号&gt;, &lt;主机号&gt;}\] <p>上式中的符号“::=”表示“<strong>定义为</strong>”。图 4-5 给出了各种 IP 地址的网络号字段和主机号字段，这里 A 类、B 类和 C 类地址都是单播地址（一对一通信），是最常用的。</p> <p><img src="/assets/images/computer-networks/the-network-number-field-and-host-number-field-in-the-ip-address.png" alt="IP 地址中的网络号字段和主机号字段"/> <em>图 4-5 IP 地址中的网络号字段和主机号字段</em></p> <p>从图 4-5 可以看出：</p> <ul> <li>A 类、B 类和 C 类地址的网络号字段（在图中这个字段是灰色的）分别为 1 个、2 个和 3 个字节长，而在网络号字段的最前面有 1~3 位的<strong>类别位</strong>，其数值分别规定为 0、10 和 110。</li> <li>A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。</li> <li>D 类地址（前 4 位是 1110）用于多播（一对多通信）。</li> <li>E 类地址（前 4 位是 1111）保留为以后用。</li> </ul> <p>这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、B 类和 C 类地址的区分已成为历史[RFC1812]，但由于很多文献和资料都还使用传统的分类的 IP 地址，而且从概念的演进上更清晰，因此我们在这里还要从分类的 IP 地址讲起。</p> <p>从 IP 地址的结构来看，IP 地址并不仅仅指明一台主机，而是还指明了主机连接到的网络。</p> <p>把 IP 地址划分为 A 类、B 类、C 类三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把 IP 地址划分为 A 类、B 类和 C 类是为了更好地满足不同用户的要求。当某个单位申请到一个 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。</p> <p>对主机或路由器来说，IP 地址都是 32 位的二进制代码。为了提高可读性，我们常把 32 位的 IP 地址中的每 8 位插入一个空格（但在机器中并没有这样的空格）。为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做<strong>点分十进制记法</strong>（dotted decimal notation）。图 4-6 是一个 B 类 IP 地址的表示方法。显然，128.11.3.31 比 10000000 00001011 00000011 00011111 书写起来要方便得多。</p> <p><img src="/assets/images/computer-networks/the-use-of-dotted-decimal-notation-improves-readability.png" alt="采用点分十进制记法能够提高可读性"/> <em>图 4-6 采用点分十进制记法能够提高可读性</em></p> <h4 id="2常用的三种类别的-ip-地址">（2）常用的三种类别的 IP 地址</h4> <p>A 类地址的网络号字段占 1 个字节，只有 7 位可供使用（该字段的第一位已固定为 0），但可指派的网络号是 126 个（即 $2^{-7} - 2$）。减 2 的原因是：第一，IP 地址中的全 0 表示“这个（this）”。网络号字段为全 0 的 IP 地址是个保留地址，意思是“<strong>本网络</strong>”；第二，网络号为 127（即 01111111）保留作为本地软件<strong>环回测试</strong>（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。</p> <p>A 类地址的主机号占 3 个字节，因此每个 A 类网络中的最大主机数是 $2^{24} - 2$，即 16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>单个网络地址</strong>（例如，一主机的 IP 地址为5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示“所有的（all）”，因此全 1 的主机号字段表示该网络上的所有主机。</p> <p>IP 地址空间共有 $2^{32}$（即 4294967296）个地址。整个 A 类地址空间共有 21 个地址，占整个 IP 地址空间的 50%。</p> <p>B 类地址的网络号字段有 2 个字节，但前面两位（10）已经固定了，只剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此这里不存在网络总数减 2 的问题。但实际上 B 类网络地址128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0 [COME06]。因此 B 类地址可指派的网络数为 $2^{14} - 1$，即 16383。B 类地址的每个网络上的最大主机数是 $2^{16} - 2$，即 65534。这里需要减 2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 $2^{30}$ 个地址，占整个 IP 地址空间的 25%。</p> <p>C 类地址有 3 个字节的网络号字段，最前面的 3 位是（110），还有 21 位可以进行分配。C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络地址是 192.0.1.0 [COME06]，因此 C 类地址可指派的网络总数是 $2^{21} - 1$，即 2097151。每个 C 类地址的最大主机数是 $2^8 - 2$，即 254。整个 C 类地址空间共约有 $2^{29}$ 个地址，占整个 IP 地址的 12.5%。</p> <p>这样，我们就可得出表 4-2 所示的 IP 地址的指派范围。</p> <p>| 网络类别 | 最大可指派的网络数 | 第一个可指派的网络号 | 最后一个可指派的网络号 | 每个网络中的最大主机数 | | — | — | — | — | — | | A | $126(2^7 - 2)$ | 1 | 126 | 16777214 | | B | $16383(2^{14} - 1)$ | 128.1 | 191.255 | 65534 | | C | $2097151(2^{21} - 1)$ | 192.0.1 | 223.255.255 | 254 | <em>表 4-2 IP 地址的指派范围</em></p> <p>表 4-3 给出了一般不使用的特殊 IP 地址，这些地址只能在特定的情况下使用。</p> <p>| 网络号 | 主机号 | 源地址使用 | 目的地址使用 | 代表的意思 | | — | — | — | — | — | | 0 | 0 | 可以 | 不可 | 在本网络上的本主机（见6。6节 DHCP 协议） | | 0 | host-id | 可以 | 不可 | 在本网络上的某台主机 host-id | | 全 1 | 全 1 | 不可 | 可以 | 只在本网络上进行广播（各路由器均不转发） | | net-id | 全 1 | 不可 | 可以 | 对 net-id 上的所有主机进行广播 | | 127 | 非全 0 或全 1 的任何数 | 可以 | 可以 | 用于本地软件环回测试 | <em>表 4-3 一般不使用的特殊 IP 地址</em></p> <p>IP 地址具有以下一些重要特点。</p> <ol> <li>每个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种<strong>分等级的地址结构</strong>。分两个等级的好处是： <ul> <li>第一，IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong>（第一级），而剩下的主机号（第二级）则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理；</li> <li>第二，路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong>（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而<strong>减小了路由表所占的存储空间以及查找路由表的时间</strong>。</li> </ul> </li> <li>实际上 IP 地址是标志一台主机（或路由器）和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>（multihomed host）。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。这好比一个建筑正好处在北京路和上海路的交叉口上，那么这个建筑就可以拥有两个门牌号码。例如，北京路 4 号和上海路 37 号。</li> <li>按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，<strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li> <li>在 IP 地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是<strong>平等</strong>的。所谓平等，是指互联网同等对待每个 IP 地址。图 4-7 画出了三个局域网（$LAN_1$，$LAN_2$ 和 $LAN_3$）通过三个路由器（$R_1$，$R_2$ 和 $R_3$）互连起来所构成的一个互联网（此互联网用虚线圆角方框表示）。其中局域网 $LAN_2$， 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有一个 IP 地址。</li> </ol> <p>我们应当注意到：</p> <ul> <li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。图中所示的网络号就是 IP 地址中的网络号字段的值，这也是文献中常见的一种表示方法。另一种表示方法是用主机号为全 0 的网络 IP 地址。</li> <li>用网桥（它只在链路层工作）互连的网段仍然是一个局域网，只能有一个网络号。</li> <li>路由器总是具有两个或两个以上的 IP 地址。即路由器的每个接口都有一个不同网络号的 IP 地址。</li> <li>当两个路由器直接相连时（例如通过一条租用线路），在连线两端的接口处，可以分配也可以不分配 IP 地址。如分配了 IP 地址，则这段连线就构成了一种只包含一段线路的特殊“网络”（如图中的 $N_1$，$N_2$ 和 $N_3$）。之所以叫做“网络”是因为它有 IP 地址。但为了节省 IP 地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配 IP 地址。通常把这样的特殊网络叫做<strong>无编号网络</strong>（unnumbered network）或<strong>无名网络</strong>（anonymous network）[COME06]。</li> </ul> <p><img src="/assets/images/computer-networks/an-ip-address-on-the-internet.png" alt="互联网中的 IP 地址"/> <em>图 4-7 互联网中的 IP 地址</em></p> <h3 id="23-ip-地址与硬件地址">2.3 IP 地址与硬件地址</h3> <p>图 4-8 说明了 IP 地址与硬件地址的区别。从层次的角度看，<strong>物理地址是数据链路层和物理层使用的地址</strong>，而 <strong>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</strong>。</p> <p><img src="/assets/images/computer-networks/differences-between-ip-addresses-and-hardware-addresses.png" alt="IP 地址与硬件地址的区别"/> <em>图 4-8 IP 地址与硬件地址的区别</em></p> <p>在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在MAC 帧的首部中。</p> <p>连接在通信链路上的设备（主机或路由器）在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。</p> <p>总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。</p> <p>图 4-9（a）画的是三个局域网用两个路由器 $R_1$ 和 $R_2$ 互连起来。现在主机 $H_1$ 要和主机 $H_2$ 通信。这两台主机的 IP 地址分别是 $IP_1$ 和 $IP_2$，而它们的硬件地址分别为 $HA_1$ 和 $HA2_1$（HA 表示 Hardware Address）。通信的路径是：$H_1$ → 经过 $R_1$ 转发 → 再经过 $R_2$ 转发 → $H_2$。路由器 $R_1$ 因同时连接到两个局域网上，因此它有两个硬件地址，即 $HA_3$ 和 $HA_4$。同理，路由器 $R_2$ 也有两个硬件地址 $HA_5$ 和 $HA_6$。</p> <p><img src="/assets/images/computer-networks/ip-addresses-and-hardware-addresses-at-different-levels.png" alt="从不同层次上看 IP 地址和硬件地址"/> <em>图 4-9 从不同层次上看 IP 地址和硬件地址</em></p> <p>图4-9（b）特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。</p> <p><img src="/assets/images/computer-networks/source-and-destination-addresses-of-different-levels-and-ranges.png" alt="图 4-9（b）中不同层次、不同区间的源地址和目的地址"/> <em>表 4-4 图 4-9（b）中不同层次、不同区间的源地址和目的地址</em></p> <p>这里要强调指出以下几点：</p> <ul> <li><strong>在 IP 层抽象的互联网上只能看到 IP 数据报</strong>。虽然 IP 数据报要经过路由器 $R_1$ 和 $R_2$ 的两次转发，但在它的首部中的源地址和目的地址始终分别是 $IP_1$ 和 $IP_2$。图中的数据报上写的“从 $IP_1$ 到 $IP_2$”就表示前者是源地址而后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li> <li>虽然在 IP 数据报首部有源站 IP 地址，但<strong>路由器只根据目的站的 IP 地址的网络号进行路由选择</strong>。</li> <li><strong>在局域网的链路层，只能看见 MAC 帧</strong>。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图 4-9（b）。开始在 $H_1$ 到 $R_1$ 间传送时，MAC 帧首部中写的是从硬件地址 $HA_1$，发送到硬件地址 $HA_3$，路由器 $R_1$ 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新添加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 $HA_4$ 和 $HA_5$。路由器 $R_2$ 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变成为 $HA_6$ 和 $HA_2$。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。</li> <li>尽管互连在一起的网络的硬件地址体系各不相同，但<strong>IP 层抽象的互联网却屏蔽了下层这些很复杂的细节</strong>。<strong>只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信</strong>。上述的这种“屏蔽”概念是一个很有用，很普遍的基本概念。例如，计算机中广泛使用的图形用户界面使得用户只需简单地点击几下鼠标就能让计算机完成很多任务。实际上计算机要完成这些任务必须执行很多条指令。但这些复杂的过程全都被设计良好的图形用户界面屏蔽掉了，使用户看不见这些复杂过程。</li> </ul> <p>以上这些概念是计算机网络的精髓所在，对这些重要概念务必仔细思考和掌握。到目前为止，还有两个重要问题没有解决：</p> <ol> <li>主机或路由器怎样知道应当在 MAC 帧的首部填入什么样的硬件地址？</li> <li>路由器中的路由表是怎样得出的？</li> </ol> <p>第一个问题就是下一节所要讲的内容，而第二个问题将在后面的 <a href="#五互联网的路由选择协议">第五节</a> 节详细讨论。</p> <h3 id="24-地址解析协议-arp">2.4 地址解析协议 ARP</h3> <p>在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址。地址解析协议 ARP 就是用来解决这样的问题的。图 4-10 说明了 ARP 协议的作用。</p> <p><img src="/assets/images/computer-networks/function-of-arp-protocol.png" alt="ARP 协议的作用"/> <em>图 4-10 ARP 协议的作用</em></p> <p>由于是 IP 协议使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。ARP 协议的用途是为了从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。注意，还有一个旧的协议叫做逆地址解析协议 RARP，它的作用是使只知道自己硬件地址的主机能够通过 RARP 协议找出其 IP 地址。现在的 DHCP 协议已经包含了 RARP 协议的功能。因此本书不再介绍 RARP 协议。</p> <p>我们知道，网络层使用的是 IP 地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但 IP 地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系（例如，IP 地址有 32 位，而局域网的硬件地址是 48 位）。此外，在一个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变。<strong>地址解析协议 ARP</strong> 解决这个问题的方法是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。</p> <p>每台主机都设有一个 <strong>ARP 高速缓存</strong>（ARP cache），里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p> <p>当主机 A 要向<strong>本局域网</strong>上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。也有可能查不到主机 B 的 IP 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 ARP，然后按以下步骤找出主机 B 的硬件地址。</p> <ol> <li>ARP 进程在本局域网上广播发送一个 ARP 请求分组（具体格式可参阅[COME06]的第 23 章）。图 4-11（a）是主机 A 广播发送 ARP 请求分组的示意图。ARP 请求分组的主要内容是：“我的 IP 地址是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18。我想知道 IP 地址为 209.0.0.6 的主机的硬件地址。”</li> <li>在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组。</li> <li>主机 B 的 IP 地址与 ARP 请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机 A 发送 ARP 响应分组（其格式见[COME06]），同时在这个 ARP 响应分组中写入自己的硬件地址。由于其余的所有主机的 IP 地址都与 ARP 请求分组中要查询的 IP 地址不一致，因此都不理睬这个 ARP 请求分组，见图 4-11（b）。ARP 响应分组的主要内容是：“我的 IP 地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A。”请注意：虽然 ARP 请求分组是广播发送的，但 ARP 响应分组是普通的单播，即从一个源地址发送到一个目的地址。</li> <li>主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的IP 地址到硬件地址的映射。</li> </ol> <p><img src="/assets/images/computer-networks/the-working-principle-of-the-address-resolution-protocol.png" alt="地址解析协议 ARP 的工作原理"/> <em>图 4-11 地址解析协议 ARP 的工作原理</em></p> <p>在上述第（3）步中，当主机 B 收到 A 的 ARP 请求分组时，同时会把主机 A 的地址映射写入主机 B 自己的 ARP 高速缓存中。以后主机 B 向 A 发送数据报时就很方便了。</p> <p>ARP 把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。</p> <p>ARP 对保存在高速缓存中的每个映射地址项目都设置生存时间（例如，10 ～ 20 分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目的生存时间是很重要的。设想有一种情况。主机 A 和 B 通信。A 的 ARP 高速缓存里保存有 B 的硬件地址。但 B 的网络适配器突然坏了，B 立即更换了一块，因此 B 的硬件地址就改变了。假定 A 还要和 B 继续通信。A 在其 ARP 高速缓存中查找到 B 原先的硬件地址，并使用该硬件地址向 B 发送数据帧。但 B 原先的硬件地址已经失效了，因此 A 无法找到主机 B。但是过了一段不长的生存时间，A 的 ARP 高速缓存中已经删除了 B 原先的硬件地址，于是 A 重新广播发送 ARP 请求分组，又找到了 B。</p> <p>注意，ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如，在前面的图 4-9 中，主机 H 就无法解析出另一个局域网上主机 $H_2$ 的硬件地址（实际上主机 $H_1$ 也不需要知道远程主机 $H_2$ 的硬件地址）。主机 $H_1$ 发送给 $H_2$ 的 IP 数据报首先需要通过与主机 $H_1$ 连接在同一个局域网上的路由器 $R_1$ 来转发。因此主机 $H_1$ 这时需要把路由器 $R_1$ 的 IP 地址 $IP_3$，解析为硬件地址 $HA_3$，以便能够把 IP 数据报传送到路由器 $R_1$。以后 $R_1$ 从转发表找出了下一跳路由器 $R_2$，同时使用 ARP 解析出 $R_2$ 的硬件地址 $HA_5$。于是 IP 数据报按照硬件地址 $HA_5$，转发到路由器 $R_2$。路由器 $R_2$ 在转发这个 IP 数据报时用类似方法解析出目的主机 $H_2$ 的硬件地址 $HA_2$，使 IP 数据报最终交付主机 $H_2$。</p> <p>从 IP 地址到硬件地址的解析是自动进行的，<strong>主机的用户对这种地址解析过程是不知道的</strong>。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地把这个 IP 地址解析为链路层所需要的硬件地址。</p> <p>下面我们归纳出使用ARP的四种典型情况（图4-12）。</p> <p><img src="/assets/images/computer-networks/four-typical-scenarios-for-using-arp.png" alt="使用 ARP 的四种典型情况"/> <em>图4 -12 使用 ARP 的四种典型情况</em></p> <ol> <li>发送方是主机（如 $H_1$），要把 IP 数据报发送到同一个网络上的另一台主机（如 $H_2$）。这时 $H_1$ 发送 ARP 请求分组（在网上广播），找到目的主机 $H_2$ 的硬件地址。</li> <li>发送方是主机（如 $H_1$），要把 IP 数据报发送到另一个网络上的一台主机（如 $H_3$ 或 $H_4$）。这时 $H_1$ 发送 ARP 请求分组（在网上广播），找到网上的一个路由器 $R_1$ 的硬件地址。剩下的工作由路由器 $R_1$ 来完成。$R_1$ 要做的事情是下面的（3）或（4）。</li> <li>发送方是路由器（如 $R_1$），要把 IP 数据报转发到与 $R_1$ 连接在同一个网络（网 2）上的主机（如 $H_3$）。这时 $R_1$ 发送 ARP 请求分组（在网 2 上广播），找到目的主机 $H_3$ 的硬件地址。</li> <li>发送方是路由器（如 $R_1$），要把 IP 数据报转发到网 3 上的一台主机（如 $H_4$）。$H_4$ 与 $R_1$ 不是连接在同一个网络上。这时 $R_1$ 发送 ARP 请求分组（在网 2 上广播），找到连接在网 2 上的一个路由器 R2 的硬件地址。剩下的工作由这个路由器 $R_2$ 来完成。</li> </ol> <p>在许多情况下需要多次使用 ARP。但这只是以上几种情况的反复使用而已。</p> <p>既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的 IP 地址，而不直接使用硬件地址进行通信？由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但 IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p> <h3 id="25-ip-数据报的格式">2.5 IP 数据报的格式</h3> <p>IP 数据报的格式能够说明 IP 协议都具有什么功能。在 TCP/IP 的标准中，各种数据格式常常以 32 位（即 4 字节）为单位来描述。图 4-13 是 IP 数据报的完整格式。</p> <p><img src="/assets/images/computer-networks/format-of-the-ip-datagram.png" alt="IP 数据报的格式"/> <em>图 4-13 IP 数据报的格式</em></p> <p>从图 4-13 可看出，一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。</p> <h4 id="1ip-数据报首部的固定部分中的各字段">（1）IP 数据报首部的固定部分中的各字段</h4> <ul> <li><strong>版本</strong>：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4（即 IPv4）。</li> <li><strong>首部长度</strong>：占 4 位，可表示的最大十进制数值是 15。请注意，首部长度字段所表示数的单位是 32 位字（1 个 32 位字长是 4 字节）。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 5（即二进制表示的首部长度是 0101）。而当首部长度为最大值 1111 时（即十进制数的 15），就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节（即首部长度为 0101），这时不使用任何选项。</li> <li><strong>区分服务</strong>：占 8 位，用来获得更好的服务。只有在使用区分服务时，这个字段才起作用。一般情况下不使用这个字段[RFC2474，3168，3260]。</li> <li> <p><strong>总长度</strong>：总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 $2^{16} - 1$ = 65535 字节。 然而实际上传送这样长的数据报在现实中是极少遇到的。</p> <p>我们知道，在 IP 层下面的每种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为<strong>最大传送单元 MTU</strong>（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的 MTU 值。例如，最常用的以太网就规定其 MTU 值是 1500 字节。若所传送的数据报长度超过数据链路层的 MTU 值，就必须把过长的数据报进行分片处理。</p> <p>虽然使用尽可能长的 IP 数据报会使传输效率得到提高（因为每个 IP 数据报中首部长度占数据报总长度的比例就会小些），但数据报短些也有好处。每个 IP 数据报越短，路由器转发的速度就越快。为此，IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p> <p>在进行分片时（见后面的“片偏移”字段），数据报首部中的“总长度”字段是指分片后的每个分片的首部长度与该分片的数据长度的总和。</p> </li> <li> <p><strong>标识</strong>（identification）：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p> </li> <li><strong>标志</strong>（flag）：占 3 位，但目前只有两位有意义。 <ul> <li>标志字段中的最低位记为 MF（More Fragment）。MF = 1 即表示后面“还有分片”的数据报。MF = 0 表示这已是若干数据报片中的最后一个。</li> <li>标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF = 0 时才允许分片。</li> </ul> </li> <li> <p><strong>片偏移</strong>：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位。这就是说，每个分片的长度一定是 8 字节（64 位）的整数倍。下面举一个例子。 【例 4-1】 一数据报的总长度为 3820 字节，其数据部分为 3800 字节长（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。于是分为 3 个数据报片，其数据部分的长度分别为 1400，1400 和 1000 字节。原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。图 4-14 给出分片后得出的结果（注意片偏移的数值）。</p> <p><img src="/assets/images/computer-networks/example-for-fragment-datagram.png" alt="数据报的分片举例"/> <em>图 4-14 数据报的分片举例</em></p> <p>表 4-5 是本例中数据报首部与分片有关的字段中的数值，其中标识字段的值是任意给定的（12345）。具有相同标识的数据报片在目的站就可无误地重装成原来的数据报。</p> <p>| | 总长度 | 标识 | MF | DF | 片偏移 | | :—: | :—: | :—: | :—: | :—: | :—: | | 原始数据报 | 3820 | 12345 | 0 | 0 | 0 | | 数据报片 1 | 1420 | 12345 | 1 | 0 | 0 | | 数据报片 2 | 1420 | 12345 | 1 | 0 | 175 | | 数据报片 3 | 1020 | 12345 | 0 | 0 | 350 | <em>表 4-5 IP 数据报首部中与分片有关的字段中的数值</em></p> <p>现在假定数据报片 2 经过某个网络时还需要再进行分片，即划分为数据报片 2-1（携带数据 800 字节）和数据报片 2-2（携带数据 600 字节）。那么这两个数据报片的总长度、标识、MF、DF 和片偏移分别为：820，12345，1，0， 175；620，12345，1，0，275。</p> </li> <li> <p><strong>生存时间</strong>：占 8 位，生存时间字段常用的英文缩写是 TTL（Time To Live），表明这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子（例如从路由器 $R_1$ 转发到 $R_2$，再转发到 $R_3$，然后又转发到 $R_1$），因而白白消耗网络资源。最初的设计是以秒作为 TTL 值的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于 1 秒，后来就把 TTL 字段的功能改为“<strong>跳数限制</strong>”（但名称不变）。路由器在每次转发数据报之前就把 TTL 值减 1。若 TTL 值减小到零，就丢弃这个数据报，不再转发。因此，现在 TTL 的单位不再是秒，而是<strong>跳数</strong>。TTL 的意义是指明数据报在互联网中至多可经过多少个路由器。显然，数据报能在互联网中经过的路由器的最大数值是 255。若把 TTL 的初始值设置为 1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前 TTL 值就减小到零，因而就会被这个路由器丢弃。</p> </li> <li> <p><strong>协议</strong>：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。</p> <p>常用的一些协议和相应的协议字段值如下：</p> <table> <thead> <tr> <th>协议名</th> <th>ICMP</th> <th>IGMP</th> <th>IP</th> <th>TCP</th> <th>EGP</th> <th>IGP</th> <th>UDP</th> <th>IPv6</th> <th>ESP</th> <th>OSPF</th> </tr> </thead> <tbody> <tr> <td>协议字段值</td> <td>1</td> <td>2</td> <td>4</td> <td>6</td> <td>8</td> <td>9</td> <td>17</td> <td>41</td> <td>50</td> <td>89</td> </tr> </tbody> </table> </li> <li> <p><strong>首部检验和</strong>：占 16 位。这个字段<strong>只检验数据报的首部</strong>，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的 CRC 检验码而采用下面的简单计算方法：在发送方，先把 IP 数据报首部划分为许多 16 位字的序列，并把检验和字段置零。用反码算术运算把所有 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有 16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为 0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。图 4-15 说明了 IP 数据报首部检验和的计算过程。</p> <p><img src="/assets/images/computer-networks/the-calculation-process-of-ip-datagram-header-check-sum.png" alt="IP 数据报首部检验和的计算过程"/> <em>图 4-15 IP 数据报首部检验和的计算过程</em></p> </li> <li><strong>源地址</strong>：占 32 位。</li> <li><strong>目的地址</strong>：占 32 位。</li> </ul> <h4 id="2ip-数据报首部的可变部分">（2）IP 数据报首部的可变部分</h4> <p>IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。</p> <p>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 IPv6 就把 IP 数据报的首部长度做成固定的。</p> <h3 id="26-ip-层转发分组的流程">2.6 IP 层转发分组的流程</h3> <p>图 4-16（a）是一个路由表的简单例子。有四个 A 类网络通过三个路由器连接在一起。每个网络上都可能有成千上万台主机（图中没有画出这些主机）。可以想象，若路由表指出到每台主机应怎样转发，则所得出的路由表就会过于庞大（如果每个网络有 1 万台主机，四个网络就有 4 万台主机，因而每个路由表就有 4 万个项目，即 4 万行。每一行对应于一台主机）。但若路由表指出到某个网络应如何转发，则每个路由器中的路由表就只包含 4 个项目（即只有 4 行，每一行对应于一个网络）。以路由器 $R_2$ 的路由表为例。由于 $R_2$ 同时连接在网络 2 和网络 3 上，因此只要目的主机在网络 2 或网络 3上，都可通过接口 0 或 1 由路由器 $R_2$ 直接交付（当然还要利用地址解析协议 ARP 才能找到这些主机相应的硬件地址）。若目的主机在网络 1 中，则下一跳路由器应为 $R_1$，其 IP 地址为 20.0.0.7。路由器 $R_2$ 和 $R_1$ 由于同时连接在网络 2 上，因此从路由器 $R_2$ 分组转发到路由器 $R_1$ 是很容易的。同理，若目的主机在网络 4 中，则路由器 $R_2$ 应把分组转发给 IP 地址为30.0.0.1 的路由器 $R_3$。我们应当注意到，图中的每个路由器都有两个不同的 IP 地址。</p> <p>可以把整个的网络拓扑简化为图 4-16（b）所示的那样。在简化图中，网络变成了一条链路，但每个路由器旁边都注明其 IP 地址。使用这样的简化图，可以使我们不必关心某个网络内部的具体拓扑以及连接在该网络上有多少台主机，因为这些对于研究分组转发问题并没有什么关系。这样的简化图强调了在互联网上转发分组时，是从一个路由器转发到下一个路由器。</p> <p>总之，在路由表中，对每一条路由最主要的是以下两个信息：</p> \[（目的网络地址，下一跳地址）\] <p><img src="/assets/images/computer-networks/an-example-of-routing-table.png" alt="路由表举例"/> <em>图 4-16 路由表举例</em></p> <p>于是，我们就根据目的网络地址来确定下一跳路由器，这样做可得出以下的结果。</p> <ul> <li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li> <li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li> </ul> <p>虽然互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做<strong>特定主机路由</strong>。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某台主机的特殊路由就十分有用。</p> <p>路由器还可采用<strong>默认路由</strong>（default route）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。实际上，默认路由在主机发送 IP 数据报时往往更能显示出它的好处。我们之前讲过，主机在发送每个 IP 数据报时都要查找自己的路由表。如果一台主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。例如，在图 4-17 的互联网中，连接在网络上的任何一台主机中的路由表只需要三个项目即可。第一个项目就是到本网络主机的路由，其目的网络就是本网络 $N_1$，因而不需要路由器转发，而是直接交付。第二个项目是到网络 $N_2$ 的路由，对应的下一跳路由器是 $R_2$。第三个项目就是<strong>默认路由</strong>。只要目的网络是其他网络（不是 $N_1$ 或 $N_2$），就一律选择默认路由，把数据报先间接交付路由器 $R_1$，让再 $R_1$ 转发给互联网中的下一个路由器，一直转发到目的网络上的路由器，最后进行直接交付。在实际上的路由器中，像图 4-17 路由表中所示的“直接”和“其他”的几个字符并没有出现在路由表中，而是被记为 0.0.0.0。</p> <p><img src="/assets/images/computer-networks/router-r1-acts-as-the-default-router-for-network-n1.png" alt="路由器 $R_1$ 充当网络 $N_1$ 的默认路由器"/> <em>图 4-17 路由器 $R_1$ 充当网络 $N_1$ 的默认路由器</em></p> <p>这里我们应当强调指出，在 IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。在 IP 数据报的首部写上的 IP 地址是源 IP 地址和目的 IP 地址，而没有中间经过的路由器的 IP 地址。既然 IP 数据报中没有下一跳路由器的 IP 地址，那么待转发的数据报又怎样能够找到下一跳路由器呢？</p> <p>当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（必须使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用 ARP 得到硬件地址、把硬件地址写入 MAC 帧的首部等过程，将不断地重复进行，造成了一定的开销。</p> <p>那么，能不能在路由表中不使用 IP 地址而直接使用硬件地址呢？不行。我们一定要弄清楚，使用抽象的 IP 地址，本来就是为了隐蔽各种底层网络的复杂性而便于分析和研究问题，这样就不可避免地要付出代价，例如在选择路由时多了一些开销。但反过来，如果在路由表中直接使用硬件地址，那就会带来更多的麻烦。</p> <p>根据以上所述，可归纳出<strong>分组转发算法</strong>如下：</p> <ol> <li>从数据报的首部提取目的主机的 IP 地址 D，得出目的网络地址为 N。</li> <li>若 N 就是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行（3）。</li> <li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。</li> <li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）。</li> <li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）。</li> <li>报告转发分组出错。</li> </ol> <p>这里我们要再强调一下，路由表并没有给分组指明到某个网络的完整路径（即先经过哪一个路由器，然后再经过哪一个路由器，等等）。路由表指出，到某个网络应当先到某个路由器（即下一跳路由器），在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</p> <h2 id="三-划分子网和构造超网">三、 划分子网和构造超网</h2> <h3 id="31-划分子网">3.1 划分子网</h3> <h4 id="1从两级-ip-地址到三级-ip-地址">（1）从两级 IP 地址到三级 IP 地址</h4> <p>在今天看来，在 ARPANET 的早期，IP 地址的设计不够合理。</p> <ol> <li><strong>IP 地址空间的利用率有时很低</strong>。每个 A 类地址网络可连接的主机数超过 1000 万，而每个 B 类地址网络可连接的主机数也超过 6 万。有的单位申请到了一个 B 类地址网络，但所连接的主机数并不多，可是又不愿意申请一个足够使用的 C 类地址，理由是考虑到今后可能的发展。IP 地址的浪费，还会使 IP 地址空间的资源过早地被用完。</li> <li>给每个物理网络分配一个网络号会<strong>使路由表变得太大</strong>因而使网络性能变坏。每个路由器都应当能够从路由表查出应怎样到达其他网络的下一跳路由器。因此，互联网中的网络数越多，路由器的路由表的项目数也就越多。这样，即使我们拥有足够多的 IP 地址资源可以给每个物理网络分配一个网络号，也会导致路由器的路由表中的项目数过多。这不仅增加了路由器的成本（需要更多的存储空间），而且使查找路由时耗费更多的时间，同时也使路由器之间定期交换的路由信息急剧增加，因而使路由器和整个互联网的性能都下降了。</li> <li><strong>两级 IP 地址不够灵活</strong>。有时情况紧急，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必事先到互联网管理机构去申请新的网络号。原来的两级 IP 地址无法做到这一点。</li> </ol> <p>为解决上述问题，在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级 IP 地址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做<strong>划分子网</strong>（subnetting）[RFC 950]，或<strong>子网寻址</strong>或<strong>子网路由选择</strong>。划分子网已成为互联网的正式标准协议。</p> <p>划分子网的基本思路如下：</p> <ol> <li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个<strong>子网</strong>（subnet）。划分子网纯属一个单位内部的事情。本单位以外的网络<strong>看不见</strong>这个网络是由多少个子网组成，因为这个单位对<strong>外仍然表现为一个网络</strong>。</li> <li> <p>划分子网的方法是从网络的主机号借用若干位作为子网号（subnet-id），当然主机号也就相应减少了同样的位数。于是两级 IP 地址在<strong>本单位内部</strong>就变为<strong>三级</strong> IP 地址：网络号、子网号和主机号。也可以用以下记法来表示： \(IP 地址 ::== {&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}\)</p> </li> <li>凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。</li> </ol> <p>下面用例子说明划分子网的概念。图 4-18 表示某单位拥有一个 B 类 IP 地址，网络地址是 145.13.0.0（网络号是 145.13）。凡目的地址为 145.13.x.x 的数据报都被送到这个网络上的路由器 $R_1$。</p> <p><img src="/assets/images/computer-networks/a-b-network.png" alt="一个 B 类网络 145.13.0.0"/> <em>图 4-18 一个 B 类网络 145.13.0.0</em></p> <p>现把图 4-18 的网络划分为三个子网（图 4-19）。这里假定子网号占用 8 位，因此在增加了子网号后，主机号就只有 8 位。所划分的三个子网分别是：145.13.3.0，145.13.7.0 和 145.13.21.0 。在划分子网后，整个网络对外部仍表现为一个网络，其网络地址仍为 145.13.0.0。但网络 145.13.0.0 上的路由器 $R_1$ 在收到外来的数据报后，再根据数据报的目的地址把它转发到相应的子网。</p> <p><img src="/assets/images/computer-networks/a-subnet-of-b-network.png" alt="把图 4-18 的网络 145.13.0.0 划分为三个子网，但对外仍是一个网络"/> <em>图 4-19 把图 4-18 的网络 145.13.0.0 划分为三个子网，但对外仍是一个网络</em></p> <p>总之，当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。</p> <h4 id="2子网掩码">（2）子网掩码</h4> <p>假定有一个数据报（其目的地址是 145.13.3.10）已经到达了路由器 $R_1$。那么这个路由器如何把它转发到子网 145.13.3.0 呢？</p> <p>我们知道，从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。因此必须另外想办法，这就是使用<strong>子网掩码</strong>（subnet mask）（见图4-20）。</p> <p><img src="/assets/images/computer-networks/each-field-and-subnet-mask-of-the-ip-address.png" alt="IP 地址的各字段和子网掩码"/> <em>图 4-20 IP 地址的各字段和子网掩码（以 145.13.3.30 为例）</em></p> <ul> <li>图 4-20（a）是 IP 地址为 145.13.3.10 的主机本来的两级 IP 地址结构。</li> <li>图 4-20（b）是这个两级 IP 地址的子网掩码。</li> <li>图 4-20（c）是同一地址的三级 IP 地址结构，也就是说，现在从原来 16 位的主机号中拿出 8 位作为子网号，而主机号由 16 位减少到 8 位。请注意，现在子网号为 3 的网络的<strong>网络地址</strong>是 145.13.3.0（既不是原来两级 IP 地址的网络地址 145.13.0.0，也不是简单的子网号 3）。为了使路由器 $R_1$ 能够很方便地从数据报中的目的 IP 地址中提取出所要找的子网的网络地址，路由器 $R_1$ 就要使用三级 IP 地址的子网掩码。</li> <li>图 4-20（d）是三级 IP 地址的子网掩码，它也是 32 位，由一串 24 个 1 和跟随的一串 8 个 0 组成。子网掩码中的 1 对应于 IP 地址中原来二级地址中的 16 位网络号加上新增加的 8 位子网号，而子网掩码中的 0 对应于现在的 8 位主机号。虽然 RFC 文档中没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用<strong>连续的 1</strong>，以免出现可能发生的差错。</li> <li>图 4-20（e）表示 $R_1$ 把三级 IP 地址的子网掩码和收到的数据报的目的 IP 地址 145.13.3.10 逐位相“与”（AND）（计算机进行这种逻辑 AND 运算是很容易的），得出了所要找的<strong>子网的网络地址</strong> 145.13.3.0。</li> </ul> <p>使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“<strong>与</strong>”运算（AND），就能够立即得出网络地址。这样在路由器处理到来的分组时就可采用同样的算法。</p> <p>归纳一下上述的要点。从网络 145.13.0.0 外面看，这就是一个普通的 B 类网络，其子网掩码为 16 个连 1 后面跟上 16 个连 0。但进入到这个网络后（即到了路由器 $R_1$），就看到了还有许多网络（即划分了子网后的许多网络），其网络地址是 145.13.x.0（这里 x 可以表示不同的数值），而这些网络的子网掩码都是 24 个连 1 后面跟上 8 个连 0。总之，在这个 B 类网络的外面和里面，看到的网络是不一样的。</p> <p>这里还要弄清一个问题，这就是：在不划分子网时，既然没有子网，为什么还要使用子网掩码？这就是为了更便于查找路由表。现在互联网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用<strong>默认子网掩码</strong>。默认子网掩码中的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相“与”（AND），就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。显然：</p> <ul> <li>A 类地址的默认子网掩码是255.0.0.0，或 0xFF000000（注：对应二进制为 11111111 00000000 00000000 00000000）。</li> <li>B 类地址的默认子网掩码是255.255.0.0，或 0xFFFF0000（注：对应二进制为 11111111 11111111 00000000 00000000）。</li> <li>C 类地址的默认子网掩码是255.255.255.0，或 0xFFFFFF00（注：对应二进制为 11111111 11111111 11111111 00000000）。</li> </ul> <p>图 4-21 是这三类 IP 地址的网络地址和相应的默认子网掩码。</p> <p><img src="/assets/images/computer-networks/default-subnet-mask-of-class-a-b-and-c-ip-addresses.png" alt="A 类、B 类和 C 类 IP 地址的默认子网掩码"/> <em>图 4-21 A 类、B 类和 C 类 IP 地址的默认子网掩码</em></p> <p><strong>子网掩码是一个网络或一个子网的重要属性</strong>。在 RFC 950 成为互联网的正式标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。我们以一个 B 类地址为例，说明可以有多少种子网划分的方法。在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的（见表 4-6）。</p> <p>| 子网号的位数 | 子网掩码 | 子网数 | 每个子网的主机数 | | :-: | :-: | :-: | :-: | :-: | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | <em>表 4-6 B 类地址的子网划分选择（使用固定长度子网）</em></p> <p>在表 4-6 中，子网数是根据子网号（subnet-id）计算出来的。若 subnet-id 有 n 位，则共有 $2^n$ 种可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数。</p> <p>表中的“子网号的位数”中没有 0，1，15 和 16这四种情况，因为这没有意义。</p> <p>注意，虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，<strong>现在全 1 和全 0 的子网号也可以使用了</strong>，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种用法。</p> <p>我们可以看出，若使用较少位数的子网号，则每一个子网上可连接的主机数就较多。反之，若使用较多位数的子网号，则子网的数目较多但每个子网上可连接的主机数就较少。因此我们可根据网络的具体情况（一共需要划分多少个子网，每个子网中最多有多少台主机）来选择合适的子网掩码。</p> <p>通过简单的计算，读者不难得到这样的结论：<strong>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数</strong>。例如，本来一个 B 类地址最多可连接 65534 台主机，但表 4-6 中任意一行的最后两项的乘积一定小于 65534。对 A 类和 C 类地址的子网划分也可得出类似的表格。</p> <p>【例 4-2】已知 IP 地址是 141.14.72.24，子网掩码是 255.255.192.0。试求网络地址。</p> <p>【解】子网掩码是 11111111 11111111 11000000 00000000。请注意，掩码的前两个字节都是全 1，因此网络地址的前两个字节可写为 141.14。子网掩码的第四字节是全 0，因此网络地址的第四字节是 0。可见本题仅需对地址中的第三字节进行计算。我们只要把 IP 地址和子网掩码的第三字节用二进制表示，就可以很容易地得出网络地址（图 4-22）。</p> <p><img src="/assets/images/computer-networks/network-address-calculation.png" alt="网络地址的计算"/> <em>图 4-22 网络地址的计算</em></p> <p>注意，在一个 IP 地址中不允许把十进制和二进制混合使用。图 4-22 中（b）和（d）的写法，仅仅为了说明解题的步骤，而并非表示平时可以这样书写 IP 地址。</p> <p>【例 4-3】在上例中，若子网掩码改为 255.255.224.0。试求网络地址，并讨论所得结果。</p> <p>【解】 用同样方法可得出网络地址是 141.14.64.0，和上例的结果相同（图 4-23）。</p> <p><img src="/assets/images/computer-networks/different-subnet-masks-give-the-same-network-address.png" alt="不同的子网掩码得出相同的网络地址"/> <em>图 4-23 不同的子网掩码得出相同的网络地址</em></p> <p>这个例子说明，同样的 IP 地址和不同的子网掩码可以得出相同的网络地址。但是，不同的掩码的效果是不同的。在例 4-2 中，子网号是 2 位，主机号是 14 位。在例 4-3 中，子网号是 3 位，主机号是 13 位。因此这两个例子中可划分的子网数和每个子网中的最大主机数都是不一样的。</p> <h3 id="32-使用子网时分组的转发">3.2 使用子网时分组的转发</h3> <p>使用子网划分后，路由表必须包含以下三项内容：<strong>目的网络地址</strong>、<strong>子网掩码</strong>和<strong>下一跳地址</strong>。在划分子网的情况下，路由器转发分组的算法如下：</p> <ol> <li>从收到的数据报的首部提取目的 IP 地址 D。</li> <li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 逐位相“<strong>与</strong>”（AND 操作），看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去），转发任务结束。否则就是间接交付，执行（3）。</li> <li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。</li> <li>对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和 D 逐位相“<strong>与</strong>”（AND 操作），其结果为 N。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行（5）。</li> <li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）。</li> <li>报告转发分组出错。</li> </ol> <p>【例 4-4】图 4-24 有三个子网，两个路由器，以及路由器 $R_1$ 中的部分路由表。现在源主机 $H_1$ 向目的主机 $H_2$ 发送分组。试讨论 $R_1$ 收到 $H_1$ 向 $H_2$ 发送的分组后查找路由表的过程。</p> <p><img src="/assets/images/computer-networks/host-h1-sends-packets-to-h2.png" alt="主机 $H_1$ 向 $H_2$ 发送分组"/> <em>图 4-24 主机 $H_1$ 向 $H_2$ 发送分组</em></p> <p>【解】源主机 $H_1$ 向目的主机 $H_2$ 发送的分组的目的地址是 $H_2$ 的 IP 地址 128.30.33.138。源主机 $H_1$ 首先要进行的操作是要判断：发送的这个分组，是在本子网上进行直接交付还是要通过本子网上的路由器进行间接交付？</p> <p>源主机 $H_1$ 把本子网的“子网掩码 255.255.255.128”与目的主机 $H_2$ 的“IP 地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），得出 128.30.33.128，它不等于 $H_1$ 的网络地址（128.30.33.0）。这说明 $H_2$ 与 $H_1$ 不在同一个子网上。因此 $H_1$ 不能把分组直接交付 $H_2$，而必须交给子网上的默认路由器 $R_1$，由 $R_1$ 来转发。</p> <p>路由器 $R_1$ 在收到一个分组后，就在其路由表中逐行寻找有无匹配的网络地址。</p> <p>先看 $R_1$ 路由表中的第一行。用这一行的“子网掩码 255.255.255.128”和收到的分组的“目的地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），得出 128.30.33.128。然后和这一行给出的目的网络地址 128.30.33.0 进行比较。但比较的结果不一致（即不匹配）。</p> <p>用同样方法继续往下找第二行。用第二行的“子网掩码 255.255.255.128”和该分组的“目的地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），结果也是 128.30.33.128。这个结果和第二行的目的网络地址 128.30.33.128 相匹配，说明这个网络（子网 2） 就是收到的分组所要寻找的目的网络。于是不需要再继续查找下去。$R_1$ 把分组从接口 1 直接交付主机 $H_2$（它们都在一个子网上）。</p> <h3 id="33-无分类编址-cidr构造超网">3.3 无分类编址 CIDR（构造超网）</h3> <h4 id="1网络前缀">（1）网络前缀</h4> <p>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：</p> <ol> <li>B 类地址在 1992 年已分配了近一半，眼看很快就将全部分配完毕!</li> <li>互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。</li> <li>整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽了。</li> </ol> <p>当时预计前两个问题将在 1994 年变得非常严重。因此 IETF 很快就研究出采用无分类编址的方法来解决前两个问题。IETF 认为上面的第三个问题属于更加长远的问题，因此专门成立 IPv6 工作组负责研究解决新版本 IP 协议的问题。</p> <p>其实早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用<strong>变长子网掩码</strong> VLSM（Variable Length Subnet Mask）可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出<strong>无分类编址</strong>方法，它的正式名字是无分类域间路由选择 CIDR（Classless Inter-Domain Routing，CIDR 的读音是“sider”）。</p> <p>CIDR 最主要的特点有两个：</p> <ol> <li><strong>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念</strong>，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是“<strong>网络前缀</strong>”（network-prefix）（或简称为“前缀”），用来指明网络，后面部分则用来指明主机。因此 CIDR 使 IP 地址从三级编址（使用子网掩码）又回到了两级编址，但这已是<strong>无分类的两级编址</strong>。其记法是：</li> </ol> \[IP 地址 ::= {&lt;网络前缀&gt;，&lt;主机号&gt;}\] <p>CIDR 还使用“<strong>斜线记法</strong>”（slash notation），或称为 <strong>CIDR 记法</strong>，即在 IP 地址后面加上斜线“/”，然后写上网络前缀所占的位数。</p> <ol> <li>CIDR 把网络前缀都相同的连续的 IP 地址组成一个“CIDR <strong>地址块</strong>”。我们只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。例如，已知 IP 地址 128.14.35.7/20 是某 CIDR 地址块中的一个地址，现在把它写成二进制表示，其中的前 20 位是网络前缀（用粗体和下划线表示出），而前缀后面的 12 位是主机号：</li> </ol> \[128.14.35.7/20 = \underline{10000000 00001110 0010}0011 00000111\] <p>这个地址所在的地址块中的最小地址和最大地址可以很方便地得出：</p> <table> <thead> <tr> <th>最小地址</th> <th>128.14.32.0</th> <th>$\underline{10000000 00001110 0010}0000 00000000$</th> </tr> </thead> <tbody> <tr> <td>最大地址</td> <td>128.14.47.255</td> <td>$\underline{10000000 00001110 0010}1111 11111111$</td> </tr> </tbody> </table> <p>当然，以上这两个特殊地址的主机是全和全 1 的地址。一般并不使用。通常只使用在这两个特殊地址之间的地址。不难看出，这个地址块共有 $2^{12}$ 个地址。我们可以用地址块中的最小地址和网络前缀的位数指明这个地址块。例如，上面的地址块可记为 128.14.32.0/20。在不需要指出地址块的起始地址时，也可把这样的地址块简称为“/20 地址块”。</p> <p>为了更方便地进行路由选择，CIDR 使用 32 位的<strong>地址掩码</strong>（address mask）。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为子网掩码。例如，/20 地址块的地址掩码是：11111111 11111111 11110000 00000000（20 个连续的 1）。<strong>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数</strong>。</p> <p>注意，“CIDR 不使用子网”是指 CIDR 并没有在 32 位地址中指明若干位作为子网字段。但分配到一个 CIDR 地址块的单位，仍然可以在本单位内根据需要划分出一些子网。这些子网也都只有一个网络前缀和一台主机号字段，但子网的网络前缀比整个单位的网络前缀要长些。例如，某单位分配到地址块/20，就可以再继续划分为 8 个子网（即需要从主机号中借用 3 位来划分子网）。这时每个子网的网络前缀就变成 23 位（原来的 20 位加上从主机号借来的 3 位），比该单位的网络前缀多了 3 位。</p> <p>斜线记法还有一个好处就是它除了表示一个 IP 地址外，还提供了其他一些重要信息。我们举例说明如下。</p> <p>例如，地址 192.199.170.82/27 不仅表示IP 地址是 192.199.170.82，而且还表示这个地址块的网络的前缀有 27 位（剩下的 5 位是主机号），因此这个地址块包含 32 个 IP 地址（232）。通过简单的计算还可得出，这个地址块的最小地址是192.199.170.64，最大地址是 192.199.170.95。具体的计算方法是这样的。找出地址掩码中 1 和 0 的交界处发生在地址中的哪个字节。现在是在第四个字节。因此只要把这一个字节的十进制 82 用二进制表示即可。十进制 82 的二进制是 01010010，取其前 3 位（这 3 位加上前 3 个字节的 24 位等于前缀的 27 位），再把后面 5 位都写成 0，即 $010\underline{00000}$，等于十进制的 64。这就找出了地址块的最小地址 192.199.170.64。再把地址的第四字节的最后 5 位都置 1，即 $010\underline{11111}$，等于十进制的 95，这就找出了地址块中的最大地址 192.199.170.95。</p> <p>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong>（route aggregation），它使得路由表中的一个项目可以表示原来传统分类地址的很多个（例如上千个）路由。路由聚合也称为<strong>构成超网</strong>（supernetting）。路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p> <p>CIDR 记法有多种形式，例如，地址块 10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。另一种简化表示方法是在网络前缀的后面加一个星号 <code class="language-plaintext highlighter-rouge">*</code>，如：</p> \[00001010 00*\] <p>意思是：在星号 <code class="language-plaintext highlighter-rouge">*</code> 之前是网络前缀，而星号 <code class="language-plaintext highlighter-rouge">*</code> 表示 IP 地址中的主机号，可以是任意值。</p> <p>前缀位数不是 8 的整数倍时，需要进行简单的计算才能得到一些地址信息。</p> <p>表 4-7 给出了最常用的 CIDR 地址块。表中的 K 表示 $2^{10}$ 即 1024。网络前缀小于 13 或大于 27 都较少使用。在“包含的地址数”中没有把全 1 和全 0 的主机号除外。</p> <p>| CIDR 前缀长度 | 点分十进制 | 包含的地址数 | 相当于包含分类的网络数 | | :-: | :-: | :-: | :-: | | /13 | 255.248.0.0 | 512 K | 8 个 B 类或 2048 个 C 类 | | /14 | 255.252.0.0 | 256 K | 4 个 B 类或 1024 个 C 类 | | /15 | 255.254.0.0 | 128 K | 2 个 B 类或 512 个 C 类 | | /16 | 255.255.0.0 | 64 K | 1 个 B 类或 256 个 C 类 | | /17 | 255.255.128.0 | 32 K | 128 个 C 类 | | /18 | 255.255.192.0 | 16 K | 64个 C 类 | | /19 | 255.255.224.0 | 8 K | 32 个 C 类 | | /20 | 255.255.240.0 | 4 K | 16 个 C 类 | | /21 | 255.255.248.0 | 2 K | 8 个 C 类 | | /22 | 255.255.252.0 | 1 K | 4 个 C 类 | | /23 | 255.255.254.0 | 512 | 2 个 C 类 | | /24 | 255.255.255.0 | 256 | 1 个 C 类 | | /25 | 255.255.255.128 | 128 | 1/2 个 C 类 | | /26 | 255.255.255.192 | 64 | 1/4 个 C 类 | | /27 | 255.255.255.224 | 32 | 1/8 个 C 类 | <em>表 4-7 常用的 CIDR 地址块</em></p> <p>从表 4-7 可看出，每一个 CIDR 地址块中的地址数一定是 2 的整数次幂。除最后几行外，CIDR 地址块都包含了多个 C 类地址（是一个 C 类地址的 $2^n$ 倍，n 是整数），这就是“<strong>构成超网</strong>”这一名词的来源。</p> <p>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。然而在分类地址的环境中，向一个部门分配 IP 地址，就只能以 <code class="language-plaintext highlighter-rouge">/8</code>，<code class="language-plaintext highlighter-rouge">/16</code> 或 <code class="language-plaintext highlighter-rouge">/24</code> 为单位来分配。这就很不灵活。</p> <p>图 4-25 给出的是 CIDR 地址块分配的例子。假定某 ISP 已拥有地址块 206.0.64.0/18（相当于有 64 个 C 类网络）。现在某大学需要 800 个 IP 地址。ISP 可以给该大学分配一个地址块 206.0.68.0/22，它包括 1024（即 $2^{10}$） 个 IP 地址，相当于 4 个连续的 C 类 <code class="language-plaintext highlighter-rouge">/24</code> 地址块，占该 ISP 拥有的地址空间的 1/16。这个大学然后可自由地对本校的各系分配地址块，而各系还可再划分本系的地址块。CIDR 的地址块分配有时不易看清，这是因为网络前缀和主机号的界限不是恰好出现在整数字节处。只要写出地址的二进制表示（从图中的地址块的二进制表示中可看出，实际上只需要将其中的一个关键字节转换为二进制的表示即可），弄清网络前缀的位数，就不会把地址块的范围弄错。</p> <p><img src="/assets/images/computer-networks/example-for-dividing-cidr-address-blocks.png" alt="CIDR 地址块划分举例"/> <em>图 4-25 CIDR 地址块划分举例</em></p> <p>从图 4-25 可以清楚地看出<strong>地址聚合</strong>的概念。这个 ISP 共拥有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，就只需用路由聚合后的一个项目 206.0.64.0/18 就能找到该 ISP。同理，这个大学共有 4 个系。在 ISP 内的路由器的路由表中，也需使用 206.0.68.0/22 这个项目。这个项目好比是大学的收发室。凡寄给这个大学任何一个系的邮件，邮递员都不考虑大学各个系的地址，而是把这些邮件集中投递到大学的收发室，然后由大学的收发室再进行下一步的投递。这样就减轻了邮递员的工作量（相当于简化了路由表的查找）。</p> <p>从图 4-25 下面表格中的二进制地址可看出，把四个系的路由聚合为大学的一个路由（即构成超网），是将网络前缀<strong>缩短</strong>。<strong>网络前缀越短，其地址块所包含的地址数就越多</strong>。而在三级结构的 IP 地址中，划分子网是使网络前缀变长。</p> <h4 id="2最长前缀匹配">（2）最长前缀匹配</h4> <p>在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个 部分组成，因此在路由表中的项目也要有相应的改变。这时，每个项目由“网络前缀”和 “下一跳地址”组成。但是在查找路由表时可能会得到不止一个匹配结果。这样就带来一个 问题：我们应当从这些匹配结果中选择哪一条路由呢？ 正确的答案是：应当从匹配结果中选择具有最长网络前缀的路由。这叫做最长前缀匹 配（longest-prefix matching），这是因为网络前缀越长，其地址块就越小，因而路由就越具体 （more specific）。最长前缀匹配又称为最长匹配或最佳匹配。为了说明最长前缀匹配的概 念，我们仍以前面的例子来讨论。 假定大学下属的四系希望 ISP 把转发给四系的数据报直接发到四系而不要经过大学的路 由器，但又不愿意改变自己使用的 IP 地址块。因此，在 ISP 的路由器的路由表中，至少要 有以下两个项目，即206。0。68。0/22（大学）和206。0。71。128/25（四系）。现在假定 ISP 收到一 个数据报，其目的 IP 地址为D=206。0。71。130。把D分别和路由表中这两个项目的掩码逐位 相“与”（AND操作）。将所得的逐位 AND 操作的结果按顺序写在下面。 D 和 11111111 11111111 1111110000000000 逐位相“与”=206。0。68。0/22 匹配 D 和 11111111 11111111 11111111 10000000 逐位相“与”=206。0。71。128/25 匹配 不难看出，现在同一个 IP 地址 D 可以在路由表中找到两个目的网络（大学和四系）和 该地址相匹配。根据最长前缀匹配的原理，应当选择后者，把收到的数据报转发到后一个目 的网络（四系），即选择两个匹配的地址中更具体的一个。 从以上的讨论可以看出，如果IP 地址的分配一开始就采用 CIDR，那么我们可以按网 络所在的地理位置来分配地址块，这样就可大大减少路由表中的路由项目。例如，可以将世 界划分为四大地区，每一地区分配一个 CIDR 地址块： 地址块 194/7 （194。0。0。0至195。255。255。255）分配给欧洲； 地址块 198/7（198。0。0。0至199。255。255。255）分配给北美洲； 地址块 200/7 （200。0。0。0至201。255。255。255）分配给中美洲和南美洲； 地址块 202/7 （202。0。0。0至203。255。255。255）分配给亚洲和太平洋地区。 上面的每一个地址块包含有约3200 万个地址。这种分配地址的方法就使得IP地址与地 理位置相关联。它的好处是可以大大压缩路由表中的项目数。例如，凡是从中国发往北美的</p> <p>IP数据报（不管它是地址块198/7中的哪一个地址）都先送交位于美国的一个路由器，因此 在路由表中使用一个项目就行了。 但是，在使用 CIDR 之前，互联网的地址管理机构没有按地理位置来分配 IP 地址。现 在要把已分配出的IP 地址收回再重新分配是件十分困难的事，因为这牵涉到很多正在工作 的主机必须改变其 IP 地址。尽管这样，CIDR 的使用已经推迟了 IP 地址耗尽的日期。 3。使用二叉线索查找路由表 使用 CIDR 后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。当路 由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。例如， 连接路由器的线路的速率为10Gbit/s，而分组的平均长度为2000 bit，那么路由器就应当平均 每秒钟能够处理 500万个分组（常记为5Mpps）。或者说，路由器处理一个分组的平均时间只 有200 ns （1 ns = 10-秒）。因此，查找每一个路由所需的时间是非常短的。可见在路由表中 必须使用很好的数据结构和使用先进的快速查找算法，这一直是人们积极研究的热门课题。 对无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。例 如，给定一个目的地址 D。对每一个可能的网络前缀长度M，路由器从 D 中提取前 M 个位成 一个网络前缀，然后查找路由表中的网络前缀。所找到的最长匹配就对应于要查找的路由。 这种最简单的算法的明显缺点就是查找的次数太多。最坏的情况是路由表中没有这个 路由。在这种情况下，算法仍要进行32次（具有32位的网络前缀是一个特定主机路由）。 就是要找到一个传统的 B 类地址（即/16），也要查找 16次。对于经常使用的默认路由，这 种算法都要经历31次不必要的查找。 为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构 中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索（binary trie），它是一种 特殊结构的树。IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二 叉线索中的各个路径就代表路由表中存放的各个地址。 图 4-26 用一个例子来说明二叉线索的结构。图中给出了 5 个 IP 地址。为了简化二叉线 索的结构，可以先找出对应于每一个 IP 地址的唯一前缀（unique prefix）。所谓唯一前缀就是 在表中所有的 IP 地址中，该前缀是唯一的。这样就可以用这些唯一前缀来构造二叉线索。 在进行查找时，只要能够和唯一前缀相匹配就行了。 32位的IP地址 01000110 00000000 00000000 00000000 01010110 00000000 00000000 00000000 0 唯一前缀 0100 0101 01100001 00000000 00000000 00000000 10110000 00000010 00000000 00000000 011 10110 10111011 00001010 00000000 00000000 10111 1 图4-26 用5个前缀构成的二叉线索</p> <p>从二叉线索的根节点自顶向下的深度最多有32层，每一层对应于IP地址中的一位。 个 IP 地址存入二叉线索的规则很简单。先检查IP地址左边的第一位，如为0，则第一层的 节点就在根节点的左下方；如为 1，则在右下方。然后再检查地址的第二位，构造出第二层 的节点。依此类推，直到唯一前缀的最后一位。由于唯一前缀一般都小于32 位，因此用唯 一前缀构造的二叉线索的深度往往不到 32 层。图中较粗的折线就是前缀 0101 在这个二叉线 索中的路径。二叉线索中的小圆圈是中间节点，而在路径终点的小方框是叶节点（也叫做外 部节点）。每个叶节点代表一个唯一前缀。节点之间的连线旁边的数字表示这条边在唯一前 缀中对应的比特是0或1。 假定有一个 IP 地址是 10011011 01111010 00000000 00000000，需要查找该地址是否在 此二叉线索中。我们从最左边查起。很容易发现，查到第三个字符（即前缀 10 后面的 0） 时，在二叉线索中就找不到匹配的，说明这个地址不在这个二叉线索中。 以上只是给出了二叉线索这种数据结构的用法，而并没有说明“与唯一前缀匹配”和 “与网络前缀匹配”的关系。显然，要将二叉线索用于路由表中，还必须使二叉线索中的每 一个叶节点包含所对应的网络前缀和子网掩码。当搜索到一个叶节点时，就必须将寻找匹配 的目的地址和该叶节点的子网掩码进行逐位“与”运算，看结果是否与对应的网络前缀相匹 配。若匹配，就按下一跳的接口转发该分组。否则，就丢弃该分组。 总之，二叉线索只是提供了一种可以快速在路由表中找到匹配的叶节点的机制。但这 是否和网络前缀匹配，还要和子网掩码进行一次逻辑与的运算。 为了提高二叉线索的查找速度，广泛使用了各种压缩技术。例如，在图 4-26 中的最后 两个地址，其最前面的4位都是1011。因此，只要一个地址的前4位是1011，就可以跳过 前面4位（即压缩了4个层次）而直接从第5位开始比较。这样就可以减少查找的时间。当 然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由表时都可以提高查找 速度，因此这样做还是值得的。</p> <h2 id="四网际控制报文协议-icmp">四、网际控制报文协议 ICMP</h2> <p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协 议 ICMP （Internet Control Message Protocol） [RFC 792]。ICMP 允许主机或路由器报告差错情 况和提供有关异常情况的报告。ICMP 是互联网的标准协议。但ICMP 不是高层协议（看起 来好像是高层协议，因为ICMP报文是装在IP数据报中，作为其中的数据部分），而是IP 层的协议。ICMP报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出 去。ICMP 报文格式如图4-27所示。</p> <p><img src="/assets/images/computer-networks/icmp-packet-format.png" alt="ICMP 报文的格式"/> <em>图 4-27 ICMP 报文的格式</em></p> <h3 id="41-icmp-报文的种类">4.1 ICMP 报文的种类</h3> <p>ICMP 报文的种类有两种，即ICMP差错报告报文和 ICMP 询问报文。 ICMP 报文的前4个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4个字节的内容与ICMP的类型有关。最后面是数据字段，其长度取决于ICMP的类型。表 4-8 给出了几种常用的ICMP报文类型。 表4-8 几种常用的ICMP报文类型 ICMP 报文种类 类型的值 ICMP 报文的类型 3 终点不可达 11 时间超过 差错报告报文 12 参数问题 5 改变路由（Redirect） 8或0 回送（Echo）请求或回答 询问报文 13 或 14 时间戳（Timestamp）请求或回答 ICMP 标准在不断更新。已不再使用的ICMP报文有：“信息请求与回答报文”、“地址 掩码请求与回答报文”、“路由器请求与通告报文”以及“源点抑制报文”[RFC 6633]。现在 不再把这几种报文列入。 ICMP 报文的代码字段是为了进一步区分某种类型中的几种不同情况。检验和字段用来 检验整个 ICMP报文。我们应当还记得，IP数据报首部的检验和并不检验 IP 数据报的内 容，因此不能保证经过传输的ICMP报文不产生差错。 表4-8 给出的 ICMP差错报告报文共有四种，即： （1）终点不可达 （2） 时间超过 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。 当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向 源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片 时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。 （3）参数问题 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时， 就丢弃该数据报，并向源点发送参数问题报文。 （4）改变路由（重定向） 路由器把改变路由报文发送给主机，让主机知道下次应将 数据报发送给另外的路由器（可通过更好的路由）。 下面对改变路由报文进行简短的解释。我们知道，在互联网的主机中也要有一个路由 表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报 发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连 接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个 默认路由器的IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个 默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由（通过和其他路由器交换 路由信息）。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络 上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由 表中增加一个项目：到某某目的地址应经过路由器R（而不是默认路由器）。 所有的 ICMP 差错报告报文中的数据字段都具有同样的格式（图4-28）。把收到的需要 进行差错报告的IP数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数</p> <p>据字段。再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。 提取收到的数据报的数据字段前8个字节是为了得到运输层的端口号（对于TCP 和 UDP） 以及运输层报文的发送序号（对于TCP）。这些信息对源点通知高层协议是有用的（端口的 作用将在下一章的 5。1。3 节中介绍）。整个ICMP报文作为IP数据报的数据字段发送给源 点。 IP 数据报的数据字段 收到的 IP 数据报 IP数据报 首部 8 字节 ICMP的 前8字节 IP数据报 首部 8 字节 ICMP差错报告报文 首部 ICMP差错报告报文 装入ICMP报文的IP数据报 ·IP数据报。 图4-28 ICMP差错报告报文的数据字段的内容 下面是不应发送 ICMP 差错报告报文的几种情况。 对 ICMP差错报告报文，不再发送 ICMP差错报告报文。 对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP差错报告报文。 对具有多播地址的数据报，都不发送ICMP差错报告报文。 • 对具有特殊地址（如127。0。0。0或0。0。0。0）的数据报，不发送ICMP差错报告报文。 常用的 ICMP 询问报文有两种，即： （1）回送请求和回答 ICMP 回送请求报文是由主机或路由器向一个特定的目的主机 发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询 问报文用来测试目的站是否可达以及了解其有关状态。 （2） 时间戳请求和回答 ICMP 时间戳请求报文是请某台主机或路由器回答当前的日 期和时间。在 ICMP 时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900 年 1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。 4。4。2 ICMP 的应用举例 ICMP 的一个重要应用就是分组网间探测 PING （Packet InterNet Groper），用来测试两台 主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使 用网络层 ICMP 的一个例子。它没有通过运输层的TCP 或UDP。 Windows 操作系统的用户可在接入互联网后转入 MS DOS（点击“开始”，点击“运 行”，再键入“cmd”）。看见屏幕上的提示符后，就键入“ping hostname”（这里的 hostname 是要测试连通性的主机名或它的IP 地址），按回车键后就可看到结果。 图 4-29 给出了从南京的一台 PC 到新浪网的邮件服务器 mail。sina。com。cn 的连通性的测 试结果。PC 一连发出四个 ICMP 回送请求报文。如果邮件服务器 mail。sina。com。cn 正常工作 而且响应这个 ICMP 回送请求报文（有的主机为了防止恶意攻击就不理睬外界发送过来的这 种报文），那么它就发回 ICMP 回送回答报文。由于往返的 ICMP 报文上都有时间戳，因此 很容易得出往返时间。最后显示出的是统计结果：发送到哪个机器（IP 地址），发送的、收 到的和丢失的分组数（但不给出分组丢失的原因），以及往返时间的最小值、最大值和平均</p> <p>值。从得到的结果可以看出，第三个测试分组丢失了。 C：\Documents and Settings\XXR&gt;piny nail。sina。com。cn Pinging nail。sina。com。cn [202。108。43。230] with 32 bytes of data： Reply from 202。108。43。230： bytes=32 time=368ms TTL=242 Reply from 202。108。43。230；bytes=32 time=324ns TTL=242 Request timed out。 Reply from 202。108。43。230： bytes 32 time-374ms TTL-242 Ping statistics for 202。108。43。230： Packets： Sent = 4。 Received = 3， Lost 1 （25% loss）。 Approximate round trip times in milli-seconds： Minimum 368ms， Maximum 374ns， Average 372ns 图4-29 用PING 测试主机的连通性 另一个非常有用的应用是 traceroute（这是 UNIX 操作系统中名字），它用来跟踪一个分 组从源点到终点的路径。在 Windows 操作系统中这个命令是 tracert。下面简单介绍这个程 序的工作原理。 Traceroute 从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的 UDP 用户数据报。第一个数据报 Pı 的生存时间 TTL 设置为 1。当 Pı 到达路径上的第一个 路由器 Rı 时，路由器R， 先收下它，接着把 TTL 的值减 1。由于 TTL 等于零了，Rı 就把 Pı 丢弃了，并向源主机发送一个 ICMP 时间超过差错报告报文。 源主机接着发送第二个数据报P2，并把 TTL 设置为2。P，先到达路由器Rı，Rı 收下后 把 TTL 减 1 再转发给路由器R2R2 收到 P2时 TTL 为1，但减1 后 TTL 变为零了。R，就丢 弃 P2，并向源主机发送一个 ICMP时间超过差错报告报文。这样一直继续下去。当最后一 个数据报刚刚到达目的主机时，数据报的TTL 是 1。主机不转发数据报，也不把 TTL 值减 1。但因 IP 数据报中封装的是无法交付的运输层的 UDP 用户数据报，因此目的主机要向源 主机发送 ICMP 终点不可达差错报告报文（见下一章的5。2。2节）。 这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的 ICMP 报文正 好给出了源主机想知道的路由信息——到达目的主机所经过的路由器的IP地址，以及到达 其中的每一个路由器的往返时间。图 4-30 是从南京的一个 PC 向新浪网的邮件服务器 mail。sina。com。cn 发出的 tracert 命令后所获得的结果。图中每一行有三个时间出现，是因为 对应于每一个 TTL 值，源主机要发送三次同样的 IP 数据报。 我们还应注意到，从原则上讲，IP 数据报经过的路由器越多，所花费的时间也会越 多。但从图 4-30 可看出，有时正好相反。这是因为互联网的拥塞程度随时都在变化，也很 难预料到。因此，完全有这样的可能：经过更多的路由器反而花费更少的时间。</p> <p>IC：\Documents and Settings\22R&gt;tracert nail。sina。com。cn Tracing route to nail。sina。com。co [202。188。43。2301 over maximum of 30 hops： 1 24 ms 24 ms 23 ms 222。95。172。1 2 23 ms 24 ms 22 ms 3 23 ms 22 ms 4 24 ms 23 ms 5 22 ms 23 ms 6 28 ns 28 ms ？ 50 ns 50 ms 8 308 ms 311 ms 9 387 ns 305 ms 10 164 ms 164 ms 23 ms 24 ms 24 ns 28 ms 51 ms 310 ms 385 ns 165 ms 221。231。204。129 221。231。206。9 202。97。27。37 202。97。41。226 202。97。35。25 202。97。36。86 219。158。32。1 219。158。13。17 202。96。12。154 11 322 ms 320 ms 12 321 ms 322 ms 2988 ms 320 ms 61。135。148。50 freenai143-230。sina。com [202。108。43。2301 Trace conplete。 图4-30 用tracert 命令获得到目的主机的路由信息</p> <h2 id="五互联网的路由选择协议">五、互联网的路由选择协议</h2> <p>本节将讨论几种常用的路由选择协议，也就是要讨论路由表中的路由是怎样得出的。 4。5。1 有关路由选择协议的几个基本概念 1。理想的路由算法 路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。一个 理想的路由算法应具有如下的一些特点[BELL86]： （1）算法必须是正确的和完整的。这里，“正确”的含义是：沿着各路由表所指引的路 由，分组一定能够最终到达目的网络和目的主机。 （2）算法在计算上应简单。路由选择的计算不应使网络通信量增加太多的额外开销。 （3） 算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。当网络中的通 信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路 发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自 适应性为“稳健性”（robustness）。 ⑪ （4）算法应具有稳定性。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛 于一个可以接受的解，而不应使得出的路由不停地变化。 （5）算法应是公平的。路由选择算法应对所有用户（除对少数优先级高的用户）都是平 等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就 明显地不符合公平性的要求。 （6） 算法应是最佳的。路由选择算法应当能够找出最好的路由，使得分组平均时延最小 而网络的吞吐量最大。虽然我们希望得到“最佳”的算法，但这并不总是最重要的。对于某</p> <p>些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，所谓 “最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。 一个实际的路由选择算法，应尽可能接近于理想的算法。在不同的应用条件下，对以 上提出的六个方面也可有不同的侧重。 应当指出，路由选择是个非常复杂的问题，因为它是网络中的所有结点共同协调工作 的结果。其次，路由选择的环境往往是不断变化的，而这种变化有时无法事先知道，例如， 网络中出了某些故障。此外，当网络发生拥塞时，就特别需要有能缓解这种拥塞的路由选择 策略，但恰好在这种条件下，很难从网络中的各结点获得所需的路由选择信息。 倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两 大类，即静态路由选择策略与动态路由选择策略。静态路由选择也叫做非自适应路由选择， 其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可 以采用静态路由选择，用人工配置每一条路由。动态路由选择也叫做自适应路由选择，其特 点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由 选择适用于较复杂的大网络。 2。分层次的路由选择协议 互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。由于 以下两个原因，互联网采用分层次的路由选择协议： （1） 互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路 由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会 使互联网的通信链路饱和。 （2） 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议 （这属于本部门内部的事情），但同时还希望连接到互联网上。 为此，可以把整个互联网划分为许多较小的自治系统（autonomous system），一般都记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内 部的路由选择协议和共同的度量。一个AS对其他AS表现出的是一个单一的和一致的路由 选择策略[RFC 4271]。 在目前的互联网中，一个大的 ISP 就是一个自治系统。这样，互联网就把路由选择协议 划分为两大类，即： （1） 内部网关协议 IGP （Interior Gateway Protocol） 选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选 择协议使用得最多，如 RIP 和 OSPF 协议。 即在一个自治系统内部使用的路由 若源主机和目的主机处在不同的 （2）外部网关协议 EGP （External Gateway Protocol） 自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统 的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是 外部网关协议 EGP。目前使用最多的外部网关协议是BGP 的版本4（BGP-4）。 自治系统之间的路由选择也叫做域间路由选择（interdomain routing），而在自治系统内部 的路由选择叫做域内路由选择（intradomain routing）。 图 4-31 是两个自治系统互连在一起的示意图。每个自治系统自己决定在本自治系统内 部运行哪一个内部路由选择协议（例如，可以是 RIP，也可以是 OSPF）。但每个自治系统都 • 152 •</p> <p>Page 163 有一个或多个路由器（图中的路由器R1和R2）除运行本系统的内部路由选择协议外，还要 运行自治系统间的路由选择协议（BGP-4）。 自治系统 B 自治系统 A R₁ 用外部网关协议 （例如，BGP-4）， R， 用内部网关协议 （例如，RIP） 用内部网关协议 （例如，OSPF） 图4-31 自治系统和内部网关协议、外部网关协议 这里我们要指出两点： （1） 互联网的早期 RFC 文档中未使用“路由器”而是使用“网关”这一名词。但是在 新的 RFC 文档中又改用“路由器”这一名词，因此有的书把原来的 IGP 和 EGP 分别改为 IRP（内部路由器协议）和ERP（外部路由器协议）。为了方便读者查阅 RFC 文档，本书仍 使用 RFC 原先使用的名字IGP 和 EGP。 （2） RFC 采用的名词 IGP 和 EGP 协议类别的名称。但 RFC 在使用名词 EGP 时出现了 一点混乱，因为最早的一个外部网关协议的协议名字正好也是EGP [RFC 827]。后来发现该 RFC 提出的 EGP 有不少缺点，就设计了一种更好的外部网关协议，叫做边界网关协议 BGP （Border Gateway Protocol），用来取代旧的 RFC 827 外部网关协议 EGP。实际上，旧协议 EGP 和新协议 BGP 都属于外部网关协议 EGP 这一类别。因此在遇到名词 EGP 时，应弄清 它是指旧协议 EGP（即RFC827）还是指外部网关协议 EGP 这个类别。 总之，使用分层次的路由选择方法，可将互联网的路由选择协议划分为： 内部网关协议 IGP：具体的协议有多种，如RIP 和OSPF等。 外部网关协议 EGP：目前使用的协议就是 BGP。 对于比较大的自治系统，还可将所有的网络再进行一次划分。例如，可以构筑一个链 路速率较高的主干网和许多速率较低的区域网。每个区域网通过路由器连接到主干网。当在 一个区域内找不到目的站时，就通过路由器经过主干网到达另一个区域网，或者通过外部路 由器到别的自治系统中去查找。下面对这两类协议分别进行介绍。 4。5。2 内部网关协议 RIP 1。工作原理 RIP （Routing Information Protocol）是内部网关协议IGP 中最先得到广泛使用的协议[RFC 1058]，它的中文名称叫做路由信息协议，但很少被使用。RIP 是一种分布式的基于距离向 量的路由选择协议，是互联网的标准协议，其最大优点就是简单。 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记 录（因此，这是一组距离，即“距离向量”）。RIP 协议将“距离”定义如下： 从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离 定义为所经过的路由器数加1。“加1”是因为到达目的网络后就进行直接交付，而到直接连 接的网络的距离已经定义为 1。例如在前面讲过的图 4-16 中，路由器R， 到网或网 2 的距</p> <p>离都是1（直接连接），而到网3的距离是2，到网4的距离是3。 RIP 协议的“距离”也称为“跳数”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多 只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型 互联网。 需要注意的是，到直接连接的网络的距离也可定义为0（采用这种定义的理由是：路由 器在和直接连接在该网络上的主机通信时，不需要经过另外的路由器。既然每经过一个路由 器要将距离加 1，那么不再经过路由器的距离就应当为0）。作者编写的其他版本的教材过去 也曾使用过这种定义。但两种不同的定义对实现 RIP 协议并无影响，因为重要的是要找出 最短距离，将所有的距离都加1或都减1，对选择最佳路由其实是一样的。 RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由（即 最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。 本节讨论的 RIP 协议和下一节要讨论的OSPF协议，都是分布式路由选择协议。它们的 共同特点就是每一个路由器都要不断地和其他一些路由器交换路由信息。我们一定要弄清以 下三个要点，即和哪些路由器交换信息？交换什么信息？在什么时候交换信息？ RIP 协议的特点是： （1）仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器， 那么这两个路由器就是相邻的。RIP协议规定，不相邻的路由器不交换信息。 （2） 路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。也就 是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到每个网络应经 过的下一跳路由器”。 （3）按固定的时间间隔交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由 信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路 由信息。 这里要强调一点：路由器在刚刚开始工作时，它的路由表是空的。然后路由器就得出 到直接相连的几个网络的距离（这些距离定义为 1）。接着，每一个路由器也只和数目非常 有限的相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知 道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 看起来 RIP 协议有些奇怪，因为“我的路由表中的信息要依赖于你的，而你的信息又 依赖于我的。”然而事实证明，通过这样的方式——“我告诉别人一些信息，而别人又告诉 我一些信息。我再把我知道的更新后的信息告诉别人，别人也这样把更新后的信息再告诉 我”，最后在自治系统中所有的结点都得到了正确的路由选择信息。在一般情况下，RIP 协 议可以收敛，并且过程也较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选 择信息的过程。 路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳 地址。路由表更新的原则是找出到每个目的网络的最短距离。这种更新算法又称为距离向量 算法。下面就是 RIP 协议使用的距离向量算法。</p> <p>2。距离向量算法 对每一个相邻路由器发送过来的RIP报文，进行以下步骤： （1） 对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一 跳”字段中的地址都改为X，并把所有的“距离”字段的值加1（见后面的解释1）。每一个 项目都有三个关键数据，即：到目的网络N，距离是d，下一跳路由器是X。 （2）对修改后的RIP报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络N，则把该项目添加到路由表中（见解释2）。 否则（即在路由表中有目的网络N，这时就再查看下一跳路由器地址） 若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目（见解释3）。 否则（即这个项目是：到目的网络，但下一跳路由器不是X） 若收到的项目中的距离d小于路由表中的距离，则进行更新（见解释4）， 否则什么也不做。（见解释5） （3） 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路 由器，即把距离置为16（距离为16表示不可达）。 （4） 返回。 上面给出的距离向量算法的基础就是 Bellman-Ford 算法（或Ford-Fulkerson 算法）。这 种算法的要点是这样的： 设 X 是结点 A到B的最短路径上的一个结点。若把路径A→B拆成两段路径A→X 和 X→B，则每一段路径A→X和X→B也都分别是结点A到X和结点X到B的最短路径。 下面是对上述距离向量算法的五点解释。 解释：这样做是为了便于进行本路由表的更新。假设从位于地址X的相邻路由器发来 的 RIP 报文的某一个项目是：“Net2， 3， Y”，意思是“我经过路由器Y到网络 Net2 的距离是 3”，那么本路由器就可推断出：“我经过X到网络Net2的距离应为3+1=4”。于是，本路 由器就把收到的 RIP报文的这一个项目修改为“Net2， 4， X”，作为下一步和路由表中原有项 目进行比较时使用（只有比较后才能知道是否需要更新）。读者可注意到，收到的项目中的 Y对本路由器是没有用的，因为Y不是本路由器的下一跳路由器地址。 解释 2： 表明这是新的目的网络，应当加入到路由表中。例如，本路由表中没有到目的 网络 Net2 的路由，那么在路由表中就要加入新的项目“Net2， 4， X”。 解释 3：为什么要替换呢？因为这是最新的消息，要以最新的消息为准。到目的网络的 距离有可能增大或减小，但也可能没有改变。例如，不管原来路由表中的项目是“Net2， 3， X”还是“Net2，5，X”，都要更新为现在的“Net2， 4， X”。 解释4：例如，若路由表中已有项目“Net2， 5， P”，就要更新为“Net2， 4， X”。因为到网 络 Net2 的距离原来是5，现在减到4，更短了。 解释5： 若距离更大了，显然不应更新。若距离不变，更新后得不到好处，因此也不更新。 【例4-5】已知路由器R6有表4-9（a）所示的路由表。现在收到相邻路由器R4发来的路 由更新信息，如表4-9（b）所示。试更新路由器R6的路由表。</p> <p>表4-9（a） 路由器 Rs 的路由表 目的网络 Net2 距离 3 下一跳路由器 R4 Net3 4 Rs 。。。 表4-9（b） R4发来的路由更新信息 目的网络 Netl 距离 3 Net2 4 Net3 下一跳路由器 R₁ R2 1 直接交付 【解】 如同路由器一样，我们不需要知道该网络的拓扑。 先把表4-9（b）中的距离都加1，并把下一跳路由器都改为R4。得出表4-9（c）。 表4-9（c） 修改后的表4-9（b） 目的网络 距离 下一跳路由器 Netl 4 R4 Net2 5 R4 Net3 2 R4 把这个表的每一行和表4-9（a）进行比较。 第一行在表4-9（a）中没有，因此要把这一行添加到表4-9（a）中。 第二行的 Net2 在表4-9（a）中有，且下一跳路由器也是 R4。因此要更新（距离增大了）。 第三行的 Net3 在表4-9（a）中有，但下一跳路由器不同。于是就要比较距离。新的路由 信息的距离是2，小于原来表中的4，因此要更新。 这样，得出更新后的R的路由表如表4-9（d）所示。 表4-9（d） 路由器R6更新后的路由表 目的网络 距离 下一跳路由器 Net1 4 R4 Net2 5 R4 Net3 2 R4 RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并 不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最 少）。这里还应注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由 于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p> <p>3。 RIP 协议的报文格式 现在较新的 RIP 版本是1998年11 月公布的 RIP2 [RFC2453]（已成为互联网标准），新 版本协议本身并无多大变化，但性能上有些改进。RIP2 可以支持变长子网掩码和无分类域 间路由选择 CIDR。此外，RIP2还提供简单的鉴别过程支持多播。 图 4-32 是 RIP2 的报文格式，它和RIP1 的首部相同，但后面的路由部分不一样。从图 4-32 还可看出，RIP 协议使用运输层的用户数据报 UDP 进行传送（使用 UDP 的端口 520。 端口的意义见 5。2。2节）。 4 字节 命令 版本 必为0 4 字节 地址标识符 路由标记 网络地址 路由信息 子网掩码 下一跳路由器地址 （20字节/路由） 可重复出现 最多 25 个 首部 路由部分 距离（1-16） IP UDP 首部 首部 RIP报文 UDP 用户数据报 IP数据报 图4-32RIP2的报文格式 RIP 报文由首部和路由部分组成。 RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1表示请求路由信 息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为 0”是为了4字节字的对齐。 RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址 族标识符（又称为地址类别）字段用来标志所使用的地址协议。如采用 IP 地址就令这个字 段的值为2（原来考虑RIP也可用于其他非 TCP/IP 协议的情况）。路由标记填入自治系统号 ASN （Autonomous System Number），这是考虑使RIP 有可能收到本自治系统以外的路由选 择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的 距离。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是4+20× 25 = 504 字节。如超过，必须再用一个RIP报文来传送。 RIP2 还具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息（20 字 节）的位置用作鉴别。这时应将地址族标识符置为全1（即0xFFFF），而路由标记写入鉴别 类型，剩下的 16字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放 入24个路由信息。</p> <p>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所 有的路由器。我们可以用图 4-33 的简单例子来说明。设三个网络通过两个路由器互连起 来，并且都已建立了各自的路由表。图中路由器交换的信息只给出了我们感兴趣的一行内 容。路由器 Rı 中的“1， 1， 直接”表示“到网1的距离是1，直接交付”。路由器 R№ 中的“1， 2， Rı”表示“到网1的距离是2，下一跳经过 Rı”。 现在假定路由器 R， 到网 1 的链路出了故障，Rı 无法到达网 1。于是路由器 Rı 把到网 1 的距离改为 16（表示到网 1 不可达），因而在 Rı的路由表中的相应项目变为“1，16，直 接”。但是，很可能要经过30秒钟后，才把更新信息发送给R2。然而R，可能已经先把自 己的路由表发送给了R，其中有“1， 2， Rı”这一项。 | 1，1，直接 1， 2， R₁ 正常情况 网1 网2 网了 R₁ R₂ 网1出故障 网 2 网了 R2 R₁ 1，16，直接 1， 2， R₁ 1， 3， R， 1，4， R₁ 1， 5， R， D ： 1， 16， R， → 1， 16， R₁ 图4-33 RIP协议的缺点：坏消息传播得慢 Rı 收到 R2 的更新报文后，误认为可经过R，到达网1，于是把收到的路由信息“1，2， Rı”修改为：“1， 3， Rı”，表明“我到网1的距离是 3，下一跳经过R”，并把更新后的信息 发送给 R2。 同理，R，接着又更新自己的路由表为“1， 4， Rı”，以为“我到网 1 距离是 4，下一跳经 过 Rı”。 这样的更新一直继续下去，直到 R 和R2 到网 1的距离都增大到16时，R 和R2 才知道 原来网1是不可达的。RIP 协议的这一特点叫做：好消息传播得快，而坏消息传播得慢。网 络出故障的传播时间往往需要较长的时间（例如数分钟）。这是RIP 的一个主要缺点。 但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。 为了使坏消息传播得更快些，可以采取多种措施。例如，让路由器记录收到某特定路 由信息的接口，而不让同一路由信息再通过此接口向反方向传送。 总之，RIP 协议最大的优点就是实现简单，开销较小。但 RIP 协议的缺点也较多。首 先，RIP 限制了网络的规模，它能使用的最大距离为15（16表示不可达）。其次，路由器之 间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最 后，“坏消息传播得慢，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使 用下一节所述的 OSPF 协议。然而目前在规模较小的网络中，使用 RIP 协议的仍占多数。</p> <p>4。5。3 内部网关协议 OSPF 1。 OSPF 协议的基本特点 这个协议的名字是开放最短路径优先 OSPF （Open Shortest Path First）。它是为克服 RIP 的缺点在 1989年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 的第二个版本OSPF2 已成为互联网标准协议 [RFC 2328]。关于OSPF 可参阅专著[MOY98]，[HUIT95]。 请注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径 优先”。实际上，所有的在自治系统内部使用的路由选择协议（包括RIP 协议）都是要寻找 一条最短的路径。 OSPF 最主要的特征就是使用分布式的链路状态协议（link state protocol），而不是像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样： （1）向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法（flooding），这就是 路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息 发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区 域中所有的路由器都得到了这个信息的一个副本。更具体的做法后面还要讨论。我们应注 意，RIP 协议是仅仅向自己相邻的几个路由器发送信息。 （2） 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道 的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的 “度量”（metric）。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都 由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。我们应注 意，对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。 （3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。 从上述的三个方面可以看出，OSPF 和 RIP 的工作原理相差较大。 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链 路状态数据库（link-state database），这个数据库实际上就是全网的拓扑结构图。这个拓扑结 构图在全网范围内是一致的（这称为链路状态数据库的同步）。因此，每一个路由器都知道 全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使 用链路状态数据库中的数据，构造出自己的路由表（例如，使用 Dijkstra 的最短路径路由算 法）。我们注意到，RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由 器，但却不知道全网的拓扑结构（只有到了下一跳路由器，才能知道再下一跳应当怎样 走）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。 OSPF 的更新过程收敛得快是其重要优点。</p> <p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的 范围，叫做区域（area）。图4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。当然，一个区域也不能太大，在一个区域内的路 由器最好不超过200个。 至其他自治系统 自治系统 AS 主干区域 0。0。0。0 R， R6 网6。 R&gt; Rs 网13 7 网23 R2 网43 网83 XX3 5 区域 0。0。0。3 区域0。0。0。1 区域0。0。0。2 图4-34 OSPF划分为两种不同的区域 划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是 整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域 的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以 外的区域进行通信，OSPF 使用层次结构的区域划分。在上层的区域叫做主干区域（backbone area）。主干区域的标识符规定为0。0。0。0。主干区域的作用是用来连通其他在下层的区域。从 其他区域来的信息都由区域边界路由器（area border router）进行概括。在图4-34 中，路由器 R3，R4 和R，都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。 在主干区域内的路由器叫做主干路由器（backbone router），如 R3，R4，Rs，R6 和R7。一个主 干路由器可以同时是区域边界路由器，如R3，R4 和R7。在主干区域内还要有一个路由器专 门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做自治系统边界路由器 （如图中的R。）。 采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复 杂了。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议 能够用于规模很大的自治系统中。这里，我们再一次地看到划分层次在网络设计中的重要 性。 OSPF 不用 UDP 而是直接用 IP 数据报传送（其IP数据报首部的协议字段值为89）。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以 不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据 报，而整个数据报就必须重传。 OSPF 分组使用24字节的固定长度首部（见图4-35），分组的数据部分可以是五种类型 分组中的一种。下面简单介绍 OSPF 首部各字段的意义。 （1） 版本 当前的版本号是2。 （2） 类型 可以是五种类型分组中的一种。 （3）分组长度 包括 OSPF 首部在内的分组长度，以字节为单位。 （4）路由器标识符 标志发送该分组的路由器的接口的 IP 地址。</p> <p>（5） 区域标识符 分组属于的区域的标识符。 （6） 检验和 用来检测分组中的差错。 （7） 鉴别类型 目前只有两种，0（不用）和1（口令）。 （8） 鉴别 鉴别类型为0时就填入0，鉴别类型为1则填入8个字符的口令。 位 0 8 16 31 版本 类型 分组长度 路由器标识符 区域标识符 检验和 鉴别类型 鉴 别 鉴 别 -24字节- OSPF 分组首部 类型1至类型5 的OSPF 分组 IP数据报首部一 OSPF 分组 IP数据报 图4-35 OSPF分组用IP数据报传送 除了以上的几个基本特点外，OSPF 还具有下列的一些特点： （1） OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实 时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此， OSPF 对于不同类型的业务可计算出不同的路由。链路的代价可以是1至65535中的任何一 个无量纲的数，因此十分灵活。商用的网络在使用OSPF时，通常根据链路带宽来计算链路 的代价。这种灵活性是RIP所没有的。 （2） 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路 径。这叫做多路径间的负载平衡（load balancing）。在代价相同的多条路径上分配通信量是 通信量工程中的简单形式。RIP只能找出到某个网络的一条路径。 （3） 所有在 OSPF 路由器之间交换的分组（例如，链路状态更新分组）都具有鉴别的功 能，因而保证了仅在可信赖的路由器之间交换链路状态信息。 （4） OSPF 支持可变长度的子网划分和无分类的编址 CIDR。 （5） 由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一 个 32 位的序号，序号越大状态就越新。OSPF规定，链路状态序号增长的速率不得超过每5 秒钟1次。这样，全部序号空间在600年内不会产生重复号。 2。 OSPF 的五种分组类型 OSPF 共有以下五种分组类型： （1） 类型 1，问候（Hello）分组，用来发现和维持邻站的可达性。 （2） 类型 2，数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库 中的所有链路状态项目的摘要信息。 （3） 类型 3，链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目 的详细信息。 （4）类型 4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。这 种分组是最复杂的，也是OSPF协议最核心的部分。路由器使用这种分组将其链路状态通知 给邻站。链路状态更新分组共有五种不同的链路状态[RFC2328]，这里从略。 （5） 类型 5，链路状态确认（Link State Acknowledgment）分组，对链路更新分组的确认。 OSPF 规定，每两个相邻路由器每隔10秒钟要交换一次问候分组。这样就能确知哪些 邻站是可达的。对相邻路由器来说，“可达”是最基本的要求，因为只有可达邻站的链路状 态信息才存入链路状态数据库（路由表就是根据链路状态数据库计算出来的）。在正常情况 下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由 器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重 新计算路由表。 其他的四种分组都是用来进行链路状态数据库的同步。所谓同步就是指不同路由器的 链路状态数据库的内容是一样的。两个同步的路由器叫做“完全邻接的”（fully adjacent）路 由器。不是完全邻接的路由器表明它们虽然在物理上是相邻的，但其链路状态数据库并没有 达到一致。 当一个路由器刚开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工 作，以及将数据发往相邻路由器所需的“代价”。如果所有的路由器都把自己的本地链路状 态信息对全网进行广播，那么各路由器只要将这些链路状态信息综合起来就可得出链路状态 数据库。但这样做开销太大，因此 OSPF 采用下面的办法。 OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态 摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了 数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对 方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网 同步的链路数据库就建立了。图 4-36 给出了OSPF 的基本操作，说明了两个路由器需要交 换各种类型的分组。 问候 确定可达性 达到数据库的同步 问候 数据库描述 数据库描述 数据库描述 数据库描述 新情况下的同步 链路状态请求 链路状态更新 链路状态确认 图4-36 OSPF 的基本操作 在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路 状态更新分组，用洪泛法向全网更新链路状态。OSPF 使用的是可靠的洪泛法，其要点见图 4-37 所示。设路由器R 用洪泛法发出链路状态更新分组。图中用一些小的箭头表示更新分 组。第一次先发给相邻的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上 游路由器除外。可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要 发送一次确认）。图中的空心箭头表示确认分组。 更新报文 R R R ACK报文 R 图4-37 用可靠的洪泛法发送更新分组 为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规 模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。由于 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于100 ms。 若 N 个路由器连接在一个以太网上，则每个路由器要向其他（N - 1）个路由器发送链路 状态信息，因而共有 N（N-1）个链路状态要在这个以太网上传送。OSPF 协议对这种多点接 入的局域网采用了指定的路由器（designated router）的方法，使广播的信息量大大减少。指定 的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。 4。5。4 外部网关协议 BGP 1989 年，公布了新的外部网关协议——边界网关协议 BGP。为简单起见，后面我们把 目前使用最多的版本 BGP-4 经常简写为 BGP。最近已经陆续发布了一些 BGP-4 的更新文 档，但目前 BGP-4仍然是草案标准[RFC 4271]。 我们首先应当弄清，在不同自治系统 AS 之间的路由选择为什么不能使用前面讨论过的 内部网关协议，如 RIP 或OSPF？ 我们知道，内部网关协议（如RIP 或OSPF）主要是设法使数据报在一个AS中尽可能 有效地从源站传送到目的站。在一个AS 内部也不需要考虑其他方面的策略。然而 BGP 使 用的环境却不同。这主要是因为以下的两个原因： 第一，互联网的规模太大，使得自治系统 AS 之间路由选择非常困难。连接在互联网主 干网上的路由器，必须对任何有效的IP 地址都能在路由表中找到匹配的目的网络。目前在 互联网的主干网路由器中，一个路由表的项目数早已超过了5万个网络前缀。如果使用链路 状态协议，则每一个路由器必须维持一个很大的链路状态数据库。对于这样大的主干网用 Dijkstra算法计算最短路径时花费的时间也太长。另外，由于自治系统 AS 各自运行自己选 定的内部路由选择协议，并使用本AS 指明的路径度量，因此，当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。例如，对某AS 来说，代价 为1000可能表示一条比较长的路由。但对另一AS代价为1000却可能表示不可接受的坏路 由。因此，对于自治系统 AS之间的路由选择，要用“代价”作为度量来寻找最佳路由也是 很不现实的。比较合理的做法是在自治系统之间交换“可达性”信息（即“可到达”或“不 可到达”）。例如，告诉相邻路由器：“到达目的网络N可经过自治系统 ASx”。 第二，自治系统 AS 之间的路由选择必须考虑有关策略。由于相互连接的网络的性能相 差很大，根据最短距离（即最少跳数）找出来的路径，可能并不合适。也有的路径的使用代 价很高或很不安全。还有一种情况，如自治系统 AS要发送数据报给自治系统 ASz，本来最 好是经过自治系统 AS3。但 AS， 不愿意让这些数据报通过本自治系统的网络，因为“这是他 们的事情，和我们没有关系。”但另一方面，自治系统 AS，愿意让某些相邻自治系统的数据 报通过自己的网络，特别是对那些付了服务费的某些自治系统更是如此。因此，自治系统之 间的路由选择协议应当允许使用多种路由选择策略。这些策略包括政治、安全或经济方面的 考虑。例如，我国国内的站点在互相传送数据报时不应经过国外兜圈子，特别是，不要经过 某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置 的，但这些策略并不是自治系统之间的路由选择协议本身。还可举出一些策略的例子，如： “仅在到达下列这些地址时才经过ASx”，“AS和AS， 相比时应优先通过 ASx”，等等。显 然，使用这些策略是为了找出较好的路径而不是最佳路径。 由于上述情况，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的 路由（不能兜圈子），而并非要寻找一条最佳路由。BGP 采用了路径向量（path vector）路由选 择协议，它与距离向量协议（如RIP）和链路状态协议（如OSPF）都有很大的区别。 在配置 BGP 时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 “BGP 发言人”。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是BGP边界路由器，但也可以不是BGP 边界路由器。 一个 BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息，就要先建立TCP 连接 （端口号为 179），然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会 话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使 用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两 个 BGP 发言人，彼此成为对方的邻站（neighbor）或对等站（peer）。 图 4-38 表示 BGP 发言人和自治系统 AS的关系的示意图。在图中画出了三个自治系统 中的 5 个 BGP 发言人。每一个 BGP 发言人除了必须运行 BGP 协议外，还必须运行该自治 系统所使用的内部网关协议，如 OSPF 或 RIP。 BGP BGP ASı 发言人 发言人 AS2 BGP 发言人 BGP 发言人 AS3 BGP 发言人 AS4 AS5 图4-38 BGP发言人和自治系统 AS的关系 边界网关协议 BGP所交换的网络可达性的信息就是要到达某个网络（用网络前缀表 示）所要经过的一系列自治系统。当BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。图 4-39 表示从图 4-38 的 AS 上的一个 BGP 发言人构造出的自治系统连通图，它是树形结构，不存 在回路。 AS， AS， AS AS ASF 图4-39 自治系统AS的连通图举例 在第 1 章的 1。2。2 节我们已经介绍了当前互联网的多级结构特点（图1-4）。这种多级结 构的网络拓扑决定了BGP路由选择协议的特点。 图 4-40 给出了一个 BGP 发言人交换路径向量的例子。自治系统 AS2 的BGP 发言人通 知主干网的 BGP 发言人：“要到达网络 Nı，N2，N3 N4可经过ASz。”主干网在收到这个通 知后，就发出通知：“要到达网络 Nı， N2， N3 和 N4 可沿路径（ASı，ASz）。”同理，主干网还 可发出通知：“要到达网络 Ns， N｡ 和N，可沿路径（ASı， AS3）。” 地区 ISP （ASz） 本地ISP（AS） N，N2 主干网 （AS） 本地ISP（AS） N3， N4 本地ISP（AS） Ns 地区 ISP （AS3） 本地 ISP（AS） No，N7 图4-40 BGP发言人交换路径向量的例子 从上面的讨论可看出，BGP 协议交换路由信息的结点数量级是自治系统个数量级， 这要比这些自治系统中的网络数少很多。要在许多自治系统之间寻找一条较好的路径，就是</p> <p>要寻找正确的 BGP 发言人（或边界路由器），而在每一个自治系统中 BGP 发言人（或边界 路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。 BGP 支持无分类域间路由选择 CIDR，因此 BGP 的路由表也就应当包括目的网络前 缀、下一跳路由器，以及到达该目的网络所要经过的自治系统序列。由于使用了路径向量的 信息，就可以很容易地避免产生兜圈子的路由。如果一个BGP 发言人收到了其他 BGP 发言 人发来的路径通知，它就要检查一下本自治系统是否在此通知的路径中。如果在这条路径 中，就不能采用这条路径（因为会兜圈子）。 在 BGP 刚刚运行时，BGP 的邻站是交换整个的BGP路由表。但以后只需要在发生变 化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。 在 RFC 4271 中规定了BGP-4 的四种报文： （1） OPEN（打开）报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。 （2）UPDATE（更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由。 （3）KEEPALIVE（保活）报文，用来周期性地证实邻站的连通性。 （4）NOTIFICATION（通知）报文，用来发送检测到的差错。 若两个邻站属于两个不同 AS，而其中一个邻站打算和另一个邻站定期地交换路由信 息，这就应当有一个商谈的过程（因为很可能对方路由器的负荷已很重因而不愿意再加重负 担）。因此，一开始向邻站进行商谈时就必须发送 OPEN 报文。如果邻站接受这种邻站关 系，就用 KEEPALIVE 报文响应。这样，两个 BGP 发言人的邻站关系就建立了。 一旦邻站关系建立了，就要继续维持这种关系。双方中的每一方都需要确信对方是存 在的，且一直在保持这种邻站关系。为此，这两个 BGP 发言人彼此要周期性地交换 KEEPALIVE 报文（一般每隔30秒）。KEEPALIVE 报文只有 19 字节长（只用 BGP 报文的 通用首部），因此不会造成网络上太大的开销。 UPDATE 报文是BGP 协议的核心内容。BGP 发言人可以用UPDATE 报文撤销它以前 曾经通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路 由时，每个更新报文只能增加一条。 BGP 可以很容易地解决距离向量路由选择算法中的“坏消息传播得慢”这一问题。当 某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很 容易选择出新的路由。距离向量算法往往不能给出正确的选择，是因为这些算法不能指出哪 些邻站到目的站的路由是独立的。 图 4-41 给出了 BGP报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度 为 19 字节。通用首部分为三个字段。标记（marker）字段为16字节长，用来鉴别收到的 BGP 报文（这是假定将来有人会发明出合理的鉴别方案）。当不使用鉴别时，标记字段要置为全 1。长度字段指出包括通用首部在内的整个 BGP报文以字节为单位的长度，最小值是 19， 最大值是 4096。类型字段的值为1到4，分别对应于上述四种 BGP报文中的一种。 OPEN 报文共有6个字段，即版本（1字节，现在的值是4）、本自治系统号（2 字节， 使用全球唯一的16 位自治系统号，由ICANN 地区登记机构分配）、保持时间（2 字节，以 秒计算的保持为邻站关系的时间）、BGP 标识符（4字节，通常就是该路由器的IP 地址）、 可选参数长度（1字节）和可选参数。</p> <p>字节 16 2 1 H 标 记 长度 类型 BGP报文通用首部 BGP报文主体部分 | TCP 首部 BGP 报文 IP 首部 TCP报文 图4-41 BGP报文具有通用的首部 UPDATE 报文共有5个字段，即不可行路由长度（2字节，指明下一个字段的长度）、 撤销的路由（列出所有要撤销的路由）、路径属性总长度（2 字节，指明下一个字段的长 度）、路径属性（定义在这个报文中增加的路径的属性）和网络层可达性信息 NLRI （Network Layer Reachability Information）。最后这个字段定义发出此报文的网络，包括网络 前缀的位数、IP 地址前缀。 KEEPALIVE 报文只有BGP的19字节长的通用首部。 NOTIFICATION 报文有3 个字段，即差错代码（1 字节）、差错子代码（1 字节）和差 错数据（给出有关差错的诊断信息）。 在讨论完路由选择之后，我们再来介绍路由器的构成。 4。5。5 路由器的构成 1。路由器的结构 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。 从路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路 由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组， 直到该分组到达终点为止。路由器的转发分组正是网络层的主要工作。图 4-42 给出了一种 典型的路由器的构成框图。 路由选择处理机 路由选择协议 路由选择 路由表 输入端口 输出端口 23元 3 分组处理 转发表 分组转发 输入端口 输出端口 1-2-3 交换结构 3 2 -1 图4-42 典型的路由器的结构（图中的数字1~3表示相应层次的构件） 部分。 从图 4-42 可以看出，整个的路由器结构可划分为两大部分：路由选择部分和分组转发 路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任 务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信 息而不断地更新和维护路由表。关于怎样根据路由选择协议构造和更新路由表，我们已在前 面的4。5。2至4。5。4节讨论过了。 分组转发部分是本节所要讨论的问题，它由三部分组成：交换结构、一组输入端口和 一组输出端口（请注意：这里的端口就是硬件接口）。下面分别讨论每一部分的组成。 交换结构（switching fabric）又称为交换组织，它的作用就是根据转发表（forwarding table） 对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构本 身就是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中 的网络”。 请注意“转发”和“路由选择”是有区别的。在互联网中，“转发”就是路由器根据转 发表把收到的 IP数据报从路由器合适的端口转发出去。“转发”仅仅涉及到一个路由器。但 “路由选择”则涉及到很多路由器，路由表则是许多路由器协同工作的结果。这些路由器按 照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态地改变所选择的路由，并 由此构造出整个的路由表。路由表一般仅包含从目的网络到下一跳（用 IP 地址表示）的映 射，而转发表是从路由表得出的。转发表必须包含完成转发功能所必需的信息。这就是说， 在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC 地址信息（如下一 跳的以太网地址）的映射。将转发表和路由表用不同的数据结构实现会带来一些好处，这是 因为在转发分组时，转发表的结构应当查找过程最优化，但路由表则需要对网络拓扑变化 的计算最优化。路由表总是用软件实现的，但转发表则甚至可用特殊的硬件来实现。请读者 注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，而可以笼统地都使 用路由表这一名词。 在图 4-42 中，路由器的输入和输出端口里面都各有三个方框，用方框中的 1， 2 和 3 分 别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按 照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理 模块。若接收到的分组是路由器之间交换路由信息的分组（如 RIP 或OSPF 分组等），则把 这种分组送交路由器的路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照 分组首部中的目的地址查找转发表，根据得出的结果，分组就经过交换结构到达合适的输出 端口。一个路由器的输入端口和输出端口就做在路由器的线路接口卡上。 输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分 散化，往往把复制的转发表放在每一个输入端口中（如图 4-42 中的虚线箭头所示）。路由选 择处理机负责对各转发表的副本进行更新。这些副本常称为“影子副本”（shadow copy）。分 散化交换可以避免在路由器中的某一点上出现瓶颈。 以上介绍的查找转发表和转发分组的概念虽然并不复杂，但在具体的实现中还是会遇 到不少困难。问题就在于路由器必须以很高的速率转发分组。最理想的情况是输入端口的处 理速率能够跟上线路把分组传送到路由器的速率。这种速率称为线速（line speed 或 wire speed）。可以粗略地估算一下。设线路是OC-48 链路，即 2。5 Gbit/s。若分组长度为256 字 节，那么线速就应当达到每秒能够处理 100 万以上的分组。现在常用 Mpps （百万分组每 秒）为单位来说明一个路由器对收到的分组的处理速率有多高。在路由器的设计中，怎样提 高查找转发表的速率是一个十分重要的研究课题。 当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个 后到的分组就必须在队列中排队等待，因而产生了一定的时延。图4-43 给出了在输入端口 的队列中排队的分组的示意图。 输入端口的处理 网络层处理 分组排队 数据链路层| · 物理层处理 处理 查表和转发 从线路接收分组 交换结构 图4-43 输入端口对线路上收到的分组的处理 我们再来观察在输出端口上的情况（图4-44）。输出端口从交换结构接收分组，然后把 它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上它就是一 个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组 就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给 物理层后发送到外部线路。 交换结构 向线路发送分组 输出端口的处理 网络层处理 分组排队 数据链路层 物理层处理· 处理 缓存管理 图4-44 输出端口把交换结构传送过来的分组发送到线路上 从以上的讨论可以看出，分组在路由器的输入端口和输出端口都可能会在队列中排队 等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少 到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。以前我们提到过的分 组丢失就是发生在路由器中的输入或输出队列产生溢出的时候。当然，设备或线路出故障也 可能使分组丢失。 2。交换结构 交换结构是路由器的关键构件[KURO13]。正是这个交换结构把分组从一个输入端口 转移到某个合适的输出端口。实现这样的交换有多种方法，图4-45 给出了三种常用的交 换方法。这三种方法都是将输入端口 I收到的分组转发到输出端口 Oz。下面简单介绍它 们的特点。 存储器 （a）通过存储器 -0-0-0 总线 （b）通过总线 互连网络 （c）通过互连网络 图4-45 三种常用的交换方法 最早使用的路由器就是利用普通的计算机，用计算机的 CPU 作为路由器的路由选择处 理机。路由器的输入和输出端口的功能和传统的操作系统中的I/O设备一样。当路由器的某 个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复 制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适 的输出端口的缓存中。若存储器的带宽（读或写）为每秒M个分组，那么路由器的交换速 率（即分组从输入端口传送到输出端口的速率）一定小于M/2。这是因为存储器对分组的读 和写需要花费的时间是同一个数量级。 许多现代的路由器也通过存储器进行交换，图4-45（a）的示意图表示分组通过存储器进 行交换。与早期的路由器的区别就是，目的地址的查找和分组在存储器中的缓存都是在输入 端口中进行的。Cisco 公司的 Catalyst 8500 系列交换机（有的公司把路由器也称为交换机） 和 Bay Network 公司的 Accelar 1200系列路由器就采用了共享存储器的方法。 图4-45（b）是通过总线进行交换的示意图。采用这种方式时，数据报从输入端口通过共 享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。但是，由于总线是 共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线 忙（因为总线正在传送另一个分组），则被阻塞而不能通过交换结构，并在输入端口排队等 待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的 限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品 都采用这种通过总线的交换方式。例如，Cisco 公司的 Catalyst 1900系列交换机就使用了带 宽达到 1 Gbit/s 的总线（叫做Packet Exchange Bus）。 图4-45（c）画的是通过纵横交换结构（crossbar switch fabric）进行交换。这种交换机构常称 为互连网络（interconnection network），它有 2N 条总线，可以使 N个输入端口和 N 个输出端 口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收 到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口 的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个 输出端口。但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到 达的分组就被阻塞，必须在输入端口排队。采用这种交换方式的路由器例子是 Cisco 公司的 12000系列交换路由器，它使用的互连网络的带宽达60Gbit/s。</p> <h2 id="六ipv6">六、IPv6</h2> <p>IP 是互联网的核心协议。现在使用的IP（即IPv4）是在20世纪70年代末期设计的。 互联网经过几十年的飞速发展，到2011年2月，IPv4的地址已经耗尽，ISP已经不能再申 请到新的IP 地址块了。我国在2014年至2015年也逐步停止了向新用户和应用分配IPv4地 址，同时全面开始商用部署 IPv6。 解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的IP，即 IPv6。到目 前为止，IPv6 还只是草案标准阶段[RFC2460，4862，4443]。有关向IPv6 转换的进展情况见 有关网站[W-NGTRANS]。 4。6。1 IPv6 的基本首部 IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组，而不是IPv4 的数据 报。为方便起见，本书仍采用数据报这一名词（[COME06]和[TANE11]也是这样做的）。 IPv6 所引进的主要变化如下： （1）更大的地址空间。IPv6 把地址从IPv4 的32 位增大到4倍，即增大到128位，使地 址空间增大了 26倍。这样大的地址空间在可预见的将来是不会用完的。 （2） 扩展的地址层次结构。IPv6 由于地址空间很大，因此可以划分为更多的层次。 （3） 灵活的首部格式。IPv6 数据报的首部和IPv4 的并不兼容。IPv6 定义了许多可选的 扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路 由器对扩展首部不进行处理（除逐跳扩展首部外）。 （4） 改进的选项。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选 项。但 IPv6 的首部长度是固定的，其选项放在有效载荷中。我们知道，IPv4 所规定的选项 是固定不变的，其选项放在首部的可变部分。 （5） 允许协议继续扩充。这一点很重要，因为技术总是在不断地发展（如网络硬件的更 新）而新的应用也还会出现。但我们知道，IPv4 的功能是固定不变的。 （6） 支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。 （7）支持资源的预分配。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。 （8） IPv6 首部改为8字节对齐（即首部长度必须是8字节的整数倍）。原来的IPv4 首部 是4字节对齐。 IPv6 数据报由两大部分组成，即基本首部（base header）和后面的有效载荷（payload）。有 效载荷也称为净负荷。有效载荷允许有零个或多个扩展首部（extension header），再后面是数 据部分（图4-46）。但请注意， 所有的扩展首部并不属于IPv6 数据报的首部。 IPv6 数据报 发送在前 基本首部 有 效 载 荷 40字节 不超过65535字节 扩展 首部1 扩展 首部N 数 据部 分 图4-46 具有多个可选扩展首部的IPv6数据报的一般形式 与 IPv4 相比，IPv6对首部中的某些字段进行了如下的更改： • 取消了首部长度字段，因为它的首部长度是固定的（40字节）。 取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。 • 取消了总长度字段，改用有效载荷长度字段。 • 取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。 • 把 TTL 字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致）。 取消了协议字段，改用下一个首部字段。 取消了检验和字段，这样就加快了路由器处理数据报的速度。我们知道，在数据链 路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的 用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确 传送到目的进程为止。因此在网络层的差错检测可以精简掉。 • 取消了选项字段，而用扩展首部来实现选项功能。 由于把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有8个（虽然首 部长度增大了一倍）。 下面解释 IPv6 基本首部中各字段的作用（参见图4-47）。 IPv6的 位0 4 12 16 24 31 版本 通信量类 流标号 有效载荷长度 下一个首部 跳数限制 基本首部 （40B） IPv6的 有效载荷 （至64KB） 源地址 （128位） 目的地址 （128位） 有效载荷（扩展首部/数据） 图4-47 40字节长的IPv6基本首部 （1） 版本（version） 占4位。它指明了协议的版本，对IPv6 该字段是6。 （2） 通信量类（traffic class） 占8位。这是为了区分不同的IPv6 数据报的类别或优先 级。目前正在进行不同的通信量类性能的实验。 （3） 流标号（flow label） 占 20 位。IPv6的一个新的机制是支持资源预分配，并且允 许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流（flow）的抽象概念。所 谓“流”就是互联网络上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音 频或视频传输），而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属 于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别 有用。对于传统的电子邮件或非实时数据，流标号则没有用处，把它置为0即可。关于流标 号可参考[RFC 6437]。 （4）有效载荷长度（payload length） 占 16 位。它指明IPv6数据报除基本首部以外的字 节数（所有扩展首部都算在有效载荷之内）。这个字段的最大值是64KB（65535字节）。 （5） 下一个首部（next header） 占8位。它相当于IPv4 的协议字段或可选字段。 • 当IPv6 数据报没有扩展首部时，下一个首部字段的作用和IPv4 的协议字段一样， 它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议（例如：6 或17分别表示应交付运输层TCP或UDP）。 当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。 占8位。用来防止数据报在网络中无限期地存在。源点在每 （6） 跳数限制（hop limit） 个数据报发出时即设定某个跳数限制（最大为 255 跳）。每个路由器在转发数据报时，要先 把跳数限制字段中的值减1。当跳数限制的值为零时，就要把这个数据报丢弃。 （7） 源地址 （8） 目的地址 占 128 位。是数据报的发送端的 IP 地址。 占 128 位。是数据报的接收端的 IP 地址。 下面我们介绍一下 IPv6 的扩展首部。 大家知道，IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上 的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。然 而实际上很多的选项在途中的路由器上是不需要检查的（因为不需要使用这些选项的信 息）。IPv6 把原来IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端 的源点和终点的主机来处理，而数据报途中经过的路由器都不处理这些扩展首部（只有一个 首部例外，即逐跳选项扩展首部），这样就大大提高了路由器的处理效率。 在 RFC 2460 中定义了以下六种扩展首部：（1）逐跳选项；（2） 路由选择；（3）分片；（4） 鉴别；（5） 封装安全有效载荷；（6） 目的站选项。 每一个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的第一 个字段都是 8 位的“下一个首部”字段。此字段的值指出了在该扩展首部后面的字段是什 么。当使用多个扩展首部时，应按以上的先后顺序出现。高层首部总是放在最后面。 4。6。2 IPv6 的地址 一般来讲，一个IPv6 数据报的目的地址可以是以下三种基本类型地址之一： （1） 单播（unicast） 单播就是传统的点对点通信。 （2） 多播（multicast） 多播是一点对多点的通信，数据报发送到一组计算机中的每一 个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。 （3） 任播（anycast） 这是 IPv6 增加的一种类型。任播的终点是一组计算机，但数据报 只交付其中的一个，通常是距离最近的一个。 IPv6 把实现 IPv6 的主机和路由器均称为结点。由于一个结点可能会使用多条链路与其 他的一些结点相连，因此一个结点可能有多个与链路相连的接口。这样，IPv6 给结点的每 一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当 到达该结点的目的地址。 在 IPv6 中，每个地址占128位，地址空间大于3。4x108。如果整个地球表面（包括陆 地和水面）都覆盖着计算机，那么IPv6 允许每平方米拥有7x103 个IP地址。如果地址分配 速率是每微秒分配100万个地址，则需要 101°年的时间才能将所有可能的地址分配完毕。 可见在想象到的将来，IPv6的地址空间是不可能用完的。 巨大的地址范围还必须使维护互联网的人易于阅读和操纵这些地址。IPv4 所用的点分 十进制记法现在也不够方便了。例如，一个用点分十进制记法的128位的地址为： 104。230。140。100。255。255。255。255。0。0。17。128。150。10。255。255 为了使地址再稍简洁些，IPv6使用冒号十六进制记法（colon hexadecimal notation，简写 为 colon hex），它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如，如果前 面所给的点分十进制数记法的值改为冒号十六进制记法，就变成了： 68E6：8C64：FFFF：FFFF：0：1180：960A： FFFF 在十六进制记法中，允许把数字前面的0省略。上面就把 0000 中的前三个0省略了。 冒号十六进制记法还包含两个技术使它尤其有用。首先，冒号十六进制记法可以允许 零压缩（zero compression），即一连串连续的零可以为一对冒号所取代，例如： 可压缩为： FF05：0：0：0：0：0：0：B3 FF05：：B3 为了保证零压缩有一个不含混的解释，规定在任一地址中只能使用一次零压缩。该技 术对已建议的分配策略特别有用，因为会有许多地址包含较长连续的零串。 其次，冒号十六进制记法可结合使用点分十进制记法的后缀。我们下面会看到这种结 合在 IPv4 向 IPv6的转换阶段特别有用。例如，下面的串是一个合法的冒号十六进制记法： 0：0：0：0：0：0：128。10。2。1 请注意，在这种记法中，虽然为冒号所分隔的每个值是两个字节（16位）的量，但每个点 分十进制部分的值则指明一个字节（8位）的值。再使用零压缩即可得出： ：： 128。10。2。1 下面再给出几个使用零压缩的例子。 1080：0：0：0：8：800：200C：417A 记为 FF01：0：0：0：0：0：0：101 （多播地址） 记为 0：0：0：0：0：0：0：1（环回地址） 1080：：8：800：200C：417A FF01：：101 记为 ：： 1 记为 ： ： 0：0：0：0：0：0：0：0（未指明地址） CIDR 的斜线表示法仍然可用。例如，60 位的前缀 12AB00000000CD3（十六进制表</p> <p>示的15个字符，每个字符代表4位二进制数字）可记为： 12AB 0000：0000：CD30：0000：0000：0000：0000/60 或12AB：：CD30：0：0：0：0/60 或12AB：0：0：CD30：：/60 （不能把16位地址CD30块中的最后的省略） 但不允许记为： 12AB：0：0：CD3/60 或 12AB：：CD30/60 （这是地址12AB：0：0：0：0：0：0：CD30的前60 位二进制） 或 12AB：：CD3/60 （这是地址12AB：0：0：0：0：0：0：0CD3的前60位二进制） IPv6 的地址分类见表4-10所示[RFC 4291]。 表4-10 IPv6 的地址分类 地址类型 未指明地址 环回地址 多播地址 二进制前缀 00。0 （128位），可记为：：128。 00。。。1 （128位），可记为：1/128。 11111111 （8位），可记为FF00：：/8。 本地链路单播地址 全球单播地址 1111111010 （10位），可记为FE80/10。 （除上述四种外，所有其他的二进制前缀） 对表 4-10 所列举的几种地址简单解释如下。 未指明地址 这是 16 字节的全 0 地址，可缩写为两个冒号“：：”。这个地址不能用 作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的 IP 地址。这类地址仅此一个。 环回地址 IPv6 的环回地址是0：0：0：0：0：0：0：1，可缩写为：：1。 它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。 多播地址 功能和 IPv4 的一样。这类地址占IPv6地址总数的1/256。 本地链路单播地址（Link-Local Unicast Address） 有些单位的网络使用TCP/IP 协议， 但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信， 但不能和互联网上的其他主机通信。这类地址占IPv6地址总数的 1/1024。 全球单播地址 IPv6 的这一类单播地址是使用得最多的一类。曾提出过多种方案来进 一步划分这128位的单播地址。根据2006年发布的草案标准 RFC 4291 的建议， IPv6 单播 地址的划分方法非常灵活，可以如图 4-48 所示的任何一种。这就是说，可把整个的 128 比 特都作为一个结点的地址。也可用n比特作为子网前缀，用剩下的（128-n）比特作为接口标 识符（相当于 IPv4 的主机号）。当然也可以划分为三级，用n比特作为全球路由选择前缀， 用 m 比特作为子网前缀，而用剩下的（128-n-m）比特作为接口标识符。 结点地址（128 bit） 子网前缀（nbit） 接口标识符（128-n）bit 全球路由选择前缀（nbit） 子网标识符（mbit） 接口标识符（128-n-m）bit 图4-48 IPv6的单播地址的几种划分方法</p> <p>4。6。3 从IPv4 向 IPv6 过渡 由于现在整个互联网的规模太大，因此，“规定一个日期，从这一天起所有的路由器一 律都改用IPv6”，显然是不可行的。这样，向IPv6 过渡只能采用逐步演进的办法，同时， 还必须使新安装的IPv6系统能够向后兼容。这就是说，IPv6系统必须能够接收和转发 IPv4 分组，并且能够为IPv4分组选择路由。 下面介绍两种向IPv6 过渡的策略，即使用双协议栈和使用隧道技术[RFC 2473，2529， 3056， 4038， 4213]。 1。双协议栈 双协议栈（dual stack）是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有双 协议栈：一个 IPv4 和一个IPv6。因此双协议栈主机（或路由器）既能够和IPv6的系统通 信，又能够和 IPv4 的系统通信。双协议栈的主机（或路由器）记为IPv6/IPv4，表明它同时 具有两种 IP 地址：一个IPv6地址和一个 IPv4 地址。 双协议栈主机在和 IPv6 主机通信时采用IPv6 地址，而和 IPv4 主机通信时则采用IPv4 地址。但双协议栈主机怎样知道目的主机是采用哪一种地址呢？它是使用域名系统 DNS 来 查询的。若 DNS 返回的是IPv4地址，双协议栈的源主机就使用 IPv4 地址。但当 DNS 返回 的是 IPv6 地址，源主机就使用 IPv6 地址。 图 4-49 所示的情况是源主机A 和目的主机 F都使用IPv6，所以A向F发送 IPv6 数据 报，路径是 A→B→C→D→E→F。中间 B 到 E 这段路径是IPv4 网络，路由器 B 不能向 C 转发 IPv6 数据报，因为C只使用IPv4 协议。B 是IPv6/IPv4 路由器，它把IPv6 数据报首部 转换为IPv4 数据报首部后发送给CC再转发到D。当D转发到 IPv4 网络的出口路由器E 时（E 也是 IPv6/IPv4 路由器），再恢复成原来的IPv6 数据报。需要注意的是：IPv6 首部中 的某些字段却无法恢复。例如，原来 IPv6 首部中的流标号 X在最后恢复出的IPv6 数据报中 只能变为空缺。这种信息的损失是使用首部转换方法所不可避免的。 IPv6 A 双协议栈 IPv6/IPv4 B IPv4 网络 双协议栈 IPv6/IPv4 D E IPv6 F 流标号：X 源地址：A 目的地址：F 源地址：A 目的地址：F 源地址：A 目的地址：F 流标号：无 源地址：A 目的地址：F 数据部分 数据部分 数据部分 数据部分 IPv4 数据报 IPv4 数据报 IPv6 数据报 IPv6 数据报 图4-49 使用双协议栈进行从IPv4 到IPv6的过渡 2。隧道技术 向 IPv6 过渡的另一种方法是隧道技术（tunneling）。图 4-50 给出了隧道技术的工作原 理。这种方法的要点就是在IPv6 数据报要进入IPv4 网络时，把IPv6数据报封装成为IPv4 数据报。现在整个的IPv6数据报变成了IPv4 数据报的数据部分。这样的IPv4 数据报从路 由器 B 经过路由器C和D，传送到E，而原来的IPv6数据报就好像在IPv4 网络的隧道中传 输，什么都没有变化。当IPv4数据报离开IPv4 网络中的隧道时，再把数据部分（即原来的 IPv6 数据报）交给主机的IPv6 协议栈。图中的一条粗线表示在IPv4 网络中好像有一个从B 到E的“IPv6隧道”，路由器B是隧道的入口而E是出口。请注意，在隧道中传送的数据 报的源地址是B而目的地址是E。 要使双协议栈的主机知道IPv4 数据报里面封装的数据是一个IPv6 数据报，就必须把 IPv4 首部的协议字段的值设置为4141表示数据报的数据部分是IPv6数据报）。 双协议栈 IPv4 网络 双协议栈 IPv6 IPv6/IPv4 IPv6/IPv4 IPv6 B A IPv6 隧道 。IPv6 隧道 D IPv6 隧道 E F 流标号：X 源地址：A 目的地址：F 源地址：B 源地址：B 目的地址：E 目的地址：E 流标号：X 源地址：A 目的地址：F IPv6 IPv6 数据报 数据报 数据部分 IPv4 数据报 IPv4 数据报 数据部分 IPv4 网络 IPv6 数据报 IPv6 数据报 图4-50 使用隧道技术进行从IPv4 到IPv6的过渡 4。6。4 ICMPv6 和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数 据报。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6，它比 ICMPv4 要复杂得多。地址解析协议 ARP 和网际组管理协议 IGMP 的功能都已被合并到 ICMPv6 中（图4-51）。 ICMP IGMP IPv4 ARP 版本4中的网络层 ICMPv6 IPv6 版本6中的网络层 图4-51 新旧版本中的网络层的比较 ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播 通信。ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类 时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为ICMPv6 报 文，而把另一些报文定义为邻站发现 ND （Neighbor-Discovery）报文或多播听众交付 MLD （Multicast Listener Delivery）报文。其实所有这些报文都应当是ICMPv6 报文，只是功能和作 用不同而已。因此我们把这些报文都列入ICMPv6 的不同类别。使用这种分类方法的原因是 所有这些报文都具有相同的格式，并且所有报文类型都由 ICMPv6 协议处理。其实，像 ND</p> <p>和 MLD 这样的协议都是运行在 ICMPv6 协议之下的。基于这样的考虑，可把ICMPv6 报文 分类如图4-52 所示。请注意，邻站发现报文和组成员关系报文分别是在ND 协议和 MLD 协 议的控制下进行发送和接收的。 ICMPv6 报文 差错报文 信息报文 邻站发现报文 ND triX 组成员关系报文 MLD 协议 图4-52 ICMPv6 报文的分类 关于 ICMPv6 的进一步讨论可参阅[FORO10]，这里从略。</p> <h2 id="七ip-多播">七、IP 多播</h2> <p>4。7。1 IP 多播的基本概念 1988年 Steve Deering 首次在其博士学位论文中提出 IP 多播的概念。1992年3月IETF 在互联网范围首次试验 IETF 会议声音的多播，当时有 20 个网点可同时听到会议的声音。IP 多播是需要在互联网上增加更多的智能才能提供的一种服务。现在 IP 多播（multicast，以 前曾译为组播）已成为互联网的一个热门课题。这是由于有许多的应用需要由一个源点发送 到许多个终点，即一对多的通信。例如，实时信息的交付（如新闻、股市行情等），软件更 新，交互式会议等。随着互联网的用户数目的急剧增加，以及多媒体通信的开展，有更多的 业务需要多播来支持。关于IP多播可参考[W-MCAST]。 与单播相比，在一对多的通信中，多播可大大节约网络资源。图 4-53（a）是视频服务器 用单播方式向 90 台主机传送同样的视频节目。为此，需要发送 90 个单播，即同一个视频分 组要发送 90 个副本。图4-53（b）是视频服务器用多播方式向属于同一个多播组的 90 个成员 传送节目。这时，视频服务器只需把视频分组当作多播数据报来发送，并且只需发送一次。 路由器 Rı 在转发分组时，需要把收到的分组复制成3个副本，分别向 R2、R， 和 R&amp; 各转发1 个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此不需要复制分组， 在局域网上的多播组成员都能收到这个视频分组。 当多播组的主机数很大时（如成千上万个），采用多播方式就可明显地减轻网络中各种 资源的消耗。在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多 播数据报的软件。能够运行多播协议的路由器称为多播路由器（multicast router）。多播路由器 当然也可以转发普通的单播IP数据报。 为了适应交互式音频和视频信息的多播，从1992 年起，在互联网上开始试验虚拟的多 播主干网 MBONE （Multicast Backbone On the InterNEt）。 MBONE 可把分组传播给地点分散 但属于一个组的许多台主机。现在多播主干网已经有了相当大的规模。 在互联网上进行多播就叫做IP 多播。IP多播所传送的分组需要使用多播 IP 地址。 我们知道，在互联网中每一台主机必须有一个全球唯一的IP地址。如果某台主机现在 想接收某个特定多播组的分组，那么怎样才能使这个多播数据报传送到这台主机？</p> <p>视频服务器M 视频服务器 M 发送1次多播 发送90次单播 1个 90 个 R₁ 复制 R₁ 30个 30个 30个 R2 R3 R₁ R2 R3 Rai 个 30个 30个 30个 多播 多播 ♡ 多播 共有90个主机接收视频节目 （a）单播 多播组成员共有90个 （b） 多播 图4-53 单播与多播的比较 显然，这个多播数据报的目的地址一定不能写入这台主机的IP地址。这是因为在同一 时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入这样多的 主机的IP 地址。在多播数据报的目的地址写入的是多播组的标识符，然后设法让加入到这 个多播组的主机的IP地址与多播组的标识符关联起来。 其实多播组的标识符就是IP地址中的D类地址。D类IP地址的前四位是1110，因此 D 类地址范围是224。0。0。0 到239。255。255。255。我们就用每一个D类地址标志一个多播组。 这样，D 类地址共可标志 228个多播组，也就是说，在同一时间可以允许有超过2。6亿的多 播组在互联网上运行。多数据报也是“尽最大努力交付”，不保证一定能够交付多播组内 的所有成员。因此，多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的 地址，并且首部中的协议字段值是2，表明使用网际组管理协议 IGMP。 显然，多播地址只能用于目的地址，而不能用于源地址。此外，对多播数据报不产生 ICMP 差错报文。因此，若在PING命令后面键入多播地址，将永远不会收到响应。 IP 多播可以分为两种。一种是只在本局域网上进行硬件多播，另一种则是在互联网的 范围进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入 到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播 交付多播组的所有成员（如图4-53（b）所示）。下面就先讨论这种硬件多播。 4。7。2 在局域网上进行硬件多播 互联网号码指派管理局IANA 拥有的以太网地址块的高24位为00-00-5E，因此 TCP/IP 协议使用的以太网多播地址块的范围是从 00-00-5E-00-00-00 到 00-00-5E-FF-FF-FF。在第3 章 3。4。3 节已讲过，以太网硬件地址字段中的第1字节的最低位为1时即为多播地址，这种 多播地址数占IANA 分配到的地址数的一半。因此IANA 拥有的以太网多播地址的范围是从 01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF。不难看出，在每一个地址中，只有23 位可用作多 播。这只能和D 类IP地址中的23位有一一对应的关系。D类IP地址可供分配的有 28 位， 可见在这 28 位中的前 5 位不能用来构成以太网硬件地址（图4-54）。例如，IP 多播地址 224。128。64。32（即E0-80-40-20）和另一个IP多播地址 224。0。64。32（即E0-00-40-20）转换成 以太网的硬件多播地址都是 01-00-5E-00-40-20。由于多播 IP 地址与以太网硬件地址的映射 关系不是唯一的，因此收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本 主机要接收的数据报丢弃。 ·这5位不使用 0 8 16 24 31 D 类 1110 IP 地址 0 1 0 0 5 E 00000001 00000000 010111100 表示多播 最低23位来自D类IP地址 48位以太网地址 图4-54 D类IP地址与以太网多播地址的映射关系 下面就讨论进行IP多播所需要的协议。 4。7。3 网际组管理协议IGMP 和多播路由选择协议 1。 IP多需要两种协议 图4-55是在互联网上传送多播数据报的例子。图中标有IP地址的四台主机都参加了一 个多播组，其组地址是226。15。37。123。显然，多播数据报应当传送到路由器Rı，R和R3， 而不应当传送到路由器R4，因为与R4连接的局域网上现在没有这个多播组的成员。但这些 路由器又怎样知道多播组的成员信息呢？这就要利用一个协议，叫做网际组管理协议 IGMP （Internet Group Management Protocol）。 135。27。74。52 参加多播组 226。15。37。123 128。56。24。34 未参加 多播组 参加多播组 226。15。37。123 R₁ IGMP 130。12。14。56 参加多播组 IGMP 226。15。37。123 IGMP R2 多播组 Ra 226。15。37。123 130。12。14。43 IGMP 参加多播组 226。15。37。123 未参加 多播组 Ral 未参加 未参加 多播组 多播组 图 4-55 IGMP 使多播路由器知道多播组成员信息 图 4-55 强调了 IGMP 的本地使用范围。请注意，IGMP 并非在互联网范围内对所有多 播组成员进行管理的协议。IGMP 不知道IP多播组包含的成员数，也不知道这些成员都分 布在哪些网络上，等等。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上 是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。 显然，仅有 IGMP 协议是不能完成多任务的。连接在局域网上的多播路由器还必须 和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成 员。这就需要使用多播路由选择协议。</p> <p>然而多播路由选择协议要比单播路由选择协议复杂得多。我们可以通过一个简单的例 子来说明（图4-56）。 N 多播组① R N， G F B E ˙多播组② 图4-56 用来说明多播路由选择的例子 我们假定图 4-56中有两个多播组。多播组①的成员有主机 A，B和C，而多播组②的 成员有主机 D，E和F。这些主机分布在三个网络上（N1，N2和N3）。 路由器 R 不应当向网络N，转发多播组①的分组，因为网络N，上没有多播组①的成 员。但是每一台主机可以随时加入或离开一个多播组。例如，如果主机 G 现在加入了多播 组①，那么从这时起，路由器 R 就必须也向网络 N； 转发多播组①的分组。这就是说，多播 转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由 选择通常是在网络拓扑发生变化时才需要更新路由。 再看一种情况。主机 E 和 F 都是多播组②的成员。当 E 向 F 发送多播数据报时，路由 器 R 把这个多播数据报转发到网络 N3。但当 F E 发送多播数据报时，路由器R则把多播 数据报转发到网络 Nz。如果路由器 R 收到来自主机A的多播数据报（A不是多播组②的成 员，但也可向多播组发送多播数据报），那么路由器R 就应当把多播数据报转发到 N2 和 N3。由此可见，多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地 址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。 还有一种情况。主机 G 没有参加任何多播组，但 G 却可向任何多播组发送多播数据 报。例如，G 可向多播组①或②发送多播数据报。主机 G 所在的局域网上可以没有任何多 播组的成员。显然，多播数据报所经过的许多网络，也不一定非要有多播组成员。总之，多 播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。 正因为如此，IP多播就成为比较复杂的问题。下面介绍这两种协议的要点。 2。 网际组管理协议 IGMP IGMP 已有了三个版本。1989年公布的RFC1112（IGMPv1）早已成为了互联网的标准 协议。2002年10月公布的建议标准IGMPv3是最新的[RFC 3376]。 和网际控制报文协议 ICMP 相似，IGMP 使用IP数据报传递其报文（即IGMP 报文加 上 IP 首部构成IP数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独 的协议，而是属于整个网际协议IP的一个组成部分。 从概念上讲，IGMP 的工作可分为两个阶段。 第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到IGMP报文后，还要利用 多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。 第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主 机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路</p> <p>由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路 由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给 其他的多播路由器。 IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些 具体措施如下： （1） 在主机和多播路由器之间的所有通信都是使用IP多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加IP多播的主 机不会收到 IGMP 报文。 （2） 多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报 文，而不需要对每一个组发送一个询问报文（虽然也允许对一个特定组发送询问报文）。默 认的询问速率是每125 秒发送一次（通信量并不太大）。 （3）当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个 来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。 （4） 在 IGMP 的询问报文中有一个数值，它指明一个最长响应时间（默认值为 10 秒）。当收到询问时，主机在0到之间随机选择发送响应所需经过的时延。因此，若一台 主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的 响应最先发送。 （5） 同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自 己就可以不再发送响应了。这样就抑制了不必要的通信量。 多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据 报是使用硬件多播。多播路由器只需要知道网络上是否至少还有一台主机是本组成员即可。 实际上，对询问报文每一个组只需有一台主机发送响应。 如果一台主机上有多个进程都加入了某个多播组，那么这台主机对发给这个多播组的 每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。 最后我们还要强调指出，多播数据报的发送者和接收者都不知道（也无法找出）一个 多播组的成员有多少，以及这些成员是哪些主机。互联网中的路由器和主机都不知道哪个应 用进程将要向哪个多播组发送多播数据报，因为任何应用进程都可以在任何时候向任何一个 多播组发送多播数据报，而这个应用进程并不需要加入这个多播组。 IGMP 的报文格式可参阅有关文档[RFC 3376]，这里从略。 3。 多播路由选择协议 虽然在 TCP/IP 中IP多播协议已成为建议标准，但多播路由选择协议（用来在多播路由 器之间传播路由信息）则尚未标准化。 在多播过程中一个多播组中的成员是动态变化的。例如在收听网上某个广播节目时， 随时会有主机加入或离开这个多播组。多播路由选择实际上就是要找出以源主机为根节点的 多播转发树。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据 报，但在多播转发树上的路由器不会收到重复的多播数据报（即多播数据报不应在互联网中 兜圈子）。不难看出，对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的 源点也会有不同的多播转发树。 已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：</p> <p>（1）洪泛与剪除。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相 邻接的。一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈 子，采用了叫做反向路径广播 RPB （Reverse Path Broadcasting）的策略。RPB 的要点是：每 一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进 行这种检查很容易，只要从本路由器寻找到源点的最短路径上（之所以叫做反向路径，因为 在计算最短路径时是把源点当作终点）的第一个路由器是否就是刚才把多播数据报送来的路 由器。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就 丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上（也就是说， 存在几条同样长度的最短路径），那么只能选择一条最短路径，选择的准则就是看这几条最 短路径中的相邻路由器的IP地址最小。图4-57的例子说明了这一概念。 R₂ 源点 转发多播数据报 X 收到后即丢弃 Rs 剪除没有 R4 组成员的树枝 图4-57 反向路径广播RPB 和剪除 为简单起见，在图4-57中的网络用路由器之间的链路来表示。我们假定各路由器之间 的距离都是 1。路由器 Rı 收到源点发来的多播数据报后，向R 和R] 转发。R， 发现 R， 就在 自己到源点的最短路径上，因此向 R， 和R4 转发收到的数据报。R， 发现 R， 不在自己到源点 的最短路径上，因此丢弃 R2 发来的数据报。其他路由器也这样转发。R， 到源点有两条最短 路径：R┐→R4→R2→Rı →源点；R→ R5 → R3 → R｣ → 源点。我们再假定 R4 的IP地址比 Rs 的 IP 地址小，所以我们只使用前一条最短路径。因此R， 只转发 Ra传过来的数据报，而丢弃 Rs 传过来的数据报。最后就得出了用来转发多播数据报的多播转发树（图中用粗线表示）， 以后就按这个多播转发树来转发多播数据报。这样就避免了多播数据报兜圈子，同时每一个 路由器也不会接收重复的多播数据报。 如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播 组的成员，就应把它和下游的树枝一起剪除。例如，在图 4-57中虚线椭圆表示剪除的部 分。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。 （2） 隧道技术（tunneling）。隧道技术适用于多播组的位置在地理上很分散的情况。例如 在图 4-58 中，网1和网2都支持多播。现在网1中的主机向网2中的一些主机进行多播。 但路由器 Rı 和 R2 之间的网络并不支持多播，因而R 和R，不能按多播地址转发数据报。为 此，路由器 Rı 就对多数据报进行再次封装，即再加上普通数据报首部，使之成为向单一 目的站发送的单播（unicast）数据报，然后通过“隧道”（tunnel）从R，发送到 R2。</p> <p>网1和网2中 网1 （支持多播） 网 2 的多播数据报 （支持多播） 首部 数据 不支持多播 的网络 R2 首部 IP数据报的数据 隧道 隧道通行的 单播IP数据报 图4-58 隧道技术在多播中的应用 单播数据报到达路由器R后，再由路由器R剥去其首部，使它又恢复成原来的多播数 据报，继续向多个目的站转发。这一点和英吉利海峡隧道运送汽车的情况相似。英吉利海峡 隧道不允许汽车在隧道中行驶。但是，可以把汽车放置在隧道中行驶的电气火车上来通过隧 道。过了隧道后，汽车又可以继续在公路上行驶。这种使用隧道技术传送数据报又叫做IP 中的 IP （IP-in-IP）。 （3）基于核心的发现技术。这种方法对于多播组的大小在较大范围内变化时都适合。这 种方法是对每一个多播组 G 指定一个核心（core）路由器，给出它的IP 单播地址。核心路由器 按照前面讲过的方法创建出对应于多播组G 的转发树。如果有一个路由器，向这个核心路 由器发送数据报，那么它在途中经过的每一个路由器都要检查其内容。当数据报到达参加了 多播组 G 的路由器 Rą 时，R， 就处理这个数据报。如果 Rı 发出的是一个多播数据报，其目 的地址是 G 的组地址，R，就向多播组G 的成员转发这个多播数据报。如果R 发出的数据 报是一个请求加入多播组 G 的数据报，R，就把这个信息加到它的路由中，并用隧道技术向 Rı转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多 了，扩大了多播转发树的覆盖范围。 目前还没有在整个互联网范围使用的多播路由选择协议。下面是一些建议使用的多播 路由选择协议。 距离向量多播路由选择协议 DVMRP （Distance Vector Multicast Routing Protocol）是在互 联网上使用的第一个多播路由选择协议[RFC 1075]。由于在 UNIX 系统中实现 RIP 的程序叫 做 routed，所以在 routed 的前面加表示多播的字母m，叫做mrouted，它使用 DVMRP 在路 由器之间传播路由信息。 基于核心的转发树 CBT （Core Based Tree） [RFC 2189，2201]。这个协议使用核心路由器 作为转发树的根节点。一个大的自治系统 AS 可划分为几个区域，每一个区域选择一个核心 路由器（也叫做中心路由器 center router，或汇聚点路由器 rendezvous router）。 开放最短通路优先的多播扩展 MOSPF （Multicast extensions to OSPF） [RFC 1585]。这个 协议是单播路由选择协议 OSPF 的扩充，使用于一个机构内。MOSPF 使用多播链路状态路 由选择创建出基于源点的多播转发树。 协议无关多播-稀疏方式 PIM-SM （Protocol Independent Multicast-Sparse Mode） [RFC 4601]。这个协议使用和 CBT 同样的方法构成多播转发树。采用“协议无关”这个名词是強 调：虽然在建立多播转发树时是使用单播数据报来和远程路由器联系的，但这并不要求使用 特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。 协议无关多播-密集方式 PIM-DM （Protocol Independent Multicast-Dense Mode） [RFC 3973]。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。 PIM-DM 不使用核心路由器，而是使用洪泛方式转发数据报。</p> <h2 id="八虚拟专用网vpn-和网络地址转换-nat">八、虚拟专用网VPN 和网络地址转换 NAT</h2> <p>4。8。1 虚拟专用网 VPN 由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机 数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。 实际上，在许多情况下，很多主机主要还是和本机构内的其他主机进行通信（例如，在大型 商场或宾馆中，有很多用于营业和管理的计算机。显然这些计算机并不都需要和互联网相 连）。假定在一个机构内部的计算机通信也是采用TCP/IP 协议，那么从原则上讲，对于这些 仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。这就是说，让这些计算机 使用仅在本机构有效的IP地址（这种地址称为本地地址），而不需要向互联网的管理机构申 请全球唯一的 IP 地址（这种地址称为全球地址）。这样就可以大大节约宝贵的全球IP 地址 资源。 但是，如果任意选择一些 IP 地址作为本机构内部使用的本地地址，那么在某种情况下 可能会引起一些麻烦。例如，有时机构内部的某台主机需要和互联网连接，那么这种仅在内 部使用的本地地址就有可能和互联网中某个IP 地址重合，这样就会出现地址的二义性问 题。 为了解决这一问题，RFC 1918 指明了一些专用地址（private address）。这些地址只能用 于一个机构的内部通信，而不能用于和互联网上的主机通信。换言之，专用地址只能用做本 地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一 律不进行转发。2013 年 4 月，RFC 6890 全面地给出了所有特殊用途的IPv4地址，但三个 专用地址块的指派并无变化，即 （1） 10。0。0。0 10。255。255。255 （或记为10。0。0。0/8，它又称为24位块） （2） 172。16。0。0 172。31。255。255 （或记为172。16。0。0/12，它又称为20位块） （3） 192。168。0。0 192。168。255。255 （或记为192。168。0。0/16，它又称为16位块） 上面的三个地址块分别相当于一个A类网络、16个连续的B类网络和256个连续的C 类网络。A 类地址本来早已用完了，而上面的地址 10。0。0。0 本来是分配给 ARPANET 的。由 于 ARPANET 已经关闭停止运行了，因此这个地址就用作专用地址。 采用这样的专用 IP 地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫 做专用网。显然，全世界可能有很多的专用互连网络具有相同的专用 IP 地址，但这并不会 引起麻烦，因为这些专用地址仅在本机构内部使用。专用 IP 地址也叫做可重用地址 （reusable address）。 有时一个很大的机构的许多部门分布的范围很广（例如，在世界各地），这些部门经常 要互相交换信息。这可以有两种方法。（1）租用电信公司的通信线路为本机构专用。这种方 法虽然简单方便，但线路的租金太高，一般难于承受。（2）利用公用的互联网作为本机构各 专用网之间的通信载体，这样的专用网又称为虚拟专用网 VPN（Virtual Private Network）。 之所以称为“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不 是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的互联</p> <p>网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。加密需要采用的协议 将在7。6。1 节讨论。“虚拟”表示“好像是”，但实际上并不是，因为现在并没有真正使用通 信专线，而 VPN只是在效果上和真正的专用网一样。一个机构要构建自己的VPN 就必须为 它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其 他场所的地址。 图 4-59 以两个场所为例说明如何使用IP隧道技术实现虚拟专用网。 假定某个机构在两个相隔较远的场所建立了专用网 A 和 B，其网络地址分别为专用地 址 10。1。0。0 和 10。2。0。0。现在这两个场所需要通过公用的互联网构成一个 VPN。 显然，每一个场所至少要有一个路由器具有合法的全球IP地址，如图4-59（a）中的路由 器 Rı 和 R2。这两个路由器和互联网的接口地址必须是合法的全球IP 地址。路由器 R」 和 R2 在专用网内部网络的接口地址则是专用网的本地地址。 加密的从X到Y的内部数据报 源地址：125。1。2。3 目的地址：194。4。5。6 外部数据报的数据部分 外部数据报 数据报首部 场所A 125。1。2。3 194。4。5。6 场所 B X 隧道 Y 10。2。0。0 10。1。0。0 10。2。0。3 10。1。0。1 互联网 （a）使用隧道技术 场所 A 虚拟专用网VPN 场所 B X Y 10。2。0。0 10。1。0。0 10。2。0。3 10。1。0。1 （b）构成虚拟专用网 图4-59 用隧道技术实现虚拟专用网 在每一个场所 A或B内部的通信量都不经过互联网。但如果场所A的主机 X 要和另一 个场所 B 的主机Y通信，那么就必须经过路由器R 和R2。主机 X 向主机 Y 发送的 IP 数据 报的源地址是 10。1。0。1，而目的地址是10。2。0。3。这个数据报先作为本机构的内部数据报从X 发送到与互联网连接的路由器Rı。路由器 R， 收到内部数据报后，发现其目的网络必须通过 互联网才能到达，就把整个的内部数据报进行加密（这样就保证了内部数据报的安全），然 后重新加上数据报的首部，封装成为在互联网上发送的外部数据报，其源地址是路由器 Rı 的全球地址 125。1。2。3，而目的地址是路由器R的全球地址 194。4。5。6。路由器，收到数据报 后将其数据部分取出进行解密，恢复出原来的内部数据报（目的地址是10。2。0。3），交付主机 Y。可见，虽然 X 向 Y 发送的数据报是通过了公用的互联网，但在效果上就好像是在本部 门的专用网上传送一样。如果主机Y要向X发送数据报，那么所进行的步骤也是类似的。 请注意，数据报从R 传送到 R， 可能要经过互联网中的很多个网络和路由器。但从逻辑</p> <p>上看，在 Rı到R，之间好像是一条直通的点对点链路，图4-59（a）中的“隧道”就是这个意 思。 如图 4-59（b）所示的、由场所 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为内联 网（intranet 或intranet VPN，即内联网VPN），表示场所A和B都属于同一个机构。 有时一个机构的 VPN 需要有某些外部机构（通常就是合作伙伴）参加进来。这样的 VPN 就称为外联网（extranet 或extranet VPN，即外联网 VPN）。 请注意，内联网和外联网都采用了互联网技术，即都是基于TCP/IP协议的。 还有一种类型的VPN，就是远程接入 VPN （remote access VPN）。我们知道，有的公司 可能并没有分布在不同场所的部门，但却有很多流动员工在外地工作。公司需要和他们保持 联系，有时还可能一起开电话会议或视频会议。远程接入 VPN 可以满足这种需求。在外地 工作的员工通过拨号接入互联网，而驻留在员工个人电脑中的 VPN 软件可以在员工的个人 电脑和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容也是保密的，员工 们感到好像就是使用公司内部的本地网络。 4。8。2网络地址转换 NAT 下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地 IP 地址 （即仅在本专用网内使用的专用地址），但现在又想和互联网上的主机通信（并不需要加 密），那么应当采取什么措施呢？ 最简单的办法就是设法再申请一些全球IP地址。但这在很多情况下是不容易做到的， 因为全球 IPv4 的地址已所剩不多了。目前使用得最多的方法是采用网络地址转换。 网络地址转换 NAT （Network Address Translation）方法是在1994年提出的。这种方法需 要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路 由器，它至少有一个有效的外部全球IP 地址。这样，所有使用本地地址的主机在和外界通 信时，都要在 NAT 路由器上将其本地地址转换成全球IP地址，才能和互联网连接。 图 4-60 给出了NAT 路由器的工作原理。在图中，专用网 192。168。0。0 内所有主机的 IP 地址都是本地 IP地址 192。168。x。x。NAT 路由器至少要有一个全球IP地址，才能和互联网相 连。图 4-60 表示出 NAT 路由器有一个全球 IP 地址 172。38。1。5（当然，NAT 路由器可以有多 个全球 IP 地址）。 全球IP地址 专用网192。168。0。0 172。38。1。5 主机B 源IP 地址 213。18。2。4 主机A 192。168。0。3 192。168。0。3 源 IP 地址 172。38。1。5 互联网 NAT 路由器 目的IP 地址 192。168。0。3 目的IP地址 172。38。1。5 图4-60 NAT路由器的工作原理 NAT 路由器收到从专用网内部的主机 A 发往互联网上主机 B 的 IP数据报：源IP地址 是 192。168。0。3，而目的 IP 地址是213。18。2。4。NAT 路由器把IP数据报的源 IP 地址</p> <p>192。168。0。3，转换为新的IP地址（即NAT 路由器的全球IP地址） 172。38。1。5，然后转发 出去。因此，主机B收到这个IP数据报时，以为A的IP地址是172。38。1。5。当B给A发 送应答时，IP数据报的目的IP地址是NAT路由器的IP地址172。38。1。5。B并不知道A的专 用地址 192。168。0。3。实际上，即使知道了，也不能使用，因为互联网上的路由器都不转发目 的地址是专用网本地IP地址的IP数据报。当NAT路由器收到互联网上的主机B发来的IP 数据报时，还要进行一次IP地址的转换。通过NAT 地址转换表，就可把IP数据报上的旧 的目的 IP 地址172。38。1。5，转换为新的目的IP地址192。168。0。3（主机A真正的本地IP地 址）。表 4-11 给出了NAT 地址转换表的举例。表中的前两行数据对应于图4-60中所举的例 子。第一列“方向”中的“出”表示离开专用网，而“入”表示进入专用网。表中后两行数 据（图4-60中没有画出对应的IP数据报）表示专用网内的另一主机192。168。0。7 向互联网发 送了IP数据报，而NAT路由器还有另外一个全球IP地址172。38。1。6。 表4-11 NAT地址转换表举例 方向 字段 旧的 IP 地址 新的 IP 地址 出 源 IP 地址 入 目的 IP 地址 192。168。0。3 172。38。1。5 172。38。1。5 192。168。0。3 出 入 源 IP 地址 目的 IP 地址 192。168。0。7 172。38。1。6 172。38。1。6 192。168。0。7 由此可见，当 NAT 路由器具有n个全球 IP 地址时，专用网内最多可以同时有n 台主机 接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的 全球IP地址。 显然，通过 NAT 路由器的通信必须由专用网内的主机发起。设想互联网上的主机要发 起通信，当 IP 数据报到达 NAT 路由器时，NAT 路由器就不知道应当把目的IP 地址转换成 专用网内的哪一个本地IP 地址。这就表明，这种专用网内部的主机不能充当服务器用，因 为互联网上的客户无法请求专用网内的服务器提供服务。 为了更加有效地利用 NAT 路由器上的全球IP 地址，现在常用的 NAT 转换表把运输层 的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的 全球 IP 地址，因而可以同时和互联网上的不同主机进行通信[COME06]。 由于运输层的端口号将在下一章 5。1。3 节讨论，因此，建议在学完运输层的有关内容 后，再学习下面的内容。从系统性考虑，把下面的这部分内容放在本章中介绍较为合适。 使用端口号的 NAT 也叫做网络地址与端口号转换 NAPT （Network Address and Port Translation），而不使用端口号的NAT 就叫做传统的NAT （traditional NAT）。但在许多文献中 并没有这样区分，而是不加区分地都使用 NAT 这个更加简洁的缩写词。表 4-12 说明了 NAPT 的地址转换机制。 表4-12 NAPT 地址转换表举例 方向 字段 出 源 IP 地址：TCP 源端口 出 源IP 地址：TCP 源端口 入 目的IP 地址：TCP 目的端口 入 目的 IP 地址：TCP 目的端口 192。168。0。4：30000 172。38。1。5：40001 172。38。1。5：40002 192。168。0。4：30000 旧的IP 地址和端口号 新的IP地址和端口号 192。168。0。3：30000 172。38。1。5：40001 172。38。1。5：40002 192。168。0。3：30000 • 188。</p> <p>从表 4-12 可以看出，在专用网内主机 192。168。0。3 向互联网发送IP数据报，其 TCP 端 口号选择为 30000。NAPT 把源IP地址和TCP端口号都进行转换（如果使用UDP，则对 UDP 的端口号进行转换。原理是一样的）。另一台主机192。168。0。4 也选择了同样的 TCP 端 口号 30000。这纯属巧合（端口号仅在本主机中才有意义）。现在 NAPT 把专用网内不同的 源 IP 地址都转换为同样的全球IP地址。但对源主机所采用的TCP端口号（不管相同或不 同），则转换为不同的新的端口号。因此，当NAPT 路由器收到从互联网发来的应答时，就 可以从 IP 数据报的数据部分找出运输层的端口号，然后根据不同的目的端口号，从NAPT 转换表中找到正确的目的主机。 应当指出，从层次的角度看，NAPT的机制有些特殊。普通路由器在转发IP数据报 时，对于源 IP地址或目的IP地址都是不改变的。但NAT 路由器在转发IP数据报时，一定 要更换其IP地址（转换源IP地址或目的IP地址）。其次，普通路由器在转发分组时，是工 作在网络层。但NAPT 路由器还要查看和转换运输层的端口号，而这本来应当属于运输层 的范畴。也正因为这样，NAPT 曾遭受了一些人的批评，认为NAPT的操作没有严格按照 次的关系。但不管怎样，NAT（包括NAPT）已成为互联网的一个重要构件。有关 NAT 的 详细讨论可参阅建议标准 RFC3022 和IETF 关于 NAT 工作组的网站[W-NAT]。</p> <h2 id="九多协议标记交换-mpls">九、多协议标记交换 MPLS</h2> <p>IETF于1997年成立了MPLS工作组，为的是开发出一种新的协议。这种新的协议就是 多协议标记交换MPLS （MultiProtocol Label Switching）。“多协议”表示在MPLS 的上层可以 采用多种协议。IETF 还综合了许多公司的类似技术，如Cisco 公司的标记交换 TAG （TAG Switching），以及Ipsilon 公司的IP交换（IP Switching）等。2001年1月MPLS终于成为互联 网的建议标准[RFC 3031，3032][W-MPLS]。 MPLS 利用面向连接技术，使每个分组携带一个叫做标记（label）的小整数（这叫做打 上标记）。当分组到达交换机（即标记交换路由器）时，交换机读取分组的标记，并用标记 值来检索分组转发表。这样就比查找路由表来转发分组要快得多。 人们经常把 MPLS与异步传递方式 ATM （Asynchronous Transfer Mode）联系起来，这仅 仅是因为它们都采用了面向连接的工作方式。以前很多人都曾认为网络的发展方向是以 ATM 为核心的宽带综合业务数字 B-ISDN。然而价格低廉得多的高速IP路由器仍然占领了 市场，最终导致 ATM 技术和 B-ISDN 未能够成为网络的发展方向。MPLS 并没有取代IP， 而是作为一种IP增强技术，被广泛地应用在互联网中。 MPLS 具有以下三个方面的特点：（1）支持面向连接的服务质量。（2） 支持流量工程， 平衡网络负载。（3）有效地支持虚拟专用网 VPN。 下面讨论 MPLS 的基本工作原理。</p> <p>4。9。1 MPLS 的工作原理 1。基本工作过程 在传统的IP网络中，分组每到达一个路由器，都必须查找路由表，并按照“最长前缀 匹配”的原则找到下一跳的IP地址（请注意，前缀的长度是不确定的。当网络很大时，查 找含有大量项目的路由表要花费很多的时间。在出现突发性的通信量时，往往还会使缓存溢 出，这就会引起分组丢失、传输时延增大和服务质量下降。 MPLS 的一个重要特点就是在 MPLS 域的入口处，给每一个IP数据报打上固定长度 “标记”，然后对打上标记的IP数据报用硬件进行转发，这就使得IP数据报转发的过程大 大地加快了。采用硬件技术对打上标记的IP数据报进行转发就称为标记交换。“交换”也 表示在转发时不再上升到第三层查找转发表，而是根据标记在第二层（链路层）用硬件进行 转发。MPLS 可使用多种链路层协议，如PPP、以太网、ATM 以及帧中继等。图4-61 是 MPLS 协议的基本原理的示意图。 MPLS 域 打上标记 B 去除标记 LDP LDP ☑ LDP 3 2 打上标记 的分组 \的分组 打上标记 2 打上标记 的分组 MPLS MPLS 入口结点 X 出口结点 ☑ 普通IP分组 打上标记的分组 普通路由器 范 标记交换路由器 LSR 图4-61 MPLS 协议的基本原理 MPLS 域（MPLS domain）是指该域中有许多彼此相邻的路由器，并且所有的路由器都是 支持 MPLS 技术的标记交换路由器 LSR （Label Switching Router）。 LSR 同时具有标记交换和 路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择 功能构造转发表。 图4-61 中给出了MPLS 的基本工作过程如下： （1） MPLS 域中的各 LSR 使用专门的标记分配协议 LDP （Label Distribution Protocol）交换 报文，并找出和特定标记相对应的路径，即标记交换路径 LSP（Label Switched Path）。例如 在图中的路径 A→B→C→D。各LSR 根据这些路径构造出转发表。这个过程和路由器构造 自己的路由表相似[RFC 3031]，限于篇幅，这里不讨论转发表构造的详细步骤。但应注意的 是，MPLS 是面向连接的，因为在标记交换路径LSP上的第一个 LSR 就根据IP数据报的初 始标记确定了整个的标记交换路径，就像一条虚连接一样。</p> <p>（2） 当一个 IP 数据报进入到MPLS 域时，MPLS 入口结点（ingress node）就给它打上标记 （后面我们就会知道，这实际上是插入一个 MPLS 首部），并按照转发表把它转发给下一个 LSR。以后的所有LSR都按照标记进行转发。 给 IP 数据报打标记的过程叫做分类（classification）。严格的第三层（网络层）分类只使用 了 IP 首部中的字段，如源IP地址和目的IP地址等。大多数运营商实现了第四层（运输层） 分类（除了要检查IP首部外，运输层还要检查TCP或UDP 首部中的协议端口号），而有些运 营商则实现了第五层（应用层）分类（更进一步地检查数据报的内部并考虑其有效载荷）。 （3）由于在全网内统一分配全局标记数值是非常困难的，因此一个标记仅仅在两个标记 交换路由器 LSR 之间才有意义。分组每经过一个 LSR，LSR 就要做两件事：一是转发，二 是更换新的标记，即把入标记更换成为出标记。这就叫做标记对换（label swapping）。做这 两件事所需的数据都已清楚地写在转发表中。例如，图 4-61 中的标记交换路由器B 从入接 口0收到一个入标记为3的IP数据报，查找了如下的转发表： 入接口 0 入标记 出接口 出标记 3 1 1 为1。 标记交换路由器B就知道应当把该IP数据报从出接口 1 转发出去，同时把标记对换 当IP数据报进入下一个LSR时，这时的入标记就是刚才得到的出标记。因此，标记交 换路由器C接着在转发该IP数据报时，又把入标记1对换为出标记2。 （4） 当 IP 数据报离开 MPLS 域时，MPLS 出口结点（egress node）就把 MPLS 的标记去 除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。 上述的这种“由入口 LSR 确定进入 MPLS 域以后的转发路径”称为显式路由选择 （explicit routing），它和互联网中通常使用的“每一个路由器逐跳进行路由选择”有着很大的 区别。 下面再讨论 MPLS 中的几个重要概念。 2。 转发等价类 FEC MPLS 有个很重要的概念就是转发等价类 FEC （Forwarding Equivalence Class）。所谓 “转发等价类”就是路由器按照同样方式对待的IP 数据报的集合。这里“按照同样方式对 待”表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级 等。FEC 的例子是： （1） 目的 IP 地址与某一个特定 IP 地址的前缀匹配的IP 数据报（这就相当于普通的 IP 路由器）； （2） 所有源地址与目的地址都相同的 IP 数据报； （3） 具有某种服务质量需求的 IP 数据报。 总之，划分 FEC 的方法不受什么限制，这都由网络管理员来控制，因此非常灵活。入 口结点并不是给每一个IP数据报指派一个不同的标记，而是将属于同样 FEC 的 IP 数据报</p> <p>都指派同样的标记。FEC 和标记是一一对应的关系。 图 4-62 给出一个把 FEC 用于负载平衡的例子。图4-62（a）的主机H 和H2分别向H，和 H4 发送大量数据。路由器A和C是数据传输必须经过的。但传统的路由选择协议只能选择 最短路径A→B→C，这就可能导致这段最短路径过载。 H B H₂ （a） 传统路由选择协议使最短路径A→B→C过载 H， H B H₁ H A H₂ Ha （b） 利用FEC使通信量较为均衡 图4-62 FEC用于负载平衡 图 4-62（b）表示在 MPLS 的情况下，入口结点 A 可设置两种 FEC：“源地址为 H 而目的 地址为 Hţ”和“源地址为 H， 而目的地址为 H4”，把前一种 FEC 的路径设置为 Hı→A→B→ C→H3，而后一种的路径设置为 H2→A→D→E→C→H4。这样可使网络的负载较为平衡。网 络管理员采用自定义的 FEC 就可以更好地管理网络的资源。这种均衡网络负载的做法也称 为流量工程 TE （Traffic Engineering）或通信量工程。 4。9。2 MPLS 首部的位置与格式 MPLS 并不要求下层的网络都使用面向连接的技术。因此一对 MPLS 路由器之间的物理 连接，既可以由一个专用电路组成，如 OC-48 线路，也可以使用像以太网这样的网络。但 是这些网络并不提供打标记的手段，而IPv4 数据报首部也没有多余的位置存放 MPLS 标 记。这就需要使用一种封装技术：在把IP数据报封装成以太网帧之前，先要插入一个 MPLS 首部。从层次的角度看，MPLS 首部就处在第二层和第三层之间（图 4-63）。在把加 上 MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为 884716，而在多播的情况下为884816。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的IP数据报。 网络层 MPLS 首部 插入 数据链路层 图4-63 MPLS 首部的位置 图4-64 给出了 MPLS 首部的格式。可见“给IP数据报打上标记”其实就是在以太网的 帧首部和 IP 数据报的首部之间插入一个4字节的 MPLS 首部。具体的标记就在“标记值” 这个字段中。</p> <p>位 20 3 1 8 标记值 试验 S 生存时间 TTL 以太网帧 帧首部MPLS 首部IP首部 IP 数据 部 分 帧尾部 IP数据报 发送在前 图4-64 MPLS 首部的格式 占 20 位。由于一个 MPLS 标记占 20位，因此从理论上讲，在设置 MPLS 首部共包括以下四个字段： （1） 标记值 MPLS 时可以使用标记的所有 20 位，因而可以同时容纳高达220个流（即1048576个流）。 但是，实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管 理和设置每条交换路径。 （2） 试验 占3位，目前保留用于试验。 （3） 栈 S 占1位，在有“标记栈”时使用。 （4） 生存时间 TTL 占8位，用来防止 MPLS 分组在MPLS 域中兜圈子。 本章的重要概念 • TCP/IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数 据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组 可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。 • IP 网是虚拟的，因为从网络层上看，IP网就是一个统一的、抽象的网络（实际上 是异构的）。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统 一的、抽象的 IP 地址处理主机之间的通信问题。 在互联网上的交付有两种：在本网络上的直接交付（不经过路由器）和到其他网络 的间接交付（经过至少一个路由器，但最后一次一定是直接交付）。 一个 IP 地址在整个互联网范围内是唯一的。分类的IP 地址包括 A 类、B 类和 C 类地址（单播地址），以及D类地址（多播地址）。E类地址未使用。 分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络 号字段最前面的类别位指明IP地址的类别。 • IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络 号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的 网络号来转发分组。 • IP 地址标志一台主机（或路由器）和一条链路的接口。多归属主机同时连接到两 个或更多的网络上。这样的主机同时具有两个或更多的IP 地址，其网络号必须是 不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两 个不同的 IP 地址。 按照互联网的观点，用转发器或网桥连接起来的若干个局域网仍为一个网络。所有 分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广 域网）都是平等的。 物理地址（即硬件地址）是数据链路层和物理层使用的地址，而 IP 地址是网络层</p> <p>和以上各层使用的地址，是一种逻辑地址（用软件实现的），在数据链路层看不见 数据报的IP 地址。 IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所 有IP数据报必须具有的（源地址、目的地址，总长度等重要字段都在固定首部 中）。一些长度可变的可选字段放在固定首部的后面。 IP 首部中的生存时间字段给出了IP数据报在互联网中所能经过的最大路由器数， 可防止IP 数据报在互联网中无限制地兜圈子。 地址解析协议 ARP 把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由 器的 IP 地址和硬件地址的映射问题。ARP 的高速缓存可以大大减少网络上的通信 量。 在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。 无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指 明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”。IP地址的分配都以CIDR 地址块为单位。 CIDR 的 32 位地址掩码（或子网掩码）由一串 1 和一串0组成，而1的个数就是 前缀的长度。只要把 IP 地址和地址掩码逐位进行“逻辑与（AND）”运算，就很 容易得出网络地址。A类地址的默认地址掩码是 255。0。0。0。B类地址的默认地址掩 码是255。255。0。0C类地址的默认地址掩码是255。255。255。0。 路由聚合（把许多前缀相同的地址用一个来代替）有利于减少路由表中的项目，减 少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 “转发”和“路由选择”有区别。“转发”是单个路由器的动作。“路由选择”是许 多路由器共同协作的过程，这些路由器相互交换信息，目的是生成路由表，再从路 由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转 发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使 用路由表这一名词。 自治系统（AS）就是在单一的技术管理下的一组路由器。一个自治系统对其他自 治系统表现出的是一个单一的和一致的路由选择策略。 路由选择协议有两大类：内部网关协议（或自治系统内部的路由选择协议），如 RIP 和 OSPF；外部网关协议（或自治系统之间的路由选择协议），如BGP-4。 RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按固定 的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自 治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器。 OSPF 是分布式的链路状态协议，适用于大型互联网。OSPF 只在链路状态发生变 化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由 器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路 的“度量”。“度量”可表示费用、距离、时延、带宽等，可统称为“代价”。所有 的路由器最终都能建立一个全网的拓扑结构图。 BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协</p> <p>议。BGP 力求寻找一条能够到达目的网络（可达）且比较好的路由（不兜圈子）， 而并非要寻找一条最佳路由。 网际控制报文协议ICMP是IP层的协议。ICMP报文作为IP数据报的数据，加上 首部后组成 IP数据报发送出去。使用ICMP并非为了实现可靠传输。ICMP 允许 主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两 种，即 ICMP差错报告报文和 ICMP 询问报文。 ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通 性。PING 使用了ICMP 回送请求与回送回答报文。 要解决 IP 地址耗尽的问题，最根本的办法就是采用具有更大地址空间的新版本的 IP 协议，即 IPv6。 IPv6 所带来的主要变化是：（1）更大的地址空间（采用128位的地址）； （2） 灵活的 首部格式；（3） 改进的选项；（4） 支持即插即用；（5）支持资源的预分配；（6） IPv6 首部改为8字节对齐。 IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有 的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。 IPv6 的地址使用冒号十六进制记法。 向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的IPv6系统能够向后兼容。 向 IPv6 过渡可以使用双协议栈或使用隧道技术。 • 与单播相比，在一对多的通信中，IP多播可大大节约网络资源。IP多播使用 D 类 IP 地址。IP 多播需要使用网际组管理协议 IGMP 和多播路由选择协议。 虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体。VPN 内 部使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球IP 地 址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送 的数据都必须加密。 使用网络地址转换NAT技术，可以在专用网络内部使用专用IP 地址，而仅在连接 到互联网的路由器使用全球IP地址。这样就大大节约了宝贵的 IP 地址。 MPLS 的特点： （1） 支持面向连接的服务质量；（2） 支持流量工程，平衡网络负 载；（3）有效地支持虚拟专用网 VPN。 MPLS 在入口结点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第 二层（链路层）用硬件进行转发（在标记交换路由器中进行标记对换），因而转发 速率大大加快。</p>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https://feng-zhang0712.github.io//blog/2024/2024-09-14-transport-layer/" rel="alternate" type="text/html" title=""/><published>2024-09-21T08:55:57+00:00</published><updated>2024-09-21T08:55:57+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/2024-09-14-transport-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/2024-09-14-transport-layer/"><![CDATA[<p>第5章 运输层 本章先概括介绍运输层协议的特点、进程之间的通信和端口等重要概念，然后讲述比 较简单的 UDP 协议。其余的篇幅都是讨论较为复杂但非常重要的 TCP 协议和可靠传输的 工作原理，包括停止等待协议和ARQ 协议。在详细讲述 TCP 报文段的首部格式之后，讨论 TCP 的三个重要问题：滑动窗口、流量控制和拥塞控制机制。最后，介绍 TCP 的连接管 理。 运输层是整个网络体系结构中的关键层次之一。一定要弄清以下一些重要概念： （1） 运输层为相互通信的应用进程提供逻辑通信。 （2） 端口和套接字的意义。 （3）无连接的 UDP 的特点。 （4） 面向连接的 TCP 的特点。 （5） 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ 协议。 （6） TCP 的滑动窗口、流量控制、拥塞控制和连接管理。 5。1 运输层协议概述 5。1。1 进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通 信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络 的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中 的路由器在转发分组时都只用到下三层的功能。 下面通过图 5-1 的示意图来说明运输层的作用。设局域网 LAN上的主机 A 和局域网 LANz 上的主机 B通过互连的广域网 WAN 进行通信。我们知道，IP协议能够把源主机 A 发 送出的分组，按照首部中的目的地址，送交到目的主机 B，那么，为什么还需要运输层呢？ 从IP层来说，通信的两端是两台主机。IP数据报的首部明确地标志了这两台主机的IP 地址。但“两台主机之间的通信”这种说法还不够清楚。这是因为，真正进行通信的实体是 在主机中的进程，是这台主机中的一个进程和另一台主机中的一个进程在交换数据（即通 信）。因此严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。IP 协议虽然 能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进 程。从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端 的通信是应用进程之间的通信。在一台主机中经常有多个应用进程同时分别和另一台主机中 的多个应用进程通信。例如，某用户在使用浏览器查找某网站的信息时，其主机的应用层运 行浏览器客户进程。如果在浏览网页的同时，还要用电子邮件给网站发送反馈意见，那么主 机的应用层就还要运行电子邮件的客户进程。在图5-1中，主机A的应用进程AP，和主机 B 的应用进程 AP通信，而与此同时，应用进程AP，也和对方的应用进程AP通信。这表明 运输层有一个很重要的功能——复用（multiplexing）和分用（demultiplexing）。这里的“复用” 是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的 首部），而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的 应用进程。图5-1中两个运输层之间有一个双向粗箭头，写明“运输层提供应用进程间的 逻辑通信”。“逻辑通信”的意思是：从应用层来看，只要把应用层报文交给下面的运输层， 运输层就可以把这报文传送到对方的运输层（哪怕双方相距很远，例如几千公里），好像这 种通信就是沿水平方向直接传送数据。但事实上这两个运输层之间并没有一条水平方向的物 理连接。数据的传送是沿着图中的虚线方向（经过多个层次）传送的。“逻辑通信”的意思 是“好像是这样通信，但事实上并非真的这样通信”。 主机A的协议栈 主机B的协议栈 应用进程 APT 应用进程。 AP， AP 5 AP， 运输层提供应用进程间的逻辑通信 4 3。 IP 层 2 1 4 3。 2 主机B 主机A 路由器1 路由器2 AP3 APL LAN， WAN LAN， APD AP， IP协议的作用范围 运输层协议的作用范围 图 5-1 运输层为相互通信的应用进程提供了逻辑通信 从这里可以看出网络层和运输层有明显的区别。网络层为主机之间提供逻辑通信，而 运输层为应用进程之间提供端到端的逻辑通信（见图 5-2）。然而正如后面还要讨论的，运 输层还具有网络层无法代替的许多其他重要功能。 运输层还要对收到的报文进行差错检测。大家应当还记得，在网络层，IP数据报首部 中的检验和字段，只检验首部是否出现差错而不检查数据部分。 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的 TCP 和 无连接的 UDP，这两种协议就是本章要讨论的主要内容。 我们还应指出，运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用 的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的</p> <p>逻辑通信信道，但这条逻辑通信信道上层的表现却因运输层使用的不同协议而有很大的差 别。当运输层采用面向连接的TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努 力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。 应用进程 应用进程 互联网 IP 协议的作用范围 （提供主机之间的逻辑通信） 运输层协议的作用范围 （提供进程之间的逻辑通信） 川 图5-2 运输层协议和网络层协议的主要区别 5。1。2 运输层的两个主要协议 TCP/IP 运输层的两个主要协议都是互联网的正式标准，即： （1）用户数据报协议 UDP （User Datagram Protocol） [RFC 768] （2）传输控制协议 TCP （Transmission Control Protocol） [RFC 793] 图 5-3 给出了这两种协议在协议栈中的位置。 应用层 UDP TCP IP 与各种网络接口 图5-3TCP/IP体系中的运输层协议 按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU （Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为TCP报文段（segment） 或UDP用户数据报。 UDP 在传送数据之前不需要先建立连接。远地主机的运输层在收到 UDP报文后，不需 要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作 方式。 TCP 则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释 放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务，因 此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协 议数据单元的首部增大很多，还要占用许多的处理机资源。 表 5-1 给出了一些应用和应用层协议主要使用的运输层协议（UDP 或 TCP）。</p> <p>表5-1 使用UDP 和TCP 协议的各种应用和应用层协议 应用 应用层协议 运输层协议 名字转换 DNS（域名系统） UDP 文件传送 TFTP（简单文件传送协议） UDP 路由选择协议 RIP（路由信息协议） UDP IP 地址配置 网络管理 DHCP（动态主机配置协议） UDP SNMP（简单网络管理协议） UDP 远程文件服务器 IP 电话 NFS（网络文件系统） 专用协议 UDP UDP 流式多媒体通信 专用协议 UDP 多播 IGMP（网际组管理协议） UDP 电子邮件 SMTP（简单邮件传送协议） TCP 远程终端接入 万维网 TELNET（远程终端协议） TCP HTTP（超文本传送协议） TCP 文件传送 FTP（文件传送协议） TCP 5。1。3 运输层的端口 前面已经提到过运输层的复用和分用功能。其实在日常生活中也有很多复用和分用的 例子。假定一个机构的所有部门向外单位发出的公文都由收发室负责寄出，这相当于各部门 都“复用”这个收发室。当收发室收到从外单位寄来的公文时，则要完成“分用”功能，即 按照信封上写明的本机构的部门地址把公文正确进行交付。 运输层的复用和分用功能也是类似的。应用层所有的应用进程都可以通过运输层再传 送到 IP 层（网络层），这就是复用。运输层从IP层收到发送给各应用进程的数据后，必须 分别交付指明的各应用进程，这就是分用。显然，给应用层的每个应用进程赋予一个非常明 确的标志是至关重要的。 我们知道，在单个计算机中的进程是用进程标识符（一个不大的整数）来标志的。但 是在互联网环境下，用计算机操作系统所指派的这种进程标识符来标志运行在应用层的各种 应用进程则是不行的。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操 作系统又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程能够互 相通信，就必须用统一的方法（而这种方法必须与特定操作系统无关）对 TCP/IP 体系的应 用进程进行标志。 但是，把一个特定机器上运行的特定进程，指明为互联网上通信的最后终点还是不可 行的。这是因为进程的创建和撤销都是动态的，通信的一方几乎无法识别对方机器上的进 程。另外，我们往往需要利用目的主机提供的功能来识别终点，而不需要知道具体实现这个 功能的进程是哪一个（例如，要和互联网上的某个邮件服务器联系，并不一定要知道这个服 务器功能是由目的主机上的哪个进程实现的）。 解决这个问题的方法就是在运输层使用协议端口号（protocol port number），或通常简称 为端口（port）。这就是说，虽然通信的终点是应用进程，但只要把所传送的报文交到目的主 机的某个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 或 UDP 来完成。 请注意，这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬</p> <p>件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层 的各种协议进程与运输实体进行层间交互的一种地址。不同的系统具体实现端口的方法可以 是不同的（取决于系统使用的操作系统）。 在后面将讲到的 UDP 和TCP 的首部格式中，我们将会看到（图5-5和图5-14） 它们都 有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用进程。 TCP/IP 的运输层用一个16位端口号来标志一个端口。但请注意，端口号只具有本地意 义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网 不同计算机中，相同的端口号是没有关联的。16 位的端口号可允许有 65535 个不同的端口 号，这个数目对一个计算机来说是足够用的。 由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的IP地址（为了找到 对方的计算机），而且要知道对方的端口号（为了找到对方计算机中的应用进程）。这和我 们寄信的过程类似。当我们要给某人写信时，就必须在信封上写明他的通信地址（这是为 了找到他的住所，相当于IP 地址），并且还要写上收件人的姓名（这是因为在同一住所中可 能有好几个人，这相当于端口号）。在信封上还写明自己的地址。当收信人回信时，很容易 在信封上找到发信人的地址。互联网上的计算机通信是采用客户-服务器方式。客户在发起 通信请求时，必须先知道对方服务器的IP 地址和端口号。因此运输层的端口号分为下面的 两大类。 （1） 服务器端使用的端口号 这里又分为两类，最重要的一类叫做熟知端口号（well- known port number）或系统端口号，数值为0~1023。这些数值可在网址 www。iana。org 查到。 IANA 把这些端口号指派给了 TCP/IP 最重要的一些应用程序，让所有的用户都知道。当一 种新的应用程序出现后，IANA 必须为它指派一个熟知端口，否则互联网上的其他应用进程 就无法和它进行通信。表5-2给出了一些常用的熟知端口号。 表5-2常用的熟知端口号 应用程序 FTP 熟知端口号 21 TELNET 23 SMTP 25 DNS TFTP HTTP SNMP SNMP （trap） HTTPS 53 69 80 161 162 443 另一类叫做登记端口号，数值为1024~49151。这类端口号是为没有熟知端口号的应用 程序使用的。使用这类端口号必须在IANA 按照规定的手续登记，以防止重复。 （2）客户端使用的端口号 数值为 49152~65535。由于这类端口号仅在客户进程运行 时才动态选择，因此又叫做短暂端口号。这类端口号留给客户进程选择暂时使用。当服务 器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给 客户进程。通信结束后，刚才已使用过的客户端口号就不复存在，这个端口号就可以供其他 客户进程使用。 下面将分别讨论 UDP 和 TCP。UDP 比较简单，本章主要讨论 TCP。 ① 注：短暂端口（ephemeral port）[STEV94， p。13]表示这种端口的存在时间是短期的。客户进程并不在意操作系统给它分配 的是哪一个端口号，因为客户进程之所以必须有一个端口号（在本地主机中必须是唯一的），是为了让运输层的实体能够找到自 己。这和熟知端口不同。服务器机器一接通电源，服务器程序就运行起来。为了让互联网上所有的客户程序都能找到服务器程 序，服务器程序所使用的端口（即熟知端口）就必须是固定的，并且是众所周知的。</p> <p>5。2 用户数据报协议 UDP 5。2。1 UDP 概述 用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和 分用的功能以及差错检测的功能。UDP 的主要特点是： （1） UDP 是无连接的，即发送数据之前不需要建立连接（当然，发送数据结束时也没有 连接可释放），因此减少了开销和发送数据之前的时延。 （2） UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状 态表（这里面有许多参数）。 （3） UDP 是面向报文的。发送方的UDP 对应用程序交下来的报文，在添加首部后就向 下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边 界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文，如 图 5-4 所示。在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不 动地交付上层的应用进程。也就是说，UDP 一次交付一个完整的报文。因此，应用程序必 须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP层在传送时可能要进行分 片，这会降低 IP层的效率。反之，若报文太短，UDP 把它交给IP层后，会使 IP 数据报的 首部的相对长度太大，这也降低了 IP 层的效率。 应用层报文 应用层 UDP 首部 UDP用户数据报的数据部分 运输层 IP 首部 IP数据报的数据部分 IP 层 图5-4 UDP是面向报文的 （4） UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些 实时应用是很重要的。很多的实时应用（如IP电话、实时视频会议等）要求源主机以恒定 的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时 延。UDP 正好适合这种要求。 （5） UDP 支持一对一，一对多、多对一和多对多的交互通信。 （6） UDP 的首部开销小，只有8个字节，比 TCP 的20个字节的首部要短。 虽然某些实时应用需要使用没有拥塞控制的 UDP，但当很多的源主机同时都向网络发 送高速率的实时视频流时，网络就有可能发生拥塞，结果大家都无法正常接收。因此，不使 用拥塞控制功能的 UDP 有可能会引起网络产生严重的拥塞问题。 还有一些使用 UDP的实时应用，需要对 UDP 的不可靠的传输进行适当的改进，以减 少数据的丢失。在这种情况下，应用进程本身可以在不影响应用的实时性的前提下，增加一 些提高可靠性的措施，如采用前向纠错或重传已丢失的报文。</p> <p>5。2。2 UDP 的首部格式 用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段很简单，只有8 个字节 （图5-5），由四个字段组成，每个字段的长度都是两个字节。各字段意义如下： （1） 源端口 源端口号。在需要对方回信时选用。不需要时可用全0。 （2）目的端口 目的端口号。这在终点交付报文时必须使用。 （3） 长度 UDP 用户数据报的长度，其最小值是8（仅有首部）。 （4）检验和 检测 UDP 用户数据报在传输中是否有错。有错就丢弃。 字节 4 4 1 1 2 源 IP 地址 目的IP 地址 0 17 UDP长度 字节 12 2 2 伪首部 源端口 目的端口 长度 检验和 UDP首部 UDP的数据部分 IP 首部 IP数据报的数据部分 图5-5 UDP用户数据报的首部和伪首部 当运输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过 相应的端口，上交最后的终点——应用进程。图5-6是UDP基于端口分用的示意图。 端口1 端口2 端口3 UDP分用 UDP数据报到达 IP 层 图5-6 UDP基于端口的分用 如果接收方 UDP 发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的 应用进程），就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给 发送方。我们在上一章4。4。2节“ICMP 的应用举例”讨论 traceroute 时，就是让发送的 UDP 用户数据报故意使用一个非法的UDP端口，结果ICMP就返回“端口不可达”差错报文， 因而达到了测试的目的。 请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的， 因此不需要使用套接字（TCP之间的通信必须要在两个套接字之间建立连接）。 UDP 用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在 UDP 用户 数据报之前增加 12 个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP 用户数 据报真正的首部。只是在计算检验和时，临时添加在 UDP 用户数据报前面，得到一个临时的 UDP 用户数据报。检验和就是按照这个临时的UDP 用户数据报来计算的。伪首部既不向下传</p> <p>送也不向上递交，而仅仅是为了计算检验和。图5-5的最上面给出了伪首部各字段的内容。 UDP 计算检验和的方法和计算IP数据报首部检验和的方法相似。但不同的是：IP 数据 报的检验和只检验IP数据报的首部，但UDP的检验和是把首部和数据部分一起都检验。在 发送方，首先是先把全零放入检验和字段。再把伪首部以及 UDP 用户数据报看成是由许多 16 位的字串接起来的。若UDP 用户数据报的数据部分不是偶数个字节，则要填入一个全零 字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和。将此和的二进制反码 写入检验和字段后，就发送这样的UDP用户数据报。在接收方，把收到的 UDP 用户数据报 连同伪首部（以及可能的填充全零字节）一起，按二进制反码求这些 16位字的和。当无差 错时其结果应为全1。否则就表明有差错出现，接收方就应丢弃这个UDP用户数据报（也 可以上交给应用层，但附上出现了差错的警告）。图 5-7 给出了一个计算 UDP 检验和的例 子。这里假定用户数据报的长度是15字节，因此要添加一个全0的字节。读者可以自己检 验一下在接收端是怎样对检验和进行检验的。不难看出，这种简单的差错检验方法的检错能 力并不强，但它的好处是简单，处理起来较快。 153。19。8。104 10011001 00010011 00001000 01101000 10101011 00000011 - 153。19 8。104 171。3 12字节伪首部 171。3。14。11 全0 17 00001110 00001011 14。11 15 00000000 00010001 00000000 00001111 0和17 15 1087 13 8 字节 UDP首部· 00000100 00111111 1087 15 全 0 00000000 00001101 13 00000000 00001111 15 7字节数据&lt; 数据 数据 数据 数据 数据 数据 数据全0 填充 01010011 01010100 01001001 01001110 01000111 00000000 按二进制反码运算求和 10010110 11101101 将得出的结果求反码 01101001 00010010 00000000 00000000 0（检验和） 01010100 01000101 数据 数据 数据 数据和0（填充） 求和得出的结果 检验和 图5-7 计算 UDP检验和的例子 如图 5-5 所示，伪首部的第3字段是全零；第4字段是IP首部中的协议字段的值。以 前已讲过，对于 UDP，此协议字段值为17；第5字段是UDP用户数据报的长度。因此，这 样的检验和，既检查了UDP用户数据报的源端口号和目的端口号以及UDP用户数据报的数 据部分，又检查了IP数据报的源 IP 地址和目的地址。 5。3 传输控制协议 TCP 概述 由于 TCP 协议比较复杂，因此本节先对TCP协议进行一般的介绍，然后再逐步深入讨 论 TCP 的可靠传输、流量控制和拥塞控制等问题。 5。3。1 TCP最主要的特点 TCP 是 TCP/IP 体系中非常复杂的一个协议。下面介绍 TCP 最主要的特点。 （1） TCP 是面向连接的运输层协议。这就是说，应用程序在使用TCP 协议之前，必须先 建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。也就是说，应用进程</p> <p>之间的通信好像在“打电话”：通话前要先拨号建立连接，通话结束后要挂机释放连接。 （2）每一条 TCP 连接只能有两个端点（endpoint），每一条 TCP 连接只能是点对点的（一 对一）。这个问题后面还要进一步讨论。 （3） TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复， 并且按序到达。 （4） TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。 TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时， 应用程序在把数据传送给 TCP 的缓存后，就可以做自己的事，而 TCP 在合适的时候把数据 发送出去。在接收时，TCP 把收到的数据放入缓存，上层的应用进程在合适的时候读取缓 存中的数据。 （5）面向字节流。TCP 中的“流”（stream）指的是流入到进程或从进程流出的字节序列。 “面向字节流”的含义是：虽然应用程序和TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序下来的数据仅仅看成是一连串的无结构的字节流。TCP 并不知道所传送 的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的 数据块具有对应大小的关系（例如，发送方应用程序交给发送方的TCP 共10 个数据块，但 接收方的 TCP 可能只用了4个数据块就把收到的字节流交付上层的应用程序）。但接收方应 用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程 序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。图 5-8 是上述概念的示 意图。 发送方 接收方 应用进程 表示 TCP 报文段的首部 表示序号为x的数据字节 应用进程 |字节流 把字节写入 发送缓存 [012-3 字节流 从接收缓存 读取字节 TCP 加上 TCP 首部 TCP 1817161514 构成TCP报文段 发送 TCP报文段 131211 → 109 H 876H 图 5-8 TCP 面向字节流的概念 为了突出示意图的要点，我们只画出了一个方向的数据流。但请注意，在实际的网络 中，一个 TCP 报文段包含上千个字节是很常见的，而图中的各部分都只画出了几个字节， 这仅仅是为了更方便地说明“面向字节流”的概念。另一点很重要的是：图 5-8 中的 TCP 连接是一条虚连接（也就是逻辑连接），而不是一条真正的物理连接。TCP报文段先要传送 到 IP 层，加上 IP 首部后，再传送到数据链路层。再加上数据链路层的首部和尾部后，才离 开主机发送到物理链路。 图 5-8 指出，TCP 和 UDP 在发送报文时所采用的方式完全不同。TCP 并不关心应用进 程一次把多长的报文发送到 TCP 的缓存中，而是根据对方给出的窗口值和当前网络拥塞的</p> <p>程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。如果 应用进程传送到 TCP 缓存的数据块太长，TCP 就可以把它划分短一些再传送。如果应用进 程一次只发来一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。 关于 TCP 报文段的长度问题，在后面还要进行讨论。 5。3。2 TCP的连接 TCP 把连接作为最基本的抽象。TCP 的许多特性都与 TCP 是面向连接的这个基本特性 有关。因此我们对TCP连接需要有更清楚的了解。 前面已经讲过，每一条 TCP 连接有两个端点。那么，TCP 连接的端点是什么呢？不是 主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫 做套接字（socket）或插口。根据 RFC 793 的定义：端口号拼接到（concatenated with） IP 地址即 构成了套接字。因此，套接字的表示方法是在点分十进制的 IP 地址后面写上端口号，中间 用冒号或逗号隔开。例如，若 IP 地址是192。3。4。5 而端口号是 80，那么得到的套接字就是 （192。3。4。5：80）。总之，我们有 套接字 socket = （IP 地址： 端口号） 每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即： TCP 连接 ：：= {socketı， socketz} = {（IPı：portı）， （IP2： portz）} （5-1） （5-2） 这里 IPı 和 IP2分别是两个端点主机的 IP 地址，而port和port2分别是两个端点主机中 的端口号。TCP 连接的两个套接字就是 socket 和 socket。可见套接字 socket 是个很抽象的 概念。在下一章的6。8节还要对套接字进行更多的介绍。 总之，TCP 连接就是由协议软件所提供的一种抽象。虽然有时为了方便，我们也可以 说，在一个应用进程和另一个应用进程之间建立了一条 TCP 连接，但一定要记住：TCP 连 接的端点是个很抽象的套接字，即（IP 地址：端口号）。也还应记住：同一个 IP 地址可以 有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的TCP 连接中。 请注意，socket 这个名词有时容易使人把一些概念弄混淆，因为随着互联网的不断发展 以及网络技术的进步，同一个名词 socket 却可表示多种不同的意思。例如： （1） 允许应用程序访问连网协议的应用编程接口 API （Application Programming Interface），即运输层和应用层之间的一种接口，称为 socket API，并简称为 socket。 （2） 在 socket API 中使用的一个函数名也叫做 socket。 （3） 调用 socket 函数的端点称为 socket，如“创建一个数据报 socket”。 （4） 调用 socket 函数时，其返回值称为 socket 描述符，可简称为 socket。 （5） 在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。 上面的这些 socket 的意思都和本章所引用的 RFC 793 定义的 socket （指端口号拼接到 IP 地址）不同。请读者加以注意。 5。4 可靠传输的工作原理 我们知道，TCP 发送的报文段是交给IP层传送的。但IP层只能提供尽最大努力服务，</p> <p>也就是说，TCP 下面的网络所提供的是不可靠的传输。因此，TCP 必须采用适当的措施才 能使得两个运输层之间的通信变得可靠。 理想的传输条件有以下两个特点： （1） 传输信道不产生差错。 （2）不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。 在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。 然而实际的网络都不具备以上两个理想条件。但我们可以使用一些可靠传输协议，当 出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告 诉发送方适当降低发送数据的速度。这样一来，本来不可靠的传输信道就能够实现可靠传输 了。下面从最简单的停止等待协议讲起。 5。4。1 停止等待协议 全双工通信的双方既是发送方也是接收方。下面为了讨论问题的方便，我们仅考虑 A 发送数据而 B 接收数据并发送确认。因此A叫做发送方，而 B 叫做接收方。因为这里是讨 论可靠传输的原理，因此把传送的数据单元都称为分组，而并不考虑数据是在哪一个层次上 传送的®。“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认 后再发送下一个分组。 1。无差错情况 停止等待协议可用图 5-9 来说明。图5-9（a）是最简单的无差错情况。A 发送分组 Mı，发 完就暂停发送，等待 B 的确认。B 收到了 M就向 A 发送确认。A 在收到了对 M的确认 后，就再发送下一个分组 M2。同样，在收到 B 对 M 的确认后，再发送 M3。 A B A 发送 M B 发送 M 确认M 丢弃有差错 的报文 发送 M2 超时重传 M 确认 M2 确认 Mı 发送 M3 发送 M2 确认 M3 （a）无差错情况 图5-9 停止等待协议 （b）超时重传</p> <p>2。出现差错 图 5-9（b）是分组在传输过程中出现差错的情况。B 接收 M时检测出了差错，就丢弃 Mı，其他什么也不做（不通知A 收到有差错的分组）。也可能是M，在传输过程中丢失 了，这时 B 当然什么都不知道。在这两种情况下，B 都不会发送任何信息。可靠传输协议 是这样设计的：A 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了， 因而重传前面发送过的分组。这就叫做超时重传。要实现超时重传，就要在每发送完一个分 组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的 超时计时器。其实在图5-9（a）中，A为每一个已发送的分组都设置了一个超时计时器。但 A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器。为简单起见，这些细 节在图5-9（a）中都省略了。 这里应注意以下三点。 第一，A 在发送完一个分组后，必须暂时保留已发送的分组的副本（在发生超时重传时 使用）。只有在收到相应的确认后才能清除暂时保留的分组副本。 第二，分组和确认分组都必须进行编号”。这样才能明确是哪一个发送出去的分组收到 了确认，而哪一个分组还没有收到确认。 第三，超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。 图 5-9（b）中的一段虚线表示如果M 正确到达 B 同时 A 也正确收到确认的过程。可见重传时 间应设定为比平均往返时间更长一些。显然，如果重传时间设定得很长，那么通信的效率就 会很低。但如果重传时间设定得太短，以致产生不必要的重传，就浪费了网络资源。然而， 在运输层重传时间的准确设定是非常复杂的，这是因为已发送出的分组到底会经过哪些网 络，以及这些网络将会产生多大的时延（这取决于这些网络当时的拥塞情况），这些都是不 确定因素。图 5-9 中把往返时间当作固定的（这并不符合网络的实际情况），只是为了讲述 原理的方便。关于重传时间应如何选择，在后面的5。6。3节还要进一步讨论。 3。确认丢失和确认迟到 图 5-10（a）说明的是另一种情况。B 所发送的对 M 的确认丢失了。A 在设定的超时重传 时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是 B 发送的确认丢 失了。因此 A 在超时计时器到期后就要重传 Mı。现在应注意 B 的动作。假定 B 又收到了 重传的分组 Mı。这时应采取两个行动。 第一，丢弃这个重复的分组 Mı，不向上层交付。 第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M</p> <p>就表示A没有收到对M，的确认。 A 发送 M B A B 发送 M 确认 M 确认 M 超时重传 M。 超时重传M。 丢弃重复的M 重传确认 M 丢弃重复的M 重传确认M 发送 M2 发送 M2 收下迟到的确认 但什么也不做 t （a）确认丢失 （b） 确认迟到 图5-10 确认丢失和确认迟到 图 5-10（b）也是一种可能出现的情况。传输过程中没有出现差错，但B 对分组 Mı的确 认迟到了。A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。B 仍然会收 到重复的 M，并且同样要丢弃重复的 Mı，并重传确认分组。 通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不 到确认，就说明通信线路太差，不能进行通信。 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。 像上述的这种可靠传输协议常称为自动重传请求ARQ （Automatic Repeat reQuest）。意思 是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。 4。信道利用率 停止等待协议的优点是简单，但缺点是信道利用率太低。我们可以用图 5-11 来说明这 个问题。为简单起见，假定在A和B之间有一条直通的信道来传送分组。 B A 分组 确认 分组。 确认→ t t RTT Tp+RTT+T4 图5-11 停止等待协议的信道利用率太低 假定 A 发送分组需要的时间是 Tn。显然，To等于分组长度除以数据率。再假定分组正 确到达 B 后，B 处理分组的时间可以忽略不计，同时立即发回确认。假定 B 发送确认分组 需要时间 T｣。如果A处理确认分组的时间也可以忽略不计，那么A在经过时间（TD + RTT + Ta）后就可以再发送下一个分组，这里的 RTT 是往返时间。因为仅仅是在时间 To 內才用来 传送有用的数据（包括分组的首部），因此信道的利用率U可用下式计算： To U = Tp+RTT+T4 （5-3）</p> <p>请注意，更细致的计算还可以在上式分子的时间 To 内扣除传送控制信息（如首部）所 花费的时间。但在进行粗略计算时，用近似的式（5-3）就可以了。 我们知道，式（5-3）中的往返时间 RTT 取决于所使用的信道。例如，假定 1200 km 的信 道的往返时间 RTT = 20 ms。分组长度是1200 bit，发送速率是1Mbit/s。若忽略处理时间和 Ta（Ta一般都远小于 Tn），则可算出信道的利用率U=5。66%。但若把发送速率提高到 10 Mbit/s，则 U = 5。96x104。信道在绝大多数时间内都是空闲的。 从图 5-11 还可看出，当往返时间 RTT 远大于分组发送时间 To 时，信道的利用率就会 非常低。还应注意的是，图 5-11 并没有考虑出现差错后的分组重传。若出现重传，则对传 送有用的数据信息来说，信道的利用率就还要降低。 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输 （如图5-12 所示）。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停 顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。显然，这种传输方式 可以获得很高的信道利用率。 B A 分组 图5-12 流水线传输可提高信道利用率 t t 当使用流水线传输时，就要使用下面介绍的连续 ARQ 协议和滑动窗口协议。 5。4。2 连续ARQ 协议 滑动窗口协议比较复杂，是TCP 协议的精髓所在。这里先给出连续 ARQ 协议最基本的 概念，但不涉及许多细节问题。详细的滑动窗口协议将在后面的5。6节中讨论。 图 5-13（a）表示发送方维持的发送窗口，它的意义是：位于发送窗口内的 5 个分组都可 连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。 在讨论滑动窗口时，我们应当注意到，图中还有一个时间坐标（但以后往往省略这样 的时间坐标）。按照习惯，“向前”是指“向着时间增大的方向”，而“向后”则是“向着时 间减少的方向”。分组发送是按照分组序号从小到大发送的。 发送窗口 1 2 3 4 5 6 7 8 9 10 11 12 t （a）发送窗口是5 发送窗口 —向前 1 2 3 4 5 6 7 8 9 10 11 12 （b） 收到一个确认后发送窗口向前滑动 图5-13 连续 ARQ协议的工作原理 连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位</p> <p>置。图 5-13（b）表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组 的位置。如果原来已经发送了前5个分组，那么现在就可以发送窗口内的第6个分组了。 接收方一般都是采用累积确认的方式。这就是说，接收方不必对收到的分组逐个发送 确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示：到这个分 组为止的所有分组都已正确收到了。 累积确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是 不能向发送方反映出接收方已经正确收到的所有分组的信息。 例如，如果发送方发送了前5个分组，而中间的第3个分组丢失了。这时接收方只能 对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都 再重传一次。这就叫做 Go-back-N （回退N），表示需要再退回来重传已发送过的 N 个分 组。可见当通信线路质量不好时，连续ARQ 协议会带来负面的影响。 在深入讨论 TCP 的可靠传输问题之前，必须先了解TCP 的报文段首部的格式。 5。5 TCP 报文段的首部格式 TCP 虽然是面向字节流的，但TCP 传送的数据单元却是报文段。一个 TCP 报文段分为 首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。因此，只有弄清 TCP 首部各字段的作用才能掌握 TCP 的工作原理。下面讨论 TCP报文段的首部格式。 TCP 报文段首部的前20个字节是固定的（图5-14），后面有4n 字节是根据需要而增加 的选项（n是整数）。因此TCP 首部的最小长度是 20 字节。 位 0 8 16 24 31 源端口 目的端口 序号 | 20字节的 TCP 首部 确认号 固定首部 数据 偏移 保留 R 窗口 检验和 紧急指针 选项 （长度可变） 填充 发送在前 TCP首部 TCP报文段的数据部分 IP 首部 IP数据报的数据部分 图5-14 TCP报文段的首部格式 首部固定部分各字段的意义如下： （1） 源端口和目的端口 各占 2 个字节，分别写入源端口号和目的端口号。和前面图 5-6 所示的 UDP 的分用相似，TCP 的分用功能也是通过端口实现的。</p> <h2 id="2-序号">（2） 序号</h2> <p>占4字节。序号范围是[0， 22 - 1]，共22（即4294967296）个序号。序 号增加到 2” − 1 后，下一个序号就又回到0。也就是说，序号使用mod 2”运算。TCP 是面 向字节流的。在一个TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送 的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是本报文段所发送 的数据的第一个字节的序号。例如，一报文段的序号字段值是 301，而携带的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段 的序号字段值应为401。这个字段的名称也叫做“报文段序号”。 （3） 确认号 ~ 占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。例 如，B 正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是 200 字节 （序号501 ·700），这表明B正确收到了A发送的到序号700为止的数据。因此，B 期望 收到 A 的下一个数据序号是701，于是B 在发送给A 的确认报文段中把确认号置为 701。 请注意，现在的确认号不是 501，也不是 700，而是 701。 总之，应当记住： 若确认号 =N，则表明：到序号-1为止的所有数据都已正确收到。 由于序号字段有32位长，可对4GB（即4千兆字节）的数据进行编号。在一般情况下 可保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。 （4）数据偏移 占4位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处 有多远。这个字段实际上是指出 TCP报文段的首部长度。由于首部中还有长度不确定的选 项字段，因此数据偏移字段是必要的。但应注意，“数据偏移”的单位是32位字（即以4字 节长的字为计算单位）。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移 的最大值是60字节，这也是TCP 首部的最大长度（即选项长度不能超过40字节）。 （5） 保留 占6位，保留为今后使用，但目前应置为0。 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报 下面有6个控制位，用来说明本报文段的性质，它们的意义见下面的（6）~（11）。 （6） 紧急 URG （URGent） 文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传 送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需 要取消该程序的运行。因此用户从键盘发出中断命令（Control + C）。如果不使用紧急数 据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据处理完毕后这两 个字符才被交付接收方的应用进程。这样做就浪费了许多时间。 当 URG置 1时，发送应用进程就告诉发送方的TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数 据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。 然而在紧急指针字段的具体实现上，由于过去的有些文档有错误或有不太明确的地 方，因而导致对有关的RFC 文档产生了不同的理解。于是，在2011年公布的建议标准 RFC 6093，把紧急指针字段的使用方法做出了更加明确的解释，并更新了几个重要的 RFC 文 档，如 RFC 793， RFC 1011， RFC 1122 等。 （7） 确认 ACK （ACKnowledgment） 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 仅当 ACK = 1 时确认号字段才有效。当ACK = 0</p> <p>（8） 推送 PSH （PuSH） 当两个应用进程进行交互式的通信时，有时在一端的应用进程 希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送 （push）操作。这时，发送方 TCP 把 PSH 置 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到 整个缓存都填满了后再向上交付。 虽然应用程序可以选择推送操作，但推送操作很少使用。 （9） 复位 RST （ReSeT） 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机 崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST 置 1 还用来拒绝一个非 法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位。 （10） 同步 SYN （SYNchronization） 在连接建立时用来同步序号。当SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。关于连 接的建立和释放，在后面的5。9节还要进行详细讨论。 （11） 终止 FIN （FINis，意思是“完”、“终”） 用来释放一个连接。当FIN=1时，表 明此报文段的发送方的数据已发送完毕，并要求释放运输连接。 （12） 窗口 占2字节。窗口值是[0，26-1]之间的整数。窗口指的是发送本报文段的 一方的接收窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号 算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为 接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的 依据。 例如，发送了一个报文段，其确认号是 701，窗口字段是 1000。这就是告诉对方：“从 701 号算起，我（即发送报文段的一方）的接收缓存空间还可接收 1000个字节数据（字 节序号是701~1700），你在给我发送数据时，必须考虑到这一点。” 总之，应当记住： 窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着。 （13） 检验和 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上12字节的伪首部。伪首部 的格式与图 5-5 中UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的 17 改为 6 （TCP 的协议号是6），把第5 字段中的 UDP 长度改为 TCP 长度。接收方收到此报文段 后，仍要加上这个伪首部来计算检验和。若使用IPv6，则相应的伪首部也要改变。 （14） 紧急指针 占2字节。紧急指针仅在URG = 1时才有意义，它指出本报文段中 的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的 末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操 作。值得注意的是，即使窗口为零时也可发送紧急数据。 （15） 选项 是20字节。 长度可变，最长可达40字节。当没有使用“选项“时，TCP 的首部长度 TCP 最初只规定了一种选项，即最大报文段长度 MSS （Maximum Segment Size） [RFC 879]。请注意 MSS 这个名词的含义。MSS 是每一个 TCP 报文段中的数据字段的最大长度。 数据字段加上 TCP 首部才等于整个的TCP报文段。所以 MSS 并不是整个TCP报文段的最</p> <p>大长度，而是“TCP报文段长度减去TCP首部长度”。 为什么要规定一个最大报文段长度 MSS呢？这并不是考虑接收方的接收缓存可能放不 下 TCP 报文段中的数据。实际上，MSS 与接收窗口值没有关系。我们知道，TCP 报文段的 数据部分，至少要加上40字节的首部（TCP 首部20字节和IP首部20字节，这里都还没有 考虑首部中的选项部分），才能组装成一个IP数据报。若选择较小的 MSS 长度，网络的利 用率就降低。设想在极端的情况下，当 TCP 报文段只含有1字节的数据时，在 IP 层传输的 数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络 的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若 TCP 报文段 非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数 据报片装配成原来的TCP报文段。当传输出错时还要进行重传。这些也都会使开销增大。 因此，MSS 应尽可能大些，只要在IP层传输时不需要再分片就行。由于IP 数据报所 经历的路径是动态变化的，因此在这条路径上确定的不需要分片的MSS，如果改走另一条 路径就可能需要进行分片。因此最佳的 MSS 是很难确定的。在连接建立的过程中，双方都 把自己能够支持的 MSS 写入这一字段，以后就按照这个数值传送数据，两个传送方向可以 有不同的 MSS 值。若主机未填写这一项，则 MSS 的默认值是536 字节长。因此，所有在 互联网上的主机都应能接受的报文段长度是536+20（固定首部长度）=556字节。 随着互联网的发展，又陆续增加了几个选项。如窗口扩大选项、时间戳选项等（见建 议标准 RFC 7323）。以后又增加了有关选择确认（SACK）选项（见建议标准 RFC 2018）。这 些选项的位置都在图5-14所示的选项字段中。 窗口扩大选项是为了扩大窗口。我们知道，TCP 首部中窗口字段长度是16位，因此最 大的窗口大小为64K字节（见下一节）。虽然这对早期的网络是足够用的，但对于包含卫星 信道的网络，传播时延和带宽都很大，要获得高吞吐率需要更大的窗口大小。 窗口扩大选项占 3 字节，其中有一个字节表示移位值S。新的窗口值等于 TCP 首部中 的窗口位数从 16 增大到（16 + S）。移位值允许使用的最大值是14，相当于窗口最大值增大 2 （16+14） 1 = 230 – 1。 窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗 口扩大，当它不再需要扩大其窗口时，可发送S=0的选项，使窗口大小回到 16。 时间戳选项占 10 字节，其中最主要的字段是时间戳值字段（4字节）和时间戳回送回 答字段（4字节）。时间戳选项有以下两个功能： 第一，用来计算往返时间 RTT（见后面的 5。6。2 节）。发送方在发送报文段时把当前时 钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回 答字段。因此，发送方在收到确认报文后，可以准确地计算出 RTT 来。 第二，用于处理 TCP 序号超过232的情况，这又称为防止序号绕回 PAWS （Protect Against Wrapped Sequence numbers）。我们知道，TCP报文段的序号只有32位，而每增加 22 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次 TCP 连接的数据传送</p> <p>中序号很可能会被重复使用。例如，当使用1。5 Mbit/s的速率发送报文段时，序号重复要 6 小时以上。但若用2。5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收 方能够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。 我们将在后面的5。6。3节介绍选择确认选项。 5。6 TCP可靠传输的实现 本节讨论 TCP 可靠传输的实现。 我们首先介绍以字节为单位的滑动窗口。为了讲述可靠传输原理的方便，我们假定数 据传输只在一个方向进行，即A发送数据，B 给出确认。这样的好处是使讨论限于两个窗 口，即发送方A的发送窗口和接收方B的接收窗口。如果再考虑B也向A发送数据，那么 还要增加 A 的接收窗口和B的发送窗口，这对讲述可靠传输的原理并没有多少帮助，反而 会使问题更加繁琐。 5。6。1 以字节为单位的滑动窗口 TCP 的滑动窗口是以字节为单位的。为了便于说明滑动窗口的工作原理，我们故意把后 面图 5-15 至图5-18中的字节编号都取得很小。现假定A收到了B发来的确认报文段，其中 窗口是 20 字节，而确认号是31（这表明B期望收到的下一个序号是31，而序号30为止的数 据已经收到了）。根据这两个数据，A就构造出自己的发送窗口，如图 5-15 所示。 后沿 不允许收缩 前沿 =&gt;前移 X← •前移 A的发送窗口= 20 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 已发送并 52 53 54 55 56 不允许发送 收到确认 允许发送的序号 B 期望 收到的序号 图5-15 根据B给出的窗口值，A构造出自己的发送窗口 我们先讨论发送方 A 的发送窗口。发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂 时保留，以便在超时重传时使用。 发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对 方确认之前连续发送更多的数据，因而可能获得更高的传输效率。在上面的5。5节我们已经 讲过，接收方会把自己的接收窗口数值放在窗口字段中发送给对方。因此，A 的发送窗口一 定不能超过 B 的接收窗口数值。在后面的5。8节我们将要讨论，发送方的发送窗口大小还要 受到当时网络拥塞程度的制约。但在目前，我们暂不考虑网络拥塞的影响。 发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留 了。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临 时存放的缓存空间。 发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种 可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口后沿不可能向后</p> <p>移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不 动。这对应于两种情况：一是没有收到新的确认，对方通知的窗口大小也不变；二是收到了 新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。 发送窗口前沿也有可能向后收缩。这发生在对方通知的窗口缩小了。但 TCP 的标准强 烈不赞成这样做。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现 在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。 现在假定A发送了序号为31~41的数据。这时，发送窗口位置并未改变（图5-16）， 但发送窗口内靠后面有11个字节（灰色小方框表示）表示已发送但未收到确认。而发送窗 口内靠前面的9个字节（42~50）是允许发送但尚未发送的。 A的发送窗口位置不变 可用窗口 26 27 28 29 30 已发送并 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 不允许发送 收到确认 已发送但未收到确认 允许发送但尚未发送 P P₂ B 的接收窗口 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 不允许接收 26 27 28 29 30 31 已发送确认 并交付主机 未按序收到 允许接收 图5-16A 发送了11个字节的数据 从以上所述可以看出，要描述一个发送窗口的状态需要三个指针：P，P2和P3（图5- 16）。指针都指向字节的序号。这三个指针指向的几个部分的意义如下： 小于P 的是已发送并已收到确认的部分，而大于P，的是不允许发送的部分。 P3-Pı=A的发送窗口 P2-P1=已发送但尚未收到确认的字节数 P3-P2=允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口） 再看一下B 的接收窗口。B的接收窗口大小是20。在接收窗口外面，到30号为止的数 据是已经发送过确认，并且已经交付主机了。因此在 B 可以不再保留这些数据。接收窗口 内的序号（31~50）是允许接收的。在图5-16中，B收到了序号为32和33的数据。这些 数据没有按序到达，因为序号为31 的数据没有收到（也许丢失了，也许滞留在网络中的某 处）。请注意，B只能对按序收到的数据中的最高序号给出确认，因此B 发送的确认报文段 中的确认号仍然是31（即期望收到的序号），而不能是32或33。 现在假定B收到了序号为31的数据，并把序号为31 33 的数据交付主机，然后B删 除这些数据。接着把接收窗口向前移动3个序号（图5-17），同时给A发送确认，其中窗口 值仍为 20，但确认号是34。这表明 B 已经收到了到序号 33 为止的数据。我们注意到，B 还收到了序号为37，38和40的数据，但这些都没有按序到达，只能先暂存在接收窗口中。 A 收到 B 的确认后，就可以把发送窗口向前滑动3个序号，但指针 Pz不动。可以看出，现 在A的可用窗口增大了，可发送的序号范围是42~53。</p> <p>A 的发送窗口 向前滑动 可用窗口增大 国 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 •不允许 已发送并收到确认 已发送但未收到确认 允许发送但尚未发送 发送 P2 P3 B 的接收窗口向前滑动 网 39 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 不允许 已发送确认并交付主机 未按序收到 允许接收 接收 图5-17A收到新的确认号，发送窗口向前滑动 A 在继续发送完序号42~53的数据后，指针P，向前移动和 P， 重合。发送窗口内的序 号都已用完，但还没有再收到确认（图 5-18）。由于 A 的发送窗口已满，可用窗口已减小到 零，因此必须停止发送。请注意，存在下面这种可能性，就是发送窗口内所有的数据都已正 确到达 B，B 也早已发出了确认。但不幸的是，所有这些确认都滞留在网络中。在没有收到 B 的确认时，A 不能猜测：“或许 B 收到了吧!”为了保证可靠传输，A只能认为 B 还没有 收到这些数据。于是，A在经过一段时间后（由超时计时器控制）就重传这部分数据，重新 设置超时计时器，直到收到B的确认为止。如果A收到确认号落在发送窗口内，那么 A 就 可以使发送窗口继续向前滑动，并发送新的数据。 已发送并收到确认 P A的发送窗口已满，可用窗口为零 54 55 56 不允许 已发送但未收到确认 发送 P₂ P3 图5-18 发送窗口内的序号都属于已发送但未被确认 我们在前面的图5-8中曾给出了这样的概念：发送方的应用进程把字节流写入 TCP 的 发送缓存，接收方的应用进程从 TCP 的接收缓存中读取字节流。下面我们就进一步讨论前 面讲的窗口和缓存的关系。图 5-19 画出了发送方维持的发送缓存和发送窗口，以及接收方 维持的接收缓存和接收窗口。这里首先要明确两点： 发送应用程序 接收应用程序 发送方 接收方 TCP TCP 发送缓存 发送窗口 接收缓存 最后写入；下一个读取 的字节 的字节 接收窗口 已发送 最后被确认 的字节 最后发送 的字节 序号增大 按序到达的 未按序到达的 序号增大 （a）发送缓存和发送窗口 下一个期望收到的字节 （b）接收缓存和接收窗口 图5-19 TCP的缓存和窗口的关系</p> <p>第一，缓存空间和序号空间都是有限的，并且都是循环使用的。最好是把它们画成圆 环状的。但这里为了画图的方便，我们还是把它们画成长条状的。 第二，由于实际上缓存或窗口中的字节数是非常之大的，因此图5-19 仅仅是个示意 图，没有标出具体的数值。但用这样的图来说明缓存和发送窗口以及接收窗口的关系是很清 楚的。 我们先看一下图5-19（a）所示的发送方的情况。 发送缓存用来暂时存放： （1）发送应用程序传送给发送方 TCP 准备发送的数据； （2） TCP已发送出但尚未收到确认的数据。 发送窗口通常只是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，因此 发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节减去最后被确 认的字节，就是还保留在发送缓存中的被写入的字节数。发送应用程序必须控制写入缓存的 速率，不能太快，否则发送缓存就会没有存放数据的空间。 再看一下图 5-19（b）所示的接收方的情况。 接收缓存用来暂时存放： （1） 按序到达的，但尚未被接收应用程序读取的数据； （2）未按序到达的数据。 如果收到的分组被检测出有差错，则要丢弃。如果接收应用程序来不及读取收到的数 据，接收缓存最终就会被填满，使接收窗口减小到零。反之，如果接收应用程序能够及时从 接收缓存中读取收到的数据，接收窗口就可以增大，但最大不能超过接收缓存的大小。图 5-19（b）中还指出了下一个期望收到的字节号。这个字节号也就是接收方给发送方的报文段的 首部中的确认号。 根据以上所讨论的，我们还要再强调以下三点。 第一，虽然 A 的发送窗口是根据B的接收窗口设置的，但在同一时刻，A 的发送窗口 并不总是和 B 的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后 （这个时间还是不确定的）。另外，正如后面 5。7节将要讲到的，发送方 A 还可能根据网络 当时的拥塞情况适当减小自己的发送窗口数值。 第二，对于不按序到达的数据应如何处理，TCP 标准并无明确规定。如果接收方把不 按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用 不利（因为发送方会重复传送较多的数据）。因此TCP 通常对不按序到达的数据是先临时存 放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。 第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以 在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两 点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网 络的资源。TCP 标准规定，确认推迟的时间不应超过0。5秒。若收到一连串具有最大长度的 报文段，则必须每隔一个报文段就发送一个确认[RFC1122]。二是捎带确认实际上并不经常 发生，因为大多数应用程序很少同时在两个方向上发送数据。 最后再强调一下，TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文 段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清是哪一 方的窗口。</p> <p>5。6。2 超时重传时间的选择 上面已经讲到，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文 段。这种重传的概念是很简单的，但重传时间的选择却是TCP 最复杂的问题之一。 由于 TCP 的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可 能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同。如果把超时重传 时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传 时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。 那么，运输层的超时计时器的超时重传时间究竟应设置为多大呢？ TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的 时间。这两个时间之差就是报文段的往返时间 RTT。TCP 保留了RTT的一个加权平均往返 时间 RTTs（这又称为平滑的往返时间，S 表示Smoothed。因为进行的是加权平均，因此得 出的结果更加平滑）。每当第一次测量到 RTT 样本时，RTT值就取为所测量到的 RTT 样本 值。但以后每测量到一个新的RTT样本，就按下式重新计算一次 RTTs： 新的 RTTs = （1 - a）×（旧的RTTs） +ax （新的 RTT 样本） （5-4） 在上式中，0≤a&lt; 1。若a很接近于零，表示新的RTT值和旧的RTT值相比变化不 大，而对新的 RTT 样本影响不大（RTT值更新较慢）。若选择a 接近于1，则表示新的 RTT值受新的RTT样本的影响较大（RTT值更新较快）。已成为建议标准的RFC 6298 推荐 的a值为 1/8，即0。125。用这种方法得出的加权平均往返时间 RTT，就比测量出的 RTT 值 更加平滑。 显然，超时计时器设置的超时重传时间 RTO （Retransmission Time-Out）应略大于上面得 出的加权平均往返时间 RTTs RFC6298建议使用下式计算RTO： RTO = RTTs + 4 × RTTp （5-5） 而 RTTD 是 RTT 的偏差的加权平均值，它与 RTTs和新的RTT 样本之差有关。RFC 6298 建议这样计算 RTTD。当第一次测量时，RTT值取为测量到的 RTT 样本值的一半。在 以后的测量中，则使用下式计算加权平均的RTTp： 新的 RTTD = （1 - B） ×（旧的RTTD）+Bx|RTTs-新的RTT 样本 | （5-6） 这里是个小于1的系数，它的推荐值是1/4，即0。25。 上面所说的往返时间的测量，实现起来相当复杂。试看下面的例子。 如图 5-20 所示，发送出一个报文段，设定的重传时间到了，还没有收到确认。于是重 传报文段。经过了一段时间后，收到了确认报文段。现在的问题是：如何判定此确认报文段 是对先发送的报文段的确认，还是对后来重传的报文段的确认？由于重传的报文段和原来的 报文段完全一样，因此源主机在收到确认后，就无法做出正确的判断，而正确的判断对确定 加权平均 RTTs的值关系很大。 若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认， 则这样计算出的RTT和超时重传时间 RTO 就会偏大。若后面再发送的报文段又是经过重 传后才收到确认报文段，则按此方法得出的超时重传时间 RTO 就越来越长。</p> <p>对哪一个报文段 的确认？ 发送报文段 超时重传 重传报文段 收到确认 时间 往返时间 RTT？ 往返时间 RTT？ 图5-20 收到的确认是对哪一个报文段的确认？ 同样，若收到的确认是对原来的报文段的确认，但被当成是对重传报文段的确认，则 由此计算出的 RTTs 和 RTO 都会偏小。这就必然导致报文段过多地重传。这样就有可能使 RTO 越来越短。 根据以上所述，Karn 提出了一个算法：在计算加权平均 RTTS 时，只要报文段重传 了，就不采用其往返时间样本。这样得出的加权平均 RTTS 和 RTO 就较准确。 但是，这又引起新的问题。设想出现这样的情况：报文段的时延突然增大了很多。因 此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算 法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。 因此要对 Karn 算法进行修正。方法是：报文段每传一次，就把超时重传时间 RTO增 大一些。典型的做法是取新的重传时间为旧的重传时间的2倍。当不再发生报文段的重传 时，才根据上面给出的（5-5）式计算超时重传时间。实践证明，这种策略较为合理。 总之，Karn 算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返 时间的估测，使计算结果更加合理。 5。6。3 选择确认 SACK 现在还有一个问题没有讨论。这就是若收到的报文段无差错，只是未按序号，中间还 缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数 据？答案是可以的。选择确认就是一种可行的处理方法。 我们用一个例子来说明选择确认（Selective ACK）的工作原理。TCP 的接收方在接收对方 发送过来的数据字节流的序号不连续，结果就形成了一些不连续的字节块（如图 5-21 所 示）。可以看出，序号1 1000 收到了，但序号 1001 1500 没有收到。接下来的字节流又 收到了，可是又缺少了3001~3500。再后面从序号4501起又没有收到。也就是说，接收方 收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么 接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这 些已收到的数据。 第二个字节块 3501 。。。 4500 连续的字节流 第一个字节块 1 。。。 1000 1501 3000 确认号=1001 L₁ = 1501 Rf = 3001_L = 3501 R₂ =4501 图 5-21 接收到的字节流序号不连续 从图 5-21 可看出，和前后字节不连续的每一个字节块都有两个边界：左边界和右边</p> <p>= 界。因此在图中用四个指针标记这些边界。请注意，第一个字节块的左边界 L 1501，但 右边界 Rı = 3001 而不是 3000。这就是说，左边界指出字节块的第一个字节的序号，但右边 界减1才是字节块中的最后一个序号。同理，第二个字节块的左边界 L2 3501，而右边界 R2=4501。 我们知道，TCP 的首部没有哪个字段能够提供上述这些字节块的边界信息。RFC 2018 规定，如果要使用选择确认 SACK，那么在建立TCP连接时，就要在 TCP 首部的选项中加 上“允许 SACK”的选项，而双方必须都事先商定好。如果使用选择确认，那么原来首部中 的“确认号字段”的用法仍然不变。只是以后在 TCP报文段的首部中都增加了 SACK 选 项，以便报告收到的不连续的字节块的边界。由于首部选项的长度最多只有40 字节，而指 明一个边界就要用掉4字节（因为序号有32位，需要使用4个字节表示），因此在选项中最 多只能指明4个字节块的边界信息。这是因为4个字节块共有8个边界，因而需要用 32 个 字节来描述。另外还需要两个字节。一个字节用来指明是 SACK 选项，另一个字节是指明 这个选项要占用多少字节。如果要报告五个字节块的边界信息，那么至少需要 42 个字节。 这就超过了选项长度的40字节的上限。互联网建议标准 RFC 2018 还对报告这些边界信息 的格式都做出了非常明确的规定，这里从略。 然而，SACK 文档并没有指明发送方应当怎样响应 SACK。因此大多数的实现还是重传 所有未被确认的数据块。 5。7 TCP 的流量控制 5。7。1 利用滑动窗口实现流量控制 一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接 收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制（flow control）就是让发送方 的发送速率不要太快，要让接收方来得及接收。 利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。 下面通过图5-22 的例子说明如何利用滑动窗口机制进行流量控制。 A seq = 1， DATA B A发送了序号1至100，还能发送300字节 seq = 101， DATA seq = 201， DATA ACK = 1， ack = 201，rwnd = 300 seq = 301， DATA seq = 401， DATA seq = 201， DATA ACK = 1， ack = 501， rwnd = 100 seq = 501， DATA A发送了序号101至200，还能发送200字节 A发送了序号201至300，但丢失了! 允许A发送序号201至500共300字节 A 发送了序号301至400，还能再发送100字节新数据 A 发送了序号401至500，不能再发送数据了 A超时重传旧的数据，但不能发送新的数据 允许A发送序号501至600共100字节 A 发送了序号 501至600，不能再发送了 ACK = 1， ack = 601， rwnd = 0 不允许A再发送（到序号600为止的数据都收到了） 图5-22 利用可变窗口进行流量控制举例</p> <p>= 设 A 向 B 发送数据。在连接建立时，B告诉了A：“我的接收窗口rwnd 400”（这里 rwnd 表示 receiver window）。因此，发送方的发送窗口不能超过接收方给出的接收窗口 的 数值。请注意，TCP 的窗口单位是字节，不是报文段。TCP 连接建立时的窗口协商过程在 图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为 1 （见图中第一个箭头上面的序号 seq = 1。图中右边的注释可帮助理解整个过程）。请注意， 图中箭头上面大写 ACK表示首部中的确认 ACK，小写 ack表示确认字段的值。 = 我们应注意到，接收方的主机B进行了三次流量控制。第一次把窗口减小到 rwnd ==== 300， 第二次又减到rwnd 100，最后减到 rwnd = 0，即不允许发送方再发送数据了。这种使发送 方暂停发送的状态将持续到主机 B 重新发出一个新的窗口值为止。我们还应注意到，B 向 A 发送的三个报文段都设置了ACK = 1，只有在ACK=1时确认号字段才有意义。 === 现在我们考虑一种情况。在图 5-22 中，B 向 A 发送了零窗口的报文段后不久，B 的接 收缓存又有了一些存储空间。于是BA发送了 rwnd 400 的报文段。然而这个报文段在 传送过程中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的 数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。 为了解决这个问题，TCP 为每一个连接设有一个持续计时器（persistence timer）。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到 期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报 文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持 续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。 5。7。2 TCP的传输效率 前面已经讲过，应用进程把数据传送到 TCP 的发送缓存后，剩下的发送任务就由 TCP 来控制了。可以用不同的机制来控制 TCP报文段的发送时机。例如，第一种机制是TCP维 持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组 装成一个 TCP 报文段发送出去。第二种机制是由发送方的应用进程指明要求发送报文段， 即 TCP 支持的推送（push）操作。第三种机制是发送方的一个计时器期限到了，这时就把当前 已有的缓存数据装入报文段（但长度不能超过MSS）发送出去。 但是，如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。 例如，一个交互式用户使用一条TELNET连接（运输层为TCP协议）。假设用户只发1 个字符，加上 20字节的首部后，得到21 字节长的TCP报文段。再加上20 字节的IP 首 部，形成 41 字节长的IP数据报。在接收方TCP 立即发出确认，构成的数据报是40字节长 （假定没有数据发送）。若用户要求远地主机回送这一字符，则又要发回41 字节长的 IP 数 据报和 40 字节长的确认IP数据报。这样，用户仅发1个字符时，线路上就需传送总长度为 162 字节共 4 个报文段。当线路带宽并不富裕时，这种传送方法的效率的确不高。因此应适 当推迟发回确认报文，并尽量使用捎带确认的方法。</p> <p>在 TCP 的实现中广泛使用 Nagle 算法。算法如下：若发送应用进程把要发送的数据逐 个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的 数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数 据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个 报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方 法可明显地减少所用的网络带宽。Nagle 算法还规定，当到达的数据已达到发送窗口大小的 一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网 络的吞吐量。 另一个问题叫做糊涂窗口综合征（silly window syndrome）[RFC 813]，有时也会使 TCP 的 性能变坏。设想一种情况：TCP 接收方的缓存已满，而交互式的应用进程一次只从接收缓 存中读取 1 个字节（这样就使接收缓存空间仅腾出 1 个字节），然后向发送方发送确认，并 把窗口设置为1个字节（但发送的数据报是40字节长）。接着，发送方又发来1个字节的数 据（请注意，发送方发送的IP数据报是41字节长）。接收方发回确认，仍然将窗口设置为 1个字节。这样进行下去，使网络的效率很低。 要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳 一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接 收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报 文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。 上述两种方法可配合使用。使得在发送方不发送很小的报文段的同时，接收方也不要 在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。 5。8 TCP 的拥塞控制 5。8。1 拥塞控制的一般原理 在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资 源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能 就要变坏。这种情况就叫做拥塞（congestion）。可以把出现网络拥塞的条件写成如下的关系式： ∑对资源的需求&gt;可用资源 （5-7） 若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐 量将随输入负荷的增大而下降。 有人可能会说：“只要任意增加一些资源，例如，把结点缓存的存储空间扩大，或把链 路更换为更高速率的链路，或把结点处理机的运算速度提高，就可以解决网络拥塞的问 题。”其实不然。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多 情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。 网络拥塞往往是由许多因素引起的。例如，当某个结点缓存的容量太小时，到达该结 点的分组因无存储空间暂存而不得不被丢弃。现在设想将该结点缓存的容量扩展到非常大， 于是凡到达该结点的分组均可在结点的缓存队列中排队，不受任何限制。由于输出链路的容 量和处理机的速度并未提高，因此在这队列中的绝大多数分组的排队等待时间将会大大增</p> <p>加，结果上层软件只好把它们进行重传（因为早就超时了）。由此可见，简单地扩大缓存的 存储空间同样会造成网络资源的严重浪费，因而解决不了网络拥塞的问题。 又如，处理机处理的速率太慢可能引起网络的拥塞。简单地将处理机的速率提高，可 能会使上述情况缓解一些，但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统 的各个部分不匹配。只有所有的部分都平衡了，问题才会得到解决。 拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分 组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。 这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见拥塞引起的重传并不会缓解 网络的拥塞，反而会加剧网络的拥塞。 拥塞控制与流量控制的关系密切，它们之间也存在着一些差别。所谓拥塞控制就是防 止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做 的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及 到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。但 TCP 连接的 端点只要迟迟不能收到对方的确认信息，就猜想在当前网络中的某处很可能发生了拥塞，但 这时却无法知道拥塞到底发生在网络的何处，也无法知道发生拥塞的具体原因。（是访问某 个服务器的通信量过大？还是在某个地区出现自然灾害？） 相反，流量控制往往是指点对点通信量的控制，是个端到端的问题（接收端控制发送 端）。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 可以用一个简单例子说明这种区别。设某个光纤网络的链路传输速率为1000 Gbit/s。有 一台巨型计算机向一台个人电脑以 1 Gbit/s的速率传送文件。显然，网络本身的带宽是足够 大的，因而不存在产生拥塞的问题。但流量控制却是必需的，因为巨型计算机必须经常停下 来，以便使个人电脑来得及接收。 但如果有另一个网络，其链路传输速率为1Mbit/s，而有 1000 台大型计算机连接在这 个网络上。假定其中的500台计算机分别向其余的500 台计算机以 100 kbit/s 的速率发送文 件。那么现在的问题已不是接收端的大型计算机是否来得及接收，而是整个网络的输入负载 是否超过网络所能承受的。 拥塞控制和流量控制之所以常常被弄混，是因为某些拥塞控制算法是向发送端发送 控制报文，并告诉发送端，网络已出现麻烦，必须放慢发送速率。这点又和流量控制是很相 似的。 进行拥塞控制需要付出代价。这首先需要获得网络内部流量分布的信息。在实施拥塞 控制时，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就 产生了额外开销。拥塞控制有时需要将一些资源（如缓存、带宽等）分配给个别用户（或一 些类别的用户）单独使用，这样就使得网络资源不能更好地实现共享。十分明显，在设计拥 塞控制策略时，必须全面衡量得失。 在图 5-23 中的横坐标是提供的负载（offered load），代表单位时间内输入给网络的分组数 目。因此提供的负载也称为输入负载或网络负载。纵坐标是吞吐量（throughput），代表单位 时间内从网络输出的分组数目。具有理想拥塞控制的网络，在吞吐量饱和之前，网络吞吐量 应等于提供的负载，故吞吐量曲线是45°的斜线。但当提供的负载超过某一限度时，由于网 络资源受限，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明提供的负载中 有一部分损失掉了（例如，输入到网络的某些分组被某个结点丢弃了）。虽然如此，在这种</p> <p>理想的拥塞控制作用下，网络的吞吐量仍然维持在其所能达到的最大值。 吞吐量 理想的拥塞控制 实际的拥塞控制 -无拥塞控制 死锁 提供的负载 轻度 拥塞 ← 拥塞 → 图5-23 拥塞控制所起的作用 但是，实际网络的情况就很不相同了。从图 5-23 可看出，随着提供的负载的增大，网 络吞吐量的增长速率逐渐减小。也就是说，在网络吞吐量还未达到饱和时，就已经有一部分 的输入分组被丢弃了。当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了轻度拥塞 的状态。更值得注意的是，当提供的负载达到某一数值时，网络的吞吐量反而随提供的负载 的增大而下降，这时网络就进入了拥塞状态。当提供的负载继续增大到某一数值时，网络的 吞吐量就下降到零，网络已无法工作，这就是所谓的死锁（deadlock）。 从原理上讲，寻找拥塞控制的方案无非是寻找使不等式（5-7）不再成立的条件。这或者 是增大网络的某些可用资源（如业务繁忙时增加一些链路，增大链路的带宽，或使额外的通 信量从另外的通路分流），或减少一些用户对某些资源的需求（如拒绝接受新的建立连接的 请求，或要求用户减轻其负荷，这属于降低服务质量）。但正如上面所讲过的，在采用某种 措施时，还必须考虑到该措施所带来的其他影响。 实践证明，拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。当 前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丟 失是网络发生拥塞的征兆而不是原因。在许多情况下，甚至正是拥塞控制机制本身成为引起 网络性能恶化甚至发生死锁的原因。这点应特别引起重视。 由于计算机网络是一个很复杂的系统，因此可以从控制理论的角度来看拥塞控制这个 问题。这样，从大的方面看，可以分为开环控制和闭环控制两种方法。开环控制就是在设计 网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系 统运行起来，就不再中途进行改正了。 闭环控制是基于反馈环路的概念，主要有以下几种措施： （1） 监测网络系统以便检测到拥塞在何时、何处发生。 （2） 把拥塞发生的信息传送到可采取行动的地方。 （3） 调整网络系统的运行以解决出现的问题。 有很多的方法可用来监测网络的拥塞。主要的一些指标是：由于缺少缓存空间而被丟 弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准 差，等等。上述这些指标的上升都标志着拥塞的增长。 一般在监测到拥塞发生时，要将拥塞发生的信息传送到产生分组的源站。当然，通知 拥塞发生的分组同样会使网络更加拥塞。 另一种方法是在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示 网络没有拥塞或产生了拥塞。也可以由一些主机或路由器周期性地发出探测分组，以询问拥</p> <p>塞是否发生。 此外，过于频繁地采取行动以缓和网络的拥塞，会使系统产生不稳定的振荡。但过于 迟缓地采取行动又不具有任何实用价值。因此，要采用某种折中的方法。但选择正确的时间 常数是相当困难的。 下面就来介绍更加具体的防止网络拥塞的方法。 5。8。2 TCP 的拥塞控制方法 TCP 进行拥塞控制的算法有四种，即慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）（见 2009年9月公布的草案标准 RFC 5681）。下面就介绍这些算法的原理。为了集中精力讨论拥塞控制，我们假定： （1） 数据是单方向传送的，对方只传送确认报文。 （2）接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。 1。慢开始和拥塞避免 下面讨论的拥塞控制也叫做基于窗口的拥塞控制。为此，发送方维持一个叫做拥塞窗 口 cwnd （congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动 态地在变化。发送方让自己的发送窗口等于拥塞窗口。 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一 些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有 可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络 出现的拥塞。 发送方又是如何知道网络发生了拥塞呢？我们知道，当网络发生拥塞时，路由器就要 丢弃分组。因此只要发送方没有按时收到应当到达的确认报文，也就是说，只要出现了超 时，就可以猜想网络可能出现了拥塞。现在通信线路的传输质量一般都很好，因传输出差错 而丢弃分组的概率是很小的（远小于1%）。因此，判断网络拥塞的依据就是出现了超时。 下面将讨论拥塞窗口cwnd 的大小是怎样变化的。我们从“慢开始算法”讲起。 慢开始算法的思路是这样的：当主机开始发送数据时，由于并不清楚网络的负荷情 况，所以如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞。经验证 明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增 大拥塞窗口数值。 旧的规定是这样的：在刚刚开始发送报文段时，先把初始拥塞窗口 cwnd 设置为1至2 个发送方的最大报文段 SMSS （Sender Maximum Segment Size）的数值，但新的 RFC 5681 把 初始拥塞窗口 cwnd设置为不超过2至4个SMSS 的数值。具体的规定如下： 若 SMSS&gt;2190 字节， 则设置初始拥塞窗口cwnd = 2 × SMSS 字节，且不得超过2个报文段。 若（SMSS &gt; 1095字节）且（SMSS≤2190字节）， 则设置初始拥塞窗口 cwnd = 3 × SMSS 字节，且不得超过3个报文段。 若 SMSS ≤ 1095 字节， 则设置初始拥塞窗口 cwnd = 4 × SMSS 字节，且不得超过4个报文段。 可见这个规定就是限制初始拥塞窗口的字节数。</p> <p>慢开始规定，在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值。更具体些，就是 拥塞窗口 cwnd 每次的增加量 = min （N， SMSS） （5-8） 其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。不难看 出，当N&lt;SMSS时，拥塞窗口每次的增加量要小于 SMSS。 用这样的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 下面用例子说明慢开始算法的原理。请注意，虽然实际上 TCP 是用字节数作为窗口大 小的单位。但为叙述方便起见，我们用报文段的个数作为窗口大小的单位，这样可以使用较 小的数字来阐明拥塞控制的原理。 在一开始发送方先设置cwnd = 1，发送第一个报文段 Mı，接收方收到后确认Mı。发送 方收到对 M的确认后，把cwnd 从1增大到2，于是发送方接着发送M和M3 两个报文 段。接收方收到后发回对 M， 和M，的确认。发送方每收到一个对新报文段的确认（重传的 不算在內）就使发送方的拥塞窗口加 1，因此发送方在收到两个确认后，cwnd 就从 2 增大 到4，并可发送Ma~M，共4个报文段（见图5-24）。因此使用慢开始算法后，每经过一个 传输轮次（transmission round），拥塞窗口 cwnd 就加倍。 发送方 接收方 cwnd = 1 发送 M 确认 Mi 轮次 1 cwnd = 2| 发送M2~M3 确认 Mq~M3 轮次2 cwnd=4 发送Ma~M-| 确认Mg~M， 轮次3 cwnd = 8 发送Mg~M15 t 图5-24 发送方每收到一个确认就把窗口 cwnd 加1 这里我们使用了一个名词——传输轮次。从图 5-24 可以看出，一个传输轮次所经历的 时间其实就是往返时间 RTT （请注意，RTT 并非是恒定的数值）。使用“传输轮次”是更加 强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一 个字节的确认。例如，拥塞窗口 cwnd 的大小是4个报文段，那么这时的往返时间 RTT 就是 发送方连续发送4个报文段，并收到这4个报文段的确认，总共经历的时间。 我们还要指出，慢开始的“慢”并不是指 cwnd 的增长速率慢，而是指在 TCP 开始发 送报文段时先设置 cwnd = 1，使得发送方在开始时只发送一个报文段（目的是试探一下网络 的拥塞情况），然后再逐渐增大 cwnd。这当然比设置大的 cwnd 值一下子把许多报文段注入 到网络中要“慢得多”。这对防止网络出现拥塞是一个非常好的方法。 顺便指出，图 5-24只是为了说明慢开始的原理。在TCP 的实际运行中，发送方只要收 到一个对新报文段的确认，其拥塞窗口 cwnd 就立即加 1， 并可以立即发送新的报文段，而 不需要等这个轮次中所有的确认都收到后（如图5-24所示的那样）再发送新的报文段。</p> <p>为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量（如何设置 ssthresh，后面还要讲）。慢开始门限 ssthresh 的用法如下： 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就 把发送方的拥塞窗口 cwnd 加1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段 就有“加法增大”AI （Additive Increase）的特点。这表明在拥塞避免阶段，拥塞窗口cwnd 按 线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 图 5-25 用具体例子说明了在拥塞控制的过程中，TCP 的拥塞窗口 cwnd 是怎样变化 的。图中的的数字●至是特别要注意的几个点。现假定TCP 的发送窗口等于拥塞窗口。 当 TCP 连接进行初始化时，把拥塞窗口 cwnd置为1。为了便于理解，图中的窗口单位 不使用字节而使用报文段的个数。在本例中，慢开始门限的初始值设置为 16 个报文段，即 ssthresh === 16。在执行慢开始算法时，发送方每收到一个对新报文段的确认ACK，就把拥塞 窗口值加 1，然后开始下一轮的传输（请注意，图5-25的横坐标是传输轮次，不是时间）。 因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（图中的点心，此时拥塞窗口 cwnd 16），就改为执行拥塞避免算法，拥塞窗口 按线性规律增长。但请注意，“拥塞避免”并非完全能够避免了拥塞。“拥塞避免”是说把 拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 = 拥塞窗口 cwnd 24 2 超时 20 拥塞避免 ssthresh -16 的初始值 12 6 拥塞避免 3-ACK 8 拥塞避免 -TCP Reno 版本 慢开始 4 慢开始 0 0 2 4 6 8 10 12 14 16 18 20 22 24 传输轮次 图5-25 TCP 拥塞窗口 cwnd在拥塞控制时的变化情况 === 当拥塞窗口 cwnd 24 时，网络出现了超时（图中的点●），发送方判断为网络拥塞。 于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。 按照慢开始算法，发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1。 当拥塞窗口 cwnd = ssthresh = 12 时（图中的点●，这是新的 ssthresh 值），改为执行拥塞避 ① 注：请注意，因为现在是讲原理，把窗口的单位改为报文段的个数。实际上应当是“拥塞窗口仅增加一个 MSS 的大 小，单位是字节”。在具体实现拥塞避免算法的方法时可以这样来完成：只要收到一个新的确认，就使拥塞窗口 cwnd 增加（MSS × MSS / cwnd）个字节。例如，假定cwnd等于10个MSS 的长度，而MSS是1460字节。发送方可一连发送14600 字节（即 10 个报文段）。假定接收方每收到一个报文段就发回一个确认。于是发送方每收到一个新的确认，就把拥塞窗口稍微增大一些，即 增大 0。1 MSS = 146 字节。经过一个往返时间 RTT（或一个传输轮次）后，发送方共收到10个新的确认，拥塞窗口就增大了 1460 字节，正好是一个 MSS 的大小。</p> <p>免算法，拥塞窗口按线性规律增大。 当拥塞窗口 cwnd = 16时（图中的点●），出现了一个新的情况，就是发送方一连收到3 个对同一个报文段的重复确认（图中记为3-ACK）。关于这个问题要解释如下。 有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收 不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开 始，把拥塞窗口 cwnd又设置为1，因而降低了传输效率。 采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要 求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序 的报文段也要立即发出对已收到的报文段的重复确认。如图5-26 所示，接收方收到了 Mı 和 M 后都分别及时发出了确认。现假定接收方没有收到M，但却收到了Ma。本来接收方可以 什么都不做。但按照快重传算法，接收方必须立即发送 M的重复确认，以便让发送方及 早知道接收方没有收到报文段 M3。发送方接着发送 M5 和 M。。接收方收到后也仍要再次分 别发出对 M2的重复确认。这样，发送方共收到了接收方的4个对M2的确认，其中后3个 都是重复确认。快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没 有收到报文段 M3，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方 也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约 20%。 发送方 接收方 发送 M。 发送 M2 发送 M3 确认 M 确认 M2 丢失!! 收到3个连续的 对M 的重复确认 立即快重传 M， 发送 M4 发送 M 发送 M。 重复确认 M 重复确认 M 重复确认 M 发送 M7 立即快重传 M， t t 图5-26 快重传的示意图 因此，在图 5-25 中的点，发送方知道现在只是丢失了个别的报文段。于是不启动慢 开始，而是执行快恢复算法。这时，发送方调整门限值 ssthresh = = cwnd / 2 = 8，同时设置拥 塞窗口 cwnd = ssthresh=8（见图 5-25 中的点●），并开始执行拥塞避免算法。 在图 5-25 中还标注有“TCP Reno 版本”，表示区别于老的 TCP Tahao 版本。 请注意，也有的快恢复实现是把快恢复开始时的拥塞窗口 cwnd 值再增大一些（增大3 个报文段的长度），即等于新的 ssthresh + 3 × MSS。这样做的理由是：既然发送方收到3个 重复的确认，就表明有3个分组已经离开了网络。这3个分组不再消耗网络的资源而是停留 在接收方的缓存中（接收方发送出 3 个重复的确认就证明了这个事实）。可见现在网络中并 不是堆积了分组而是减少了3个分组。因此可以适当把拥塞窗口扩大些。</p> <p>从图 5-25 可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的，这常称为加 法增大 AI （Additive Increase）。而一旦出现超时或3个重复的确认，就要把门限值设置为当 前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD （Multiplicative Decrease）。二者合在一起就是所谓的AIMD算法。 采用这样的拥塞控制方法使得 TCP 的性能有明显的改进[STEV94][RFC 5681]。 根据以上所述，TCP的拥塞控制可以归纳为图5-27的流程图。这个流程图就比图 5-25 所示的特例要更加全面些。例如，图5-25 没有说明在慢开始阶段如果出现了超时（即出现 了网络拥塞）或出现 3-ACK，发送方应采取什么措施。但从图 5-27 的流程图就可以很明确 地知道发送方应采取的措施。 ssthresh = cwnd / 2 连接建立 cwnd = 1 慢开始 超时 拥塞窗口cwnd = 1 按指数规律增大 3个重复 的 ACK cwndssthresh 拥塞避免 3个重复 超时 拥塞窗口 cwnd 按线性规律增大 的 ACK 连接终止 ssthresh = cwnd / 2 cwnd = ssthresh 图5-27 TCP的拥塞控制的流程图 在这一节的开始我们就假定了接收方总是有足够大的缓存空间，因而发送窗口的大小 由网络的拥塞程度来决定。但实际上接收方的缓存空间总是有限的。接收方根据自己的接收 能力设定了接收方窗口 rwnd，并把这个窗口值写入 TCP 首部中的窗口字段，传送给发送 方。因此，接收方窗口又称为通知窗口（advertised window）。因此，从接收方对发送方的流 量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收方窗口值 rwnd。 如果把本节所讨论的拥塞控制和接收方对发送方的流量控制一起考虑，那么很显然， 发送方的窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一 个，也就是说： 发送方窗口的上限值 = ： Min [rwnd， cwnd] （5-9）式指出： （5-9） 当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。 反之，当 cwnd &lt; rwnd时，则是网络的拥塞程度限制发送方窗口的最大值。 也就是说， rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。 5。8。3 主动队列管理 AQM 上一节讨论的 TCP 拥塞控制并没有和网络层采取的策略联系起来。其实，它们之间有</p> <p>着密切的关系。 例如，假定一个路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的 数据部分（即 TCP 报文段）经过很长时间才能到达终点，结果引起发送方对这些报文段的 重传。根据前面所讲的，重传会使 TCP 连接的发送端认为在网络中发生了拥塞。于是在 TCP 的发送端就采取了拥塞控制措施，但实际上网络并没有发生拥塞。 网络层的策略对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。在最简单的情 况下，路由器的队列通常都是按照“先进先出”FIFO （First In First Out） 的规则处理到来的 分组。由于队列长度总是有限的，因此当队列已满时，以后再到达的所有分组（如果能够继 续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略（tail-drop policy）。 路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入拥塞控制的慢开始状态，结果使 TCP 连接的发送方突然把数据的发送速率降低到 很小的数值。更为严重的是，在网络中通常有很多的 TCP 连接（它们有不同的源点和终 点），这些连接中的报文段通常是复用在网络层的IP 数据报中传送。在这种情况下，若发生 了路由器中的尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这许多TCP 连接在 同一时间突然都进入到慢开始状态。这在 TCP 的术语中称为全局同步（global syncronization）。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通 信量又突然增大很多。 为了避免发生网络中的全局同步现象，在1998年提出了主动队列管理 AQM （Active Queue Management）。所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不 得不丢弃后面到达的分组。这样就太被动了。应当在队列长度达到某个值得警惕的数值时 （即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。这样就提醒了发送方放慢 发送的速率，因而有可能使网络拥塞的程度减轻，甚至不出现网络拥塞。AQM 可以有不同 实现方法，其中曾流行多年的就是随机早期检测 RED （Random Early Detection）。RED 还有 几个不同的名称，如 Random Early Drop 或Random Early Discard （随机早期丢弃）。 实现 RED 时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个 分组到达时，RED 就按照规定的算法先计算当前的平均队列长度。 （1） 若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。 （2） 若平均队列长度超过最大门限，则把新到达的分组丢弃。 （3）若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率把新到达的分 组丢弃（这就体现了丢弃分组的随机性）。 由此可见，RED 不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃， 而是在检测到网络拥塞的早期征兆时（即路由器的平均队列长度达到一定数值时），就以概 率p 丢弃个别的分组，让拥塞控制只在个别的 TCP 连接上进行，因而避免发生全局性的拥 塞控制。 在 RED 的操作中，最难处理的就是丢弃概率的选择，因为p并不是个常数。对每一 个到达的分组，都必须计算丢弃概率 p 的数值。IETF 曾经推荐在互联网中的路由器使用 RED 机制[RFC 2309]，但多年的实践证明，RED 的使用效果并不太理想。因此，在 2015 年 公布的 RFC 7567已经把过去的 RFC2309 列为“陈旧的”，并且不再推荐使用RED。对路 由器进行主动队列管理 AQM 仍是必要的。AQM 实际上就是对路由器中的分组排队进行智</p> <p>能管理，而不是简单地把队列的尾部丢弃。现在已经有几种不同的算法来代替旧的 RED，但 都还在实验阶段。目前还没有一种算法能够成为IETF 的标准，读者可注意这方面的进展。 5。9 TCP 的运输连接管理 TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的建立和释 放是每一次面向连接的通信中必不可少的过程。因此，运输连接就有三个阶段，即：连接建 立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。 在TCP 连接建立过程中要解决以下三个问题： （1） 要使每一方能够确知对方的存在。 （2）要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以 及服务质量等）。 （3） 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。 TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client）， 而被动等待连接建立的应用进程叫做服务器（server）。 5。9。1 TCP 连接建立 TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。 图 5-28 画出了三报文握手 建立TCP连接的过程。 客戶 A CLOSED 主动打开 SYN = 1， seq = x SYN- SENT | SYN = 1， ACK = 1， seq = y， ack= x + 服务器 B CLOSED 被动打开 LISTEN SYN- ACK = 1， seq = x + 1， ack = y + 1 RCVD ESTAB- LISHED ESTAB- 数据传送 LISHED 图 5-28 用三报文握手建立TCP 连接 假定主机 A 运行的是TCP 客户程序，而 B 运行 TCP 服务器程序。最初两端的 TCP 进</p> <p>程都处于 CLOSED （关闭）状态。图中在主机下面的方框分别是 TCP 进程所处的状态。请 注意，在本例中，A主动打开连接，而B被动打开连接。 一开始，B 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请 求。然后服务器进程就处于 LISTEN（收听）状态，等待客户的连接请求。如有，即作出 响应。 = A 的TCP 客户进程也是首先创建传输控制模块 TCB。然后，在打算建立TCP 连接时， 向 B 发出连接请求报文段，这时首部中的同步位 SYN = 1，同时选择一个初始序号 seq = x。TCP 规定，SYN报文段（即SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。 这时，TCP 客户进程进入SYN-SENT（同步已发送）状态。 B 收到连接请求报文段后，如同意建立连接， 则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。 请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务器进程进 入SYN-RCVD（同步收到）状态。 TCP 客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号 ack = y + 1，而自己的序号 seq = x + 1。TCP 的标准规定，ACK报文段可以携带数据。但如 果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq = x + 1。这 时，TCP 连接已经建立，A进入 ESTABLISHED （已建立连接）状态。 当 B 收到 A 的确认后，也进入ESTABLISHED状态。 上面给出的连接建立过程叫做三报文握手。请注意，在图5-28中B发送给A 的报文 段，也可拆成两个报文段。可以先发送一个确认报文段（ACK： 1， ack = x + 1），然后再发 送一个同步报文段（SYN = 1， seq = y）。这样的过程就变成了四报文握手，但效果是一 样的。 为什么 A 最后还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然 又传送到了B，因而产生错误。 所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况，A 发出连接请 求，但因连接请求报文丢失而未收到确认。于是 A 再重传一次连接请求。后来收到了确 认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中 第一个丢失，第二个到达了 B，没有“已失效的连接请求报文段”。 现假定出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某 些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早 已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是A又发出一次新的连 接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用报文握手，那么只要 B 发出确认，新的连接就建立了。 由于现在 A 并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B 发送数 据。但 B 却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样 白白浪费了。</p> <p>采用三报文握手的办法，可以防止上述现象的发生。例如在刚才的异常情况下，A不会 向 B 的确认发出确认。B 由于收不到确认，就知道A并没有要求建立连接。 5。9。2 TCP的连接释放 TCP 连接释放过程比较复杂，我们仍结合双方状态的改变来阐明连接释放的过程。 数据传输结束后，通信的双方都可释放连接。现在A和B都处于 ESTABLISHED 状态 （图5-29）。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u，它等于前面 已传送过的数据的最后一个字节的序号加 1。这时 A 进入 FIN-WAIT-1（终止等待 1）状 态，等待 B 的确认。请注意，TCP 规定，FIN报文段即使不携带数据，它也消耗掉一个 序号。 客戶 A ESTAB- 数据传送 主动关闭LISHED FIN = 1， seq =u FIN- WAIT-1 FIN- WAIT-2 等待 2MSL TIME- WAIT CLOSED ACK = 1， seq = v， ack= u + 1 数据传送 FIN = 1， ACK = 1， seq = w， ack= u + 1 服务器 B 通知 ESTAB- 应用 LISHED 进程 CLOSE- WAIT 被动关闭 LAST- ACK = 1， seq = u+1，ack=w + 1 ACK CLOSED 图5-29 TCP 连接释放的过程 B收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号 是 v，等于 B 前面已传送过的数据的最后一个字节的序号加1。然后 B 就进入 CLOSE- WAIT （关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到 B 这个方 向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发 送了，但 B 若发送数据，A仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这 个状态可能会持续一段时间。 A 收到来自 B 的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待 B 发出的连接 释放报文段。 若 B 已经没有要向A发送的数据，其应用进程就通知 TCP 释放连接。这时B 发出的连 接释放报文段必须使 FIN = 1。现假定 B 的序号为w（在半关闭状态 B 可能又发送了一些数 据）。B还必须重复上次已发送过的确认号 ack = u+1。这时B 就进入 LAST-ACK（最后确 认）状态，等待 A 的确认。 A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK 置 1，</p> <p>确认号 ack = w + 1，而自己的序号是 seq = u + 1 （根据 TCP 标准，前面发送过的 FIN 报文 段要消耗一个序号）。然后进入到 TIME-WAIT（时间等待）状态。请注意，现在 TCP 连接 还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间 2MSL 后，A 才进 入到 CLOSED 状态。时间 MSL 叫做最长报文段寿命（Maximum Segment Lifetime），RFC 793 建议设为2分钟。但这完全是从工程上来考虑的，对于现在的网络，MSL=2分钟可能太长 了一些。因此 TCP 允许不同的实现可根据具体情况使用更小的 MSL 值。因此，从 A 进入 到 TIME-WAIT状态后，要经过4分钟才能进入到 CLOSED 状态，才能开始建立下一个新 的连接。当A撤销相应的传输控制块 TCB后，就结束了这次的 TCP 连接。 为什么 A 在 TIME-WAIT状态必须等待 2MSL 的时间呢？这有两个理由。 第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能 丢失，因而使处在LAST-ACK 状态的B收不到对已发送的FIN + ACK 报文段的确认。B会 超时重传这个 FIN + ACK 报文段，而A就能在2MSL 时间内收到这个重传的FIN + ACK 报 文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完ACK 报文段后 立即释放连接，那么就无法收到B重传的FIN+ACK 报文段，因而也不会再发送一次确认 报文段。这样，B就无法按照正常步骤进入 CLOSED 状态。 第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最 后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报 文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。 B 只要收到了 A 发出的确认，就进入 CLOSED 状态。同样，在撤销相应的传输控 制块 TCB 后，就结束了这次的TCP连接。我们注意到，B结束TCP 连接的时间要比A早 一些。 上述的TCP 连接释放过程是四报文握手。 除时间等待计时器外，TCP 还设有一个保活计时器（keepalive timer）。设想有这样的情 况：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然出故障。显然，服务 器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这 就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置 通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若一连发送 10个探测报文段后仍无客户的响应，服务器就认为客户端出 了故障，接着就关闭这个连接。 5。9。3 TCP 的有限状态机 为了更清晰地看出 TCP 连接的各种状态之间的关系，图5-30 给出了 TCP 的有限状态 机。图中每一个方框即 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所 使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明 引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。请注意图中有三种不同的箭 头。粗实线箭头表示对客户进程的正常变迁。粗虚线箭头表示对服务器进程的正常变迁。另 一种细线箭头表示异常变迁。</p> <p>起点 CLOSED 主动打开 发送 SYN 被动打开 关闭 收到 SYN LISTEN 发送SYN+ACK 被动打开 收到 RST 发送 SYN 收到SYN，发送SYN+ACK 关闭 或超时 SYN-RCVD 同时打开 ▶收到ACK -SYN-SENT 主动打开 「收到SYN+ACK 发送 ACK 数据传送 被动关闭 关闭 阶段 收到 FIN 发送 FIN 发送 ACK ESTABLISHED ——- CLOSE-WAIT 关闭 发送 FIN 主动关闭 关闭 发送 FIN “ 收到 FIN 同时关闭 发送 ACK FIN-WAIT-1 CLOSING 收到ACK 收到 FIN+ACK LAST-ACK —– 发送 ACK 收到ACK 「收到ACK 收到 FIN 发送 ACK FIN-WAIT-2 TIME-WAIT 等待 2MSL 时间后 图5-30 TCP的有限状态机 我们可以把图 5-30 和前面的图5-28、图5-29 对照起来看。在图5-28 和图 5-29 中左边 客户进程从上到下的状态变迁，就是图5-30 中粗实线箭头所指的状态变迁。而在图 5-28 和 5-29 右边服务器进程从上到下的状态变迁，就是图5-30中粗虚线箭头所指的状态变迁。 还有一些状态变迁，例如连接建立过程中的从 LISTEN 到 SYN-SENT 和从 SYN-SENT 到 SYN-RCVD。读者可分析在什么情况下会出现这样的变迁（见习题5-40）。 本章的重要概念 • 运输层提供应用进程间的逻辑通信，也就是说，运输层之间的通信并不是真正在两 个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节（如网络拓 扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体 之间有一条端到端的逻辑通信信道。 • 242 • 网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑 通信。 运输层有两个主要的协议：TCP 和 UDP。它们都有复用和分用，以及检错的功 能。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供 尽最大努力服务），但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当 运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。</p> <p>运输层用一个 16位端口号来标志一个端口。端口号只具有本地意义，它只是为了 标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同 计算机中，相同的端口号是没有关联的。 两台计算机中的进程要互相通信，不仅要知道对方的IP地址（为了找到对方的计 算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。 运输层的端口号分为服务器端使用的端口号（0~1023指派给熟知端口，1024 49151 是登记端口号）和客户端暂时使用的端口号（49152~65535）。 ~ UDP 的主要特点是：（1）无连接；（2）尽最大努力交付；（3） 面向报文；（4） 无拥塞 控制；（5） 支持一对一，一对多、多对一和多对多的交互通信；（6）首部开销小 （只有四个字段：源端口、目的端口、长度、检验和）。 • TCP 的主要特点是：（1）面向连接；（2）每一条 TCP 连接只能是点对点的（一对 一）；（3） 提供可靠交付的服务；（4）提供全双工通信；（5）面向字节流。 • TCP 用主机的 IP 地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫 做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。 • • 停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停 止发送，等待对方的确认。在收到确认后再发送下一个分组。分组需要进行编号。 超时重传是指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组 （认为刚才发送的分组丢失了）。因此每发送完一个分组需要设置一个超时计时 器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式 常称为自动重传请求 ARQ。 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送 确认。 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内 的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认， 对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已正确收 到了。 TCP 报文段首部的前 20 个字节是固定的，后面有 4N 字节是根据需要而增加的选 项（N 是整数）。在一个TCP 连接中传送的字节流中的每一个字节都按顺序编号。 首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。 TCP 首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若 确认号为N，则表明：到序号N-1为止的所有数据都已正确收到。 TCP 首部中的窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态 变化着的。 • TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后 沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许 发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移 （收到了新的确认）。发送窗口前沿通常是不断向前移动的。 流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 。 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络 的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入到网络</p>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https://feng-zhang0712.github.io//blog/2024/2024-09-15-application-layer/" rel="alternate" type="text/html" title=""/><published>2024-09-21T08:55:57+00:00</published><updated>2024-09-21T08:55:57+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/2024-09-15-application-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/2024-09-15-application-layer/"><![CDATA[<p>第6章 应用层</p> <p>在前五章我们已经详细地讨论了计算机网络提供通信服务的过程。但是我们还没有讨 论这些通信服务是如何提供给应用进程来使用的。本章讨论各种应用进程通过什么样的应用 层协议来使用网络所提供的这些通信服务。 在上一章，我们学习了运输层为应用进程提供了端到端的通信服务。但不同的网络 应用的应用进程之间，还需要有不同的通信规则。因此在运输层协议之上，还需要有应用层 协议（application layer protocol）。这是因为，每个应用层协议都是为了解决某一类应用问题， 而问题的解决又必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成。应 用进程之间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规 则。具体来说，应用层协议应当定义： 应用进程交换的报文类型，如请求报文和响应报文。 各种报文类型的语法，如报文中的各个字段及其详细描述。 字段的语义，即包含在字段中的信息的含义。 进程何时，如何发送报文，以及对报文进行响应的规则。 互联网公共领域的标准应用的应用层协议是由 RFC 文档定义的，大家都可以使用。例 如，万维网的应用层协议 HTTP（超文本传输协议）就是由RFC 7230 定义的。如果浏览器 开发者遵守 RFC 7230标准，所开发出来的浏览器就能够访问任何遵守该标准的万维网服务 器并获取相应的万维网页面。在互联网中还有很多其他应用的应用层协议不是公开的，而是 专用的。例如，很多现有的P2P文件共享系统使用的就是专用应用层协议。 请注意，应用层协议与网络应用并不是同一个概念。应用层协议只是网络应用的一部 分。例如，万维网应用是一种基于客户/服务器体系结构的网络应用。万维网应用包含很多 部件，有万维网浏览器、万维网服务器、万维网文档的格式标准，以及一个应用层协议。万 维网的应用层协议是HTTP，它定义了在万维网浏览器和万维网服务器之间传送的报文类 型、格式和序列等规则。而万维网浏览器如何显示一个万维网页面，万维网服务器是用多线 程还是用多进程来实现，则都不是HTTP所定义的内容。 应用层的许多协议都是基于客户服务器方式。即使是P2P对等通信方式，实质上也是 一种特殊的客户服务器方式。这里再明确一下，客户（client）和服务器（server）都是指通信中所 涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。这里最主 要的特征就是：客户是服务请求，服务器是服务提供方。 下面先讨论许多应用协议都要使用的域名系统。在介绍了文件传送协议和远程登录协 议后，再重点介绍万维网的工作原理及其主要协议。由于万维网的出现使互联网得到了飞速 的发展，因此万维网在本章中占有最大的篇幅，也是本章的重点。接着讨论用户经常使用的 电子邮件。最后，介绍有关网络管理方面的问题以及有关网络编程的基本概念。对应用层更 深入的学习可参阅[COME15][COME06][TANE11]及有关标准。 本章最重要的内容是： （1） 域名系统 DNS——从域名解析出 IP 地址。 （2） 万维网和 HTTP协议，以及万维网的两种不同的信息搜索引擎。 （3） 电子邮件的传送过程，SMTP 协议和 POP3 协议、IMAP 协议使用的场合。 （4） 动态主机配置协议 DHCP的特点。 （5） 网络管理的三个组成部分（SNMP 本身、管理信息结构 SMI 和管理信息库 MIB） 的作用。 （6）系统调用和应用编程接口的基本概念。 （7）P2P文件系统。 6。1 域名系统 DNS 6。1。1 域名系统概述 域名系统 DNS（Domain Name System）是互联网使用的命名系统，用来把便于人们使用 的机器名字转换为IP地址。域名系统其实就是名字系统。为什么不叫“名字”而叫“域 名”呢？这是因为在这种互联网的命名系统中使用了许多的“域”（domain），因此就出现了 “域名”这个名词。 “域名系统”很明确地指明这种系统是用在互联网中的。 许多应用层软件经常直接使用域名系统 DNS。虽然计算机的用户只是间接而不是直接 使用域名系统，但DNS 却为互联网的各种网络应用提供了核心服务。 用户与互联网上某台主机通信时，必须要知道对方的IP地址。然而用户很难记住长达 32 位的二进制主机地址。即使是点分十进制IP地址也并不太容易记忆。但在应用层为了便 于用户记忆各种网络应用，连接在互联网上的主机不仅有IP地址，而且还有便于用户记忆 的主机名字。域名系统DNS能够把互联网上的主机名字转换为IP地址。 早在 ARPANET 时代，整个网络上只有数百台计算机，那时使用一个叫做hosts 的文 件，列出所有主机名字和相应的IP 地址。只要用户输入一台主机名字，计算机就可很快地 把这台主机名字转换成机器能够识别的二进制IP 地址。 为什么机器在处理IP数据报时要使用IP地址而不使用域名呢？这是因为IP 地址的长 度是固定的32 位（如果是IPv6地址，那就是128位，也是定长的），而域名的长度并不是 固定的，机器处理起来比较困难。 从理论上讲，整个互联网可以只使用一个域名服务器，使它装入互联网上所有的主机 名，并回答所有IP地址的查询。然而这种做法并不可取。因为互联网规模很大，这样的 域名服务器肯定会因过负荷而无法正常工作，而且一旦域名服务器出现故障，整个互联网就 会瘫痪。因此，早在 1983 年互联网就开始采用层次树状结构的命名方法，并使用分布式的 域名系统 DNS。DNS 的互联网标准是RFC1034， 1035。 互联网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户服务器方 式。DNS 使大多数名字都在本地进行解析（resolve），仅少量解析需要在互联网上通信，因 此 DNS 系统的效率很高。由于 DNS是分布式系统，即使单个计算机出了故障，也不会妨碍 ① 注：在 TCP/IP 的文档中，这种地址转换常称为地址解析。解析就是转换的意思，地址解析可能会包含多次的查询请求 和回答过程。 • 252 •</p> <p>Page 263 整个 DNS 系统的正常运行。 域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序（可简称为域名服务 器）共同完成的。域名服务器程序在专设的结点上运行，而人们也常把运行域名服务器程序 的机器称为域名服务器。 域名到 IP 地址的解析过程的要点如下：当某一个应用进程需要把主机名解析为 IP 地址 时，该应用进程就调用解析程序（resolver），并成为 DNS 的一个客户，把待解析的域名放在 DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器（使用 UDP 是为了减少开 销）。本地域名服务器在查找域名后，把对应的IP 地址放在回答报文中返回。应用进程获得 目的主机的 IP 地址后即可进行通信。 若本地域名服务器不能回答该请求，则此域名服务器就暂时成为 DNS 中的另一个客 户，并向其他域名服务器发出查询请求。这种过程直至找到能够回答该请求的域名服务器为 止。上述这种查找过程，后面还要进一步讨论。 6。1。2 互联网的域名结构 早期的互联网使用了非等级的名字空间，其优点是名字简短。但当互联网上的用户数 急剧增加时，用非等级的名字空间来管理一个很大的而且是经常变化的名字集合是非常困难 的。因此，互联网后来就采用了层次树状结构的命名方法，就像全球邮政系统和电话系统那 样。采用这种命名方法，任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结 构的名字，即域名（domain name）。这里，“域”（domain）是名字空间中一个可被管理的划 分。域还可以划分为子域，而子域还可继续划分为子域的子域，这样就形成了顶级域、二级 域、三级域，等等。 从语法上讲，每一个域名都由标号（label）序列组成，而各标号之间用点隔开（请注意， 是小数点“。”，不是中文的句号“。”）。例如下面的域名 mail。cctv。com 三级域名。二级域名。顶级域名 就是中央电视台用于收发电子邮件的计算机（即邮件服务器）的域名，它由三个标号 组成，其中标号com 是顶级域名，标号 cctv 是二级域名，标号 mail 是三级域名。 DNS 规定，域名中的标号都由英文字母和数字组成，每一个标号不超过63 个字符（但 为了记忆方便，最好不要超过 12 个字符），也不区分大小写字母（例如，CCTV 或 cctv 在 域名中是等效的）。标号中除连字符（-）外不能使用其他的标点符号。级别最低的域名写在最 左边，而级别最高的顶级域名则写在最右边。由多个标号组成的完整域名总共不超过255个 字符。DNS 既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么 意思。各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由 ICANN 进行管 理。用这种方法可使每一个域名在整个互联网范围内是唯一的，并且也容易设计出一种查找 域名的机制。 需要注意的是，域名只是个逻辑概念，并不代表计算机所在的物理地点。变长的域名 和使用有助记忆的字符串，是为了便于人使用。而 IP 地址是定长的32位二进制数字则非常 便于机器进行处理。这里需要注意，域名中的“点”和点分十进制IP地址中的“点”并无 一一对应的关系。点分十进制 IP 地址中一定是包含三个“点”，但每一个域名中“点”的数 • 253 •</p> <p>Page 264 目则不一定正好是三个。 据 2012 年 5 月的统计[W-IANA-root]，现在顶级域名 TLD （Top Level Domain）已有 326 个。原先的顶级域名共分为三大类： （1）国家顶级域名 nTLD：采用 ISO 3166 的规定。如： cn 表示中国，us 表示美国，uk表 示英国，等等。国家顶级域名又常记为 ccTLD （cc 表示国家代码 country-code）。到 2012 年5月为止，国家顶级域名总数已达 296 个。 （2） 通用顶级域名 gTLD： 到 2006 年 12 月为止，通用顶级域名的总数已经达到 20 个。 最先确定的通用顶级域名有7个，即： com（公司企业），net（网络服务机构），org （非营利性组织），int（国际组织），edu （美国专用的教育机构），gov （美国的政府部门），mil 表示 （美国的军事部门）。 以后又陆续增加了13个通用顶级域名： aero（航空运输企业），asia（亚太地区），biz（公司和企业），cat （使用加泰隆人的语 言和文化团体），coop（合作团体），info（各种情况）， jobs（人力资源管理者），mobi（移 动产品与服务的用户和提供者），museum（博物馆）， name（个人） ，pro（有证书的专业人 员）， tel（Telnic股份有限公司），travel（旅游业）。 （3） 基础结构域名（infrastructure domain）：这种顶级域名只有一个，即 arpa，用于反向域 名解析，因此又称为反向域名。 值得注意的是，ICANN于2011年6月20日在新加坡会议上正式批准新顶级域名（New gTLD），因此任何公司、机构都有权向ICANN 申请新的顶级域。新顶级域名的后缀特点，使 企业域名具有了显著的、强烈的标志特征。因此，新顶级域名被认为是真正的企业网络商 标。新顶级域名是企业品牌战略发展的重要内容，其申请费很高（18 万美元），并且在 2013 年开始启用。目前已有一些由两个汉字组成的中文的顶级域名出现了，例如，商城、公司、 新闻等。到2016年，在ICANN注册的中文顶级域名已有60个[W-IANA-root]。 在国家顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为 jp 的日 本，将其教育和企业机构的二级域名定为ac和co，而不用edu 和 com。 我国把二级域名划分为“类别域名”和“行政区域名”两大类。 “类别域名”共 7 个，分别为：ac（科研机构），com（工、商、金融等企业），edu （中国的教育机构），gov （中国的政府机构），mil（中国的国防机构），net（提供互联网络 服务的机构），org （非营利性的组织）。 “行政区域名”共 34 个，适用于我国的各省、自治区、直辖市。例如：bj （北京市）， js （江苏省），等等。 关于我国的互联网络发展现状以及各种规定（如申请域名的手续），均可在中国互联网 网络信息中心 CNNIC 的网址上找到[W-CNNIC]。 用域名树来表示互联网的域名系统是最清楚的。图 6-1 是互联网域名空间的结构，它实 ① 注：实际上，国家顶级域名也包括某些地区的域名，如我国的香港特区（hk）和台湾省（tw）也都是 ccTLD 里面的顶 级域名。此外，国家顶级域名可以使用一个国家自己的文字。例如，中国可以有“。cn”、“中国”和繁体字的“中國”这三种不 同形式的域名。 • 254 •</p> <p>Page 265 际上是一个倒过来的树，在最上面的是根，但没有对应的名字。根下面一级的节点就是最 高一级的顶级域名（由于根没有名字，所以在根下面一级的域名就叫做顶级域名）。顶级域 名可往下划分子域，即二级域名。再往下划分就是三级域名、四级域名，等等。图 6-1 列举 了一些域名作为例子。凡是在顶级域名 com 下注册的单位都获得了一个二级域名。图中给 出的例子有：中央电视台 cctv，以及IBM、华为等公司。在顶级域名cn（中国）下面举出 了几个二级域名，如：bj，edu 以及 com。在某个二级域名下注册的单位就可以获得一个三 级域名。图中给出的在 edu 下面的三级域名有： tsinghua （清华大学）和 pku（北京大学）。 一旦某个单位拥有了一个域名，它就可以自己决定是否要进一步划分其下属的子域，并且不 必由其上级机构批准。图中 cctv（中央电视台）和 tsinghua （清华大学）都分别划分了自己 的下一级的域名 mail 和 www（分别是三级域名和四级域名）。域名树的树叶就是单台计 算机的名字，它不能再继续往下划分子域了。 根 顶级域名 aero com net org edu gov 二级域名 cctv • • • ibm huawei bi edu com 三级域名 mail 。 。 。 WWW tsinghua 。。。 pku 四级域名 mail 。。。 WWW 图6-1 互联网的域名空间 应当注意，虽然中央电视台和清华大学都各有一台计算机取名为 mail，但它们的域名 并不一样，因为前者是 mail。cctv。com，而后者是 mail。tsinghua。edu。cn。因此，即使在世界上 还有很多单位的计算机取名为mail，但是它们在互联网中的域名都必须是唯一的。 这里还要强调指出，互联网的名字空间是按照机构的组织来划分的，与物理的网络无 关，与 IP 地址中的“子网”也没有关系。 6。1。3 域名服务器 上面讲述的域名体系是抽象的。但具体实现域名系统则是使用分布在各地的域名服务 器。从理论上讲，可以让每一级的域名都有一个相对应的域名服务器，使所有的域名服务器 构成和图 6-1 相对应的“域名服务器树”的结构。但这样做会使域名服务器的数量太多，使 域名系统的运行效率降低。因此DNS 就采用划分区的办法来解决这个问题。 一个服务器所负责管辖的（或有权限的）范围叫做区（zone）。各单位根据具体情况来划 分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权 限域名服务器（authoritative name server），用来保存该区中的所有主机的域名到IP 地址的映 射。总之，DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。区是 DNS 服务器实际管辖的范围。区可能等于或小于域，但一定不能大于域。 图 6-2 是区的不同划分方法的举例。假定 abc 公司有下属部门x和 y，部门 x 下面又分 三个分部门 u，v 和 w，而 y 下面还有其下属部门 t。图 6-2（a）表示 abc 公司只设一个区 abc。com。这时，区 abc。com 和域 abc。com 指的是同一件事。但图 6-2（b）表示abc公司划分了 两个区（大的公司可能要划分多个区）：abc。com 和y。abc。com。这两个区都隶属于域 abc。com，都各设置了相应的权限域名服务器。不难看出，区是“域”的子集。 根 根 org com edu org com edu 域 abc。com abc ☑ abc。com 域 abc。com abc 区 abc。com 区y。abc。com （a） （b） 图 6-2DNS 划分区的举例 t W 图 6-3 以图 6-2（b）中公司 abc划分的两个区为例，给出了 DNS 域名服务器树状结构图。 这种 DNS 域名服务器树状结构图可以更准确地反映出 DNS 的分布式结构。在图 6-3 中的每 一个域名服务器都能够进行部分域名到IP地址的解析。当某个DNS 服务器不能进行域名到 IP 地址的转换时，它就设法找互联网上别的域名服务器进行解析。 根域名服务器 根域名服务器 顶级域名服务器 org域名服务器 com域名服务器 edu 域名服务器 权限域名服务器 abc。com 域名服务器 abc 公司有两个 权限域名服务器 y。abc。com 域名服务器 图6-3 树状结构的DNS域名服务器 从图 6-3 可看出，互联网上的 DNS 域名服务器也是按照层次安排的。每一个域名服务 器都只对域名体系中的一部分进行管辖。根据域名服务器所起的作用，可以把域名服务器划 分为以下四种不同的类型： （1）根域名服务器（root name server）：根域名服务器是最高层次的域名服务器，也是最 重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP 地址。 根域名服务器是最重要的域名服务器，因为不管是哪一个本地域名服务器，若要对互联网上 任何一个域名进行解析（即转换为 IP 地址），只要自己无法解析，就首先要求助于根域名服 • 256 •</p> <p>Page 267 务器。假定所有的根域名服务器都瘫痪了，那么整个互联网中的 DNS 系统就无法工作。据 统计，到 2016 年2 月，全世界已经在588个地点（地点数值还在不断增加）安装了根域名 服务器，但这么多的根域名服务器却只使用 13 个不同 IP 地址的域名，即 a。rootservers。net， b。rootservers。net， m。rootservers。net。每个域名下的根域名服务器由专门的公司或美国政府 。。。 的某个部门负责运营。但请注意，虽然互联网的根域名服务器总共只有 13 个域名，但这不 表明根域名服务器是由13台机器所组成（如果仅仅依靠这13 台机器，根本不可能为全世界 的互联网用户提供令人满意的服务）。实际上，在互联网中是由 13 套装置（13 installations）构 成这 13 组根域名服务器[W-ROOT]。每一套装置在很多地点安装根域名服务器（也可称为 镜像根服务器），但都使用同一个域名。负责运营根域名服务器的公司大多在美国，但所有 的根域名服务器却分布在全世界。为了提供更可靠的服务，在每一个地点的根域名服务器往 往由多台机器组成（为了安全起见，有些根域名服务器的具体地点还是保密的）。现在世界 上大部分DNS 域名服务器，都能就近找到一个根域名服务器查询 IP地址（现在这些根域名 服务器都已增加了 IPv6 地址）。为了方便，人们常用从 A 到 M 的前 13 个英文字母中的一 个，来表示某组根域名服务器。 图6-4 是覆盖范围很大的一组根域名服务器L在世界上150个地点的分布图（在中国有 3个，位置都在北京）。由于根域名服务器采用了任播（anycast）技术，因此当 DNS 客户向某 个根域名服务器的IP地址发出查询报文时，互联网上的路由器就能找到离这个DNS 客户最 近的一个根域名服务器。这样做不仅加快了 DNS 的查询过程，也更加合理地利用了互联网 的资源。 图6-4根域名服务器在世界上150个地点的分布图 必须指出，目前根域名服务器的分布仍然是很不均衡的。例如，在北美，平均每 375 万个网民就可以分摊到一个根域名服务器，而在亚洲，平均超过2千万个网民才分摊到一个 根域名服务器，这样就会使亚洲的网民上网速度明显地低于北美的。 需要注意的是，在许多情况下，根域名服务器并不直接把待查询的域名直接转换成IP 地址（根域名服务器也没有存放这种信息），而是告诉本地域名服务器下一步应当找哪一个 顶级域名服务器进行查询。 由于根域名服务器在 DNS 中的地位特殊，因此对根域名服务器有许多具体的要求，可 参阅 RFC 2870。 （2） 顶级域名服务器（即TLD 服务器）：这些域名服务器负责管理在该顶级域名服务器 注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果， 也可能是下一步应当找的域名服务器的IP地址）。 （3） 权限域名服务器：这就是前面已经讲过的负责一个区的域名服务器。当一个权限域 名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当 找哪一个权限域名服务器。例如在图 6-2（b）中，区 abc。com 和区 y。abc。com 各设有一个权限 域名服务器。 （4） 本地域名服务器（local name server）： 本地域名服务器并不属于图 6-3 所示的域名服 务器层次结构，但它对域名系统非常重要。当一台主机发出 DNS 查询请求时，这个查询请 求报文就发送给本地域名服务器。由此可看出本地域名服务器的重要性。每一个互联网服务 提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域 名服务器有时也称为默认域名服务器。当计算机使用 Windows 7 操作系统时，打开“控制 面板”，然后依次选择“网络和 Internet” “网络和共享中心”→“查看网络状态和任务” ·“无线网络连接”（假定采用家庭网络）→“属性” “Internet 协议版本4”→“属性” 等项目，就可以看见首选 DNS服务器和备用DNS 服务器的IP 地址。这里的DNS 服务器指 的就是本地域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离。当所 要查询的主机也属于同一个本地ISP时，该本地域名服务器立即就能将所查询的主机名转换 为它的IP 地址，而不需要再去询问其他的域名服务器。 →» →» 为了提高域名服务器的可靠性， DNS域名服务器都把数据复制到几个域名服务器来保 存，其中的一个是主域名服务器（master name server），其他的是辅助域名服务器（secondary name server）。当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中 断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中 进行。这样就保证了数据的一致性。 下面简单讨论一下域名的解析过程。这里要注意两点。 第一，主机向本地域名服务器的查询一般都是采用递归查询（recursive query）。所谓递归 查询就是：如果主机所询问的本地域名服务器不知道被查询域名的IP 地址，那么本地域名 服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继 续查询），而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果或者是 所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。 第二，本地域名服务器向根域名服务器的查询通常是采用迭代查询（iterative query）。迭 代查询的特点是这样的：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时， 要么给出所要查询的IP地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务 器进行查询”。然后让本地域名服务器进行后续的查询（而不是替本地域名服务器进行后续 的查询）。根域名服务器通常是把自己知道的顶级域名服务器的IP 地址告诉本地域名服务 器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的 查询请求后，要么给出所要查询的 IP 地址，要么告诉本地域名服务器下一步应当向哪一个 权限域名服务器进行查询，本地域名服务器就这样进行迭代查询。最后，知道了所要解析的 域名的IP 地址，然后把这个结果返回给发起查询的主机。当然，本地域名服务器也可以采 用递归查询，这取决于最初的查询请求报文的设置是要求使用哪一种查询方式。 图 6-5 用例子说明了这两种查询的区别。 根域名服务器 顶级域名服务器 dns。com 根域名服务器 顶级域名服务器 dns。com 迭代查询 递归查询 dns。xyz。com 本地域名服务器 权限域名服务 dns。abc。com 本地域名服务器 权限域名服务 dns。xyz。com dns。abc。com 递归 y。abc。com的IP 地址 递归 y。abc。com 的IP 地址 查询 查询 m。xyz。com （a） 本地域名服务器采用迭代查询 m。xyz。com （b）本地域名服务器采用递归查询 图6-5DNS查询举例 假定域名为 m。xyz。com 的主机想知道另一台主机（域名为y。abc。com）的 IP 地址。例 如，主机 m。xyz。com 打算发送邮件给主机 y。abc。com。这时就必须知道主机 y。abc。com 的 IP 地址。下面是图 6-5（a）的几个查询步骤： 地址。 ● 主机 m。xyz。com 先向其本地域名服务器 dns。xyz。com 进行递归查询。 ● 本地域名服务器采用迭代查询。它先向一个根域名服务器查询。 ● 根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器 dns。com 的 IP ● 本地域名服务器向顶级域名服务器 dns。com 进行查询。 ● 顶级域名服务器 dns。com 告诉本地域名服务器，下一次应查询的权限域名服务器 dns。abc。com 的IP 地址。 • 本地域名服务器向权限域名服务器 dns。abc。com 进行查询。 ● 权限域名服务器 dns。abc。com 告诉本地域名服务器，所查询的主机的 IP 地址。 ● 本地域名服务器最后把查询结果告诉主机m。xyz。com。 我们注意到，这8个步骤总共要使用8个UDP用户数据报的报文。本地域名服务器经 过三次迭代查询后，从权限域名服务器 dns。abc。com 得到了主机 y。abc。com 的 IP 地址，最后 把结果返回给发起查询的主机m。xyz。com。 图 6-5（b）是本地域名服务器采用递归查询的情况。在这种情况下，本地域名服务器只 需向根域名服务器查询一次，后面的几次查询都是在其他几个域名服务器之间进行的（步 骤●至●）。只是在步骤，本地域名服务器从根域名服务器得到了所需的 IP 地址。最后 在步骤©，本地域名服务器把查询结果告诉主机 m。xyz。com。整个的查询也是使用8个 UDP 报文。 为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报 文数量，在域名服务器中广泛地使用了高速缓存（有时也称为高速缓存域名服务器）。高速 • 259 •</p> <p>Page 270 缓存用来存放最近查询过的域名以及从何处获得域名映射 信息的记录。 例如，在图 6-5（a）的查询过程中，如果在不久前已经有用户查询过域名为 y。abc。com 的 IP 地址，那么本地域名服务器就不必向根域名服务器重新查询 y。abc。com 的 IP 地址，而是 直接把高速缓存中存放的上次查询结果（即y。abc。com 的 IP 地址）告诉用户。 假定本地域名服务器的缓存中并没有y。abc。com 的IP 地址，而是存放着顶级域名服务器 dns。com 的 IP 地址，那么本地域名服务器也可以不向根域名服务器进行查询，而是直接向 com 顶级域名服务器发送查询请求报文。这样不仅可以大大减轻根域名服务器的负荷，而且 也能够使互联网上的 DNS 查询请求和回答报文的数量大为减少。 由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应 为每项内容设置计时器并处理超过合理时间的项（例如，每个项目只存放两天）。当域名服 务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名 服务器获取绑定信息。当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存 在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。 不但在本地域名服务器中需要高速缓存，在主机中也很需要。许多主机在启动时从本 地域名服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并 且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机自然应 该定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删掉无效的项。由于 域名改动并不频繁，大多数网点不需花太多精力就能维护数据库的一致性。 6。2 文件传送协议 6。2。1 FTP 概述 文件传送协议 FTP （File Transfer Protocol） [RFC 959]是互联网上使用得最广泛的文件传 送协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用 ASCII 码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）。 FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。RFC 959 很早就成为了互联网的正式标准。 在互联网发展的早期阶段，用FTP 传送文件约占整个互联网的通信量的三分之一，而 由电子邮件和域名系统所产生的通信量还小于 FTP 所产生的通信量。只是到了 1995 年， WWW 的通信量才首次超过了FTP。 在下面 6。2。2 和 6。2。3 节分别介绍基于TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP，它们都是文件共享协议中的一大类，即复制整个文件，其特点是：若要存取一个文 件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然 后再将修改后的文件副本传回到原节点。 文件共享协议中的另一大类是联机访问（on-line access）。联机访问意味着允许多个程序 同时对一个文件进行存取。和数据库系统的不同之处是用户不需要调用一个特殊的客户进 程，而是由操作系统提供对远地共享文件进行访问的服务，就如同对本地文件的访问一样。 这就使用户可以用远地文件作为输入和输出来运行任何应用程序，而操作系统中的文件系统 则提供对共享文件的透明存取。透明存取的优点是：将原来用于处理本地文件的应用程序用 来处理远地文件时，不需要对该应用程序作明显的改动。属于文件共享协议的有网络文件系 统NFS （Network File System） [COME06]。网络文件系统NFS最初是在UNIX 操作系统环境 下实现文件和目录共享的。NFS 可使本地计算机共享远地的资源，就像这些资源在本地一 样。由于 NFS 原先是美国 SUN 公司在 TCP/IP 网络上创建的，因此目前 NFS 主要应用在 TCP/IP 网络上。然而现在 NFS 也可在 OS/2， MS-Windows， NetWare 等操作系统上运行。 NFS 还没有成为互联网的正式标准。经过几次修订更新，现在的最新版本（NFSv4）于 2015 年 3 月发布[RFC 7530]，目前还只是建议标准。限于篇幅，本书不讨论 NFS 的详细工 作过程。 6。2。2 FTP 的基本工作原理 网络环境中的一项基本应用就是将文件从一台计算机中复制到另一台可能相距很远的 计算机中。初看起来，在两台主机之间传送文件是很简单的事情。其实这往往非常困难。原 因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。经常遇到的问题是： （1） 计算机存储数据的格式不同。 （2） 文件的目录结构和文件命名的规定不同。 （3）对于相同的文件存取功能，操作系统使用的命令不同。 （4） 访问控制方法不同。 文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用TCP 可靠的运输服务。 FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。 FTP 使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程， 负责处理单个请求。 主进程的工作步骤如下： （1） 打开熟知端口（端口号为21），使客户进程能够连接上。 （2） 等待客户进程发出连接请求。 （3） 启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即 终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。 （4） 回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并 发进行的。 FTP 的工作情况如图6-6所示。图中的椭圆圈表示在系统中运行的进程。图中的服务器 端有两个从属进程：控制进程和数据传送进程。为简单起见，服务器端的主进程没有画上。 客户端除了控制进程和数据传送进程外，还有一个用户界面进程用来和用户接口。 在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：“控制连 接”和“数据连接”。控制连接在整个会话期间一直保持打开， FTP 客户所发出的传送请 求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传 输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后</p> <p>就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数 据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。由于 FTP 使用了一个分离的控制连接，因此 FTP 的控制信息是带外（out of band）传送的。 用户界面 TCP控制连接 控制进程 控制进程 互联网 数据传送 进程 数据传送 进程 FTP客户端 TCP 数据连接 FTP服务器端 图 6-6 FTP使用的两个TCP连接 当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 21， 同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进 程用自己传送数据的熟知端口 20 与客户进程所提供的端口号建立数据传送连接。由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。 使用两个独立的连接的主要好处是使协议更加简单和更容易实现，同时在传输文件时 还可以利用控制连接对文件的传输进行控制。例如，客户发送“请求终止传输”。 FTP 并非对所有的数据传输都是最佳的。例如，计算机 A 上运行的应用程序要在远地 计算机 B 的一个很大的文件末尾添加一行信息。若使用 FTP，则应先将此文件从计算机 B 传送到计算机 A，添加上这一行信息后，再用FTP 将此文件传送到计算机 B，来回传送 这样大的文件很花时间。实际上这种传送是不必要的，因为计算机 A 并没有使用该文件的 内容。 然而网络文件系统 NFS 则采用另一种思路。NFS 允许应用进程打开一个远地文件，并 能在该文件的某一个特定的位置上开始读写数据。这样，NFS 可使用户只复制一个大文件 中的一个很小的片段，而不需要复制整个大文件。对于上述例子，计算机A中的 NFS 客户 软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 中的 NFS 服 务器，NFS 服务器更新文件后返回应答信息。在网络上传送的只是少量的修改数据。 6。2。3 简单文件传送协议 TFTP TCP/IP 协议族中还有一个简单文件传送协议 TFTP （Trivial File Transfer Protocol），它是 一个很小且易于实现的文件传送协议。TFTP 的版本是互联网的正式标准[RFC1350]。虽 然 TFTP 也使用客户服务器方式，但它使用UDP 数据报，因此 TFTP 需要有自己的差错改 正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录 的功能，也不能对用户进行身份鉴别。 TFTP 的主要优点有两个。第一，TFTP 可用于 UDP 环境。例如，当需要将程序或文件 同时向许多机器下载时就往往需要使用TFTP。第二，TFTP 代码所占的内存较小。这对较 小的计算机或某些特殊用途的设备是很重要的。这些设备不需要硬盘，只需要固化了 TFTP、UDP 和 IP 的小容量只读存储器即可。当接通电源后，设备执行只读存储器中的代 码，在网络上广播一个 TFTP 请求。网络上的 TFTP 服务器就发送响应，其中包括可执行二 进制程序。设备收到此文件后将其放入内存，然后开始运行程序。这种方式增加了灵活性， 也减少了开销。 TFTP的主要特点是： （1） 每次传送的数据报文中有512字节的数据，但最后一次可不足 512 字节。 （2）数据报文按序编号，从1开始。 （3） 支持 ASCII 码或二进制传送。 （4）可对文件进行读或写。 （5） 使用很简单的首部。 TFTP 的工作很像停止等待协议（见第 5 章 5。4。1 节）。发送完一个文件块后就等待对方 的确认，确认时应指明所确认的块编号。发完数据后在规定时间内收不到确认就要重发数据 PDU。发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这 样就可保证文件的传送不致因某一个数据报的丢失而告失败。 在一开始工作时。TFTP客户进程发送一个读请求报文或写请求报文给 TFTP 服务器进 程，其熟知端口号码为 69。TFTP服务器进程要选择一个新的端口和 TFTP 客户进程进行通 信。若文件长度恰好为512字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只 含首部而无数据的数据报文。若文件长度不是512字节的整数倍，则最后传送数据报文中的 数据字段一定不满512字节，这正好可作为文件结束的标志。 6。3 远程终端协议 TELNET TELNET 是一个简单的远程终端协议[RFC 854]，它也是互联网的正式标准。用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录到远地的另一台主机上（使用主机 名或 IP 地址）。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接 连在远地主机上。因此，TELNET 又称为终端仿真协议。 TELNET 并不复杂，以前应用得很多。现在由于计算机的功能越来越强，用户已较少 使用TELNET了。 TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机 则运行 TELNET 服务器进程。和FTP的情况相似，服务器中的主进程等待新的请求，并产 生从属进程来处理每一个连接。 TELNET 能够适应许多计算机和操作系统的差异。例如，对于文本中一行的结束，有 的系统使用 ASCII 码的回车（CR），有的系统使用换行（LF），还有的系统使用两个字符，回车 -换行（CR-LF）。又如，在中断一个程序时，许多系统使用 Control-C （^C），但也有系统使用 ESC 按键。为了适应这种差异，TELNET 定义了数据和命令应怎样通过互联网。这些定义 就是所谓的网络虚拟终端 NVT （Network Virtual Terminal）。图 6-7 说明了 NVT 的意义。客户 软件把用户的击键和命令转换成NVT格式，并送交服务器。服务器软件把收到的数据和命 令从 NVT 格式转换成远地系统所需的格式。向用户返回数据时，服务器把远地系统的格式 转换为 NVT 格式，本地客户再从NVT 格式转换到本地系统所需的格式。 TELNET 客户端 TELNET 互联网 服务器端 TCP连接 客户 【服务器 使用客户端的格式 使用NVT 格式 使用服务器端的格式 图 6-7 TELNET 使用网络虚拟终端 NVT 格式 NVT 的格式定义很简单。所有的通信都使用8位一个字节。在运转时，NVT 使用7位 ASCII 码传送数据，而当高位置1时用作控制命令。ASCII 码共有95 个可打印字符（如字 母、数字、标点符号）和 33 个控制字符。所有可打印字符在 NVT 中的意义和在 ASCII 码 中一样。但 NVT 只使用了 ASCII 码的控制字符中的几个。此外，NVT 还定义了两字符的 CR-LF 为标准的行结束控制符。当用户键入回车按键时，TELNET 的客户就把它转换为 CR-LF 再进行传输，而TELNET 服务器要把 CR-LF 转换为远地机器的行结束字符。 TELNET 的选项协商（Option Negotiation）使 TELNET 客户和 TELNET 服务器可商定使 用更多的终端功能，协商的双方是平等的。 6。4 万维网 WWW 6。4。1 万维网概述 万维网 WWW（World Wide Web）并非某种特殊的计算机网络。万维网是一个大规模的、 联机式的信息储藏所，英文简称为 Web。万维网用链接的方法能非常方便地从互联网上的 一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富 的信息。图 6-8 说明了万维网提供分布式服务的特点。 万维网站点A 链接到 链接到 链接到 链接到 链接到 万维网站点 B 万维网站点 D 链接到 链接到 万维网站点 C 万维网站点 E 图6-8 万维网提供分布式服务 图 6-8 画出了五个万维网上的站点，它们可以相隔数千公里，但都必须连接在互联网 上。每一个万维网站点都存放了许多文档。在这些文档中有一些地方的文字是用特殊方式显 示的（例如用不同的颜色，或添加了下划线），而当我们将鼠标移动到这些地方时，鼠标的 箭头就变成了一只手的形状。这就表明这些地方有一个链接（link） （这种链接有时也称为超 链 hyperlink），如果我们在这些地方点击鼠标，就可以从这个文档链接到可能相隔很远的另 一个文档。经过一定的时延（几秒钟、几分钟甚至更长，取决于所链接的文档的大小和网络 的拥塞情况），在我们的屏幕上就能将远方传送过来的文档显示出来。例如，站点 A 的某个 文档中有两个地方●和●可以链接到其他的站点。当我们点击链接时，就可链接到站点 B 的某个文档。若点击●则可链接到站点 E。站点 B的文档也有两个地方和有链接。若点 击链接●就可链接到站点D，而点击链接就链接到站点E，但从E的这个文档已不能继续 链接到其他任何的站点。站点 D 的文档中有两个地方●和●有链接，可以分别链接到 A 和 C。 正是由于万维网的出现，使互联网从仅由少数计算机专家使用变为普通百姓也能利用 的信息资源。万维网的出现使网站数按指数规律增长。因此，万维网的出现是互联网发展中 的一个非常重要的里程碑。 万维网是欧洲粒子物理实验室的 Tim Berners-Lee 最初于1989年3月提出的。1993 年 2 月，第一个图形界面的浏览器（browser）开发成功，名字叫做 Mosaic。1995 年著名的 Netscape Navigator 浏览器上市。目前最流行的浏览器是微软公司的 Internet Explorer。 万维网是一个分布式的超媒体（hypermedia）系统，它是超文本（hypertext）系统的扩充。所 谓超文本是指包含指向其他文档的链接的文本（text）。也就是说，一个超文本由多个信息源 链接成，而这些信息源可以分布在世界各地，并且数目也是不受限制的。利用一个链接可使 用户找到远在异地的另一个文档，而这又可链接到其他的文档（依此类推）。这些文档可以 位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。 超媒体与超文本的区别是文档内容不同。超文本文档仅包含文本信息，而超媒体文档 还包含其他表示方式的信息，如图形、图像、声音、动画以及视频图像等。 分布式的和非分布式的超媒体系统有很大区别。在非分布式系统中，各种信息都驻留 在单个计算机的磁盘中。由于各种文档都可从本地获得，因此这些文档之间的链接可进行一 致性检查。所以，一个非分布式超媒体系统能够保证所有的链接都是有效的和一致的。 万维网把大量信息分布在整个互联网上。每台主机上的文档都独立进行管理。对这些 文档的增加、修改、删除或重新命名都不需要（实际上也不可能）通知到互联网上成千上万 的节点。这样，万维网文档之间的链接就经常会不一致。例如，主机 A 上的文档 X 本来包 含了一个指向主机 B 上的文档 Y 的链接。若主机 B 的管理员在某日删除了文档 Y，那么主 机A的上述链接显然就失效了。 万维网以客户服务器方式工作。上面所说的浏览器就是在用户主机上的万维网客户程 序。万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。客户 程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在一个客 户程序主窗口上显示出的万维网文档称为页面（page）。 从以上所述可以看出，万维网必须解决以下几个问题： （1） 怎样标志分布在整个互联网上的万维网文档？ （2） 用什么样的协议来实现万维网上的各种链接？ （3） 怎样使不同作者创作的不同风格的万维网文档，都能在互联网上的各种主机上显示 出来，同时使用户清楚地知道在什么地方存在着链接？ （4） 怎样使用户能够很方便地找到所需的信息？ 为了解决第一个问题，万维网使用统一资源定位符 URL （Uniform Resource Locator）来标 志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。 为了解决上述的第二个问题，就要使万维网客户程序与万维网服务器程序之间的交互遵守严 格的协议，这就是超文本传送协议 HTTP （HyperText Transfer Protocol）。HTTP 是一个应用层 协议，它使用 TCP 连接进行可靠的传送。为了解决上述的第三个问题，万维网使用超文本 标记语言 HTML （HyperText Markup Language），使得万维网页面的设计者可以很方便地用链 接从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的主机屏幕上将 这些页面显示出来。最后，用户可使用搜索工具在万维网上方便地查找所需的信息。 下面我们将进一步讨论上述的这些重要概念。 6。4。2 统一资源定位符 URL 1。URL 的格式 统一资源定位符 URL 是用来表示从互联网上得到的资源位置和访问这些资源的方法。 URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。只要能够对资源 定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。由此可见， URL 实际上就是在互联网上的资源的地址。只有知道了这个资源在互联网上的什么地方， 才能对它进行操作。显然，互联网上的所有资源，都有一个唯一确定的URL。 这里所说的“资源”是指在互联网上可以被访问的任何对象，包括文件目录、文件、 文档、图像、声音等，以及与互联网相连的任何形式的数据。“资源”还包括电子邮件的地 址和 USENET 新闻组，或USENET 新闻组中的报文。 URL 相当于一个文件名在网络范围的扩展。因此，URL 是与互联网相连的机器上的任 何可访问对象的一个指针。由于访问不同对象所使用的协议不同，所以 URL 还指出读取某 个对象时所使用的协议。URL 的一般形式由以下四个部分组成：</p> <协议>：//<主机>：<端口>/<路径> URL 的第一部分是最左边的<协议>。这里的<协议>就是指出使用什么协议来获取该万 维网文档。现在最常用的协议就是http（超文本传送协议 HTTP），其次是ftp（文件传送协 议 FTP）。 在<协议>后面的“：//”是规定的格式。它的右边是第二部分<主机>，它指出这个万维 网文档是在哪一台主机上。这里的<主机>就是指该主机在互联网上的域名。再后面是第三 和第四部分<端口>和<路径>，有时可省略。 现在有些浏览器为了方便用户，在输入 URL 时，可以把最前面的“http：//”甚至把主机 名最前面的“www”省略，然后浏览器替用户把省略的字符添上。例如，用户只要键入 ctrip。com，浏览器就自动把未键入的字符补齐，变成http：//www。ctrip。com。 下面我们简单介绍使用得最多的一种 URL。 2。使用 HTTP 的 URL 对于万维网的网点的访问要使用HTTP协议。HTTP的URL的一般形式是： http：//<主机>：<端口>/<路径> HTTP 的默认端口号是80，通常可省略。若再省略文件的<路径>项，则 URL 就指到互 联网上的某个主页（home page）。主页是个很重要的概念，它可以是以下几种情况之一： （1） 一个 WWW 服务器的最高级别的页面。 （2）某一个组织或部门的一个定制的页面或目录。从这样的页面可链接到互联网上的与 本组织或部门有关的其他站点。 （3）由某一个人自己设计的描述他本人情况的WWW页面。 例如，要查有关清华大学的信息，就可先进入到清华大学的主页，其 URL 为 ： http：//www。tsinghua。edu。cn 这里省略了默认的端口号 80。我们从清华大学的主页入手，就可以通过许多不同的链 接找到所要查找的各种有关清华大学各个部门的信息。 更复杂一些的路径是指向层次结构的从属页面。例如： http：//www。tsinghua。edu。cn/publish/newthu/newthu_cnt/faculties/index。html 主机域名 路径名 是清华大学的“院系设置”页面的URL。注意：上面的URL中使用了指向文件的路径，而 文件名就是最后的 index。htm。后缀 htm（有时可写为html）表示这是一个用超文本标记语 言 HTML 写出的文件。 URL 里面的字母不分大小写，但为了便于阅读，有时故意使用一些大写字母。 用户使用 URL 并非仅仅能够访问万维网的页面，而且还能够通过URL 使用其他的互 联网应用程序，如FTP或USENET 新闻组等。更重要的是，用户在使用这些应用程序时， 只使用一个程序，即浏览器。这显然是非常方便的。 6。4。3 超文本传送协议 HTTP 1。 HTTP 的操作过程 HTTP 协议定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档， 以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP 是面向事务的（transaction- oriented） 应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种 多媒体文件）的重要基础。请注意，HTTP 不仅传送完成超文本跳转所必需的信息，而且也 传送任何可从互联网上得到的信息，如文本、超文本、声音和图像等。 万维网的大致工作过程如图6-9所示。 服务器 链接到URL的超链 www。tsinghua。edu。cn 客戶 清华大学 院系设置 浏览器 服务器 程序 程序 HTTP HTTP 使用此 TCP连接 互联网 建立TCP连接 浏览器 发出请求 HTTP请求报文 HTTP 响应报文 服务器 返回响应 释放TCP 连接 图6-9万维网的工作过程 每个万维网网点都有一个服务器进程，它不断地监听 TCP 的端口80，以便发现是否有 浏览器（即万维网客户。请注意，浏览器和万维网客户是同义词）向它发出连接建立请求。 一旦监听到连接建立请求并建立了TCP 连接之后，浏览器就向万维网服务器发出浏览某个 页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP连接就被释放了。在 浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则。这些格 式和规则就是超文本传送协议HTTP。 HTTP 规定在 HTTP客户与HTTP服务器之间的每次交互，都由一个ASCII 码串构成的 请求和一个类似的通用互联网扩充，即“类 MIME （MIME-like）”的响应组成。HTTP 报文 通常都使用TCP 连接传送。 用户浏览页面的方法有两种。一种方法是在浏览器的地址窗口中键入所要找的页面的 URL。另一种方法是在某一个页面中用鼠标点击一个可选部分，这时浏览器会自动在互联网 上找到所要链接的页面。 HTTP 使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。HTTP 不必考 虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP协议本身是无连接的。这就是 说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立 HTTP 连接。在1997年以前使用的是RFC1945 定义的HTTP/1。0 协议。现在普遍使用的升 级版本 HTTP/1。1 已是互联网建议标准[RFC 7231]。 HTTP 协议是无状态的（stateless）。也就是说，同一个客户第二次访问同一个服务器上的 页面时，服务器的响应与第一次被访问时的相同（假定现在服务器还没有把该页面更新）， 因为服务器并不记得曾经访问过的这个客户，也不记得为该客户曾经服务过多少次。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的 HTTP 请求。 下面我们粗略估算一下，从浏览器请求一个万维网文档到收到整个文档所需的时间 （图 6-10）。用户在点击鼠标链接某个万维网文档时，HTTP 协议首先要和服务器建立TCP 连接。这需要使用三报文握手。当建立TCP连接的三报文握手的前两部分完成后（即经过 了一个 RTT 时间后），万维网客户就把 HTTP 请求报文，作为建立 TCP 连接的三报文握手 中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求 的文档作为响应报文返回给客户。 万维网服务器 万维网客户 发起 TCP 连接 RTT HTTP 请求报文 RTT HTTP响应报文 一传输文档的时间 整个文档收到 时间 时间 图 6-10 请求一个万维网文档所需的时间 从图 6-10 可看出，请求一个万维网文档所需的时间是该文档的传输时间（与文档大小 成正比）加上两倍往返时间 RTT（一个 RTT 用于连接 TCP 连接，另一个RTT 用于请求和 接收万维网文档。TCP 建立连接的三报文握手的第三个报文段中的数据，就是客户对万维 网文档的请求报文）。 HTTP/1。0 的主要缺点，就是每请求一个文档就要有两倍 RTT 的开销。若一个主页上有 很多链接的对象（如图片等）需要依次进行链接，那么每一次链接下载都导致2 × RTT 的开 销。另一种开销就是万维网客户和服务器每一次建立新的 TCP 连接都要分配缓存和变量。 特别是万维网服务器往往要同时服务于大量客户的请求，所以这种非持续连接会使万维网服 务器的负担很重。好在浏览器都能够打开5~10个并行的TCP 连接，而每一个 TCP 连接处 理客户的一个请求。因此，使用并行 TCP 连接可以缩短响应时间。 HTTP/1。1 协议较好地解决了这个问题，它使用了持续连接（persistent connection）。所谓 持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户 （浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并 不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。目前 一些流行的浏览器（如IE 11。0）的默认设置就使用了 HTTP/1。1。如果用户不愿意使用持续 连接的浏览器，可以选择IE浏览器上面的“工具” “Internet 选项” “高级”等项目， 把“HTTP 1。1 设置”的选择取消即可。 HTTP/1。1 协议的持续连接有两种工作方式，即非流水线方式（without pipelining）和流水 线方式（with pipelining）。 非流水线方式的特点，是客户在收到前一个响应后才能发出下一个请求。因此，在 TCP 连接已建立后，客户每访问一次对象都要用去一个往返时间 RTT。这比非持续连接要用去两 倍 RTT 的开销，节省了建立 TCP 连接所需的一个 RTT 时间。但非流水线方式还是有缺点 的，因为服务器在发送完一个对象后，其TCP 连接就处于空闲状态，浪费了服务器资源。 流水线方式的特点，是客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报 文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用 流水线方式时，客户访问所有的对象只需花费一个 RTT 时间。流水线工作方式使 TCP 连接 中的空闲时间减少，提高了下载文档效率。 2。 代理服务器 代理服务器（proxy server）是一种网络实体，它又称为万维网高速缓存（Web cache）。代理 服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这 个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网 访问该资源。代理服务器可在客户端或服务器端工作，也可在中间系统上工作。下面我们用 例子说明它的作用。 设图 6-11（a）是校园网不使用代理服务器的情况。这时，校园网中所有的计算机都通过2 Mbit/s 专线链路（R-R2）与互联网上的源点服务器建立TCP连接。因而校园网各计算机访 问互联网的通信量往往会使这条2Mbit/s的链路过载，使得时延大大增加。 图 6-11（b）是校园网使用代理服务器的情况。这时，访问互联网的过程是这样的： （1） 校园网的计算机中的浏览器向互联网的服务器请求服务时，就先和校园网的代理服 务器建立 TCP 连接，并向代理服务器发出HTTP请求报文（见图6-11（b）中的●）。 （2） 若代理服务器已经存放了所请求的对象，代理服务器就把这个对象放入 HTTP 响应 报文中返回给计算机的浏览器。 （3） 否则，代理服务器就代表发出请求的用户浏览器，与互联网上的源点服务器（origin server）建立 TCP 连接（如图6-11（b）中的●所示），并发送HTTP请求报文。 源点服务器 校园网 这条链路通信量 过大，时延增加 浏览器 R， 2 Mbit/s 互联网 （a）不使用代理服务器 这条链路通信量 减少，时延不大 源点服务器 校园网 浏览器 R₂ 2 Mbit/s 互联网 校园网的 代理服务器 （b）使用代理服务器 图6-11 代理服务器的作用 （4） 源点服务器把所请求的对象放在HTTP响应报文中返回给校园网的代理服务器。 （5） 代理服务器收到这个对象后，先复制在自己的本地存储器中（留待以后用），然后 再把这个对象放在HTTP 响应报文中，通过已建立的TCP 连接（见图 6-11（b）中的●），返回 给请求该对象的浏览器。 我们注意到，代理服务器有时是作为服务器（当接受浏览器的 HTTP 请求时），但有时 却作为客户（当向互联网上的源点服务器发送HTTP请求时）。 在使用代理服务器的情况下，由于有相当大一部分通信量局限在校园网的内部，因此， 2 Mbit/s 专线链路（R-R2）上的通信量大大减少，因而减小了访问互联网的时延。 3。 HTTP 的报文结构 HTTP 有两类报文： （1） 请求报文——从客户向服务器发送请求报文，见图6-12（a）。 （2） 响应报文——从服务器到客户的回答，见图6-12（b）。 空格 回车换行 空格 回车换行 方法 URL 版本 CRLF 请求行 版本 状态码 短语 CRLF 状态行 | 首部字段名： 值 CRLF 「首部字段名 ： 值 CRLF ： ·首部行 | 首部字段名 ： 值 CRLF 8 | 首部字段名： 值 CRLF 首部行 CRLF 实体主体 （通常不用） CRLF 实体主体 （有些响应报文不用） （a）请求报文 （b）响应报文 图6-12 HTTP 的报文结构 由于 HTTP 是面向文本的（text-oriented），因此在报文中的每一个字段都是一些 ASCII 码 串，因而各个字段的长度都是不确定的。 HTTP 请求报文和响应报文都是由三个部分组成的。可以看出，这两种报文格式的区别 就是开始行不同。 （1）开始行，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行 （Request-Line），而在响应报文中的开始行叫做状态行（Status-Line）。在开始行的三个字段之 间都以空格分隔开，最后的“CR”和“LF”分别代表“回车”和“换行”。 （2）首部行，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但 也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有 “回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。 （3） 实体主体（entity body），在请求报文中一般都不用这个字段，而在响应报文中也可能 没有这个字段。 下面先介绍 HTTP 请求报文的一些主要特点。 请求报文的第一行“请求行”只有三个内容，即方法，请求资源的 URL，以及 HTTP 的版本。 请注意：这里的名词“方法”（method）是面向对象技术中使用的专门名词。所谓“方 法”就是对所请求的对象进行的操作，这些方法实际上也就是一些命令。因此，请求报文的 类型是由它所采用的方法决定的。表6-1 给出了请求报文中常用的几种方法。 表6-1 HTTP请求报文的一些方法 方法（ 操作 ） 意义 OPTION GET 请求一些选项的信息 请求读取由 URL 所标志的信息 HEAD 请求读取URL 所标志的信息的首部 POST 给服务器添加信息（例如，注释） PUT 在指明的 URL 下存储一个文档 DELETE 删除指明的 URL 所标志的资源 TRACE CONNECT 用来进行环回测试的请求报文 用于代理服务器 下面是 HTTP 的请求报文的开始行（即请求行）的格式。请注意，在 GET 后面有一个 空格，接着是某个完整的URL，其后面又有一个空格，最后是HTTP/1。1。 GET http：//www。xyz。edu。cn/dir/index。htm HTTP/1。1 下面是一个完整的HTTP请求报文的例子： GET /dir/index。htm HTTP/1。1 Host： www。xyz。edu。cn Connection： close User-Agent： Mozilla/5。0 Accept-Language： cn {请求行使用了相对URL} {此行是首部行的开始。这行给出主机的域名} {告诉服务器发送完请求的文档后就可释放连接} {表明用户代理是使用火狐浏览器Firefox} {表示用户希望优先得到中文版本的文档} {请求报文的最后还有一个空行} 在请求行使用了相对URL（即省略了主机的域名）是因为下面的首部行（第2 行）给 出了主机的域名。第3行是告诉服务器不使用持续连接，表示浏览器希望服务器在传送完所 请求的对象后即关闭TCP连接。这个请求报文没有实体主体。 再看一下 HTTP响应报文的主要特点。 每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。 状态行包括三项内容，即HTTP 的版本，状态码，以及解释状态码的简单短语。 状态码（Status-Code）都是三位数字的，分为5大类，原先有 33 种[RFC 2616]，后来又增 加了几种[RFC 6585]。这5大类的状态码都是以不同的数字开头的。 1xx 表示通知信息，如请求收到了或正在进行处理。 2xx 表示成功，如接受或知道了。 3xx 表示重定向，如要完成请求还必须采取进一步的行动。 4xx表示客户的差错，如请求中有错误的语法或不能完成。 5xx表示服务器的差错，如服务器失效无法完成请求。 下面三种状态行在响应报文中是经常见到的。 {接受} HTTP/1。1 202 Accepted HTTP/1。1 400 Bad Request {错误的请求} Http/1。1 404 Not Found {找不到} 若请求的网页从 http：//www。ee。xyz。edu/index。html 转移到了一个新的地址，则响应报文 的状态行和一个首部行就是下面的形式： HTTP/1。1 301 Moved Permanently {永久性地转移了} Location： http：//www。xyz。edu/ee/index。html {新的 URL} 4。 在服务器上存放用户的信息 在本节（6。4。3节）第1小节“HTTP的操作过程”中已经讲过，HTTP 是无状态的。这 样做虽然简化了服务器的设计，但在实际工作中，一些万维网站点却常常希望能够识别用 户。例如，在网上购物时，一个顾客要购买多种物品。当他把选好的一件物品放入“购物 车”后，他还要继续浏览和选购其他物品。因此，服务器需要记住用户的身份，使他接着选 购的一些物品能够放入同一个“购物车”中，这样就便于集中结账。有时某些万维网站点也 可能想限制某些用户的访问。要做到这点，可以在 HTTP 中使用Cookie。在RFC 6265 中对 Cookie 进行了定义，规定万维网站点可以使用 Cookie 来跟踪用户。Cookie 原意是“小甜 饼”（广东人用方言音译为“曲奇”），目前尚无标准译名，在这里 Cookie 表示在 HTTP 服务 器和客户之间传递的状态信息。现在很多网站都已广泛使用Cookie。 Cookie 是这样工作的。当用户 A 浏览某个使用 Cookie 的网站时，该网站的服务器就为 A产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目。接着在 给 A 的 HTTP 响应报文中添加一个叫做 Set-cookie 的首部行。这里的“首部字段名”就是 “Set-cookie”，而后面的“值”就是赋予该用户的“识别码”。例如这个首部行是这样的： Set-cookie： 31d4d96e407aad42 当 A 收到这个响应时，其浏览器就在它管理的特定 Cookie 文件中添加一行，其中包括 这个服务器的主机名和 Set-cookie 后面给出的识别码。当A继续浏览这个网站时，每发送一 个 HTTP 请求报文，其浏览器就会从其 Cookie 文件中取出这个网站的识别码，并放到 HTTP 请求报文的 Cookie 首部行中： Cookie： 31d4d96e407aad42 于是，这个网站就能够跟踪用戶 31d4d96e407aad42（用户 A）在该网站的活动。需 要注意的是，服务器并不需要知道这个用户的真实姓名以及其他的信息。但服务器能够知道 用户 31d4d96e407aad42 在什么时间访问了哪些页面，以及访问这些页面的顺序。如果 A 是在网上购物，那么这个服务器可以为 A 维护一个所购物品的列表，使 A 在结束这次购物 时可以一起付费。 如果 A 在几天后再次访问这个网站，那么他的浏览器会在其 HTTP 请求报文中继续使 用首部行 Cookie： 31d4d96e407aad42，而这个网站服务器根据A 过去的访问记录可以 向他推荐商品。如果A 已经在该网站登记过和使用信用卡付费，那么这个网站就已经保 存了 A 的姓名、电子邮件地址、信用卡号码等信息。这样，当A继续在该网站购物时，只 要还使用同一个电脑上网，由于浏览器产生的HTTP请求报文中都携带了同样的 Cookie 首 部行，服务器就可利用 Cookie 来验证出这是用户A，因此以后A在这个网站购物时就不必 重新在键盘上输入姓名、信用卡号码等信息。这对顾客显然是很方便的。 尽管 Cookie 能够简化用户网上购物的过程，但Cookie的使用一直引起很多争议。有人 认为 Cookie 会把计算机病毒带到用户的计算机中。其实这是对Cookie 的误解。Cookie 只是 一个小小的文本文件，不是计算机的可执行程序，因此不可能传播计算机病毒，也不可能用 来获取用户计算机硬盘中的信息。对于 Cookie 的另一个争议，是关于用户隐私的保护问 题。例如，网站服务器知道了 A 的一些信息，就有可能把这些信息出卖给第三方。Cookie 还可用来收集用户在万维网网站上的行为。这些都属于用户个人的隐私。有些网站为了使顾 客放心，就公开声明他们会保护顾客的隐私，绝对不会把顾客的识别码或个人信息出售或转 移给其他厂商。 为了让用户有拒绝接受 Cookie 的自由，在浏览器中用户可自行设置接受Cookie 的条 件。例如在浏览器IE11。0 中，选择工具栏中的“工具” “Internet 选项”→“隐私”命 令，就可以看见菜单中的左边有一个可上下滑动的标尺，它有六个位置。最高的位置是阻止 所有 Cookie，而最低的位置是接受所有 Cookie。中间的位置则是在不同条件下可以接受 Cookie。用户可根据自己的情况对 IE 浏览器进行必要的设置。 6。4。4 万维网的文档 1。超文本标记语言 HTML 要使任何一台计算机都能显示出任何一个万维网服务器上的页面，就必须解决页面制 作的标准化问题。超文本标记语言 HTML （HyperText Markup Language）就是一种制作万维 网页面的标准语言，它消除了不同计算机之间信息交流的障碍。但请注意，HTML 并不是 应用层的协议，它只是万维网浏览器使用的一种语言。由于 HTML 非常易于掌握且实施简 单，因此它很快就成为万维网的重要基础[RFC 2854]。官方的 HTML 标准由万维网联盟 W3C（即WWW Consortium）负责制定。有关 HTML 的一些参考资料见[W-HTML]。从 HTML 在 1993 年问世后，就不断地对其版本进行更新。现在最新的版本是 HTML 5。0 （2014 年 9 月发布），新的版本增加了在网页中嵌入音频、视频以及交互式文档等功能。现 在一些主流的浏览器都支持HTML 5。0。 HTML 定义了许多用于排版的命令，即“标签”（tag）。例如，<i>表示后面开始用斜体 字排版，而</i>则表示斜体字排版到此结束。HTML 把各种标签嵌入到万维网的页面中，这 样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器（例如， Windows 的记事本 Notepad）创建的ASCII 码文件。但应注意，仅当 HTML 文档是以。html 或。htm 为后缀时，浏览器才对这样的 HTML 文档的各种标签进行解释。如果 HTML 文档 改为以。txt 为其后缀，则 HTML 解释程序就不对标签进行解释，而浏览器只能看见原来的文 本文件。 并非所有的浏览器都支持所有的 HTML 标签。若某一个浏览器不支持某一个 HTML 标 签，则浏览器将忽略此标签，但在一对不能识别的标签之间的文本仍然会被显示出来。 下面是一个简单例子，用来说明 HTML 文档中标签的用法。在每一个语句后面的花括 号中的字是给读者看的注释，在实际的 HTML 文档中并没有这种注释。 <html> <head> <TITLE>一个 HTML 的例子</TITLE> </head> <body> <h1>HTML 很容易掌握</h1> <p>这是第一个段落。</p> {HTML 文档开始} {首部开始} {“一个 HTML 的例子”是文档的标题} {首部结束} {主体开始} {“HTML 很容易掌握”是主体的1级题头} {<p>和</p>之间的文字是一个段落} <p>这是第二个段落。</p> </body> </html> {<p>和</p>之间的文字是一个段落} {主体结束} {HTML 文档结束} 把上面的 HTML 文档存入D盘的文件夹 HTML 中，文件名是HTML-example。html（注 意：实际的文档中没有注释部分）。当浏览器读取了该文档后，就按照 HTML 文档中的各种 标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并显示出来。图 6-13 表示 IE 浏览器在计算机屏幕上显示出的与该文档有关部分的画面。文档的标题（title）“一个 HTML 的例子”显示在浏览器最上面的标题栏中。文件的路径显示在地址栏中。再下面就 是文档的主体部分。主体部分的题头（heading），即文档主体部分的标题“HTML 很容易掌 握”，用较大的字号显示出来，因为在标签中指明了使用的是1级题头<h1>。 目前已开发出了很好的制作万维网页面的软件工具，使我们能够像使用 Word 文字处理 器那样很方便地制作各种页面。即使我们用 Word 文字处理器编辑了一个文件，但只要在 “另存为（Save As）”时选取文件后缀为。htm 或。html，就可以很方便地把 Word 的。doc 格式文 件转换为浏览器可以显示的HTML 格式的文档。 a 个HTML的例子 icrosoft Internet Explorer 文件（z） 编辑（g） 查看收款（a） 工具） 帮助 Q 地址（ ep1。html D：\HTML\HTHL-ex HTML很容易掌握 这是第一个段落、 这是第二个段落。 图6-13 在屏幕上显示的HTML 文档主体部分的例子 HTML 允许在万维网页面中插入图像。一个页面本身带有的图像称为内含图像（inline image）。HTML 标准并没有规定该图像的格式。实际上，大多数浏览器都支持 GIF 和 JPEG 文件。很多格式的图像占据的存储空间太大，因而这种图像在互联网传送时就很浪费时间。 例如，一幅位图文件（。bmp）可能要占用 500 ~ 700 KB 的存储空间。但若将此图像改存为经压 缩的 。gif 格式，则可能只有十几个千字节，大大减少了存储空间。 HTML 还规定了链接的设置方法。我们知道每个链接都有一个起点和终点。链接的起 点说明在万维网页面中的什么地方可引出一个链接。在一个页面中，链接的起点可以是一个 字或几个字，或是一幅图，或是一段文字。在浏览器所显示的页面上，链接的起点是很容易 识别的。在以文字作为链接的起点时，这些文字往往用不同的颜色显示（例如，一般的文字 用黑色字时，链接起点往往使用蓝色字），甚至还会加上下划线（一般由浏览器来设置）。当 我们将鼠标移动到一个链接的起点时，表示鼠标位置的箭头就变成了一只手。这时只要点击 鼠标，这个链接就被激活。 链接的终点可以是其他网站上的页面。这种链接方式叫做远程链接。这时必须在 HTML 文档中指明链接到的网站的URL。有时链接可以指向本计算机中的某一个文件或本 文件中的某处，这叫做本地链接。这时必须在HTML 文档中指明链接的路径。 实际上，现在这种链接方式已经不局限于用在万维网文档中。在最常用的 Word 文字处 理器的工具栏中，也设有“插入超链接”的按钮。只要点击这个按钮，就可以看到设置超链 接的窗口。用户可以很方便地在自己写的 Word 文档中设置各种链接的起点和终点。 在这一小节的最后，我们还要简单介绍一下和浏览器有关的几种其他语言。 XML （Extensible Markup Language）是可扩展标记语言，它和 HTML 很相似。但 XML 的设计宗旨是传输数据，而不是显示数据（HTML 是为了在浏览器上显示数据）。更具体 些，XML 用于标记电子文件，使其具有结构性的标记语言，可用来标记数据、定义数据类 型，是一种允许用户对自己的标记语言进行定义的源语言。XML 是一种简单、与平台无关 并被广泛采用的标准。XML 相对于 HTML 的优点是它将用户界面与结构化数据分隔开 来。这种数据与显示的分离使得集成来自不同源的数据成为可能。客户信息、订单、研究结 果、账单付款、病历、目录数据及其他信息都可以转换为 XML。XML 不是要替换 HTML，而是对 HTML 的补充。XML 标记由文档的作者定义，并且是无限制的。HTML 标记则是预定义的；HTML 作者只能使用当前 HTML 标准所支持的标记。 另一种语言 XHTML （Extensible HTML）是可扩展超文本标记语言，它与HTML 4。01 几 乎是相同的。但XHTML 是更严格的HTML 版本，也是一个W3C标准（2000年1月制 定），是作为一种 XML 应用被重新定义的HTML，并将逐渐取代HTML。所有新的浏览器 都支持 XHTML。 还有一种语言 CSS （Cascading Style Sheets）是层叠样式表，它是一种样式表语言，用于 为HTML 文档定义布局。CSS 与HTML 的区别就是：HTML 用于结构化内容，而 CSS 则 用于格式化结构化的内容。例如，在浏览器上显示的字体、颜色、边距、高度、宽度、背景 图像等方面，都能够给出精确的规定。现在所有的浏览器都支持 CSS。 2。 动态万维网文档 上面所讨论的万维网文档只是万维网文档中最基本的一种，即所谓的静态文档（static document）。静态文档在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程 中，内容不会改变。由于这种文档的内容不会改变，因此用户对静态文档的每次读取所得到 的返回结果都是相同的。 静态文档的最大优点是简单。由于 HTML 是一种排版语言，因此静态文档可以由不懂 程序设计的人员来创建。但静态文档的缺点是不够灵活。当信息变化时就要由文档的作者手 工对文档进行修改。可见，变化频繁的文档不适于做成静态文档。 动态文档（dynamic document）是指文档的内容是在浏览器访问万维网服务器时才由应用 程序动态创建的。当浏览器请求到达时，万维网服务器要运行另一个应用程序，并把控制转 移到此应用程序。接着，该应用程序对浏览器发来的数据进行处理，并输出 HTTP 格式的文 档，万维网服务器把应用程序的输出作为对浏览器的响应。由于对浏览器每次请求的响应都 是临时生成的，因此用户通过动态文档所看到的内容是不断变化的。动态文档的主要优点是 具有报告当前最新信息的能力。例如，动态文档可用来报告股市行情、天气预报或民航售票 情况等内容。但动态文档的创建难度比静态文档的高，因为动态文档的开发不是直接编写文 档本身，而是编写用于生成文档的应用程序，这就要求动态文档的开发人员必须会编程，而 所编写的程序还要通过大范围的测试，以保证输入的有效性。 动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方 法不同。而从浏览器的角度看，这两种文档并没有区别。动态文档和静态文档的内容都遵循 HTML 所规定的格式，浏览器仅根据在屏幕上看到的内容无法判定服务器送来的是哪一种 文档，只有文档的开发者才知道。 从以上所述可以看出，要实现动态文档就必须在以下两个方面对万维网服务器的功能 进行扩充： （1）应增加另一个应用程序，用来处理浏览器发来的数据，并创建动态文档。 （2）应增加一个机制，用来使万维网服务器将浏览器发来的数据传送给这个应用程序， 然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。 图 6-14 是扩充了功能的万维网服务器的示意图。这里增加了一个机制，叫做通用网关 接口 CGI （Common Gateway Interface）。CGI 是一种标准，它定义了动态文档应如何创建， 输入数据应如何提供给应用程序，以及输出结果应如何使用。 在万维网服务器中新增加的应用程序叫做 CGI 程序。取这个名字的原因是：万维网服 务器与 CGI 的通信遵循 CGI 标准。“通用”是因为这个标准所定义的规则对其他任何语言都 是通用的。“网关”二字的出现是因为 CGI程序还可能访问其他的服务器资源，如数据库或 图形软件包，因而 CGI程序的作用有点像一个网关。也有人将 CGI 程序简称为网关程序。 “接口”是因为有一些已定义好的变量和调用等可供其他 CGI 程序使用。请读者注意：在 看到 CGI 这个名词时，应弄清是指CGI 标准，还是指CGI程序。 万维网 万维网服务器 客户端 浏览器 互联网 ·程序 服务器 程序 数据库 HTTP CGD ② CGI 程序创建动态文档 ● 请求文档 HTTP请求报文 ● 响应动态 文档 HTTP 响应报文 图6-14 扩充了功能的万维网服务器 CGI 程序的正式名字是 CGI 脚本（script）。按照计算机科学的一般概念，“脚本”指的 是一个程序，它被另一个程序（解释程序）而不是计算机的处理机来解释或执行。有一些语 言专门作为脚本语言（script language），如 Perl， REXX（在IBM 主机上使用），JavaScript 以 及 Tcl/Tk等。脚本也可用一些常用的编程语言写出，如C，C++等。使用脚本语言可更容易 和更快地进行编码，这对一些有限功能的小程序是很合适的。但一个脚本运行起来比一般的 编译程序要慢，因为它的每一条指令先要被另一个程序来处理（这就要一些附加的指令）， 而不是直接被指令处理器来处理。脚本不一定是一个独立的程序，它可以是一个动态装入的 库，甚至是服务器的一个子程序。 CGI 程序又称为 cgi-bin 脚本，这是因为在许多万维网服务器上，为便于找到 CGI 程 序，就将 CGI 程序放在/cgi-bin 的目录下。 3。 活动万维网文档 随着 HTTP 和万维网浏览器的发展，上一节所述的动态文档已明显地不能满足发展的 需要。这是因为，动态文档一旦建立，它所包含的信息内容也就固定下来而无法及时刷新屏 幕。另外，像动画之类的显示效果，动态文档也无法提供。 有两种技术可用于浏览器屏幕显示的连续更新。一种技术称为服务器推送（server push），这种技术是将所有的工作都交给服务器。服务器不断地运行与动态文档相关联的应 用程序，定期更新信息，并发送更新过的文档。 尽管从用户的角度看，这样做可达到连续更新的目的，但这也有很大的缺点。首先， 为了满足很多客户的请求，服务器就要运行很多服务器推送程序。这将造成过多的服务器开 销。其次，服务器推送技术要求服务器为每一个浏览器客户维持一个不释放的 TCP 连接。 随着 TCP 连接的数目增加，每一个连接所能分配到的网络带宽就下降，这就导致网络传输 时延的增大。 另一种提供屏幕连续更新的技术是活动文档（active document）。这种技术是把所有的工 作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段活动文档程序副 本，使该程序副本在浏览器端运行。这时，活动文档程序可与用户直接交互，并可连续地改 变屏幕的显示。只要用户运行活动文档程序，活动文档的内容就可以连续地改变。由于活动 文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。 从传送的角度看，浏览器和服务器都把活动文档看成是静态文档。在服务器上的活动 文档的内容是不变的，这点和动态文档是不同的。浏览器可在本地缓存一份活动文档的副 本。活动文档还可处理成压缩形式，以便于存储和传送。另一点要注意的是，活动文档本身 并不包括其运行所需的全部软件，大部分的支持软件是事先存放在浏览器中的。图 6-15 说 明了活动文档的创建过程。 • 278 • 万维网 客户端 万维网服务器 浏览器 程序 互联网 服务器 程序 ● 请求文档 ● 此程序在 客户端创建 出活动文档 =D 文档 HTTP HTTP请求报文 HTTP响应报文 程序 ② 响应程序 程序| 程序事先被编译 图6-15 活动文档由服务器发送过来的程序在客户端创建 成二进制代码， 存放为文件 由美国 SUN 公司开发的 Java 语言是一项用于创建和运行活动文档的技术。在 Java 技 术中使用了一个新的名词“小应用程序”（applet）来描述活动文档程序。当用户从万维网服 务器下载一个嵌入了Java 小应用程序的 HTML 文档后，用户可在浏览器的显示屏幕上点击 某个图像，然后就可看到动画的效果；或是在某个下拉式菜单中点击某个项目，即可看到根 据用户键入的数据所得到的计算结果。实际上，Java技术是活动文档技术的一部分。限于 篇幅，有关 Java技术的进一步讨论这里从略。 6。4。5 万维网的信息检索系统 1。全文检索搜索与分类目录搜索 万维网是一个大规模的、联机式的信息储藏所。那么，应当采用什么方法才能找到所 需的信息呢？如果已经知道存放该信息的网点，那么只要在浏览器的地址（Location）框内键 入该网点的 URL 并按回车键，就可进入该网点。但是，若不知道要找的信息在何网点，那 就要使用万维网的搜索工具。 在万维网中用来进行搜索的工具叫做搜索引擎（search engine）。搜索引擎的种类很多， 但大体上可划分为两大类，即全文检索搜索引擎和分类目录搜索引擎。 全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件（例如 一种叫做“蜘蛛”或“网络机器人”的 Spider 程序）到互联网上的各网站收集信息，找到 一个网站后可以从这个网站再链接到另一个网站，像蜘蛛爬行一样。然后按照一定的规则建 立一个很大的在线索引数据库供用户查询。用户在查询时只要输入关键词，就从已经建立的 索引数据库里进行查询（并不是实时地在互联网上检索到的信息）。因此很可能有些查到的 信息已经是过时的（例如很多年前的）。建立这种索引数据库的网站必须定期对已建立的数 据库进行更新维护（但不少网站的维护很不及时，因此对查找到的信息-定要注意其发布的 时间）。现在全球最大的并且最受欢迎的全文检索搜索引擎就是谷歌 Google （www。google。com）。谷歌提供的主要的搜索服务有：网页搜索、图片搜索、视频搜索、地图 搜索、新闻搜索、购物搜索、博客搜索、论坛搜索、学术搜索、财经搜索等。应全球用户的 需求，谷歌在美国及世界各地创建数据中心。至2013年底，谷歌的数据中心在全球共设有 12 处。大多数数据中心的业主基于信息安全考虑，极少透露其数据中心的信息及內部情 形。 我们将在下一小节简单介绍谷歌搜索技术的特点。现在“谷歌”不仅是网站名，而且 还是动词。例如，“谷歌一下”的意思就是“用谷歌网站进行信息搜索”。在全文检索搜索引 擎中另外两个著名的网站是美国微软的必应（cn。bing。com）和中国的百度（www。baidu。com）。 分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交网站信 息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条 件，则输入到分类目录的数据库中，供网上用户查询。因此，分类目录搜索也叫做分类网站 搜索。分类目录的好处就是用户可根据网站设计好的目录有针对性地逐级查询所需要的信 息，查询时不需要使用关键词，只需要按照分类（先找大类，再找下面的小类），因而查询 的准确性较好。但分类目录查询的结果并不是具体的页面，而是被收录网站主页的 URL 地 址，因而所得到的内容就比较有限。相比之下，全文检索可以检索出大量的信息（一次检索 的结果是几百万条，甚至是千万条以上），但缺点是查询结果不够准确，往往是罗列出了海 量的信息（如上千万个页面），使用户无法迅速找到所需的信息。在分类目录搜索引擎中最 著名的就是雅虎（www。yahoo。com）。国内著名的分类搜索引擎有雅虎中国（cn。yahoo。com）、新 浪（sina。com。cn）、搜狐（www。sohu。com）、网易（www。163。com）等。 图 6-16 说明了上述这两种搜索方法的区别。图 6-16（a）是全文搜索谷歌的首页。用户只 需在空白的栏目中键入拟搜索的关键词，搜索引擎就返回搜索结果，用户可根据屏幕上显示 的结果继续点击下去，直到看到满意的结果。图 6-16（b）是分类检索新浪网的首页。我们可 以看到页面上有三行共 63 个类别。用户要检索的内容通常总是在这几十个类别之中，因此 按类别点击查找下去，最后就可以查找到所要检索的内容。 Google ↓ （a）全文检索举例 sina sina。com。cn Siha新浪网 微博 大家正在竣：攜眷高格调喝法 南京 15°C 核心价值观： 网站举报APP下载 O 燒烤网络空间 維护网民权益 新闻 军事 社会 国际 财经 股票 基金 期货 科技 手机探索外汇 体育 NBA 中超 奥运 娱乐 明星 电影 座 汽车 报价 买车 秒车 博客 专栏 文史天气 视频 综艺 航拍 直播 房产 二手房家居 收藏 时间 女性健康 育儿 教育 高考 公益 佛学 圖片 读书 情感 法院 城市 鲜城 旅游 航空 游戏 页游 手游 SHOW 江苏 English 彩票高尔夫 微博 邮箱 更多 √ （b）分类检索举例 图6-16 举例说明两种检索的区别 从用户的角度看，使用这两种不同的搜索引擎一般都能够实现自己查询信息的目的。 为了使用户能够更加方便地搜索到有用信息，目前许多网站往往同时具有全文检索搜索和分 类目录搜索的功能。在互联网上搜索信息需要经验的积累。要多实践才能掌握从互联网获取 信息的技巧。 这里再强调一下，不管哪种搜索引擎，就是告诉你只要链接到什么地方就可以检索到 所需的信息。搜索引擎网站本身并没有直接存储这些信息。 值得注意的是，目前出现了垂直搜索引擎（Vertical Search Engine），它针对某一特定领 域、特定人群或某一特定需求提供搜索服务。垂直搜索也是提供关键字来进行搜索的，但被 放到了一个行业知识的上下文中，返回的结果更倾向于信息、消息、条目等。例如，对买房 的人讲，他希望查找的是房子的具体供求信息（如面积、地点、价格等），而不是有关房子 供求的一般性的论文或新闻、政策等。目前热门的垂直搜索行业有：购物、旅游、汽车、求 职、房产、交友等。还有一种元搜索引擎（Meta Search Engine），它把用户提交的检索请求 发送到多个独立的搜索引擎上去搜索，并把检索结果集中统一处理，以统一的格式提供 给用户，因此是搜索引擎之上的搜索引擎。它的主要精力放在提高搜索速度、智能化处 理搜索结果、个性化搜索功能的设置和用户检索界面的友好性上。元搜索引擎的查全率 和查准率都比较高。 2。 Google 搜索技术的特点 Google 的搜索引擎性能优良，因为它使用了先进的硬件和软件。以往的大多数的搜索 引擎是使用少量大型服务器。在访问高峰期，搜索的速度就会明显减慢。Google 则利用在 互联网上相互链接的计算机来快速查找每个搜索的答案，并且成功地缩短了查找的相应时 间。Google 的搜索软件可同时进行许多运算，它的核心技术就是 PageRank™，译为网页排 名。 PageRank 对搜索出来的结果按重要性进行排序，这是 Google 的两个创始人 Larry Page 和 Sergey Brin 共同开发出来的[W-GOOGLE]。由于用户在有限的时间内，不可能阅读全部 的搜索结果（因为数量往往非常大），而通常仅仅是查阅一下前几个（或前几十个）项目。 因此用户希望检索结果能够按重要性来排序。但怎样确定某个页面的重要性呢？传统的搜索 引擎往往是检查关键字在网页上出现的频率。PageRank 技术则把整个互联网当作了一个整 体对待，检查整个网络链接的结构，并确定哪些网页重要性最高。更具体些，就是如果有很 多网站上的链接都指向页面 A，那么页面 A 就比较重要。PageRank 对链接的数目进行加权 统计。对来自重要网站的链接，其权重也较大。统计链接数目的问题是一个二维矩阵相乘的 问题，从理论上讲，这种二维矩阵的元素数是网页数目的平方。对于1亿个网页，这个矩阵 就有1亿亿个元素。这样大的矩阵相乘，计算量是非常大的。Larry Page 和 Sergey Brin 两人 利用稀疏矩阵计算的技巧，大大地简化了计算量。他们用迭代的方法解决了这个问题。他们 先假定所有网页的排名是相同的，并且根据此初始值，算出各个网页的第一次迭代排名，再 根据第一次迭代排名算出第二次的排名。他们从理论上证明了不论初始值如何选取，这种算 法都保证了网页排名的估计值能收敛到排名的真实值。这种算法是完全没有任何人工干预 的，厂商不可能用金钱购买网页的排名。Google 还要进行超文本匹配分析，以确定哪些网 页与正在执行的特定搜索相关。在综合考虑整体重要性以及与特定查询的相关性之后， Google 就把最相关、最可靠的搜索结果放在首位。 然而有一些著名网站通过“竞价排名”把虚假广告信息放在检索结果的首位，结果误 导了消费者，使受骗者蒙受很大的损失。因此对网络搜索的结果，我们应认真分析其真伪， 提高辨别能力，不要随意轻信网络检索的广告信息（哪怕是知名度很高的网站）。 6。4。6 博客和微博 近年来，万维网的一些新的应用广为流行，这就是博客和微博。下面进行简单的介绍。 1。博客 我们知道，建立网站就是万维网的一种应用。博客（blog）和网站有很相似的地方。博客 的作者可以源源不断地往万维网上的个人博客里填充内容，供其他网民阅读。网民可以用浏 览器上网阅读博客、发表评论，也可以什么都不做。 博客是万维网日志（weblog）的简称。也有人把 blog 进行音译，译为“部落格”，或“部 落阁”。还有人用“博文”来表示“博客文章”。 本来，网络日志是指个人撰写并在互联网上发布的、属于网络共享的个人日记。但现 在它不仅可以是个人日记，而且可以有无数的形式和大小，也没有任何实际的规则。 现在博客已经极大地扩充了互联网的应用和影响，成为了所有网民都可以参与的一种 新媒体，并使得无数的网民有了发言权，有了与政府、机构、企业，以及很多人交流的机 会。在博客出现以前，网民是互联网上内容的消费者，网民在互联网上搜寻并下载感兴趣的 信息。这些信息是其他人生产的，他们把这些信息放在互联网的某个服务器上，供广大网民 使用（也就是供网民消费）。但博客改变了这种情况，网民不仅是互联网上内容的消费者， 而且还是互联网上内容的生产者。 从历史上看，weblog 这个新词是 Jorn Barger 于1997 年创造的。简写的 blog（这是今 天最常用的术语）则是 Peter Merholz 于1999年创造的。不久，有人把blog 既当作名词，也 当作动词，表示编辑博客或写博客。接着，新名词 blogger 也出现了，它表示博客的拥有 者，或博客内容的撰写者和维护者，或博客用户。博客可以看成是继电子邮件、电子公告牌 系统 BBS 和即时传信 IM （Instant Messaging）之后的第四种网络交流方式。 现在从一些著名的门户网站的主页上都能很容易地进入到博客页面，这让用户查看博 客或发表自己的博客都非常方便。前面的图 6-16（b）所示的新浪网站首页， 就可看到在几十 个分类中的第1行第9列的“博客”。 当我们在新浪网站主页点击“博客”时，就可以看到各式各样的博客。也可以利用搜 索工具寻找所需的博客。如果我们已在新浪博客注册了，那么也可随时把自己的博客发表在 此，让别人来阅读。我们还可直接登录新浪博客网站 blog。sina。com。cn。 博客与个人网站还是有不少区别的。这里最主要的区别就是建立个人网站成本较高， 需要租用个人空间、域名等，同时建立网站的个人需要懂得 HTML 语言和网页制作等相关 技术；但博客在这方面是不需要什么投资的，所需的技术仅仅是会上网和会用键盘或书写板 输入汉字即可。因此网民用较短的时间就能够把自己写的博客发表在网上，而不像制作个人 网站那样花费较多的时间。正因为写博客的门槛较低，广大的网民才有可能成为今天互联网 上的信息制造者。 顺便提一下，不要把“博客”和“播客”弄混。播客（Podcast）是苹果手机的一个预装软 件，能够让用户通过手机订阅和自动下载所预订的音乐文件，以便随时欣赏音乐。 2。微博 在图 6-16（b）新浪网站首页各种分类的第1行的最后，可以找到“微博”。微博就是微型 博客（microblog），又称为微博客，它的意思已经非常清楚。博客或微博里的朋友，常称为 “博友”。微博也被人戏称为“围脖”，把博友戏称为“脖友”。 但微博不同于一般的博客。微博只记录片段、碎语，三言两语，现场记录，发发感 慨，晒晒心情，永远只针对一个问题进行回答。微博只是记录自己琐碎的生活，呈现给人 看，而且必须很真实。微博中不必有太多的逻辑思维，很随便，很自由，有点像电影中的一 个镜头。写微博比写其他东西简单多了，不需要标题，不需要段落，更不需要漂亮的词汇。 2009 年是中国微博蓬勃发展的一年，相继出现了新浪微博、139说客、9911、嘀咕网、 同学网、贫嘴等微博客。例如，新浪微博就是由中国最大的门户网站新浪网推出的微博服 务，是中国目前用户数最多的微博网站（weibo。com），名人用户众多是新浪微博的一大特 色，基本已经覆盖大部分知名文体明星、企业高管、媒体人士。用户可以通过网页、WAP 网、手机短信彩信、手机客户端等多种方式更新自己的微博。每条微博字数最初限制为 140 英文字符，但现在已增加了“长微博”的选项， 可输入更多的字符。微博还提供插入图片、 视频、音乐等功能。根据统计，从2010年3月到2012年3月共两年的时间，新浪微博的覆 盖人数从 2510。9 万增长到 3 亿人，而其中 90%的用户认为微博改变了他们与媒体接触的方 式。 现在不少地方政府也开通了微博（即政务微博），这是信息公开的表现。政府可以通过 政务微博，及时公布政情、公务、资讯等，获取与民众更多、更直接、更快的沟通，特别是 在突发事件或者群体性事件发生的时候，微博就能够成为政府新闻发布的一种重要手段。 虽然政务微博具有“传递信息、沟通上下、解决问题”的功能性特点，并受到广大网 民的欢迎，但政务微博的日常管理也非常重要。如果政务微博因缺乏良好的管理而不能够满 足群众的各种需求，那么它就会成为一种无用的摆设。 微博是一种互动及传播性极快的工具，其实时性、现场感及快捷性，往往超过所有媒 体。这是因为微博对用户的技术要求门槛非常低，而且在语言的编排组织上，没有博客那么 高。另外，微博开通的多种API 使大量的用户可通过手机、网络等方式来即时更新自己的 个人信息。微博网站的即时传信功能非常强大，可以通过QQ和MSN直接书写。 我们正处在一个急剧变革的时代，人们需要用贯穿不同社会阶层的信息去了解社会、 改变生活。在互联网上微博的出现正好满足了广大网民的需求。微博发布、转发信息的功能 很强大，这种一个人的“通讯社”将对整个社会产生越来越大的影响。 6。4。7 社交网站 社交网站 SNS （Social Networking Site）是近年来发展非常迅速的一种网站，其作用是为 一群拥有相同兴趣与活动的人创建在线社区。社交网站的功能非常丰富，如电子邮件、即时 传信（在线聊天）、博客撰写、共享相册、上传视频、网页游戏、创建社团、刊登广告等， 对现实社交结构已经形成了巨大冲击。社交网络服务提供商针对不同的群众，有着不同的定 位，对个人消费者都是免费的。这种网站通过朋友，一传十，十传百地把联系范围不断扩大 下去。前面曾提到过的BBS和微博，可以看作是社交网站的前身。 2004 年社交网站脸书（Facebook，又名面书、脸谱、脸谱网）在美国诞生。脸书最初的用 户定位是大学生，但现在它的用户范围已经扩大了很多。接着社交网站热潮席卷全球，而国内 以人人网、开心网等为代表的社交网站也如雨后春笋般迅速崛起。社交网站极大地丰富了人 们的社交生活，孕育了新的经济增长点，其所蕴含的巨大商业价值和社会力量也正凸显出来。 毫无疑问，目前世界上排名第一且分布最广的社交网站是脸书。脸书最大的特点就是 可以非常方便地寻找朋友或联系老同学、老同事，能够简易地在朋友圈中分享图片、视频和 音频文件（现在也可以发送其他文件，如。docx， xlsx 等），以及通过集成的地图功能分享用 户所在的位置。现在脸书的月度活跃用户已达11。5亿人之多，其中半数以上为移动电话用 户。在 2010年3月，脸书在美国的访问人数已超过谷歌，成为全美访问量最大的网站。脸 书的官网域名为 Facebook。com，并持有。cn 域名 Facebook。cn。排名第二的社交网站是视频分 享网站 YouTube，其月度活跃用户人数为10亿人。2006年 YouTube。com 网站被谷歌收购， 目前谷歌手上持有了 youtube。com/。com。cn/。net/。org 等域名。国内类似的视频分享网站有优酷 （www。youku。com）、土豆（movie。tudou。com）、56网（56。com）等。 另一种能够提供微博服务的社交网络现在也很流行。例如推特 Twitter （twitter。com） 网 站创建于 2006 年，它可以让用户发表不超过140个英文字符的消息。这些消息也被称为 “推文”（Tweet）。我国的新浪微博（www。weibo。com）、腾讯微博（t。qq。com）等就是这种性质的 社交网站。职业性社交网站领英LinkedIn 也是很受欢迎的网站。 目前在我国最为流行的社交网站就是微信（weixin。qq。com）。微信最初是专为手机用户使 用的聊天工具，其功能是“收发信息、拍照分享、联系朋友”。但几年来经过多次系统更 新，现在微信不仅可传送文字短信、图片、录音电话、视频短片，还可提供实时音频或视频 聊天，甚至可进行网上购物、转账、打车，等等。原来微信仅限于在手机上使用，但新的微 信版本已能够安装在普通电脑上。现在微信的功能已远远超越了社交领域。我们知道，电子 邮件可以发送给网上任何一个并不认识你的用户，也不管他是否愿意接收你发送的邮件。各 种博客和微博也可供任何上网用户浏览。但微信只能在确定的朋友圈中交换信息。正是由于 朋友之间更加需要交换信息，而微信的功能又不断在扩展，因此微信在我国已成为几乎每个 网民都使用的应用软件。 6。5 电子邮件 6。5。1 电子邮件概述 大家知道，实时通信的电话有两个严重缺点。第一，电话通信的主叫和被叫双方必须 同时在场。第二，有些电话常常不必要地打断被叫者的工作或休息。 电子邮件（e-mail）是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件 发送到收件人使用的邮件服务器，并放在其中的收件人邮箱（mail box）中，收件人可在自己 方便时上网到自己使用的邮件服务器进行读取。这相当于互联网为用户设立了存放邮件的信 箱，因此 e-mail 有时也称为“电子信箱”。电子邮件不仅使用方便，而且还具有传递迅速和 费用低廉的优点。据有的公司报道，使用电子邮件后可提高劳动生产率 30%以上。现在电 子邮件不仅可传送文字信息，而且还可附上声音和图像。由于电子邮件和手机的广泛使用， 现已迫使传统的电报业务退出市场，因为这种传统电报既贵又慢，且很不方便。 1982 年 ARPANET 的电子邮件问世后，很快就成为最受广大网民欢迎的互联网应用。 电子邮件的两个最重要的标准就是：简单邮件传送协议SMTP（Simple Mail Transfer Protocol） [RFC 5321]和互联网文本报文格式[RFC 5322]。 由于互联网的 SMTP 只能传送可打印的7位ASCII 码邮件，因此在 1993 年又提出了通 用互联网邮件扩充 MIME （Multipurpose Internet Mail Extensions）。MIME 在其邮件首部中说 明了邮件的数据类型（如文本、声音、图像、视像等）。在 MIME 邮件中可同时传送多种类 型的数据。这在多媒体通信的环境下是非常有用的。 一个电子邮件系统应具有图 6-17 所示的三个主要组成构件，这就是用户代理、邮件服 务器，以及邮件发送协议（如 SMTP）和邮件读取协议（如POP3）。POP3 是邮局协议（Post Office Protocol）的版本3。凡是有TCP 连接的，都经过了互联网，有的甚至可以跨越数千公 里的距离。这里为简洁起见，没有画出网络。在互联网中，邮件服务器的数量是很大的。正 是这些邮件服务器构成了电子邮件基础结构的核心。在图6-17 中为了说明问题，仅仅画出 了两个邮件服务器。 发件人 用户代理 发送方 接收方 发送邮件服务器 邮件服务器 邮件 SMTP SMTP SMTP POP3 读取 邮件 POP3 收件人 用户代理 POP3 客戶 TCP （服务器） 服务器 TCP 客戶 连接 连接 SMTP 发送邮件 SMTP /SMTP™ 客戶 TCP 连接 服务器 用户邮箱 （读取邮件） 发送方 （发送邮件） SMTP POP3 （发送邮件）SMTP 接收方 用户代理 邮件缓存 发送方 邮件服务器 互联网 接收方 邮件服务器 用户代理 图6-17 电子邮件的最主要的组成构件 用户代理 UA （User Agent）就是用户与电子邮件系统的接口，在大多数情况下它就是运 行在用户电脑中的一个程序。因此用户代理又称为电子邮件客户端软件。用户代理向用户提 供一个很友好的接口（目前主要是窗口界面）来发送和接收邮件。现在可供大家选择的用户 代理有很多种。例如，微软公司的Outlook Express 和我国张小龙制作的Foxmail，都是很受 欢迎的电子邮件用户代理。 用户代理至少应当具有以下4个功能。 （1）撰写。给用户提供编辑信件的环境。例如，应让用户能创建便于使用的通讯录（有 常用的人名和地址）。回信时不仅能很方便地从来信中提取出对方地址，并自动地将此地址 写入到邮件中合适的位置，而且还能方便地对来信提出的问题进行答复（系统自动将来信复 制一份在用户撰写回信的窗口中，因而用户不需要再输入来信中的问题）。 （2） 显示。能方便地在计算机屏幕上显示出来信（包括来信附上的声音和图像）。 （3）处理。处理包括发送邮件和接收邮件。收件人应能根据情况按不同方式对来信进行 处理。例如，阅读后删除、存盘、打印、转发等，以及自建目录对来信进行分类保存。有时 还可在读取信件之前先查看一下邮件的发件人和长度等，对于不愿收的信件可直接在邮箱中 删除。 （4） 通信。发信人在撰写完邮件后，要利用邮件发送协议发送到用户所使用的邮件服务 收件人在接收邮件时，要使用邮件读取协议从本地邮件服务器接收邮件。 互联网上有许多邮件服务器可供用户选用（有些要收取少量的邮箱费用）。邮件服务器 24 小时不间断地工作，并且具有很大容量的邮件信箱。邮件服务器的功能是发送和接收邮 件，同时还要向发件人报告邮件传送的结果（已交付、被拒绝、丢失等）。邮件服务器按照 客户服务器方式工作。邮件服务器需要使用两种不同的协议。一种协议用于用户代理向邮件 服务器发送邮件或在邮件服务器之间发送邮件，如 SMTP 协议，而另一种协议用于用户代 理从邮件服务器读取邮件，如邮局协议 POP3。 这里应当注意，邮件服务器必须能够同时充当客户和服务器。例如，当邮件服务器 A 向另一个邮件服务器B发送邮件时，A 就作为 SMTP 客户，而 B 是 SMTP 服务器。反之， 当 B 向 A 发送邮件时，B 就是 SMTP 客户，而A 就是 SMTP 服务器。 图 6-17 给出了计算机之间发送和接收电子邮件的几个重要步骤。请注意，SMTP 和 POP3（或 IMAP）都是使用TCP连接来传送邮件的，使用TCP 的目的是为了可靠地传送 邮件。 发件人调用计算机中的用户代理撰写和编辑要发送的邮件。 • 发件人点击屏幕上的“发送邮件”按钮，把发送邮件的工作全都交给用户代理来完 成。用户代理把邮件用 SMTP 协议发给发送方邮件服务器，用户代理充当 SMTP 客户，而 发送方邮件服务器充当 SMTP 服务器。用户代理所进行的这些工作，用户是看不到的。有 的用户代理可以让用户在屏幕上看见邮件发送的进度显示。用户所使用的邮件服务器究竟在 什么地方，用户并不知道，也不必要知道。实际上，用户在把写好的信件交付给用户代理 后，就什么都不用管了。 ● SMTP 服务器收到用户代理发来的邮件后，就把邮件临时存放在邮件缓存队列中， 等待发送到接收方的邮件服务器（等待时间的长短取决于邮件服务器的处理能力和队列中待 发送的信件的数量。但这种等待时间一般都远远大于分组在路由器中等待转发的排队时 间）。 ● 发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP 服务器建立TCP连 接，然后就把邮件缓存队列中的邮件依次发送出去。请注意，邮件不会在互联网中的某个中 间邮件服务器落地。如果SMTP客户还有一些邮件要发送到同一个邮件服务器，那么可以 在原来已建立的TCP连接上重复发送。如果SMTP客户无法和SMTP服务器建立TCP连接 （例如，接收方服务器过负荷或出了故障），那么要发送的邮件就会继续保存在发送方的邮 件服务器中，并在稍后一段时间再进行新的尝试。如果SMTP客户超过了规定的时间还不 能把邮件发送出去，那么发送邮件服务器就把这种情况通知用户代理。 ● 运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的 用户邮箱中，等待收件人进行读取。 • 收件人在打算收信时，就运行计算机中的用户代理，使用POP3（或IMAP）协议读 取发送给自己的邮件。请注意，在图6-17中，POP3 服务器和 POP3 客户之间的箭头表示的 是邮件传送的方向。但它们之间的通信是由POP3客户发起的。 请注意这里有两种不同的通信方式。一种是“推”（push）： SMTP 客户把邮件“推”给 SMTP 服务器。另一种是“拉”（pull）：POP3 客户把邮件从 POP3 服务器“拉”过来。细心 的读者可能会想到这样的问题：如果让图 6-17 中的邮件服务器程序就在发送和接收方的 计算机中运行，那么岂不是可以直接把邮件发送到收件人的计算机中？ 答案是“不行”。这是因为并非所有的计算机都能运行邮件服务器程序。有些计算机可能 没有足够的存储空间来运行允许程序在后台运行的操作系统，或是可能没有足够的 CPU 能 力来运行邮件服务器程序。更重要的是，邮件服务器程序必须不间断地运行，每天24 小时 都必须不间断地连接在互联网上，否则就可能使很多外面发来的邮件无法接收。这样看来， 让用户的计算机运行邮件服务器程序显然是很不现实的（一般用户在不使用计算机时就将机 器关闭）。让来信暂时存储在用户的邮件服务器中，而当用户方便时就从邮件服务器的用户 信箱中读取来信，则是一种比较合理的做法。在 Foxmail 中使用一种“特快专递”服务。这 种服务就是从发件人的用户代理直接利用 SMTP 把邮件发送到接收方邮件服务器。这就加 快了邮件的交付（省去在发送邮件服务器中的排队等待时间）。但这种“特快专递”和邮 政的 EMS 直接把邮件送到用户家中不同，它并没有把邮件直接发送到收件人的计算机中。 但有些邮件服务器为了防止垃圾邮件和计算机病毒，拒绝接收从一般用户直接发来的邮件。 电子邮件由信封（envelope）和内容（content）两部分组成。电子邮件的传输程序根据邮件信 封上的信息来传送邮件。这与邮局按照信封上的信息投递信件是相似的。 在邮件的信封上，最重要的就是收件人的地址。TCP/IP体系的电子邮件系统规定电子 邮件地址（e-mail address）的格式如下： 用户名 @ 邮件服务器的域名 （6-1） 在上式中，符号“@”读作“at”，表示“在”的意思。例如，在电子邮件地址 “xyz@abc。com”中，“abc。com”就是邮件服务器的域名，而“xyz”就是在这个邮件服务 器中收件人的用户名，也就是收件人邮箱名，是收件人为自己定义的字符串标识符。但应注 意，这个用户名在邮件服务器中必须是唯一的（当用户定义自己的用户名时，邮件服务器要 负责检查该用户名在本服务器中的唯一性）。这样就保证了每一个电子邮件地址在世界范围 内是唯一的。这对保证电子邮件能够在整个互联网范围内的准确交付是十分重要的。电子邮 件的用户一般采用容易记忆的字符串。 6。5。2 简单邮件传送协议 SMTP 下面介绍 SMTP的一些主要特点。 SMTP 规定了在两个相互通信的 SMTP 进程之间应如何交换信息。由于SMTP 使用客 户服务器方式，因此负责发送邮件的SMTP 进程就是SMTP客户，而负责接收邮件的 SMTP 进程就是SMTP服务器。至于邮件内部的格式，邮件如何存储，以及邮件系统应以多 快的速度来发送邮件，SMTP也都未做出规定。 SMTP 规定了 14条命令和21种应答信息。每条命令用几个字母组成，而每一种应答信 息一般只有一行信息，由一个3位数字的代码开始，后面附上（也可不附上）很简单的文字 说明。下面通过发送和接收方的邮件服务器之间的 SMTP 通信的三个阶段介绍几个最主 要的命令和响应信息。 1。连接建立 发件人的邮件送到发送方邮件服务器的邮件缓存后，SMTP 客户就每隔一定时间（例如 30分钟）对邮件缓存扫描一次。如发现有邮件，就使用SMTP 的熟知端口号码 25 与接收方 邮件服务器的 SMTP 服务器建立 TCP 连接。在连接建立后，接收方 SMTP 服务器要发出 “220 Service ready”（服务就绪）。然后 SMTP 客户向SMTP 服务器发送HELO命令，附上 发送方的主机名。SMTP 服务器若有能力接收邮件，则回答：“250 OK”，表示已准备好接 收。若 SMTP 服务器不可用，则回答“421 Service not available”（服务不可用）。 如在一定时间内（例如三天）发送不了邮件，邮件服务器会把这个情况通知发件人。 SMTP 不使用中间的邮件服务器。不管发送和接收方的邮件服务器相隔有多远，不管 在邮件传送过程中要经过多少个路由器，TCP 连接总是在发送和接收方这两个邮件服务 器之间直接建立。当接收方邮件服务器出故障而不能工作时，发送方邮件服务器只能等待一 段时间后再尝试和该邮件服务器建立 TCP 连接，而不能先找一个中间的邮件服务器建立 TCP 连接。 2。邮件传送 邮件的传送从 MAIL 命令开始。MAIL 命令后面有发件人的地址。如：MAIL FROM： &lt;xiexiren@tsinghua。org。cn&gt;。若 SMTP 服务器已准备好接收邮件，则回答“250 OK”。否 则，返回一个代码，指出原因。如：451（处理时出错），452 （存储空间不够），500 （命令 无法识别）等。 下面跟着一个或多个 RCPT 命令，取决于把同一个邮件发送给一个或多个收件人，其 格式为 RCPT TO：<收件人地址>。RCPT 是 recipient（收件人）的缩写。每发送一个 RCPT 命令，都应当有相应的信息从 SMTP 服务器返回，如：“250 OK”，表示指明的邮箱在接收 方的系统中，或“550 No such user here”（无此用户），即不存在此邮箱。 RCPT 命令的作用就是：先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮 件。这样做是为了避免浪费通信资源，不至于发送了很长的邮件以后才知道地址错误。 再下面就是 DATA 命令，表示要开始传送邮件的内容了。SMTP 服务器返回的信息是： “354 Start mail input； end with <CRLF>。<CRLF>”。这里<CRLF>是“回车换行”的意思。若 不能接收邮件，则返回421（服务器不可用），500（命令无法识别）等。接着 SMTP 客户就 发送邮件的内容。发送完毕后，再发送<CRLF>。<CRLF>（两个回车换行中间用一个点隔 开）表示邮件内容结束。实际上在服务器端看到的可打印字符只是一个英文的句点。若邮件 收到了，则 SMTP 服务器返回信息“250 OK”，或返回差错代码。 虽然 SMTP 使用TCP连接试图使邮件的传送可靠，但“发送成功”并不等于“收件人 读取了这个邮件”。当一个邮件传送到接收方的邮件服务器后（即接收方的邮件服务器收下 了这个邮件），再往后的情况如何，就有好几种可能性。接收方的邮件服务器也可能接着就 出了故障，使收到的邮件全部丢失（在收件人读取信件之前）。也可能被邮件服务器的软件 当作垃圾邮件删除了。也可能收件人在清理自己的邮箱时，把尚未读取的邮件一起都删除 了。有时收件人由于某种原因，很久没有查阅自己的邮箱，根本不知道自己的邮箱中有一些 来信。因此，一个邮件即使是“发送成功”，收件人也不一定会读取到这个邮件。尽管如 此，基于 SMTP 的电子邮件通常都被认为是可靠的。 3。 连接释放 邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是“221 （服务关闭）”，表示SMTP 同意释放 TCP 连接。邮件传送的全部过程即结束。 这里再强调一下，使用电子邮件的用户看不见以上这些过程，所有这些复杂过程都被 电子邮件的用户代理屏蔽了。 已经广泛使用多年的 SMTP 存在着一些缺点。例如，发送电子邮件不需要经过鉴别。 这就是说，在 FROM 命令后面的地址可以任意填写。这就大大方便了垃圾邮件的作者，给 收信人添加了麻烦（有人估计，在全世界所有的电子邮件中，垃圾邮件至少占到 50%以 上，甚至高达 90%）。又如，SMTP 本来就是为传送 ASCII 码而不是传送二进制数据设计 的。虽然后来有了 MIME 可以传送二进制数据（见后面 6。5。6 节的介绍），但在传送非 ASCII 码的长报文时，在网络上的传输效率是不高的。此外，SMTP 传送的邮件是明文，不 利于保密。 为了解决上述问题，2008 年 10 月颁布的 RFC 5321 对 SMTP 进行了扩充，成为扩充的 SMTP （Extended SMTP），记为ESMTP。RFC 5321 在许多命令中增加了扩展的参数。新增加 的功能有：客户端的鉴别，服务器接受二进制报文，服务器接受分块传送的大报文，发送前 先检查报文的大小，使用安全传输 TLS（见下一章 7。6。2 节），以及使用国际化地址等。考 虑到现在的许多 SMTP 邮件服务器可能还没有升级到 ESMTP，因此特规定使用 ESMTP 的 客户端在准备传送报文时，不是发送 HLLO 而是发送 EHLO 报文。如果 EHLO 报文被对方 服务器端拒绝，就表明对方仍然是一个标准的 SMTP 邮件服务器（不使用扩展的参数），因 而就要按照原来使用的SMTP 参数进行邮件的传送。如果 EHLO 报文被接受了，那么客户 端就可以使用 ESMTP扩展的参数传送报文了。 6。5。3 电子邮件的信息格式 一个电子邮件分为信封和内容两大部分。在 RFC 5322 文档中只规定了邮件内容中的首 部（header）格式，而对邮件的主体（body）部分则让用户自由撰写。用户写好首部后，邮件系统 自动地将信封所需的信息提取出来并写在信封上。所以用户不需要填写电子邮件信封上的信 息。 邮件内容首部包括一些关键字，后面加上冒号。最重要的关键字是：To 和 Subject。 “To：”后面填入一个或多个收件人的电子邮件地址。在电子邮件软件中，用户把经常 通信的对象姓名和电子邮件地址写到地址簿（address book）中。当撰写邮件时，只需打开地址 簿，点击收件人名字，收件人的电子邮件地址就会自动地填入到合适的位置上。 “ Subject： ”是邮件的主题。它反映了邮件的主要内容。主题类似于文件系统的文件 名，便于用户查找邮件。 邮件首部还有一项是抄送“Cc：”。这两个字符来自“Carbon copy”，意思是留下一个 “复写副本”。这是借用旧的名词，表示应给某某人发送一个邮件副本。 有些邮件系统允许用户使用关键字 Bcc （Blind carbon copy）来实现盲复写副本。这是使 发件人能将邮件的副本送给某人，但不希望此事为收件人知道。Bcc 又称为暗送。 首部关键字还有“From”和“Date”，表示发件人的电子邮件地址和发信日期。这两项 一般都由邮件系统自动填入。 另一个关键字是“Reply-To”，即对方回信所用的地址。这个地址可以与发件人发信时 所用的地址不同。例如有时到外地借用他人的邮箱给自己的朋友发送邮件，但仍希望对方将 回信发送到自己的邮箱。这一项可以事先设置好，不需要在每次写信时进行设置。 6。5。4 邮件读取协议 POP3 和 IMAP 现在常用的邮件读取协议有两个，即邮局协议第 3 个版本 POP3 和网际报文存取协议 IMAP （Internet Message Access Protocol）。现分别讨论如下。 邮局协议 POP 是一个非常简单，但功能有限的邮件读取协议。邮局协议 POP 最初公布 于1984年。经过几次更新，现在使用的是1996年的版本POP3 [RFC 1939]，它已成为互联 网的正式标准。大多数的ISP 都支持 POP3。 POP3 也使用客户服务器的工作方式。在接收邮件的用户计算机中的用户代理必须运行 POP3 客户程序，而在收件人所连接的ISP的邮件服务器中则运行 POP3 服务器程序。当 然，这个 ISP 的邮件服务器还必须运行 SMTP 服务器程序，以便接收发送邮件服务器的 SMTP 客户程序发来的邮件。这些请参阅图 6-17。POP3 服务器只有在用户输入鉴别信息 （用户名和口令）后，才允许对邮箱进行读取。 POP3 协议的一个特点就是只要用户从 POP3 服务器读取了邮件，POP3 服务器就把该 邮件删除。这在某些情况下就不够方便。例如，某用户在办公室的台式计算机上接收了一个 邮件，还来不及写回信，就马上携带笔记本电脑出差。当他打开笔记本电脑写回信时， POP3 服务器上却已经删除了原来已经看过的邮件（除非他事先将这些邮件复制到笔记本电 脑中）。为了解决这一问题，POP3 进行了一些功能扩充，其中包括让用户能够事先设置 邮件读取后仍然在POP3 服务器中存放的时间[RFC 2449]。目前 RFC 2449 是互联网建议 标准。 另一个读取邮件的协议是网际报文存取协议 IMAP，它比 POP3 复杂得多。IMAP 和 POP 都按客户服务器方式工作，但它们有很大的差别。现在较新的版本是2003年3月修订 的版本 4，即 IMAP4 [RFC 3501]，它目前也是互联网的建议标准。不过在习惯上，对这个 协议大家很少加上版本号“4”，而经常简单地用IMAP表示IMAP4。但是对 POP3 却不会 忘记写上版本号“3”。 在使用 IMAP 时，在用户的计算机上运行 IMAP 客户程序，然后与接收方的邮件服务 器上的 IMAP 服务器程序建立TCP连接。用户在自己的计算机上就可以操纵邮件服务器的 邮箱，就像在本地操纵一样，因此 IMAP 是一个联机协议。当用户计算机上的IMAP 客户程 序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该 邮件才传到用户的计算机上。用户可以根据需要为自己的邮箱创建便于分类管理的层次式的 邮箱文件夹，并且能够将存放的邮件从某一个文件夹中移动到另一个文件夹中。用户也可按 某种条件对邮件进行查找。在用户未发出删除邮件的命令之前，IMAP 服务器邮箱中的邮件 一直保存着。 IMAP 最大的好处就是用户可以在不同的地方使用不同的计算机（例如，使用办公室的 计算机、或家中的计算机，或在外地使用笔记本电脑）随时上网阅读和处理自己在邮件服务 器中的邮件。IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像 附件（此文件可能很大）的邮件，而用户使用的是无线上网，信道的传输速率很低。为了节 省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很大的附件。 IMAP 的缺点是如果用户没有将邮件复制到自己的计算机上，则邮件一直存放在 IMAP 服务器上。要想查阅自己的邮件，必须先上网。 下面的表 6-2 给出了 IMAP 和 POP3 的主要功能的比较。 表 6-2 IMAP 和POP3的主要功能比较 操作位置 操作内容 IMAP 收件箱 发件箱 阅读、标记、移动、删除邮件等 保存到已发送 创建文件夹 草稿 新建自定义的文件夹 保存草稿 垃圾文件夹 接收并移入垃圾文件夹的邮件 客户端与邮箱更新同步 客户端与邮箱更新同步 客户端与邮箱更新同步 客户端与邮箱更新同步 支持 POP3 仅在客户端内 仅在客户端内 仅在客户端内 仅在客户端内 不支持 广告邮件 接收并移入广告邮件夹的邮件 支持 不支持 最后再强调一下，不要把邮件读取协议 POP3 或IMAP 与邮件传送协议 SMTP 弄混。发 件人的用户代理向发送方邮件服务器发送邮件，以及发送方邮件服务器向接收方邮件服务器 发送邮件，都是使用 SMTP 协议。而POP3 或IMAP则是用户代理从接收方邮件服务器上读 取邮件所使用的协议。 6。5。5 基于万维网的电子邮件 从前面的图 6-17 可看出，用户要使用电子邮件，必须在自己使用的计算机中安装用户 代理软件 UA。如果外出到某地而又未携带自己的笔记本电脑，那么要使用别人的计算机进 行电子邮件的收发，将是非常不方便的。 现在这个问题解决了。在20 世纪 90 年代中期，Hotmail 推出了基于万维网的电子邮件 （Webmail）。今天，几乎所有的著名网站以及大学或公司，都提供了万维网电子邮件。常用 的万维网电子邮件有谷歌的 Gmail，微软的 Hotmail，雅虎的 Yahoo! Mail。我国的网易 （163 或126）和新浪（sina）等互联网技术公司也都提供万维网邮件服务。 万维网电子邮件的好处就是：不管在什么地方（在任何一个国家的网吧、宾馆或朋友 家中），只要能够找到上网的计算机，在打开任何一种浏览器后，就可以非常方便地收发电 子邮件。使用万维网电子邮件不需要在计算机中再安装用户代理软件。浏览器本身可以向用 户提供非常友好的电子邮件界面（和原来的用户代理提供的界面相似），使用户在浏览器上 就能够很方便地撰写和收发电子邮件。 例如，你使用的是网易163邮箱，那么在任何一个浏览器的地址栏中，键入 163邮 箱的 URL （mail。163。com），按回车键后，就可以使用163 电子邮件了，这和在家中一样 方便。你曾经接收和发送过的邮件，已删除的邮件以及你的通讯录等内容，都照常呈现在屏 幕上。 我们知道，用户在浏览器中浏览各种信息时需要使用HTTP 协议。因此，在浏览器和 互联网上的邮件服务器之间传送邮件时，仍然使用HTTP协议。但是在各邮件服务器之间传 送邮件时，则仍然使用SMTP协议。 6。5。6 通用互联网邮件扩充MIME 1。 MIME概述 前面所述的电子邮件协议 SMTP 有以下缺点： （1） SMTP 不能传送可执行文件或其他的二进制对象。人们曾试图将二进制文件转换为 SMTP 使用的 ASCII 文本，例如流行的 UNIX_UUencode/UUdecode 方案，但这些均未形成 正式标准或事实上的标准。 （2） SMTP 限于传送7位的ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚 至带重音符号的法文或德文）就无法传送。即使在 SMTP 网关将 EBCDIC 码（即扩充的二/ 十进制交换码）转换为ASCII码，也会遇到一些麻烦。 （3） SMTP 服务器会拒绝超过一定长度的邮件。 （4） 某些 SMTP 的实现并没有完全按照SMTP 的互联网标准。常见的问题如下： 回车、换行的删除和增加； 超过 76 个字符时的处理：截断或自动换行； 后面多余空格的删除； • 将制表符 tab 转换为若干个空格。 于是在这种情况下就提出了通用互联网邮件扩充 MIME [RFC 2045~2049]。MIME并 没有改动或取代 SMTP。MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结 构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程 序和协议下传送。图6-18表示MIME 和 SMTP 的关系。 用户 用户 非 ASCII码 MIME 非 ASCII码 MIME | 7位ASCII码 7位ASCII码 7位ASCII码 SMTP SMTP 图6-18 MIME 和 SMTP 的关系 MIME 主要包括以下三部分内容： （1） 5 个新的邮件首部字段，它们可包含在原来的邮件首部中。这些字段提供了有关邮 件主体的信息。 （2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。 （3）定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。 为适应于任意数据类型和表示，每个MIME 报文包含告知收件人数据类型和使用编码 的信息。MIME 把增加的信息加入到原来的邮件首部中。 下面是 MIME 增加的5个新的邮件首部的名称及其意义（有的可以是选项）。 （1） MIME-Version： 标志 MIME 的版本。现在的版本号是1。0。若无此行，则为英文文 本。 （2） Content-Description：这是可读字符串，说明此邮件主体是否是图像、音频或视频。 （3） Content-Id：邮件的唯一标识符。 （4） Content-Transfer-Encoding： 在传送时邮件的主体是如何编码的。 （5） Content-Type： 说明邮件主体的数据类型和子类型。 上述的前三项的意思很清楚，因此下面只对后两项进行介绍。 2。内容传送编码 下面介绍三种常用的内容传送编码 （Content-Transfer-Encoding）。 最简单的编码就是7位ASCII 码，而每行不能超过1000个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。 另一种编码称为quoted-printable，这种编码方法适用于所传送的数据中只有少量的非 ASCII 码，例如汉字。这种编码方法的要点就是对于所有可打印的ASCII 码，除特殊字符等 号“=”外，都不改变。等号“=”和不可打印的 ASCII 码以及非 ASCII 码的数据的编码方 法是：先将每个字节的二进制代码用两个十六进制数字表示，然后在前面再加上一个等号 “=”。例如，汉字的“系统”的二进制编码是：11001111 10110101 11001101 10110011（共 有 32 位，但这四个字节都不是 ASCII 码），其十六进制数字表示为：CFB5CDB3。用 quoted-printable 编码表示为：=CF=B5=CD=B3，这12个字符都是可打印的ASCII 字符，它 • 们的二进制编码需要96位，和原来的32位相比，开销达200%。而等号“=”的二进制代 码为 00111101，即十六进制的 3D，因此等号“=”的quoted-printable 编码为“=3D”。 对于任意的二进制文件，可用 base64 编码。这种编码方法是先把二进制代码划分为一 个个 24 位长的单元，然后把每一个24位单元划分为4个6位组。每一个6位组按以下方法 转换成 ASCII 码。6位的二进制代码共有 64 种不同的值，从0到63。用 A 表示 0，用 B 表 示1，等等。26个大写字母排列完毕后，接下去再排26个小写字母，再后面是10个数字， 最后用“+”表示 62，而用“/”表示63。再用两个连在一起的等号“= ”和一个等号 “=”分别表示最后一组的代码只有 8 位或 16 位。回车和换行都忽略，它们可在任何地方 插入。 下面是一个 base64编码的例子： 24位二进制代码 划分为4个6位组 对应的 base64编码 用 ASCII编码发送 01001001 00110001 01111001 010010 010011 000101 111001 S T F 5 01010011 01010100 01000110 00110101 不难看出，24 位的二进制代码采用 base64编码后变成了32位，开销为25%。 3。 内容类型 MIME 标准规定 Content-Type 说明必须含有两个标识符，即内容类型（type）和子类型 （subtype），中间用“/”分开。 MIME 标准原先定义了7个基本内容类型和15种子类型（见RFC 1521，但这个文档已 被列入“陈旧的”）。除了内容类型和子类型，MIME 允许发件人和收件人自己定义专用的内 容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串 X-开始。但是，后来陆续出现了几百个子类型，而且子类型的数目还在不断地增加。现在 可以在网站上查出现有的MIME类型和子类型的名称，以及申请新的子类型的具体步骤[W- MEDIA-TYPE]。表6-3 列出了MIME的内容类型、子类型举例及其说明®。 表6-3 可出现在 MIME Content-Type 说明中的类型及子类型举例 内容类型 子类型举例 text（文本） |plain， html， xml， css image（图像） audio （音频） | gif， jpeg， tiff | basic， mpeg， mp4 video （视频） | mpeg， mp4， quicktime 说明 | 不同格式的文本 | 不同格式的静止图像 可听见的声音 不同格式的影片 续表 内容类型 子类型举例 说明 | model （模型） vrml | 3D模型 不同应用程序产生的数据 （ message （报文） | multipart（多部分） | 封装的报文 多种类型的组合 | application（应用） | octet-stream， pdf， javascript， zip |http， rfc822 | mixed， alternative， parallel， digest MIME 的内容类型中的 multipart 是很有用的，因为它使邮件增加了相当大的灵活性。 MIME 标准为 multipart 定义了四种可能的子类型，每个子类型都提供重要功能。 （1） mixed 子类型允许单个报文含有多个相互独立的子报文，每个子报文可有自己的类 型和编码。mixed 子类型报文使用户能够在单个报文中附上文本、图形和声音，或者用额外 数据段发送一个备忘录，类似商业信笺含有的附件。在 mixed 后面还要用到一个关键字，即 Boundary=，此关键字定义了分隔报文各部分所用的字符串（由邮件系统定义），只要在邮 件的内容中不会出现这样的字符串即可。当某一行以两个连字符“--”开始，后面紧跟上述 的字符串，就表示下面开始了另一个子报文。 （2） alternative 子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件和 软件系统的收件人发送备忘录时，这种类型的 multipart 报文很有用。例如，用户可同时用 普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在查看 图形时选择格式化的形式。 （3） parallel 子类型允许单个报文含有可同时显示的各个子部分（例如，图像和声音子部 分必须一起播放）。 （4） digest 子类型允许单个报文含有一组其他报文（如从讨论中收集电子邮件报文）。 下面显示了一个 MIME 邮件，它包含有一个简单解释的文本和含有非文本信息的照 片。邮件中第一部分的注解说明第二部分含有一张照片。 From： xiexiren@tsinghua。org。cn To： xyz@163。com MIME-Version： 1。0 Content-Type： multipart/mixed； boundary=qwertyuiop --qwertyuiop XYZ： 你要的图片在此邮件中，收到后请回信。 --qwertyuiop Content-Type： image/gif Content-Transfer-Encoding： base64 。。。data for the image （图像的数据）。。。 --qwertyuiop-- 谢希仁 上面最后一行表示 boundary 的字符串后面还有两个连字符“--”，表示整个multipart 的 结束。 6。6 动态主机配置协议 DHCP 为了把协议软件做成通用的和便于移植的，协议软件的编写者不会把所有的细节都固 定在源代码中。相反，他们把协议软件参数化。这就使得在很多台计算机上有可能使用同一 个经过编译的二进制代码。一台计算机和另一台计算机的许多区别，都可以通过一些不同的 参数来体现。在协议软件运行之前，必须给每一个参数赋值。 在协议软件中给这些参数赋值的动作叫做协议配置。一个协议软件在使用之前必须是 已正确配置的。具体的配置信息有哪些则取决于协议栈。例如，连接到互联网的计算机的协 议软件需要配置的项目包括： （1） IP 地址； （2） 子网掩码； （3） 默认路由器的IP 地址； （4）域名服务器的IP 地址。 为了省去给计算机配置 IP 地址的麻烦，我们能否在计算机的生产过程中，事先给每一 台计算机配置好一个唯一的 IP 地址呢（如同每一个以太网适配器拥有一个唯一的硬件地 址）？这显然是不行的。这是因为 IP 地址不仅包括了主机号，而且还包括了网络号。一个 IP 地址指出了一台计算机连接在哪一个网络上。当计算机还在生产时，无法知道它在出厂 后将被连接到哪一个网络上。因此，需要连接到互联网的计算机，必须对IP地址等项目进 行协议配置。 用人工进行协议配置很不方便，而且容易出错。因此，应当采用自动协议配置的方法。 互联网现在广泛使用的是动态主机配置协议 DHCP （Dynamic Host Configuration Protocol），它提供了一种机制，称为即插即用连网（plug-and-play networking）。这种机制允许 一台计算机加入新的网络和获取 IP 地址而不用手工参与。DHCP 最新的 RFC 文档是 1997 年的 RFC 2131 和 RFC 2132，目前还是互联网草案标准。 DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一 个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。DHCP 给运行服务器 软件而位置固定的计算机指派一个永久地址，而当这计算机重新启动时其地址不改变。 DHCP 使用客户服务器方式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送 发现报文（DHCPDISCOVER）（将目的IP地址置为全1，即255。255。255。255），这时该主机 就成为 DHCP 客户。发送广播报文是因为现在还不知道 DHCP 服务器在什么地方，因此要 发现（DISCOVER）DHCP 服务器的IP地址。这台主机目前还没有自己的IP 地址，因此它 将 IP 数据报的源 IP 地址设为全0。这样，在本地网络上的所有主机都能够收到这个广播报 文，但只有 DHCP 服务器才对此广播报文进行回答。DHCP服务器先在其数据库中查找该 计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 （address pool）中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文 （DHCPOFFER），表示“提供”了IP地址等配置信息。 但是我们并不愿意在每一个网络上都设置一个 DHCP 服务器，因为这样会使 DHCP 服 务器的数量太多。因此现在是使每一个网络至少有一个 DHCP 中继代理（relay agent）（通常 是一台路由器，见图 6-19），它配置了 DHCP 服务器的IP地址信息。当 DHCP 中继代理收 到主机 A 以广播形式发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等 待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再把此提供报文发回给 主机 A。需要注意的是，图6-19 只是个示意图。实际上，DHCP 报文只是 UDP 用户数据报 的数据，它还要加上 UDP 首部、IP数据报首部，以及以太网的 MAC 帧的首部和尾部后， 才能在链路上传送。 主机A 广播 DHCPDISCOVER 单播 DHCPDISCOVER 其他网络 DHCP 服务器 DHCP 中继代理 图6-19 DHCP 中继代理以单播方式转发发现报文 DHCP 服务器分配给 DHCP 客户的IP地址是临时的，因此 DHCP 客戶只能在一段有限 的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期（lease period），但并没 有具体规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。例 如，一个校园网的 DHCP 服务器可将租用期设定为1小时。DHCP 服务器在给 DHCP 发送 的提供报文的选项中给出租用期的数值。按照 RFC 2132 的规定，租用期用4字节的二进制 数字表示，单位是秒。因此可供选择的租用期范围从1秒到136年。DHCP客户也可在自己 发送的报文中（例如，发现报文）提出对租用期的要求。 DHCP 的详细工作过程如图6-20 所示。DHCP 客户使用的 UDP 端口是68，而 DHCP 服务器使用的 UDP端口是67。这两个 UDP 端口都是熟知端口。 被动打开 67 服务器 · UDP 67 服务器 客戶 68 DHCPDISCOVER UDP UDP 客戶 68 DHCPOFFER 67 服务器 。 UDP UDP 客戶 68 DHCPREQUEST 67 服务器 UDP UDP 客户 68 DHCPACK 67 服务器 UDP UDP 6 客户 68 UDP 客户 68 UDP DHCPREQUEST 1 DHCPACK 67 服务器 UDP 67 服务器 。 UDP 客户 68 DHCPNACK 67 服务器 UDP UDP 9 客户 68 DHCPRELEASE 67 服务器 UDP UDP 图6-20 DHCP 协议的工作过程 下面按照图 6-20 中的注释编号（●至）进行简单的解释。 1 DHCP 服务器被动打开UDP端口67，等待客户端发来的报文。 2 DHCP 客户从 UDP 端口 68 发送 DHCP 发现报文。 • 凡收到 DHCP 发现报文的DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客戶 可能收到多个 DHCP 提供报文。 4 DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器 发送 DHCP 请求报文。 • 被选择的 DHCP服务器发送确认报文 DHCPACK。从这时起，DHCP 客戶就可以使 用这个 IP 地址了。这种状态叫做已绑定状态，因为在 DHCP 客户端的 IP 地址和硬 件地址已经完成绑定，并且可以开始使用得到的临时 IP 地址了。 DHCP 客户现在要根据服务器提供的租用期T 设置两个计时器 T和T2，它们的超 时时间分别是 0。5T 和0。875T。当超时时间到了就要请求更新租用期。 • 租用期过了一半（Tı 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租 用期。 DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用 期，重新设置计时器。 8 DHCP 服务器若不同意，则发回否认报文 DHCPNACK。这时 DHCP 客户必须立即 停止使用原来的IP 地址，而必须重新申请IP 地址（回到步骤●）。 若 DHCP 服务器不响应步骤的请求报文 DHCPREQUEST，则在租用期过了 87。5%时（T2 时间到），DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复 步骤●），然后又继续后面的步骤。 9 DHCP 客户可以随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发 送释放报文 DHCPRELEASE 即可。 DHCP 很适合于经常移动位置的计算机。当计算机使用 Windows 操作系统时，点击 “控制面板”的“网络”图标就可以找到某个连接中的“网络”下面的菜单，找到 TCP/IP 协议后点击其“属性”按钮，若选择“自动获得IP 地址”和“自动获得DNS 服务器地 址”，就表示是使用DHCP 协议。 6。7 简单网络管理协议 SNMP 6。7。1 网络管理的基本概念 虽然网络管理还没有精确定义，但它的内容可归纳为： 网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、 测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行 性能、服务质量等。网络管理常简称为网管。 我们可以看到，网络管理并不是指对网络进行行政上的管理。 网络是一个非常复杂的分布式系统。这是因为网络上有很多不同厂家生产的、运行着 多种协议的结点（主要是路由器），而这些结点还在相互通信和交换信息。网络的状态总是 不断地变化着。可见，我们必须使用一种机制来读取这些结点上的状态信息，有时还要把一 些新的状态信息写入到这些结点上。 下面简单介绍网络管理模型中的主要构件（见图6-21）。 管理站又称为管理器，是整个网络管理系统的核心，它通常是个有着良好图形界面的 高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理 站发出的。管理站的所在部门也常称为网络运行中心 NOC （Network Operations Center）。管 理站中的关键构件是管理程序（如图6-21 中有字母 M 的椭圆形图标所示）。管理程序在运 行时就成为管理进程。管理站（硬件）或管理程序（软件）都可称为管理者（manager）或管 理器，所以这里的 manager 不是指人而是指机器或软件。网络管理员（administrator）才是指 人。大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的 设备。 被管设备 被管设备 互联网 被管设备 被管设备 被管设备 网管协议 网络 管理站 管理员 M ·管理程序（运行SNMP客户程序） A ·代理程序（运行 SNMP 服务器程序） 图6-21 网络管理的一般模型 在被管网络中有很多的被管设备（包括设备中的软件）。被管设备可以是主机、路由 器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多被管对象 （Managed Object）。被管对象可以是被管设备中的某个硬件（例如，一块网络接口卡），也可 以是某些硬件或软件（例如，路由选择协议）的配置参数的集合。被管设备有时可称为网络 元素或简称为网元。在被管设备中也会有一些不能被管的对象（在下面的 6。7。2 节将会讲到 对象命名树，所谓不能被管的对象就是不在对象命名树上的对象）。 在每一个被管设备中都要运行一个程序以便和管理站中的管理程序进行通信。这些运 行着的程序叫做网络管理代理程序，或简称为代理（agent）（如图6-22 中有字母 A 的几个椭 圆形图标所示）。代理程序在管理程序的命令和控制下，在被管设备上采取本地的行动。 在图 6-22 中还有一个重要构件就是网络管理协议，简称为网管协议。后面还要讨论它 的作用。 简单网络管理协议 SNMP （Simple Network Management Protocol）中的管理程序和代理程 序按客户服务器方式工作。管理程序运行 SNMP 客户程序，而代理程序运行 SNMP 服务器 程序。在被管对象上运行的 SNMP 服务器程序不停地监听来自管理站的 SNMP 客户程序的 请求（或命令）。一旦发现了，就立即返回管理站所需的信息，或执行某个动作（例如，把 某个参数的设置进行更新）。在网管系统中往往是一个（或少数几个）客户程序与很多的服 务器程序进行交互。 关于网络管理有一个基本原理，这就是： 若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有 对象的影响必须尽量小些。 SNMP 正是按照这样的基本原理来设计的。 SNMP 发布于 1988 年。OSI 虽然在这之前就已制定出许多的网络管理标准，但当时 （到现在也很少）却没有符合 OSI 网管标准的产品。SNMP 最重要的指导思想就是要尽可 能简单。SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。在网 络正常工作时，SNMP 可实现统计、配置和测试等功能。当网络出故障时，可实现各种差错 检测和恢复功能。经过近二十年的使用，SNMP 不断修订完善，较新的版本是SNMPv3，而 前两个版本分别是SNMPv2 和 SNMPv1。但一般可简称为 SNMP。现在 SNMPv3 已成为互 联网标准（STD 62）。SNMPv3 最大的改进就是安全特性。也就是说，只有被授权的人员才 有资格执行网络管理的功能（如关闭某一条链路）和读取有关网络管理的信息（如读取一个 配置文件的內容）。然而 SNMP 协议已相当庞大，一点也不“简单”，整个标准共有八个 RFC 文档[RFC 3411~3418]。因此这里只能给出一些最基本的概念。 若网络元素使用的不是 SNMP 协议而是另一种网络管理协议，那么 SNMP 协议就无法 控制该网络元素。这时可使用委托代理（proxy agent）。委托代理能提供如协议转换和过滤操 作等功能对被管对象进行管理。 SNMP 的网络管理由三个部分组成，即SNMP 本身、管理信息结构 SMI （Structure of Management Information）和管理信息库 MIB （Management Information Base）。下面简述这三 部分的作用。 SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象 （变量名及其状态（值）。SNMP 负责读取和改变这些数值。 SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和 对象的值进行编码的规则。这样做是为了确保网络管理数据的语法和语义无二义性。但从 SMI 的名称并不能看出它的功能。请注意，SMI 并不定义一个实体应管理的对象数目，也 不定义被管对象名以及对象名及其值之间的关联。 MIB 在被管理的实体中创建了命名对象，并规定了其类型。 为了更好地理解上述的几个组成部分，可以把它们和程序设计进行一下对比。 我们在编程时要使用某种语言，而这种语言就是用来定义编程的规则。例如，一个变 量名必须从字母开始而后面接着是字母数字。在网络管理中，这些规则由SMI来定义。 在程序设计中必须对变量进行说明。例如，int counter，表示变量 counter 是整数类型。 MIB 在网络管理中就做这样的事情。MIB 给每个对象命名，并定义对象的类型。 在编程中的说明语句之后，程序需要写出一些语句用来存储变量的值，并在需要时改 变这些变量的值。SNMP 在网络管理中完成这件任务。SNMP 按照SMI 定义的规则，存 储、改变和解释这些已由MIB 说明的对象的值。 总之，SMI 建立规则，MIB对变量进行说明，而SNMP 完成网管的动作。 下面就一一介绍上述的三个构件。 6。7。2 管理信息结构 SMI 管理信息结构 SMI 是 SNMP 的重要组成部分。根据 6。7。1 节所讲的，SMI 的功能应当 有三个，即规定： （1）被管对象应怎样命名； （2）用来存储被管对象的数据类型有哪些； （3） 在网络上传送的管理数据应如何编码。 1。被管对象的命名 SMI 规定，所有的被管对象都必须处在对象命名树（object naming tree）上。图6-22 给出 了对象命名树的一部分。对象命名树的根没有名字，它的下面有三个顶级对象，都是世界上 著名的标准制定单位，即ITU-T （过去叫做CCITT），ISO，以及这两个组织的联合体，它 们的标号分别是 0 到 2。图中的对象名习惯上用英文小写表示。在 ISO 的下面的一个标号为 3 的节点是 ISO 认同的的组织成员 org。在其下面有一个美国国防部 dod （Department of Defense）的子树（标号为 6），再下面就是 internet（标号为 1）。在只讨论 internet 中的对象 时，可只画出 internet 以下的子树，并在internet 节点旁边写上对象标识符 1。3。6。1 即可。 根 itu-t （0） iso （1） iso/itu-t （2） org （3） dod （6） internet （1） 1。3。6。1 （iso。org。dod。internet） mgmt （2） mib-2（1） 1。3。6。1。2。1 （iso。org。dod。internet。mgmt。mib-2） system（1） 八 interface（2） at（3） ip（4） icmp（5） tcp（6） udp（7） 八 八 egp（8） 。。。 八 八八 ipInReceives（3） 1。3。6。1。2。1。4。3 图6-22 SMI规定所有被管对象必须在命名树上 在 internet 节点下面的标号为2的节点是mgmt（管理）。再下面只有一个节点，即管理 信息库 mib-2，其对象标识符为1。3。6。1。2。1。在mib-2 下面包含了所有被SNMP 管理的对象 （见下面6。7。3 节的讨论）。 2。被管对象的数据类型 SMI 使用基本的抽象语法记法1（即ISO制定的ASN。1）来定义数据类型，但又增加 了一些新的定义。因此 SMI 既是ASN。1 的子集，又是ASN。1 的超集。ASN。1 的记法很严 格，它使得数据的含义不存在任何可能的二义性。例如，使用ASN。1 时不能简单地说 个具有整数值的变量”，而必须说明该变量的准确格式和整数取值的范围。当网络中的计算 机对数据项并不都使用相同的表示时，采用这种精确的记法就尤其重要。 我们知道，任何数据都具有两种重要的属性，即值（value）与类型（type）。这里“值”是 某个值集合中的一个元素，而“类型”则是值集合的名字。如果给定一种类型，则这种类型 的一个值就是该类型的一个具体实例。 SMI 把数据类型分为两大类：简单类型和结构化类型。简单类型是最基本的、直接使 用 ASN。1 定义的类型。表6-4 给出了最主要的几种简单类型。 表6-4 几种最主要的简单类型 类型 大小 说明 INTEGER 4字节 在-231 到231-1之间的整数 Interger32 4 字节 和 INTEGER 相同 Unsigned32 4 字节 在0到22 −1之间的无符号数 OCTET STRING 可变 不超过65535字节长的字节串 OBJECT IDENTIFIER 可变 对象标识符 IPAddress 4 字节 由4个整数组成的IP地址 Counter32 4字节 可从0增加到23”的整数；当它到达最大值时就返回到0 TimeTicks 4字节 记录时间的计数值，以1/100秒为单位 BITS 比特串 Opaque 可变 不解释的串 SMI 定义了两种结构化数据类型，即 sequence 和 sequence ofo 数据类型 sequence 类似于 C 语言中的 struct 或 record，它是一些简单数据类型的组合 （不一定要相同的类型）。而数据类型 sequence of 类似于 C 语言中的 array，它是同样类型 的简单数据类型的组合，或同样类型的 sequence 数据类型的组合。 3。 编码方法 SMI 使用 ASN。1 制定的基本编码规则BER（Basic Encoding Rule）进行数据的编码。BER 指明了每种数据的类型和值。在发送端用 BER 编码，可把用ASN。1 所表述的报文转换成唯 一的比特序列。在接收端用BER 进行解码，就可得到该比特序列所表示的ASN。1报文。 初看起来，或许用两个字段就能表示类型和值。但由于表示值可能需要多个字节，因 此还需要一个指出“要用多少字节表示值”的长度字段。因此 ASN。1 把所有的数据元素都 表示为 T-L-V 三个字段组成的序列（见图6-23）。T字段（Tag）定义数据的类型，L 字段 （Length）定义 V 字段的长度，而V字段（Value）定义数据的值。 字节 1 可变 可变 数据元素 标记T 长度L 值V 类别 格式 位2 编 号 1 5 图6-23 用TLV 方法进行编码 （1） T 字段又叫做标记字段，占1 字节。T 字段比较复杂，因为它要定义的数据类型较 多。T字段又再分为以下三个子字段： 类别（2位）共四种：通用类（00），即 ASN。1 定义的类型；应用类（01），即 SMI 定 义的类型；上下文类（10），即上下文所定义的类型；专用类（11），保留为特定厂商 定义的类型。 格式（1 位）共两种，指出数据类型的种类：简单数据类型（0），结构化数据类型 （1）。 • 编号（5位）用来标志不同的数据类型。编号的范围一般为0~30。当编号大于 30 时，T 字段就要扩展为多个字节（这种情况很少用到，可参考 ITU-T X。209，这里 从略）。 表6-5是一些数据类型的T字段的编码。 表6-5 几种数据类型的T字段编码 数据类型 类别 格式 编号 T字段（二进制） T字段（十六进制） INTEGER 00 0 00010 00000010 02 OCTET STRING 00 0 00100 00000100 04 OBJECT IDENTIFIER 00 0 00110 00000110 06 NULL 00 0 00101 00000101 05 Sequence， sequence of 00 1 10000 00110000 30 IPAddress 01 0 00000 01000000 40 Counter 01 0 00001 01000001 41 Gauge 01 0 00010 01000010 42 TimeTicks Opaque 01 0 00011 01000011 43 01 0 00100 01000100 44 （2） L 字段又叫做长度字段（单字节或多字节）。当字段为单字节时，其最高位为 0， 后面的7位定义V字段的长度。当L 字段为多个字节时，其最高位为 1，而后面的 7 位定 义后续字节的字节数（用二进制整数表示）。这时，所有的后续字节并置起来的二进制整数 定义V字段的长度。图6-24给出了L字段的格式。 指出V字段长度=2字节 单字节的L字段00000010 指出后续字节数 = 2 指出V字段长度=262字节 多字节的L字段 0000010 0000000100000110 后续字节数=2 图6-24 L字段的格式 （3） V 字段又叫做值字段，用于定义数据元素的值。 根据以上所述，我们给出两个用十六进制表示的编码例子。例如，INTEGER 15，根据 表 6-5，其 T 字段是02，再根据表 6-4，INTEGER 类型要用4字节编码。最后得出 TLV 编 码为 02 04 00 00 00 OF。又如 IPAddress 192。1。2。3，IPAddress 的T字段是40，V字段需要4 字节表示，因此IPAddress 192。1。2。3 的TLV编码是4004C0 01 02 03。 TLV 方法中的V字段还可嵌套其他数据元素的TLV 字段，并可多重嵌套。 6。7。3 管理信息库 MIB 所谓“管理信息”就是指在互联网的网管框架中被管对象的集合。被管对象必须维持 可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚拟的信息存储器，所 以才称为管理信息库 MIB。管理程序就使用 MIB 中这些信息的值对网络进行管理（如读取 或重新设置这些值）。只有在 MIB 中的对象才是 SNMP 所能够管理的。例如，路由器应当 • 维持各网络接口的状态、入分组和出分组的流量、丢弃的分组和有差错的报文的统计信息， 而调制解调器则应当维持发送和接收的字符数、码元传输速率和接受的呼叫等统计信息。因 此在 MIB 中就必须有上面这样一些信息。 我们再看一下图 6-22，可以找到节点 mib-2 下面的部分是 MIB 子树。表 6-6 给出了节 点 mib-2 所包含的前八个信息类别代表的意思（在后面还有好几个类别）。 表6-6 节点 mib-2 所包含的信息类别举例 类别 标号 所包含的信息 system （1） interfaces （2） 主机或路由器的操作系统 各种网络接口 address translation （3） 地址转换（例如，ARP 映射） ip （4） IP 软件 icmp （5） ICMP 软件 tcp （6） TCP 软件 udp （7） UDP 软件 egp （8） EGP 软件 我们可以用个简单例子进一步说明 MIB 的意义。例如，从图 6-22 可以看出，对象 ip 的标号是4。因此，所有与 IP 有关的对象都从前缀 1。3。6。1。2。1。4 开始。 （1） 在节点 ip 下面有个名为ipInReceives 的 MIB 变量（见图6-22），表示收到的 IP 数据 报数。这个变量的标号是3，变量的名字是： iso。org。dod。internet。mgmt。mib。ip。ipInReceives， 而相应的数值表示是：1。3。6。1。2。1。4。3。 （2）当 SNMP 在报文中使用 MIB 变量时，对于简单类型的变量，后缀0指具有该名字 的变量的实例。因此，当这个变量出现在发送给路由器的报文中时，ipInReceives 的数值表 示（即变量的一个实例）就是：1。3。6。1。2。1。4。3。0。 （3） 请注意，对于分配给一个 MIB 变量的数值或后缀是完全没有办法进行推算的，必 须查找已发布的标准。 上面所说的 MIB对象命名树的大小并没有限制。下面给出若干 MIB 变量的例子（见表 6-7），以便更好地理解 MIB 的意义。这里的“变量”是指特定对象的一个实例。 表 6-7 MIB 变量的例子 MIB 变量 所属类别 意义 sysUpTime system 距上次重启动的时间 ifNumber interfaces 网络接口数 ifMtu interfaces 特定接口的最大传送单元 MTU ipDefaultTTL ip IP 在生存时间字段中使用的值 ipInReceives ip 接收到的数据报数目 ipForwDatagrams ip 转发的数据报数目 ipOutNoRoutes ip 路由选择失败的数目 ipReasmOKs ip 重装的数据报数目 ipFragOKs ip 分片的数据报数目 ipRouting Table ip IP 路由表 icmpInEchos icmp 收到的 ICMP 回送请求数目 MIB 变量 所属类别 tcpRtoMin tcp 意义 TCP 允许的最小重传时间 tcpMaxConn tcp tcpInSegs udpInDatagrams tcp udp 允许的最大TCP 连接数目 已收到的TCP报文段数目 已收到的 UDP数据报数目 续表 上面列举的大多数项目的值可用一个整数来表示。但 MIB 也定义了更复杂的结构。例 如，MIB 变量 ipRoutingTable 则定义一个完整的路由表。还有其他一些 MIB 变量定义了路 由表项目的内容，并允许网络管理协议访问路由器中的单个项目，包括前缀、地址掩码以及 下一跳地址等。当然，MIB 变量只给出了每个数据项的逻辑定义，而一个路由器使用的內 部数据结构可能与 MIB 的定义不同。当一个查询到达路由器时，路由器上的代理软件负责 MIB 变量和路由器用于存储信息的数据结构之间的映射。 6。7。4 SNMP 的协议数据单元和报文 实际上，SNMP 的操作只有两种基本的管理功能，即： （1）“读”操作，用 Get 报文来检测各被管对象的状况； （2）“写”操作，用Set报文来改变各被管对象的状况。 SNMP 的这些功能通过探询操作来实现，即SNMP 管理进程定时向被管理设备周期性 地发送探询信息。上述时间间隔可通过 SNMP 的管理信息库 MIB 来建立。探询的好处是： 第一，可使系统相对简单；第二，能限制通过网络所产生的管理信息的通信量。但探询管理 协议不够灵活，而且所能管理的设备数目不能太多。探询系统的开销也较大。如探询频繁而 并未得到有用的报告，则通信线路和计算机的CPU周期就被浪费了。 但 SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为 陷阱（trap），表示它能够捕捉“事件”。但这种陷阱信息的参数是受限制的。 当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达 到某些门限值的事件（这就叫做过滤）。这种方法的好处是：第一，仅在严重事件发生时才 发送陷阱；第二，陷阱信息很简单且所需字节数很少。 总之，使用探询（至少是周期性地）以维持对网络资源的实时监视，同时也采用陷阱 机制报告特殊事件，使得 SNMP成为一种有效的网络管理协议。 SNMP 使用无连接的UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保 证可靠交付的。这里还要指出，SNMP 使用UDP 的方法有些特殊。在运行代理程序的服务 器端用熟知端口161 来接收Get 或Set报文和发送响应报文（与熟知端口通信的客户端使用 临时端口），但运行管理程序的客户端则使用熟知端口162来接收来自各代理的 trap 报文。 SNMP 现在共定义了如表 6-8 所示的8种类型的协议数据单元[RFC 3416]，其中 PDU 编号为4的已经废弃了。在 PDU 编号后面是对应的T字段值（十六进制表示）。 表6-8 SNMP定义的协议数据单元类型 PDU 编号（T字段 ） PDU 名称 用途 0 （A0） GetRequest 管理者从代理读取一个或一组变量的值 PDU 编号（T字段 ） 1（Al） PDU 名称 GetNextRequest 用途 续表 管理者从代理读取 MIB 树上的下一个变量的值（即使不知道此变量名也行）。 此操作可反复进行，特别是按顺序一一读取列表中的值很方便 2 （A2） Response 代理向管理者或管理者向管理者发送对五种 Request 报文的响应，并提供差错 码、差错状态等信息 3（A3） SetRequest 管理者对代理的一个或多个MIB 变量的值进行设置 5（A5） 6（A6） GetBulkRequest 管理者从代理读取大数据块的值（如大的列表中的值） InformRequest 管理者从另一远程管理者读取该管理者控制的代理中的变量值 7 （A7） 8（A8） SNMPv2Trap 代理向管理者报告代理中发生的异常事件 Report 在管理者之间报告某些类型的差错，目前尚未定义 和大多数 TCP/IP协议不一样，SNMP报文没有固定的字段。相反，它们使用标准 ASN。1 编码。因此，SNMP报文用人工进行编码和理解时都比较困难。为此，在图 6-25 中 给出了 SNMPv1 的报文格式。可以看出，一个 SNMP 报文共由四个部分组成，即版本、首 部、安全参数和SNMP报文的数据部分。版本现在已是版本3。首部包括报文标识（message identification）、最大报文长度、报文标志（message flag）。报文标志占1字节，其中的每一位 定义安全类型或其他信息。安全参数用来产生报文摘要（见下一章的7。4节）。 从图6-25 可看出，在SNMP PDU 前面还有两个有关加密信息的字段。这是当数据部分 需要加密时才使用的两个字段。与网络管理直接相关的是后面的 SNMP PDU 部分。对于表 6-8 给出的前四种PDU的格式都是相同的，即由PDU类型、请求ID、差错状态、差错索引 以及变量绑定这几个字段组成。PDU 的各种类型以及类型的编号和T字段的编码已在表6-8 中给出。下面简单介绍一下其他字段的作用。 IP数据报 UDP数据报 20字节 8字节 SNMP 报文 IP UDP 首部首部 版本 首部 安全 参数 SNMP 报文的数据部分 上下文引擎 ID | 上下文名 PDU 类型 请求ID 差错状态差错索引 名 值名值 有关加密信息的字段 首部 SNMP PDU 图6-25 SNMP 的报文格式 变量绑定 （1）请求标识符（request ID） 由管理进程设置的4字节数值。代理进程在发送响应 报文时也要返回此请求标识符。由于管理进程可同时向许多代理发出请求读取变量值的报 文，因此设置了请求标识符可使管理进程能够识别返回的响应是对应于哪一个请求报文。 （2） 差错状态（error status） 在请求报文中，这个字段是零。当代理进程响应时，就填 入 0~18 中的一个数字。例如表示 noError （一切正常），1表示tooBig（代理无法把回答 装入到一个 SNMP 报文之中），2 表示 noSuchName（操作指明了一个不存在的变量），3表 示badValue（无效值或无效语法），等等[RFC3416]。 （3） 差错索引（error index） 在请求报文中，这个字段是零。当代理进程响应时，若出 现 noSuchName， badValue或readOnly 的差错，代理进程就设置一个整数，指明有差错的变 量在变量列表中的偏移。 （4） 变量绑定（variable-bindings） 中，变量的值应忽略（类型是NULL）。 指明一个或多个变量的名和对应的值。在请求报文 为了大致了解 ASN。1 给出的定义的形式，下面举出定义 GetRequest-PDU 的例子。两个 连字符“--”后面的是注解。 Get-request-PDU ：：= [0] IMPLICIT SEQUENCE { --[0]表示上下文类，编号为0 --类型是SEQUENCE --变量 request-id的类型是integer32 request-id integer32， error-status INTEGER {0。。18}， error-index variable-bindings VarBindList} --变量 error-status取值为0~18的整数 INTEGER {0。。max-bindings}， --变量 error-index 取值为0~max-bindings 的整数 --变量 variable-binding 的类型是VarBindList 但变量 VarBindList 是什么类型呢？还需要继续定义（这里从略）。上面 ASN。1 定义中 的第二行中的 IMPLICIT 叫做隐式标记，是为了在进行编码时可省去对IMPLICIT 后面的类 型（SEQUENCE）的编码，使最后得出的编码更加简洁。 下面我们假定管理者发送 GetRequest-PDU，为的是从某路由器的代理进程获得“收到 UDP数据报的数目”的信息。从图6-22可以查出，mib-2 下面第7个节点是udp，而udp节 点下面的第一个节点就是 udpInDatagrams。由于这个节点已经是叶节点（即没有连接在它下 面的子节点了），读取这个节点的数值时应在节点标识符后面加上0，即 1。3。1。1。2。1。7。1。0。这 样，可得出 GetRequest-PDU 的ASN。1 编码如图6-26 所示。 T L INTEGER 04 T GetRequest-PDU A0 1D L GetRequest -PDU request-id error-status error-index variable-bindings L VarBind V T LV LV T T 05 AE 56 02 INTEGER 01：00 INTEGER 01 00 SEQUENCE OF OF request-ID T L SEQUENCE OD name value T L V T L OBJECT IDENTIFIER 09 01 03 06 01 02 01 01 01 00 1。 3。 6。 1。 2。 1。 7。 1。0 NULL 00 图6-26 GetRequest-PDU的ASN。1 编码 可以把图中各字段的十六进制编码表示如下。 A0 1D 02 04 05 AE 56 02 02 01 00 02 01 00 • 306 • 30 OF 30 0D --- GetRequest-PDU，上下文类型，长度1D16=29 -- INTEGER 类型，长度 0416，request-id = 05 AE56 02 -- INTEGER类型，长度 0116， error status = 0016 -- INTEGER 类型，长度 0116， error index = 0016 --- SEQUENCE OF 类型，长度 OF16 = 15 --- SEQUENCE 类型，长度 0。6 = 13 06 09 01 03 06 01 02 01 07 01 00 05 00 -- - OBJECT IDENTIFIER类型，长度 0916， udpInDatagrams -- NULL 类型，长度 0016 6。8 应用进程跨越网络的通信 在这以前我们已经讨论了互联网使用的几种常用的应用层协议，这些应用协议使广大 用户可以更加方便地利用互联网的资源。 现在的问题是：如果我们还有一些特定的应用需要互联网的支持，但这些应用又不能 直接使用已经标准化的互联网应用协议，那么我们应当做哪些工作？要回答这个问题，实际 上就是要了解下面要介绍的系统调用和应用编程接口。这些问题实际上需要一门专门的课程 来学习，我们在这里只能给出一些初步的概念。 6。8。1 系统调用和应用编程接口 大多数操作系统使用系统调用（system call）的机制在应用程序和操作系统之间传递控制 权。对程序员来说，系统调用和一般程序设计中的函数调用非常相似，只是系统调用是将控 制权传递给了操作系统。图6-27说明了多个应用进程使用系统调用的机制。 应用程序 1 应用程序2 。。。 应用程序 n 在用户地址空间中 的应用程序 由应用程序调用的系统函数 系统调用接口 包括 TCP/IP 协议软件的操作系统内核 系统地址空间中 的协议软件 图6-27 多个应用进程使用系统调用的机制 当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口。此接 口再把控制权传递给计算机的操作系统。操作系统把这个调用转给某个内部过程，并执行所 请求的操作。内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程。总 之，只要应用进程需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执 行必要的操作后把控制权返回给应用进程。因此，系统调用接口实际上就是应用进程的控制 权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些 程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口 API （Application Programming Interface）。API从程序设计的角度定义了许多标准的系统调用 函数。应用进程只要使用标准的系统调用函数就可得到操作系统的服务。因此从程序设计的 角度看，也可以把API看成是应用程序和操作系统之间的接口。 现在 TCP/IP 协议软件已驻留在操作系统中。由于TCP/IP 协议族被设计成能运行在多 种操作系统的环境中，因此 TCP/IP 标准没有规定应用程序与 TCP/IP 协议软件如何接口的细 节，而是允许系统设计者能够选择有关 API 的具体实现细节。目前，只有几种可供应用程 序使用 TCP/IP 的应用编程接口 API。这里最著名的就是美国加利福尼亚大学伯克利分校为 Berkeley UNIX 操作系统定义了一种 API，它又称为套接字接口（socket interface） （或插口接 口）。微软公司在其操作系统中采用了套接字接口 API，形成了一个稍有不同的 API，并称 之为 Windows Socket，简称为 WinSock。AT&amp;T 为其 UNIX系统V 定义了一种API，简写为 TLI （Transport Layer Interface）。 我们知道，若要让计算机做某件事情，就要编写使计算机能理解的程序。在网络环境 下的计算机应用都有一个共同特点，这就是：在不同地点的计算机要通过网络进行通信。从 另一种角度看，计算机之间的通信就是本计算机要读取另一个地点的计算机中的数据，或者 要把数据从本计算机写入到另一个地点的计算机中。这种“读取”和“写入”的过程都要用 到上面所说的系统调用。 在讨论网络编程时常常把套接字作为应用进程和运输层协议之间的接口，图6-28 表示 这一概念。图中假定了运输层使用TCP 协议（若使用UDP协议，情况也是类似的，只是 UDP 是无连接的。通信的两端仍然可用两个套接字来标志）。现在套接字已成为计算机操作 系统内核的一部分。 客户 服务器 由应用程序 控制 应用进程 应用进程 套接字 |套接字 互联网 由操作系统 TCP TCP 控制 图6-28 套接字成为应用进程与运输层协议的接口 请注意：在套接字以上的进程是受应用程序控制的，而在套接字以下的运输层协议软 件则是受计算机操作系统的控制。因此，只要应用程序使用TCP/IP 协议进行通信，它就必 须通过套接字与操作系统交互（这就要使用系统调用函数）并请求其服务。我们应当注意 到，应用程序的开发者对套接字以上的应用进程具有完全的控制，但对套接字以下的运输层 却只有很少的控制，例如，可以选择运输层协议（TCP 或UDP）以及一些运输层的参数 （如最大缓存空间和最大报文长度等）。 当应用进程（客户或服务器）需要使用网络进行通信时，必须首先发出 socket 系统调 用，请求操作系统为其创建一个“套接字”。这个调用的实际效果是请求操作系统把网络通 信所需要的一些系统资源（存储器空间、CPU 时间、网络带宽等）分配给该应用进程。操 作系统为这些资源的总和用一个叫做套接字描述符（socket descriptor）的号码（小的整数）来 表示，然后把这个套接字描述符返回给应用进程。此后，应用进程所进行的网络操作（建立 连接、收发数据、调整网络通信参数等）都必须使用这个套接字描述符。所以，几乎所有的 网络系统调用都把这个套接字描述符作为套接字的许多参数中的第一个参数。在处理系统调 用的时候，通过套接字描述符，操作系统就可以识别出应该使用哪些资源来完成应用进程所 请求的服务。通信完毕后，应用进程通过一个关闭套接字的 close 系统调用通知操作系统回 收与该套接字描述符相关的所有资源。由此可见，套接字是应用进程为了获得网络通信服务 而与操作系统进行交互时使用的一种机制。 图 6-29 给出了当应用进程发出 socket 系统调用时，操作系统所创建的套接字描述符 与套接字数据结构的关系。由于在一个机器中可能同时出现多个套接字，因此需要有一个存 放套接字描述符的表，而每一个套接字描述符有一个指针指向存放套接字的地址。在套接字 的数据结构中有许多参数要填写。图 6-29 中已填写好的参数是协议族（PF_INET，表示使 用 Internet 的 TCP/IP 协议族）和服务（SOCKSTREAM，表示使用流式服务，也就是使用 TCP 服务）。在刚刚创建一个新的套接字时，有灰色背景的四个项目（本地和远地 IP 地址， 本地和远地端口）都是未填写的，因此它和任何机器中的应用进程暂时都还没有联系。 操作系统 套接字描述符表 （每一个进程一个描述符） 套接字的数据结构 0 1 2。 3。 4。 0： 协议族：PF_INET 1： 服务：SOCK_STREAM 2： 3： 远地 4： ： 图6-29 调用 socket 创建套接字 。。。 6。8。2 几种常用的系统调用 下面我们以使用TCP 的服务为例介绍几种常用的系统调用。 1。连接建立阶段 当套接字被创建后，它的端口号和IP 地址都是空的，因此应用进程要调用 bind（绑 定）来指明套接字的本地地址（本地端口号和本地 IP 地址）。在服务器端调用bind 时就是 把熟知端口号和本地IP 地址填写到已创建的套接字中。这就叫做把本地地址绑定到套接 字。在客户端也可以不调用 bind，这时由操作系统内核自动分配一个动态端口号（通信结 束后由系统收回）。 服务器在调用 bind 后，还必须调用 listen （收听）把套接字设置为被动方式，以便 随时接受客户的服务请求。UDP 服务器由于只提供无连接服务，不使用 listen 系统调 用。 服务器紧接着就调用 accept（接受），以便把远地客户进程发来的连接请求提取出 来。系统调用 accept 的一个变量就是要指明是从哪一个套接字发起的连接。 调用 accept 要完成的动作较多。这是因为一个服务器必须能够同时处理多个连接。 这样的服务器常称为并发方式（concurrent）工作的服务器。可以有多种方法实现这种并发方 式。图 6-30 所示的是一种实现方法。 主服务器进程 M（就是通常所说的服务器进程）一调用 accept，就为每一个新的连 接请求创建一个新的套接字，并把这个新创建的套接字的标识符返回给发起连接的客户方。 与此同时，主服务器进程还要创建一个从属服务器进程（如图6-30 中的S）来处理新建立 的连接。这样，从属服务器进程用这个新创建的套接字和客户进程建立连接，而主服务器进 程用原来的套接字重新调用 accept，继续接受下一个连接请求。在已建立的连接上，从属 服务器进程就使用这个新创建的套接字传送和接收数据。数据通信结束后，从属服务器进程 就关闭这个新创建的套接字，同时这个从属服务器也被撤销。 主服务器进程 M 从属服务器进程 服务器 应用进程 S3 S2 S₁ 接受连接请求 的套接字 （原来的套接字） 连接 连接 连接 套接字 套接字 套接字 - 操作系统 （新创建的套接字） 图6-30 并发方式工作的服务器 总之，在任一时刻，服务器中总是有一个主服务器进程和零个或多个从属服务器进 程。主服务器进程用原来的套接字接受连接请求，而从属服务器进程用新创建的套接字（在 图 6-30 中注明是“连接套接字”）和相应的客户建立连接并可进行双向传送数据。 以上介绍的是服务器为了接受客户端发起的连接请求而进行的一些系统调用。现在看 一下客户端的情况。当使用 TCP 协议的客户已经调用 socket 创建了套接字后，客户进程 就调用 connect，以便和远地服务器建立连接（这就是主动打开，相当于客户发出的连接 请求）。在 connect 系统调用中，客户必须指明远地端点（即远地服务器的IP地址和端口 号）。 2。 数据传送阶段 客户和服务器都在 TCP 连接上使用 send 系统调用传送数据，使用recv 系统调用接 收数据。通常客户使用 send 发送请求，而服务器使用 send 发送回答。服务器使用 recv 接收客户用 send 调用发送的请求。客户在发完请求后用recv 接收回答。 调用 send 需要三个变量：数据要发往的套接字的描述符、要发送的数据的地址以及数 据的长度。通常 send 调用把数据复制到操作系统内核的缓存中。若系统的缓存已满， send 就暂时阻塞，直到缓存有空间存放新的数据。 调用 recv 也需要三个变量：要使用的套接字的描述符、缓存的地址以及缓存空间的长 度。 3。连接释放阶段 一旦客户或服务器结束使用套接字，就把套接字撤销。这时就调用 close 释放连接和 撤销套接字。 图 6-31 画出了上述的一些系统调用的使用顺序。有些系统调用在一个 TCP 连接中可能 会循环使用。 客户端 服务器端 socket bind socket listen connect 连接建立请求 accept send recv close recv send close 图6-31 系统调用使用顺序的例子 UDP 服务器由于只提供无连接服务，因此不使用listen 和 accept 系统调用。 6。9 P2P 应用 我们在第1章1。3。1 节中已经简单地介绍了P2P 应用的概念。现在我们将进一步讨论 P2P 应用的若干工作原理。 P2P 应用就是指具有 P2P 体系结构的网络应用。所谓 P2P 体系结构就是在这样的网络 应用中，没有（或只有极少数的）固定的服务器，而绝大多数的交互都是使用对等方式 （P2P 方式）进行的。 P2P 应用的范围很广，例如，文件分发、实时音频或视频会议、数据库系统、网络服务 支持（如 P2P 打车软件、P2P理财等）。限于篇幅，下面只介绍最常用的P2P文件分发的工 作原理。 P2P 文件分发不需要使用集中式的媒体服务器，而所有的音频/视频文件都是在普通的 互联网用户之间传输的。这其实是相当于有很多（有时达到上百万个）分散在各地的媒体服 务器（由普通用户的计算机充当这种媒体服务器）向其他用户提供所要下载的音频/视频文 件。这种 P2P 文件分发方式解决了集中式媒体服务器可能出现的瓶颈问题。 目前在互联网流量中，P2P 工作方式下的文件分发已占据了最大的份额，比万维网应用 所占的比例大得多。因此单纯从流量的角度看，P2P 文件分发应当是互联网上最重要的应 用。现在 P2P 文件分发不仅传送音频文件 MP3，而且还传送视频文件（10~1000 MB，或 更大）、各种软件和图像文件。 6。9。1 具有集中目录服务器的 P2P 工作方式 最早使用 P2P 工作方式的是Napster。这个名称来自1999 年美国东北大学的新生 Shawn Fanning 所写的一个叫做 Napster 的软件。利用这个软件就可通过互联网免费下载各种 MP3 音乐。Napster 的出现使MP3成为网络音乐事实上的标准。 Napster 能够搜索音乐文件，能够提供检索功能。所有音乐文件的索引信息都集中存放 在 Napster 目录服务器中。这个目录服务器起着索引的作用。使用者只要查找目录服务器， 就可知道应从何处下载所要的MP3文件。在2000年，Napster 成为互联网上最流行的 P2P 应用，并占据互联网上的通信量中相当大的比例。 这里的关键就是运行 Napster 的所有用户，都必须及时向 Napster 的目录服务器报告自 己已经存有哪些音乐文件。Napster 目录服务器就用这些用户信息建立起一个动态数据库， 集中存储了所有用户的音乐文件信息（即对象名和相应的 IP 地址）。当某个用户想下载某个 MP3 文件时，就向目录服务器发出查询（这个过程仍是传统的客户-服务器方式），目录服 务器检索出结果后向用户返回存放这一文件的计算机 IP 地址，于是这个用户就可以从中选 取一个地址下载想要得到的 MP3文件（这个下载过程就是P2P 方式）。可以看出，Napster 的文件传输是分散的（P2P方式），但文件的定位则是集中的（客户服务器方式）。 图 6-32 是Napster 的工作过程的示意图。假定 Napster 目录服务器已经建立了其用户的 动态数据库。图中给出了某个用户要下载音乐文件的主要交互过程。 A Napster 集中式 目录服务器 A有，B，C有。 谁有文件 MP3#？ 请求文件 MP3# MP3# C B 图6-32 Napster 的工作过程 ● 用戶X向Napster 目录服务器查询（客户—服务器方式）谁有音乐文件 MP3#。 ② Napster 目录服务器回答X：有三个地点有文件MP3#，即A，B和C（给出了这三个 地点的 IP 地址）。于是用户X得知所需的文件 MP3#的三个下载地点。 ● 用戶 X 可以随机地选择三个地点中的任一个，也可以使用 PING 报文寻找最方便下 载的一个。在图 6-32 中，我们假定 X向A发送下载文件 MP3#的请求报文。现在X和A都 使用 P2P 方式通信，互相成为对等方，X是临时的客户，而对等方A是临时的服务器。 ● 对等方A（现在作为服务器）把文件MP3#发送给X。 这种集中式目录服务器的最大缺点就是可靠性差，而且会成为其性能的瓶颈（尤其是 在用户数非常多的情况下）。更为严重的是这种做法侵犯了唱片公司的版权。虽然 Napster 网站并没有直接非法复制任何 MP3 文件（Napster 网站不存储任何 MP3 文件，因而并没有 直接侵犯版权），但法院还是判决 Napster 属于“间接侵害版权”，因此在 2000 年 7 月底 Napster 网站就被迫关闭了。 6。9。2 具有全分布式结构的P2P文件共享程序 在第一代 P2P 文件共享网站 Napster 关闭后，开始出现了以 Gnutella 为代表的第二代 P2P 文件共享程序。Gnutella 是一种采用全分布方法定位内容的P2P文件共享应用程序。 Gnutella 与 Napster 最大的区别就是不使用集中式的目录服务器进行查询，而是使用洪泛法 在大量 Gnutella 用户之间进行查询。为了不使查询的通信量过大，Gnutella 设计了一种有限 范围的洪泛查询。这样可以减少倾注到互联网的查询流量，但由于查询的范围受限，因而这 也影响到查询定位的准确性。 为了更加有效地在大量用户之间使用P2P技术下载共享文件，最近几年已经开发出很 多种第三代 P2P 共享文件程序[KURO13]，它们使用分散定位和分散传输技术。如 KaZaA， 电骡 eMule，比特洪流BT（BitTorrent）等。 下面对比特洪流 BT 的主要特点进行简单的介绍。 在 P2P 的文件分发应用中，2001 年由 Brahm Cohen 开发的 BitTorrent （中文意思是“比 特洪流”）是很具代表性的一个。取这个名称的原因就是 BitTorrent 把参与某个文件分发的 所有对等方的集合称为一个洪流（torrent）。为了方便，下面我们使用 BitTorrent 的简称 BT。 BT 把对等方下载文件的数据单元称为文件块（chunk），一个文件块的长度是固定不变的，例 如，典型的数值是 256 KB。当一个新的对等方加入某个洪流时，一开始并没有文件块。 但新的对等方逐渐地能够下载到一些文件块。而与此同时，它也为别的对等方上传一些文件 块。某个对等方获得了整个的文件后，可以立即退出这个洪流（相当于自私的用户），也可 继续留在这个洪流中，为其他的对等方上传文件块（相当于无私的用户）。加入或退出某个 洪流可在任何时间完成（即使在某个文件还没有下载完毕时），也是完全自由的。 BT 的协议相当复杂[W-BT]。下面讨论其基本机制。 每一个洪流都有一个基础设施结点，叫做追踪器（tracker）。当一个对等方加入洪流时， 必须向追踪器登记（或称为注册），并周期性地通知追踪器它仍在洪流中。追踪器因而就跟 踪了洪流中的对等方。一个洪流中可以拥有少到几个多到几百或几千个对等方。 我们用图 6-33 来进一步说明 BT 的工作原理。当一个新的对等方A加入洪流时，追踪 器就随机地从参与的对等方集合中选择若干个（例如，30个），并把这些对等方的IP 地址 告诉 A。于是 A就和这些对等方建立了TCP 连接。我们称所有与A建立了TCP 连接的对 等方为“相邻对等方”（neighboring peers）。在图 6-33 中我们画出了 A 有三个相邻对等方 （B，C 和 D）。这些相邻对等方的数目是动态变化的，有的不久就离开了，但又有新加入 进来的。请注意，实际的网络拓扑可能是非常复杂的（参见图6-34的实际网络图）。我们知 道，TCP 连接只是个逻辑连接，而每一个 TCP 连接可能会穿越很多的网络。因此我们在讨 论问题时，可以利用实际网络上面的一个更加简洁的覆盖网络，这个覆盖网络忽略了实际网 络的许多细节，使问题的讨论更加方便。在覆盖网络中，A的三个相邻对等方就看得很清 楚。然而在实际网络中，则反映不出这几个对等方的相邻关系。 在任何时刻，每一个对等方可能只拥有某文件的一个文件块子集，而不同的对等方所 拥有的文件块子集也不会完全相同。对等方A将通过TCP连接周期性地向其相邻对等方索 取它们拥有的文件块列表。根据收到的文件块列表，A就知道了应当请求哪一个相邻对等方 把哪些自己缺少的文件块发送过来。 追踪器 TCP连接 D D BT 覆盖网络 实际网络 图6-33 在覆盖网络中对等方的相邻关系的示意图 图 6-34 是对等方之间互相传送数据块的示意图。例如，A 向 B、C和D 索取数据块， 但 B 同时也向C和D传送数据块，D和C还互相传送数据块。由于P2P对等用户的数量非 常多，因此，从不同的对等方获得不同的数据块，然后组装成整个的文件，一般要比仅从一 个地方下载整个的文件要快很多。 对等方A 对等方 对等方 B 图例： 数据块 数据块传送 对等方C 图6-34 对等方之间互相传送文件数据块 然而 A 必须做出两个重要决定。第一，哪些文件块是首先需要向其相邻对等方请求 的？第二，在很多向 A 请求文件块的相邻对等方中，A应当向哪些相邻对等方发送所请求 的文件块？ 对于第一个问题，A要使用叫做最稀有的优先（rarest first）的技术。我们知道，凡是A所 缺少的而正好相邻对等方已拥有的文件块，都应当去索取。可能其中的某些文件块，很多相 邻对等方都有（即文件块的副本很多），这就是“不稀有的”文件块，以后可慢慢请求。如 果 A 所缺少的文件块在相邻对等方中的副本很少，那就是“很稀有的”。因此，A 首先应当 请求副本最少的文件块（即最稀有的）。否则，一旦拥有最稀有文件块的对等方退出了洪 流，就会影响A对所缺文件块的收集。 对于第二个问题，BT 采用了一种更加机灵的算法，其基本思想就是：凡当前有以最高 数据率向 A 传送文件块的某相邻对等方，A就优先把所请求的文件块传送给该相邻对等 方。具体来说，A 持续地测量从其相邻对等方接收数据的速率，并确定速率最高的4个相邻 对等方。接着，A就把文件块发送给这4个相邻对等方。每隔10秒钟，A 还要重新计算数 据率，然后可能修改这4个对等方。在 BT 的术语中，这4个对等方叫做已疏通的或无障碍 的（unchoked）对等方。更重要的是，每隔30秒，A要随机地找一个另外的相邻对等方 B，并 向其发送文件块。这样，A有可能成为B的前4位上传文件块的提供者。在此情况下，B 也有可能向 A 发送文件块。如果B发送文件的速率足够快，那么B也有可能进入A的前 4 位上传文件块的提供者。这样做的结果是，这些对等方相互之间都能够以令人满意的速率 交换文件块。 6。9。3 P2P 文件分发的分析 我们从一个例子开始，来讨论 P2P 文件分发中的几个重要概念[KURO13]。 在图 6-35 中，有N台主机要从互联网上的服务器下载一个大文件，其长度为 F bit。在 图中我们把这个文件也记为F。按照习惯，从互联网传送数据到主机，叫做下载 （download），而反过来传送数据，即从主机向互联网传送，则称为上传（upload）或上载。服务 器的文件是供互联网上的用户享用的，因此服务器的文件只是单方向上传到互联网。我们把 服务器的上传速率记为us，单位是bit/s。再假定主机与互联网连接的链路的上传速率和下载 速率分别为 u； 和d，单位都是bit/s。我们还假定互联网的核心部分不会产生拥塞。瓶颈只 会发生在服务器的接入链路，或者是某些主机的接入链路。 62 d2 d₁ dN UN 文件 F 互联网 Из 5 ds 服务器 图6-35 文件分发的例子 我们先在传统的客户服务器方式下，计算给所有主机分发完毕的最短时间 Tes。 从服务器端考虑，N 台主机共需要从服务器得到的数据总量（比特数）是NF。如果服 务器能够不停地以其上传速率us向各主机传送数据，一直到各主机都收到文件 F，就需要 时间 NF/us，单位是秒。由此可见，不可能小于 NF/us 如果 N 台主机都以各自的下载速率不停地下载文件F，那么下载速率最慢的主机（设 其下载速率为 dmin）的下载文件时间（F/dmin），将是N个下载时间中最大的一个。由此可 见，Tas也不可能小于 F/dmin。 如果 NF/us ≥ F/dmin，则瓶颈在服务器端的接入链路。这时 Tes = NF/us。 如果 F/dmin ≥ NF/us，则瓶颈在下载最慢的主机的接入链路。这时Tes = F/dmin。 由此可得出所有主机都下载完文件F的最少时间是 NF F Tes = max- us da min （6-2） 从以上分析可以看出，若公式（6-2）括号中的第一项远大于第二项，则 Ts近似与主机数 N成正比。如果主机数增大1000倍，那么文件的分发时间也要增大 1000 倍。 下面讨论在 P2P方式下，文件全部分发完毕的最少时间 Tp2p。然而在P2P方式下，文 件分发所需的时间较难计算，这是因为每一台主机在接收文件的同时，还利用自己的上传能 力向其他主机传送文件。文件传送所需的时间取决于主机向对等方传送文件的具体方式。但 是，我们还是可以导出文件分发所需的最少时间的表达式。 在文件分发开始时，只有服务器有文件F。服务器必须把文件F的每一个比特通过接入 链路传送到互联网（至少要传送一次）。因此文件分发的最少时间不可能小于F/us。和客户- 服务器方式相比，在P2P方式下，服务器不需要一遍一遍地发送文件F，因为互联网上的其 他主机（即对等方）可以代替服务器向其他对等方分发文件 F。 在 P2P 方式下，下载速率最慢的主机（设其下载速率为dmin）下载文件 F 的时间是 F/dmin，这是 N个对等方下载时间中最大的一个。可见文件分发的最少时间不可能小于 F/dmin。这个结论和客户服务器方式是一样的。 整个系统中所有主机（包括服务器）的上传速率之和是ur=us+U1+U2+。。。+uyo因 此，文件分发的最少时间也不可能小于 NF/uTo 这样，我们得出在P2P方式下所有主机都下载完文件F的最少时间的下限是 F F NF Tpzp≥max- us d UT min （6-3） 在公式（6-3）的推导过程中，我们假定每一个对等方只要收到一个比特就立即上传到互 联网的其他对等方。但实际上是把收到的若干个比特组成一个数据块后再上传出去。但是当 文件 F 很大时，我们也可以在公式（6-3）中取等号，作为文件F的最少分发时间 Tpzp的近似 值。 有一种情况最值得我们注意。这就是对等方的数目N非常大，因此在公式（6-3）的括号 中的最后一项的值将远大于前两项的值。这样，Tpzp值的下限就近似为NF/uT 我们再假定一些数据。设所有的对等方的上传速率都是u，并且 Flu ==== 1 小时，所有对 等方的下载速率都不小于服务器的上传速率，因而不会对我们的计算产生影响。我们还设服 务器的上传速率us=10u。当N=30时，用公式（6-3）算出所有主机都下载完文件F的最少时 间的下限是 Tp2p = 0。75 F/u= 0。75小时&lt;1小时（不管多大）。如果采用客户-服务器方 式，则当N=30时，所有主机都下载完文件F的最少时间是Ts=NF/us=3小时。 6。9。4 在P2P对等方中搜索对象 在 P2P 文件系统中，对等方用户的数量非常多，并且处于一种无序的状态。任何一个 对等方可以随时加入进来或随时退出。在这种情况下，怎样有效地找到所需的文件，也就是 怎样有效地定位对等方及其资源，乃是P2P系统中的一个十分重要的问题。 限于篇幅，我们在这里只简单介绍一下怎样利用散列函数来定位对等方。 我们知道，Gnutella 是一种采用全分布方法定位内容的P2P文件共享应用程序，它解决 了集中式目录服务器所造成的瓶颈问题。然而 Gnutella 是在非结构化的覆盖网络中采用查询 洪泛的方法来进行查找的，因此查找的效率较低。现在比较好的查找方法是设法构建一种分 布式数据库，以进行对等方及其资源的定位。这种分布式数据库在概念上并不复杂，只要能 够支持大量对等方（可能有几百万个）进行索引查找即可。存储在数据库中的信息只有两个 部分： （1）要查找的资源名K（例如，电影或歌曲的名字）。资源名也可称为关键字。 （2）存放该对象的结点的IP地址N。有的IP地址还附带有端口号。 存放在数据库中的信息就是大量成对出现的（资源名 K，结点的 IP 地址 N）。在查找某 资源名 K 时，只要在数据库中查找到匹配的资源名K，数据库就能够返回对应的结点的 IP 地址 N。所以问题的关键就是要设法把每个资源名K 存放在一个非常便于查找的地方。 细心的读者可能会联想到曾在前面 6。1 节讨论的 DNS 域名系统。DNS 是根据主机的域 名来查找其 IP 地址，这和 P2P 的情况有相似之处。但我们知道，主机的域名是结构化的命 名系统，因此域名服务器可以划分为几种不同的级别（如根服务器等）便于查找。但 P2P 系统则不同，其资源名是非结构化的。因此不能套用DNS的那种查找方法。 前面已经讲过，Napster 在一个集中式目录服务器中构建的查找数据库虽然很简单，但 性能上却有瓶颈。在 P2P 系统中，应怎样构建分布式的P2P数据库？让每个对等方都拥有 所有对等方 IP 地址的列表是不可行的。让所有成对出现的（资源名 K， IP 地址 N）随机地分 散到各对等方也是不可行的。因为这将使查找对象的次数过大，无法使用。现在广泛使用的 索引和查找技术叫做分布式散列表 DHT （Distributed Hash Table）。DHT 也可译为分布式哈希 表，它是由大量对等方共同维护的散列表。基于 DHT 的具体算法已有不少，如 Chord， Pastry，CAN （Content Addressable Network），以及Kademilia 等。下面简单介绍广泛使用的 Chord 算法，这是美国麻省理工大学于2001年提出的[STOI01]。 分布式散列表 DHT 利用散列函数，把资源名K及其存放的结点IP地址N都分别映射 为资源名标识符 KID 和结点标识符 NID。如果所有的对等方都使用散列函数 SHA-1（我们 在下一章 7。4。1 节还要介绍 SHA-1 在网络安全方面的应用），那么通过散列得出的标识符 KID 和 NID 都是 160位二进制数字，且其数值范围在[0， 2'60 - 1]之间。虽然从理论上讲，散 列函数 SHA-1 是多对一的函数，但实际上不同输入得到相同的输出的概率是极小的。此 外，通过 SHA-1 映射得到的标识符能够比较均匀而稀疏地分布在 Chord 环上。为便于讨 论，我们假定现在标识符只有5位二进制数字，也就是说，所有经散列函数得出的标识符的 数值范围都在[0， 31]之间。Chord 把结点按标识符数值从小到大沿顺时针排列成一个环形覆 盖网络（见图 6-36（a）），并按照下面的规则进行映射： （1） 结点标识符 NID 按照其标识符值映射到 Chord 环上对应的点，见图 6-36（a）中标有 NID 的小圆点，如 N4， N7， N10， N20， N26 和 N30。 （2） 资源名标识符 KID 则按照其标识符值映射到与其值最接近的下一个 NID，见图 6- 36（a）中标有 KID 的小方块。所谓“最接近的下一个”NID 就是指：从KID值开始，按顺时 针方向沿 Chord 环遇到的下一个 NID。例如，K31 和K2应放在N4，因为在环上从 31 和 2 按顺时针方向遇到的下一个 NID 是 N4。同理，K8，K12，K23 和K29应分别放在N10， N20， N26 和 N30。如果碰巧同时出现 K29和N29（这种概率极小），那么K29 就应当放在 N29。 请注意：在图 6-36中，K31 和K2 都放在N4，这表示要查找存放资源K31 或 K2 的结 点的 IP 地址，就应当到结点N4去查找。请注意，资源 K31 和 K2 并非存放在结点 N4。 这就是说，每个资源由 Chord 环上与其标识符值最接近的下一个结点提供服务。我们 再强调一下，Chord 环并非实际的网络。在 Chord环上相邻的结点，在地理上很可能相距非 常远。 N30 K31 K2 N30 K31 K2 图例：ONID K29 31 0 1 30 2 K29 29 3 N4 KID 30 31 0 1 2 K23 ☑ 29 1N4 28 28 N26 27 27 6 26 K23 25 7ON7 25 70N7 8 8 24 24 9 9 23 23 K8 K8 10 10 22 22 11 N10 11 N10 21 21 20 20 N20 19 N20 K12 18 17 16 15 （a） KID 和 NID映射在环上 18 17 16 15 -K12 N13 （b）N13加入，N26退出 图 6-36 基于 DHT 的 Chord 环 Chord 环上的每一个结点都要维护两个指针变量，一个指向其后继结点，而另一个指向 其前任结点。例如，在图 6-36（a）中，N10 的后继结点是N20（沿顺时针方向 N10 的下一个 结点），其前任结点是N7（沿逆时针方向N10之前的一个结点）。如果一个新的结点 N13 加 入进来，那么 N20 的前任结点就变为N13，因而 K12 就要从N20的位置移到 N13，同时 N10 的后继结点就变为N13（见图6-36（b））。此外，如果结点 N26 退出，那么 K23 就要移 到N30，而N30 的前任结点就变为N20，同时N20的后继结点变为N30。 在这样的 Chord 环上查找资源，从理论上讲，任何一个结点，只要从其后继结点一个 个地遍历查找下去，一定可以找到所查询的资源。可见要定位一个资源，平均需要沿环发送 查找报文 N/2 个，或遍历 O（N）个结点（N为环上的总结点数）。显然，这种顺序查找的方法 效率很低。 = 为了加速查找，在 Chord 环上可以增加一些指针表（finger table），它又称为路由表或查 找器表。若 Chord 环上的标识符有 m 位（现在 m 5），则在结点n上的指针表可设置不超 过 m 个指针，指向其后继的结点。我们先看图 6-37中结点 N4的指针表。指针表中的第2 列是从 N4 可以指向的多个后继结点。本来每一个结点仅仅指向沿顺时针方向的下一个后继 结点，但现在则指向多个后继结点（在本例中就是 N7，N10 和N20）。第1列的第i行是计 算 （N4 + 2'-'），用来得出后继结点。例如，第4行 i = 4，算出（N4 + 2-1） = N4 + 8 = 12，而 Chord 环上的结点 12 的后继结点是N20。图中还画出了从 N4 到这几个后继结点的 连线（这些连线就是 Chord 环上的弦，Chord 名字由此得出）。还有一点要注意的是，在 N20 的指针表中的第5行，N20+16=36，但按照模 2‘运算，36 mod 2 = 4，恰好结点4的 后继结点是N4。 假定在图 6-37 中的结点 N4 要查找 K29。如果用遍历各结点的方法，则要查找 5 次， 即 N7→N10→N20→N29→N30。但若利用指针表，则 N4 首先在自己的指针表中寻找在不 到 29 且最接近 29 的结点，即N20，然后把定位资源 K29 的请求发送给 N20。在 N20 的指 针表中继续类似的寻找。结果是：最接近29的结点是N30。这就是存放资源 K29 的结点。 这种查找方法类似于二分查找，只用了两次查找，定位一个资源仅需 O（logz）步。 N30 K31 K2 图例： ● NID N4 的指针表 K29 31 0 1 2 KID N4 29 N4 + 1 |N7 28 N4 + 2 NZ N26 N4 + 4 N10 K23 ONG N4 + 8 |N20 8 N4+16 N20 24 N20 的指针表 23 K8 N20+1 N26 N20+2 N26 11 JN10 N20+4 N26 12 19 13 N20+8 N30 N20 |N20+16 N4 K12 图6-37 结点 N4 和N20 的指针表 在 P2P 网络中，对等方可能相当频繁地加入或退出系统，这就需要很好地维护这个分 布式数据库（维护各结点的指针和指针表），而这种维护的工作量可能会很大。当对等方数 量非常大时，究竟采用何种查询机制更加合理，则需要根据具体情况来确定。 P2P 技术还在不断地改进，但随着 P2P 文件共享程序日益广泛地使用，也产生了一系列 的问题有待于解决。这些问题已迫使人们要重新思考下一代互联网应如何演进。例如，音频 /视频文件的知识产权就是其中的一个问题。又如，当非法盗版的、或不健康的音频/视频文 件在互联网上利用 P2P 文件共享程序广泛传播时，要对P2P的流量进行有效的管理，在技 术上还是有相当的难度。由于现在 P2P 文件共享程序的大量使用，已经消耗了互联网主干 网上大部分的带宽。因此，怎样制定出合理的收费标准，既能够让广大网民接受，又能使网 络运营商赢利并继续加大投入，也是目前迫切需要解决的问题。 本章的重要概念 • • 应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于不同主机中的 多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所 遵循的协议。应用层的许多协议都是基于客户服务器方式的。客户是服务请求方， 服务器是服务提供方。 域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。DNS 是一个联机分布式数据库系统，并采用客户服务器方式。 域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序（即域名服务 器）共同完成的。 互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器， 都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制IP 地址中的 点没有关系。 域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服 务器。 文件传送协议 FTP 使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客戶 和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接。实际用于传输 文件的是数据连接。 万维网 WWW 是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网 • 上的一个站点链接到另一个站点。 万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回 客户所要的万维网文档。在客户程序主窗口上显示出的万维网文档称为页面。 万维网使用统一资源定位符 URL 来标志万维网上的各种文档，并使每一个文档在整 个互联网的范围内具有唯一的标识符 URL。 万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议 HTTP。HTTP 使用TCP连接进行可靠的传送。但HTTP协议本身是无连接、无状 态的。HTTP/1。1协议使用了持续连接（分为非流水线方式和流水线方式）。 万维网使用超文本标记语言 HTML 来显示各种万维网页面。 万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的 过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时 才由应用程序动态创建的。 活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可 连续地改变屏幕的显示。 • 在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索 搜索引擎和分类目录搜索引擎两大类。 • 电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发送 到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自 己使用的邮件服务器进行读取，相当于“电子信箱”。 一个电子邮件系统有三个主要组成构件，即：用户代理、邮件服务器，以及邮件协 议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和IMAP）。用户代 理和邮件服务器都要运行这些协议。 电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的 视窗界面来发送和接收邮件。 从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送，都要使用 SMTP 协议。但用户代理从邮件服务器读取邮件时，则要使用 POP3（或IMAP） 协议。 基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏览器和邮件服 务器之间的邮件传送使用 HTTP 协议，而在邮件服务器之间邮件的传送仍然使用 SMTP 协议。 简单网络管理协议 SNMP 由三部分组成，即（1） SNMP 本身，负责读取和改变各代 理中的对象名及其状态数值；（2）管理信息结构 SMI，定义命名对象和定义对象类 型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的基本编码规 则 BER；（3） 管理信息库 MIB，在被管理的实体中创建了命名对象，并规定了其类 型。 系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称 为应用编程接口API。API就是应用程序和操作系统之间的接口。 • 套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而 与操作系统进行交互时使用的一种机制。 320。 目前 P2P 工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应 </CRLF></CRLF></CRLF></CRLF></CRLF></收件人地址></h1></路径></路径></端口></主机></路径></端口></主机></主机></协议></协议></协议></路径></端口></主机></协议>]]></content><author><name></name></author></entry><entry><title type="html">ES6 - 编程风格</title><link href="https://feng-zhang0712.github.io//blog/2024/style/" rel="alternate" type="text/html" title="ES6 - 编程风格"/><published>2024-09-20T00:00:00+00:00</published><updated>2024-09-20T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/style</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/style/"><![CDATA[<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。本章内容主要参考了 <a href="https://github.com/airbnb/javascript">Airbnb</a> 公司的 JavaScript 风格规范。</p> <h2 id="一块级作用域">一、块级作用域</h2> <h3 id="1let-取代-var">（1）let 取代 var</h3> <p>ES6 提出了两个新的声明变量的命令：<code class="language-plaintext highlighter-rouge">let</code> 和 <code class="language-plaintext highlighter-rouge">const</code>。其中，建议使用 <code class="language-plaintext highlighter-rouge">let</code> 命令取代 <code class="language-plaintext highlighter-rouge">var</code>，因为两者语义相同，而且 <code class="language-plaintext highlighter-rouge">let</code> 没有副作用。</p> <h3 id="2全局常量和线程安全">（2）全局常量和线程安全</h3> <p>在 <code class="language-plaintext highlighter-rouge">let</code> 和 <code class="language-plaintext highlighter-rouge">const</code> 之间，建议优先使用 <code class="language-plaintext highlighter-rouge">const</code>，尤其是在全局环境，不应该设置变量，只应设置<strong>常量</strong>。</p> <p><code class="language-plaintext highlighter-rouge">const</code> 优于 <code class="language-plaintext highlighter-rouge">let</code> 有几个原因。</p> <ul> <li><code class="language-plaintext highlighter-rouge">const</code> 可以提醒阅读程序的人，这个变量不应该改变。</li> <li><code class="language-plaintext highlighter-rouge">const</code> 比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算。</li> <li>JavaScript 编译器会对 <code class="language-plaintext highlighter-rouge">const</code> 进行优化，所以多使用 <code class="language-plaintext highlighter-rouge">const</code>，有利于提高程序的运行效率，也就是说 <code class="language-plaintext highlighter-rouge">let</code> 和 <code class="language-plaintext highlighter-rouge">const</code> 的本质区别，其实是编译器内部的处理不同。</li> <li><code class="language-plaintext highlighter-rouge">const</code> 可以防止无意间修改变量值所导致的错误。</li> </ul> <h2 id="二字符串">二、字符串</h2> <p>静态字符串一律使用<strong>单引号</strong>或<strong>反引号</strong>，不使用双引号。动态字符串使用反引号。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bad</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">foobar</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// acceptable</span>
<span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="s2">`foobar`</span><span class="p">;</span>

<span class="c1">// good</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">foobar</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="s2">`foo</span><span class="p">${</span><span class="nx">a</span><span class="p">}</span><span class="s2">bar`</span><span class="p">;</span>
</code></pre></div></div> <h2 id="三解构赋值">三、解构赋值</h2> <ul> <li>使用数组成员对变量赋值时，优先使用<strong>解构赋值</strong>。</li> <li>如果函数返回多个值，优先使用<strong>对象的解构赋值</strong>，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</li> </ul> <h2 id="四对象">四、对象</h2> <ul> <li>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</li> <li> <p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用 <code class="language-plaintext highlighter-rouge">Object.assign</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bad</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">// if reshape unavoidable</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>

<span class="c1">// good</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="kc">null</span> <span class="p">};</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div> </div> </li> <li> <p>如果对象的属性名是动态的，可以在创造对象的时候，使用<strong>属性表达式</strong>定义。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bad</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">id</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">San Francisco</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nf">getKey</span><span class="p">(</span><span class="dl">'</span><span class="s1">enabled</span><span class="dl">'</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="c1">// good</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">id</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">San Francisco</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">[</span><span class="nf">getKey</span><span class="p">(</span><span class="dl">'</span><span class="s1">enabled</span><span class="dl">'</span><span class="p">)]:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div> </div> </li> <li>对象的属性和方法，尽量采用<strong>简洁表达法</strong>，这样易于描述和书写。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">some value</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// bad</span>
<span class="kd">const</span> <span class="nx">atom</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">ref</span><span class="p">:</span> <span class="nx">ref</span><span class="p">,</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">addValue</span><span class="p">:</span> <span class="nf">function </span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">atom</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// good</span>
<span class="kd">const</span> <span class="nx">atom</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">ref</span><span class="p">,</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="nf">addValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">atom</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="五数组">五、数组</h2> <ul> <li>使用<strong>扩展运算符</strong>（<code class="language-plaintext highlighter-rouge">...</code>）拷贝数组。</li> <li>使用 <strong><code class="language-plaintext highlighter-rouge">Array.from</code></strong> 方法，将类似数组的对象转为数组。</li> </ul> <h2 id="六函数">六、函数</h2> <ul> <li>立即执行函数可以写成箭头函数的形式。</li> <li>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 <code class="language-plaintext highlighter-rouge">this</code>。</li> <li>箭头函数取代 <code class="language-plaintext highlighter-rouge">Function.prototype.bind</code>，不应再用 <code class="language-plaintext highlighter-rouge">self</code>/<code class="language-plaintext highlighter-rouge">_this</code>/<code class="language-plaintext highlighter-rouge">that</code> 绑定 <code class="language-plaintext highlighter-rouge">this</code>。</li> <li>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</li> <li>所有配置项都应该集中在一个对象，放在<strong>最后一个参数</strong>，布尔值最好不要直接作为参数，因为代码语义会很差，也不利于将来增加其他配置项。</li> <li>不要在函数体内使用 <code class="language-plaintext highlighter-rouge">arguments</code> 变量，使用 rest 运算符（<code class="language-plaintext highlighter-rouge">...</code>）代替。因为 rest 运算符显式表明你想要获取参数，而且 <code class="language-plaintext highlighter-rouge">arguments</code> 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</li> <li>使用<strong>默认值</strong>语法设置函数参数的默认值。</li> </ul> <h2 id="七map-解构">七、Map 解构</h2> <p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要 <code class="language-plaintext highlighter-rouge">key: value</code> 的数据结构，使用 Map 结构。因为 Map 有<strong>内建的遍历机制</strong>。</p> <h2 id="八class">八、Class</h2> <ul> <li>总是用 Class，取代需要 <code class="language-plaintext highlighter-rouge">prototype</code> 的操作。因为 Class 的写法更简洁，更易于理解。</li> <li>使用 <code class="language-plaintext highlighter-rouge">extends</code> 实现继承，因为这样更简单，不会有破坏 <code class="language-plaintext highlighter-rouge">instanceof</code> 运算的危险。</li> </ul> <h2 id="九模块">九、模块</h2> <p>ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">import</code> 取代 <code class="language-plaintext highlighter-rouge">require()</code>。</li> <li>使用 <code class="language-plaintext highlighter-rouge">export</code> 取代 <code class="language-plaintext highlighter-rouge">module.exports</code>。</li> <li>如果模块只有一个输出值，就使用 <code class="language-plaintext highlighter-rouge">export default</code>，如果模块有多个输出值，除非其中某个输出值特别重要，否则建议不要使用 <code class="language-plaintext highlighter-rouge">export default</code>，即多个输出值如果是<strong>平等关系</strong>，<code class="language-plaintext highlighter-rouge">export default</code> 与普通的 <code class="language-plaintext highlighter-rouge">export</code> 就不要同时使用。</li> <li>如果模块默认输出一个函数，函数名的首字母应该<strong>小写</strong>，表示这是一个<strong>工具方法</strong>。</li> <li>如果模块默认输出一个对象，对象名的首字母应该<strong>大写</strong>，表示这是一个<strong>配置值对象</strong>。</li> </ul> <h2 id="十eslint-的使用">十、ESLint 的使用</h2> <p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p> <ol> <li> <p>首先，在项目的根目录安装 ESLint。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> npm <span class="nb">install</span> <span class="nt">--save-dev</span> eslint
</code></pre></div> </div> </li> <li> <p>然后，安装 Airbnb 语法规则，以及 <code class="language-plaintext highlighter-rouge">import</code>、<code class="language-plaintext highlighter-rouge">a11y</code>、<code class="language-plaintext highlighter-rouge">react</code> 插件。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> npm <span class="nb">install</span> <span class="nt">--save-dev</span> eslint-config-airbnb
 npm <span class="nb">install</span> <span class="nt">--save-dev</span> eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react
</code></pre></div> </div> </li> <li> <p>最后，在项目的根目录下新建一个 <code class="language-plaintext highlighter-rouge">.eslintrc</code> 文件，配置 ESLint。</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"extends"</span><span class="p">:</span><span class="w"> </span><span class="s2">"eslint-config-airbnb"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span></code></pre></div> </div> </li> </ol> <p>现在就可以检查，当前项目的代码是否符合预设的规则。</p> <h2 id="十一参考">十一、参考</h2> <ul> <li>阮一峰，<a href="https://es6.ruanyifeng.com/#docs/style">ECMAScript 6 入门 - 编程风格</a></li> </ul>]]></content><author><name></name></author><category term="frontend"/><category term="es6"/><category term="style"/><category term="airbnb"/><summary type="html"><![CDATA[本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。本章内容主要参考了 Airbnb 公司的 JavaScript 风格规范。]]></summary></entry><entry><title type="html">响应式 Web 设计</title><link href="https://feng-zhang0712.github.io//blog/2024/responsive-web-design/" rel="alternate" type="text/html" title="响应式 Web 设计"/><published>2024-09-14T00:00:00+00:00</published><updated>2024-09-14T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/responsive-web-design</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/responsive-web-design/"><![CDATA[<h2 id="一简介">一、简介</h2> <p>响应式 Web 设计，指网页内容会随着访问它的视口及设备的不同而呈现不同的样式。</p> <p>在响应式设计的早期，人们会针对不同的流行的设备宽度设置<strong>断点</strong>，所谓“断点”，就是某个宽度临界点，跨过这个点布局就会发生显著变化。显然，这并不是一个好的做法，因为这样实际上把设计跟特定的屏幕大小绑定了。既然是响应式设计，那应该与显示它的设备无关才对，而不是只在某些屏幕中才最合适。断点应该由内容和设计本身决定，也就是，根据项目的实际需求设计决定。</p> <h2 id="二媒体查询">二、媒体查询</h2> <p><strong>媒体查询</strong>（Media Queries）主要用于设计响应式 Web 设计，使网页能够适应不同的设备和屏幕尺寸。即根据设备的特性（如屏幕宽度、高度、分辨率等）应用不同的样式。W3C 对媒体查询的定义是：媒体查询包含媒体类型和零个或多个检测媒体特性的表达式（比如，<code class="language-plaintext highlighter-rouge">width</code>、<code class="language-plaintext highlighter-rouge">height</code> 和 <code class="language-plaintext highlighter-rouge">color</code> 都是可用于媒体查询的特性）。使用媒体查询，可以不必修改内容本身，而让网页适配不同的设备。</p> <p>常用媒体特性如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">width</code>：视口的宽度。</li> <li><code class="language-plaintext highlighter-rouge">height</code>：视口的高度。</li> <li><code class="language-plaintext highlighter-rouge">device-width</code>：设备屏幕的宽度。</li> <li><code class="language-plaintext highlighter-rouge">device-height</code>：设备屏幕的高度。</li> <li><code class="language-plaintext highlighter-rouge">resolution</code>：设备屏幕的分辨率，通常以 <code class="language-plaintext highlighter-rouge">dpi</code>（每英寸点数）或 <code class="language-plaintext highlighter-rouge">dppx</code>（每像素点数）表示。</li> <li><code class="language-plaintext highlighter-rouge">orientation</code>：设备的方向，可以是 <code class="language-plaintext highlighter-rouge">portrait</code> 或 <code class="language-plaintext highlighter-rouge">landscape</code>。</li> <li><code class="language-plaintext highlighter-rouge">aspect-ratio</code>：视口的宽高比。不如，16∶9 的宽屏显示器可以写成 <code class="language-plaintext highlighter-rouge">aspect-ratio: 16/9</code>。</li> <li><code class="language-plaintext highlighter-rouge">color</code>：设备的颜色位深。</li> <li><code class="language-plaintext highlighter-rouge">color-index</code>：设备颜色查找表中的条目数，值必须是数值，且不能为负。</li> <li><code class="language-plaintext highlighter-rouge">monochrome</code>：单色帧缓冲中表示每个像素的位数，值必须是数值（整数），比如 <code class="language-plaintext highlighter-rouge">monochrome: 2</code>，且不能为负。</li> <li><code class="language-plaintext highlighter-rouge">scan</code>：针对电视的逐行扫描（progressive）和隔行扫描（interlace）。例如 720p HD TV（720p 中的 <code class="language-plaintext highlighter-rouge">p</code> 表示 progressive，即逐行）可以使用 <code class="language-plaintext highlighter-rouge">scan: progressive</code> 来判断； 而 1080i HD TV（1080i 中的 <code class="language-plaintext highlighter-rouge">i</code> 表示 interlace，即隔行）可以使用 <code class="language-plaintext highlighter-rouge">scan: interlace</code> 来判断。</li> <li><code class="language-plaintext highlighter-rouge">grid</code>：设备基于栅格还是位图。</li> </ul> <p>上面列表中的特性，除 <code class="language-plaintext highlighter-rouge">grid</code> 外，都可以加上 <code class="language-plaintext highlighter-rouge">min-</code> 或 <code class="language-plaintext highlighter-rouge">max-</code> 前缀以指定范围。</p> <h3 id="21-媒体查询的语法">2.1 媒体查询的语法</h3> <p>下面是一个最简单的媒体查询语法结构。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@media</span> <span class="n">media-type</span> <span class="n">and</span> <span class="p">(</span><span class="n">media-feature</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">/* CSS规则 */</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">media-type</code>：指定设备类型，如 <code class="language-plaintext highlighter-rouge">screen</code>、<code class="language-plaintext highlighter-rouge">print</code> 等。可以省略，表示适用于所有类型（此时 <code class="language-plaintext highlighter-rouge">media-type: all</code>）。</li> <li><code class="language-plaintext highlighter-rouge">media-feature</code>：指定的媒体特性，如 <code class="language-plaintext highlighter-rouge">max-width</code>、<code class="language-plaintext highlighter-rouge">min-width</code> 等。</li> </ul> <p>也可以在 <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性中指定设备类型。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"style sheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">media=</span><span class="s">"screen"</span> <span class="na">href=</span><span class="s">"style.css"</span><span class="nt">&gt;</span> 
</code></pre></div></div> <h3 id="22-组合媒体查询">2.2 组合媒体查询</h3> <p>多个媒体查询组合，使用逗号（<code class="language-plaintext highlighter-rouge">,</code>）分隔不同的查询条件。表示如果任意一个条件为真则应用样式。还可以使用逻辑运算符 <code class="language-plaintext highlighter-rouge">and</code>、<code class="language-plaintext highlighter-rouge">or</code>、<code class="language-plaintext highlighter-rouge">not</code> 组合多个条件。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* 适用于屏幕最大宽度为600px或屏幕高度为 800px 的设备 */</span>
<span class="k">@media</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">),</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-height</span><span class="p">:</span> <span class="m">800px</span><span class="p">)</span> <span class="p">{</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">lightblue</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c">/* 适用于屏幕宽度在 600px 到 1200px 之间且横向模式的设备 */</span>
<span class="k">@media</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">min-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span> <span class="m">1200px</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">orientation</span><span class="p">:</span> <span class="nb">landscape</span><span class="p">)</span> <span class="p">{</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">lightgreen</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以在使用 <code class="language-plaintext highlighter-rouge">@import</code> 导入 CSS 时使用媒体查询，有条件地向当前样式表中加载其他样式表。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@import</span> <span class="sx">url("phone.css")</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span><span class="m">360px</span><span class="p">);</span> 
</code></pre></div></div> <p>上面的代码表示，<code class="language-plaintext highlighter-rouge">phone.css</code> 样式表生效的条件是：设备类型必须是屏幕设备，且视口不超过 360px。</p> <p>注意，在针对所有设备的媒体查询中，可以使用简写语法，即省略关键字 <code class="language-plaintext highlighter-rouge">all</code>（以及紧随其后的 <code class="language-plaintext highlighter-rouge">and</code>）。换句话说，如果不指定关键字，则关键字就是 <code class="language-plaintext highlighter-rouge">all</code>。</p> <h3 id="23-视口的-meta-标签">2.3 视口的 meta 标签</h3> <p>视口的 <code class="language-plaintext highlighter-rouge">meta</code> 标签，是网页与移动浏览器的接口。网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。视口的 <code class="language-plaintext highlighter-rouge">meta</code> 标签主要使用以下几个属性控制页面在移动端的行为。</p> <ul> <li><code class="language-plaintext highlighter-rouge">width</code>：用于设置页面的宽度。</li> <li><code class="language-plaintext highlighter-rouge">height</code>：用于设置页面的高度，通常设置了 <code class="language-plaintext highlighter-rouge">width</code> 就不会再设置 <code class="language-plaintext highlighter-rouge">height</code>。</li> <li><code class="language-plaintext highlighter-rouge">initial-scale</code>：设置页面的初始缩放比例。</li> <li><code class="language-plaintext highlighter-rouge">user-scalable</code>：一个布尔值，用于设置页面是否可以缩放。</li> <li><code class="language-plaintext highlighter-rouge">minimum-scale</code>：设置页面的最小缩放比例，只有在 <code class="language-plaintext highlighter-rouge">user-scalable=true</code> 时，此属性才会生效。</li> <li><code class="language-plaintext highlighter-rouge">maximum-scale</code>：设置页面的最大缩放比例，只有在 <code class="language-plaintext highlighter-rouge">user-scalable=true</code> 时，此属性才会生效。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">meta</span> <span class="nt">name</span><span class="o">=</span><span class="s1">"viewport"</span> <span class="nt">content</span><span class="o">=</span><span class="s1">"width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=0.5, maximum-scale=3"</span> <span class="o">/&gt;</span> 
</code></pre></div></div> <p>上面的代码表示，在移动设备上，页面的宽度为设备宽度，页面初始的缩放比例为 1，允许用户进行缩放操作，且最小和最大缩放比例分别为 0.5 和 3。</p> <h2 id="三弹性布局网格布局与响应式图片">三、弹性布局、网格布局与响应式图片</h2> <p>布局的传统解决方案，基于盒状模型，依赖 <code class="language-plaintext highlighter-rouge">display</code> + <code class="language-plaintext highlighter-rouge">position</code> + <code class="language-plaintext highlighter-rouge">float</code> 等属性。而现代的布局方案，更多的是使用 Flex 和 Grid 布局。下面依次对他们进行介绍。</p> <h3 id="31-盒模型">3.1 盒模型</h3> <p>CSS 盒模型指一个元素在页面上所占据的空间。由四部分组成：<code class="language-plaintext highlighter-rouge">content</code>、<code class="language-plaintext highlighter-rouge">padding</code>、<code class="language-plaintext highlighter-rouge">border</code> 和 <code class="language-plaintext highlighter-rouge">margin</code>。盒模型主要分为两种：标准盒模型和替代盒模型。</p> <p>（1）标准盒模型（content-box）</p> <p>此模型元素的 <code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code>，只包含内容的宽高，不包含 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>。 此时 <code class="language-plaintext highlighter-rouge">padding</code>、<code class="language-plaintext highlighter-rouge">border</code> 和 <code class="language-plaintext highlighter-rouge">margin</code> 都在这个盒子的外部。</p> <p>（2）替代盒模型（border-box）</p> <p>也叫 IE 盒子模型，此模型元素的 <code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code>，包含 <code class="language-plaintext highlighter-rouge">content</code>、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>。此时 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code> 都在盒子内部。</p> <p>（3）可以通过 <code class="language-plaintext highlighter-rouge">box-sizing</code> 属性，设置一个元素显示为哪种盒模型。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">box-sizing</span><span class="o">:</span> <span class="nt">content-box</span> <span class="o">(</span><span class="nt">默认</span><span class="o">)</span> <span class="o">|</span> <span class="nt">border-box</span><span class="o">;</span>
</code></pre></div></div> <h3 id="32-布局相关属性">3.2 布局相关属性</h3> <p>先介绍几个跟布局相关的属性，他们是：<code class="language-plaintext highlighter-rouge">display</code>、<code class="language-plaintext highlighter-rouge">position</code> 和 <code class="language-plaintext highlighter-rouge">z-index</code>。</p> <p>（1）<code class="language-plaintext highlighter-rouge">display</code> 属性设置元素是否被视为块级或行级盒子以及用于子元素的布局。其语法格式如下（以下只列出了 display 属性的几个常用取值）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">display</span><span class="o">:</span> <span class="nt">flex</span> <span class="o">|</span> <span class="nt">grid</span> <span class="o">|</span> <span class="nt">none</span> <span class="o">|</span> <span class="nt">block</span> <span class="o">|</span> <span class="nt">inline</span> <span class="o">|</span> <span class="nt">inline-block</span> <span class="o">|</span> <span class="nt">table</span><span class="o">;</span>
</code></pre></div></div> <p>注意区分 <code class="language-plaintext highlighter-rouge">display: none</code>、<code class="language-plaintext highlighter-rouge">visibility: hidden</code> 及 <code class="language-plaintext highlighter-rouge">opacity: 0</code> 之间的区别。</p> <ul> <li><code class="language-plaintext highlighter-rouge">display: none</code>：用于将元素完全从页面中移除，包括占用的空间。</li> <li><code class="language-plaintext highlighter-rouge">visibility: hidden</code>：用于隐藏元素，但元素占用的空间会保留，且该元素仍会影响页面布局。</li> <li><code class="language-plaintext highlighter-rouge">opacity: 0</code>：元素依然参与正常布局，且依然“可见”，只是该元素变为透明样式，但用户依然可以与其交互 ·。</li> </ul> <p>（2）<code class="language-plaintext highlighter-rouge">position</code> 属性用于指定一个元素在页面的定位方式。其语法格式如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">position</span><span class="o">:</span> <span class="nt">static</span> <span class="o">(</span><span class="nt">默认</span><span class="o">)</span> <span class="o">|</span> <span class="nt">relative</span> <span class="o">|</span> <span class="nt">absolute</span> <span class="o">|</span> <span class="nt">fixed</span> <span class="o">|</span> <span class="nt">sticky</span><span class="o">;</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">static</code>：默认值，表示元素按照正常的文档流进行布局。使用 <code class="language-plaintext highlighter-rouge">static</code> 定位的元素不会被定位偏移（此时，<code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 属性无效）。</li> <li><code class="language-plaintext highlighter-rouge">relative</code>：定位的元素相对于其正常位置进行偏移。使用 <code class="language-plaintext highlighter-rouge">relative</code> 定位的元素仍然占据原来的空间，但可以通过 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 属性进行偏移。适用于需要微调元素位置的场景。</li> <li><code class="language-plaintext highlighter-rouge">absolute</code>：定位的元素脱离正常文档流，不再占据空间。使用 <code class="language-plaintext highlighter-rouge">absolute</code> 定位的元素相对于最近的非 <code class="language-plaintext highlighter-rouge">static</code> 的祖先元素进行定位。如果没有这样的祖先元素，则相对于网页的根元素 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 进行定位。适用于需要精确定位的场景。</li> <li><code class="language-plaintext highlighter-rouge">fixed</code>：定位的元素脱离正常文档流，不再占据空间。使用 <code class="language-plaintext highlighter-rouge">fixed</code> 定位的元素相对于 视口（浏览器窗口）进行定位，即使页面滚动，其位置也不会改变。适用于需要固定位置的元素，如导航栏、工具栏等。</li> <li> <p><code class="language-plaintext highlighter-rouge">sticky</code>：定位的元素根据用户的滚动位置进行切换，介于 <code class="language-plaintext highlighter-rouge">relative</code> 和 <code class="language-plaintext highlighter-rouge">fixed</code> 之间。使用 <code class="language-plaintext highlighter-rouge">sticky</code> 定位的元素在跨越特定阈值（即 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 设置的值）之前表现为 <code class="language-plaintext highlighter-rouge">relative</code> 定位，跨越阈值后表现为 <code class="language-plaintext highlighter-rouge">fixed</code> 定位。适用于需要在滚动时固定位置的元素，如表头、侧边栏等。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">#toolbar</span> <span class="p">{</span>
  <span class="nl">top</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="n">sticky</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码中，页面向下滚动时，<code class="language-plaintext highlighter-rouge">#toolbar</code> 的父元素开始脱离视口，一旦视口的顶部与 <code class="language-plaintext highlighter-rouge">#toolbar</code> 的距离小于 20px（门槛值），<code class="language-plaintext highlighter-rouge">#toolbar</code> 就自动变为 <code class="language-plaintext highlighter-rouge">fixed</code> 定位，保持与视口顶部 20px 的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），<code class="language-plaintext highlighter-rouge">#toolbar</code> 恢复成 <code class="language-plaintext highlighter-rouge">relative</code> 定位。</p> </li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">z-index</code> 属性用于控制重叠元素的层叠顺序。</p> <p><code class="language-plaintext highlighter-rouge">z-index</code> 只有在 <code class="language-plaintext highlighter-rouge">position</code> 属性值为 <code class="language-plaintext highlighter-rouge">relative</code>、<code class="language-plaintext highlighter-rouge">absolute</code>、<code class="language-plaintext highlighter-rouge">fixed</code> 或 <code class="language-plaintext highlighter-rouge">sticky</code> 时才有效。<code class="language-plaintext highlighter-rouge">z-index</code> 的值可以是正整数、负整数或零，值越大，元素的层级越高。</p> <h3 id="33-flex-布局">3.3 Flex 布局</h3> <p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span><span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 也可以为行内元素开启 Flex 布局 */</span>
<span class="nc">.box</span><span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意，设为 Flex 布局以后，子元素的 <code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">clear</code> 和 <code class="language-plaintext highlighter-rouge">vertical-align</code> 属性将失效。</p> <h4 id="331-基本概念">3.3.1 基本概念</h4> <p>采用 Flex 布局的元素，称为 Flex <strong>容器</strong>（container）。它的所有子元素自动成为容器成员，称为 Flex <strong>项目</strong>（item）。</p> <p>容器默认存在两根轴：水平的<strong>主轴</strong>（main axis）和垂直的<strong>交叉轴</strong>（cross axis）。主轴的开始位置（与边框的交叉点）叫做 <strong>main start</strong>，结束位置叫做 <strong>main end</strong>；交叉轴的开始位置叫做 <strong>cross start</strong>，结束位置叫做 <strong>cross end</strong>。</p> <p><strong>项目默认沿主轴排列</strong>。单个项目占据的主轴空间叫做 <strong>main size</strong>，占据的交叉轴空间叫做 <strong>cross size</strong>。</p> <h4 id="332-容器的属性">3.3.2 容器的属性</h4> <p>作用在容器上的属性有 6 个：<code class="language-plaintext highlighter-rouge">flex-direction</code>、<code class="language-plaintext highlighter-rouge">flex-wrap</code>、<code class="language-plaintext highlighter-rouge">flex-flow</code>、<code class="language-plaintext highlighter-rouge">justify-content</code>、<code class="language-plaintext highlighter-rouge">align-items</code> 和 <code class="language-plaintext highlighter-rouge">align-content</code>。下面，依次对他们进行讲解。</p> <p>（1）<code class="language-plaintext highlighter-rouge">flex-direction</code>：用于决定主轴的方向（即项目的排列方向）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">row</span> <span class="err">|</span> <span class="n">row-reverse</span> <span class="err">|</span> <span class="n">column</span> <span class="err">|</span> <span class="n">column-reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="flex-direction 属性"/></p> <ul> <li><code class="language-plaintext highlighter-rouge">row</code>（默认值）：主轴为水平方向，起点在左端。</li> <li><code class="language-plaintext highlighter-rouge">row-reverse</code>：主轴为水平方向，起点在右端。</li> <li><code class="language-plaintext highlighter-rouge">column</code>：主轴为垂直方向，起点在上沿。</li> <li><code class="language-plaintext highlighter-rouge">column-reverse</code>：主轴为垂直方向，起点在下沿。</li> </ul> <p>（2）<code class="language-plaintext highlighter-rouge">flex-wrap</code>：默认情况下，项目都排在一条线（又称”轴线”）上。<code class="language-plaintext highlighter-rouge">flex-wrap</code> 属性定义，如果一条轴线排不下，如何换行。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span><span class="p">{</span>
  <span class="nl">flex-wrap</span><span class="p">:</span> <span class="nb">nowrap</span> <span class="err">|</span> <span class="n">wrap</span> <span class="err">|</span> <span class="n">wrap-reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">nowrap</code>（默认）：不换行。</li> <li><code class="language-plaintext highlighter-rouge">wrap</code>：换行，第一行在上方。</li> <li><code class="language-plaintext highlighter-rouge">wrap-reverse</code>：换行，第一行在下方。</li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">flex-flow</code>：<code class="language-plaintext highlighter-rouge">flex-direction</code> 属性和 <code class="language-plaintext highlighter-rouge">flex-wrap</code> 属性的简写形式，默认值为 <code class="language-plaintext highlighter-rouge">row nowrap</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">flex-flow</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">flex-direction</span><span class="err">&gt;</span> <span class="err">||</span> <span class="err">&lt;</span><span class="n">flex-wrap</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（4）<code class="language-plaintext highlighter-rouge">justify-content</code>：定义项目在主轴上的对齐方式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-around</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="justify-content 属性"/></p> <p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>（默认值）：左对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：右对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>： 居中。</li> <li><code class="language-plaintext highlighter-rouge">space-between</code>：两端对齐，项目之间的间隔都相等。</li> <li><code class="language-plaintext highlighter-rouge">space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li> </ul> <p>（5）<code class="language-plaintext highlighter-rouge">align-items</code>：定义项目在交叉轴上的对齐方式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="nb">baseline</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="align-items 属性"/></p> <p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>：交叉轴的起点对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：交叉轴的终点对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：交叉轴的中点对齐。</li> <li><code class="language-plaintext highlighter-rouge">baseline</code>: 项目的第一行文字的基线对齐。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>（默认值）：如果项目未设置高度或设为 <code class="language-plaintext highlighter-rouge">auto</code>，将占满整个容器的高度。</li> </ul> <p>（6）align-content：定义多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="align-content 属性"/></p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>：与交叉轴的起点对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：与交叉轴的终点对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：与交叉轴的中点对齐。</li> <li><code class="language-plaintext highlighter-rouge">space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li> <li><code class="language-plaintext highlighter-rouge">space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>（默认值）：轴线占满整个交叉轴。</li> </ul> <h4 id="333-项目的属性">3.3.3 项目的属性</h4> <p>作用在项目上的属性有 6 个：<code class="language-plaintext highlighter-rouge">order</code>、<code class="language-plaintext highlighter-rouge">flex-grow</code>、<code class="language-plaintext highlighter-rouge">flex-shrink</code>、<code class="language-plaintext highlighter-rouge">flex-basis</code>、<code class="language-plaintext highlighter-rouge">flex</code> 和 <code class="language-plaintext highlighter-rouge">align-self</code>。下面，依次对他们进行讲解。</p> <p>（1）<code class="language-plaintext highlighter-rouge">order</code>：定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">order</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">integer</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">flex-grow</code>：定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-grow</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">number</span><span class="err">&gt;</span><span class="p">;</span> <span class="c">/* default 0 */</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果所有项目的 <code class="language-plaintext highlighter-rouge">flex-grow</code> 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code class="language-plaintext highlighter-rouge">flex-grow</code> 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p> <p>（3）<code class="language-plaintext highlighter-rouge">flex-shrink</code>：定义项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-shrink</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">number</span><span class="err">&gt;</span><span class="p">;</span> <span class="c">/* default 1 */</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果所有项目的 <code class="language-plaintext highlighter-rouge">flex-shrink</code> 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 <code class="language-plaintext highlighter-rouge">flex-shrink</code> 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</p> <p>（4）<code class="language-plaintext highlighter-rouge">flex-basis</code>：定义在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 <code class="language-plaintext highlighter-rouge">auto</code>，即项目的本来大小。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-basis</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">length</span><span class="err">&gt;</span> <span class="err">|</span> <span class="nb">auto</span><span class="p">;</span> <span class="c">/* default auto */</span>
<span class="p">}</span>
</code></pre></div></div> <p>它可以设为跟 <code class="language-plaintext highlighter-rouge">width</code> 或 <code class="language-plaintext highlighter-rouge">height</code> 属性一样的值（比如 350px），则项目将占据固定空间。</p> <p>（5）<code class="language-plaintext highlighter-rouge">flex</code>：<code class="language-plaintext highlighter-rouge">flex-grow</code>, <code class="language-plaintext highlighter-rouge">flex-shrink</code> 和 <code class="language-plaintext highlighter-rouge">flex-basis</code> 的简写，默认值为 <code class="language-plaintext highlighter-rouge">0 1 auto</code>。后两个属性可选。</p> <p>该属性有两个快捷值：<code class="language-plaintext highlighter-rouge">auto</code> (<code class="language-plaintext highlighter-rouge">1 1 auto</code>) 和 <code class="language-plaintext highlighter-rouge">none</code> (<code class="language-plaintext highlighter-rouge">0 0 auto</code>)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p> <p>（6）<code class="language-plaintext highlighter-rouge">align-self</code>：<code class="language-plaintext highlighter-rouge">align-self</code> 属性允许单个项目有与其他项目有不一样的对齐方式，可覆盖 <code class="language-plaintext highlighter-rouge">align-items</code> 属性。默认值为 <code class="language-plaintext highlighter-rouge">auto</code>，表示继承父元素的 <code class="language-plaintext highlighter-rouge">align-items</code> 属性，如果没有父元素，则等同于 <code class="language-plaintext highlighter-rouge">stretch</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="nb">auto</span> <span class="err">|</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="nb">baseline</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="align-self 属性"/></p> <p>该属性可能取 6 个值，除了 <code class="language-plaintext highlighter-rouge">auto</code>，其他都与 <code class="language-plaintext highlighter-rouge">align-items</code> 属性完全一致。</p> <h3 id="34-grid-布局">3.4 Grid 布局</h3> <p>网格布局（Grid）将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p> <p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”<strong>行</strong>“和”<strong>列</strong>“，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。</p> <h4 id="341-基本概念">3.4.1 基本概念</h4> <p>（1）采用网格布局的区域，称为<strong>容器</strong>（container）。容器内部采用网格定位的子元素，称为<strong>项目</strong>（item）。</p> <p>注意：项目只能是容器的<strong>顶层子元素</strong>，不包含项目的子元素。Grid 布局只对项目生效。</p> <p>（2）容器里面的水平区域称为”<strong>行</strong>“（row），垂直区域称为”<strong>列</strong>“（column）。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032502.png" alt="Grid 布局的行和列"/></p> <p>（3）行和列的交叉区域，称为”<strong>单元格</strong>“（cell）。正常情况下，<code class="language-plaintext highlighter-rouge">n</code> 行和 <code class="language-plaintext highlighter-rouge">m</code> 列会产生 <code class="language-plaintext highlighter-rouge">n x m</code> 个单元格。比如，3 行 3 列会产生 9 个单元格。</p> <p>（4）划分网格的线，称为”<strong>网格线</strong>“（grid line）。水平网格线划分出行，垂直网格线划分出列。</p> <p>正常情况下，<code class="language-plaintext highlighter-rouge">n</code> 行有 <code class="language-plaintext highlighter-rouge">n + 1</code> 根水平网格线，<code class="language-plaintext highlighter-rouge">m</code> 列有 <code class="language-plaintext highlighter-rouge">m + 1</code> 根垂直网格线，比如三行就有四根水平网格线。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032503.png" alt="Grid 布局的网格线"/></p> <p>上图是一个 4 x 4 的网格，共有 5 根水平网格线和 5 根垂直网格线。</p> <h4 id="342-容器属性">3.4.2 容器属性</h4> <p>（1）<code class="language-plaintext highlighter-rouge">display: grid</code>：指定一个容器采用网格布局。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032504.png" alt="display: grid 的效果"/></p> <p>上图是 <code class="language-plaintext highlighter-rouge">display: grid</code> 的<a href="https://jsbin.com/guvivum/edit?html,css,output">效果</a>。</p> <p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-grid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032505.png" alt="display: inline-grid 的效果"/></p> <p>上图是 <code class="language-plaintext highlighter-rouge">display: inline-grid</code> 的<a href="https://jsbin.com/qatitav/edit?html,css,output">效果</a>。</p> <p>注意，设为网格布局以后，容器子元素（项目）的 <code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">display: inline-block</code>、<code class="language-plaintext highlighter-rouge">display: table-cell</code>、<code class="language-plaintext highlighter-rouge">vertical-align</code> 和 <code class="language-plaintext highlighter-rouge">column-*</code> 等设置都将失效。</p> <p>（2）<code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性、<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性定义每列的列宽，<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性定义每行的行高。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/qiginur/edit?css,output">上面代码</a>指定了一个三行三列的网格，列宽和行高都是 100px。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032506.png" alt="grid-template-rows 属性，grid-template-columns 属性"/></p> <p>除了使用<strong>绝对单位</strong>，也可以使用<strong>百分比</strong>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">33.33%</span> <span class="m">33.33%</span> <span class="m">33.33%</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">33.33%</span> <span class="m">33.33%</span> <span class="m">33.33%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">repeat()</code>：函数用于重复一组值。上面的代码用 <code class="language-plaintext highlighter-rouge">repeat()</code> 改写如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">33.33%</span><span class="p">);</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">33.33%</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">repeat()</code> 接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。<code class="language-plaintext highlighter-rouge">repeat()</code> 也可以重复某种模式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">100</span><span class="nt">px</span> <span class="err">20</span><span class="nt">px</span> <span class="err">80</span><span class="nt">px</span><span class="o">);</span>
</code></pre></div> </div> <p>上面代码定义了 6 列，第一列和第四列的宽度为 100px，第二列和第五列为 20px，第三列和第六列为 80px。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032507.png" alt="repeat() 重复某种模式"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">auto-fill</code> 关键字：表示自动填充。有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每行（或每列）容纳尽可能多的单元格，这时可以使用 <code class="language-plaintext highlighter-rouge">auto-fill</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="n">auto-fill</span><span class="p">,</span> <span class="m">100px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p><a href="https://jsbin.com/himoku/edit?css,output">上面代码</a>表示每列宽度 100px，然后自动填充，直到容器不能放置更多的列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032508.png" alt="auto-fill"/></p> <p>除了 <code class="language-plaintext highlighter-rouge">auto-fill</code>，还有一个关键字 <code class="language-plaintext highlighter-rouge">auto-fit</code>，两者的行为基本是相同的。只有当容器足够宽，可以在一行容纳所有单元格，并且单元格宽度不固定的时候，才会有行为差异：<code class="language-plaintext highlighter-rouge">auto-fill</code> 会用空格子填满剩余宽度，<code class="language-plaintext highlighter-rouge">auto-fit</code> 则会尽量扩大单元格的宽度。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">fr</code>（fraction 的缩写，意为”片段”）关键字：用于表示比例关系。如果两列的宽度分别为 1fr 和 2fr，就表示后者是前者的两倍。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">1</span><span class="n">fr</span> <span class="m">1</span><span class="n">fr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p><a href="https://jsbin.com/hadexek/edit?html,css,output">上面代码</a>表示两个相同宽度的列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032509.png" alt="fr 表示的相同宽度的列"/></p> <p><code class="language-plaintext highlighter-rouge">fr</code> 可以与绝对长度的单位结合使用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">150px</span> <span class="m">1</span><span class="n">fr</span> <span class="m">2</span><span class="n">fr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码表示，第一列的宽度为 150px，第二列的宽度是第三列的一半。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032510.png" alt="fr 与绝对长度的单位结合使用"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">minmax()</code>：此函数用于产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="err">1</span><span class="nt">fr</span> <span class="err">1</span><span class="nt">fr</span> <span class="nt">minmax</span><span class="o">(</span><span class="err">100</span><span class="nt">px</span><span class="o">,</span> <span class="err">1</span><span class="nt">fr</span><span class="o">);</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">minmax(100px, 1fr)</code> 表示列宽不小于 100px，不大于 1fr。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">auto</code> 关键字：表示由浏览器自己决定长度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="err">100</span><span class="nt">px</span> <span class="nt">auto</span> <span class="err">100</span><span class="nt">px</span><span class="o">;</span>
</code></pre></div> </div> <p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了 <code class="language-plaintext highlighter-rouge">min-width</code>，且这个值大于最大宽度。</p> </li> <li> <p>网格线的名称：<code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性里面，还可以使用方括号，指定每根网格线的名字，方便以后的引用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">c3</span><span class="p">]</span> <span class="nb">auto</span> <span class="p">[</span><span class="n">c4</span><span class="p">];</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">r3</span><span class="p">]</span> <span class="nb">auto</span> <span class="p">[</span><span class="n">r4</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码指定网格布局为 3 行 x 3 列，因此有 4 根垂直网格线和 4 根水平网格线。方括号里面依次是这八根线的名字。</p> <p>网格布局允许同一根线有多个名字，比如 <code class="language-plaintext highlighter-rouge">[fifth-line row-5]</code>。</p> </li> <li> <p>布局实例</p> <p><code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性对于网页布局非常有用。两栏式布局只需要一行代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.wrapper</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">70%</span> <span class="m">30%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码将左边栏设为 70%，右边栏设为 30%。传统的十二网格布局，写起来也很容易。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="err">12</span><span class="o">,</span> <span class="err">1</span><span class="nt">fr</span><span class="o">);</span>
</code></pre></div> </div> </li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">grid-row-gap</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 属性、<code class="language-plaintext highlighter-rouge">grid-gap</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-row-gap</code> 属性设置行与行的间隔（行间距），<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 属性设置列与列的间隔（列间距）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">grid-row-gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="py">grid-column-gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/mezufab/edit?css,output">上面代码</a>中，<code class="language-plaintext highlighter-rouge">grid-row-gap</code> 用于设置行间距，grid-column-gap 用于设置列间距。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032511.png" alt="grid-row-gap 属性、grid-column-gap 属性"/></p> <p><code class="language-plaintext highlighter-rouge">grid-gap</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-column-gap</code> 和 <code class="language-plaintext highlighter-rouge">grid-row-gap</code> 的合并简写形式，语法如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-gap</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">grid-row-gap</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">grid-column-gap</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>因此，上面一段 CSS 代码等同于下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">grid-gap</span><span class="p">:</span> <span class="m">20px</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">grid-gap</code> 省略了第二个值，浏览器认为第二个值等于第一个值。</p> <p>注意，根据最新标准，上面三个属性名的 <code class="language-plaintext highlighter-rouge">grid-</code> 前缀已经删除，<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 和 <code class="language-plaintext highlighter-rouge">grid-row-gap</code> 写成 column-gap 和 <code class="language-plaintext highlighter-rouge">row-gap</code>，<code class="language-plaintext highlighter-rouge">grid-gap</code> 写成 <code class="language-plaintext highlighter-rouge">gap</code>。</p> <p>（4）<code class="language-plaintext highlighter-rouge">grid-template-areas</code> 属性</p> <p>网格布局允许指定”<strong>区域</strong>“（area），一个区域由单个或多个单元格组成。<code class="language-plaintext highlighter-rouge">grid-template-areas</code> 属性用于定义区域。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-areas</span><span class="p">:</span> <span class="s2">'a b c'</span>
                       <span class="s2">'d e f'</span>
                       <span class="s2">'g h i'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码先划分出 9 个单元格，然后将其定名为 <code class="language-plaintext highlighter-rouge">a</code> 到 <code class="language-plaintext highlighter-rouge">i</code> 的九个区域，分别对应这九个单元格。</p> <p>多个单元格合并成一个区域的写法如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s2">'a a a'</span>
                     <span class="s2">'b b b'</span>
                     <span class="s2">'c c c'</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码将9个单元格分成 <code class="language-plaintext highlighter-rouge">a</code>、<code class="language-plaintext highlighter-rouge">b</code>、<code class="language-plaintext highlighter-rouge">c</code> 三个区域。</p> <p>下面是一个布局实例。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s1">"header header header"</span>
                     <span class="s1">"main main sidebar"</span>
                     <span class="s1">"footer footer footer"</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码中，顶部是页眉区域 <code class="language-plaintext highlighter-rouge">header</code>，底部是页脚区域 <code class="language-plaintext highlighter-rouge">footer</code>，中间部分则为 <code class="language-plaintext highlighter-rouge">main</code> 和 <code class="language-plaintext highlighter-rouge">sidebar</code>。</p> <p>如果某些区域不需要利用，则使用”点”（<code class="language-plaintext highlighter-rouge">.</code>）表示。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s2">'a . c'</span>
                     <span class="s2">'d . f'</span>
                     <span class="s2">'g . i'</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p> <p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名 <code class="language-plaintext highlighter-rouge">-start</code>，终止网格线自动命名为区域名 <code class="language-plaintext highlighter-rouge">-end</code>。比如，区域名为 <code class="language-plaintext highlighter-rouge">header</code>，则起始位置的水平网格线和垂直网格线叫做 <code class="language-plaintext highlighter-rouge">header-start</code>，终止位置的水平网格线和垂直网格线叫做 <code class="language-plaintext highlighter-rouge">header-end</code>。</p> <p>（5）<code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性</p> <p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032506.png" alt="子元素排列顺序"/></p> <p>这个顺序由 <code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性决定，默认值是 <code class="language-plaintext highlighter-rouge">row</code>，即”<strong>先行后列</strong>“。也可以将它设成 <code class="language-plaintext highlighter-rouge">column</code>，变成”<strong>先列后行</strong>“。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">column</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/xutokec/edit?css,output">上面代码</a>设置了 <code class="language-plaintext highlighter-rouge">column</code> 以后，放置顺序就变成了下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032512.png" alt="按照 column 方式排列"/></p> <p><code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性除了设置成 <code class="language-plaintext highlighter-rouge">row</code> 和 <code class="language-plaintext highlighter-rouge">column</code>，还可以设成 <code class="language-plaintext highlighter-rouge">row dense</code> 和 <code class="language-plaintext highlighter-rouge">column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p> <p><a href="https://jsbin.com/wapejok/edit?css,output">下面的例子</a>让 1 号项目和 2 号项目各占据两个单元格，然后在默认的 grid-auto-flow: row 情况下，会产生下面这样的布局。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032513.png" alt="grid-auto-flow: row 时，元素的排列方式"/></p> <p>上图中，1 号项目后面的位置是空的，这是因为 3 号项目默认跟着 2 号项目，所以会排在 2 号项目后面。</p> <p>现在修改设置，设为 <code class="language-plaintext highlighter-rouge">row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">row</span> <span class="nt">dense</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/helewuy/edit?css,output">上面代码</a>的效果如下。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032514.png" alt="grid-auto-flow: row dense 时，元素的排列方式"/></p> <p>上图会先填满第一行，再填满第二行，所以 3 号项目会紧跟在 1 号项目的后面。8 号项目和 9 号项目就会排到第四行。</p> <p>如果将设置改为 <code class="language-plaintext highlighter-rouge">column dense</code>，表示”先列后行”，并且尽量填满空格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">column</span> <span class="nt">dense</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/pupoduc/1/edit?html,css,output">上面代码</a>的效果如下。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032515.png" alt="grid-auto-flow: column dense 时，元素的排列方式"/></p> <p>上图会先填满第一列，再填满第 2 列，所以 3 号项目在第一列，4 号项目在第二列。8 号项目和 9 号项目被挤到了第四列。</p> <p>（6）<code class="language-plaintext highlighter-rouge">justify-items</code> 属性、<code class="language-plaintext highlighter-rouge">align-items</code> 属性、<code class="language-plaintext highlighter-rouge">place-items</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">justify-items</code> 属性设置单元格内容的<strong>水平位置</strong>（左中右），<code class="language-plaintext highlighter-rouge">align-items</code> 属性设置单元格内容的<strong>垂直位置</strong>（上中下）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">justify-items</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性的写法完全相同，都可以取下面这些值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">start</code>：对齐单元格的起始边缘。</li> <li><code class="language-plaintext highlighter-rouge">end</code>：对齐单元格的结束边缘。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：单元格内部居中。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">justify-items</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/gijeqej/edit?css,output">上面代码</a>表示，单元格的内容左对齐，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032516.png" alt="justify-items: start 的效果"/></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/tecawur/edit?css,output">上面代码</a>表示，单元格的内容头部对齐，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032517.png" alt="align-items: start 的效果"/></p> <p><code class="language-plaintext highlighter-rouge">place-items</code> 属性是 <code class="language-plaintext highlighter-rouge">align-items</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-items</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-items</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-items</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-items</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>如果省略第二个值，则浏览器认为与第一个值相等。</p> <p>（7）<code class="language-plaintext highlighter-rouge">justify-content</code> 属性、<code class="language-plaintext highlighter-rouge">align-content</code> 属性、<code class="language-plaintext highlighter-rouge">place-content</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">justify-content</code> 属性是整个内容区域在容器里面的<strong>水平位置</strong>（左中右），<code class="language-plaintext highlighter-rouge">align-content</code> 属性是整个内容区域的<strong>垂直位置</strong>（上中下）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-evenly</span><span class="p">;</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-evenly</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以 <code class="language-plaintext highlighter-rouge">justify-content</code> 属性为例，<code class="language-plaintext highlighter-rouge">align-content</code> 属性的图完全一样，只是将水平方向改成垂直方向。）</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">start</code> - 对齐容器的起始边框。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032519.png" alt="justify-content: start 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">end</code> - 对齐容器的结束边框。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032518.png" alt="justify-content: end 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">center</code> - 容器内部居中。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032520.png" alt="justify-content: center 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">stretch</code> - 项目大小没有指定时，拉伸占据整个网格容器。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032521.png" alt="justify-content: stretch 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-around</code> - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032522.png" alt="justify-content: space-around 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-between</code> - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032523.png" alt="justify-content: space-between 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-evenly</code> - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032524.png" alt="justify-content: space-evenly 的效果"/></p> </li> </ul> <p><code class="language-plaintext highlighter-rouge">place-content</code> 属性是 <code class="language-plaintext highlighter-rouge">align-content</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-content</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-content</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-content</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-content</span><span class="o">&gt;</span>
</code></pre></div></div> <p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p> <p>（8）<code class="language-plaintext highlighter-rouge">grid-auto-columns</code> 属性、<code class="language-plaintext highlighter-rouge">grid-auto-rows</code> 属性</p> <p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p> <p><code class="language-plaintext highlighter-rouge">grid-auto-columns</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-auto-rows</code> 属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与 <code class="language-plaintext highlighter-rouge">grid-template-columns</code> 和 <code class="language-plaintext highlighter-rouge">grid-template-rows</code> 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p> <p><a href="https://jsbin.com/sayuric/edit?css,output">下面的例子</a>里面，划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-auto-rows</span><span class="p">:</span> <span class="m">50px</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面代码指定新增的行高统一为 50px（原始的行高为 100px）。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032525.png" alt="grid-auto-columns 属性、grid-auto-rows 属性"/></p> <p>（9）<code class="language-plaintext highlighter-rouge">grid-template</code> 属性、<code class="language-plaintext highlighter-rouge">grid</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-template</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-template-columns</code>、<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 和 <code class="language-plaintext highlighter-rouge">grid-template-areas</code> 这三个属性的合并简写形式。</p> <p>grid 属性是 <code class="language-plaintext highlighter-rouge">grid-template-rows</code>、<code class="language-plaintext highlighter-rouge">grid-template-columns</code>、<code class="language-plaintext highlighter-rouge">grid-template-areas</code>、<code class="language-plaintext highlighter-rouge">grid-auto-rows</code>、<code class="language-plaintext highlighter-rouge">grid-auto-columns</code>、<code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 这六个属性的合并简写形式。</p> <p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p> <h4 id="343-项目属性">3.4.3 项目属性</h4> <p>（1）<code class="language-plaintext highlighter-rouge">grid-column-start</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column-end</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row-start</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row-end</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row</code> 属性</p> <p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p> <ul> <li><code class="language-plaintext highlighter-rouge">grid-column-start</code>：左边框所在的垂直网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-column-end</code>：右边框所在的垂直网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-row-start</code>：上边框所在的水平网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-row-end</code>：下边框所在的水平网格线</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/yukobuf/edit?css,output">上面代码</a>指定，1 号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032526.png" alt="grid-column-start: 2且grid-column-end: 4时的效果"/></p> <p>上图中，只指定了 1 号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p> <p>除了 1 号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的 <code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性决定，这个属性的默认值是 <code class="language-plaintext highlighter-rouge">row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成 <code class="language-plaintext highlighter-rouge">column</code>、<code class="language-plaintext highlighter-rouge">row dense</code> 和 <code class="language-plaintext highlighter-rouge">column dense</code>，看看其他项目的位置发生了怎样的变化。</p> <p><a href="https://jsbin.com/nagobey/edit?html,css,output">下面的例子</a>是指定四个边框位置的效果。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">3</span><span class="p">;</span>
  <span class="py">grid-row-start</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="py">grid-row-end</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032527.png" alt="grid-column-start: 1 且 grid-column-end: 3 且 grid-row-start: 2 且 grid-row-end: 4时的效果"/></p> <p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="n">header-start</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="n">header-end</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p> <p>这四个属性的值还可以使用 <code class="language-plaintext highlighter-rouge">span</code> 关键字，表示”<strong>跨越</strong>“，即左右边框（上下边框）之间跨越多少个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/hehumay/edit?html,css,output">上面代码</a>表示，1 号项目的左边框距离右边框跨越 2 个网格。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032528.png" alt="`grid-column-start: span 2` 时的效果"/></p> <p>这与<a href="https://jsbin.com/mujihib/edit?html,css,output">下面的代码</a>效果完全一样。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">grid-column</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-column-start</code> 和 <code class="language-plaintext highlighter-rouge">grid-column-end</code> 的合并简写形式，<code class="language-plaintext highlighter-rouge">grid-row</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-row-start</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-row-end</code> 的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">start-line</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">end-line</span><span class="err">&gt;</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">start-line</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">end-line</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>下面是一个例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等同于 */</span>
<span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">3</span><span class="p">;</span>
  <span class="py">grid-row-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-row-end</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，项目 item-1 占据第一行，从第一根列线到第三根列线。</p> <p>这两个属性之中，也可以使用 span 关键字，表示跨越多少个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#b03532</span><span class="p">;</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等同于 */</span>
<span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#b03532</span><span class="p">;</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/volugow/edit?html,css,output">上面代码</a>中，项目 <code class="language-plaintext highlighter-rouge">item-1</code> 占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032529.png" alt="grid-column: 1 / 3 且 grid-row: 1 / 3 时 item-1 占据的区域"/></p> <p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，项目 <code class="language-plaintext highlighter-rouge">item-1</code> 占据左上角第一个网格。</p> <p>（2）<code class="language-plaintext highlighter-rouge">grid-area</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-area</code> 属性指定项目放在哪一个区域。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，1 号项目位于 <code class="language-plaintext highlighter-rouge">e</code> 区域，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032530.png" alt="grid-area: e 时的效果"/></p> <p><code class="language-plaintext highlighter-rouge">grid-area</code> 属性还可用作 <code class="language-plaintext highlighter-rouge">grid-row-start</code>、<code class="language-plaintext highlighter-rouge">grid-column-start</code>、<code class="language-plaintext highlighter-rouge">grid-row-end</code>、<code class="language-plaintext highlighter-rouge">grid-column-end</code> 的合并简写形式，直接指定项目的位置。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">row-start</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">column-start</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">row-end</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">column-end</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（3）<code class="language-plaintext highlighter-rouge">justify-self</code> 属性、<code class="language-plaintext highlighter-rouge">align-self</code> 属性、<code class="language-plaintext highlighter-rouge">place-self</code> 属性</p> <ul> <li><code class="language-plaintext highlighter-rouge">justify-self</code> 属性设置单元格内容的水平位置（左中右），跟 <code class="language-plaintext highlighter-rouge">justify-items</code> 属性的用法完全一致，但只作用于单个项目。</li> <li><code class="language-plaintext highlighter-rouge">align-self</code> 属性设置单元格内容的垂直位置（上中下），跟 <code class="language-plaintext highlighter-rouge">align-items</code> 属性的用法完全一致，也是只作用于单个项目。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="py">justify-self</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性都可以取下面四个值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">start</code>：对齐单元格的起始边缘。</li> <li><code class="language-plaintext highlighter-rouge">end</code>：对齐单元格的结束边缘。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：单元格内部居中。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li> </ul> <p>下面是 <code class="language-plaintext highlighter-rouge">justify-self: start</code> 的例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span>  <span class="p">{</span>
  <span class="py">justify-self</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032532.png" alt="justify-self: start 时的效果"/></p> <p><code class="language-plaintext highlighter-rouge">place-self</code> 属性是 <code class="language-plaintext highlighter-rouge">align-self</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-self</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-self</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-self</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-self</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>如果省略第二个值，<code class="language-plaintext highlighter-rouge">place-self</code> 属性会认为这两个值相等。</p> <h3 id="35-响应式图片">3.5 响应式图片</h3> <h3 id="351-srcset-属性">3.5.1 <code class="language-plaintext highlighter-rouge">srcset</code> 属性</h3> <p><code class="language-plaintext highlighter-rouge">srcset</code> 属性用来指定多张图像，适应<strong>不同像素密度</strong>的屏幕。它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，然后是像素密度的描述符。请看下面的例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-320w.jpg,
             foo-480w.jpg 1.5x,
             foo-640w.jpg 2x"</span>
     <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-640w.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">srcset</code> 属性给出了三个图像 URL，适应三种不同的像素密度。</p> <p>浏览器会根据当前设备的像素密度，选择需要加载的图像。如果 <code class="language-plaintext highlighter-rouge">srcset</code> 属性都不满足条件，那么就加载 <code class="language-plaintext highlighter-rouge">src</code> 属性指定的默认图像。</p> <h3 id="352-srcset-属性sizes-属性">3.5.2 <code class="language-plaintext highlighter-rouge">srcset</code> 属性、<code class="language-plaintext highlighter-rouge">sizes</code> 属性</h3> <p><code class="language-plaintext highlighter-rouge">sizes</code> 属性与 <code class="language-plaintext highlighter-rouge">srcset</code> 属性配合使用，可以实现根据不同的设备宽度应用不同尺寸的图像。其实现步骤如下。</p> <ol> <li><code class="language-plaintext highlighter-rouge">srcset</code> 属性列出所有可用的图像。</li> </ol> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-160.jpg 160w,
              foo-320.jpg 320w,
              foo-640.jpg 640w,
              foo-1280.jpg 1280w"</span>
      <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-1280.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">srcset</code> 属性列出四张可用的图像，每张图像的 URL 后面是一个空格，再加上宽度描述符。<strong>宽度描述符就是图像原始的宽度，加上字符 <code class="language-plaintext highlighter-rouge">w</code></strong>。上例的四种图片的原始宽度分别为 160px、320px、640px 和 1280px。</p> <ol> <li><code class="language-plaintext highlighter-rouge">sizes</code> 属性列出不同设备的图像显示宽度。</li> </ol> <p><code class="language-plaintext highlighter-rouge">sizes</code> 属性的值是一个逗号分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图像的显示宽度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">sizes</span><span class="o">=</span><span class="s1">"(max-width: 440px) 100vw,
              (max-width: 900px) 33vw,
              254px"</span>
      <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-160.jpg 160w,
              foo-320.jpg 320w,
              foo-640.jpg 640w,
              foo-1280.jpg 1280w"</span>
      <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-1280.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">sizes</code> 属性给出了三种屏幕条件，以及对应的图像显示宽度。宽度不超过 440px 的设备，图像显示宽度为 100%；宽度 441px 到 900px 的设备，图像显示宽度为 33%；宽度 900px 以上的设备，图像显示宽度为 254px。</p> <ol> <li>浏览器根据当前设备的宽度，从 <code class="language-plaintext highlighter-rouge">sizes</code> 属性获得图像的显示宽度，然后从 <code class="language-plaintext highlighter-rouge">srcset</code> 属性找出最接近该宽度的图像，进行加载。</li> </ol> <p>假定当前设备的屏幕宽度是 480px，浏览器从 <code class="language-plaintext highlighter-rouge">sizes</code> 属性查询得到，图片的显示宽度是 33vw（即 33%），等于 160px。<code class="language-plaintext highlighter-rouge">srcset</code> 属性里面，正好有宽度等于 160px 的图片，于是加载 <code class="language-plaintext highlighter-rouge">foo-160.jpg</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">sizes</code> 属性必须与 <code class="language-plaintext highlighter-rouge">srcset</code> 属性搭配使用。单独使用 <code class="language-plaintext highlighter-rouge">sizes</code> 属性是无效的。</p> <h3 id="353-picture-标签source-标签">3.5.3 <code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签、<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签</h3> <p>使用 <code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签和 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签，可以实现对不同尺寸及不同像素密度屏幕的适配。<picture> 标签是一个容器标签，内部使用 <source/> 和 <img/>，指定不同情况下加载的图像。</picture></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">media</span><span class="o">=</span><span class="s1">"(max-width: 500px)"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"cat-vertical.jpg"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 501px)"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"cat-horizontal.jpg"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">src</span><span class="o">=</span><span class="s1">"cat.jpg"</span> <span class="nt">alt</span><span class="o">=</span><span class="s1">"cat"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签内部有两个 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签和一个 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签。</p> <p><code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性给出媒体查询表达式，<code class="language-plaintext highlighter-rouge">srcset</code> 属性就是 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">srcset</code> 属性，给出加载的图像文件。<code class="language-plaintext highlighter-rouge">sizes</code> 属性其实这里也可以用，但由于有了 <code class="language-plaintext highlighter-rouge">media</code> 属性，就没有必要了。浏览器<strong>按照</strong> <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> <strong>标签出现的顺序</strong>，依次判断当前设备是否满足 <code class="language-plaintext highlighter-rouge">media</code> 属性的媒体查询表达式，如果满足就加载 <code class="language-plaintext highlighter-rouge">srcset</code> 属性指定的图片文件，并且不再执行后面的 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签和 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签。</p> <p><code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签是默认情况下加载的图像，用来满足上面所有 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 都不匹配的情况。</p> <p>上面例子中，设备宽度如果不超过 500px，就加载竖屏的图像，否则加载横屏的图像。</p> <p>下面给出一个例子，同时考虑屏幕尺寸和像素密度的适配。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@desktop.png,
                  homepage-person@desktop-2x.png 2x"</span>       
          <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 990px)"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@tablet.png,
                  homepage-person@tablet-2x.png 2x"</span> 
          <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 750px)"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@mobile.png,
               homepage-person@mobile-2x.png 2x"</span> 
       <span class="nt">alt</span><span class="o">=</span><span class="s1">"Shopify Merchant, Corrine Anestopoulos"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性给出屏幕尺寸的适配条件，每个条件都用 <code class="language-plaintext highlighter-rouge">srcset</code> 属性，再给出两种像素密度的图像 URL。</p> <h3 id="354-source-标签的-type-属性">3.5.4 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性</h3> <p>除了响应式图像，<code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签还可以用来选择不同格式的图像。比如，如果当前浏览器支持 Webp 格式，就加载这种格式的图像，否则加载 PNG 图像。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">type</span><span class="o">=</span><span class="s1">"image/svg+xml"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"logo.xml"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">type</span><span class="o">=</span><span class="s1">"image/webp"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"logo.webp"</span><span class="o">&gt;</span> 
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">src</span><span class="o">=</span><span class="s1">"logo.png"</span> <span class="nt">alt</span><span class="o">=</span><span class="s1">"ACME Corp"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性给出图像的 MIME 类型，<code class="language-plaintext highlighter-rouge">srcset</code> 是对应的图像 URL。</p> <p>浏览器按照 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签出现的顺序，依次检查是否支持 <code class="language-plaintext highlighter-rouge">type</code> 属性指定的图像格式，如果支持就加载图像，并且不再检查后面的 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签了。上面例子中，图像加载优先顺序依次为 svg 格式、webp 格式和 png 格式。</p> <h2 id="四h5-与响应式-web-设计">四、H5 与响应式 Web 设计</h2> <h3 id="41-h5-页面结构新特性">4.1 H5 页面结构新特性</h3> <p>（1）<code class="language-plaintext highlighter-rouge">doctype</code>：用于告诉浏览器文档类型。相比于 H4 的写法，新写法简化了很多。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">lang 属性</code>：用于指定文档使用的语言。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
</code></pre></div></div> <p>（3）<code class="language-plaintext highlighter-rouge">charset</code>：<code class="language-plaintext highlighter-rouge">charset</code> 属性用于指定字符编码。除非有特殊需要，否则 <code class="language-plaintext highlighter-rouge">charset</code> 的属性值一般都是 <code class="language-plaintext highlighter-rouge">utf-8</code>。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
</code></pre></div></div> <h3 id="42-h5-结构化元素">4.2 H5 结构化元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;main&gt;</code>：用于表示页面的主内容区。通常，每个页面的主内容区只能有一个，而且不能作为 <code class="language-plaintext highlighter-rouge">article</code>、<code class="language-plaintext highlighter-rouge">aside</code>、<code class="language-plaintext highlighter-rouge">header</code>、<code class="language-plaintext highlighter-rouge">footer</code>、<code class="language-plaintext highlighter-rouge">nav</code> 或 <code class="language-plaintext highlighter-rouge">header</code> 等其他 H5 语义元素的后代。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;section&gt;</code>：用于定义文档或应用中一个通用的区块。比如，某块内容包含自然标题（h1 ~ h6），就可以使用 <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> 标签作为容器。</p> <p>（3）<code class="language-plaintext highlighter-rouge">&lt;nav&gt;</code>：用于包装主导航链接。</p> <p>（4）<code class="language-plaintext highlighter-rouge">&lt;article&gt;</code>：用于包含一个独立的内容块。比如，有博客正文和新闻报道就可以放在 <code class="language-plaintext highlighter-rouge">&lt;article&gt;</code> 中。</p> <p>（5）<code class="language-plaintext highlighter-rouge">&lt;aside&gt;</code>：用于包含与其旁边内容不相关的内容。常用于侧边栏、突出引用、广告和导航元素。</p> <p>（6）<code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;figcaption&gt;</code>：<code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 常用于包含注解、图示、照片和代码等。<code class="language-plaintext highlighter-rouge">&lt;figcaption&gt;</code> 可作为 <code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 的嵌套元素使用。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;figure</span> <span class="na">class=</span><span class="s">"MoneyShot"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;img</span> <span class="na">class=</span><span class="s">"MoneyShotImg"</span> <span class="na">src=</span><span class="s">"img/scones.jpg"</span> <span class="na">alt=</span><span class="s">"Incredible scones"</span> <span class="nt">/&gt;</span> 
  <span class="nt">&lt;figcaption</span> <span class="na">class=</span><span class="s">"ImageCaption"</span><span class="nt">&gt;</span>
    Incredible scones, picture from Wikipedia
  <span class="nt">&lt;/figcaption&gt;</span> 
<span class="nt">&lt;/figure&gt;</span> 
</code></pre></div></div> <p>（7）<code class="language-plaintext highlighter-rouge">&lt;detail&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;summary&gt;</code>：这两个元素经常成对出现，比如，我们经常使用的“展开/收起”部件，就可以用它们来实现。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;details&gt;</span> 
  <span class="nt">&lt;summary&gt;</span>I ate 15 scones in one day<span class="nt">&lt;/summary&gt;</span> 
  <span class="nt">&lt;p&gt;</span>Of course I didn't. It would probably kill me if I did. What a way to go. Mmmmmm, scones!<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/details&gt;</span>
</code></pre></div></div> <p>在不添加任何样式的请款下，上面代码的（展开）效果如下。</p> <p><img src="/assets/images/css/detail-and-summary.png" alt="details and summary tag"/></p> <p>（8）<code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>：常用在站点页头作为“报头”。它可以在一个页面中出现多次（比如，页面中每个 <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> 中都可以有一个 <code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>）。</p> <p>（9）<code class="language-plaintext highlighter-rouge">&lt;footer&gt;</code>：常用于在相应区块中包含与区块相关的内容，可以包含指向其他文档的链接，或者版权声明。<code class="language-plaintext highlighter-rouge">&lt;footer&gt;</code> 同样可以在页面中出现多次。</p> <p>（10）<code class="language-plaintext highlighter-rouge">&lt;address&gt;</code>：用于标记联系人信息，比如地址信息。</p> <p>（11）<code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code> ~ <code class="language-plaintext highlighter-rouge">&lt;h6&gt;</code>：h1 到 h6 元素不能用于标记副标题、字幕、广告语，除非想把它们用作新区块或子区块的标题。</p> <h3 id="43-h5-文本级元素">4.3 H5 文本级元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;b&gt;</code>：表示只为引人注意而标记的文本，不传达更多的重要性信息，也不用于表达其他的愿望或情绪。比如，不用于文章摘要中的关键词、评测当中的产品名、交互式文本程序中的可执行命令，等等。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code>：表示内容中需要强调的部分。</p> <p>（3）<code class="language-plaintext highlighter-rouge">&lt;i&gt;</code>：表示一段文本，用于表示另一种愿望或情绪，或者以突出不同文本形式的方式表达偏离正文的意思。</p> <h3 id="44-新的媒体元素">4.4 新的媒体元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;video&gt;</code>：用于在页面中嵌入视频，<code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> 标签必须成对使用。如果浏览器不支持此标签，可以在其中潜入一段文字，用于提示。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">src=</span><span class="s">"myVideo.mp4"</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span><span class="nt">&gt;</span>
  What, do you mean you don't understand HTML5?
<span class="nt">&lt;/video&gt;</span> 
</code></pre></div></div> <p>对于某些旧版本浏览器，可以使用 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签以提供后备资源。比如，除了提供 MP4 版本的视频，如果想某些低版本浏览器也能看到视频，可以添加一个 Flash源 作为后备。或者，如果用户浏览器没有任何播放条件，还可以提供一个下载视频的链接。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span> <span class="na">controls</span> <span class="na">preload=</span><span class="s">"auto"</span> <span class="na">loop</span> <span class="na">poster=</span><span class="s">"myVideoPoster.png"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">"video/myVideo.mp4"</span> <span class="na">type=</span><span class="s">"video/mp4"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;object</span>
    <span class="na">width=</span><span class="s">"640"</span>
    <span class="na">height=</span><span class="s">"480"</span>
    <span class="na">type=</span><span class="s">"application/x-shockwaveflash"</span>
    <span class="na">data=</span><span class="s">"myFlashVideo.SWF"</span>
  <span class="nt">&gt;</span>
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"movie"</span> <span class="na">value=</span><span class="s">"myFlashVideo.swf"</span> <span class="nt">/&gt;</span> 
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"flashvars"</span> <span class="na">value=</span><span class="s">"controlbar=over&amp;amp;image=myVideoPoster.jpg&amp;amp;file=myVideo.mp4"</span> <span class="nt">/&gt;</span> 
    <span class="nt">&lt;img</span>
      <span class="na">src=</span><span class="s">"myVideoPoster.png"</span>
      <span class="na">width=</span><span class="s">"640"</span>
      <span class="na">height=</span><span class="s">"480"</span>
      <span class="na">alt=</span><span class="s">"__ TITLE__"</span>
      <span class="na">title=</span><span class="s">"No video playback capabilities, please download the video below"</span>
    <span class="nt">/&gt;</span> 
  <span class="nt">&lt;/object&gt;</span> 
  <span class="nt">&lt;p&gt;</span>
    <span class="nt">&lt;b&gt;</span>Download Video:<span class="nt">&lt;/b&gt;</span> MP4 Format: <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"myVideo.mp4"</span><span class="nt">&gt;</span>"MP4"<span class="nt">&lt;/a&gt;</span> 
  <span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/video&gt;</span>
</code></pre></div></div> <p>通常，很难对不同的视频播放画面做响应式设计，多数情况下，影片的播放比例并不相同。<a href="http://embedresponsively.com/">这里</a> 有一个网站，你可以把视频的 url 地址粘贴进去，就会得到一段响应式代码，从而使得在网页缩放时，视频依然会保持应有的比例。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;audio&gt;</code>：<code class="language-plaintext highlighter-rouge">&lt;audio&gt;</code> 用于在页面中嵌入音频，其用法与 <code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> 类似。</p> <h3 id="45-其他特性">4.5 其他特性</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 标签中可以放多个元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"index.html"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;h2&gt;</span>The home page<span class="nt">&lt;/h2&gt;</span> 
  <span class="nt">&lt;p&gt;</span>This paragraph also links to the home page<span class="nt">&lt;/p&gt;</span> 
  <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"home-image.png"</span> <span class="na">alt=</span><span class="s">"home-slice"</span> <span class="nt">/&gt;</span> 
<span class="nt">&lt;/a&gt;</span> 
</code></pre></div></div> <p>（2）WCAG 和 WAI-ARIA</p> <p>WCAG 和 WAI-ARIA 提供了与无障碍交互相关的标准。</p> <h2 id="五css3-新特性">五、CSS3 新特性</h2> <p>这部分并不会讨论 CSS3 中所有的新特性，而只是讨论跟响应式设计有关的新特性。</p> <h3 id="51-css-响应式多列布局">5.1 CSS 响应式多列布局</h3> <p>以下示例，以下面的代码布局为例进行讲解。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;main&gt;</span> 
  <span class="nt">&lt;p&gt;</span>lloremipsimLoremipsum dolor sit amet, consectetur ... <span class="nt">&lt;/p&gt;</span> 
  <span class="nt">&lt;p&gt;</span>lloremipsimLoremipsum dolor sit amet, consectetur ... <span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/main&gt;</span>
</code></pre></div></div> <p>（1）使用 CSS 多列布局可以通过几种方式让文本分成多列显示。比如，可以给每列设定固定的列宽。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-width</span><span class="p">:</span> <span class="m">12em</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码表示，设置没列的宽度为 12em，改变视口宽度时，列宽不变，列数动态改变。</p> <p>（2）固定列数，可变宽度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-count</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码表示，当页面缩放时，列数固定，宽度可变。</p> <p>（3）添加列间距和分隔线。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-gap</span><span class="p">:</span> <span class="m">2em</span><span class="p">;</span> 
  <span class="nl">column-rule</span><span class="p">:</span> <span class="nb">thin</span> <span class="nb">dotted</span> <span class="m">#999</span><span class="p">;</span> 
  <span class="nl">column-width</span><span class="p">:</span> <span class="m">12em</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码，用于给列间添加间距和分隔线。</p> <h3 id="52-断字">5.2 断字</h3> <p>（1）容器中的文字默认一行显示，如果文字太长，超出了容器的长度，就会显示在容器外面。可以使用下面的方式，对文字进行<strong>换行</strong>处理。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">word-wrap</span><span class="o">:</span> <span class="nt">break-word</span><span class="o">;</span>
</code></pre></div></div> <p>（2）可以对文字<strong>截短</strong>处理，并且使得超出容器宽度的部分，显示为 <code class="language-plaintext highlighter-rouge">...</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">p</span> <span class="p">{</span> 
 <span class="nl">width</span><span class="p">:</span> <span class="m">520px</span><span class="p">;</span> 
 <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span> 
 <span class="nl">text-overflow</span><span class="p">:</span> <span class="n">ellipsis</span><span class="p">;</span> 
 <span class="nl">white-space</span><span class="p">:</span> <span class="n">no-wrap</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>最后的 <code class="language-plaintext highlighter-rouge">white-space: nowrap</code> 声明是为了确保长出来的文本不会折行显示在外部元素中。</p> <h3 id="53-在-css-中创建分支">5.3 在 CSS 中创建分支</h3> <p>在响应式设计，经常会碰到某些设备不支持什么特性或技术的情况。此时，往往需要在 CSS 中创建一个分支。如果浏览器支持某特性，就应用一段代码；如果不支持，则应用另一段代码。这点类似于 JavaScript 中 <code class="language-plaintext highlighter-rouge">if...else</code> 语句。</p> <p>在 CSS 中创建分支有两种手段。一是完全基于 CSS，但支持的浏览器却不多； 二是借助 JavaScript 库，获得广泛兼容性。</p> <p>（1）特性查询</p> <p>CSS 原生的分支语法就是特性查询，比如下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">(</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span>

<span class="k">@supports</span> <span class="n">not</span> <span class="p">(</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-block</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码表示，如果浏览器支持 <code class="language-plaintext highlighter-rouge">display: flex</code>，就对 <code class="language-plaintext highlighter-rouge">.item</code> 选择器设置一种样式；否则，则设置为另一种样式。</p> <p>（2）组合条件</p> <p>假设我们只想在浏览器支持 flexbox 和 <code class="language-plaintext highlighter-rouge">pointer: coarse</code> 时应用某些规则，可以使用下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">((</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nb">pointer</span><span class="p">:</span> <span class="n">coarse</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">and</code> 关键字，其他支持的关键字还有 <code class="language-plaintext highlighter-rouge">or</code>。比如，除了前面两个条件满足之外，如果浏览器支持 3D 变形也想应用样式，那么可以使用下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">((</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nb">pointer</span><span class="p">:</span> <span class="n">coarse</span><span class="p">))</span> <span class="n">or</span> <span class="p">(</span><span class="n">transform</span><span class="p">:</span> <span class="n">translate3d</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>注意，某些低版本及 IE 浏览器，并不支持 <code class="language-plaintext highlighter-rouge">@support</code> 关键字。</p> <p>（3）在 <code class="language-plaintext highlighter-rouge">@supports</code> 得到广泛支持以前，还可以使用 Modernizr 这个 JavaScript 工具在 CSS 中实现分支。</p> <h3 id="54-新的-css3-选择器">5.4 新的 CSS3 选择器</h3> <p>（1）属性选择器，用于对某些元素的属性进行选择。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">border</span><span class="p">:</span> <span class="m">3px</span> <span class="nb">dashed</span> <span class="m">#e15f5f</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，表示选中任何包含 <code class="language-plaintext highlighter-rouge">alt</code> 属性的 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 元素。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">=</span><span class="s1">"sausages"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="c">/* 样式 */</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码，只会选择 <code class="language-plaintext highlighter-rouge">alt</code> 属性值为 <code class="language-plaintext highlighter-rouge">sausages</code> 的 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>元素。即同时指定了属性的值，进一步缩小了搜索范围。</p> <p>CSS3 支持依据属性选择器包含的子字符串来选择元素。这时分为三种情况：</p> <ul> <li>以 xxx 开头。</li> <li>包含 xxx。</li> <li>以 xxx 结尾。</li> </ul> <p>（2）选中属性值以某字符串开头的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"img/ace-film.jpg"</span> <span class="na">alt=</span><span class="s">"film-ace"</span><span class="nt">&gt;</span> 
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"img/rubbish-film.jpg"</span> <span class="na">alt=</span><span class="s">"film-rubbish"</span><span class="nt">&gt;</span> 
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">^=</span><span class="s1">"film"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="c">/* 样式 */</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">^</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">alt</code> 属性值中以 <code class="language-plaintext highlighter-rouge">film</code> 字符串开头的情况。即此时会选中 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 表情中，<code class="language-plaintext highlighter-rouge">alt</code> 属性以 <code class="language-plaintext highlighter-rouge">film</code> 开头的元素（在这里会同时选中上边的两个 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签）。</p> <p>（2）选中属性值包含某字符串的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"scones cream jam"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">data-ingredients</span><span class="o">*=</span><span class="s1">"cream"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的属性选择器，使用 <code class="language-plaintext highlighter-rouge">*</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">data-ingredients</code> 属性值中包含 <code class="language-plaintext highlighter-rouge">cream</code> 字符串的情况。此时 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 标签会被选中。</p> <p>（3）选中属性值以某字符串结尾的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"scones cream jam"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"toast jam butter"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"jam toast butter"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">data-ingredients</span><span class="err">$</span><span class="o">=</span><span class="s1">"jam"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的属性选择器，使用 <code class="language-plaintext highlighter-rouge">$</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">data-ingredients</code> 属性值中以 <code class="language-plaintext highlighter-rouge">jam</code> 字符串结尾的情况。此时，第一个 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 标签会被选中。</p> <h3 id="55-伪类选择器">5.5 伪类选择器</h3> <ul> <li><code class="language-plaintext highlighter-rouge">:last-child</code>：用于选择某个父元素中的最后一个子元素。</li> <li><code class="language-plaintext highlighter-rouge">:nth-child(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-last-child(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-of-type(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-last-of-type(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:not</code>：</li> <li><code class="language-plaintext highlighter-rouge">:empty</code>：</li> <li><code class="language-plaintext highlighter-rouge">:first-line</code>：</li> <li><code class="language-plaintext highlighter-rouge">:has</code>：</li> </ul> <h3 id="56-calc-函数">5.6 <code class="language-plaintext highlighter-rouge">calc()</code> 函数</h3> <h3 id="57-css3-的新颜色格式及透明度">5.7 CSS3 的新颜色格式及透明度</h3> <p>（1）可以使用 <code class="language-plaintext highlighter-rouge">rgb()</code> 或 <code class="language-plaintext highlighter-rouge">rgba()</code> 函数定义颜色，前者接收三个参数（取值为 0 ~ 255），分别表示红、绿、蓝三原色分量的值，后者除了这三个参数，还可以接受一个 alpha 透明度数值，取值为 0 ~ 1。</p> <p>（2）CSS3 还支持HSL（Hue Saturation Lightness，色相、饱和度、亮度）颜色系统。</p> <h2 id="六css3-高级技术">六、CSS3 高级技术</h2> <h2 id="七svg-与响应式-web-设计">七、SVG 与响应式 Web 设计</h2> <h2 id="八css3-过渡变形和动画">八、CSS3 过渡、变形和动画</h2> <h2 id="九表单">九、表单</h2> <h2 id="十参考">十、参考</h2> <ul> <li><a href="https://benfrain.com/">Ben Frain</a>，《响应式 Web 设计：HTML5和CSS实战》</li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a></li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程</a></li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2019/06/responsive-images.html">响应式图像教程</a></li> </ul>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="media queries"/><category term="responsive web design"/><category term="responsive images"/><category term="flex box layout"/><category term="grid layout"/><summary type="html"><![CDATA[一、简介]]></summary></entry><entry><title type="html">CSS Modules 用法教程</title><link href="https://feng-zhang0712.github.io//blog/2024/css-modules/" rel="alternate" type="text/html" title="CSS Modules 用法教程"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/css-modules</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/css-modules/"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2016/06/css_modules.html">CSS Modules 用法教程</a></p>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="css modules"/><summary type="html"><![CDATA[CSS Modules 用法教程]]></summary></entry><entry><title type="html">CSS 预处理器</title><link href="https://feng-zhang0712.github.io//blog/2024/css-preprocessor/" rel="alternate" type="text/html" title="CSS 预处理器"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/css-preprocessor</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/css-preprocessor/"><![CDATA[<h2 id="一概念">一、概念</h2> <p>CSS 预处理器是一种脚本语言，扩展了原生 CSS 的功能。通过预处理器，可以使用更高级的语法和特性来编写样式代码。预处理器文件（如 .sass）在编译过程中会被转换成标准的 CSS 文件。</p> <h2 id="二常见的-css-预处理器">二、常见的 CSS 预处理器</h2> <p>Sass：提供了两种语法，Sass（缩进语法）和 SCSS（类似 CSS 的语法）。Sass 是目前最流行的预处理器之一。 LESS：另一个流行的预处理器，语法上与 CSS 更接近，容易上手。</p> <h2 id="三预处理器的用途和优点">三、预处理器的用途和优点</h2> <h3 id="31-变量">3.1 变量</h3> <p>预处理器支持变量，可以用来存储重复使用的值（如颜色）等。</p> <h3 id="32-嵌套">3.2 嵌套</h3> <p>预处理器允许嵌套 CSS，可以更清晰地表示层次结构。</p> <h3 id="33-混合宏mixin">3.3. 混合宏（Mixin）</h3> <p>混合宏允许定义一组可重用的样式规则，类似于函数。可以通过传递参数自定义样式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@mixin</span> <span class="n">border-radius</span><span class="p">(</span><span class="err">$</span><span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">-webkit-border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
     <span class="nl">-moz-border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
          <span class="nl">border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button</span> <span class="p">{</span>
  <span class="err">@include</span> <span class="err">border-radius(10px);</span>
<span class="p">}</span>

</code></pre></div></div> <h3 id="34-继承">3.4 继承</h3> <p>预处理器支持继承样式，一个选择器可以继承另一个选择器的样式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="nt">button-styles</span> <span class="p">{</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">10px</span> <span class="m">20px</span><span class="p">;</span>
  <span class="nl">border</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
  <span class="nl">cursor</span><span class="p">:</span> <span class="nb">pointer</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button</span> <span class="p">{</span>
  <span class="err">@extend</span> <span class="err">%button-styles;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="m">#3498db</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button-secondary</span> <span class="p">{</span>
  <span class="err">@extend</span> <span class="err">%button-styles;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="m">#2ecc71</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="35-函数">3.5 函数</h3> <p>预处理器允许定义函数，进行复杂的计算和逻辑操作，然后返回值，供样式规则使用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@function</span> <span class="n">calculate-margin</span><span class="p">(</span><span class="err">$</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">@return</span> <span class="err">$</span><span class="n">value</span> <span class="err">*</span> <span class="m">1.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="n">calculate-margin</span><span class="p">(</span><span class="m">10px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="36-导入和拆分文件">3.6 导入和拆分文件</h3> <p>预处理器支持将样式拆分成多个文件，并使用 @import 语句导入。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* _variables.scss */</span>
<span class="err">$</span><span class="nt">primary-color</span><span class="o">:</span> <span class="err">#3498</span><span class="nt">db</span><span class="o">;</span>
<span class="err">$</span><span class="nt">secondary-color</span><span class="o">:</span> <span class="err">#2</span><span class="nt">ecc71</span><span class="o">;</span>

<span class="c">/* _mixins.scss */</span>
<span class="k">@mixin</span> <span class="n">flex-center</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* styles.scss */</span>
<span class="k">@import</span> <span class="s2">'variables'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s2">'mixins'</span><span class="p">;</span>
<span class="nc">.header</span> <span class="p">{</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="err">$</span><span class="n">primary-color</span><span class="p">;</span>
  <span class="err">@include</span> <span class="err">flex-center;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100vh</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="37-条件语句和循环">3.7 条件语句和循环</h3> <p>预处理器支持条件语句和循环。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="nt">themes</span><span class="o">:</span> <span class="o">(</span><span class="s2">'light'</span><span class="o">,</span> <span class="s2">'dark'</span><span class="o">);</span>
<span class="k">@each</span> <span class="err">$</span><span class="n">theme</span> <span class="n">in</span> <span class="err">$</span><span class="n">themes</span> <span class="p">{</span>
  <span class="nc">.theme-</span><span class="err">#</span><span class="p">{</span><span class="err">$theme</span><span class="p">}</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="n">if</span><span class="p">(</span><span class="err">$</span><span class="n">theme</span> <span class="err">==</span> <span class="s2">'light'</span><span class="p">,</span> <span class="m">#fff</span><span class="p">,</span> <span class="m">#333</span><span class="p">);</span>
    <span class="nl">color</span><span class="p">:</span> <span class="n">if</span><span class="p">(</span><span class="err">$</span><span class="n">theme</span> <span class="err">==</span> <span class="s2">'light'</span><span class="p">,</span> <span class="m">#333</span><span class="p">,</span> <span class="m">#fff</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="sass"/><summary type="html"><![CDATA[一、概念]]></summary></entry><entry><title type="html">React 中的事件</title><link href="https://feng-zhang0712.github.io//blog/2024/events-in-react/" rel="alternate" type="text/html" title="React 中的事件"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/events-in-react</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/events-in-react/"><![CDATA[<p>React 的事件代理机制（Event Delegation）是其性能优化的一种手段。通过事件代理，React 将所有的事件监听器统一绑定到根元素，而不是每个具体的 DOM 元素上。这种方法减少了实际绑定到 DOM 元素上的事件处理器数量，从而提升了性能，特别是在有大量动态生成的元素时。</p> <h3 id="事件代理的工作原理">事件代理的工作原理</h3> <ol> <li><strong>统一绑定事件处理器</strong>：React 会在组件挂载时，将所有事件处理器统一绑定到应用的根元素（例如 <code class="language-plaintext highlighter-rouge">document</code> 或 <code class="language-plaintext highlighter-rouge">root</code> DOM 节点）。</li> <li><strong>事件捕获和冒泡</strong>：当用户在具体的 DOM 元素上触发事件时，事件会按照捕获和冒泡的机制传播。React 利用这个机制，在事件冒泡到根元素时捕获事件。</li> <li><strong>事件分发</strong>：在根元素上捕获到事件后，React 解析事件的目标元素，并根据目标元素和事件类型，找到对应的 React 组件实例和事件处理器，然后调用该处理器。</li> </ol> <h3 id="优点">优点</h3> <ul> <li><strong>性能优化</strong>：减少了实际绑定在 DOM 元素上的事件处理器数量，降低了内存消耗和性能开销。</li> <li><strong>简化事件管理</strong>：通过统一的事件处理机制，简化了事件添加和移除的管理。</li> </ul> <h3 id="示例">示例</h3> <p>以下是一个简单的示例，展示了事件代理的基本概念：</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">ButtonList</span> <span class="kd">extends</span> <span class="nc">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 获取被点击的按钮元素</span>
    <span class="kd">const</span> <span class="nx">button</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Button </span><span class="p">${</span><span class="nx">button</span><span class="p">.</span><span class="nx">textContent</span><span class="p">}</span><span class="s2"> clicked!`</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 1<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 2<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 3<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">ButtonList</span><span class="p">;</span>
</code></pre></div></div> <p>在这个示例中，三个按钮的点击事件都通过 <code class="language-plaintext highlighter-rouge">div</code> 容器上的 <code class="language-plaintext highlighter-rouge">onClick</code> 处理器进行处理。点击任意按钮时，事件会冒泡到 <code class="language-plaintext highlighter-rouge">div</code> 容器，被捕获并处理。</p> <h3 id="深入理解">深入理解</h3> <ul> <li><strong>合成事件</strong>：React 使用合成事件（Synthetic Events）对象来封装浏览器的原生事件对象。合成事件对象提供了与原生事件对象相同的接口，但具备跨浏览器的兼容性。</li> <li><strong>事件池</strong>：React 维护一个事件池，用于存储和复用合成事件对象。事件处理器执行后，合成事件对象会被复用以提高性能。因此，在事件处理器中，不能异步访问合成事件对象；如果需要异步访问，可以调用 <code class="language-plaintext highlighter-rouge">event.persist()</code> 方法防止对象被复用。</li> </ul> <h3 id="注意事项">注意事项</h3> <ul> <li><strong>异步访问事件对象</strong>：在异步函数中访问合成事件对象时，需要调用 <code class="language-plaintext highlighter-rouge">event.persist()</code> 方法。例如：</li> </ul> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nf">persist</span><span class="p">();</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span> <span class="c1">// 异步访问事件对象</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li><strong>非冒泡事件</strong>：某些事件不会冒泡，例如 <code class="language-plaintext highlighter-rouge">onBlur</code> 和 <code class="language-plaintext highlighter-rouge">onFocus</code>。React 通过特殊处理，将这些事件也通过事件代理机制进行处理。</li> </ul> <h3 id="总结">总结</h3> <p>React 的事件代理机制通过在根元素上统一绑定事件处理器，有效地减少了实际绑定在 DOM 元素上的事件处理器数量，提升了性能，并简化了事件管理。这是 React 提升性能和简化事件管理的一种重要手段。</p>]]></content><author><name></name></author><category term="frontend"/><category term="react"/><category term="events"/><summary type="html"><![CDATA[React 的事件代理机制（Event Delegation）是其性能优化的一种手段。通过事件代理，React 将所有的事件监听器统一绑定到根元素，而不是每个具体的 DOM 元素上。这种方法减少了实际绑定到 DOM 元素上的事件处理器数量，从而提升了性能，特别是在有大量动态生成的元素时。]]></summary></entry><entry><title type="html">ES6 - Array</title><link href="https://feng-zhang0712.github.io//blog/2024/array/" rel="alternate" type="text/html" title="ES6 - Array"/><published>2024-09-12T00:00:00+00:00</published><updated>2024-09-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/array</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/array/"><![CDATA[]]></content><author><name></name></author><category term="frontend"/><category term="React"/><category term="es6"/><summary type="html"><![CDATA[]]></summary></entry></feed>