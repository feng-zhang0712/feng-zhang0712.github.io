<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-09T12:23:47+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/features/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/features</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/features/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/features/">《JavaScript 教程 - 语法专题》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一数据类型的转换">一、数据类型的转换</h2> <h3 id="1-强制转换">1. 强制转换</h3> <p>强制转换主要指使用 <code class="language-plaintext highlighter-rouge">Boolean()</code>、<code class="language-plaintext highlighter-rouge">Number()</code> 和 <code class="language-plaintext highlighter-rouge">String()</code> 三个函数，手动转换成布尔值、数字或者字符串。</p> <h4 id="11-boolean">1.1 Boolean()</h4> <p><code class="language-plaintext highlighter-rouge">Boolean()</code> 函数将任意类型的值转为布尔值。除了以下五个值的转换结果为 <code class="language-plaintext highlighter-rouge">false</code>，其他的值全部为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">undefined</code></li> <li><code class="language-plaintext highlighter-rouge">null</code></li> <li><code class="language-plaintext highlighter-rouge">0</code>（包含 <code class="language-plaintext highlighter-rouge">-0</code> 和 <code class="language-plaintext highlighter-rouge">+0</code>）</li> <li><code class="language-plaintext highlighter-rouge">NaN</code></li> <li><code class="language-plaintext highlighter-rouge">''</code>（空字符串）</li> </ul> <p>所有对象的布尔值都是 <code class="language-plaintext highlighter-rouge">true</code>，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于 <code class="language-plaintext highlighter-rouge">obj1</code> &amp;&amp; <code class="language-plaintext highlighter-rouge">obj2</code> 这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Boolean</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="12-number">1.2 Number()</h4> <p><code class="language-plaintext highlighter-rouge">Number()</code> 函数将任意类型的值转化成数值。</p> <h5 id="1原始类型值">（1）原始类型值</h5> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数值：转换后还是原来的值</span>
<span class="nc">Number</span><span class="p">(</span><span class="mi">324</span><span class="p">)</span> <span class="c1">// 324</span>

<span class="c1">// 字符串：如果可以被解析为数值，则转换为相应的数值</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">324</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 324</span>

<span class="c1">// 字符串：如果不可以被解析为数值，返回 NaN</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">324abc</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// NaN</span>

<span class="c1">// 空字符串转为0</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">''</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="c1">// 布尔值：true 转成 1，false 转成 0</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="c1">// undefined：转成 NaN</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// NaN</span>

<span class="c1">// null：转成 0</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 0</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Number()</code> 函数将字符串转为数值，要比 <code class="language-plaintext highlighter-rouge">parseInt()</code> 函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为 <code class="language-plaintext highlighter-rouge">NaN</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 42</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// NaN</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">parseInt()</code> 逐个解析字符，而 <code class="language-plaintext highlighter-rouge">Number()</code> 函数整体转换字符串的类型。</p> <p><code class="language-plaintext highlighter-rouge">parseInt()</code> 和 <code class="language-plaintext highlighter-rouge">Number()</code> 函数都会自动过滤一个字符串前导和后缀的空格。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="se">\t\</span><span class="s1">v</span><span class="se">\r</span><span class="s1">12.34</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 12</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="se">\t\</span><span class="s1">v</span><span class="se">\r</span><span class="s1">12.34</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 12.34</span>
</code></pre></div></div> <h5 id="2对象">（2）对象</h5> <p><code class="language-plaintext highlighter-rouge">Number()</code> 方法的参数是对象时，将返回 <code class="language-plaintext highlighter-rouge">NaN</code>，除非是包含单个数值的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// NaN</span>
<span class="nc">Number</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// NaN</span>
<span class="nc">Number</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// 5</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Number()</code> 方法的参数是对象时的转换规则是这样。</p> <ol> <li>调用对象自身的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法。如果返回原始类型的值，则直接对该值使用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数，不再进行后续步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法返回的还是对象，则改为调用对象自身的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数，不再进行后续步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回的是对象，就报错。</li> </ol> <p>默认情况下，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回对象本身，所以一般总是会调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，而 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回对象的类型字符串（比如 <code class="language-plaintext highlighter-rouge">[object Object]</code>）。当然，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，都是可以自定义的。</p> <h4 id="13-string">1.3 String()</h4> <p><code class="language-plaintext highlighter-rouge">String()</code> 函数可以将任意类型的值转化成字符串。</p> <h5 id="1原始类型值-1">（1）原始类型值</h5> <ul> <li><strong>数值</strong>：转为相应的字符串。</li> <li><strong>字符串</strong>：转换后还是原来的值。</li> <li><strong>布尔值</strong>：<code class="language-plaintext highlighter-rouge">true</code> 转为字符串 <code class="language-plaintext highlighter-rouge">"true"</code>，<code class="language-plaintext highlighter-rouge">false</code> 转为字符串 <code class="language-plaintext highlighter-rouge">"false"</code>。</li> <li><strong>undefined</strong>：转为字符串 <code class="language-plaintext highlighter-rouge">"undefined"</code>。</li> <li><strong>null</strong>：转为字符串 <code class="language-plaintext highlighter-rouge">"null"</code>。</li> </ul> <h5 id="2对象-1">（2）对象</h5> <p><code class="language-plaintext highlighter-rouge">String()</code> 方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// "[object Object]"</span>
<span class="nc">String</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// "1,2,3"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">String()</code> 方法的参数是对象时的转换规则跟 <code class="language-plaintext highlighter-rouge">Number()</code> 类似，只是互换了 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法和 <code class="language-plaintext highlighter-rouge">toString()</code> 方法的执行顺序。</p> <ul> <li>先调用对象自身的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。如果返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">String()</code> 函数，不再进行以下步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回的是对象，再调用原对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">String()</code> 函数，不再进行以下步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回的是对象，就报错。</li> </ul> <h3 id="2-自动转换">2. 自动转换</h3> <p>自动转换发生在三种情况：不同类型的数据互相运算、对非布尔值类型的数据求布尔值以及对非数值类型的值使用一元运算符（即 <code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">123</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span> <span class="c1">// "123abc"</span>

<span class="k">if </span><span class="p">(</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>  <span class="c1">// "hello"</span>

<span class="o">+</span> <span class="p">{</span><span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">}</span> <span class="c1">// NaN</span>
<span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1">// NaN</span>
</code></pre></div></div> <h4 id="21-自动转换为布尔值">2.1 自动转换为布尔值</h4> <p>预期为布尔值的地方（比如 <code class="language-plaintext highlighter-rouge">if</code> 语句的条件部分），系统内部会自动调用 <code class="language-plaintext highlighter-rouge">Boolean()</code> 函数将非布尔值的参数自动转换为布尔值。</p> <h4 id="22-自动转换为字符串">2.2 自动转换为字符串</h4> <p>预期为字符串的地方，就会将非字符串的值自动转为字符串。主要发生在字符串的加法运算时，当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p> <h4 id="23-自动转换为数值">2.3 自动转换为数值</h4> <p>预期为数值的地方，系统内部会自动调用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数将参数值自动转换为数值。除了加法运算符（<code class="language-plaintext highlighter-rouge">+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p> <h2 id="二错误处理机制">二、错误处理机制</h2> <h3 id="1-error-实例对象">1. Error 实例对象</h3> <p>JavaScript 抛出的错误都是 <code class="language-plaintext highlighter-rouge">Error</code> 构造函数的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">err</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">出错了</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">err</span><span class="p">.</span><span class="nx">message</span> <span class="c1">// "出错了"</span>
</code></pre></div></div> <p>JavaScript 语言标准只提到，<code class="language-plaintext highlighter-rouge">Error</code> 实例对象必须有 <code class="language-plaintext highlighter-rouge">message</code> 属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对 <code class="language-plaintext highlighter-rouge">Error</code> 实例还提供 <code class="language-plaintext highlighter-rouge">name</code> 和 <code class="language-plaintext highlighter-rouge">stack</code> 属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p> <ul> <li><code class="language-plaintext highlighter-rouge">message</code>：错误提示信息</li> <li><code class="language-plaintext highlighter-rouge">name</code>：错误名称（非标准属性）</li> <li><code class="language-plaintext highlighter-rouge">stack</code>：错误的堆栈（非标准属性）</li> </ul> <h3 id="2-原生错误类型">2. 原生错误类型</h3> <p>JavaScript 在 <code class="language-plaintext highlighter-rouge">Error</code> 对象的基础上，定义了其他 6 种派生对象。</p> <h4 id="21-syntaxerror-对象">2.1 SyntaxError 对象</h4> <p><code class="language-plaintext highlighter-rouge">SyntaxError</code> 对象是解析代码时发生的语法错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 变量名错误</span>
<span class="kd">var</span> <span class="mi">1</span><span class="nx">a</span><span class="p">;</span>
<span class="c1">// Uncaught SyntaxError: Invalid or unexpected token</span>

<span class="c1">// 缺少括号</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Uncaught SyntaxError: Unexpected string</span>
</code></pre></div></div> <h4 id="22-referenceerror-对象">2.2 ReferenceError 对象</h4> <p><code class="language-plaintext highlighter-rouge">ReferenceError</code> 对象是引用一个不存在的变量时发生的错误。</p> <h4 id="23-rangeerror-对象">2.3 RangeError 对象</h4> <p><code class="language-plaintext highlighter-rouge">RangeError</code> 对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是 <code class="language-plaintext highlighter-rouge">Number</code> 对象的方法参数超出范围，以及函数堆栈超过最大值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组长度不得为负数</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Uncaught RangeError: Invalid array length</span>
</code></pre></div></div> <h4 id="24-typeerror-对象">2.4 TypeError 对象</h4> <p><code class="language-plaintext highlighter-rouge">TypeError</code> 对象是变量或参数不是预期类型时发生的错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="mi">123</span>
<span class="c1">// Uncaught TypeError: 123 is not a constructor</span>
</code></pre></div></div> <h4 id="25-urierror-对象">2.5 URIError 对象</h4> <p><code class="language-plaintext highlighter-rouge">URIError</code> 对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及 <code class="language-plaintext highlighter-rouge">encodeURI()</code>、<code class="language-plaintext highlighter-rouge">decodeURI()</code>、<code class="language-plaintext highlighter-rouge">encodeURIComponent()</code>、<code class="language-plaintext highlighter-rouge">decodeURIComponent()</code>、<code class="language-plaintext highlighter-rouge">escape()</code> 和 <code class="language-plaintext highlighter-rouge">unescape()</code> 这六个函数。</p> <h4 id="26-evalerror-对象">2.6 EvalError 对象</h4> <p><code class="language-plaintext highlighter-rouge">eval</code> 函数没有被正确执行时，会抛出 <code class="language-plaintext highlighter-rouge">EvalError</code> 错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p> <h3 id="3-自定义错误">3. 自定义错误</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">UserError</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">默认信息</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">UserError</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">UserError</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">();</span>
<span class="nx">UserError</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">UserError</span><span class="p">;</span>

<span class="k">new</span> <span class="nc">UserError</span><span class="p">(</span><span class="dl">'</span><span class="s1">这是自定义的错误！</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码自定义一个错误对象 <code class="language-plaintext highlighter-rouge">UserError</code>，让它<strong>继承</strong> <code class="language-plaintext highlighter-rouge">Error</code> 对象。然后，就可以生成这种自定义类型的错误了。</p> <h3 id="4-throw-语句">4. throw 语句</h3> <p><code class="language-plaintext highlighter-rouge">throw</code> 语句用于手动中断程序执行，抛出一个错误。可以是系统错误，也可以是自定义错误。实际上，<code class="language-plaintext highlighter-rouge">throw</code> 可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p> <h3 id="5-trycatch-和-trycatchfinally-结构">5. try…catch 和 try…catch…finally 结构</h3> <p><code class="language-plaintext highlighter-rouge">catch</code> 代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p> <p>下面的例子反映了 <code class="language-plaintext highlighter-rouge">try...catch...finally</code> 三者之间的执行顺序。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">throw</span> <span class="dl">'</span><span class="s1">bug</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 这句原本会延迟到 finally 代码块结束再执行</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 不会运行</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 这句会覆盖掉前面那句 return</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 不会运行</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 不会运行</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nf">f</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="c1">// 1</span>
<span class="c1">// 3</span>

<span class="nx">result</span>
<span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">catch</code> 代码块结束执行之前，会先执行 <code class="language-plaintext highlighter-rouge">finally</code> 代码块。</p> <h2 id="三编程风格">三、编程风格</h2> <h3 id="1-缩进">1. 缩进</h3> <p>不管是空格和 Tab 键，坚持使用一种方式。</p> <h3 id="2-区块">2. 区块</h3> <p>总是使用<strong>大括号</strong>表示区块。区块起首的大括号跟在关键字的后面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">block</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="3-圆括号">3. 圆括号</h3> <p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。建议可以用空格，区分这两种不同的括号。</p> <ul> <li>表示函数调用时，函数名与左括号之间没有空格。</li> <li>表示函数定义时，函数名与左括号之间没有空格。</li> <li>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</li> </ul> <h3 id="5-行尾的分号">5. 行尾的分号</h3> <h4 id="51-不使用分号的情况">5.1 不使用分号的情况</h4> <ul> <li><code class="language-plaintext highlighter-rouge">for</code> 和 <code class="language-plaintext highlighter-rouge">while</code> 循环</li> <li>分支语句：<code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">switch</code> 和 <code class="language-plaintext highlighter-rouge">try</code></li> <li>函数的声明语句</li> </ul> <h4 id="52-分号的自动添加">5.2 分号的自动添加</h4> <p>除了上边三种情况，所有语句都应该使用分号（即使如果没有使用分号，大多数情况下，JavaScript 会自动添加）。</p> <h3 id="6-全局变量">6. 全局变量</h3> <p>避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如 <code class="language-plaintext highlighter-rouge">UPPER_CASE</code>。</p> <h3 id="7-变量声明">7. 变量声明</h3> <p>变量最好放在代码块的头部。所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</p> <h3 id="8-with-语句">8. with 语句</h3> <p><code class="language-plaintext highlighter-rouge">with</code> 可以减少代码的书写，但是会造成混淆。因此，不要使用 <code class="language-plaintext highlighter-rouge">with</code> 语句。</p> <h3 id="9-相等和严格相等">9. 相等和严格相等</h3> <p>相等运算符会自动转换变量类型，造成很多意想不到的情况。建议不要使用相等运算符（<code class="language-plaintext highlighter-rouge">==</code>），只使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）。</p> <h3 id="10-语句的合并">10. 语句的合并</h3> <p>建议不要将不同目的的语句，合并成一行。</p> <h3 id="11-自增和自减运算符">11. 自增和自减运算符</h3> <p>建议自增（<code class="language-plaintext highlighter-rouge">++</code>）和自减（<code class="language-plaintext highlighter-rouge">--</code>）运算符尽量使用 <code class="language-plaintext highlighter-rouge">+=</code> 和 <code class="language-plaintext highlighter-rouge">-=</code> 代替。</p> <h3 id="12-switchcase-结构">12. switch…case 结构</h3> <p><code class="language-plaintext highlighter-rouge">switch...case</code> 结构要求，在每个 <code class="language-plaintext highlighter-rouge">case</code> 的最后一行必须是 <code class="language-plaintext highlighter-rouge">break</code> 语句，否则会接着运行下一个 <code class="language-plaintext highlighter-rouge">case</code>。这样不仅容易忘记，还会造成代码的冗长。</p> <p>而且，<code class="language-plaintext highlighter-rouge">switch...case</code> 不使用大括号，不利于代码形式的统一。此外，这种结构类似于 <code class="language-plaintext highlighter-rouge">goto</code> 语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch </span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid action.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码建议改写成对象结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">actions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">actions</span><span class="p">[</span><span class="nx">action</span><span class="p">]</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid action.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">actions</span><span class="p">[</span><span class="nx">action</span><span class="p">]();</span>
<span class="p">}</span>
</code></pre></div></div> <p>因此，建议 <code class="language-plaintext highlighter-rouge">switch...case</code> 结构可以用对象结构代替。</p> <h2 id="四console-对象与控制台">四、console 对象与控制台</h2> <h3 id="1-console-对象">1. console 对象</h3> <p><code class="language-plaintext highlighter-rouge">console</code> 对象可以输出各种信息到控制台。<code class="language-plaintext highlighter-rouge">console</code> 的常见用途有两个。</p> <ul> <li>调试程序，显示网页代码运行时的错误信息。</li> <li>提供了一个命令行接口，用来与网页代码互动。</li> </ul> <h3 id="2-console-对象的静态方法">2. console 对象的静态方法</h3> <h4 id="21-consolelogconsoleinfoconsoledebug">2.1 console.log()，console.info()，console.debug()</h4> <p><code class="language-plaintext highlighter-rouge">console.log</code> 方法用于在控制台输出信息。它可以接受一个或多个参数，不同类型的数据必须使用对应的占位符。</p> <ul> <li><code class="language-plaintext highlighter-rouge">%s</code> 字符串</li> <li><code class="language-plaintext highlighter-rouge">%d</code> 整数</li> <li><code class="language-plaintext highlighter-rouge">%i</code> 整数</li> <li><code class="language-plaintext highlighter-rouge">%f</code> 浮点数</li> <li><code class="language-plaintext highlighter-rouge">%o</code> 对象的链接</li> <li><code class="language-plaintext highlighter-rouge">%c</code> CSS 格式字符串</li> </ul> <p>使用 <code class="language-plaintext highlighter-rouge">%c</code> 占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">%cThis text is styled!</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">color: red; background: yellow; font-size: 24px;</span><span class="dl">'</span>
<span class="p">)</span>
</code></pre></div></div> <p>上面代码运行后，输出的内容将显示为黄底红字。</p> <p><code class="language-plaintext highlighter-rouge">console.info</code> 是 <code class="language-plaintext highlighter-rouge">console.log</code> 方法的别名，用法完全一样。只不过 <code class="language-plaintext highlighter-rouge">console.info</code> 方法会在输出信息的前面，加上一个蓝色图标。</p> <p><code class="language-plaintext highlighter-rouge">console.debug</code> 方法与 <code class="language-plaintext highlighter-rouge">console.log</code> 方法类似，会在控制台输出调试信息。但是，默认情况下，<code class="language-plaintext highlighter-rouge">console.debug</code> 输出的信息不会显示，只有在打开显示级别在 <code class="language-plaintext highlighter-rouge">verbose</code> 的情况下，才会显示。</p> <p><code class="language-plaintext highlighter-rouge">console</code> 对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义 <code class="language-plaintext highlighter-rouge">console.log</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">log</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">info</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">warn</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span> <span class="o">=</span> <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nf">bind</span><span class="p">(</span>
    <span class="nx">console</span><span class="p">,</span>
    <span class="k">new</span> <span class="nc">Date</span><span class="p">().</span><span class="nf">toISOString</span><span class="p">()</span>
  <span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">出错了！</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// 2014-05-18T09:00.000Z 出错了！</span>
</code></pre></div></div> <p>上面代码表示，使用自定义的 <code class="language-plaintext highlighter-rouge">console.log</code> 方法，可以在显示结果添加当前时间。</p> <h4 id="22-consolewarnconsoleerror">2.2 console.warn()，console.error()</h4> <p><code class="language-plaintext highlighter-rouge">warn</code> 方法和 <code class="language-plaintext highlighter-rouge">error</code> 方法也是在控制台输出信息，它们与 <code class="language-plaintext highlighter-rouge">log</code> 方法的不同之处在于，<code class="language-plaintext highlighter-rouge">warn</code> 方法输出信息时，在最前面加一个黄色三角，表示警告；<code class="language-plaintext highlighter-rouge">error</code> 方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p> <h4 id="23-consoletable">2.3 console.table()</h4> <p>对于某些复合类型的数据，<code class="language-plaintext highlighter-rouge">console.table</code> 方法可以将其转为表格显示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">languages</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">JavaScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.js</span><span class="dl">"</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TypeScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.ts</span><span class="dl">"</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">CoffeeScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.coffee</span><span class="dl">"</span> <span class="p">}</span>
<span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">table</span><span class="p">(</span><span class="nx">languages</span><span class="p">);</span>
</code></pre></div></div> <table> <thead> <tr> <th>-(index)-</th> <th>-name-</th> <th>-fileExtension-</th> </tr> </thead> <tbody> <tr> <td>0 -</td> <td>“JavaScript”</td> <td>“.js”</td> </tr> <tr> <td>1 -</td> <td>“TypeScript”</td> <td>“.ts”</td> </tr> <tr> <td>2 -</td> <td>“CoffeeScript”</td> <td>“.coffee”</td> </tr> </tbody> </table> <h4 id="24-consolecount">2.4 console.count()</h4> <p><code class="language-plaintext highlighter-rouge">count</code> 方法用于计数，输出它被调用了多少次。该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p> <h4 id="25-consoledirconsoledirxml">2.5 console.dir()，console.dirxml()</h4> <p><code class="language-plaintext highlighter-rouge">dir</code> 方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">({</span><span class="na">f1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="na">f2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">})</span>
<span class="c1">// Object {f1: "foo", f2: "bar"}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">dir</span><span class="p">({</span><span class="na">f1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="na">f2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">})</span>
<span class="c1">// Object</span>
<span class="c1">//   f1: "foo"</span>
<span class="c1">//   f2: "bar"</span>
<span class="c1">//   __proto__: Object</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">dirxml</code> 方法主要用于以目录树的形式，显示 DOM 节点。如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code class="language-plaintext highlighter-rouge">console.dirxml</code> 等同于 <code class="language-plaintext highlighter-rouge">console.dir</code>。</p> <h4 id="26-consoleassert">2.6 console.assert()</h4> <p><code class="language-plaintext highlighter-rouge">console.assert</code> 方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p> <p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为 <code class="language-plaintext highlighter-rouge">false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">assert</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="dl">'</span><span class="s1">判断条件不成立</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Assertion failed: 判断条件不成立</span>
</code></pre></div></div> <h4 id="27-consoletimeconsoletimeend">2.7 console.time()，console.timeEnd()</h4> <p>这两个方法用于计时，可以算出一个操作所花费的准确时间。<code class="language-plaintext highlighter-rouge">time</code> 方法表示计时开始，<code class="language-plaintext highlighter-rouge">timeEnd</code> 方法表示计时结束。它们的参数是计时器的名称。调用 <code class="language-plaintext highlighter-rouge">timeEnd</code> 方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">time</span><span class="p">(</span><span class="dl">'</span><span class="s1">Array initialize</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">array</span><span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">timeEnd</span><span class="p">(</span><span class="dl">'</span><span class="s1">Array initialize</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Array initialize: 1914.481ms</span>
</code></pre></div></div> <h4 id="28-consolegroupconsolegroupendconsolegroupcollapsed">2.8 console.group()，console.groupEnd()，console.groupCollapsed()</h4> <p><code class="language-plaintext highlighter-rouge">console.group</code> 和 <code class="language-plaintext highlighter-rouge">console.groupEnd</code> 这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p> <p><code class="language-plaintext highlighter-rouge">console.groupCollapsed</code> 方法与 <code class="language-plaintext highlighter-rouge">console.group</code> 方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p> <h4 id="29-consoletraceconsoleclear">2.9 console.trace()，console.clear()</h4> <p><code class="language-plaintext highlighter-rouge">console.trace</code> 方法显示当前执行的代码在堆栈中的调用路径。</p> <p><code class="language-plaintext highlighter-rouge">console.clear</code> 方法用于清除当前控制台的所有输出，将光标回置到第一行。</p> <h3 id="3-控制台命令行-api">3. 控制台命令行 API</h3> <p>浏览器控制台中，除了使用 <code class="language-plaintext highlighter-rouge">console</code> 对象，还可以使用一些控制台自带的命令行方法。</p> <p>（1）<code class="language-plaintext highlighter-rouge">$_</code></p> <p><code class="language-plaintext highlighter-rouge">$_</code> 属性返回上一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="c1">// 4</span>
<span class="nx">$_</span>
<span class="c1">// 4</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">$0</code> - <code class="language-plaintext highlighter-rouge">$4</code></p> <p>控制台保存了最近 5 个在 Elements 面板选中的 DOM 元素，<code class="language-plaintext highlighter-rouge">$0</code> 代表倒数第一个（最近一个），<code class="language-plaintext highlighter-rouge">$1</code> 代表倒数第二个，以此类推直到 <code class="language-plaintext highlighter-rouge">$4</code>。</p> <p>（3）<code class="language-plaintext highlighter-rouge">$(selector)</code></p> <p><code class="language-plaintext highlighter-rouge">$(selector)</code> 返回第一个匹配的元素，等同于 <code class="language-plaintext highlighter-rouge">document.querySelector()</code>。注意，如果页面脚本对 <code class="language-plaintext highlighter-rouge">$</code> 有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行 <code class="language-plaintext highlighter-rouge">$(selector)</code> 就会采用 jQuery 的实现，返回一个数组。</p> <p>（4）<code class="language-plaintext highlighter-rouge">$$(selector)</code></p> <p><code class="language-plaintext highlighter-rouge">$$(selector)</code> 返回选中的 DOM 对象，等同于 <code class="language-plaintext highlighter-rouge">document.querySelectorAll</code>。</p> <p>（5）<code class="language-plaintext highlighter-rouge">$x(path)</code></p> <p><code class="language-plaintext highlighter-rouge">$x(path)</code> 方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">$x</span><span class="p">(</span><span class="dl">"</span><span class="s2">//p[a]</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div> <p>上面代码返回所有包含a元素的p元素。</p> <p>（6）<code class="language-plaintext highlighter-rouge">inspect(object)</code></p> <p><code class="language-plaintext highlighter-rouge">inspect(object)</code> 方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在 Elements 面板中显示，比如 <code class="language-plaintext highlighter-rouge">inspect(document)</code> 会在 Elements 面板显示 <code class="language-plaintext highlighter-rouge">document</code> 元素。JavaScript 对象在控制台面板 Profiles 面板中显示，比如 <code class="language-plaintext highlighter-rouge">inspect(window)</code>。</p> <p>（7）<code class="language-plaintext highlighter-rouge">getEventListeners(object)</code></p> <p><code class="language-plaintext highlighter-rouge">getEventListeners(object)</code> 方法返回一个对象，该对象的成员为 <code class="language-plaintext highlighter-rouge">object</code> 登记了回调函数的各种事件（比如 <code class="language-plaintext highlighter-rouge">click</code> 或 <code class="language-plaintext highlighter-rouge">keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p> <p>（8）<code class="language-plaintext highlighter-rouge">keys(object)</code>，<code class="language-plaintext highlighter-rouge">values(object)</code></p> <p><code class="language-plaintext highlighter-rouge">keys(object)</code> 方法返回一个数组，包含 <code class="language-plaintext highlighter-rouge">object</code> 的所有键名。</p> <p><code class="language-plaintext highlighter-rouge">values(object)</code> 方法返回一个数组，包含 <code class="language-plaintext highlighter-rouge">object</code> 的所有键值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="dl">'</span><span class="s1">p1</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p2</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">};</span>

<span class="nf">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
<span class="c1">// ["p1", "p2"]</span>
<span class="nf">values</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
<span class="c1">// ["a", "b"]</span>
</code></pre></div></div> <p>（9）<code class="language-plaintext highlighter-rouge">monitorEvents(object[, events])</code>，<code class="language-plaintext highlighter-rouge">unmonitorEvents(object[, events])</code></p> <p><code class="language-plaintext highlighter-rouge">monitorEvents(object[, events])</code> 方法监听特定对象上发生的特定事件。事件发生时，会返回一个 <code class="language-plaintext highlighter-rouge">Event</code> 对象，包含该事件的相关信息。<code class="language-plaintext highlighter-rouge">unmonitorEvents</code> 方法用于停止监听。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="dl">"</span><span class="s2">resize</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">monitorEvents</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">resize</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">scroll</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div> <p>上面代码分别表示单个事件和多个事件的监听方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nx">$0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">mouse</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">unmonitorEvents</span><span class="p">(</span><span class="nx">$0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码表示如何停止监听。</p> <p>monitorEvents 允许监听同一大类的事件。所有事件可以分成四个大类。</p> <ul> <li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li> <li>key：”keydown”, “keyup”, “keypress”, “textInput”</li> <li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li> <li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#msg</span><span class="dl">"</span><span class="p">),</span> <span class="dl">"</span><span class="s2">key</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码表示监听所有 <code class="language-plaintext highlighter-rouge">key</code> 大类的事件。</p> <p>（10）其他方法</p> <p>命令行 API 还提供以下方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">clear()</code>：清除控制台的历史。</li> <li><code class="language-plaintext highlighter-rouge">copy(object)</code>：复制特定 DOM 元素到剪贴板。</li> <li><code class="language-plaintext highlighter-rouge">dir(object)</code>：显示特定对象的所有属性，是 <code class="language-plaintext highlighter-rouge">console.dir</code> 方法的别名。</li> <li><code class="language-plaintext highlighter-rouge">dirxml(object)</code>：显示特定对象的 XML 形式，是 <code class="language-plaintext highlighter-rouge">console.dirxml</code> 方法的别名。</li> </ul> <h3 id="4-debugger-语句">4. debugger 语句</h3> <p><code class="language-plaintext highlighter-rouge">debugger</code> 语句主要用于除错，作用是设置断点。</p> <h2 id="五参考">五、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/features/">JavaScript 教程 - 语法专题</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 语法专题》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/operators/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-08T00:00:00+00:00</published><updated>2024-10-08T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/operators</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/operators/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/operators/">《JavaScript 教程 - 运算符》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一算术运算符">一、算术运算符</h2> <h3 id="11-概述">1.1 概述</h3> <p>JavaScript 共提供 10 个算术运算符，用来完成基本的算术运算。包括 <code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">**</code>（指数运算符）、<code class="language-plaintext highlighter-rouge">%</code>（余数运算符）、<code class="language-plaintext highlighter-rouge">++x</code>（或者 <code class="language-plaintext highlighter-rouge">x++</code>，即自增运算符）、<code class="language-plaintext highlighter-rouge">--x</code>（或者 <code class="language-plaintext highlighter-rouge">x--</code>，即）自减运算符、<code class="language-plaintext highlighter-rouge">+x</code>（数值运算符） 和 <code class="language-plaintext highlighter-rouge">-x</code>（负数值运算符）。</p> <h3 id="12-加法运算符">1.2 加法运算符</h3> <h4 id="基本规则">基本规则</h4> <p>相比于其他运算符，加法运算符（<code class="language-plaintext highlighter-rouge">+</code>）比较特殊，即可当作算数运算符，又可对字符串进行连接操作。</p> <p>只要有一个是运算子是字符串，进行的就是字符串的连接操作（此时，如果另一个运算子不是字符串，会被转为字符串）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// "1a"</span>
<span class="kc">false</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// "falsea"</span>
</code></pre></div></div> <p>加法运算符是在<strong>运行时</strong>决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“<strong>重载</strong>”（overload）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1">// "345"</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span> <span class="c1">// "75"</span>
</code></pre></div></div> <p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：<strong>所有运算子一律转为数值，再进行相应的数学运算</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">-</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">*</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// 2</span>
<span class="mi">1</span> <span class="o">/</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// 0.5</span>
</code></pre></div></div> <h4 id="对象的相加">对象的相加</h4> <p>如果运算子是对象，必须先转成原始类型的值，然后再相加。它的规则是：首先自动调用对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法，如果此时返回的是原始类型的值，则进行相应的操作，如果 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法得到的是对象类型，再自动调用对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法，将对象转为字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "[object Object]2"</span>
</code></pre></div></div> <p>上面代码中，对象 <code class="language-plaintext highlighter-rouge">obj</code> 转成原始类型的值是 <code class="language-plaintext highlighter-rouge">[object Object]</code>，再加 <code class="language-plaintext highlighter-rouge">2</code> 就得到了上面的结果。</p> <p>（1）首先，自动调用对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// { p: 1 }</span>
</code></pre></div></div> <p>（2）一般来说，对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法总是返回对象自身，这时再自动调用对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法，将其转为字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">().</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "[object Object]"</span>
</code></pre></div></div> <p>对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法默认返回 <code class="language-plaintext highlighter-rouge">[object Object]</code>，所以就得到了最前面那个例子的结果。</p> <p>注意，如果 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法返回的是原始类型的值，就不再调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法，否则会调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法，尝试将对象转为字符串。</p> <p>知道了这个规则以后，就可以自己定义 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法或 <code class="language-plaintext highlighter-rouge">toString</code> 方法，得到想要的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">valueOf</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，我们定义 <code class="language-plaintext highlighter-rouge">obj</code> 对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法返回 <code class="language-plaintext highlighter-rouge">1</code>，于是 <code class="language-plaintext highlighter-rouge">obj + 2</code> 就得到了 <code class="language-plaintext highlighter-rouge">3</code>。这个例子中，由于 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法直接返回一个原始类型的值，所以不再调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <p>下面是自定义 <code class="language-plaintext highlighter-rouge">toString</code> 方法的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">toString</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "hello2"</span>
</code></pre></div></div> <p>上面代码中，对象 obj 的 <code class="language-plaintext highlighter-rouge">toString</code> 方法返回字符串 <code class="language-plaintext highlighter-rouge">hello</code>。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。</p> <p>这里有一个特例，如果运算子是一个 <code class="language-plaintext highlighter-rouge">Date</code> 对象的实例，那么会优先执行 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "hello2"</span>
</code></pre></div></div> <p>上面代码中，对象 <code class="language-plaintext highlighter-rouge">obj</code> 是一个 <code class="language-plaintext highlighter-rouge">Date</code> 对象的实例，并且自定义了 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法和 <code class="language-plaintext highlighter-rouge">toString</code> 方法，结果 <code class="language-plaintext highlighter-rouge">toString</code> 方法优先执行。</p> <h3 id="13-余数运算符">1.3 余数运算符</h3> <p>对于余数运算符（<code class="language-plaintext highlighter-rouge">%</code>）来说，运算结果的正负号由第一个运算子的正负号决定。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="mi">1</span> <span class="o">%</span> <span class="mi">2</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">%</span> <span class="o">-</span><span class="mi">2</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>所以，为了得到负数的正确余数值，可以先使用绝对值函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 错误的写法</span>
<span class="kd">function</span> <span class="nf">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// 正确的写法</span>
<span class="kd">function</span> <span class="nf">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">6.5</span> <span class="o">%</span> <span class="mf">2.1</span>
<span class="c1">// 0.19999999999999973</span>
</code></pre></div></div> <h3 id="14-自增和自减运算符">1.4 自增和自减运算符</h3> <p>对于自增和自减运算符，运算之后，变量的值发生变化，这种效应叫做运算的<strong>副作用</strong>（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。</p> <p>自增和自减运算符放置的位置不同，会导致不同的行为。</p> <ul> <li>如果放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。</li> <li>如果放在变量之后，会先返回变量操作前的值，再进行自增/自减操作。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">x</span><span class="o">++</span> <span class="c1">// 1</span>
<span class="o">++</span><span class="nx">y</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">x</code> 是先返回当前值，然后自增，所以得到 <code class="language-plaintext highlighter-rouge">1</code>；<code class="language-plaintext highlighter-rouge">y</code> 是先自增，然后返回新的值，所以得到 <code class="language-plaintext highlighter-rouge">2</code>。</p> <h3 id="15-数值运算符负数值运算符">1.5 数值运算符，负数值运算符</h3> <p>数值运算符（<code class="language-plaintext highlighter-rouge">+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。</p> <p>数值运算符的作用在于可以将任何值转为数值（与 <code class="language-plaintext highlighter-rouge">Number</code> 函数的作用相同）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span><span class="kc">true</span> <span class="c1">// 1</span>
<span class="o">+</span><span class="p">[]</span> <span class="c1">// 0</span>
<span class="o">+</span><span class="p">{}</span> <span class="c1">// NaN</span>
</code></pre></div></div> <p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行 <code class="language-plaintext highlighter-rouge">NaN</code> 也是数值）。</p> <p>负数值运算符（<code class="language-plaintext highlighter-rouge">-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。</p> <h3 id="16-指数运算符">1.6 指数运算符</h3> <p>指数运算符（<code class="language-plaintext highlighter-rouge">**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="c1">// 16</span>
</code></pre></div></div> <p>注意，指数运算符是<strong>右结合</strong>。即多个指数运算符连用时，先进行最右边的计算。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于 2 ** (3 ** 2)</span>
<span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">**</span> <span class="mi">2</span>
<span class="c1">// 512</span>
</code></pre></div></div> <p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。</p> <h2 id="二比较运算符">二、比较运算符</h2> <h3 id="21-概述">2.1 概述</h3> <p>JavaScript 提供了 8 个比较运算符，他们是：<code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;=</code>、<code class="language-plaintext highlighter-rouge">&lt;=</code>、<code class="language-plaintext highlighter-rouge">==</code>、<code class="language-plaintext highlighter-rouge">===</code>、<code class="language-plaintext highlighter-rouge">!=</code> 和 <code class="language-plaintext highlighter-rouge">!==</code>。</p> <p>这八个比较运算符分成两类：相等比较和非相等比较。对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p> <h3 id="22-非相等运算符字符串的比较">2.2 非相等运算符：字符串的比较</h3> <p>字符串按照字典顺序进行比较。首先比较首字符的 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点。如果相等，再比较第二个字符的 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点，以此类推。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">dog</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">Cat</span><span class="dl">'</span> <span class="c1">// true' c 的 Unicode 码点是 99，C 的 Unicode 码点是 67</span>
<span class="dl">'</span><span class="s1">大</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">小</span><span class="dl">'</span> <span class="c1">// false “大”的 Unicode 码点是 22823，“小”是23567</span>
</code></pre></div></div> <h3 id="23-非相等运算符非字符串的比较">2.3 非相等运算符：非字符串的比较</h3> <p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。</p> <h4 id="1原始类型值">（1）原始类型值</h4> <p>如果两个运算子都是原始类型的值，则先转成数值再比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">4</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="c1">// 等同于 5 &gt; Number('4')</span>
<span class="c1">// 即 5 &gt; 4</span>

<span class="kc">true</span> <span class="o">&gt;</span> <span class="kc">false</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number(true) &gt; Number(false)</span>
<span class="c1">// 即 1 &gt; 0</span>

<span class="mi">2</span> <span class="o">&gt;</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 2 &gt; Number(true)</span>
<span class="c1">// 即 2 &gt; 1</span>
</code></pre></div></div> <p>任何值（包括 <code class="language-plaintext highlighter-rouge">NaN</code> 本身）与 <code class="language-plaintext highlighter-rouge">NaN</code> 使用非相等运算符进行比较，返回的都是 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="mi">1</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="2对象">（2）对象</h4> <p>如果运算子是对象，会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法；如果返回的还是对象，再接着调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">11</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; '11'</span>
<span class="c1">// 即 '2' &gt; '11'</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">11</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="c1">// 等同于 (function () { return '1' })() &gt; '11'</span>
<span class="c1">// 即 '1' &gt; '11'</span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span>
<span class="c1">// 即 '2' &gt; '1'</span>
</code></pre></div></div> <h3 id="24-严格相等运算符">2.4 严格相等运算符</h3> <ul> <li>相等运算符（<code class="language-plaintext highlighter-rouge">==</code>）比较两个值是否<strong>相等</strong>。如果两个值不是同一类型，相等运算符会将它们转换成同一个类型，再用严格相等运算符进行比较。</li> <li>严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）比较两个值是否为“<strong>同一个值</strong>”。如果两个值不是同一类型，严格相等运算符直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <p>对于严格相等运算符：</p> <ul> <li>如果两个值的类型不同，直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回 <code class="language-plaintext highlighter-rouge">true</code>，值不同就返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li>复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向<strong>同一个地址</strong>。</li> <li><code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 与自身严格相等。</li> </ul> <h3 id="25-严格不相等运算符">2.5 严格不相等运算符</h3> <p>严格不相等运算符（<code class="language-plaintext highlighter-rouge">!==</code>）先求严格相等运算符的结果，然后取相反值。</p> <h3 id="26-相等运算符">2.6 相等运算符</h3> <p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。比较不同类型的数据时，相等运算符会先将数据进行<strong>类型转换</strong>，然后再用严格相等运算符比较。</p> <ul> <li> <p>原始类型的值会转换成数值再进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 1 === Number(true)</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="c1">// 等同于 2 === Number(false)</span>

<span class="dl">'</span><span class="s1">true</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
<span class="c1">// 等同于 Number('true') === Number(true)</span>
<span class="c1">// 等同于 NaN === 1</span>

<span class="dl">''</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number('') === 0</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="dl">''</span> <span class="o">==</span> <span class="kc">false</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number('') === Number(false)</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number('1') === Number(true)</span>
<span class="c1">// 等同于 1 === 1</span>

<span class="dl">'</span><span class="se">\n</span><span class="s1">  123  </span><span class="se">\t</span><span class="dl">'</span> <span class="o">==</span> <span class="mi">123</span> <span class="c1">// true</span>
<span class="c1">// 因为字符串转为数字时，省略前置和后置的空格</span>
</code></pre></div> </div> </li> <li> <p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。先调用对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，得到字符串形式，再进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组与数值的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">// true</span>

<span class="c1">// 数组与字符串的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1,2</span><span class="dl">'</span> <span class="c1">// true</span>

<span class="c1">// 对象与布尔值的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 只有与自身比较，或者互相比较时，才会返回 <code class="language-plaintext highlighter-rouge">true</code>；与其他类型的值比较时，结果都为 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">undefined</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="c1">// true</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
<span class="kc">undefined</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
</code></pre></div> </div> </li> <li> <p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">==</span> <span class="dl">''</span>             <span class="c1">// true</span>
<span class="mi">0</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span>            <span class="c1">// true</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">true</span>           <span class="c1">// false</span>
<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span>          <span class="c1">// false</span>

<span class="kc">false</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">false</span><span class="dl">'</span>    <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span>        <span class="c1">// true</span>

<span class="kc">false</span> <span class="o">==</span> <span class="kc">undefined</span>  <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="kc">null</span>       <span class="c1">// false</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">undefined</span>   <span class="c1">// true</span>

<span class="dl">'</span><span class="s1"> </span><span class="se">\t\r\n</span><span class="s1"> </span><span class="dl">'</span> <span class="o">==</span> <span class="mi">0</span>     <span class="c1">// true</span>
</code></pre></div> </div> </li> </ul> <p>建议不要使用相等运算符（<code class="language-plaintext highlighter-rouge">==</code>），最好只使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）。</p> <h3 id="27-不相等运算符">2.7 不相等运算符</h3> <p>不相等运算符（<code class="language-plaintext highlighter-rouge">!=</code>）先求相等运算符的结果，然后取相反值。</p> <h2 id="三布尔运算符">三、布尔运算符</h2> <h3 id="31-概述">3.1 概述</h3> <p>布尔运算符用于将表达式转为布尔值，共包含四个运算符：<code class="language-plaintext highlighter-rouge">!</code>（取反运算符）、<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>（且运算符）、<code class="language-plaintext highlighter-rouge">||</code>（或运算符）和 <code class="language-plaintext highlighter-rouge">?:</code>（三元运算符）。</p> <h3 id="32-取反运算符">3.2 取反运算符（!）</h3> <ul> <li><code class="language-plaintext highlighter-rouge">undefined</code>、<code class="language-plaintext highlighter-rouge">null</code>、<code class="language-plaintext highlighter-rouge">false</code>、<code class="language-plaintext highlighter-rouge">0</code>、<code class="language-plaintext highlighter-rouge">NaN</code> 和空字符串（<code class="language-plaintext highlighter-rouge">''</code>）取反后为 <code class="language-plaintext highlighter-rouge">true</code>，其他值都为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li> <p>对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 <code class="language-plaintext highlighter-rouge">Boolean()</code> 函数的作用相同。这是一种常用的类型转换的写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!!</span><span class="nx">x</span>
<span class="c1">// 等同于</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> <h3 id="33-且运算符">3.3 且运算符（&amp;&amp;）</h3> <p>且运算符（<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>）的运算规则是：如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>，则返回第二个运算子的<strong>值</strong>（注意是值，不是布尔值）；如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">false</code>，则直接返回第一个运算子的<strong>值</strong>，且不再对第二个运算子求值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">''</span> <span class="c1">// ""</span>
<span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "f"</span>
<span class="dl">''</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// ""</span>
</code></pre></div></div> <p>这种跳过第二个运算子的机制，被称为“<strong>短路</strong>”。有时候可以用它取代 if 结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 等价于</span>
<span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nf">doSomething</span><span class="p">();</span>
</code></pre></div></div> <p>且运算符可以多个连用，这时返回第一个布尔值为 <code class="language-plaintext highlighter-rouge">false</code> 的表达式的值。如果所有表达式的布尔值都为 <code class="language-plaintext highlighter-rouge">true</code>，则返回最后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">''</span> <span class="o">&amp;&amp;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
<span class="c1">// ''</span>

<span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="mi">3</span>
<span class="c1">// 3</span>
</code></pre></div></div> <h3 id="34-或运算符">3.4 或运算符（||）</h3> <p>或运算符（<code class="language-plaintext highlighter-rouge">||</code>）的运算规则是：如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>，则返回第一个运算子的<strong>值</strong>，且不再对第二个运算子求值；如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">false</code>，则返回第二个运算子的<strong>值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">||</span> <span class="dl">''</span> <span class="c1">// "t"</span>
<span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "t"</span>
<span class="dl">''</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "f"</span>
<span class="dl">''</span> <span class="o">||</span> <span class="dl">''</span> <span class="c1">// ""</span>
</code></pre></div></div> <p>或运算符可以多个连用，这时返回第一个布尔值为 <code class="language-plaintext highlighter-rouge">true</code> 的表达式的值。如果所有表达式都为 <code class="language-plaintext highlighter-rouge">false</code>，则返回最后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="dl">''</span> <span class="o">||</span> <span class="mi">4</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">||</span> <span class="kc">true</span>
<span class="c1">// 4</span>

<span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="dl">''</span>
<span class="c1">// ''</span>
</code></pre></div></div> <h2 id="四二进制位运算符">四、二进制位运算符</h2> <h3 id="41-概述">4.1 概述</h3> <p>二进制位运算符用于直接对二进制位进行计算，共有 7 个。</p> <ul> <li>二进制<strong>或</strong>运算符（or）：符号为 <code class="language-plaintext highlighter-rouge">|</code>，表示若两个二进制位都为 <code class="language-plaintext highlighter-rouge">0</code>，则结果为 <code class="language-plaintext highlighter-rouge">0</code>，否则为 <code class="language-plaintext highlighter-rouge">1</code>。</li> <li>二进制<strong>与</strong>运算符（and）：符号为 <code class="language-plaintext highlighter-rouge">&amp;</code>，表示若两个二进制位都为 <code class="language-plaintext highlighter-rouge">1</code>，则结果为 <code class="language-plaintext highlighter-rouge">1</code>，否则为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li>二进制<strong>否</strong>运算符（not）：符号为 <code class="language-plaintext highlighter-rouge">~</code>，表示对一个二进制位取反。</li> <li><strong>异或</strong>运算符（xor）：符号为 <code class="language-plaintext highlighter-rouge">^</code>，表示若两个二进制位不相同，则结果为 <code class="language-plaintext highlighter-rouge">1</code>，否则为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><strong>左移</strong>运算符（left shift）：符号为 <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>。</li> <li><strong>右移</strong>运算符（right shift）：符号为 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>。</li> <li>头部补零的右移运算符（zero filled right shift）：符号为 <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>。</li> </ul> <p>这些位运算符直接处理每个比特位（bit）。</p> <p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是以 <strong>32 位带符号的整数</strong>进行运算的，并且返回值也是一个 32 位带符号的整数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div> <p>上面这行代码的意思，就是将 <code class="language-plaintext highlighter-rouge">i</code>（不管是整数或小数）转为 32 位整数。</p> <p>利用这个特性，可以写出一个函数，将任意数值转为32位整数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">toInt32</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">toInt32</span><span class="p">(</span><span class="mf">1.001</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="mf">1.999</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// -1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// -1</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">toInt32()</code> 方法将任意值与 <code class="language-plaintext highlighter-rouge">0</code> 进行一次或运算，这个位运算会自动将一个值转为 32 位整数。上面代码中，<code class="language-plaintext highlighter-rouge">toInt32()</code> 用于将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于 2 的 32 次方的整数，大于 32 位的数位都会被舍去。</p> <h3 id="42-二进制或运算符">4.2 二进制或运算符</h3> <p>二进制或运算符（<code class="language-plaintext highlighter-rouge">|</code>）<strong>逐位</strong>比较两个运算子，两个二进制位之中只要有一个为 <code class="language-plaintext highlighter-rouge">1</code>，就返回 <code class="language-plaintext highlighter-rouge">1</code>，否则返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">|</span> <span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">3</code> 的二进制形式分别是 <code class="language-plaintext highlighter-rouge">00</code> 和 <code class="language-plaintext highlighter-rouge">11</code>，所以进行二进制或运算会得到 <code class="language-plaintext highlighter-rouge">11</code>（即 <code class="language-plaintext highlighter-rouge">3</code>）。</p> <p>位运算<strong>只对整数有效</strong>，遇到小数时，会将小数部分舍去，只保留整数部分。所以，<strong>将一个小数与 <code class="language-plaintext highlighter-rouge">0</code> 进行二进制或运算，等同于对该数去除小数部分，即取整数位</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">2.9</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// 2</span>
<span class="o">-</span><span class="mf">2.9</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// -2</span>
</code></pre></div></div> <h3 id="43-二进制与运算符">4.3 二进制与运算符</h3> <p>二进制与运算符（<code class="language-plaintext highlighter-rouge">&amp;</code>）<strong>逐位</strong>比较两个运算子，两个二进制位之中只要有一个位为 <code class="language-plaintext highlighter-rouge">0</code>，就返回 <code class="language-plaintext highlighter-rouge">0</code>，否则返回 <code class="language-plaintext highlighter-rouge">1</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="c1">// 0</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">0</code>（二进制 <code class="language-plaintext highlighter-rouge">00</code>）和 <code class="language-plaintext highlighter-rouge">3</code>（二进制 <code class="language-plaintext highlighter-rouge">11</code>）进行二进制与运算会得到 <code class="language-plaintext highlighter-rouge">00</code>（即 <code class="language-plaintext highlighter-rouge">0</code>）。</p> <h3 id="44-二进制否运算符">4.4 二进制否运算符</h3> <p>二进制否运算符（<code class="language-plaintext highlighter-rouge">~</code>）将每个二进制位都变为相反值（<code class="language-plaintext highlighter-rouge">0</code> 变为 <code class="language-plaintext highlighter-rouge">1</code>，<code class="language-plaintext highlighter-rouge">1</code> 变为 <code class="language-plaintext highlighter-rouge">0</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~</span> <span class="mi">3</span> <span class="c1">// -4</span>
</code></pre></div></div> <p>上面表达式对 <code class="language-plaintext highlighter-rouge">3</code> 进行二进制否运算，得到 <code class="language-plaintext highlighter-rouge">-4</code>。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为 32 位的二进制整数再进行运算。</p> <p><code class="language-plaintext highlighter-rouge">3</code> 的 32 位整数形式是 <code class="language-plaintext highlighter-rouge">00000000000000000000000000000011</code>，二进制否运算以后得到 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111100</code>。由于第一位（符号位）是 1，所以这个数是一个负数。JavaScript 内部采用<strong>补码</strong>形式表示负数，即需要将这个数减去 <code class="language-plaintext highlighter-rouge">1</code>，再取一次反，然后加上负号，才能得到这个负数对应的 10 进制值。这个数减去 1 等于 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111011</code>，再取一次反得到 <code class="language-plaintext highlighter-rouge">00000000000000000000000000000100</code>，再加上负号就是 <code class="language-plaintext highlighter-rouge">-4</code>。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于 <code class="language-plaintext highlighter-rouge">-1</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~</span> <span class="o">-</span><span class="mi">3</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面表达式可以这样算，<code class="language-plaintext highlighter-rouge">-3</code> 的取反值等于 <code class="language-plaintext highlighter-rouge">-1</code> 减去 <code class="language-plaintext highlighter-rouge">-3</code>，结果为 <code class="language-plaintext highlighter-rouge">2</code>。</p> <p>对一个整数连续两次二进制否运算，得到它自身。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~~</span><span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>所有的位运算都只对<strong>整数</strong>有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，<strong>对一个小数连续进行两次二进制否运算，能达到取整效果</strong>。使用二进制<strong>否</strong>运算取整，是所有取整方法中最快的一种。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~~</span><span class="mf">2.9</span> <span class="c1">// 2</span>
<span class="o">~~</span><span class="mf">47.11</span> <span class="c1">// 47</span>
<span class="o">~~</span><span class="mf">1.9999</span> <span class="c1">// 1</span>
<span class="o">~~</span><span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>对字符串进行二进制否运算，JavaScript 引擎会先调用 <code class="language-plaintext highlighter-rouge">Number</code> 函数，将字符串转为数值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于 ~Number('011')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">011</span><span class="dl">'</span>  <span class="c1">// -12</span>

<span class="c1">// 相当于 ~Number('42 cats')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number('0xcafebabe')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">0xcafebabe</span><span class="dl">'</span> <span class="c1">// 889275713</span>

<span class="c1">// 相当于 ~Number('deadbeef')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">deadbeef</span><span class="dl">'</span> <span class="c1">// -1</span>
</code></pre></div></div> <p>对于其他类型的值，二进制否运算也是先用 <code class="language-plaintext highlighter-rouge">Number</code> 转为数值，然后再进行处理。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于 ~Number([])</span>
<span class="o">~</span><span class="p">[]</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number(NaN)</span>
<span class="o">~</span><span class="kc">NaN</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number(null)</span>
<span class="o">~</span><span class="kc">null</span> <span class="c1">// -1</span>
</code></pre></div></div> <h3 id="45-异或运算符">4.5 异或运算符</h3> <p>异或运算（<code class="language-plaintext highlighter-rouge">^</code>）在两个二进制位不同时返回 <code class="language-plaintext highlighter-rouge">1</code>，相同时返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">^</span> <span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面表达式中，<code class="language-plaintext highlighter-rouge">0</code>（二进制 <code class="language-plaintext highlighter-rouge">00</code>）与 <code class="language-plaintext highlighter-rouge">3</code>（二进制 <code class="language-plaintext highlighter-rouge">11</code>）进行异或运算，它们每一个二进制位都不同，所以得到 <code class="language-plaintext highlighter-rouge">11</code>（即 <code class="language-plaintext highlighter-rouge">3</code>）。</p> <p>“异或运算”有一个特殊运用，连续对两个数 <code class="language-plaintext highlighter-rouge">a</code> 和 <code class="language-plaintext highlighter-rouge">b</code> 进行三次异或运算，<code class="language-plaintext highlighter-rouge">a^=b; b^=a; a^=b;</code>，可以<strong>互换</strong>它们的值。这意味着，<strong>“异或运算”可以在不引入临时变量的前提下，互换两个变量的值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>

<span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">b</span> <span class="o">^=</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">;</span>

<span class="nx">a</span> <span class="c1">// 99</span>
<span class="nx">b</span> <span class="c1">// 10</span>
</code></pre></div></div> <p>这是互换两个变量的值的最快方法。</p> <p><strong>异或运算也可以用来取整</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">12.9</span> <span class="o">^</span> <span class="mi">0</span> <span class="c1">// 12</span>
</code></pre></div></div> <h3 id="46-左移运算符">4.6 左移运算符</h3> <p>左移运算符（<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>）表示将一个数的二进制值向左移动指定的位数，尾部补 <code class="language-plaintext highlighter-rouge">0</code>，即乘以 <code class="language-plaintext highlighter-rouge">2</code> 的指定次方。向左移动的时候，最高位的符号位是一起移动的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 4 的二进制形式为100，</span>
<span class="c1">// 左移一位为1000（即十进制的8）</span>
<span class="c1">// 相当于乘以2的1次方</span>
<span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1">// 8</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1">// -8</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">-4</code> 左移一位得到 <code class="language-plaintext highlighter-rouge">-8</code>，是因为 -4 的二进制形式是 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111100</code>，左移一位后得到 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111000</code>，该数转为十进制（减去 <code class="language-plaintext highlighter-rouge">1</code> 后取反，再加上负号）即为 <code class="language-plaintext highlighter-rouge">-8</code>。</p> <p><strong>如果左移 <code class="language-plaintext highlighter-rouge">0</code> 位，就相当于将该数值转为 32 位整数，等同于取整，对于正数和负数都有效</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">13.5</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="c1">// 13</span>

<span class="o">-</span><span class="mf">13.5</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="c1">// -13</span>
</code></pre></div></div> <p>左移运算符用于二进制数值非常方便。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">color</span> <span class="o">=</span> <span class="p">{</span><span class="na">r</span><span class="p">:</span> <span class="mi">186</span><span class="p">,</span> <span class="na">g</span><span class="p">:</span> <span class="mi">218</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">85</span><span class="p">};</span>

<span class="c1">// RGB to HEX</span>
<span class="c1">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span>
<span class="kd">var</span> <span class="nx">rgb2hex</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">r</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">g</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// 先转成十六进制，然后返回字符串</span>
    <span class="p">.</span><span class="nf">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">// 去除字符串的最高位，返回后面六个字符串</span>
<span class="p">}</span>

<span class="nf">rgb2hex</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">r</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
<span class="c1">// "#bada55"</span>
</code></pre></div></div> <p>上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。</p> <h3 id="47-右移运算符">4.7 右移运算符</h3> <p>右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补 <code class="language-plaintext highlighter-rouge">0</code>；如果是负数，头部全部补 <code class="language-plaintext highlighter-rouge">1</code>。右移运算符基本上相当于除以 <code class="language-plaintext highlighter-rouge">2</code> 的指定次方（最高位即符号位参与移动）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>
<span class="cm">/*
// 因为 4 的二进制形式为 00000000000000000000000000000100
// 右移一位得到 00000000000000000000000000000010
// 即为十进制的 2
*/</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// -2</span>
<span class="cm">/*
// 因为 -4 的二进制形式为 11111111111111111111111111111100
// 右移一位，头部补 1，得到 11111111111111111111111111111110
// 即为十进制的 -2
*/</span>
</code></pre></div></div> <p>右移运算可以模拟 2 的整除运算。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>
<span class="c1">// 相当于 5 / 2 = 2</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>
<span class="c1">// 5</span>
<span class="c1">// 相当于 21 / 4 = 5</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
<span class="c1">// 2</span>
<span class="c1">// 相当于 21 / 8 = 2</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
<span class="c1">// 1</span>
<span class="c1">// 相当于 21 / 16 = 1</span>
</code></pre></div></div> <h3 id="48-头部补零的右移运算符">4.8 头部补零的右移运算符</h3> <p>头部补零的右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>）与右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补 <code class="language-plaintext highlighter-rouge">0</code>，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）完全一致，区别主要在于负数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2147483646</span>
<span class="cm">/*
// 因为 -4 的二进制形式为11111111111111111111111111111100
// 带符号位的右移一位，得到 01111111111111111111111111111110
// 即为十进制的 2147483646
*/</span>
</code></pre></div></div> <p>这个运算实际上将一个值转为 32 位无符号整数。</p> <p>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">0</span> <span class="c1">// 4294967295</span>
</code></pre></div></div> <p>上面代码表示，<code class="language-plaintext highlighter-rouge">-1</code> 作为 32 位整数时，内部的储存形式使用无符号整数格式解读，值为 <code class="language-plaintext highlighter-rouge">4294967295</code>（即 <code class="language-plaintext highlighter-rouge">(2^32)-1</code>，等于 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111111</code>）。</p> <h3 id="49-开关作用">4.9 开关作用</h3> <p>位运算符可以用作设置对象属性的开关。</p> <p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">FLAG_A</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 0001</span>
<span class="kd">var</span> <span class="nx">FLAG_B</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 0010</span>
<span class="kd">var</span> <span class="nx">FLAG_C</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 0100</span>
<span class="kd">var</span> <span class="nx">FLAG_D</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// 1000</span>
</code></pre></div></div> <p>上面代码设置 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">C</code>、<code class="language-plaintext highlighter-rouge">D</code> 四个开关，每个开关分别占有一个二进制位。</p> <ul> <li> <p>可以用二进制<strong>与</strong>运算，检查当前设置是否打开了指定开关。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">flags</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 二进制的0101</span>

<span class="k">if </span><span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">FLAG_C</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span>
</code></pre></div> </div> <p>上面代码检验是否打开了开关 <code class="language-plaintext highlighter-rouge">C</code>。如果打开，会返回 <code class="language-plaintext highlighter-rouge">true</code>，否则返回 <code class="language-plaintext highlighter-rouge">false</code>。</p> </li> <li> <p>现在假设需要打开 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">D</code> 三个开关，我们可以构造一个掩码变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mask</span> <span class="o">=</span> <span class="nx">FLAG_A</span> <span class="o">|</span> <span class="nx">FLAG_B</span> <span class="o">|</span> <span class="nx">FLAG_D</span><span class="p">;</span>
<span class="c1">// 0001 | 0010 | 1000 =&gt; 1011</span>
</code></pre></div> </div> <p>上面代码对 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">D</code> 三个变量进行二进制或运算，得到掩码值为二进制的 <code class="language-plaintext highlighter-rouge">1011</code>。</p> <p>有了掩码，二进制<strong>或</strong>运算可以确保打开指定的开关。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags | mask;
</code></pre></div> </div> <p>上面代码中，计算后得到的 <code class="language-plaintext highlighter-rouge">flags</code> 变量，代表三个开关的二进制位都打开了。</p> </li> <li> <p>二进制<strong>与</strong>运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags &amp; mask;
</code></pre></div> </div> </li> <li> <p>异或运算可以<strong>切换</strong>（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags ^ mask;
</code></pre></div> </div> </li> <li> <p>二进制<strong>否</strong>运算可以翻转当前设置，即原设置为 <code class="language-plaintext highlighter-rouge">0</code>，运算后变为 <code class="language-plaintext highlighter-rouge">1</code>；原设置为 <code class="language-plaintext highlighter-rouge">1</code>，运算后变为 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = ~flags;
</code></pre></div> </div> </li> </ul> <h2 id="五其他运算符运算顺序">五、其他运算符，运算顺序</h2> <h3 id="51-void-运算符">5.1 void 运算符</h3> <p><code class="language-plaintext highlighter-rouge">void</code> 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 <code class="language-plaintext highlighter-rouge">undefined</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="mi">0</span> <span class="c1">// undefined</span>
<span class="k">void</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// undefined</span>
</code></pre></div></div> <p>上面是 <code class="language-plaintext highlighter-rouge">void</code> 运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为 <code class="language-plaintext highlighter-rouge">void</code> 运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，<code class="language-plaintext highlighter-rouge">void 4 + 7</code> 实际上等同于 <code class="language-plaintext highlighter-rouge">(void 4) + 7</code>。</p> <p><code class="language-plaintext highlighter-rouge">void</code> 运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">javascript: void(document.form.submit())</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="nx">提交</span>
<span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div></div> <p>上面的代码中，用户点击链接提交表单，但是不产生页面跳转。</p> <h3 id="52-逗号运算符">5.2 逗号运算符</h3> <p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span> <span class="c1">// "b"</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="o">++</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 10</span>
</code></pre></div></div> <p>上面代码中，逗号运算符返回后一个表达式的值。</p> <p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hi!</span><span class="dl">'</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
<span class="c1">// Hi!</span>

<span class="nx">value</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，先执行逗号之前的操作，然后返回逗号后面的值。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/operators/">JavaScript 教程 - 运算符</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 运算符》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">webpack 构建流程</title><link href="https://feng-zhang0712.github.io//blog/2024/build-flow/" rel="alternate" type="text/html" title="webpack 构建流程"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/build-flow</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/build-flow/"><![CDATA[<p>webpack 的构建流程，主要包括初始化、编译、打包、优化和生成输出五个阶段。</p> <h3 id="41-初始化阶段">4.1 初始化阶段</h3> <p>在初始化阶段，webpack 根据配置文件和命令行参数进行初始化工作。包括以下步骤。</p> <ul> <li><strong>读取配置</strong>：读取 webpack 配置文件（<code class="language-plaintext highlighter-rouge">webpack.config.js</code>）并解析配置项。</li> <li><strong>注册插件</strong>：根据配置文件中的 <code class="language-plaintext highlighter-rouge">plugins</code> 项注册所有插件。</li> <li><strong>创建编译器对象</strong>：初始化 <code class="language-plaintext highlighter-rouge">Compiler</code> 对象，这是 webpack 构建的核心引擎，负责整个构建过程的协调工作。</li> <li><strong>应用插件</strong>：调用每个插件的 <code class="language-plaintext highlighter-rouge">apply</code> 方法，将插件挂载到 webpack 的钩子上。</li> <li><strong>触发环境钩子</strong>：触发 <code class="language-plaintext highlighter-rouge">environment</code> 和 <code class="language-plaintext highlighter-rouge">afterEnvironment</code> 等初始化阶段的钩子。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./webpack.config.js</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">webpack</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">webpack</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">compiler</span> <span class="o">=</span> <span class="nf">webpack</span><span class="p">(</span><span class="nx">config</span><span class="p">);</span>

<span class="nx">compiler</span><span class="p">.</span><span class="nf">run</span><span class="p">((</span><span class="nx">err</span><span class="p">,</span> <span class="nx">stats</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">stats</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></div></div> <p>初始化阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">initialize</code>：初始化 webpack。</li> <li><code class="language-plaintext highlighter-rouge">environment</code>：设置环境变量。</li> <li><code class="language-plaintext highlighter-rouge">afterEnvironment</code>：环境变量设置完成。</li> <li><code class="language-plaintext highlighter-rouge">entryOption</code>：处理入口选项。</li> </ul> <h3 id="42-编译阶段">4.2 编译阶段</h3> <p>编译阶段主要负责将源代码转换为 webpack 的模块化表示形式。</p> <ul> <li><strong>确定入口点</strong>：根据配置中的 <code class="language-plaintext highlighter-rouge">entry</code> 项确定入口模块。</li> <li><strong>递归解析模块</strong>：从入口点出发，递归解析依赖的模块。每个模块都会经过相应的 Loader 处理，转换为 webpack 能够理解的模块。</li> <li><strong>生成模块依赖图</strong>：构建模块与模块之间的依赖关系图。</li> </ul> <p>以下是编译阶段的详细流程。</p> <ol> <li><strong>创建 Compilation 对象</strong>：<code class="language-plaintext highlighter-rouge">Compiler</code> 对象会创建一个新的 <code class="language-plaintext highlighter-rouge">Compilation</code> 对象，用来存储当前编译的状态和结果。</li> <li><strong>触发 Compilation 钩子</strong>：触发 <code class="language-plaintext highlighter-rouge">thisCompilation</code> 和 <code class="language-plaintext highlighter-rouge">compilation</code> 钩子，通知插件开始编译。</li> <li><strong>构建模块</strong>： <ul> <li><strong>从入口开始</strong>：从入口模块开始，使用 <code class="language-plaintext highlighter-rouge">loader</code> 对模块进行转换。</li> <li><strong>递归解析</strong>：解析模块的依赖（如 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 语句）并递归处理依赖的模块。</li> <li><strong>生成抽象语法树（AST）</strong>：解析模块代码并生成 AST。</li> <li><strong>应用 Loader</strong>：按照配置的 <code class="language-plaintext highlighter-rouge">loader</code> 对模块进行处理。</li> <li><strong>添加模块到依赖图</strong>：将处理后的模块添加到依赖图中。</li> </ul> </li> </ol> <p>编译阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">beforeCompile</code>：编译开始前。</li> <li><code class="language-plaintext highlighter-rouge">compile</code>：编译阶段开始。</li> <li><code class="language-plaintext highlighter-rouge">thisCompilation</code>：新的 Compilation 创建前。</li> <li><code class="language-plaintext highlighter-rouge">compilation</code>：新的 Compilation 创建后。</li> </ul> <h3 id="43-打包阶段">4.3 打包阶段</h3> <p>打包阶段负责将编译后的模块根据依赖图进行打包，生成一个或多个 Chunk。</p> <ul> <li><strong>生成 Chunk</strong>：根据入口和依赖关系生成 Chunk，每个 Chunk 代表一个输出文件。</li> <li><strong>添加 Chunk 到 Compilation</strong>：将生成的 Chunk 添加到 <code class="language-plaintext highlighter-rouge">Compilation</code> 对象中。</li> </ul> <p>打包阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">make</code>：从入口点开始构建模块。</li> <li><code class="language-plaintext highlighter-rouge">afterCompile</code>：编译完成。</li> </ul> <h3 id="44-优化阶段">4.4 优化阶段</h3> <p>在优化阶段，webpack 会对生成的 Chunk 进行优化，如代码压缩、提取公共模块等。</p> <ul> <li><strong>代码拆分</strong>：提取公共模块、动态导入模块等。</li> <li><strong>压缩代码</strong>：根据配置对代码进行压缩和混淆。</li> <li><strong>其他优化</strong>：如 Tree Shaking、Scope Hoisting 等。</li> </ul> <h3 id="45-生成输出阶段">4.5 生成输出阶段</h3> <p>生成输出阶段负责将优化后的代码输出到指定的目录。</p> <ul> <li><strong>生成输出资源</strong>：根据 Chunk 生成最终的输出文件（如 JavaScript、CSS、HTML 等）。</li> <li><strong>写入文件系统</strong>：将生成的文件写入到输出目录（通常是 <code class="language-plaintext highlighter-rouge">dist</code> 目录）。</li> </ul> <p>以下是生成输出阶段的详细流程。</p> <ol> <li><strong>触发 <code class="language-plaintext highlighter-rouge">emit</code> 钩子</strong>：在写入文件前触发 <code class="language-plaintext highlighter-rouge">emit</code> 钩子，通知插件进行最后的修改或添加额外的文件。</li> <li><strong>写入文件到输出目录</strong>：将生成的文件写入到输出目录。</li> <li><strong>触发 <code class="language-plaintext highlighter-rouge">afterEmit</code> 钩子</strong>：写入文件后触发 <code class="language-plaintext highlighter-rouge">afterEmit</code> 钩子，通知插件输出过程已完成。</li> </ol> <p>生成输出阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">emit</code>：生成资源到输出目录前。</li> <li><code class="language-plaintext highlighter-rouge">afterEmit</code>：生成资源到输出目录后。</li> </ul> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 的构建流程，主要包括初始化、编译、打包、优化和生成输出五个阶段。]]></summary></entry><entry><title type="html">webpack 常用配置项</title><link href="https://feng-zhang0712.github.io//blog/2024/concepts/" rel="alternate" type="text/html" title="webpack 常用配置项"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/concepts</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/concepts/"><![CDATA[<p>webpack 是一个静态模块（比如各种资源文件）打包工具。webpack 会从一个或多个入口点构建依赖图(dependency graph)，然后将项目中所需的每个模块组合成一个或多个 bundles。</p> <h3 id="11-module">1.1 Module</h3> <p>Module（模块） 是 webpack 构建系统的基本单位。在 webpack 中，几乎所有的文件都被视为模块，包括 JavaScript、CSS、HTML、图片、字体等。模块是代码的最小单元，通过导入和导出实现代码的复用和分离。</p> <p>模块封装了特定功能，独立于其他模块。模块之间可以相互依赖，通过 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 引入其他模块。不仅限于 JavaScript 文件，任何资源文件都可以作为模块。</p> <h3 id="12-chunk">1.2 Chunk</h3> <p>Chunk（代码块） 是 webpack 在打包过程中生成的中间产物。每个 Chunk 包含一组紧密相关的模块。最终，一个或多个 Chunk 会被合并成一个 Bundle。</p> <p>Chunk 是 webpack 在打包过程中动态生成的。它使得代码拆分成为可能，可以根据不同的策略（如按需加载）生成多个 Chunk。Chunk 可以通过懒加载或动态导入的方式按需加载，以优化应用的加载性能。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/index.js</span>
<span class="k">import</span><span class="p">(</span><span class="cm">/* webpackChunkName: "moduleA" */</span> <span class="dl">'</span><span class="s1">./moduleA</span><span class="dl">'</span><span class="p">).</span><span class="nf">then</span><span class="p">(({</span> <span class="nx">greeting</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">greeting</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <h3 id="13-bundle">1.3 Bundle</h3> <p>Bundle（包） 是 webpack 打包后的输出文件，它包含了应用程序的所有模块代码。Bundle 是浏览器可以执行的最终文件，通常是一个或多个 JavaScript 文件。</p> <p>Bundle 是 webpack 打包的最终结果。在小型项目中，所有模块可能会被打包成一个单一的 Bundle 文件。在大型项目中，可以使用代码拆分（code splitting）将模块打包成多个 Bundle 文件，以优化加载性能。</p> <h3 id="14-webpack-中的占位符">1.4 webpack 中的占位符</h3> <ol> <li><strong><code class="language-plaintext highlighter-rouge">[name]</code></strong>：表示模块的名称。通常用于多入口配置中，根据入口名称生成文件名。</li> <li><strong><code class="language-plaintext highlighter-rouge">[id]</code></strong>：表示模块的 ID。用于生成文件名中的模块 ID，适用于需要唯一标识模块的场景。</li> <li><strong><code class="language-plaintext highlighter-rouge">[hash]</code></strong>：表示编译时的哈希值。常用于生成具有唯一性的文件名，防止缓存问题。</li> <li><strong><code class="language-plaintext highlighter-rouge">[chunkhash]</code></strong>：表示代码块的哈希值。用于根据代码块内容生成哈希值，适用于代码分割和缓存优化。</li> <li><strong><code class="language-plaintext highlighter-rouge">[contenthash]</code></strong>：表示文件内容的哈希值。适用于根据文件内容生成哈希值，通常用于生成 CSS 文件名。</li> <li><strong><code class="language-plaintext highlighter-rouge">[ext]</code></strong>：表示文件的扩展名。用于保持文件的原始扩展名，适用于文件处理和加载。</li> <li><strong><code class="language-plaintext highlighter-rouge">[path]</code></strong>：表示包含文件的路径。用于生成包含文件路径的文件名，适用于文件管理和组织。</li> <li><strong><code class="language-plaintext highlighter-rouge">[query]</code></strong>：表示文件请求中的查询字符串。用于生成包含查询字符串的文件名，适用于动态加载和参数传递。</li> </ol> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 是一个静态模块（比如各种资源文件）打包工具。webpack 会从一个或多个入口点构建依赖图(dependency graph)，然后将项目中所需的每个模块组合成一个或多个 bundles。]]></summary></entry><entry><title type="html">webpack 常用配置项</title><link href="https://feng-zhang0712.github.io//blog/2024/configuration/" rel="alternate" type="text/html" title="webpack 常用配置项"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/configuration</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/configuration/"><![CDATA[<h3 id="21-entry">2.1 Entry</h3> <p><code class="language-plaintext highlighter-rouge">entry</code> 指定 webpack 构建的入口。webpack 会从入口文件开始构建依赖图。在书写形式上，分为单入口、多入口和数组入口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 单入口文件写法</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/index.js</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 多个入口文件写法，它们将分别生成各自的打包文件</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">app</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/app.js</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">admin</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/admin.js</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 数组入口文件写法，表示多个入口文件将被打包到一个文件中</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">./src/index.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">./src/vendor.js</span><span class="dl">'</span><span class="p">],</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="22-output">2.2 Output</h3> <p><code class="language-plaintext highlighter-rouge">output</code> 指定打包文件的输出位置和文件名。</p> <h3 id="23-module">2.3 Module</h3> <p><code class="language-plaintext highlighter-rouge">module</code> 定义处理不同类型文件模块的规则。即如何处理除 <code class="language-plaintext highlighter-rouge">.js</code> 文件以外的其他资源，例如 CSS、图片、字体等。<code class="language-plaintext highlighter-rouge">module</code> 配置项主要包含 <code class="language-plaintext highlighter-rouge">rules</code> 和 <code class="language-plaintext highlighter-rouge">noParse</code> 两个属性。</p> <h4 id="1-modulerules">(1) <code class="language-plaintext highlighter-rouge">module.rules</code></h4> <p><code class="language-plaintext highlighter-rouge">module.rules</code> 属性是 <code class="language-plaintext highlighter-rouge">module</code> 配置项的核心部分，它是一个数组，每个元素都是一个规则对象，用于定义如何使用 Loader 加载和转换不同类型的模块。<code class="language-plaintext highlighter-rouge">module.rules</code> 对象的主要属性如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">test</code>：一个正则表达式，用于匹配文件路径。</li> <li><code class="language-plaintext highlighter-rouge">exclude</code>：排除的文件路径，通常用于排除 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录。</li> <li><code class="language-plaintext highlighter-rouge">include</code>：包含的文件路径，通常用于指定处理哪些目录下的文件。</li> <li><code class="language-plaintext highlighter-rouge">use</code>：指定使用的加载器（详细方式），可以是单个加载器或加载器数组。</li> <li><code class="language-plaintext highlighter-rouge">loader</code>：指定使用的加载器（简写方式）。</li> <li><code class="language-plaintext highlighter-rouge">options</code>：加载器的选项参数。</li> <li><code class="language-plaintext highlighter-rouge">type</code>：指定模块的类型，例如 <code class="language-plaintext highlighter-rouge">json</code> 等。</li> </ul> <p>以下是一个 <code class="language-plaintext highlighter-rouge">module.rules</code> 配置项的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">png|jpg|gif</span><span class="se">)</span><span class="sr">$/</span><span class="p">,</span> <span class="c1">// 匹配图片文件</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 保持文件名和扩展名</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">images/</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 输出路径</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">woff|woff2|eot|ttf|otf</span><span class="se">)</span><span class="sr">$/</span><span class="p">,</span> <span class="c1">// 匹配字体文件</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 保持文件名和扩展名</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">fonts/</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 输出路径</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>Loader 本质上是一个函数，主要用于在 webpack 构建过程中，将不同类型的文件转换为模块。Loader 可以处理 JavaScript 以外的资源文件，例如 CSS、SCSS、TypeScript、图片等。它们允许你在 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 模块时预处理文件。以下是一些 webpack 中常见的 Loader。</p> <ul> <li><code class="language-plaintext highlighter-rouge">babel-loader</code>：用于将最新的 ES 语法转换为浏览器是别的 JavaScript。</li> <li><code class="language-plaintext highlighter-rouge">style-loader</code>：将 css 添加到样式标签 <code class="language-plaintext highlighter-rouge">style</code> 中。</li> <li><code class="language-plaintext highlighter-rouge">css-loader</code>：允许将 css 文件通过 require 的方式引入，并返回 css 代码。</li> <li><code class="language-plaintext highlighter-rouge">sass-loader:</code>：处理 sass 文件。</li> <li><code class="language-plaintext highlighter-rouge">postcss-loader</code>：用 postcss 来处理 CSS。</li> <li><code class="language-plaintext highlighter-rouge">file-loader</code>：分发文件到 output 目录并返回相对路径。</li> <li><code class="language-plaintext highlighter-rouge">url-loader</code>：和 <code class="language-plaintext highlighter-rouge">file-loader</code> 类似，可以选择性的把图片转成 base64 格式的字符串，并打包到 js 中，比较合适对小图片的处理。</li> <li><code class="language-plaintext highlighter-rouge">html-minify-loader</code>：压缩 HTML。</li> </ul> <p>注意，大部分 Loader 在使用之前要先下载。</p> <h4 id="2modulenoparse">（2）<code class="language-plaintext highlighter-rouge">module.noParse</code></h4> <p><code class="language-plaintext highlighter-rouge">module.noParse</code> 用于配置哪些模块文件不需要解析。通过 <code class="language-plaintext highlighter-rouge">noParse</code>，可以跳过对大型库或文件的解析。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">noParse</span><span class="p">:</span> <span class="sr">/jquery|lodash/</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，告诉 webpack 在进行代码解析式，不解析 <code class="language-plaintext highlighter-rouge">jquery</code> 和 <code class="language-plaintext highlighter-rouge">lodash</code> 库。</p> <h3 id="24-plugins">2.4 Plugins</h3> <p>Plugin 用于扩展 webpack 的功能。它们可以在整个编译生命周期的不同阶段执行更广泛的任务，如 <strong>打包优化</strong>、<strong>环境变量注入</strong>、<strong>代码压缩</strong> 等。Plugin 可以比 Loader 处理更加复杂和多样化的任务。</p> <p>Plugin 是具有 <code class="language-plaintext highlighter-rouge">apply</code> 方法的 JavaScript 对象。这个 <code class="language-plaintext highlighter-rouge">apply</code> 方法在 webpack 启动时被调用，并且插件可以通过 webpack 的钩子机制（hooks）在编译过程的各个阶段插入自己的逻辑。</p> <p>以下是一些 webpack 中常见的 Plugin。</p> <ul> <li><code class="language-plaintext highlighter-rouge">DefinePlugin</code>：允许在编译时创建配置的全局对象，它是一个 webpack 内置的插件，不需要安装。</li> <li><code class="language-plaintext highlighter-rouge">html-webpack-plugin</code>：用于简化 HTML 文件的创建、管理以及注入打包后的 JavaScript 文件。</li> <li><code class="language-plaintext highlighter-rouge">mini-css-extract-plugin</code>：将 CSS 从 JavaScript 中提取出来，生成独立的 CSS 文件。</li> <li><code class="language-plaintext highlighter-rouge">css-minimizer-webpack-plugin</code></li> <li><code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code></li> </ul> <h3 id="25-mode">2.5 Mode</h3> <p><code class="language-plaintext highlighter-rouge">mode</code> 用于设置构建模式，影响 webpack 内置的优化功能。webpack 提供了三种模式。</p> <ul> <li><code class="language-plaintext highlighter-rouge">development</code>：用于开发环境。在这个模式下， 主要侧重于提升构建速度和开发体验。在此模式下， webpack 不会压缩代码，并且会启用 Source Map、HMR（热模块替换）和详细的日志。</li> <li><code class="language-plaintext highlighter-rouge">production</code>：用于生产环境。在这个模式下， 主要侧重于优化代码体积和运行性能。在此模式下， webpack 会启用代码压缩和混淆、自动移除未使用的代码（Tree Shaking）和启用各种优化（如代码拆分、作用域提升）等。</li> <li><code class="language-plaintext highlighter-rouge">none</code>：不应用任何默认优化或配置。在这个模式下，只会按照配置文件中的指示进行打包，而不进行额外的优化和处理。</li> </ul> <h3 id="26-resolve">2.6 Resolve</h3> <p><code class="language-plaintext highlighter-rouge">resolve</code> 控制模块解析的行为。包括定义模块路径的查找方式、文件扩展名的解析顺序、别名等。<code class="language-plaintext highlighter-rouge">resolve</code> 的主要配置项如下。</p> <h4 id="1resolvealias">（1）<code class="language-plaintext highlighter-rouge">resolve.alias</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.alias</code> 用于为模块路径创建别名。通过别名，可以简化模块引用的路径。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">alias</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">@components</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/components/</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">import</span> <span class="nx">Button</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@components/Button</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p>上面的代码中，我们为 <code class="language-plaintext highlighter-rouge">src/components/</code> 目录指定了一个别名 <code class="language-plaintext highlighter-rouge">@components</code>，这样在导入模块时，就可以使用 <code class="language-plaintext highlighter-rouge">import xxx from '@components/xxx'</code> 的形式，而不必每次都写前边的路径。</p> <h4 id="2resolveextensions">（2）<code class="language-plaintext highlighter-rouge">resolve.extensions</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.extensions</code> 定义在解析模块时可以省略的文件扩展名。默认值是 <code class="language-plaintext highlighter-rouge">['.js', '.json']</code>。</p> <h4 id="3resolvemodules">（3）<code class="language-plaintext highlighter-rouge">resolve.modules</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.modules</code> 指定解析模块时要搜索的目录。默认值是 [‘node_modules’]。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">modules</span><span class="p">:</span> <span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">import</span> <span class="nx">Util</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">utils/util</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 实际引入的是 'src/utils/util.js'</span>
</code></pre></div></div> <p>上面的代码，我们指定了 <code class="language-plaintext highlighter-rouge">resolve.modules</code> 的目录为 <code class="language-plaintext highlighter-rouge">src</code> 和 <code class="language-plaintext highlighter-rouge">node_modules</code>。这样，在导入模块时，webpack 会首先去 <code class="language-plaintext highlighter-rouge">src</code> 目录下寻找，如果找不到，就去 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录下寻找。</p> <h4 id="4resolvefallback">（4）<code class="language-plaintext highlighter-rouge">resolve.fallback</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.fallback</code> 指定当模块在指定目录中找不到时，应该回退到哪个目录进行查找。常用于处理某些模块在特定环境下的缺失问题。</p> <h4 id="5resolveplugins">（5）<code class="language-plaintext highlighter-rouge">resolve.plugins</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.plugins</code> 用于配置一些自定义的解析插件。可以定义自己的解析规则或使用现成的解析插件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">alias</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">@components</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/components/</span><span class="dl">'</span><span class="p">),</span>
      <span class="dl">'</span><span class="s1">@utils</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/utils/</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
    <span class="na">extensions</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.jsx</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.json</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.ts</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.tsx</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">modules</span><span class="p">:</span> <span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">fallback</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">:</span> <span class="nx">require</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">path-browserify</span><span class="dl">'</span><span class="p">),</span>
      <span class="dl">'</span><span class="s1">crypto</span><span class="dl">'</span><span class="p">:</span> <span class="nx">require</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">crypto-browserify</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
     <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
      <span class="c1">// 在此添加解析插件</span>
    <span class="p">],</span>

    <span class="c1">// 其他配置...</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="27-devtool">2.7 Devtool</h3> <p><code class="language-plaintext highlighter-rouge">devtool</code> 用于控制生成 source map 的方式。source map 用于将编译后的代码映射回源代码，有助于调试和错误追踪。常见的 <code class="language-plaintext highlighter-rouge">devtool</code> 配置有如下几个。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">cheap-module-source-map</code></strong>：类似于 cheap-source-map，对 loader 处理后的代码也生成 source map。优点是构建速度较快，适合调试经过 loader 处理的代码。缺点是调试时无法准确定位到列，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">source-map</code></strong>：生成独立的 <code class="language-plaintext highlighter-rouge">.map</code> 文件，提供完整的 source map。优点是可以查看源文件及其位置。缺点是构建速度慢，适合生产环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">eval</code></strong>：使用 <code class="language-plaintext highlighter-rouge">eval</code> 生成每个模块的 source map。优点是构建速度最快，缺点是生成的 source map 不支持断点调试，适合快速开发和调试。</li> <li><strong><code class="language-plaintext highlighter-rouge">inline-source-map</code></strong>：将 source map 作为 Data URL 内嵌在编译后的代码中。优点是调试体验好，构建速度较快。缺点是会增加文件体积，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">cheap-source-map</code></strong>：生成独立的 source map 文件，但不包含列信息。优点是构建速度较快，适合开发环境。缺点是调试时无法准确定位到列，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">eval-source-map</code></strong>：每个模块使用 eval 生成 source map，并将 source map 作为 Data URL 内嵌。优点是构建速度快，调试体验好。适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">hidden-source-map</code></strong>：生成独立的 source map 文件，但不在编译后的代码中引用。优点是保护源代码，但仍然可以使用 source map 进行调试。缺点是需要手动关联 source map 文件，适合生产环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">nosources-source-map</code></strong>：生成独立的 source map 文件，但隐藏源文件内容。优点是保护源代码内容，但提供错误信息的映射。缺点是不能查看源代码，适合生产环境。</li> </ul> <p>多数情况下，在开发中主要使用 <code class="language-plaintext highlighter-rouge">cheap-module-source-map</code>；而在生产环境中，主要使用 <code class="language-plaintext highlighter-rouge">source-map</code>。</p> <h3 id="28-devserver">2.8 DevServer</h3> <p><code class="language-plaintext highlighter-rouge">devServer</code> 用于配置开发服务器。即设置开发环境中的本地服务器，以便进行实时预览、热模块替换（HMR）、代理请求等操作。<code class="language-plaintext highlighter-rouge">devServer</code> 常见的配置项如下。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">contentBase</code></strong>：指定开发服务器的根目录，即服务器将从哪个目录提供文件。</li> <li><strong><code class="language-plaintext highlighter-rouge">https</code></strong>：是否启用 HTTPS 协议。</li> <li><strong><code class="language-plaintext highlighter-rouge">host</code></strong>：指定开发服务器的主机名。</li> <li><strong><code class="language-plaintext highlighter-rouge">port</code></strong>：指定开发服务器的端口号。</li> <li><strong><code class="language-plaintext highlighter-rouge">open</code></strong>：是否自动打开浏览器。</li> <li><strong><code class="language-plaintext highlighter-rouge">hot</code></strong>：是否启用模块热替换（HMR）。</li> <li><strong><code class="language-plaintext highlighter-rouge">proxy</code></strong>：配置代理，将特定请求转发到其他服务器。</li> <li><strong><code class="language-plaintext highlighter-rouge">compress</code></strong>：是否启用 gzip 压缩。</li> <li><strong><code class="language-plaintext highlighter-rouge">before</code></strong> 和 <strong><code class="language-plaintext highlighter-rouge">after</code></strong>：在开发服务器启动之前或之后执行特定的中间件函数。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">devServer</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">contentBase</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">dist</span><span class="dl">'</span><span class="p">),</span> <span class="c1">// 指定根目录</span>
    <span class="na">https</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">// 使用 HTTP 协议</span>
    <span class="na">host</span><span class="p">:</span> <span class="dl">'</span><span class="s1">0.0.0.0</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 指定主机名</span>
    <span class="na">port</span><span class="p">:</span> <span class="mi">3000</span><span class="p">,</span> <span class="c1">// 指定端口号</span>
    <span class="na">open</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 自动打开浏览器</span>
    <span class="na">hot</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用模块热替换</span>
    <span class="na">proxy</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">/api</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">target</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http://localhost:3000</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">changeOrigin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">},</span>
    <span class="na">compress</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用 gzip 压缩</span>
    <span class="na">before</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">server</span><span class="p">,</span> <span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/some/path</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">({</span> <span class="na">custom</span><span class="p">:</span> <span class="dl">'</span><span class="s1">response</span><span class="dl">'</span> <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">},</span>
    <span class="na">after</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">server</span><span class="p">,</span> <span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Dev server is running!</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="c1">// 其他配置项...</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="29-optimization">2.9 Optimization</h3> <p><code class="language-plaintext highlighter-rouge">optimization</code> 控制构建过程中的优化行为。以下是常见的 <code class="language-plaintext highlighter-rouge">optimization</code> 配置项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">splitChunks</code></strong>：用于将代码拆分成更小的块，以实现代码的按需加载和更好的缓存策略。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimize</code></strong>：是否启用代码压缩。一般在生产环境中使用。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimizer</code></strong>：自定义代码压缩工具和压缩选项。默认使用 TerserPlugin 进行 JavaScript 代码压缩。</li> <li><strong><code class="language-plaintext highlighter-rouge">providedExports</code></strong>：用于告诉 webpack 是否分析每个模块提供的导出内容。默认值为 true。</li> <li><strong><code class="language-plaintext highlighter-rouge">usedExports</code></strong>：用于启用 Tree Shaking，去除未使用的导出。默认值为 true。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TerserPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">terser-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">splitChunks</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 对所有类型的代码进行分离</span>
    <span class="p">},</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用代码压缩</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span><span class="k">new</span> <span class="nc">TerserPlugin</span><span class="p">({</span>
      <span class="na">terserOptions</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">compress</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">drop_console</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除 console 语句</span>
        <span class="p">},</span>
      <span class="p">},</span>
    <span class="p">})],</span>
    <span class="na">runtimeChunk</span><span class="p">:</span> <span class="dl">'</span><span class="s1">single</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 提取运行时代码到单独的 chunk</span>
    <span class="na">moduleIds</span><span class="p">:</span> <span class="dl">'</span><span class="s1">deterministic</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 使用确定性的模块 ID</span>
    <span class="na">chunkIds</span><span class="p">:</span> <span class="dl">'</span><span class="s1">deterministic</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 使用确定性的 chunk ID</span>
    <span class="na">mangleWasmImports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 压缩 WebAssembly 导入名称</span>
    <span class="na">removeAvailableModules</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除可用的模块</span>
    <span class="na">removeEmptyChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除空的 chunk</span>
    <span class="na">mergeDuplicateChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 合并重复的 chunk</span>
    <span class="na">flagIncludedChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 标记包含的 chunk</span>
    <span class="na">providedExports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">usedExports</span><span class="p">:</span> <span class="kc">true</span>
    <span class="na">sideEffects</span><span class="p">:</span> <span class="kc">true</span>
    <span class="na">nodeEnv</span><span class="p">:</span> <span class="dl">'</span><span class="s1">production</span><span class="dl">'</span>
    <span class="na">realContentHash</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[2.1 Entry]]></summary></entry><entry><title type="html">webpack 项目优化</title><link href="https://feng-zhang0712.github.io//blog/2024/optimization/" rel="alternate" type="text/html" title="webpack 项目优化"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/optimization</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/optimization/"><![CDATA[<h3 id="61-启用代码压缩">6.1 启用代码压缩</h3> <h4 id="1压缩-html-代码">（1）压缩 HTML 代码</h4> <p><code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 用于简化 HTML 文件的创建、管理以及注入打包后的 JavaScript 文件。下面列出了一些 <code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 常用的配置项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">title</code></strong>：页面的标题，会被插入到 <code class="language-plaintext highlighter-rouge">&lt;title&gt;</code> 标签中。</li> <li><strong><code class="language-plaintext highlighter-rouge">filename</code></strong>：生成的 HTML 文件的名称，默认是 <code class="language-plaintext highlighter-rouge">index.html</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">template</code></strong>：指定模板文件的路径。</li> <li><strong><code class="language-plaintext highlighter-rouge">inject</code></strong>：注入选项，默认为 <code class="language-plaintext highlighter-rouge">true</code>，表示将打包的资源注入到生成的 HTML 文件中。它可以是 <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code>、<code class="language-plaintext highlighter-rouge">'head'</code> 或者 <code class="language-plaintext highlighter-rouge">'body'</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">favicon</code></strong>：指定 favicon 文件的路径。</li> <li><strong><code class="language-plaintext highlighter-rouge">meta</code></strong>：注入页面的 <code class="language-plaintext highlighter-rouge">meta</code> 标签，可以是一个对象。</li> <li><strong><code class="language-plaintext highlighter-rouge">hash</code></strong>：如果为 <code class="language-plaintext highlighter-rouge">true</code>，则会在所有的资源文件后面加一个唯一的 hash，防止缓存。</li> <li><strong><code class="language-plaintext highlighter-rouge">minify</code></strong>：用于控制生成的 HTML 文件的代码压缩。这个属性接受一个对象，内含多个配置选项，分别控制不同的压缩行为。</li> </ul> <p>通过配置 <code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 的 <code class="language-plaintext highlighter-rouge">minify</code> 属性来压缩 HTML 代码。以下是 <code class="language-plaintext highlighter-rouge">minify</code> 属性的常用选项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">collapseWhitespace</code></strong>：压缩 HTML 中的空白。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeComments</code></strong>：移除 HTML 中的注释。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeRedundantAttributes</code></strong>：移除多余的属性（如 <code class="language-plaintext highlighter-rouge">&lt;input type="text"&gt;</code> 中的 <code class="language-plaintext highlighter-rouge">type="text"</code>）。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeScriptTypeAttributes</code></strong>：移除 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签中的 <code class="language-plaintext highlighter-rouge">type="text/javascript"</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeStyleLinkTypeAttributes</code></strong>：移除 <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;style&gt;</code> 标签中的 <code class="language-plaintext highlighter-rouge">type="text/css"</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">useShortDoctype</code></strong>：将文档类型简化为 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">minifyCSS</code></strong>：压缩内联的 CSS。</li> <li><strong><code class="language-plaintext highlighter-rouge">minifyJS</code></strong>：压缩内联的 JavaScript。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HtmlWebpackPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">html-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nc">HtmlWebpackPlugin</span><span class="p">({</span>
      <span class="na">template</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/index.html</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">minify</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">collapseWhitespace</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeComments</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeRedundantAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeScriptTypeAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeStyleLinkTypeAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">useShortDoctype</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minifyCSS</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minifyJS</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">]</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="2压缩-css-代码">（2）压缩 CSS 代码</h4> <p><code class="language-plaintext highlighter-rouge">css-minimizer-webpack-plugin</code> 是一个用于压缩 CSS 代码的 Webpack 插件，它基于 cssnano 提供的优化功能，能够有效地减少 CSS 文件的体积，从而提升加载性能。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">test</code></strong>：匹配需要压缩的文件，默认值是 <code class="language-plaintext highlighter-rouge">/\.css$/i</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">parallel</code></strong>：启用并行压缩以提升构建速度，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimizerOptions</code></strong>：传递给 cssnano 的配置选项。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">CssMinimizerPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">css-minimizer-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">`...`</span><span class="p">,</span>
      <span class="k">new</span> <span class="nc">CssMinimizerPlugin</span><span class="p">({</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.</span><span class="sr">css$/i</span><span class="p">,</span>
        <span class="na">parallel</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minimizerOptions</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">preset</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">'</span><span class="s1">default</span><span class="dl">'</span><span class="p">,</span>
            <span class="p">{</span>
              <span class="na">discardComments</span><span class="p">:</span> <span class="p">{</span> <span class="na">removeAll</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span> <span class="c1">// 移除所有注释</span>
            <span class="p">},</span>
          <span class="p">],</span>
        <span class="p">},</span>
      <span class="p">}),</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="3压缩-javascript-代码">（3）压缩 JavaScript 代码</h4> <p><code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code> 用于压缩和优化 JavaScript 代码。它基于 Terser，一个 JavaScript 解析器、压缩器、美化器和 AST 工具包。<code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code> 是 Webpack 内置的 JavaScript 压缩插件，在生产环境下默认使用，可以通过自定义配置优化其行为。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">test</code></strong>：匹配需要压缩的文件，默认值是 <code class="language-plaintext highlighter-rouge">/\.m?js(\?.*)?$/i</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">parallel</code></strong>：启用并行压缩以提升构建速度，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">extractComments</code></strong>：提取注释到单独的文件中，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">terserOptions</code></strong>：传递给 Terser 的配置选项，详细配置见 Terser Options。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TerserPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">terser-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span>
      <span class="k">new</span> <span class="nc">TerserPlugin</span><span class="p">({</span>
        <span class="na">parallel</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">extractComments</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">terserOptions</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">compress</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">drop_console</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="p">},</span>
          <span class="na">format</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">comments</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="p">},</span>
        <span class="p">},</span>
      <span class="p">}),</span>
    <span class="p">],</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="62-图片压缩">6.2 图片压缩</h3> <p><code class="language-plaintext highlighter-rouge">file-loader</code> 的主要作用是将文件导出到输出目录，并返回文件的 URL。它可以处理各种类型的文件，包括图片、字体、音频、视频等。以下是几个常用的 <code class="language-plaintext highlighter-rouge">file-loader</code> 配置项。</p> <ul> <li><code class="language-plaintext highlighter-rouge">name</code>：设置文件的命名格式，可以使用占位符（如 <code class="language-plaintext highlighter-rouge">[name]</code>、<code class="language-plaintext highlighter-rouge">[ext]</code>、<code class="language-plaintext highlighter-rouge">[hash]</code> 等）。</li> <li><code class="language-plaintext highlighter-rouge">outputPath</code>：设置文件输出目录，可以是相对于输出路径的相对路径。</li> <li><code class="language-plaintext highlighter-rouge">publicPath</code>：设置文件的公共路径（通常用于 CDN）。</li> <li><code class="language-plaintext highlighter-rouge">emitFile</code>：是否输出文件，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> </ul> <p><code class="language-plaintext highlighter-rouge">image-webpack-loader</code> 是一个图片压缩加载器，可以结合 <code class="language-plaintext highlighter-rouge">file-loader</code> 使用，处理后的图片会自动进行压缩优化，从而减少文件体积，提高加载性能。以下是几个常用的 <code class="language-plaintext highlighter-rouge">image-webpack-loader</code> 配置项。</p> <ul> <li><code class="language-plaintext highlighter-rouge">mozjpeg</code>：配置 <code class="language-plaintext highlighter-rouge">mozjpeg</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">progressive</code>：是否开启渐进式 JPEG。</li> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量，范围是 0-100。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">optipng</code>：配置 <code class="language-plaintext highlighter-rouge">optipng</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">enabled</code>：是否开启 <code class="language-plaintext highlighter-rouge">optipng</code> 压缩。</li> <li><code class="language-plaintext highlighter-rouge">optimizationLevel</code>：优化级别，范围是 0-7。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">pngquant</code>：配置 <code class="language-plaintext highlighter-rouge">pngquant</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量范围，如 [0.65, 0.90]。</li> <li><code class="language-plaintext highlighter-rouge">speed</code>：压缩速度，范围是 1-11。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">gifsicle</code>：配置 <code class="language-plaintext highlighter-rouge">gifsicle</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">interlaced</code>：是否开启交错模式。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">webp</code>：配置 <code class="language-plaintext highlighter-rouge">webp</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量，范围是 0-100。</li> </ul> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HtmlWebpackPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">html-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">png|jpe</span><span class="se">?</span><span class="sr">g|gif|svg</span><span class="se">)</span><span class="sr">$/i</span><span class="p">,</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">images/</span><span class="dl">'</span><span class="p">,</span>
            <span class="p">},</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">image-webpack-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">mozjpeg</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">progressive</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
                <span class="na">quality</span><span class="p">:</span> <span class="mi">65</span><span class="p">,</span>
              <span class="p">},</span>
              <span class="na">optipng</span><span class="p">:</span> <span class="p">{</span> <span class="na">enabled</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span>
              <span class="na">pngquant</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">quality</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.90</span><span class="p">],</span>
                <span class="na">speed</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
              <span class="p">},</span>
              <span class="na">gifsicle</span><span class="p">:</span> <span class="p">{</span> <span class="na">interlaced</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
              <span class="na">webp</span><span class="p">:</span> <span class="p">{</span> <span class="na">quality</span><span class="p">:</span> <span class="mi">75</span> <span class="p">},</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="63-tree-shaking">6.3 Tree Shaking</h3> <p>Tree Shaking 通过在编译时分析模块的依赖关系，移除那些没有被引用的代码，从而减少最终打包文件的体积。为了启用 Tree Shaking，需要使用 ES6 模块语法（import/export）并配置 optimization。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">usedExports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用 Tree Shaking</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="64-代码分离code-splitting">6.4 代码分离（Code Splitting）</h3> <p>将代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件。默认情况下，所有的 JavaScript 代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度。代码分离可以分出出更小的 bundle，以及控制资源加载优先级，提供代码的加载性能。</p> <p>SplitChunksPlugin 是 Webpack 提供的一个内置插件，可以用于实现代码分离（code splitting）。SplitChunksPlugin 的常用配置如下。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">chunks</code></strong>：可以是 <code class="language-plaintext highlighter-rouge">'all'</code>、<code class="language-plaintext highlighter-rouge">'async'</code> 或 <code class="language-plaintext highlighter-rouge">'initial'</code>。指定要分离的块类型。</li> <li><strong><code class="language-plaintext highlighter-rouge">minSize</code></strong>：生成块的最小大小（以字节为单位），默认值为 30000。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxSize</code></strong>：生成块的最大大小（以字节为单位），超过此大小会进一步分离。</li> <li><strong><code class="language-plaintext highlighter-rouge">minChunks</code></strong>：最少引用次数，文件被引用次数超过此值时才会被分离，默认值为 1。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxAsyncRequests</code></strong>：按需加载时的最大并行请求数，默认值为 6。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxInitialRequests</code></strong>：入口点的最大并行请求数，默认值为 4。</li> <li><strong><code class="language-plaintext highlighter-rouge">automaticNameDelimiter</code></strong>：生成名称时的分隔符，默认值为 ~。</li> <li><strong><code class="language-plaintext highlighter-rouge">name</code></strong>：指定分离块的名称，可以是 <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code> 或者一个函数。</li> <li><strong><code class="language-plaintext highlighter-rouge">cacheGroups</code></strong>：指定缓存组，为不同的分离规则定义不同的缓存组。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">splitChunks</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">minSize</span><span class="p">:</span> <span class="mi">20000</span><span class="p">,</span>
      <span class="na">maxSize</span><span class="p">:</span> <span class="mi">70000</span><span class="p">,</span>
      <span class="na">minChunks</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">maxAsyncRequests</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
      <span class="na">maxInitialRequests</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="na">automaticNameDelimiter</span><span class="p">:</span> <span class="dl">'</span><span class="s1">~</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">cacheGroups</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">vendors</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">[\\/]</span><span class="sr">node_modules</span><span class="se">[\\/]</span><span class="sr">/</span><span class="p">,</span>
          <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">vendors</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="na">default</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">minChunks</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
          <span class="na">priority</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
          <span class="na">reuseExistingChunk</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="p">},</span>
      <span class="p">},</span>
    <span class="p">},</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，我们定义了两个缓存组。<code class="language-plaintext highlighter-rouge">vendors</code> 缓存组用来将所有来自 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录的模块分离到一个名为 <code class="language-plaintext highlighter-rouge">vendors</code> 的块中。<code class="language-plaintext highlighter-rouge">default</code> 缓存组用来将被至少两次引用的模块分离到一个默认块中，并且优先级较低。</p> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[6.1 启用代码压缩]]></summary></entry><entry><title type="html">webpack 的发布-订阅模式</title><link href="https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model/" rel="alternate" type="text/html" title="webpack 的发布-订阅模式"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model/"><![CDATA[<h3 id="31-什么是发布-订阅模式">3.1 什么是发布-订阅模式？</h3> <p><strong>发布-订阅模式</strong> 是一种设计模式，其中一个主体（发布者）维护一系列依赖其状态的观察者（订阅者）。发布者在状态变化时向观察者发送通知，而观察者可以选择性地对这些通知做出响应。</p> <p>webpack 的插件系统基于发布-订阅模式。这个模式允许 webpack 在构建过程的不同阶段广播事件，插件可以订阅这些事件并在适当的时机执行特定的任务。</p> <p>在 webpack 中，发布者是 webpack 本身，它在构建过程的不同阶段广播事件。订阅者是 webpack 插件，它们订阅感兴趣的事件并在这些事件触发时执行特定逻辑。</p> <h3 id="32-webpack-生命周期广播事件">3.2 webpack 生命周期广播事件</h3> <p>webpack 在其构建生命周期的不同阶段会广播一系列事件。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">initialize</code></strong>：初始化阶段，webpack 构建过程开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">environment</code></strong>：设置环境变量。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterEnvironment</code></strong>：环境变量设置完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">entryOption</code></strong>：处理入口选项。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterPlugins</code></strong>：插件初始化完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterResolvers</code></strong>：解析器初始化完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">beforeRun</code></strong>：构建过程开始前。</li> <li><strong><code class="language-plaintext highlighter-rouge">run</code></strong>：构建过程开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">beforeCompile</code></strong>：编译前准备阶段。</li> <li><strong><code class="language-plaintext highlighter-rouge">compile</code></strong>：编译阶段开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">thisCompilation</code></strong>：新的 Compilation 创建前。</li> <li><strong><code class="language-plaintext highlighter-rouge">compilation</code></strong>：新的 Compilation 创建后。</li> <li><strong><code class="language-plaintext highlighter-rouge">make</code></strong>：从入口点开始构建模块。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterCompile</code></strong>：编译完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">emit</code></strong>：生成资源到输出目录前。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterEmit</code></strong>：生成资源到输出目录后。</li> <li><strong><code class="language-plaintext highlighter-rouge">done</code></strong>：构建过程完成。</li> </ul> <h3 id="33-插件如何与广播事件协调工作">3.3 插件如何与广播事件协调工作</h3> <p>webpack 插件通过订阅这些事件来协调工作。插件在注册时将其逻辑挂载到特定的事件上，当事件被触发时，插件的逻辑会自动执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyPlugin</span> <span class="p">{</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 插件的逻辑</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is my plugin!</span><span class="dl">'</span><span class="p">);</span>
      <span class="nf">callback</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">MyPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>上面代码是一个自定义的插件，其中：</p> <ul> <li><code class="language-plaintext highlighter-rouge">apply</code> 方法用于注册插件。</li> <li><code class="language-plaintext highlighter-rouge">compiler</code> 对象是 webpack 编译器实例，提供了绑定事件的钩子（hooks）。</li> <li><code class="language-plaintext highlighter-rouge">compiler.hooks.emit</code> 表示 <code class="language-plaintext highlighter-rouge">emit</code> 事件的钩子。<code class="language-plaintext highlighter-rouge">tapAsync</code> 方法用于异步钩子，注册一个回调函数，该函数将在 <code class="language-plaintext highlighter-rouge">emit</code> 事件被触发时执行。</li> </ul> <h3 id="34-webpack-插件与生命周期事件的工作流程">3.4 webpack 插件与生命周期事件的工作流程</h3> <ol> <li>插件注册：插件通过 <code class="language-plaintext highlighter-rouge">apply</code> 方法注册到 webpack 编译器。在 <code class="language-plaintext highlighter-rouge">apply</code> 方法中，插件通过 <code class="language-plaintext highlighter-rouge">compiler</code> 对象的钩子（hooks）订阅感兴趣的事件。</li> <li>事件触发：webpack 在构建过程的不同阶段触发事件。当事件被触发时，所有订阅了该事件的插件都将依次执行其注册的回调函数。</li> <li>回调执行：插件的回调函数执行其特定的逻辑。例如，修改编译资源、生成额外的文件、优化输出等。</li> </ol> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">class</span> <span class="nc">MyPlugin</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">options</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 生成一个额外的文件</span>
      <span class="kd">const</span> <span class="nx">content</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">This is a generated file</span><span class="dl">'</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">outputPath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nx">compiler</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">output</span><span class="p">.</span><span class="nx">path</span><span class="p">,</span> <span class="dl">'</span><span class="s1">generated-file.txt</span><span class="dl">'</span><span class="p">);</span>

      <span class="nx">compilation</span><span class="p">.</span><span class="nx">assets</span><span class="p">[</span><span class="dl">'</span><span class="s1">generated-file.txt</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">source</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">content</span><span class="p">,</span>
        <span class="na">size</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">content</span><span class="p">.</span><span class="nx">length</span>
      <span class="p">};</span>

      <span class="c1">// 写入文件到输出目录</span>
      <span class="nx">fs</span><span class="p">.</span><span class="nf">writeFile</span><span class="p">(</span><span class="nx">outputPath</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">The file has been saved!</span><span class="dl">'</span><span class="p">);</span>
        <span class="nf">callback</span><span class="p">();</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">MyPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>上面的代码，是一个自定义的插件，它会在 <code class="language-plaintext highlighter-rouge">emit</code> 阶段生成一个额外的文件。</p> <ul> <li>插件在 <code class="language-plaintext highlighter-rouge">emit</code> 阶段生成一个名为 <code class="language-plaintext highlighter-rouge">generated-file.txt</code> 的文件，并将其内容设置为 <code class="language-plaintext highlighter-rouge">"This is a generated file"</code>。</li> <li>通过 <code class="language-plaintext highlighter-rouge">compilation.assets</code> 将生成的文件添加到 webpack 的资源管理中。</li> <li>异步写入文件到输出目录，当写入完成后调用 <code class="language-plaintext highlighter-rouge">callback</code> 以通知 webpack 继续构建过程。</li> </ul> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[3.1 什么是发布-订阅模式？]]></summary></entry><entry><title type="html">webpack 中的 Loader</title><link href="https://feng-zhang0712.github.io//blog/2024/loader/" rel="alternate" type="text/html" title="webpack 中的 Loader"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/loader</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/loader/"><![CDATA[<p>loader 本质上是导出为函数的 JavaScript 模块。<a href="https://github.com/webpack/loader-runner">loader runner</a> 会调用此函数，然后将上一个 loader 产生的结果或者资源文件传入进去。函数中的 <code class="language-plaintext highlighter-rouge">this</code> 作为上下文会被 webpack 填充，并且 loader runner 中包含一些实用的方法，比如可以使 loader 调用方式变为异步，或者获取 <code class="language-plaintext highlighter-rouge">query</code> 参数。</p> <p>如果是单个处理结果，可以在 <a href="#1同步-loader">同步模式</a> 中直接返回。如果有多个处理结果，则必须调用 <code class="language-plaintext highlighter-rouge">this.callback()</code>。在 <a href="#2异步-loader">异步模式</a> 中，必须调用 <code class="language-plaintext highlighter-rouge">this.async()</code> 来告知 loader runner 等待异步结果，它会返回 <code class="language-plaintext highlighter-rouge">this.callback()</code> 回调函数。随后 loader 必须返回 <code class="language-plaintext highlighter-rouge">undefined</code> 并且调用该回调函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *
 * @param {string|Buffer} content 源文件的内容
 * @param {object} [map] 可以被 https://github.com/mozilla/source-map 使用的 SourceMap 数据
 * @param {any} [meta] meta 数据，可以是任何内容
 */</span>
<span class="kd">function</span> <span class="nf">webpackLoader</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>loader 分为几种不同的类型，他们是同步 Loader、异步 Loader、Raw Loader 和 Pitching Loader。</p> <h2 id="loader-分类">Loader 分类</h2> <h3 id="1同步-loader">（1）同步 Loader</h3> <p>通过 <code class="language-plaintext highlighter-rouge">return</code> 或者 <code class="language-plaintext highlighter-rouge">this.callback()</code> 同步地返回处理后的 <code class="language-plaintext highlighter-rouge">content</code> 值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">return</code> 返回处理之后的 <code class="language-plaintext highlighter-rouge">content</code>，然后交由 webpack 或者之后的 <code class="language-plaintext highlighter-rouge">loader</code> 继续处理。</p> <p>除了使用 <code class="language-plaintext highlighter-rouge">return</code> 关键词，还可以使用 <code class="language-plaintext highlighter-rouge">this.callback()</code>，后者的优点是更灵活，因为它允许传递多个参数，而不仅仅是 <code class="language-plaintext highlighter-rouge">content</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">),</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">);</span>

  <span class="c1">// 当调用 callback() 函数时，总是返回 undefined</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="2异步-loader">（2）异步 Loader</h3> <p>异步 loader 使用 <code class="language-plaintext highlighter-rouge">this.async()</code> 来获取 callback 函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="k">async</span><span class="p">();</span>
  <span class="nf">someAsyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nf">callback</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="3raw-loader">（3）Raw Loader</h3> <p>默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。通过设置 <code class="language-plaintext highlighter-rouge">raw</code> 为 <code class="language-plaintext highlighter-rouge">true</code>，loader 可以接收原始的 Buffer。每个 loader 都可以用 String 或者 Buffer 的形式传递它的处理结果。complier 会把它们在 loader 之间相互转换。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">assert</span><span class="p">(</span><span class="nx">content</span> <span class="k">instanceof</span> <span class="nx">Buffer</span><span class="p">);</span>

  <span class="c1">// 返回值也可以是一个 `Buffer`</span>
  <span class="c1">// 即使不是 "raw"，loader 也没问题</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">raw</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div> <h3 id="4pitching-loader">（4）Pitching Loader</h3> <p>loader <strong>总是</strong>从右到左被调用。有些情况下，loader 只关心 request 后面的<strong>元数据</strong>（metadata），并且忽略前一个 loader 的结果。在实际（从右到左）执行 loader 之前，会先<strong>从左到右</strong>调用 loader 上的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>假如我们有以下配置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">//...</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a-loader</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b-loader</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c-loader</span><span class="dl">'</span><span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，会按照下面的顺序执行。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|- a-loader `pitch`
  |- b-loader `pitch`
    |- c-loader `pitch`
      |- requested module is picked up as a dependency
    |- c-loader normal execution
  |- b-loader normal execution
|- a-loader normal execution
</code></pre></div></div> <p>从上面代码可以看出，在同一组 loader 配置中，<code class="language-plaintext highlighter-rouge">pitch()</code> 方法会优先执行。loader 模块中引入 “pitching” 阶段，主要是基于以下两个原因。</p> <ol> <li> <p>传递给 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法的 <code class="language-plaintext highlighter-rouge">data</code>，在执行阶段也会暴露在 <code class="language-plaintext highlighter-rouge">this.data</code> 之下，并且可以用于在循环时，捕获并共享前面的信息。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
 <span class="p">};</span>

 <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">data</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
 <span class="p">};</span>
</code></pre></div> </div> </li> <li> <p>如果某个 loader 在 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法中给出一个结果，那么这个过程会回过身来，并跳过剩下的 loader。在我们上面的例子中，如果 <code class="language-plaintext highlighter-rouge">b-loader</code> 的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法返回了一些东西，<code class="language-plaintext highlighter-rouge">b-loader</code> 之后的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法以及所有的 loader 方法，都将不再执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
 <span class="p">};</span>

 <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if </span><span class="p">(</span><span class="nf">someCondition</span><span class="p">())</span> <span class="p">{</span>
     <span class="k">return </span><span class="p">(</span>
       <span class="dl">'</span><span class="s1">module.exports = require(</span><span class="dl">'</span> <span class="o">+</span>
       <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="dl">'</span><span class="s1">-!</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">remainingRequest</span><span class="p">)</span> <span class="o">+</span>
       <span class="dl">'</span><span class="s1">);</span><span class="dl">'</span>
     <span class="p">);</span>
   <span class="p">}</span>
 <span class="p">};</span>
</code></pre></div> </div> <p>上面的代码，将会按照下面的顺序执行。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> |- a-loader `pitch`
   |- b-loader `pitch` returns a module
 |- a-loader normal execution
</code></pre></div> </div> </li> </ol> <h2 id="loader-context">Loader Context</h2> <p>loader context 表示在 loader 内使用 <code class="language-plaintext highlighter-rouge">this</code> 可以访问的一些方法或属性。</p> <h3 id="thisasync">this.async()</h3> <p>用于告诉 loader-runner 这个 loader 将会异步地回调。返回 <code class="language-plaintext highlighter-rouge">this.callback()</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="k">async</span><span class="p">();</span>
</code></pre></div></div> <h3 id="thiscallback">this.callback()</h3> <p>用于同步或异步调用，并返回多个结果。预期的参数是：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nf">callback</span><span class="p">(</span>
  <span class="nx">err</span><span class="p">:</span> <span class="nb">Error</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">content</span><span class="p">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">Buffer</span><span class="p">,</span>
  <span class="nx">sourceMap</span><span class="p">?:</span> <span class="nx">SourceMap</span><span class="p">,</span> <span class="c1">// 表示一个可以被 this module 解析的 source map</span>
  <span class="nx">meta</span><span class="p">?:</span> <span class="nx">any</span> <span class="c1">// 此参数会被 webpack 忽略，可以是任何东西（例如一些元数据）</span>
<span class="p">);</span>
</code></pre></div></div> <p>注意，在使用了 <code class="language-plaintext highlighter-rouge">this.callback()</code> 的情况下，就不应该在使用 <code class="language-plaintext highlighter-rouge">return</code> 返回 <code class="language-plaintext highlighter-rouge">content</code>，而是应该返回 <code class="language-plaintext highlighter-rouge">undefined</code>，从而避免含糊的 loader 结果。</p> <h3 id="thisemitfile">this.emitFile()</h3> <p>用于产生一个文件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">emitFile</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">content</span><span class="p">:</span> <span class="nx">Buffer</span><span class="o">|</span><span class="nx">string</span><span class="p">,</span> <span class="nx">sourceMap</span><span class="p">:</span> <span class="p">{...})</span>
</code></pre></div></div> <h3 id="thisgetoptionsschema">this.getOptions(schema)</h3> <p>用于提取给定的 loader 选项，接受一个可选的 JSON schema 作为参数。</p> <h3 id="thisutils">this.utils</h3> <p>用于访问 <code class="language-plaintext highlighter-rouge">contextify</code> 与 <code class="language-plaintext highlighter-rouge">absolutify</code> 功能。</p> <ul> <li><code class="language-plaintext highlighter-rouge">contextify</code>：返回一个新的请求字符串，尽可能避免使用绝对路径。</li> <li><code class="language-plaintext highlighter-rouge">absolutify</code>：尽可能使用相对路径返回一个新的请求字符串。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">contextify</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">absolutify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span> <span class="dl">'</span><span class="s1">./index.js</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">absolutify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">resourcePath</span><span class="p">);</span>
  <span class="c1">// …</span>
  <span class="k">return</span> <span class="nx">content</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>这里只是列举出了几个常用的 Loader Context API，更多方法请参考 <a href="https://webpack.docschina.org/api/loaders/">Loader Interface</a>。</p> <h2 id="编写-loader">编写 Loader</h2> <h3 id="用法准则">用法准则</h3> <p>编写 loader 时应该遵循以下准则。它们按重要程度排序，有些仅适用于某些场景。</p> <h4 id="1保持简单">（1）保持<strong>简单</strong></h4> <p>loaders 应该只做单一任务。这不仅使每个 loader 易维护，也可以在更多场景链式调用。</p> <h4 id="2使用链式传递">（2）使用<strong>链式</strong>传递</h4> <p>利用 loader 可以链式调用的优势。写五个简单的 loader 实现五项任务，而不是一个 loader 实现五项任务。功能隔离不仅使 loader 更简单，可能还可以将它们用于你原先没有想到的功能。</p> <h4 id="3模块化的输出">（3）<strong>模块化</strong>的输出</h4> <p>保证输出模块化。loader 生成的模块与普通模块遵循相同的设计原则。</p> <h4 id="4确保无状态">（4）确保<strong>无状态</strong></h4> <p>确保 loader 在不同模块转换之间不保存状态。每次运行都应该独立于其他编译模块以及相同模块之前的编译结果。</p> <h4 id="5使用-loader-utilities">（5）使用 <strong>loader utilities</strong></h4> <p>充分利用 <code class="language-plaintext highlighter-rouge">loader-utils</code> 包。它提供了许多有用的工具，但最常用的一种工具是获取传递给 loader 的选项。<code class="language-plaintext highlighter-rouge">schema-utils</code> 包配合 <code class="language-plaintext highlighter-rouge">loader-utils</code>，用于保证 loader 选项，进行与 JSON Schema 结构一致的校验。</p> <h4 id="6记录-loader-的依赖">（6）记录 <strong>loader 的依赖</strong></h4> <p>如果一个 loader 使用外部资源（例如，从文件系统读取），必须声明它。这些信息用于使缓存 loaders 无效，以及在观察模式(watch mode)下重编译。</p> <h4 id="7解析模块依赖关系">（7）解析<strong>模块依赖关系</strong></h4> <p>根据模块类型，可能会有不同的模式指定依赖关系。例如在 CSS 中，使用 <code class="language-plaintext highlighter-rouge">@import</code> 和 <code class="language-plaintext highlighter-rouge">url(...)</code> 语句来声明依赖。这些依赖关系应该由模块系统解析。</p> <p>可以通过以下两种方式中的一种来实现：</p> <ul> <li>通过把它们转化成 <code class="language-plaintext highlighter-rouge">require</code> 语句。</li> <li>使用 <code class="language-plaintext highlighter-rouge">this.resolve</code> 函数解析路径。</li> </ul> <p><code class="language-plaintext highlighter-rouge">css-loader</code> 是第一种方式的一个例子。它将 <code class="language-plaintext highlighter-rouge">@import</code> 语句替换为 <code class="language-plaintext highlighter-rouge">require</code> 其他样式文件，将 <code class="language-plaintext highlighter-rouge">url(...)</code> 替换为 <code class="language-plaintext highlighter-rouge">require</code> 引用文件，从而实现将依赖关系转化为 <code class="language-plaintext highlighter-rouge">require</code> 声明。</p> <p>对于 <code class="language-plaintext highlighter-rouge">less-loader</code>，无法将每个 <code class="language-plaintext highlighter-rouge">@import</code> 转化为 <code class="language-plaintext highlighter-rouge">require</code>，因为所有 <code class="language-plaintext highlighter-rouge">.less</code> 的文件中的变量和混合跟踪必须一次编译。因此，<code class="language-plaintext highlighter-rouge">less-loader</code> 将 less 编译器进行了扩展，自定义路径解析逻辑。然后，利用第二种方式，通过 webpack 的 <code class="language-plaintext highlighter-rouge">this.resolve</code> 解析依赖。</p> <h4 id="8提取通用代码">（8）提取<strong>通用代码</strong></h4> <p>避免在 loader 处理的每个模块中生成通用代码。相反，你应该在 loader 中创建一个运行时文件，并生成 <code class="language-plaintext highlighter-rouge">require</code> 语句以引用该共享模块：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/loader-runtime.js</span>

<span class="kd">const</span> <span class="p">{</span> <span class="nx">someOtherModule</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./some-other-module</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">runtime</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">someOtherModule</span><span class="p">(</span><span class="nx">params</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// src/loader.js</span>
<span class="k">import</span> <span class="nx">runtime</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./loader-runtime.js</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">loader</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nf">runtime</span><span class="p">({</span>
    <span class="nx">source</span><span class="p">,</span>
    <span class="na">y</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">(),</span>
  <span class="p">})}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="9避免绝对路径">（9）避免<strong>绝对路径</strong></h4> <p>不要在模块代码中插入绝对路径，因为当项目根路径变化时，文件绝对路径也会变化。<code class="language-plaintext highlighter-rouge">loader-utils</code> 中的 <a href="https://github.com/webpack/loader-utils#stringifyrequest">stringifyRequest</a> 方法，可以将绝对路径转化为相对路径。</p> <h4 id="10使用-peer-dependencies">（10）使用 <strong>peer dependencies</strong></h4> <p>如果你的 loader 简单包裹另外一个包，你应该把这个包作为一个 peerDependency 引入。这种方式允许应用程序开发者在必要情况下，在 <code class="language-plaintext highlighter-rouge">package.json</code> 中指定所需的确定版本。</p> <p>例如，<code class="language-plaintext highlighter-rouge">sass-loader</code> 指定 <code class="language-plaintext highlighter-rouge">node-sass</code> 作为同等依赖，引用如下：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"peerDependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"node-sass"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.0.0"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[loader 本质上是导出为函数的 JavaScript 模块。loader runner 会调用此函数，然后将上一个 loader 产生的结果或者资源文件传入进去。函数中的 this 作为上下文会被 webpack 填充，并且 loader runner 中包含一些实用的方法，比如可以使 loader 调用方式变为异步，或者获取 query 参数。]]></summary></entry><entry><title type="html">webpack 中的 Plugin</title><link href="https://feng-zhang0712.github.io//blog/2024/plugin/" rel="alternate" type="text/html" title="webpack 中的 Plugin"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/plugin</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/plugin/"><![CDATA[<p>webpack 在代码编译过程中，会触发一系列 Tapable 钩子事件，插件所做的，就是在相应的钩子上注册事件，执行不同的任务。当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行。</p> <h2 id="一钩子">一、钩子</h2> <p>钩子（hooks）的本质是事件。webpack 把编译过程中触发的各类关键事件封装成事件接口暴露了出来。这些接口就被称为钩子，钩子是 webpack 插件中的关键概念。</p> <p><a href="https://github.com/webpack/tapable">Tapable</a> 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。</p> <p>Tapable 统一暴露了三个方法给插件，用于注册不同的钩子事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">tap()</code>：可以注册同步钩子和异步钩子。</li> <li> <p><code class="language-plaintext highlighter-rouge">tapAsync()</code>：回调方式注册异步钩子。</p> <p>使用 <code class="language-plaintext highlighter-rouge">tapAsync()</code> 方法来绑定插件时，<strong>必须</strong>调用函数的最后一个参数 <code class="language-plaintext highlighter-rouge">callback()</code> 指定的回调函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">HelloAsyncPlugin</span> <span class="p">{</span>
    <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span>
        <span class="dl">'</span><span class="s1">HelloAsyncPlugin</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="c1">// 执行某些异步操作...</span>
          <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">异步任务完成...</span><span class="dl">'</span><span class="p">);</span>
            <span class="nf">callback</span><span class="p">();</span>
          <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloAsyncPlugin</span><span class="p">;</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">tapPromise()</code>：Promise 方式注册异步钩子。</p> <p>使用 <code class="language-plaintext highlighter-rouge">tapPromise()</code> 方法来绑定插件时，<strong>必须</strong>返回一个 Promise，异步任务完成后调用 Promise 的 <code class="language-plaintext highlighter-rouge">resolve()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">HelloAsyncPlugin</span> <span class="p">{</span>
    <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapPromise</span><span class="p">(</span><span class="dl">'</span><span class="s1">HelloAsyncPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 返回一个 pormise ，异步任务完成后 resolve</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">异步任务完成...</span><span class="dl">'</span><span class="p">);</span>
            <span class="nf">resolve</span><span class="p">();</span>
          <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloAsyncPlugin</span><span class="p">;</span>
</code></pre></div> </div> </li> </ul> <p>目前，<a href="https://github.com/webpack/tapable/blob/master/lib/index.js">Tapable</a> 中定义了十种 Hooks。</p> <ul> <li>SyncHook</li> <li>SyncBailHook</li> <li>SyncWaterfallHook</li> <li>SyncLoopHook</li> <li>AsyncParallelHook</li> <li>AsyncParallelBailHook</li> <li>AsyncSeriesHook</li> <li>AsyncSeriesBailHook</li> <li>AsyncSeriesLoopHook</li> <li>AsyncSeriesWaterfallHook</li> </ul> <p>上面的钩子，按照执行方式，分为<strong>同步钩子</strong>和<strong>异步钩子</strong>，他们的名称分别以前缀 <code class="language-plaintext highlighter-rouge">Sync</code> 和 <code class="language-plaintext highlighter-rouge">Async</code> 开头。<a href="https://webpack.docschina.org/">webpack 文档中</a>列出的所有的 <a href="https://webpack.docschina.org/api/compiler-hooks/">compiler 钩子</a> 和 <a href="https://webpack.docschina.org/api/compilation-hooks/">compilation 钩子</a>，都继承自这些 Hooks。</p> <p>下面，分别对这些 Hooks 进行介绍。</p> <h3 id="synchook">SyncHook</h3> <h3 id="asyncparallelhook">AsyncParallelHook</h3> <h3 id="asyncserieshook">AsyncSeriesHook</h3> <h2 id="二compiler-对象">二、Compiler 对象</h2> <p><code class="language-plaintext highlighter-rouge">compiler</code> 对象中保存着完整的 webpack 环境配置，每次启动 webpack 构建时它都是一个独一无二、仅仅会创建一次的对象。这个对象会在首次启动 webpack 时创建，我们可以通过 <code class="language-plaintext highlighter-rouge">compiler</code> 对象上访问到 webapck 的主环境配置，比如 loader、plugin 等等配置信息。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-object-structure-480.webp 480w,/assets/images/webpack/compiler-object-structure-800.webp 800w,/assets/images/webpack/compiler-object-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-object-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler 对象的结构 </div> <p>webpack 中的很多<a href="https://webpack.docschina.org/api/compiler-hooks/#hooks">生命周期函数钩子</a>，由 <code class="language-plaintext highlighter-rouge">compiler</code> 暴露，可以通过以下方式注册监听。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">someHook</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
<span class="p">});</span>
</code></pre></div></div> <p>compiler 对象有以下主要属性。</p> <h3 id="compileroptions">compiler.options</h3> <p><code class="language-plaintext highlighter-rouge">compiler.options</code>：用于访问本次启动 webpack 时候所有的配置文件，比如 <code class="language-plaintext highlighter-rouge">loaders</code>、<code class="language-plaintext highlighter-rouge">entry</code> 、<code class="language-plaintext highlighter-rouge">output</code>、<code class="language-plaintext highlighter-rouge">plugin</code> 等等完整配置信息。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-options-structure-480.webp 480w,/assets/images/webpack/compiler-options-structure-800.webp 800w,/assets/images/webpack/compiler-options-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-options-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler.options 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler.options 对象的结构 </div> <h3 id="compilerhooks">compiler.hooks</h3> <p><code class="language-plaintext highlighter-rouge">compiler.hooks</code>：用于注册 tapable 的不同种类 Hook，从而可以在 <code class="language-plaintext highlighter-rouge">compiler</code> 生命周期中植入不同的逻辑。</p> <div class="row justify-content-center"> <div class="col-10"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-hooks-structure-480.webp 480w,/assets/images/webpack/compiler-hooks-structure-800.webp 800w,/assets/images/webpack/compiler-hooks-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-hooks-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler.hooks 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler.hooks 对象的结构 </div> <h3 id="compilerinputfilesystem-和-compileroutputfilesystem">compiler.inputFileSystem 和 compiler.outputFileSystem</h3> <p><code class="language-plaintext highlighter-rouge">compiler.inputFileSystem</code> 和 <code class="language-plaintext highlighter-rouge">compiler.outputFileSystem</code>：用于进行文件操作，相当于 Nodejs 中 <code class="language-plaintext highlighter-rouge">fs</code>。</p> <h2 id="三compilation-对象">三、Compilation 对象</h2> <p><code class="language-plaintext highlighter-rouge">compilation</code> 对象代表一次资源的构建，<code class="language-plaintext highlighter-rouge">compilation</code> 实例能够访问所有的模块和它们的依赖。一个 <code class="language-plaintext highlighter-rouge">compilation</code> 对象会对构建依赖图中所有模块进行编译。在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、分块(chunk)、哈希(hash)和重新创建(restore)。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compilation-object-structure-480.webp 480w,/assets/images/webpack/compilation-object-structure-800.webp 800w,/assets/images/webpack/compilation-object-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compilation-object-structure.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compilation 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compilation 对象的结构 </div> <p>Compilation 类扩展自 Tapable，并提供了很多<a href="https://webpack.docschina.org/api/compilation-hooks/">生命周期钩子</a>。他们的使用方式，跟使用 <code class="language-plaintext highlighter-rouge">compiler</code> 注册监听钩子的方式相同。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">compilation</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">someHook</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
<span class="p">});</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">compilation</code> 对象有以下主要属性。</p> <h3 id="compilationmodules">compilation.modules</h3> <p><code class="language-plaintext highlighter-rouge">compilation.modules</code> 用于访问所有模块，打包的每一个文件都是一个模块。</p> <h3 id="compilationchunks">compilation.chunks</h3> <p><code class="language-plaintext highlighter-rouge">compilation.chunks</code> chunk 即是多个 modules 组成而来的一个代码块。入口文件引入的资源组成一个 chunk，通过代码分割的模块又是另外的 chunk。</p> <h3 id="compilationassets">compilation.assets</h3> <p><code class="language-plaintext highlighter-rouge">compilation.assets</code> 用于访问本次打包生成所有文件的结果。</p> <h3 id="compilationhooks">compilation.hooks</h3> <p><code class="language-plaintext highlighter-rouge">compilation.hooks</code> 用于注册 tapable 的不同种类 Hook，用于在 <code class="language-plaintext highlighter-rouge">compilation</code> 编译模块阶段进行逻辑添加以及修改。</p> <h2 id="四自定义-plugin">四、自定义 Plugin</h2> <p>webpack 插件由以下几个部分组成。</p> <ul> <li>一个 JavaScript 命名<strong>函数</strong>或<strong>类</strong>。</li> <li>在插件函数的 prototype 上定义一个 <code class="language-plaintext highlighter-rouge">apply</code> 方法。</li> <li>指定一个绑定到 webpack 自身的事件钩子。</li> <li>处理 webpack 内部实例的特定数据。</li> <li>功能完成后调用 webpack 提供的回调。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyExampleWebpackPlugin</span> <span class="p">{</span>
  <span class="c1">// 在插件函数的 prototype 上定义一个 `apply` 方法，以 compiler 为参数。</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 指定一个挂载到 webpack 自身的事件钩子。</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span>
      <span class="dl">'</span><span class="s1">MyExampleWebpackPlugin</span><span class="dl">'</span><span class="p">,</span>
      <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">这是一个示例插件！</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
          <span class="dl">'</span><span class="s1">这里表示了资源的单次构建的 `compilation` 对象：</span><span class="dl">'</span><span class="p">,</span>
          <span class="nx">compilation</span>
        <span class="p">);</span>

        <span class="c1">// 用 webpack 提供的插件 API 处理构建过程</span>
        <span class="nx">compilation</span><span class="p">.</span><span class="nf">addModule</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>

        <span class="nf">callback</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>插件是由「具有 <code class="language-plaintext highlighter-rouge">apply</code> 方法的 prototype 对象」所实例化出来的。这个 <code class="language-plaintext highlighter-rouge">apply</code> 方法在安装插件时，会被 <code class="language-plaintext highlighter-rouge">compiler</code> 调用一次。apply 方法可以接收一个 <code class="language-plaintext highlighter-rouge">compiler</code> 对象的引用，从而可以在回调函数中访问到 <code class="language-plaintext highlighter-rouge">compiler</code> 对象。一个插件结构如下。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HelloWorldPlugin</span> <span class="p">{</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span>
      <span class="dl">'</span><span class="s1">Hello World Plugin</span><span class="dl">'</span><span class="p">,</span>
      <span class="p">(</span>
        <span class="nx">stats</span> <span class="cm">/* 绑定 done 钩子后，stats 会作为参数传入。 */</span>
      <span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloWorldPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>然后就可以在 webpack 配置文件中使用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HelloWorldPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello-world</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span><span class="k">new</span> <span class="nc">HelloWorldPlugin</span><span class="p">({</span> <span class="na">options</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})],</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="五参考">五、参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 在代码编译过程中，会触发一系列 Tapable 钩子事件，插件所做的，就是在相应的钩子上注册事件，执行不同的任务。当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行。]]></summary></entry><entry><title type="html">HTTP 缓存</title><link href="https://feng-zhang0712.github.io//blog/2024/07-caching/" rel="alternate" type="text/html" title="HTTP 缓存"/><published>2024-10-03T00:00:00+00:00</published><updated>2024-10-03T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/07-caching</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/07-caching/"><![CDATA[<blockquote> <p>本文节选自《HTTP 权威指南 - 第4章 连接管理》。</p> </blockquote> <p>Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存有下列优点。</p> <ul> <li><strong>减少了冗余的数据传输</strong>，节省了你的网络费用。</li> <li><strong>缓解了网络瓶颈的问题</strong>。不需要更多的带宽就能够更快地加载页面。</li> <li><strong>降低了对原始服务器的要求</strong>。服务器可以更快地响应，避免过载的出现。</li> <li><strong>降低了距离时延</strong>，因为从较远的地方加载页面会更慢一些。</li> </ul> <h2 id="一冗余的数据传输">一、冗余的数据传输</h2> <p>有很多客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传送给一个客户端。一些相同的字节会在网络中一遍遍地传输。这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重 Web 服务器的负载。有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少那些流入/流出原始服务器的、被浪费掉了的重复流量。</p> <h2 id="二带宽瓶颈">二、带宽瓶颈</h2> <p>缓存还可以<strong>缓解网络的瓶颈</strong>问题。很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽（参见图 7-1）。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能 —— 尤其是要传输比较大的文件时。</p> <p>在图 7-1 中，Joe 的五金商店旧金山分店的用户通过 1.4Mbit/s 的 T1 因特网连接，从亚特兰大总店下载一个 5MB 的库存文件要花 30 秒的时间。如果在旧金山分店里缓存了这个文档，本地用户通过以太网连接只要花费不到 1 秒的时间就可以获得同一份文档了。表 7-1 说明了在几种不同的网速下，传输几种不同大小的文档时，带宽会对传输速度产生什么样的影响。带宽会给较大的文档带来显而易见的时延，不同类型网络的速度差异会非常明显。’一个 54kbit/s 的 Modem 传输一个 5MB 的文件需要 749 秒（超过 12 分钟），而在快速以太网 LAN 中，只要不到一秒的时间。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="缓存可以改善由有限广域带宽造成的网络瓶颈" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-1 缓存可以改善由有限广域带宽造成的网络瓶颈 </div> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="带宽造成的传输时延，理想化情况（以秒为时间单位）" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 7-1 带宽造成的传输时延，理想化情况（以秒为时间单位） </div> <h2 id="三瞬间拥塞">三、瞬间拥塞</h2> <p>缓存在破坏<strong>瞬间拥塞</strong>（Flash Crowds）时显得非常重要。突发事件（比如爆炸性新闻、批量 E-mail 公告，或者某个名人事件）使很多人几乎同时去访问一个 Web 文档时，就会出现瞬间拥塞（参见图 7-2）。由此造成的过多流量峰值可能会使网络和 Web 服务器产生灾难性的崩溃。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="瞬间拥塞会使 Web 服务器过载" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-2 瞬间拥塞会使 Web 服务器过载 </div> <h2 id="四距离时延">四、距离时延</h2> <p>即使带宽不是问题，距离也可能成为问题。每台网络路由器都会增加因特网流量的时延。即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著的时延。将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="即便使用的是并行的持久连接，光速也会造成显著的时延" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-3 即便使用的是并行的持久连接，光速也会造成显著的时延 </div> <h2 id="五命中和未命中的">五、命中和未命中的</h2> <p>缓存无法保存世界上每份文档的副本。可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存<strong>命中</strong>（cache hit），参见图 7-4a。其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为缓存<strong>未命中</strong>（cache miss），参见图 7-4b。</p> <h3 id="51-再验证">5.1 再验证</h3> <p>原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本。这些“新鲜度检测”被称为 HTTP <strong>再验证</strong>（revalidation）（参见图 7-4c）。为了有效地进行再验证，HTTP 定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="缓存命中、未命中以及再验证" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-4 缓存命中、未命中以及再验证 </div> <p>缓存中通常会包含数百万的文档，而且网络带宽是很珍贵的，所以大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行再验证。</p> <p>缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 进行响应。只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端（参见图 7-5a）这被称作<strong>再验证命中</strong>（revalidate hit）或<strong>缓慢命中</strong>（slow hit）。这种方式要与原始服务器进行核对，所以会比单纯的缓存命中要慢， 但它没有从服务器中获取对象数据，所以要比缓存未命中快一些。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="成功的再验证比缓存未命中要快，失败的再验证几乎和未命中的速度一样" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-5 成功的再验证比缓存未命中要快，失败的再验证几乎和未命中的速度一样 </div> <p>HTTP 为我们提供了几个用来对已缓存对象进行再验证的工具，但最常用的是 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 首部。将这个首部添加到 <code class="language-plaintext highlighter-rouge">GET</code> 请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。</p> <p>这里列出了在 3 种情况下（服务器内容未被修改，服务器内容已被修改，或者服务器上的对象被删除了）服务器收到 <code class="language-plaintext highlighter-rouge">GET</code> <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 请求时会发生的情况：</p> <ul> <li>再验证命中：如果服务器对象未被修改，服务器会向客户端发送 HTTP <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应。图 7-6 对此进行了描述。</li> <li>再验证未命中：如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的 HTTP <code class="language-plaintext highlighter-rouge">200 OK</code> 响应。</li> <li>对象被删除：如果服务器对象已经被删除了，服务器就回送一个 <code class="language-plaintext highlighter-rouge">404 Not Found</code> 响应，缓存也会将其副本删除。</li> </ul> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP 使用 If-Modified-Since 首部进行再验证" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-6 HTTP 使用 If-Modified-Since 首部进行再验证 </div> <h3 id="52-命中率">5.2 命中率</h3> <p>由<strong>缓存提供服务的请求所占的比例</strong>被称为<strong>缓存命中率</strong>（cache hit rate，或称为缓存命中比例），有时也被称为文档命中率（document hit rate）。命中率通常用百分数来描述，<code class="language-plaintext highlighter-rouge">0%</code> 表示每次请求都未命中（要通过网络来获取文档），<code class="language-plaintext highlighter-rouge">100%</code> 表示每次请求都命中了（在缓存中有一份副本）。</p> <p>缓存的管理者希望缓存命中率接近 100%。而实际得到的命中率则与缓存的大小、缓存用户兴趣点的相似性、缓存数据的变化或个性化频率，以及如何配置缓存有关。命中率很难预测，但对现在中等规模的 Web 缓存来说，<code class="language-plaintext highlighter-rouge">40%</code> 的命中率是很合理的。缓存的好处是，即使是中等规模的缓存，其所包含的常见文档也足以显著地提高性能、减少流量了。缓存会努力确保将有用的内容保存在缓存中。</p> <h3 id="53-字节命中率">5.3 字节命中率</h3> <p>由于文档并不全是同一尺寸的，所以文档命中率并不能说明一切。有些大型对象被访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大。因此，有些人更愿意使用<strong>字节命中率</strong>（byte hit rate）作为度量值（尤其那些按流量字节付费的人!）。</p> <p>字节命中率表示的是<strong>缓存提供的字节在传输的所有字节中所占的比例</strong>。通过这种度量方式，可以得知节省流量的程度。<code class="language-plaintext highlighter-rouge">100%</code> 的字节命中率说明每个字节都来自缓存，没有流量流到因特网上去。</p> <p>文档命中率和字节命中率对缓存性能的评估都是很有用的。文档命中率说明阻止了多少通往外部网络的 Web 事务。事务有一个通常都很大的固定时间成分（比如，建立一条到服务器的 TCP 连接）， 提高文档命中率对降低整体延迟（时延）很有好处。字节命中率说明阻止了多少字节传向因特网。提高字节命中率对节省带宽很有利。</p> <h3 id="54-区分命中和未命中的情况">5.4 区分命中和未命中的情况</h3> <p>不幸的是，HTTP 没有为用户提供一种手段来区分响应是缓存命中的，还是访问原始服务器得到的。在这两种情况下，响应码都是 <code class="language-plaintext highlighter-rouge">200 OK</code>，说明响应有主体部分。有些商业代理缓存会在 <code class="language-plaintext highlighter-rouge">Via</code> 首部附加一些额外信息，以描述缓存中发生的情况。客户端有一种方法可以判断响应是否来自缓存，就是使用 <code class="language-plaintext highlighter-rouge">Date</code> 首部。将响应中 <code class="language-plaintext highlighter-rouge">Date</code> 首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存的响应。客户端也可以通过 <code class="language-plaintext highlighter-rouge">Age</code> 首部来检测缓存的响应，通过这个首部可以分辨出这条响应的使用期。</p> <h2 id="六缓存的拓扑结构">六、缓存的拓扑结构</h2> <p>缓存可以是单个用户专用的，也可以是数千名用户共享的。专用缓存被称为<strong>私有缓存</strong>（private cache）。私有缓存是个人的缓存，包含了单个用户最常用的页面（参见图 7-7a）。共享的缓存被称为<strong>公有缓存</strong>（public cache）。公有缓存中包含了某个用户团体的常用页面（参见图 7-7b）。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="公有和私有缓存" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-7 公有和私有缓存 </div> <h3 id="61-私有缓存">6.1 私有缓存</h3> <p>私有缓存不需要很大的动力或存储空间，这样就可以将其做得很小，很便宜。Web 浏览器中有内建的私有缓存 —— 大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的大小和各种设置。还可以去看看浏览器的缓存中有些什么内容。</p> <h3 id="62-公有代理缓存">6.2 公有代理缓存</h3> <p>公有缓存是特殊的共享代理服务器，被称为<strong>缓存代理服务器</strong>（caching proxy server），或者更常见地被称为<strong>代理缓存</strong>（proxy cache）。代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。</p> <p>在图 7-8a 中，每个客户端都会重复地访问一个（还不在私有缓存中的）新的“热门”文档。每个私有缓存都要获取同一份文档，这样它就会多次穿过网络。而如图 7-8b 所示，使用共享的公有缓存时，对于这个流行的对象，缓存只要取一次就行了，它会用共享的副本为所有的请求服务，以降低网络流量。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="共享的公有缓存可以降低网络流量" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图7-8 共享的公有缓存可以降低网络流量 </div> <h3 id="63-代理缓存的层次结构">6.3 代理缓存的层次结构</h3> <p>在实际中，实现<strong>层次化</strong>（hierarchy）的缓存是很有意义的，在这种结构中，在较小缓存中未命中的请求会被导向较大的<strong>父缓存</strong>（parent cache），由它来为剩下的那些“提炼过的”流量提供服务。图 7-9 显示了一个两级的缓存层次结构。其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="在两级的缓存层次结构中访问文档" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-9 在两级的缓存层次结构中访问文档 </div> <p>我们希望大部分用户都能在附近的第一级缓存中命中（参见图 7-9a）。如果没有命中，较大的父缓存可能能够处理它们的请求（参见图 7-9b）。在缓存层次结构很深的情况下，请求可能要穿过很长一溜缓存，但每个拦截代理都会添加一些性能损耗，当代理链路变得很长的时候，这种性能损耗会变得非常明显。</p> <h3 id="64-网状缓存内容路由以及对等缓存">6.4 网状缓存、内容路由以及对等缓存</h3> <p>有些网络结构会构建复杂的<strong>网状缓存</strong>（cache mesh），而不是简单的缓存层次结构。网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为<strong>内容路由器</strong>（content router）。</p> <p>网状缓存中为内容路由设计的缓存（除了其他任务之外）要完成下列所有功能。</p> <ul> <li>根据 URL 在父缓存或原始服务器之间进行动态选择。</li> <li>根据 URL 动态地选择一个特定的父缓存。</li> <li>前往父缓存之前，在本地缓存中搜索已缓存的副本。</li> <li>允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的缓存。</li> </ul> <p>缓存之间这些更为复杂的关系允许不同的组织互为<strong>对等</strong>（peer）实体，将它们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为<strong>兄弟缓存</strong>（sibling cache）（参见图 7-10）。HTTP 并不支持兄弟缓存，所以人们通过一些协议对 HTTP 进行了扩展，比如<strong>因特网缓存协议</strong>（Internet Cache Protocol，ICP）和<strong>超文本缓存协议</strong>（HyperText Caching Protocol，HTCP）。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="兄弟缓存" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 7-10 兄弟缓存 </div> <h2 id="七缓存的处理步骤">七、缓存的处理步骤</h2> <p>现代的商业化代理缓存相当地复杂。这些缓存构建得非常高效，可以支持 HTTP 和其他一些技术的各种高级特性。但除了一些微妙的细节之外，Web 缓存的基本工作原理大多很简单。对一条 HTTP <code class="language-plaintext highlighter-rouge">GET</code> 报文的基本缓存处理过程包括 7 个步骤（参见图 7-11）。</p> <ol> <li>接收 —— 缓存从网络中读取抵达的请求报文。缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。</li> <li>解析 —— 缓存对报文进行解析，提取出 URL 和各种首部。缓存将请求报文解析为片断，将首部的各个部分放入易于操作的数据结构中。这样，缓存软件就更容易处理首部字段并修改它们了。</li> <li>查询 —— 缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）。缓存获取了 URL，查找本地副本。本地副本可能存储在内存、本地磁盘，甚至附近的另一台计算机中。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。如果本地没有这个文档，它可以根据情形和配置，到原始服务器或父代理中去取，或者返回一条错误信息。已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。已缓存对象中还包含了一些<strong>元数据</strong>（metadata），用来记录对象在缓存中停留了多长时间，以及它被用过多少次等。</li> <li>新鲜度检测 —— 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。HTTP 通过缓存将服务器文档的副本保留一段时间。在这段时间里，都认为文档是“新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但一旦已缓存副本停留的时间太长，超过了文档的<strong>新鲜度限值</strong>（freshness limit），就认为对象“过时”了，在提供该文档之前，缓存要再次与服务器进行确认，以查看文档是否发生了变化。客户端发送给缓存的所有请求首部自身都可以强制缓存进行再验证，或者完全避免验证，这使得事情变得更加复杂了。HTTP 有一组非常复杂的新鲜度检测规则，缓存产品支持的大量配置选项，以及与非 HTTP 新鲜度标准进行互通的需要则使问题变得更加严重了。</li> <li>创建响应 —— 缓存会用新的首部和已缓存的主体来构建一条响应报文。我们希望缓存的响应看起来就像来自原始服务器的一样，缓存将已缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础首部进行了修改和扩充。缓存负责对这些首部进行改造，以便与客户端的要求相匹配。比如，服务器返回的可能是一条 HTTP/1.0 响应（甚至是 HTTP/0.9 响应），而客户端期待的是一条HTTP/1.1 响应，在这种情况下，缓存必须对首部进行相应的转换。缓存还会向其中插入新鲜度信息（<code class="language-plaintext highlighter-rouge">Cache-Control</code>、<code class="language-plaintext highlighter-rouge">Age</code> 以及 <code class="language-plaintext highlighter-rouge">Expires</code> 首部），而且通常会包含一个 <code class="language-plaintext highlighter-rouge">Via</code> 首部来说明请求是由一个代理缓存提供的。注意，缓存不应该调整 <code class="language-plaintext highlighter-rouge">Date</code> 首部。<code class="language-plaintext highlighter-rouge">Date</code> 首部表示的是原始服务器最初产生这个对象的日期。</li> <li>发送 —— 缓存通过网络将响应发回给客户端。一旦响应首部准备好了，缓存就将响应回送给客户端。和所有代理服务器一样，代理缓存要管理与客户端之间的连接。高性能的缓存会尽力高效地发送数据，通常可以避免在本地缓存和网络 I/O 缓冲区之间进行文档内容的复制。</li> <li>日志 —— 缓存可选地创建一个日志文件条目来描述这个事务。大多数缓存都会保存日志文件以及与缓存的使用有关的一些统计数据。每个缓存事务结束之后，缓存都会更新缓存命中和未命中数目的统计数据（以及其他相关的度量值），并将条目插入一个用来显示请求类型、URL 和所发生事件的日志文件。最常见的缓存日志格式为 Squid 日志格式和网景的可扩展通用日志格式，但很多缓存产品都允许用户创建自定义的日志文件。</li> </ol> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="处理一个新鲜的缓存命中" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-11 处理一个新鲜的缓存命中 </div> <p>图 7-12 以简化形式显示了缓存是如何处理请求，以 <code class="language-plaintext highlighter-rouge">GET</code> 一个 URL 的。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="缓存 GET 请求的流程图" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-12 缓存 GET 请求的流程图 </div> <h2 id="八保持副本的新鲜">八、保持副本的新鲜</h2> <p>HTTP 有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP 将这些简单的机制称为<strong>文档过期</strong>（document expiration）和服<strong>务器再验证</strong>（server revalidation）。</p> <h3 id="81-文档过期">8.1 文档过期</h3> <p>通过特殊的 HTTP <code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部和 <code class="language-plaintext highlighter-rouge">Expires</code> 首部， HTTP 让原始服务器向每个文档附加了一个“过期日期”（参见图 7-13）。这些首部说明了在多长时间内可以将这些内容视为新鲜的。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Expires 首部和 Cache-Control 首部" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-13 Expires 首部和 Cache-Control 首部 </div> <p>在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系 —— 当然，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果被修改过，就要获取一份新鲜（带有新的过期日期）的副本。</p> <h3 id="82-过期日期和使用期">8.2 过期日期和使用期</h3> <p>服务器用 HTTP/1.0+ 的 <code class="language-plaintext highlighter-rouge">Expires</code> 首部或HTTP/1.1 的 <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 响应首部来指定过期日期，同时还会带有响应主体。<code class="language-plaintext highlighter-rouge">Expires</code> 首部和 <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 首部所做的事情本质上是一样的，<code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部。绝对日期依赖于计算机时钟的正确设置（注：而本地计算机时钟有可能被恶意篡改）。表 7-2 列出了各种过期响应首部。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="过期响应首部" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 7-2 过期响应首部 </div> <h3 id="83-服务器再验证">8.3 服务器再验证</h3> <p>仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别；这只是意味着到了要进行核对的时间了。这种情况被称为“<strong>服务器再验证</strong>”，说明<strong>缓存需要询问原始服务器文档是否发生了变化</strong>。</p> <ul> <li>如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。</li> <li>如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。</li> </ul> <p>HTTP 协议要求行为正确的缓存返回下列内容之一：</p> <ul> <li>“足够新鲜”的已缓存副本;</li> <li>与服务器进行过再验证，确认其仍然新鲜的已缓存副本;</li> <li>如果需要与之进行再验证的原始服务器出故障了， 就返回一条错误报文“;</li> <li>附有警告信息说明内容可能不正确的已缓存副本。</li> </ul> <h3 id="84-用条件方法进行再验证">8.4 用条件方法进行再验证</h3> <p>HTTP 的条件方法可以高效地实现再验证。HTTP 允许缓存向原始服务器发送一个“条件 <code class="language-plaintext highlighter-rouge">GET</code>”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。通过这种方式，将新鲜度检测和对象获取结合成了单个条件 <code class="language-plaintext highlighter-rouge">GET</code>。向 <code class="language-plaintext highlighter-rouge">GET</code> 请求报文中添加一些特殊的条件首部，就可以发起条件 <code class="language-plaintext highlighter-rouge">GET</code>。只有条件为真时，Web 服务器才会返回对象。</p> <p>HTTP 定义了 5 个条件请求首部。对缓存再验证来说最有用的 2 个首部是 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 和 <code class="language-plaintext highlighter-rouge">If-None-Match</code>。所有的条件首部都以前缀 <code class="language-plaintext highlighter-rouge">If-</code> 开头。表 7-3 列出了在缓存再验证中使用的条件请求首部。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="缓存再验证中使用的两个条件首部" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 7-3 缓存再验证中使用的两个条件首部 </div> <h3 id="85-if-modified-since-date-再验证">8.5 If-Modified-Since: Date 再验证</h3> <p>最常见的缓存再验证首部是 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code>。<code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 再验证请求通常被称为 IMS 请求。只有自某个日期之后资源发生了变化的时候，IMS 请求才会指示服务器执行请求：</p> <ul> <li>如果自指定日期后，文档被修改了，<code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 条件就为真，通常 <code class="language-plaintext highlighter-rouge">GET</code> 就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。</li> <li>如果自指定日期后，文档没被修改过，条件就为假，会向客户端返回 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应报文，为了提高有效性，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如，<code class="language-plaintext highlighter-rouge">Content-Type</code> 首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。</li> </ul> <p><code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 首部可以与 <code class="language-plaintext highlighter-rouge">Last-Modified</code> 服务器响应首部配合工作。原始服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行再验证时，就会包含一个 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 首部，其中携带有最后修改已缓存副本的日期：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">If-Modified-Since: &lt;cached last-modified date&gt;
</span></code></pre></div></div> <p>如果在此期间内容被修改了，最后的修改日期就会有所不同，原始服务器就会回送新的文档。否则，服务器会注意到缓存的最后修改日期与服务器文档当前的最后修改日期相符，会返回一个 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="如果未发生变化，If-Modified-Since 再验证会返回 304 响应，如果发生了变化，就返回带有新主体的 200 响应" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-14 如果未发生变化，If-Modified-Since 再验证会返回 304 响应，如果发生了变化，就返回带有新主体的 200 响应 </div> <p>注意，有些 Web 服务器并没有将 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 作为真正的日期来进行比对。相反，它们在 IMS 日期和最后修改日期之间进行了字符串匹配。这样得到的语义就是“如果最后的修改不是在这个确定的日期进行的”，而不是“如果在这个日期之后没有被修改过”。将最后修改日期作为某种序列号使用时，这种替代语义能够很好地识别出缓存是否过期，但这会妨碍客户端将 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 首部用于真正基于时间的一些目的。</p> <h3 id="86-if-none-match-实体标签再验证">8.6 If-None-Match: 实体标签再验证</h3> <p>有些情况下仅使用最后修改日期进行再验证是不够的。</p> <ul> <li>有些文档可能会被周期性地重写（比如，从一个后台进程中写入），但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。</li> <li>有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据（比如对拼写或注释的修改）。</li> <li>有些服务器无法准确地判定其页面的最后修改日期。</li> <li>有些服务器提供的文档会在亚秒间隙发生变化（比如，实时监视器），对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。</li> </ul> <p>为了解决这些问题，HTTP 允许用户对被称为实体标签 <code class="language-plaintext highlighter-rouge">ETag</code> 的“版本标识符”进行比较。实体标签是附加到文档上的任意标签（引用字符串）。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用 <code class="language-plaintext highlighter-rouge">If-None-Match</code> 条件首部来 <code class="language-plaintext highlighter-rouge">GET</code> 文档的新副本了。</p> <p>在图 7-15 中，缓存中有一个实体标签为 <code class="language-plaintext highlighter-rouge">v2.6</code> 的文档。它会与原始服务器进行再验证，如果标签 <code class="language-plaintext highlighter-rouge">v2.6</code> 不再匹配，就会请求一个新对象。在图 7-15 中，标签仍然与之匹配，因此会返回一条 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="因为实体标签仍然匹配，If-None-Match 再验证成功" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-15 因为实体标签仍然匹配，If-None-Match 再验证成功 </div> <p>如果服务器上的实体标签已经发生了变化（可能变成了 <code class="language-plaintext highlighter-rouge">v3.0</code>），服务器会在一个 <code class="language-plaintext highlighter-rouge">200 OK</code> 响应中返回新的内容以及相应的新 <code class="language-plaintext highlighter-rouge">Etag</code>。</p> <p>可以在 <code class="language-plaintext highlighter-rouge">If-None-Match</code> 首部包含几个实体标签，告诉服务器，缓存中已经存在带有这些实体标签的对象副本：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">If-None-Match: "v2.6"
If-None-Match: "v2.4", "v2.5", "v2.6"
If-None-Match: "foobar", "A34FAC0095", "Profiles in Courage"
</span></code></pre></div></div> <h3 id="87-强弱验证器">8.7 强弱验证器</h3> <p>缓存可以用实体标签来判断，与服务器相比，已缓存版本是不是最新的（与使用最近修改日期的方式很像）。从这个角度来看，实体标签和最近修改日期都是<strong>缓存验证器</strong>（cache validator）。</p> <p>有时，服务器希望在对文档进行一些非实质性或不重要的修改时，不要使所有的已缓存副本都失效。HTTP/1.1 支持“弱验证器”，如果只对内容进行了少量修改，就允许服务器声明那是“足够好”的等价体。</p> <p>只要内容发生了变化，强验证器就会变化。弱验证器允许对一些内容进行修改，但内容的主要含义发生变化时，通常它还是会变化的。有些操作不能用弱验证器来实现（比如有条件地获取部分内容），所以，服务器会用前缀 <code class="language-plaintext highlighter-rouge">W/</code> 来标识弱验证器。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">ETag: W/"v2.6"
If-None-Match: W/"v2.6"
</span></code></pre></div></div> <p>不管相关的实体值以何种方式发生了变化，强实体标签都要发生变化。而相关实体在语义上发生了比较重要的变化时，弱实体标签也应该发生变化。</p> <p>注意，原始服务器一定不能为两个不同的实体重用一个特定的强实体标签值，或者为两个语义不同的实体重用一个特定的弱实体标签值。缓存条目都可能会留存任意长的时间，与过期时间无关， 有人可能希望当缓存验证条目时，绝对不会再次使用在过去某一时刻获得的验证器，这种愿望可能不太现实。</p> <h3 id="88-什么时候应该使用实体标签和最近修改日期">8.8 什么时候应该使用实体标签和最近修改日期</h3> <p>如果服务器回送了一个实体标签，HTTP/1.1 客户端就必须使用实体标签验证器。如果服务器只回送了一个 <code class="language-plaintext highlighter-rouge">Last-Modified</code> 值，客户端就可以使用 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 验证。如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样 HTTP/1.0 和 HTTP/1.1 缓存就都可以正确响应了。</p> <p>除非 HTTP/1.1 原始服务器无法生成实体标签验证器，否则就应该发送一个出去，如果使用弱实体标签有优势的话，发送的可能就是个弱实体标签，而不是强实体标签。而且，最好同时发送一个最近修改值。</p> <p>如果 HTTP/1.1 缓存或服务器收到的请求既带有 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code>，又带有实体标签条件首部，那么只有这两个条件都满足时，才能返回 <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 响应。</p> <h2 id="九控制缓存的能力">九、控制缓存的能力</h2> <p>服务器可以通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以：</p> <ul> <li>附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: no-store</code> 首部到响应中去。</li> <li>附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: no-cache</code> 首部到响应中去。</li> <li>附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: must-revalidate</code> 首部到响应中去。</li> <li>附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 首部到响应中去。</li> <li>附加一个 <code class="language-plaintext highlighter-rouge">Expires</code> 日期首部到响应中去。</li> <li>不附加过期信息，让缓存确定自己的过期日期。</li> </ul> <h3 id="91-no-store-与-no-cache-响应首部">9.1 no-Store 与 no-Cache 响应首部</h3> <p>HTTP/1.1 提供了几种限制对象缓存，或限制提供已缓存对象的方式，以维持对象的新鲜度。<code class="language-plaintext highlighter-rouge">no-store</code> 首部和 <code class="language-plaintext highlighter-rouge">no-cache</code> 首部可以防止缓存提供未经证实的已缓存对象：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Pragma: no-cache
Cache-Control: no-store
Cache-Control: no-cache
</span></code></pre></div></div> <p>标识为 <code class="language-plaintext highlighter-rouge">no-store</code> 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条 <code class="language-plaintext highlighter-rouge">no-store</code> 响应，然后删除对象。</p> <p>标识为 <code class="language-plaintext highlighter-rouge">no-cache</code> 的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。这个首部使用 do-not-serve-from-cache-without-revalidation 这个名字会更恰当一些。</p> <p>HTTP/1.1 中提供 <code class="language-plaintext highlighter-rouge">Pragma: no-cache</code> 首部是为了兼容于 HTTP/1.0+。除了与只理解 <code class="language-plaintext highlighter-rouge">Pragma: no-cache</code> 的 HTTP/1.0 应用程序进行交互时，HTTP 1.1 应用程序都应该使用 <code class="language-plaintext highlighter-rouge">Cache-Control: no-cache</code>。</p> <h3 id="92-max-age-响应首部">9.2 max-age 响应首部</h3> <p><code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。还有一个 <code class="language-plaintext highlighter-rouge">s-maxage</code> 首部，其行为与 <code class="language-plaintext highlighter-rouge">max-age</code> 类似，但仅适用于共享（公有）缓存：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
</span></code></pre></div></div> <p>服务器可以请求缓存不要缓存文档，或者将最大使用期设置为零，从而在每次访问的时候都进行刷新：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Cache-Control: max-age=0
Cache-Control: s-maxage=0
</span></code></pre></div></div> <h3 id="93-expires-响应首部">9.3 Expires 响应首部</h3> <p>不推荐使用 <code class="language-plaintext highlighter-rouge">Expires</code> 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。可以通过计算过期值和日期值之间的秒数差来计算类似的新鲜生存期：</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Expires: Fri, 05 Jul 2002, 05:00:00 GMT
</span></code></pre></div></div> <p>有些服务器还会回送一个 <code class="language-plaintext highlighter-rouge">Expires: 0</code> 响应首部，试图将文档置于永远过期的状态，但这种语法是非法的，可能给某些软件带来问题。应该试着支持这种结构的输入，但不应该产生这种结构的输出。</p> <h3 id="94-must-revalidate-响应首部">9.4 must-revalidate 响应首部</h3> <p>可以配置缓存，使其提供一些陈旧（过期）的对象，以提高性能。如果原始服务器希望缓存严格遵守过期信息，可以在原始响应中附加一个 <code class="language-plaintext highlighter-rouge">Cache-Control: must-revalidate</code> 首部。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Cache-Control: must-revalidate
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Cache-Control: must-revalidate</code> 响应首部告诉缓存，在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本。缓存仍然可以随意提供新鲜的副本。如果在缓存进行 <code class="language-plaintext highlighter-rouge">must-revalidate</code> 新鲜度检查时，原始服务器不可用，缓存就必须返回一条 <code class="language-plaintext highlighter-rouge">504 Gateway Timeout</code> 错误。</p> <h3 id="95-试探性过期">9.5 试探性过期</h3> <p>如果响应中没有 <code class="language-plaintext highlighter-rouge">Cache-Control: max-age</code> 首部，也没有 <code class="language-plaintext highlighter-rouge">Expires</code> 首部，缓存可以计算出一个试探性最大使用期。可以使用任意算法，但如果得到的最大使用期大于 24 小时，就应该向响应首部添加一个 Heuristic Expiration Warning（试探性过期警告，警告 13）首部。据我们所知，很少有浏览器会为用户提供这种警告信息。LM-Factor 算法是一种很常用的试探性过期算法，如果文档中包含了最后修改日期，就可以使用这种算法。LM-Factor 算法将最后修改日期作为依据，来估计文档有多么易变。算法的逻辑如下所示。</p> <ul> <li>如果已缓存文档最后一次修改发生在很久以前，它可能会是一份稳定的文档，不太会突然发生变化，因此将其继续保存在缓存中会比较安全。</li> <li>如果已缓存文挡最近被修改过，就说明它很可能会频繁地发生变化，因此在与服务器进行再验证之前，只应该将其缓存很短一段时间。</li> </ul> <p>实际的 LM-Factor 算法会计算缓存与服务器对话的时间跟服务器声明文档最后被修改的时间之间的差值，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时间。下面是 LM-factor 算法的 Perl 伪代码：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$time_since_modify</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$server_Date</span> <span class="o">-</span> <span class="nv">$server_Last_Modified</span><span class="p">);</span>
<span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nv">$time_since_modify</span> <span class="o">*</span> <span class="nv">$lm_factor</span><span class="p">);</span>
</code></pre></div></div> <p>图 7-16 以图形方式给出了 LM-factor 的新鲜周期。图中用交叉线画出的阴影表示的是将 LM-factor 设置为 0.2 计算出的新鲜周期。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="用 LM-factor 算法计算新鲜周期" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-16 用 LM-factor 算法计算新鲜周期 </div> <p>通常人们会为试探性新鲜周期设置上限，这样它们就不会变得太大了。尽管比较保守的站点会将这个值设置为一天，但通常站点会将其设置为一周。</p> <p>如果最后修改日期也没有的话，缓存就没什么信息可利用了。缓存通常会为没有任何新鲜周期线索的文档分配一个默认的新鲜周期（通常是一个小时或一天）。有时，比较保守的缓存会将这种试探性新鲜生存期设置为 0，强制缓存在每次将其提供给客户端之前，都去验证一下这些数据仍然是新鲜的。</p> <p>与试探性新鲜计算有关的最后一点是 —— 它们可能比你想象的要常见得多。很多原始服务器仍然不会产生 <code class="language-plaintext highlighter-rouge">Expires</code> 和 <code class="language-plaintext highlighter-rouge">max-age</code> 首部。选择缓存过期的默认时间时要特别小心!</p> <h3 id="96-客户端的新鲜度限制">9.6 客户端的新鲜度限制</h3> <p>Web 浏览器都有 Refresh（刷新）或 Reload（重载）按钮，可以强制对浏览器或代理缓存中可能过期的内容进行刷新。Refresh 按钮会发布一个附加了 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 请求首部的 <code class="language-plaintext highlighter-rouge">GET</code> 请求，这个请求会强制进行再验证，或者无条件地从服务器获取文档。Refresh 的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。客户端可以用 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 请求首部来强化或放松对过期时间的限制。有些应用程序对文档的新鲜度要求很高（比如人工刷新按钮），对这些应用程序来说，客户端可以用 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部使过期时间更严格。另一方面，作为提高性能、可靠性或开支的一种折衷方式，客户端可能会放松新鲜度要求。表 7-4 对 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 请求指令进行了总结。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Cache-Control 请求指令" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 表 7-4 Cache-Control 请求指令 </div> <h3 id="97-注意事项">9.7 注意事项</h3> <p>文档过期系统并不是一个完美的系统。如果发布者不小心分配了一个很久之后的过期日期，在文档过期之前，她要对文档做的任何修改都不一定能显示在所有缓存中。</p> <p>因此，很多发布者都不会使用很长的过期日期。而且，很多发布者甚至都不使用过期日期，这样缓存就很难确定文档会在多长时间内保持新鲜了。</p> <h2 id="十设置缓存控制">十、设置缓存控制</h2> <p>不同的 Web 服务器为 HTTP Cache-Control 和 Expiration 首部的设置提供了一些不同的机制。本节简要介绍了流行的 Apache Web 服务器是怎样支持缓存控制的。</p> <h3 id="101-控制-apache-的-http-首部">10.1 控制 Apache 的 HTTP 首部</h3> <p>Apache Web 服务器提供了几种设置 HTTP 缓存控制首部的机制。其中很多机制在默认情况下都没有启动——你要启动它们（有些情况下先要获取 Apache 的扩展模块）。下面是对某些 Apache 特性的简要描述。</p> <ul> <li>mod_headers：通过 mod_headers 模块可以对单独的首部进行设置。装载了这个模块，就可以用设置单个 HTTP 首部的指令来扩充 Apache 的配置文件了。还可以将这些设置与 Apache 的常用表达式以及过滤器结合在一起使用，将这些首部与个别内容关联起来。这里有一个配置实例，这个例子将某目录下所有的 HTML 文件都标识为非缓存的：</li> </ul> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Files *。html&gt;
Header set Cache-control no-cache
&lt;/Files&gt;
</code></pre></div></div> <ul> <li>mod_expires：mod_expires 模块提供的程序逻辑可以自动生成带有正确过期日期的 Expires 首部。通过这个模块，就可以将文档的过期日期设置为对其最后一次被访问之后或者其最近修改日期之后的某一时间段。通过这个模块可以为不同的文件类型设置不同的过期日期，还可以使用便捷的详尽描述信息来描述其缓存能力，比如 “access plus 1 month（自访问之后起1个月）”。这里有几个例子：</li> </ul> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"
</code></pre></div></div> <ul> <li>mod_cern_meta：通过 mod_cern_meta 模块可以将一个包含 HTTP 首部的文件与特定的对象联系起来。启动这个模块时，就创建了一组“元文件”，每个需要控制的文档一个，而且还会为每个元文件添加所期望的首部。</li> </ul> <h3 id="102-通过-http-equiv-控制-html-缓存">10.2 通过 HTTP-EQUIV 控制 HTML 缓存</h3> <p>HTTP 服务器响应首部用于回送文档的到期信息以及缓存控制信息。Web 服务器与配置文件进行交互，为所提供的文档分配正确的 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 首部。为了让作者在无需与 Web 服务器的配置文件进行交互的情况下，能够更容易地为所提供的 HTML 文档分配 HTTP 首部信息，HTML 2.0 定义了 <code class="language-plaintext highlighter-rouge">&lt;META HTTP-EQUIV&gt;</code> 标签。这个可选的标签位于 HTML 文档的顶部，定义了应该与文档有所关联的 HTTP 首部。这里有一个 <code class="language-plaintext highlighter-rouge">&lt;META HTTP-EQUIV&gt;</code> 标签设置的例子，它将 HTML 文档标记为非缓冲的：</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;HTML&gt;</span>
<span class="nt">&lt;HEAD&gt;</span>
<span class="nt">&lt;TITLE&gt;</span>My Document<span class="nt">&lt;/TITLE&gt;</span>
<span class="nt">&lt;META</span> <span class="na">HTTP-EQUIV=</span><span class="s">"Cache-control"</span> <span class="na">CONTENT=</span><span class="s">"no-cache"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/HEAD&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
</code></pre></div></div> <p>最初，HTTP-EQUIV标签是给 Web 服务器使用的。如 HTML RFC 1866 所述，Web 服务器应该为 HTML 解析 <code class="language-plaintext highlighter-rouge">&lt;META HTTP-EQUIV&gt;</code> 标签，并将规定的首部插入 HTTP 响应中：</p> <p>HTTP 服务器可以用此信息来处理文档。特别是，它可以在为请求此文档的报文所发送的响应中包含一个首部字段：首部名称是从 <code class="language-plaintext highlighter-rouge">HTTP-EQUIV</code> 属性值中获取的，首部值是从 <code class="language-plaintext highlighter-rouge">CONTENT</code> 属性值中获取的。</p> <p>不幸的是，支持这个可选特性会增加服务器的额外负载，这些值也只是静态的，而且它只支持 HTML，不支持很多其他的文件类型，所以很少有 Web 服务器和代理支持此特性。</p> <p>但是，有些浏览器确实会解析并在 HTML 内容中使用 <code class="language-plaintext highlighter-rouge">HTTP-EQUIV</code> 标签，像对待真的 HTTP 首部那样来处理嵌入式首部（参见图 7-17）。这样的效果并不好，因为支持 <code class="language-plaintext highlighter-rouge">HTTP-EQUIV</code> 标签的 HTML 浏览器使用的 <code class="language-plaintext highlighter-rouge">Cache-control</code> 规则可能会与拦截代理缓存所用的规则有所不同。这样会使缓存的过期处理行为发生混乱。</p> <p>总之，<code class="language-plaintext highlighter-rouge">&lt;META HTTP-EQUIV&gt;</code> 标签并不是控制文档缓存特性的好方法。通过配置正确的服务器发出 HTTP 首部，是传送文档缓存控制请求的唯一可靠的方法。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="大多数软件都会忽略 HTTP-EQUIV 标签，所以这些标签可能会带来一些问题" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-17 大多数软件都会忽略 HTTP-EQUIV 标签，所以这些标签可能会带来一些问题 </div> <h2 id="十一详细算法">十一、详细算法</h2> <p>HTTP 规范提供了一个详细，但有点儿含糊不清而且经常会让人混淆的算法，来计算文档的使用期以及缓存的新鲜度。本节会对 HTTP 的新鲜度计算算法进行详细的讨论（参见图 7-12 中那个“足够新鲜？”菱形框），并对此算法的动机进行解释。本节最适用于那些研究缓存内部机制的人。为了便于说明 HTTP 规范中的内容，我们使用了 Perl 伪代码。</p> <h3 id="111-使用期和新鲜生存期">11.1 使用期和新鲜生存期</h3> <p>为了分辨已缓存文档是否足够新鲜，缓存只需要计算两个值：已缓存副本的使用期（age），和已缓存副本的新鲜生存期（freshness lifetime）。如果已缓存副本的时长小于新鲜生存期，就说明副本足够新鲜，可以使用。用 Perl 表示为：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$is_fresh_enough</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$age</span> <span class="o">&lt;</span> <span class="nv">$freshness_lifetime</span><span class="p">);</span>
</code></pre></div></div> <p>文档的使用期就是自从服务器将其发送出来（或者最后一次被服务器再验证）之后“老去”的总时间。”缓存可能不知道文档响应是来自上游缓存，还是来自服务器的，所以它不能假设文档是最新的。它必须根据显式的 <code class="language-plaintext highlighter-rouge">Age</code> 首部（优先），或者通过对服务器生成的 <code class="language-plaintext highlighter-rouge">Date</code> 首部的处理，来确定文档的使用期。</p> <p>文档的新鲜生存期表明，已缓存副本在经过多长时间之后，就会因新鲜度不足而无法再向客户端提供了。新鲜生存期考虑了文档的过期日期，以及客户端可能请求的任何新鲜度覆盖范围。</p> <p>有些客户端可能愿意接受稍微有些过期的文档（使用 <code class="language-plaintext highlighter-rouge">Cache-Control: max-stale</code> 首部）。有些客户端可能无法接受会在近期过期的文档（使用 <code class="language-plaintext highlighter-rouge">Cache-Control: min-fresh</code> 首部）。缓存将服务器过期信息与客户端的新鲜度要求结合在一起，以确定最大的新鲜生存期。</p> <h3 id="112-使用期的计算">11.2 使用期的计算</h3> <p>响应的使用期就是服务器发布响应（或服务器对其进行了再验证）之后经过的总时间。使用期包含了响应在因特网路由器和网关中游荡的时间，在中间节点缓存中存储的时间，以及响应在你的缓存中停留的时间。例 7-1 给出了使用期计算的伪代码。</p> <p>例 7-1 HTTP/1.1 使用期计算算法计算了已缓存文档的总体使用期</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$time_got_response</span> <span class="o">-</span> <span class="nv">$Date_header_value</span><span class="p">);</span>
<span class="nv">$corrected_apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="nv">$apparent_age</span><span class="p">,</span> <span class="nv">$Age_header_value</span><span class="p">);</span>
<span class="nv">$response_delay_estimate</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$time_got_response</span> <span class="o">-</span> <span class="nv">$time_issued_request</span><span class="p">);</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">=</span> <span class="nv">$corrected_apparent_age</span> <span class="o">+</span> <span class="nv">$response_delay_estimate</span><span class="p">;</span>
<span class="nv">$how_long_copy_has_been_in_our_cache</span> <span class="o">=</span> <span class="nv">$current_time</span> <span class="o">-</span> <span class="nv">$time_got_response</span><span class="p">;</span>
<span class="nv">$age</span> <span class="o">=</span> <span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">+</span> <span class="nv">$how_long_copy_has_been_in_our_cache</span><span class="p">;</span> 
</code></pre></div></div> <p>HTTP 使用期计算的细节有点儿棘手，但其基本概念很简单。响应到达缓存时，缓存可以通过查看 <code class="language-plaintext highlighter-rouge">Date</code> 首部或 <code class="language-plaintext highlighter-rouge">Age</code> 首部来判断响应已使用的时间。缓存还能记录下文档在本地缓存中的停留时间。把这些值加在一起，就是响应的总使用期。HTTP 用一些魔法对时钟偏差和网络时延进行了补偿，但基本计算非常简单：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$age</span> <span class="o">=</span> <span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">+</span> <span class="nv">$how_long_copy_has_been_in_our_cache</span><span class="p">;</span> 
</code></pre></div></div> <p>缓存可以很方便地判断出已缓存副本已经在本地缓存了多长时间（这就是简单的簿记问题），但很难确定响应抵达缓存时的使用期，因为不是所有服务器的时钟都是同步的，而且我们也不知道响应到过哪里。完善的使用期计算算法会试着对此进行补偿。</p> <h4 id="1表面使用期是基于-date-首部的">（1）表面使用期是基于 Date 首部的</h4> <p>如果所有的计算机都共享同样的、完全精确的时钟，已缓存文档的使用期就可以是文档的“表面使用期”——当前时间减去服务器发送文档的时间。服务器发送时间就是 <code class="language-plaintext highlighter-rouge">Date</code> 首部的值。最简单的起始时间计算可以直接使用表面时间：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">$time_got_response</span> <span class="o">-</span> <span class="nv">$Date_header_value</span><span class="p">;</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">=</span> <span class="nv">$apparent_age</span><span class="p">;</span>
</code></pre></div></div> <p>但并不是所有的时钟都实现了良好的同步。客户端和服务器时钟之间可能有数分钟的差别，如果时钟没有设置好的话，甚至会有数小时或数天的区别。</p> <p>Web 应用程序，尤其是缓存代理，要做好与时间值有很大差异的服务器进行交互的准备。这种问题被称为时钟偏差（clock skew）——两台计算机时钟设置的不同。由于时钟偏差的存在， 表面使用期有时会不太准确，而且有时会是负的。</p> <p>如果使用期是负的，就将其设置为零。我们还可以对表面使用期进行完整性检查，以确定它没有大得令人不可思议，不过，实际上，表面使用期可能并没错。我们可能在与一个将文档缓存了很久的父缓存对话（缓存可能还存储了原始的 <code class="language-plaintext highlighter-rouge">Date</code> 首部）：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$time_got_response</span> <span class="o">-</span> <span class="nv">$Date_header_value</span><span class="p">);</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">=</span> <span class="nv">$apparent_age</span><span class="p">;</span>
</code></pre></div></div> <p>要明确 <code class="language-plaintext highlighter-rouge">Date</code> 首部描述的是原始服务器的日期。代理和缓存一定不能修改这个日期!</p> <h4 id="2逐跳使用期的计算">（2）逐跳使用期的计算</h4> <p>这样就可以去除时钟偏差造成的负数使用期了，但对时钟偏差给精确性带来的整体偏差，我们能做的工作很少。文档经过代理和缓存时，HTTP/1.1 会让每台设备都将相对使用期累加到 <code class="language-plaintext highlighter-rouge">Age</code> 首部中去，以此来解决缺乏通用同步时钟的问题。这种方式并不需要进行跨服务器的、端到端的时钟对比。</p> <p>文档经过代理时，<code class="language-plaintext highlighter-rouge">Age</code> 首部值会随之增加。使用 HTTP/1.1 的应用程序应该在 <code class="language-plaintext highlighter-rouge">Age</code> 首部值中加上文档在每个应用程序和网络传输过程中停留的时间。每个中间应用程序都可以很容易地用本地时钟计算出文档的停留时间。</p> <p>但响应链中所有的非 HTTP/1.1 设备都无法识别 <code class="language-plaintext highlighter-rouge">Age</code> 首部，它们会将首部未经修改地转发出去，或者将其删除掉。因此，在 HTTP/1.1 得到普遍应用之前，<code class="language-plaintext highlighter-rouge">Age</code> 首部都将是低估了的相对使用期。</p> <p>除了基于 <code class="language-plaintext highlighter-rouge">Date</code> 计算出来的 <code class="language-plaintext highlighter-rouge">Age</code> 之外，还使用了相对 <code class="language-plaintext highlighter-rouge">Age</code> 值，而且不论是跨服务器的 <code class="language-plaintext highlighter-rouge">Date</code> 值，还是计算出来的 <code class="language-plaintext highlighter-rouge">Age</code> 值都可能被低估，所以会选择使用估计出的两个 <code class="language-plaintext highlighter-rouge">Age</code> 值中最保守的那个（最保守的值就是最老的 <code class="language-plaintext highlighter-rouge">Age</code> 值）。使用这种方式，HTTP 就能容忍 <code class="language-plaintext highlighter-rouge">Age</code> 首部存在的错误，尽管这样可能会搞错究竟哪边更新鲜：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="err">（</span><span class="mi">0</span><span class="err">，</span> <span class="nv">$time_got_response</span> <span class="nv">$Date_header_value</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$corrected_apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="err">（</span><span class="nv">$apparent_age</span><span class="err">，</span> <span class="nv">$Age_header_value</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$corrected_apparent_age</span><span class="p">;</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span>
</code></pre></div></div> <h4 id="3对网络时延的补偿">（3）对网络时延的补偿</h4> <p>事务处理可能会很慢。这是使用缓存的主要动因。但对速度非常慢的网络，或者那些过载的服务器来说，如果文档在网络或服务器中阻塞了很长时间，相对使用期的计算可能会极大地低估文档的使用期。</p> <p><code class="language-plaintext highlighter-rouge">Date</code> 首部说明了文档是在什么时候离开原始服务器的，但并没有说明文档在到缓存的传输过程中花费了多长时间。如果文档的传输经过了一长串的代理和父缓存，网络时延可能会相当大。</p> <p>没有什么简便的方法可以用来测量从服务器到缓存的单向网络时延，但往返时延则比较容易测量。缓存知道它请求文档的时间，以及文档抵达的时间。HTTP/1.1 会在这些网络时延上加上整个往返时延，以便对其进行保守地校正。这个从缓存到服务</p> <p>器再到缓存的时延高估了从服务器到缓存的时延，但它是保守的。如果出错了，它只会使文档看起来比实际使用期要老，并引发不必要的再验证。计算是这样进行的：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$apparent_age</span> <span class="o">=</span> <span class="nv">max</span><span class="err">（</span><span class="mi">0</span><span class="err">，</span> <span class="nv">$time_got_response</span> <span class="nv">$Date_header_value</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$corrected_apparent_age</span> <span class="o">=</span> <span class="nv">max</span> <span class="err">（</span><span class="nv">$apparent_age</span><span class="err">，</span> <span class="nv">$Age_header_value</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$response_delay_estimate</span> <span class="o">=</span> <span class="err">（</span><span class="nv">$time_got_response</span> <span class="nv">$time_issued_request</span><span class="err">）</span><span class="p">;</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span>
<span class="o">=</span>
<span class="nv">$corrected_apparent_age</span> <span class="o">+</span> <span class="nv">$response_delay_estimate</span><span class="p">;</span>
</code></pre></div></div> <h3 id="113-完整的使用期计算算法">11.3 完整的使用期计算算法</h3> <p>上一节说明了当HTTP 所承载的文档抵达缓存时，如何计算其使用期。只要将这条响应存储到缓存中去，它就会进一步老化。当对缓存中文档的请求到达时，我们需要知道文档在缓存中停留了多长的时间，这样才能计算文档现在的使用期：</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$age</span> <span class="o">=</span>
<span class="nv">$age_when_document_arrived_at_our_cache</span> <span class="o">+</span>
<span class="nv">$how_long_copy_has_been_in_our_cache</span><span class="p">;</span>
</code></pre></div></div> <p>嗒嗒!这样就有了例 7-1 中给出的完整的 HTTP/1.1 使用期计算算法。这就是简单的簿记问题了——我们知道了文档是什么时候到达缓存的（$time_got_reponse），也知道当前请求是什么时候到达的（刚才），这样停留时间就是两者之差了。所有这些都以图形方式显示在图 7-18 中了。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/http-the-definitive-guide/-480.webp 480w,/assets/images/http-the-definitive-guide/-800.webp 800w,/assets/images/http-the-definitive-guide/-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/http-the-definitive-guide/.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="已缓存文档的使用期包括在网络和缓存中停留的时间" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 7-18 已缓存文档的使用期包括在网络和缓存中停留的时间 </div> <h3 id="114-新鲜生存期计算">11.4 新鲜生存期计算</h3> <p>回想一下，我们是在想办法弄清楚已缓存文档是否足够新鲜，是否可以提供给客户端。要回答这个问题，就必须确定已缓存文档的使用期，并根据服务器和客户端限制来计算新鲜生存期。我们刚刚解释了如何计算使用期;现在我们来看看新鲜生存期的计算。</p> <p>文档的新鲜生存期说明了在文档不再新鲜，无法提供给某个特定的客户端之前能够停留多久。新鲜生存期取决于服务器和客户端的限制。服务器上可能有一些与文档的出版变化率有关的信息。那些非常稳定的已归档报告可能会在数年内保持新鲜。期刊可能只在下一期的出版物出来之前的剩余时间内有效——下一周，或是明早6点。</p> <p>客户端可能有些其他指标。如果稍微有些过期的内容速度更快的话，它们可能也愿意接受，或者它们可能希望接收最新的内容。缓存是为用户服务的。必须要满足他们的要求。</p> <h3 id="115-完整的服务器---新鲜度算法">11.5 完整的服务器 - 新鲜度算法</h3> <p>例 7-2 给出了一个用于计算服务器新鲜度限制的 Perl 算法。它会返回文档仍由服务器提供时所能到达的最大使用期。</p> <p>例 7-2 服务器新鲜度限制的计算</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sub </span><span class="nf">server_freshness_limit</span>
<span class="p">{</span> 
 <span class="nb">local</span><span class="p">(</span><span class="nv">$heuristic</span><span class="p">,</span><span class="nv">$server_freshness_limit</span><span class="p">,</span><span class="nv">$time_since_last_modify</span><span class="p">);</span>
 <span class="nv">$heuristic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Max_Age_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$Max_Age_value</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="nv">elseif</span> <span class="p">(</span><span class="nv">$Expires_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$Expires_value</span> <span class="o">-</span> <span class="nv">$Date_value</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="nv">elseif</span> <span class="p">(</span><span class="nv">$Last_Modified_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$time_since_last_modify</span> <span class="o">=</span> <span class="nv">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$Date_value</span> <span class="o">-</span> 
<span class="err">　　　　　　　　</span><span class="nv">$Last_Modified_value</span><span class="p">);</span>
 <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nv">$time_since_last_modify</span> <span class="o">*</span>
<span class="err">　　　　　　　　</span><span class="nv">$lm_factor</span><span class="p">);</span>
 <span class="nv">$heuristic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">else</span>
 <span class="p">{</span>
  <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$default_cache_min_lifetime</span><span class="p">;</span>
 <span class="nv">$heuristic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$heuristic</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$server_freshness_limit</span> <span class="o">&gt;</span> <span class="nv">$default_cache_max_lifetime</span><span class="p">)</span>
 <span class="p">{</span> <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$default_cache_max_lifetime</span><span class="p">;</span> <span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$server_freshness_limit</span> <span class="o">&lt;</span> <span class="nv">$default_cache_min_lifetime</span><span class="p">)</span>
 <span class="p">{</span> <span class="nv">$server_freshness_limit</span> <span class="o">=</span> <span class="nv">$default_cache_min_lifetime</span><span class="p">;</span> <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span><span class="p">(</span><span class="nv">$server_freshness_limit</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>现在，我们来看看客户端怎样修正服务器为文档指定的使用期限制。例 7-3 显示了一个 Perl 算法，此算法获取了服务器的新鲜度限制并根据客户端的限制对其进行修改。它会返回一个最大使用期，这是在无需再次验证，仍由缓存提供文档的前提下，文档的最大生存时间。</p> <p>例 7-3 客户端新鲜度限制的计算</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sub </span><span class="nf">client_modified_freshness_limit</span>
<span class="p">{</span>
 <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">server_freshness_limit</span><span class="p">(</span> <span class="p">);</span> <span class="c1">## From Example 7-2</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Max_Stale_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Max_Stale_value</span> <span class="o">==</span> <span class="nv">$INT_MAX</span><span class="p">)</span>
 <span class="p">{</span> <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">$INT_MAX</span><span class="p">;</span> <span class="p">}</span>
 <span class="k">else</span>
 <span class="p">{</span> <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">server_freshness_limit</span><span class="p">(</span> <span class="p">)</span> <span class="o">+</span> <span class="nv">$Max_Stale_value</span><span class="p">;</span> <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Min_Fresh_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">min</span><span class="p">(</span><span class="nv">$age_limit</span><span class="p">,</span> <span class="nv">server_freshness_limit</span><span class="p">(</span> <span class="p">)</span> <span class="o">-</span> 
<span class="err">　　　　　　　</span><span class="nv">$Min_Fresh_value_set</span><span class="p">);</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$Max_Age_value_set</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="nv">$age_limit</span> <span class="o">=</span> <span class="nv">min</span><span class="p">(</span><span class="nv">$age_limit</span><span class="p">,</span> <span class="nv">$Max_Age_value</span><span class="p">);</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>整个进程中包含两个变量：文档的使用期及其新鲜度限制。如果使用期小于新鲜度限制，就说明文档“足够新鲜”。例 7-3 中的算法只是考虑了服务器的新鲜度限制，并根据附加的客户端限制对其进行了调整。希望通过本节的介绍能使在 HTTP 规范中描述的比较微妙的过期算法更清晰一些。</p> <h2 id="十二缓存和广告">十二、缓存和广告</h2> <p>读到这里，你一定已经意识到缓存可以提高性能并减少流量。知道缓存可以帮助用户，并为用户提供更好的使用体验，而且缓存也可以帮助网络运营商减少流量。</p> <h3 id="121-发布广告者的两难处境">12.1 发布广告者的两难处境</h3> <p>你可能认为内容提供商会喜欢缓存。毕竟，如果到处都是缓存的话，内容提供商就不需要购买大型的多处理器 Web 服务器来满足用户需求了——他们不需要付过高的网络服务费，一遍一遍地向用户发送同样的数据。更好的一点是，缓存可以将那些漂亮的文章和广告以更快，甚至更好看的方式显示在用户的显示器上，鼓励他们去浏览更多的内容，看更多的广告。这就是内容提供商所希望的!吸引更多的眼球和更多的广告!</p> <p>但这就是困难所在。很多内容提供商的收益都是通过广告实现的 具体来说，每向用户显示一次广告内容，内容提供商就会得到相应的收益。（可能还不到一两便士，但如果一天显示数百万条广告的话，这些钱就会叠加起来!）这就是缓存的问题——它们会向原始服务器隐藏实际的访问次数。如果缓存工作得很好，原始服务器可能根本收不到任何 HTTP 访问，因为这些访问都被因特网缓存吸收了。但如果你的收益是基于访问次数的话，你就高兴不起来了。</p> <h3 id="122-发布者的响应">12.2 发布者的响应</h3> <p>现在，广告商会使用各种类型的“缓存清除”技术来确保缓存不会窃取他们的命中流量。他们会在内容上加上 <code class="language-plaintext highlighter-rouge">no-cache</code> 首部。他们会通过 CGI 网关提供广告。还会在每次访问时重写广告 URL。</p> <p>这些缓存清除技术并不仅用于代理缓存。实际上，现在主要将其用于每个 Web 浏览器中都启用了的缓存。但是，如果某些内容提供商维护其命中率的行为太过火了，就会降低缓存为其站点带来的积极作用。</p> <p>理想情况下，内容提供商会让缓存吸收其流量，而缓存会告诉内容提供商它们拦截了多少次命中。现在，缓存有好几种方式可以做到这一点。</p> <p>一种解决方案就是配置缓存，每次访问时都与原始服务器进行再验证。这样，每次访问时都会将命中推向原始服务器，但通常不会传送任何主体数据。当然，这样会降低事务处理的速度。</p> <h3 id="123-日志迁移">12.3 日志迁移</h3> <p>理想的解决方案是不需要将命中传递给服务器的。毕竟，缓存就可以记录下所有的命中。缓存只要将命中日志发送给服务器就行了。实际上，为了保持内容提供商们的满意度， 有些大型缓存的提供商已经在对缓存日志进行人工处理，并将其传送给受影响的内容提供商了。</p> <p>但是，命中日志很大，很难移动。而缓存日志并没有被标准化或被组织成独立的日志，以传送给单独的内容提供商。而且，这里面还存在着认证和隐私问题。已经有一些高效（和不那么高效的）日志分发策略的建议了。但还没有哪个建议成熟到足以为 Web 软件厂商采用。很多建议都非常复杂，需要联合商业伙伴才能实现。“有几家联合厂商已经开始开发广告收入改造工程的支撑框架了。</p> <h3 id="124-命中计数和使用限制">12.4 命中计数和使用限制</h3> <p>RFC 2227，“HTTP 的简单命中计数和使用限制”中定义了一种简单得多的方案。这个协议向 HTTP 中添加了一个称为 Meter 的首部，这个首部会周期性地将对特定URL 的命中次数回送给服务器。通过这种方式，服务器可以从缓存周期性地获取对已缓存文档命中次数的更新。</p> <p>而且，服务器还能控制在缓存必须向服务器汇报之前，其中的文档还可以使用多少次，或者为缓存文档设置一个时钟超时值。这种控制方式被称为使用限制;通过这种方式，服务器可以对缓存向原始服务器汇报之前，已缓存资源的使用次数进行控制。</p> <h2 id="十三参考">十三、参考</h2> <ul> <li><a href="https：//www.oreilly.com/library/view/http-the-definitive/1565925092/">HTTP 权威指南</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="computer"/><category term="networks"/><category term="http"/><summary type="html"><![CDATA[本文节选自《HTTP 权威指南 - 第4章 连接管理》。]]></summary></entry></feed>