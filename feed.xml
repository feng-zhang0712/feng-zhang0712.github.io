<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-19T15:26:10+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html"></title><link href="https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer/" rel="alternate" type="text/html" title=""/><published>2024-09-19T15:26:10+00:00</published><updated>2024-09-19T15:26:10+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer/"><![CDATA[<h2 id="一介绍">一、介绍</h2> <p>数据链路层属于计算机网络的低层。数据链路层使用的信道主要有以下两种类型：</p> <ul> <li><strong>点对点信道</strong>。这种信道使用一对一的点对点通信方式。</li> <li><strong>广播信道</strong>。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li> </ul> <p>本章中我们研究的是在同一个局域网中，分组怎样从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，局域网仍属于数据链路层的范围。</p> <p>下面看一下两台主机通过互联网进行通信时数据链路层所处的地位（图 3-1）。图 3-1（a）表示用户主机 $H_1$ 通过电话线上网，中间经过三个路由器（$R_1$，$R_1$ 和 $R_1$）连接到远程主机 $H_2$。所经过的网络可以是多种的，如电话网、局域网和广域网。当主机 $H_1$ 向 $H_2$ 发送数据时，从协议的层次上看，数据的流动如图 3-1（b）所示。主机 $H_1$ 和 $H_2$ 都有完整的五层协议栈，但路由器在转发分组时使用的协议栈只有下面的三层。数据进入路由器后要先从物理层上到网络层，在转发表中找到下一跳的地址后，再下到物理层转发出去。因此，数据从主机 $H_1$ 传送到主机 $H_2$ 需要在路径中的各结点的协议栈向上和向下流动多次，如图中的浅灰色箭头所示。</p> <p>然而当我们专门研究数据链路层的问题时，在许多情况下我们可以只关心在协议栈中水平方向的各数据链路层。于是，当主机 $H_1$ 向主机 $H_2$ 发送数据时，我们可以想象数据就是在数据链路层从左向右沿水平方向传送的，如图3 -2 中从左到右的粗箭头所示，即通过以下这样的链路：</p> <p>$H_1$ 的链路层 → $R_1$ 的链路层 → $R_2$ 的链路层 → $R_3$ 的链路层 → $H_2$ 的链路层</p> <p><img src="/assets/images/computer-networks/data-flow-at-the-data-link-layer.png" alt="数据在数据链路层的流动"/> <em>图 3-2 只考虑数据在数据链路层的流动</em></p> <p>图 3-2 指出，从数据链路层来看，$H_1$ 到 $H_2$ 的通信可以看成由四段不同的链路层通信组成，即：$H_1$ → $R_1$，$R_1$ → $R_2$，$R_2$ → $R_3$ 和 $R_3$ → $H_2$。这四段不同的链路层可能采用不同的数据链路层协议。</p> <h2 id="二使用点对点信道的数据链路层">二、使用点对点信道的数据链路层</h2> <h3 id="21-数据链路和帧">2.1 数据链路和帧</h3> <p>“链路”和“数据链路”并不是一回事。</p> <ul> <li><strong>链路</strong>（link）：指从一个结点到相邻结点的一段物理线路（有线或无线），中间没有任何其他的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。</li> <li><strong>数据链路</strong>（data link）：是另一个概念。这是因为当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用<strong>网络适配器</strong>（既有硬件，也包括软件）来实现这些协议。一般的适配器都包括了数据链路层和物理层这两层的功能。</li> </ul> <p>数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是 <strong>IP 数据报</strong>（或简称为数据报、分组或包）。</p> <p>为了把主要精力放在点对点信道的数据链路层协议上，可以采用如图 3-3（a）所示的三层模型。在这种三层模型中，不管在哪段链路上的通信（主机和路由器之间或两个路由器之间），我们都看成是结点和结点的通信（如图中的结点 A 和 B），而每个结点只有下三层：网络层、数据链路层和物理层。</p> <p><img src="/assets/images/computer-networks/data-link-layer-using-point-to-point-channel.png" alt="使用点对点信道的数据链路层"/> <em>图 3-3 使用点对点信道的数据链路层</em></p> <p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p> <ol> <li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。</li> <li>结点 A 把封装好的帧发送给结点 B 的数据链路层。</li> <li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。</li> </ol> <p>数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方，如图 3-3（b）所示。</p> <h3 id="22-三个基本问题">2.2 三个基本问题</h3> <p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：<strong>封装成帧</strong>、<strong>透明传输</strong>和<strong>差错检测</strong>。</p> <h4 id="1封装成帧">（1）封装成帧</h4> <p><strong>封装成帧</strong>（framing）就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束（图 3-4 表示用帧首部和帧尾部封装成帧的一般概念）。我们知道，分组交换的一个重要概念就是：所有在互联网上传送的数据都以分组（即 IP 数据报）为传送单位。网络层的 IP 数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行<strong>帧定界</strong>（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限</strong> —— <strong>最大传送单元 MTU</strong>（Maximum Transfer Unit）。图 3-4 给出了帧的首部和尾部的位置，以及帧的数据部分与 MTU 的关系。</p> <p><img src="/assets/images/computer-networks/encapsulate-frames-with-frame-headers-and-tails.png" alt="用帧首部和尾部封装成帧"/> <em>图 3-4 用帧首部和尾部封装成帧</em></p> <p>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的<strong>帧定界符</strong>。我们知道，ASCII 码是 7 位编码，一共可组合成 128 个不同的 ASCII 码，其中可打印的有 95 个，而不可打印的控制字符有 33 个。图 3-5 的例子可说明帧定界的概念。控制字符 SOH（Start Of Header）放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT （End Of Transmission）表示帧的结束。请注意，SOH 和 EOT 都是控制字符的名称。它们的十六进制编码分别是 01（二进制是 00000001）和 04（二进制是 00000100）。</p> <p><img src="/assets//images/computer-networks/method-of-delimiting-frames-with-control-characters.png" alt="用控制字符进行帧定界的方法举例"/> <em>图 3-5 用控制字符进行帧定界的方法举例</em></p> <p>当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧（只有首部开始符 SOH 而没有传输结束符 EOT），必须丢弃。而后面收到的数据有明确的帧定界符（SOH 和 EOT），因此这是一个完整的帧，应当收下。</p> <h4 id="2透明传输">（2）透明传输</h4> <p>由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。</p> <p>当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现像 SOH 或 EOT 这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p> <p>但当数据部分是非 ASCII 码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 这种控制字符一样（见图 3-6），数据链路层就会错误地“找到帧的边界”，把部分帧收下（误认为是个完整的帧），而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符 SOH）。</p> <p><img src="/assets/images/computer-networks/the-data-section-happens-to-have-the-same-code-as-the-eot.png" alt="数据部分恰好出现与 EOT 一样的代码"/> <em>图 3-6 数据部分恰好出现与EOT 一样的代码</em></p> <p>像图 3-6 所示的帧的传输显然就不是“透明传输”，因为当遇到数据中碰巧出现字符“EOT”时就传不过去了。数据中的“EOT”将被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端当作无效帧而丢弃。但实际上在数据中出现的字符“EOT”并非控制字符而仅仅是二进制数据 00000100。</p> <p>前面提到的“透明”是一个很重要的术语。它表示：<strong>某个实际存在的事物看起来却好像不存在一样</strong>（例如，你看不见在你前面有块 100%透明的玻璃的存在）。“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。</p> <p>为了解决透明传输问题，必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。具体的方法是：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个<strong>转义字符</strong>“ESC”（其十六进制编码是 1B，二进制是 00011011）。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为<strong>字节填充</strong>（byte stuffing）或<strong>字符填充</strong>（character stuffing）。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。图 3-7 表示用字节填充法解决透明传输的问题。</p> <p><img src="/assets/images/computer-networks/using-byte-filling-method-to-solve-the-problem-of-transparent-transmission.png" alt="用字节填充法解决透明传输的问题"/> <em>图 3-7 用字节填充法解决透明传输的问题</em></p> <h4 id="4差错检测">（4）差错检测</h4> <p>现实的通信链路都不会是理想的。这就是说，比特在传输过程中可能会产生差错：1 可能会变成 0，而 0 也可能变成 1。这就叫做<strong>比特差错</strong>。比特差错是传输差错中的一种。在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率 BER</strong> （Bit Error Rate）。例如，误码率为 $10^{-10}$ 时，表示平均每传送 $10_{10}$ 个比特就会出现一个比特的差错。误码率与信噪比有很大的关系。如果设法提高信噪比，就可以使误码率减小。实际的通信链路并不是理想的，它不可能使误码率下降到零。因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了<strong>循环冗余检验 CRC</strong>（Cyclic Redundancy Check）的检错技术。</p> <p>下面我们通过一个简单的例子来说明循环冗余检验的原理。</p> <p>在发送端，先把数据划分为组，假定每组 k 个比特。现假定待传送的数据 M = 101001（k = 6）。CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位<strong>冗余码</strong>，然后构成一个帧发送出去，一共发送（k + n）位。在所要发送的数据后面增加 n 位的冗余码，虽然增大了数据传输的开销，但却可以进行差错检测。当传输可能出现差错时，付出这种代价往往是很值得的。</p> <p>这 n 位冗余码可用以下方法得出。用二进制的<strong>模 2 运算</strong>进行 $2^n$ 乘 M 的运算，这相当于在 M 后面添加 n 个 O。得到的（k + n）位的数除以收发双方事先商定的长度为（n + 1）位的除数 P，得出商是 Q 而余数是 R（n 位，比 P 少一位）（关于除数 P 下面还要介绍）。在图 3-8 所示的例子中，M = 101001（即 k = 6）。假定除数P = 1101（即 n = 3）。经模 2 除法运算后的结果是：商 Q = 110101 （这个商并没有什么用处），而余数 R = 001。这个余数 R 就作为冗余码拼接在数据 M 的后面发送出去。这种为了进行检错而添加的冗余码常称为<strong>帧检验序列 FCS</strong>（Frame Check Sequence）。因此加上 FCS 后发送的帧是 101001001（即 $2^nM$ + FCS），共有（k + n）位。</p> <p>顺便说一下，循环冗余检验 CRC 和帧检验序列 FCS 并不是同一个概念。CRC 是一种检错方法，而 FCS 是添加在数据后面的冗余码，在检错方法上可以选用 CRC，但也可不选用 CRC。</p> <p><img src="/assets/images/computer-networks/examples-that-illustrate-the-principle-of-cyclic-redundancy-checking.png" alt="说明循环冗余检验原理的例子"/> <em>图 3-8 说明循环冗余检验原理的例子</em></p> <p>在接收端把接收到的数据帧为单位进行 CRC 检验：把收到的每个帧都除以同样的除数 P（模 2 运算），然后检查得到的余数 R。</p> <p>如果在传输过程中无差错，那么经过 CRC 检验后得出的余数 R 肯定是 0（读者可以自己验算一下。被除数现在是 101001001，而除数是 P = 1101，看余数 R 是否为 0）。</p> <p>但如果出现误码，那么余数 R 仍等于零的概率是非常非常小的（这可以通过不太复杂的概率计算得出，例如，可参考[TANE11]）。</p> <p>总之，在接收端对收到的每一帧经过 CRC 检验后，有以下两种情况：</p> <ul> <li>若得出的余数 R = 0，则判定这个帧没有差错，就接受（accept）。</li> <li>若余数 R ≠ 0，则判定这个帧有差错（但无法确定究竟是哪一位或哪几位出现了差错），就丢弃。</li> </ul> <p>一种较方便的方法是用多项式来表示循环冗余检验过程。在上面的例子中，用多项式 P(X) = $X_3$ + $X_2$ + 1 表示上面的除数 P = 1101（最高位对应于 $X_3$，最低位对应于 $X_0$）。多项式 P(X) 称为<strong>生成多项式</strong>。现在广泛使用的生成多项式 P(X) 有以下几种：</p> <p>\(CRC-16 = X_{16} + X_{15} + X_2 + 1\) \(CRC-CCITT = X_{16} + X_{12} + X_5 + 1\) \(CRC-32 = X_{32} + X_{26} + X_{23} + X_{22} + X_{16} + X_{12} + X_{11} + X_{10} + X_8 + X_7 + X_5 + X_4 + X_2 + X + 1\)</p> <p>在数据链路层，发送端帧检验序列 FCS 的生成和接收端的 CRC 检验都是用硬件完成的，处理很迅速，因此并不会延误数据的传输。</p> <p>从以上的讨论不难看出，如果我们在传送数据时不以帧为单位来传送，那么就无法加入冗余码以进行差错检验。因此，如果要在数据链路层进行差错检验，就必须把数据划分为帧，每一帧都加上冗余码，一帧接一帧地传送，然后在接收方逐帧进行差错检验。</p> <p>最后再强调一下，在数据链路层若<strong>仅仅</strong>使用循环冗余检验 CRC 差错检测技术，则只能做到对帧的<strong>无差错接受</strong>，即：“<strong>凡是接收端数据链路层接受的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错</strong>”。接收端丢弃的帧虽然曾<strong>收到</strong>了，但最终还是因为有差错被丢弃，即没有被<strong>接受</strong>。以上所述的可以近似地表述为（通常都是这样认为）：“<strong>凡是接收端数据链路层接受的帧均无差错</strong>”。</p> <p>注意，我们现在并没有要求数据链路层向网络层提供“<strong>可靠传输</strong>”的服务。所谓“可靠传输”就是：数据链路层的发送端发送什么，在接收端就收到什么。传输差错可分为两大类：一类就是前面所说的最基本的比特差错，而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了<strong>帧丢失</strong>、<strong>帧重复</strong>或<strong>帧失序</strong>。例如，发送方连续传送三个帧：[#1]-[#2]-[#3]。假定接收端收到的每个帧都没有比特差错，但却出现下面的几种情况：</p> <ul> <li><strong>帧丢失</strong>：收到[#1]-[#3]（丢失[#2]）。</li> <li><strong>帧重复</strong>：收到[#1]-[#2]-[#2]-[#3]（收到两个[#2]）。</li> <li><strong>帧失序</strong>：收到[#1]-[#3]-[#2]（后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样）。</li> </ul> <p>以上三种情况都属于“<strong>出现传输差错</strong>”，但都不是这些帧里有“比特差错”。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂。</p> <p>总之，我们应当明确，“无比特差错”与“无传输差错”并不是同样的概念。在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</p> <p>我们知道，过去 OSI 的观点是：必须让数据链路层向上提供可靠传输。因此在 CRC 检错的基础上，增加了<strong>帧编号</strong>、<strong>确认</strong>和<strong>重传机制</strong>。收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。这种方法在历史上曾经起到很好的作用。但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。因此，现在互联网就采取了区别对待的方法：</p> <ul> <li>对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，运输层的 TCP 协议）来完成。</li> <li>对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</li> </ul> <p>实践证明，这样做可以提高通信效率。</p> <h2 id="二点对点协议-ppp">二、点对点协议 PPP</h2> <p>在通信线路质量较差的年代，在数据链路层使用可靠传输协议曾经是一种好办法。因此，能实现可靠传输的<strong>高级数据链路控制 HDLC</strong>（High-level Data Link Control）就成为当时比较流行的数据链路层协议。但现在 HDLC 已很少使用了。对于点对点的链路，简单得多的<strong>点对点协议 PPP</strong>（Point-to-Point Protocol）则是目前使用得最广泛的数据链路层协议。</p> <h3 id="21-ppp-协议的特点">2.1 PPP 协议的特点</h3> <p>我们知道，互联网用户通常都要连接到某个 ISP 才能接入到互联网。PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议（图 3-9）。</p> <p><img src="/assets/images/computer-networks/the-link-between-the-user-and-the-isp-uses-ppp.png" alt="用户到 ISP 的链路使用 PPP 协议"/> <em>图 3-9 用户到 ISP 的链路使用 PPP 协议</em></p> <p>PPP 协议是 IETF 在 1992 年制定的。经过 1993 年和 1994 年的修订，现在的 PPP 协议在 1994 年就已成为互联网的正式标准[RFC 1661]。</p> <h4 id="1ppp-协议应满足的需求">（1）PPP 协议应满足的需求</h4> <p>IETF 认为，在设计 PPP 协议时必须考虑以下多方面的需求[RFC 1547]：</p> <ol> <li><strong>简单</strong>：IETF 在设计互联网体系结构时把其中最复杂的部分放在 TCP 协议中，而网际协议 IP 则相对比较简单，它提供的是不可靠的数据报服务。在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。IETF 把“简单”作为<strong>首要的需求</strong>。简单的设计还可使协议在实现时不容易出错，从而使不同厂商在协议的不同实现上的互操作性提高了。我们知道，协议标准化的一个主要目的就是提高协议的互操作性。总之，这种数据链路层的协议非常简单：接收方每收到一个帧，就进行 CRC 检验。如 CRC 检验正确，就收下这个帧；反之，就丢弃这个帧，<strong>其他什么也不做</strong>。</li> <li><strong>封装成帧</strong>：PPP 协议必须规定特殊的字符作为帧定界符（即标志一个帧的开始和结束的字符），以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</li> <li><strong>透明性</strong>：PPP 协议必须保证数据传输的透明性。这就是说，如果数据中碰巧出现了和帧定界符一样的比特组合时，就要采取有效的措施来解决这个问题。</li> <li><strong>多种网络层协议</strong>：PPP 协议必须能够<strong>在同一条物理链路上同时支持多种网络层协议</strong>（如 IP 和 IPX 等）的运行。当点对点链路所连接的是局域网或路由器时，PPP 协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。</li> <li><strong>多种类型链路</strong>：除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。例如，串行的（一次只发送一个比特）或并行的（一次并行地发送多个比特），同步的或异步的，低速的或高速的，电的或光的，交换的动态的）或非交换的（静态的）点对点链路。</li> <li><strong>差错检测</strong>：PPP 协议必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong>。若在数据链路层不进行差错检测，那么已出现差错的无用帧就还要在网络中继续向前转发，因而会白白浪费许多的网络资源。</li> <li><strong>检测连接状态</strong>：PPP 协议必须具有一种机制能够及时（不超过几分钟）自动检测出链路是否处于正常工作状态。当出现故障的链路隔了一段时间后又重新恢复正常工作时，就特别需要有这种及时检测功能。</li> <li><strong>最大传送单元</strong>：PPP 协议必须对每种类型的点对点链路设置<strong>最大传送单元 MTU</strong> 的标准默认值。这样做是为了促进各种实现之间的互操作性。如果高层协议发送的分组过长并超过 MTU 的数值，PPP 就要丢弃这样的帧，并返回差错。需要强调的是，MTU 是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，而不是帧的总长度。</li> <li><strong>网络层地址协商</strong>：PPP 协议必须提供一种机制使通信的两个网络层（例如，两个 IP 层）的实体能够通过协商知道或能够配置彼此的网络层地址。协商的算法应尽可能简单，并且能够在所有的情况下得出协商结果。这对拨号连接的链路特别重要，因为如果仅仅在链路层建立了连接而不知道对方网络层地址，则还不能够保证网络层可以传送分组。</li> <li><strong>数据压缩协商</strong>：PPP 协议必须提供一种方法来协商使用数据压缩算法。但PPP协议并不要求将数据压缩算法进行标准化。</li> </ol> <p>在 TCP/IP 协议族中，可靠传输运输层的 TCP 协议负责，因此数据链路层的 PPP 协议不需要进行纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路（即一个主站轮流和链路上的多个从站进行通信），而只支持点对点的链路通信。此外，PPP 协议只支持全双工链路。</p> <h4 id="2ppp-协议的组成">（2）PPP 协议的组成</h4> <p>PPP 协议有三个组成部分：</p> <ol> <li>一个将 IP 数据报封装到串行链路的方法。PPP 既支持异步链路（无奇偶检验的 8 比特数据），也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。</li> <li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议 LCP</strong>（Link Control Protocol）。通信的双方可协商一些选项。在 RFC 1661 中定义了11种类型的 LCP 分组。</li> <li>一套<strong>网络控制协议 NCP</strong>（Network Control Protocol），其中的每个协议支持不同的网络层协议，如 IP、OSI 的网络层、DECnet，以及 AppleTalk 等。</li> </ol> <h3 id="22-ppp-协议的帧格式">2.2 PPP 协议的帧格式</h3> <h4 id="1各字段的意义">（1）各字段的意义</h4> <p>PPP 的帧格式如图 3-10 所示。PPP 帧的首部和尾部分别为四个字段和两个字段。首部的第一个字段和尾部的第二个字段都是标志字段 <strong>F</strong>（Flag），规定为 0x7E（符号“0x”表示它后面的字符是用十六进制表示的。十六进制的 7E 的二进制表示是 01111110）。标志字段表示一个帧的开始或结束。因此标志字段就是 PPP 帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃。</p> <p><img src="/assets/images/computer-networks/ppp-frame-format.png" alt="PPP 帧的格式"/> <em>图 3-10 PPP 帧的格式</em></p> <ul> <li>首部中的地址字段 A 规定为 0xFF（即 11111111）。</li> <li>控制字段 C 规定为 0x03 （即 00000011）（最初曾考虑以后再对这 A 和 C 两个字段的值进行其他定义，但至今也没有给出。可见这两个字段实际上并没有携带 PPP 帧的信息）。</li> <li>PPP 首部的第四个字段是 2 字节的协议字段。 <ul> <li>当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。</li> <li>若为 0xC021，则信息字段是 PPP 链路控制协议 LCP 的数据。</li> <li>而 0x8021 表示这是网络层的控制数据。</li> </ul> </li> <li>信息字段的长度是可变的，不超过 1500 字节。</li> <li>尾部中的第一个字段（2 字节）是使用 CRC 的帧检验序列 FCS。</li> </ul> <h4 id="2字节填充">（2）字节填充</h4> <p>当信息字段中出现和标志字段一样的比特（0x7E）组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。当 PPP 使用异步传输时，它把转义符定义为 0x7D（即 01111101），并使用<strong>字节填充</strong>，填充方法如下：</p> <ol> <li>把信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列（0x7D， 0x5E）。</li> <li>若信息字段中出现一个 0x7D 的字节（即出现了和转义字符一样的比特组合），则把 0x7D 转变成为 2 字节序列（0x7D， 0x5D）。</li> <li>若信息字段中出现 ASCII 码的控制字符（即数值小于0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。例如，出现 0x03 就要把它转变为2字节序列（0x7D， 0x23）。</li> </ol> <p>由于在发送端进行了字节填充，因此在链路上传送的信息字节数就超过了原来的信息字节数。但接收端在收到数据后再进行与发送端字节填充相反的变换，就可以正确地恢复出原来的信息。</p> <h4 id="3零比特填充">（3）零比特填充</h4> <p>PPP 协议用在使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符地传送）时。在这种情况下，PPP 协议采用零比特填充方法来实现透明传输。</p> <p>零比特填充的具体做法是：在发送端，先扫描整个信息字段。只要发现有 5 个连续 1，则立即填入一个 0。因此经过这种零比特填充后的数据，就可以保证在信息字段中不会出现 6 个连续 1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除，以还原成原来的信息比特流（图 3-11）。这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</p> <p><img src="/assets/images/computer-networks/fill-and-deletion-of-zero-bits.png" alt="零比特的填充与删除"/> <em>图 3-11 零比特的填充与删除</em></p> <h3 id="23-ppp-协议的工作状态">2.3 PPP 协议的工作状态</h3> <p>当用户拨号接入 ISP 后，就建立了一条从用户个人电脑到 ISP 的物理连接。这时，用户个人电脑向 ISP 发送一系列的链路控制协议 LCP 分组（封装成多个 PPP 帧），以便建立 LCP 连接。这些分组及其响应选择了将要使用的一些 PPP 参数。接着还要进行网络层配置，网络控制协议 NCP 给新接入的用户个人电脑分配一个临时的 IP 地址。这样，用户个人电脑就成为互联网上的一个有 IP 地址的主机了。</p> <p>当用户通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p> <p>上述过程可用图 3-12 的状态图来描述。</p> <p>PPP 链路的起始和终止状态永远是图 3-12 中的“<strong>链路静止</strong>”（Link Dead）状态，这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接。</p> <p>当用户个人电脑通过调制解调器呼叫路由器时（通常是在屏幕上用鼠标点击一个连接按钮），路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP 就进入“<strong>链路建立</strong>”（Link Establish）状态，其目的是建立链路层的 LCP 连接。这时 LCP 开始协商一些<strong>配置选项</strong>，即发送 LCP 的<strong>配置请求帧</strong>（Configure-Request）。这是个 PPP 帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：</p> <ul> <li>配置确认帧（Configure-Ack）：所有选项都接受。</li> <li>配置否认帧（Configure-Nak）：所有选项都理解但不能接受。</li> <li>配置拒绝帧（Configure-Reject）：选项有的无法识别或不能接受，需要协商。</li> </ul> <p><img src="/assets/images/computer-networks/ppp-status-diagram.png" alt="PPP 协议的状态图"/> <em>图 3-12 PPP 协议的状态图</em></p> <p>LCP 配置选项包括链路上的最大帧长、所使用的鉴别协议（authentication protocol）的规约（如果有的话），以及不使用 PPP 帧中的地址和控制字段（因为这两个字段的值是固定的，没有任何信息量，可以在 PPP 帧的首部中省略这两个字节）。</p> <p>协商结束后双方就建立了 LCP 链路，接着就进入“<strong>鉴别</strong>”（Authenticate）状态。在这一状态，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用<strong>口令鉴别协议 PAP</strong>（Password Authentication Protocol），则需要发起通信的一方发送身份标识符和口令。系统可允许用户若干次。如果需要有更好的安全性，则可使用更加复杂的<strong>口令握手鉴别协议 CHAP</strong>（Challenge-Handshake Authentication Protocol）。若鉴别身份失败，则转到“<strong>链路终止</strong>”（Link Terminate）状态。若鉴别成功，则进入“<strong>网络层协议</strong>”（Network-Layer Protocol）状态。</p> <p>在“<strong>网络层协议</strong>”状态，PPP 链路的两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP 协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个 PPP 协议进行通信。</p> <p>如果在 PPP 链路上运行的是 IP 协议，则对 PPP 链路的每一端配置 IP 协议模块（如分配IP地址）时就要使用 NCP 中支持 IP 的协议 —— <strong>IP 控制协议 IPCP</strong>（IP Control Protocol）。IPCP 分组也封装成 PPP 帧（其中的协议字段为 0x8021）在 PPP 链路上传送。在低速链路上运行时，双方还可以协商使用压缩的 TCP 和 IP 首部，以减少在链路上发送的比特数。</p> <p>当网络层配置完毕后，链路就进入可进行数据通信的“<strong>链路打开</strong>”（Link Open）状态。链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可发送<strong>回送请求</strong> LCP 分组（Echo-Request）和<strong>回送回答</strong> LCP 分组（Echo-Reply），以检查链路的状态。</p> <p>数据传输结束后，可以由链路的一端发出<strong>终止请求</strong> LCP 分组（Terminate-Request）请求终止链路连接，在收到对方发来的<strong>终止确认</strong> LCP 分组（Terminate-Ack）后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，也会从“链路打开”<strong>状态转到</strong>“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”状态。</p> <p>图 3-12 右方的灰色方框给出了对 PPP 协议的几个状态的说明。从设备之间无链路开始，到先建立物理链路，再建立链路控制协议 LCP 链路。经过鉴别后再建立网络控制协议 NCP 链路，然后才能交换数据。由此可见，PPP协 议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p> <h2 id="三使用广播信道的数据链路层">三、使用广播信道的数据链路层</h2> <p>广播信道可以进行一对多的通信。下面要讨论的局域网使用的就是广播信道。</p> <h3 id="31-局域网的数据链路层">3.1 局域网的数据链路层</h3> <p>局域网最主要的特点是：<strong>网络为一个单位所拥有，且地理范围和站点数目均有限</strong>。在局域网刚刚出现时，局域网比广域网具有较高的数据率、较低的时延和较小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率。</p> <p>局域网可按网络拓扑进行分类。</p> <ul> <li><strong>星形网</strong>：集线器（hub）的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了非常广泛的应用。</li> <li><strong>环形网</strong>。</li> <li><strong>总线网</strong>：各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。总线网以传统以太网最为著名。</li> </ul> <p><img src="/assets/images/computer-networks/lan-topology.png" alt="局域网的拓扑"/> <em>图 3-13 局域网的拓扑</em></p> <p>局域网工作的层次跨越了数据链路层和物理层。</p> <p>共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法：</p> <ul> <li><strong>静态划分信道</strong>：如频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价较高，不适合于局域网使用。</li> <li> <p><strong>动态媒体接入控制</strong>：又称为<strong>多点接入</strong>（multiple access），其特点是信道并非在用户通信时固定分配给用户。这里又分为以下两类：</p> <ul> <li><strong>随机接入</strong>：所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生<strong>碰撞</strong>（即发生了冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</li> <li><strong>受控接入</strong>：用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询</strong>（polling），或称为<strong>轮询</strong>。</li> </ul> </li> </ul> <h4 id="适配器的作用">适配器的作用</h4> <p>计算机与外界局域网的连接是通过<strong>通信适配器</strong>（adapter，简称为“<strong>网卡</strong>”）进行的。在这种通信适配器上面装有处理器和存储器（包括 RAM 和 ROM）。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。</p> <p>适配器所实现的功能包含了数据链路层及物理层这两个层次的功能。现在的芯片的集成度都很高，以致很难把一个适配器的功能严格按照层次的关系精确划分开。</p> <p>当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。当计算机要发送 IP 数据报时，就由协议栈把 IP 数据报向下交给适配器，组装成帧后发送到局域网。图 3-15 表示适配器的作用。注意，计算机的硬件地址就在适配器的 ROM 中，而计算机的软件地址 —— IP 地址，则在计算机的存储器中。</p> <p><img src="/assets/images/computer-networks/computers-communicate-with-local-area-networks-through-adapters.png" alt="计算机通过适配器和局域网进行通信"/> <em>图 3-15 计算机通过适配器和局域网进行通信</em></p> <h3 id="32-csmacd-协议">3.2 CSMA/CD 协议</h3> <p>为了通信的简便，以太网采取了以下两种措施：</p> <p>第一，采用较为灵活的<strong>无连接</strong>的工作方式，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编号，也不要求对方发回确认。这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，<strong>以太网提供的服务是尽最大努力的交付</strong>，即<strong>不可靠的交付</strong>。当目的站收到有差错的数据帧时（例如，用 CRC 查出有差错），就把帧丢弃，其他什么也不做。<strong>对有差错帧是否需要重传则由高层来决定</strong>。例如，如果高层使用 TCP 协议，那么 TCP 就会发现丢失了一些数据。于是经过一定的时间后，TCP 就把这些数据重新传递给以太网进行重传。但<strong>以太网并不知道这是重传帧，而是当作新的数据帧来发送</strong>。</p> <p>我们知道，总线上只要有一台计算机在发送数据，总线的传输资源就被占用。因此，<strong>在同一时间只能允许一台计算机发送数据</strong>，否则各计算机之间就会互相干扰，使得所发送数据被破坏。因此，如何协调总线上各计算机的工作就是以太网要解决的一个重要问题。以太 网采用最简单的随机接入，但有很好的协议用来减少冲突发生的概率。这好比有一屋子的人在开讨论会，没有会议主持人控制发言。想发言的随时可发言，不需要举手示意。但我们还必须有个协议来协调大家的发言。这就是：如果你听见有人在发言，那么你就必须等别人讲完了才能发言（否则就干扰了别人的发言）。但有时碰巧两个或更多的人同时发言了，那么一旦发现冲突，大家都必须立即停止发言，等听到没有人发言了你再发言。以太网采用的协调方法和上面的办法非常像，它使用的协议是 CSMA/CD，意思是<strong>载波监听多点接入</strong>/<strong>碰撞检测</strong>（Carrier Sense Multiple Access with Collision Detection）。</p> <p>第二，以太网发送的数据都使用<strong>曼彻斯特编码</strong>的信号。我们知道，二进制基带数字信号通常就是高、低电压交替出现的信号。使用这种信号的最大问题就是当出现一长串的连 1 或 0 时，接收端就无法从收到的比特流中提取位同步（即比特同步）信号。如图 3-16 所示，曼彻斯特编码的编码方法是把每个码元再分成两个相等的间隔。码元 1 是前一个间隔为低电压而后一个间隔为高电压。码 0 则正好相反，从高电压变到低电压（也可采用相反的约定，即 1 是“前高后低”而 0 是“前低后高”）。这样就保证了在每个码元的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来。但是从曼彻斯特编码的波形图也不难看出其缺点，这就是它所占的频带宽度比原始的基带信号增加了一倍（因为每秒传送的码数加倍了）。</p> <p><img src="/assets/images/computer-networks/manchester-encoding.png" alt="曼彻斯特编码"/> <em>图 3-16 曼彻斯特编码</em></p> <p>下面介绍 CSMA/CD 协议的要点。</p> <ul> <li>“<strong>多点接入</strong>”就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。</li> <li>“<strong>载波监听</strong>”就是用电子技术检测总线上有没有其他计算机也在发送。其实总线上并没有什么“载波”，这里只不过借用一下“载波”这个名词而已。因此载波监听就是<strong>检测信道</strong>，这是个很重要的措施。<strong>不管在发送前，还是在发送中，每个站都必须不停地检测信道</strong>。在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。这就称为碰撞检测。</li> <li>“<strong>碰撞检测</strong>”也就是“<strong>边发送边监听</strong>”，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大（互相叠加）。当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“<strong>冲突检测</strong>”。这时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。因此，任何一个正在发送数据的站，一旦发现总线上出现了碰撞，其适配器就要立即停止发送，免得继续进行无效的发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</li> </ul> <p>既然每个站在发送数据前已经监听到信道为“空闲”，那么为什么还会出现数据在总线上的碰撞呢？这是因为电磁波在总线上总是以有限的速率传播。这和我们开讨论会时相似。一听见会场安静，我们就立即发言，但偶尔也会发生几个人同时抢着发言而产生冲突的情况。图 3-17 所示的例子可以说明这种情况。设图中的局域网两端的站 A 和 B 相距 1km，用同轴电缆相连。<strong>电磁波在 1km 电缆的传播时延约为 $5\mu s$</strong>（这个数字应当记住）。因此，A 向 B 发出的数据，在约 $5\mu s$ 后才能传送到 B。换言之，B 若在 A 发送的数据到达 B 之前发送自己的帧（因为这时 B 的载波监听检测不到 A 所发送的信息），则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。在局域网的分析中，常把总线上的<strong>单程端到端传播时延</strong>记为 $\tau$ 。发送数据的站希望尽早知道是否发生了碰撞。那么，A 发送数据后，最迟要经过<strong>两倍的总线端到端的传播时延</strong>（$2\tau$）(或总线的端到端往返传播时延)才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延（这两个站之间的距离最大）为端到端传播时延。</p> <p><img src="/assets/images/computer-networks/influence-of-propagation-delay-on-carrier-monitoring.png" alt="传播时延对载波监听的影响"/> <em>图 3-17 传播时延对载波监听的影响</em></p> <p>显然，在使用 CSMA/CD 协议时，一个站<strong>不可能同时进行发送和接收</strong>（<strong>但必须边发送边监听信道</strong>）。因此使用 CSMA/CD 协议的以太网不可能进行全双工通信而只能进行<strong>双向交替通信</strong>（<strong>半双工通信</strong>）。</p> <p>下面是图 3-17 中的一些重要的时刻。</p> <ul> <li>在 t = 0 时，A 发送数据。B 检测到信道为空闲。</li> <li>在t = $\tau$ - $\delta$ 时（这里），A 发送的数据还没有到达 B 时，由于 B 检测到信道是空闲的，因此 B 发送数据。</li> <li>经过时间 $\delta$/2 后，即在 t = $\tau$ - $\delta$/2 时，A 发送的数据和 B 发送的数据发生了碰撞。但这时 A 和 B 都不知道发生了碰撞。</li> <li>在 t = $\tau$ 时，B 检测到发生了碰撞，于是停止发送数据。</li> <li>在 t = 2$\tau$ - $\delta$ 时，A 也检测到发生了碰撞，因而也停止发送数据。</li> </ul> <p>A 和 B 发送数据均失败，它们都要推迟一段时间再重新发送。</p> <p>由此可见，<strong>每个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性</strong>。这一小段时间是<strong>不确定的</strong>，它取决于另一个发送数据的站到本站的距离。因此，以太网<strong>不能保证</strong>某一时间内一定能够把自己的数据帧成功地发送出去（因为存在产生碰撞的可能）。以太网的这一特点称为<strong>发送的不确定性</strong>。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</p> <p>从图 3-17 可看出，最先发送数据帧的 A 站，在发送数据帧后至多经过时间 $2\tau$ 就可知道所发送的数据帧是否遭受了碰撞。这就是 $\delta$ → 0 的情况。因此以太网的端到端往返时间 $2\tau$ 称为<strong>争用期</strong>（contention period），它是一个很重要的参数。争用期又称为<strong>碰撞窗口</strong>（collision window）。这是因为一个站在发送完数据后，只有通过争用期的“考验”，即<strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。这时，就可以放心把这一帧数据顺利发送完毕。</p> <p>以太网使用<strong>截断二进制指数退避</strong>（truncated binary exponential backoff）算法来确定碰撞后重传的时机。截断二进制指数退避算法并不复杂。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是<strong>推迟</strong>（这叫做<strong>退避</strong>）一个随机的时间。这点很容易理解，因为如果几个发生碰撞的站都在监听信道，那么都会同时发现信道变成了空闲。如果大家都同时再重新发送，那么肯定又会发生碰撞。为了使各站进行重传时再次发生冲突的概率减小，具体的退避算法如下：</p> <ol> <li>协议规定了基本退避时间为争用期 $2\tau$，具体的<strong>争用期时间是 $51.2\mu s$</strong>。对于 10 Mbit/s 以太网，在争用期内可发送 512 bit，即 64 字节。也可以说争用期是 <strong>512 比特时间</strong>。1 比特时间就是发送 1 比特所需的时间。所以这种时间单位与数据密切相关。为了方便，也可以<strong>直接使用比特作为争用期的单位</strong>。争用期是 512 bit，即争用期是发送 512 bit 所需的时间。 （2） 从离散的整数集合[0, 1, …, ($2^k -1$)]中随机取出一个数，记为 r。重传应推后的时间就是 r 倍的争用期。上面的参数 k 按下面的公式计算：</li> </ol> \[k = Min[重传次数，10]\] <p>可见当重传次数不超过 10 时，参数等于重传次数；但当重传次数超过 10 时，k 就不再增大而一直等于 10。 （3） 当重传达 16 次仍不能成功时（这表明同时打算发送数据的站太多，以致连续发生冲突），则丢弃该帧，并向高层报告。</p> <p>例如，在第 1 次重传时，k = 1，随机数 r 从整数 {0，1} 中选一个数。因此重传的站可选择的重传推迟时间是 0 或 $2\tau$，在这两个时间中随机选择一个。</p> <p>若再发生碰撞，则在第 2 次重传时，k = 2，随机数 r 就从整数 {0, 1, 2, 3} 中选一个数。因此重传推迟的时间是在 0，$2\tau$，$4\tau$ 和 $6\tau$ 这 4 个时间中随机选取一个。</p> <p>同样，若再发生碰撞，则重传时 k = 3，随机数 r 就从整数 {0, 1, 2, 3, 4, 5, 6, 7} 中选一个数。依此类推。</p> <p>若连续多次发生冲突，就表明可能有较多的站参与争用信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为<strong>动态退避</strong>），因而减小发生碰撞的概率，有利于整个系统的稳定。</p> <p>我们还应注意到，适配器每发送一个新的帧，就要执行一次 CSMA/CD 算法。适配器对过去发生过的碰撞并无记忆功能。因此，当好几个适配器正在执行指数退避算法时，很可能有某个适配器发送的新帧能够碰巧立即成功地插入到信道中，得到了发送权，而已经推迟好几次发送的站，有可能很不巧，还要继续执行退避算法，继续等待。</p> <p>现在考虑一种情况。某个站发送了一个很短的帧，但在发送完毕之前并没有检测出碰撞。假定这个帧在继续向前传播到达目的站之前和别的站发送的帧发生了碰撞，因而目的站将收到有差错的帧（当然会把它丢弃）。可是发送站却不知道这个帧发生了碰撞，因而不会重传这个帧。这种情况显然是我们所不希望的。为了避免发生这种情况，以太网规定了一个最短帧长 64 字节，即 512 bit。如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于 64 字节。对于 10 Mbit/s 以太网，发送 512 bit 的时间需要 $51.2\mu s$**，也就是上面提到的争用期。</p> <p>由此可见，以太网在发送数据时，如果在争用期（共发送了 64 字节）没有发生碰撞，那么后续发送的数据就一定不会发生冲突。换句话说，如果发生碰撞，就一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节，因此<strong>凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧</strong>。只要收到了这种无效帧，就应当立即将其丢弃。</p> <p>前面已经讲过，信号在以太网上传播1 km 大约需要 $5\mu s$。以太网上最大的端到端时延必须小于争用期的一半（即 $25.6\mu s$），这相当于以太网的最大端到端长度约为 5km。实际上的以太网覆盖范围远远没有这样大。因此，实用的以太网都能在争用期 $51.2\mu s$ 内检测到可能发生的碰撞。以太网的争用期确定为 $51.2\mu s$，不仅考虑到以太网的端到端时延，而且还包括其他的许多因素，如存在的转发器所增加的时延，以及下面要讲到的强化碰撞的干扰信号的持续时间等。</p> <p><strong>强化碰撞</strong>指当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送 32 比特或 48 比特的人为干扰信号（jamming signal），以便让所有用户都知道现在已经发生了碰撞（图 3-18）。对于 10 Mbit/s 以太网，发送 32（或 48） 比特只需要 3.2（或 4.8）$\mu s$。</p> <p><img src="/assets/images/computer-networks/the-addition-of-artificial-interference-signals.png" alt="人为干扰信号的加入"/> <em>图 3-18 人为干扰信号的加入</em></p> <p>从图 3-18 可以看出，A 站从发送数据开始到发现碰撞并停止发送的时间间隔是 $T_B$。A 站得知碰撞已经发生时所发送的强化碰撞的干扰信号的持续时间是 $T_J$。图中的 B 站在得知发生碰撞后，也要发送人为干扰信号，但为简单起见，图 3-18 没有画出 B 站所发送的人为干扰信号。发生碰撞使 A 浪费时间 $T_B + T_J$。可是整个信道被占用的时间还要增加一个单程端到端的传播时延 $\tau$。因此总线被占用的时间是 $T_B + T_J + \tau$。</p> <p>以太网还规定了帧间最小间隔为 $9.6\mu s$，相当于 96 比特时间。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p> <p>根据以上所讨论的，可以把 CSMA/CD 协议的要点归纳如下：</p> <ol> <li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须<strong>先检测信道</strong>。</li> <li>检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。</li> <li> <p>在发送过程中仍不停地检测信道，即网络适配器要<strong>边发送边监听</strong>。这里只有两种可能性：</p> <ul> <li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到（1）。</li> <li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤（2），继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。</li> </ul> </li> </ol> <p>以太网每发送完一帧，一定要把已发送的帧暂时保留一下。如果在争用期内检测出发生了碰撞，那么还要在推迟一段时间后再把这个暂时保留的帧重传一次。</p> <h3 id="33-使用集线器的星形拓扑">3.3 使用集线器的星形拓扑</h3> <p>传统以太网使用更便宜和更灵活的双绞线。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong>（hub），如图 3-19 所示。双绞线以太网总是和集线器配合使用。每个站需要用两对无屏蔽双绞线（放在一根电缆内），分别用于发送和接收。双绞线的两端使用 RJ-45 插头。由于集线器使用了大规模集成电路芯片，因此集线器的可靠性就大大提高了。1990 年 IEEE 制定出星形以太网 10BASE-T 的标准 802.3i。“10”代表 10 Mbit/s 的数据率，BASE 表示连接线上的信号是基带信号，T 代表双绞线。</p> <p><img src="/assets/images/computer-networks/twisted-pair-ethernet-using-a-hub.png" alt="使用集线器的双绞线以太网"/> <em>图 3-19 使用集线器的双绞线以太网</em></p> <p>但 10BASE-T 以太网的通信距离稍短，每个站到集线器的距离不超过 100m。这种性价比很高的 10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，从此以太网的拓扑就从总线型变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。</p> <p>使双绞线能够传送高速数据的主要措施是把双绞线的绞合度做得非常精确。这样不仅可使特性阻抗均匀以减少失真，而且大大减少了电磁波辐射和无线电频率的干扰。在多对双绞线的电缆中，还要使用更加复杂的绞合方法。集线器的一些特点如下：</p> <ul> <li>从表面上看，使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一个传统以太网那样运行。也就是说，<strong>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD 协议</strong>（更具体些说，是各站中的适配器执行 CSMA/CD 协议）。网络中的各站必须竞争对传输媒体的控制，并且<strong>在同一时刻至多只允许一个站发送数据</strong>。</li> <li>一个集线器有许多<strong>接口</strong>，例如 8 至 16 个，每个接口通过 RJ-45 插头（与电话机使用的插头 RJ-11 相似，但略大一些）用两对双绞线与一台计算机上的适配器相连（这种插座可连接 4 对双绞线，实际上只用 2 对，即发送和接收各使用一对双绞线）。因此，一个集线器很像一个多接口的转发器。</li> <li><strong>集线器工作在物理层</strong>，它的每个接口仅仅<strong>简单地转发比特</strong> —- 收到 1 就转发 1，收到 0 就转发 0，不进行碰撞检测。若两个接口同时有信号输入（即发生碰撞），那么所有的接口都将收不到正确的帧。图 3-20 是具有三个接口的集线器的示意图。</li> <li>集线器采用了专门的芯片，进行自适应串音回波抵消。这样就可使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰（这种干扰即近端串音）。每个比特在转发之前还要进行再生整形并重新定时。</li> </ul> <p><img src="/assets/images/computer-networks/a-hub-with-three-interfaces.png" alt="具有三个接口的集线器"/> <em>图 3-20 具有三个接口的集线器</em></p> <h3 id="34-以太网的信道利用率">3.4 以太网的信道利用率</h3> <p>假定一个 10 Mbit/s 以太网同时有 10 个站在工作，那么每个站所能发送数据的平均速率似乎应当是总数据率的 1/10（即 1Mbit/s）。其实不然，因为多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到 100%。</p> <p>图 3-21 的例子是以太网的信道被占用的情况。一个站在发送帧时出现了碰撞。经过一个争用期 $2\tau$ 后（$\tau$ 是以太网单程端到端传播时延），可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 $T_0$。它等于帧长（bit）除以发送速率（10 Mbit/s）。</p> <p><img src="/assets/images/computer-networks/the-ethernet-channel-is-occupied.png" alt="以太网的信道被占用的情况"/> <em>图 3-21 以太网的信道被占用的情况</em></p> <p>我们应当注意到，成功发送一个帧需要占用信道的时间是 $T_0 + \tau$，比这个帧的发送时间要多一个单程端到端时延。这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是 $\tau$。因此，必须在经过时间 $T_o + \tau$ 后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</p> <p>从图 3-21 可看出，要提高以太网的信道利用率，就必须减小 $\tau$ 与 $T_0$ 之比。在以太网中定义了参数 a，它是以太网单<strong>程端到端时延 $\tau$ 与帧的发送时间 $T_0$ 之比</strong>：</p> \[a = \frac{\tau}{T_0}\] <p>当 a → 0 时，表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常非常少。反之，参数 a 越大，表明争用期所占的比例越大，这就使得每发生一次碰撞就浪费了不少的信道资源，使得信道利用率明显降低。因此，以太网的参数 a 的值应当尽可能小些。从（3-2）式可看出，这就要求（3-2）式分子 $\tau$ 的数值要小些，而分母 $T_0$ 的数值要大些。这就是说，当数据率一定时，以太网的连线的长度受到限制（否则 $\tau$ 的数值会太大），同时以太网的帧长不能太短（否则 $T_0$ 的值会太小，使 a 值太大）。</p> <p>现在考虑一种理想化的情况。假定以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），并且能够非常有效地利用网络的传输资源，即总线一旦空闲就有某一个站立即发送数据。这样，发送一帧占用线路的时间是 $T_0 + \tau$，而帧本身的发送时间是 $T_0$。于是我们可计算出极限信道利用率 $S_{max}$ 为：</p> \[S{max} = \frac{T_o}{T_0 + \tau} = \frac{1}{1 + a}\] <p>上式的意义是：虽然实际的以太网不可能有这样高的极限信道利用率，但上式指出了<strong>只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率</strong>。反之，若参数 a 远大于 1（即每发生一次碰撞，就要浪费相对较多的传输数据的时间），则极限信道利用率就远小于 1，而这时实际的信道利用率就更小了。据统计，当以太网的利用率达到 30% 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p> <h3 id="35-以太网的-mac-层">3.5 以太网的 MAC 层</h3> <h4 id="1mac-层的硬件地址">（1）MAC 层的硬件地址</h4> <p>在局域网中，硬件地址又称为物理地址或 MAC 地址（因为这种地址用在 MAC 帧中）。</p> <p>IEEE 802 标准为局域网规定了一种 48 位的全球地址（一般都简称为“地址”），是指局域网上的每台计算机中<strong>固化在适配器的 ROM 中的地址</strong>。</p> <p>严格地讲，局域网的“地址”应当是每个站的“<strong>名字</strong>”或<strong>标识符</strong>[PERL00]。人们习惯于把这种 48 位的“名字”称为“地址”。</p> <p>请注意，如果连接在局域网上的主机或路由器安装有多个适配器，那么这样的主机或 路由器就有多个“地址”。更准确些说，这种48位“地址”应当是某个接口的标识符。</p> <p>现在 IEEE 的<strong>注册管理机构 RA</strong>（Registration Authority）是局域网全球地址的法定管理机构[W-IEEERA]，它负责分配地址字段的 6 个字节中的前三个字节（即高位 24 位）。世界上凡要生产局域网适配器的厂家都必须向 IEEE 购买由这三个字节构成的这个号（即地址块），这个号的正式名称是<strong>组织唯一标识符 OUI</strong>（Organizationally Unique Identifier），通常也叫做<strong>公司标识符</strong>（company_id）。地址字段中的后三个字节（即低位 24位）则由厂家自行指派，称为<strong>扩展标识符</strong>（extended identifier），只要保证生产出的适配器没有重复地址即可。可见用一个地址块可以生成 $2^{24}$ 个不同的地址。用这种方式得到的 48 位地址称为 EUI-48，这里 EUI 表示<strong>扩展的唯一标识符</strong>（Extended Unique Identifier）。EUI-48 的使用范围并不局限于局域网的硬件地址，而是可以用于软件接口。但应注意，24 位的 OUI 不能够单独用来标志一个公司，因为一个公司可能有几个 OUI，也可能有几个小公司合起来购买一个 OUI。在生产适配器时，这种 6 字节的 MAC 地址已被固化在适配器的 ROM 中。因此，MAC 地址也叫做<strong>硬件地址</strong>（hardware address）或<strong>物理地址</strong>。可见“MAC 地址”实际上就是<strong>适配器地址</strong>或<strong>适配器标识符 EUI-48</strong>。当这块适配器插入（或嵌入）到某台计算机后，适配器上的标识符 EUI-48 就成为这台计算机的 MAC 地址了。</p> <p>IEEE 规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual/Group。当 I/G 位为 0 时，地址字段表示一个<strong>单个站地址</strong>。当 I/G 位为 1 时表示组地址，用来进行多播。因此，IEEE 只分配地址字段前三个字节中的 23 位。当 I/G 位分别为 0 和 1 时，一个地址块可分别生成 $2^{24}$ 个单个站地址和 $2^{24}$ 个组地址。</p> <p>IEEE 还考虑到可能有人并不愿意向 IEEE 的 RA 购买 OUI。为此，IEEE 把地址字段第 1 字节的最低第二位规定为 G/L 位，表示 Global/Local。当 G/L 位为 0 时是全球管理（保证在全球没有相同的地址），厂商向 IEEE 购买的 OUI 都属于<strong>全球管理</strong>。当地址字段的 G/L 位为 1 时是<strong>本地管理</strong>，这时用户可任意分配网络上的地址。采用 2 字节地址字段时全都是本地管理。但应当指出，以太网几乎不理会这个 G/L 位。</p> <p>这样，在全球管理时，对每个站的地址可用 46 位的二进制数字来表示（最低位和最低第 2 位均为 0 时）。剩下的 46 位组成的地址空间可以有 $2^{46}$ 个地址，已经超过 70 万亿个，可保证世界上的每一个适配器都可有一个唯一的地址。</p> <p>当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。</p> <p>我们知道适配器有过滤功能。但适配器从网络上每收到一个 MAC 帧就先用硬件检查 MAC 帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。这里“发往本站的帧”包括以下三种帧：</p> <ul> <li><strong>单播</strong>（unicast）帧 （一对一），即收到的帧的 MAC 地址与本站的硬件地址相同。</li> <li><strong>广播</strong>（broadcast）帧（一对全体），即发送给本局域网上所有站点的帧（全 1 地址）。</li> <li><strong>多播</strong>（multicast）帧（一对多），即发送给本局域网上一部分站点的帧。</li> </ul> <p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。有的适配器可用编程方法识别多播地址。当操作系统启动时，它就把适配器初始化，使适配器能够识别某些多播地址。显然，只有目的地址才能使用广播地址和多播地址。</p> <p>以太网适配器还可设置为一种特殊的工作方式，即<strong>混杂方式</strong>（promiscuous mode）。工作在混杂方式的适配器只要“听到”有帧在以太网上传输就都悄悄地接收下来，而不管这些帧是发往哪个站。请注意，这样做实际上是“窃听”其他站点的通信而并不中断其他站点的通信。网络上的黑客（hacker 或 cracker）常利用这种方法非法获取网上用户的口令。因此，以太网上的用户不愿意网络上有工作在混杂方式的适配器。</p> <p>但混杂方式有时却非常有用。例如，网络维护和管理人员需要用这种方式来监视和分析以太网上的流量，以便找出提高网络性能的具体措施。有一种很有用的网络工具叫做<strong>嗅探器</strong>（Sniffer）就使用了设置为混杂方式的网络适配器。此外，这种嗅探器还可帮助学习网络的人员更好地理解各种网络协议的工作原理。因此，混杂方式就像一把双刃剑，是利是弊要看你怎样使用它。</p> <h4 id="2mac-帧的格式">（2）MAC 帧的格式</h4> <p>常用的以太网 MAC 帧格式有两种标准，一种是 DIX Ethernet V2 标准（即以太网 V2 标准），另一种是 IEEE 的 802.3 标准。这里只介绍使用得最多的以太网 V2 的 MAC 帧格式（图 3-22）。图中假定网络层使用的是 IP 协议。实际上使用其他的协议也是可以的。</p> <p><img src="/assets/images/computer-networks/mac-frame-format-of-ethernet-v2.png" alt="以太网 V2 的 MAC 帧格式"/> <em>图 3-22 以太网 V2 的 MAC 帧格式</em></p> <p>以太网 V2 的 MAC 帧较为简单，由五个字段组成。</p> <ol> <li>第一个字段为 6 字节长的<strong>目的地址</strong>字段。</li> <li>第二个字段为 6 字节长的<strong>源地址</strong>字段。</li> <li>第三个字段是 2 字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。例如，当类型字段的值是 0x0800 时，就表示上层使用的是 IP 数据报。若类型字段的值为 0x8137，则表示该帧是由 Novell IPX 发过来的。</li> <li>第四个字段是数据字段，其长度在 46 到 1500 字节之间（46 字节是这样得出的：最小长度 64 字节减去 18 字节的首部和尾部就得出数据字段的最小长度）。</li> <li>最后一个字段是 4 字节的帧检验序列 FCS（使用 CRC 检验）。当传输媒体的误码率为 $1 x 10^{-8}$ 时，MAC 子层可使未检测到的差错小于 $1 x 10^{-14}$。</li> </ol> <p>这里我们要指出，在以太网 V2 的 MAC 帧格式中，其首部并没有一个帧长度（或数据长度）字段。那么，MAC 子层又怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议呢？我们在前面讲述图 3-16 的曼彻斯特编码时已经讲过，这种曼彻斯特编码的一个重要特点就是：在曼彻斯特编码的每个码元（不管码元是 1 或 0）的正中间一定有一次电压的转换（从高到低或从低到高）。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了（既不发送 1，也不发送 0）。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数 4 字节（FCS 字段长度是4字节），就能确定数据字段的结束位置。</p> <p>当数据字段的长度小于 46 字节时，MAC 子层就会在数据字段的后面加入一个整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。我们应当注意到，MAC 帧的首部并没有指出数据字段的长度是多少。在有填充字段的情况下，接收端的 MAC 子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。现在的问题是：上层协议如何知道填充字段的长度呢?（IP 层应当丢弃没有用处的填充字段。可见，上层协议必须具有识别有效的数据字段长度的功能。我们知道，当上层使用 IP 协议时，其首部就有一个“总长度”字段。因此，“总长度”加上填充字段的长度，应当等于 MAC 帧数据字段的长度。例如，当 IP 数据报的总长度为 42 字节时，填充字段共有 4 字节。当 MAC 帧把 46 字节的数据上交给 IP 层后，IP 层就把其中最后 4 字节的填充字段丢弃。</p> <p>从图 3-22 可看出，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节。这是因为当一个站在刚开始接收 MAC 帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此 MAC 帧的最前面的若干位就无法接收，结果使整个的 MAC 成为无用的帧。为了接收端迅速实现同步，从 MAC 子层向下传到物理层时还要在帧的前面插入 8 字节（由硬件生成），它由两个字段构成。</p> <ul> <li>第一个字段是 7 个字节的前同步码（1 和 0 交替码），它的作用是使接收端的适配器在接收 MAC 帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现同步”（同步就是比特同步的意思）。</li> <li>第二个字段是帧开始定界符，定义为 10101011。它的前六位的作用和前同步码一样，最后的两个连续的就是告诉接收端适配器：“MAC 帧的信息马上就要来了，请适配器注意接收”。</li> </ul> <p>MAC 帧的 FCS 字段的检验范围不包括前同步码和帧开始定界符。顺便指出，在使用 SONET/SDH 进行同步传输时则不需要用前同步码，因为在同步传输时收发双方的位同步总是一直保持着的。</p> <p>还需注意，在以太网上传送数据时是以帧为单位传送的。以太网在传送帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个 MAC 帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。</p> <p>IEEE 802.3 标准规定凡出现下列情况之一的即为无效的 MAC 帧：</p> <ul> <li>帧的长度不是整数个字节。</li> <li>用收到的帧检验序列 FCS 查出有差错。</li> <li>收到的帧的 MAC 客户数据字段的长度不在 46~1500 字节之间。考虑到 MAC 帧首部和尾部的长度共有 18 字节，可以得出有效的 MAC 帧长度为 64~1518 字节之间。</li> </ul> <p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p> <p>最后要提一下，IEEE 802.3 标准规定的 MAC 帧格式与上面所讲的以太网 V2 MAC 帧格式的区别就是两个地方。</p> <p>第一，IEEE 802.3 规定的 MAC 帧的第三个字段是“长度/类型”。当这个字段值大于 0x0600 时（相当于十进制的 1536），就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。只有当这个字段值小于 0x0600 时才表示“长度”，即 MAC 帧的数据部分长度。显然，在这种情况下，若数据字段的长度与长度字段的值不一致，则该帧为无效的 MAC 帧。实际上，前面我们已经讲过，由于以太网采用了曼彻斯特编码，长度字段并无实际意义。</p> <p>第二，当“长度/类型”字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</p> <p>由于现在广泛使用的局域网只有以太网，因此 LLC 帧已经失去了原来的意义。现在市场上流行的都是以太网 V2 的 MAC 帧，但大家也常常把它称为 IEEE 802.3 标准的 MAC 帧。</p> <h2 id="四扩展的以太网">四、扩展的以太网</h2> <p>在许多情况下，我们希望对以太网的覆盖范围进行扩展。本节先讨论在物理层对以太网扩 展，然后讨论在数据链路层对以太网扩展。这种扩展的以太网在网络层看来仍然是一个网络。</p> <h3 id="41-在物理层扩展以太网">4.1 在物理层扩展以太网</h3> <p>以太网上的主机之间的距离不能太远（例如，10BASE-T 以太网的两台主机之间的距离 不超过200 米），否则主机发送的信号经过铜线的传输就会衰减到使 CSMA/CD 协议无法正 常工作。在过去广泛使用粗缆或细缆以太网时，常使用工作在物理层的转发器来扩展以太网 的地理覆盖范围。那时，两个网段可用一个转发器连接起来。IEEE 802。3 标准还规定，任意 两个站之间最多可以经过三个电缆网段。但随着双绞线以太网成为以太网的主流类型，扩展 以太网的覆盖范围已很少使用转发器了。 现在，扩展主机和集线器之间的距离的一种简单方法就是使用光纤（通常是一对光 纤）和一对光纤调制解调器，如图3-23所示。</p> <p><img src="" alt=""/> <em>图 3-23 主机使用光纤和一对光纤调制解调器连接到集线器</em></p> <p>光纤调制解调器的作用就是进行电信号和光信号的转换。由于光纤带来的时延很小， 并且带宽很宽，因此使用这种方法可以很容易地使主机和几公里以外的集线器相连接。 如果使用多个集线器，就可以连接成覆盖更大范围的多级星形结构的以太网。例如， 一个学院的三个系各有一个 10BASE-T 以太网（图3-24（a）），可通过一个主干集线器把各系 的以太网连接起来，成为一个更大的以太网（图3-24（b））。</p> <p><img src="" alt=""/> <em>图 3-24 用多个集线器连成更大的以太网</em></p> <p>这样做可以有以下两个好处。第一，使这个学院不同系的以太网上的计算机能够进行 跨系的通信。第二，扩大了以太网覆盖的地理范围。例如，在一个系的 10BASE-T 以太网 中，主机与集线器的最大距离是100m，因而两台主机之间的最大距离是200 m。但在通过 主干集线器相连接后，不同系的主机之间的距离就可扩展了，因为集线器之间的距离可以是 100m（使用双绞线）或甚至更远（如使用光纤）。 但这种多级结构的集线器以太网也带来了一些缺点。 （1） 如图 3-24（a）所示的例子，在三个系的以太网互连起来之前，每一个系的 10BASE-T 以太网是一个独立的碰撞域（collision domain，又称为冲突域），即在任一时刻，在每一个 碰撞域中只能有一个站在发送数据。每一个系的以太网的最大吞吐量是10 Mbit/s，因此三 个系总的最大吞吐量共有 30 Mbit/s。在三个系的以太网通过集线器互连起来后就把三个碰 撞域变成一个碰撞域（范围扩大到三个系），如图3-24（b）所示，而这时的最大吞吐量仍然是 一个系的吞吐量 10 Mbit/s。这就是说，当某个系的两个站在通信时所传送的数据会通过所 有的集线器进行转发，使得其他系的内部在这时都不能通信（一发送数据就会碰撞）。 （2） 如果不同的系使用不同的以太网技术（如数据率不同），那么就不可能用集线器将 它们互连起来。如果在图 3-24 中，一个系使用 10 Mbit/s 的适配器，而另外两个系使用 10/100Mbit/s 的适配器，那么用集线器连接起来后，大家都只能工作在10 Mbit/s 的速率。 集线器基本上是个多接口（即多端口）的转发器，它并不能把帧进行缓存。</p> <h3 id="42-在数据链路层扩展以太网">4.2 在数据链路层扩展以太网</h3> <p>扩展以太网更常用的方法是在数据链路层进行。最初人们使用的是网桥（bridge）。网桥 对收到的帧根据其 MAC 帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所 有的接口转发此帧，而是根据此帧的目的 MAC 地址，查找网桥中的地址表，然后确定将该 帧转发到哪一个接口，或者是把它丢弃（即过滤）。 1990 年问世的交换式集线器（switching hub），很快就淘汰了网桥。交换式集线器常称为 以太网交换机（switch）或第二层交换机（L2 switch），强调这种交换机工作在数据链路层。 “交换机”并无准确的定义和明确的概念。著名网络专家 Perlman认为：“交换机”应 当是一个市场名词，而交换机的出现的确使数据的转发更加快速了[PERL00]。本书也使用 这个广泛被接受的名词——以太网交换机。下面简单地介绍以太网交换机的特点。 1。以太网交换机的特点 以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口，和工作 在物理层的转发器、集线器有很大的差别。以太网交换机的每个接口都直接与一个单台主机 或另一个以太网交换机相连，并且一般都工作在全双工方式。以太网交换机还具有并行性， 即能同时连通多对接口，使多对主机能同时通信（而网桥只能一次分析和转发一个帧）。相 互通信的主机都是独占传输媒体，无碰撞地传输数据。 以太网交换机的接口还有存储器，能在输出端口繁忙时把到来的帧进行缓存。因此， 如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的接口 繁忙时，发送帧的这两台主机的接口会把收到的帧暂存一下，以后再发送出去。 以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过自学 习算法自动地逐渐建立起来的。以太网交换机由于使用了专用的交换结构芯片，用硬件转 发，其转发速率要比使用软件转发的网桥快很多。 以太网交换机的性能远远超过普通的集线器，而且价格并不贵，这就使工作在物理层 的集线器逐渐地退出了市场。 对于传统的 10 Mbit/s 的共享式以太网，若共有10 个用户，则每个用户占有的平均带宽 只有1Mbit/s。若使用以太网交换机来连接这些主机，虽然在每个接口到主机的带宽还是 10 Mbit/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此 对于拥有 10 个接口的交换机的总容量则为100 Mbit/s。这正是交换机的最大优点。 从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不 需要作任何改动。 以太网交换机一般都具有多种速率的接口，例如，可以具有 10 Mbit/s、100 Mbit/s 和 1 Gbit/s 的接口的各种组合，这就大大方便了各种不同情况的用户。 虽然许多以太网交换机对收到的帧采用存储转发方式进行转发，但也有一些交换机采 用直通（cut-through）的交换方式。直通交换不必把整个数据帧先缓存后再进行处理，而是在 接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的 转发速度。如果在这种交换机的内部采用基于硬件的交叉矩阵，交换时延就非常小。直通交 换的一个缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他 的站。在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线 路速率匹配、协议转换或差错检测时。现在有的厂商已生产出能支持两种交换方式的以太网 交换机。以太网交换机的发展与建筑物结构化布线系统的普及应用密切相关。在结构化布线 系统中，广泛地使用了以太网交换机。 2。以太网交换机的自学习功能 我们用一个简单例子来说明以太网交换机是怎样进行自学习的。 假定在图 3-25 中的以太网交换机有4个接口，各连接一台计算机，其MAC地址分别 是 A，B，C 和 D。在一开始，以太网交换机里面的交换表是空的（图3-25（a））。</p> <p><img src="" alt=""/> <em>图 3-25 以太网交换机中的交换表</em></p> <p>A 先向 B 发送一帧，从接口进入到交换机。交换机收到帧后，先查找交换表，没有 查到应从哪个接口转发这个帧（在 MAC 地址这一列中，找不到目的地址为 B 的项目）。接 着，交换机把这个帧的源地址 A和接口1写入交换表中，并向除接口 1 以外的所有接口广 播这个帧（这个帧就是从接口1进来的，当然不应当把它再从接口1转发出去）。 C 和 D 将丢弃这个帧，因为目的地址不对。只 B 才收下这个目的地址正确的帧。这也 称为过滤。 从新写入交换表的项目（A， 1）可以看出，以后不管从哪一个接口收到帧，只要其目的地 址是 A，就应当把收到的帧从接口 1 转发出去。这样做的依据是：既然 A 发出的帧是从接 口1进入到交换机的，那么从交换机的接口1转发出的帧也应当可以到达 A。 假定接下来 B 通过接口 3 向 A 发送一帧。交换机查找交换表，发现交换表中的 MAC 地址有 A。表明要发送给A 的帧（即目的地址为A 的帧）应从接口1转发。于是就把这个 帧传送到接口1转发给A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的 项目（B， 3），表明今后如有发送给B的帧，就应当从接口3转发出去。 经过一段时间后，只要主机 C 和 D 也向其他主机发送帧，以太网交换机中的交换表就 会把转发到C或D应当经过的接口号（24）写入到交换表中。这样，交换表中的项目就 齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口。 考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需 要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就 自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。 以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配 置，因此非常方便。 但有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的 链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈 子。我们用图 3-26 的简单例子来说明这个问题。</p> <p><img src="" alt=""/> <em>图 3-26 在两个交换机之间兜圈子的帧</em></p> <p>在图 3-26 中，假定一开始主机A通过接口交换机#1 向主机B发送一帧。交换机#1 收 到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向：离开交换机#1 的 接口 3→ 交换机#2的接口→ 接口2→ 交换机#1 的接口4→ 接口3→ 交换机#2的接口 1 这样就无限制地循环圈子下去，白白消耗了网络资源。 为了解决这种兜圈子问题，IEEE 802。1D 标准制定了一个生成树协议 STP （Spanning Tree Protocol）。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一 台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。 3。从总线以太网到星形以太网 大家知道，传统的电话网是星形结构，其中心就是电话交换机。那么在20世纪70 年 代中期出现的局域网，为什么不采用这种星形结构呢?这是因为在当时的技术条件下，还很 难用廉价的方法制造出高可靠性的以太网交换机。所以那时的以太网就采用无源的总线结 构。这种总线式以太网一问世就受到广大用户的欢迎，并获得了很快的发展。 然而随着以太网上站点数目的增多，使得总线结构以太网的可靠性下降。与此同时， 大规模集成电路以及专用芯片的发展，使得星形结构的以太网交换机可以做得既便宜又可 靠。在这种情况下，采用以太网交换机的星形结构又成为以太网的首选拓扑，而传统的总线 以太网也很快从市场上消失了。 总线以太网使用 CSMA/CD 协议，以半双工方式工作。但以太网交换机不使用共享总 线，没有碰撞问题，因此不使用CSMA/CD 协议，而是以全双工方式工作。既然连以太网的 重要协议 CSMA/CD 都不使用了（相关的“争用期”也没有了），为什么还叫做以太网呢? 原因就是它的帧结构未改变，仍然采用以太网的帧结构。</p> <h3 id="43-虚拟局域网">4.3 虚拟局域网</h3> <p>利用以太网交换机可以很方便地实现虚拟局域网VLAN （Virtual LAN）。在IEEE 802。1Q 标准中，对虚拟局域网 VLAN 是这样定义的： 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段 具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算 机属于哪一个 VLAN。 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。 图 3-27 画的是使用了四个交换机的网络拓扑。设有10台计算机分配在三个楼层中，构 成了三个局域网，即： LANı： （A1， A2， B1， Cı），LAN2： （A3， B2， Cz），LAN3： （A4，B3， C3） 但这 10 个用户划分为三个工作组，也就是说划分为三个虚拟局域网 VLAN。即： VLANı： （A1，A2，A3， A4）， VLAN2： （B1， B2， B3）; VLAN3： （C1，C2，C3）。</p> <p>图 3-27 三个虚拟局域网 VLAN、VLAN 和 VLAN 的构成</p> <p>从图 3-27 可看出，每一个VLAN 的计算机可处在不同的局域网中，也可以不在同一层 利用以太网交换机可以很方便地将这10台计算机划分为三个虚拟局域网：VLAN， VLAN， 和VLAN，。在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他成员 所发出的广播。例如，计算机 B1~B，同属于虚拟局域网 VLANz。当B，向工作组内成员发 送数据时，计算机B2和B;将会收到广播的信息，虽然它们没有和B，连在同一个以太网交 换机上。相反，B，向工作组内成员发送数据时，计算机A1，A2和C都不会收到B，发出的 广播信息，虽然他们都与B连接在同一个以太网交换机上。以太网交换机不向虚拟局域网 以外的计算机传送B的广播信息。这样，虚拟局域网限制了接收广播信息的计算机数，使 得网络不会因传播过多的广播信息（即所谓的“广播风暴”而引起性能恶化。 由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非 常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。 以太网交换机的种类很多。例如，“具有第三层特性的第二层交换机”和“多层交换 机”。前者具有某些第三层的功能，如数据报的分片和对多播通信量的管理，而后者可根据 第三层的IP 地址对分组进行过滤。 1988 年 IEEE 批准了 802。3ac标准，这个标准定义了以太网的帧格式的扩展，以便支 持虚拟局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符（见 图 3-28），称为 VLAN 标记（tag），用来指明发送该帧的计算机属于哪一个虚拟局域网。插入 VLAN 标记得出的帧称为 802。1Q 帧。显然，如果还使用原来的以太网帧格式，那么就无法 区分是否划分了虚拟局域网。图3-27 标注出在几个粗线链路上传输的帧是 802。1Q 帧。在其 他链路上传输的仍然是普通的以太网帧。 802。1Q帧 字节 6 以太网 6 4 2 46-1500 4 MAC帧目的地址 源地址 VLAN标记 类型 数据 FCS 802。1Q 标记类型 标记控制信息 10000001 00000000 VID 2 字节 2 字节 用户优先级 CFI 图 3-28 插入 VLAN 标记后变成了 802。1Q 帧 VLAN 标记字段的长度是4字节，插入在以太网 MAC 帧的源地址字段和类型字段之 间。VLAN 标记的前两个字节总是设置为0x8100（即二进制的 10000001 00000000），称为 IEEE 802。1Q 标记类型。 当数据链路层检测到 MAC 帧的源地址字段后面的两个字节的值是0x8100时，就知道 现在插入了 4 字节的 VLAN 标记。于是就接着检查后面两个字节的内容。在后面的两个字 节中，前 3 位是用户优先级字段，接着的一位是规范格式指示符 CFI （Canonical Format Indicator），最后的12位是该虚拟局域网 VLAN 标识符 VID （VLAN ID），它唯一地标志了 这个以太网帧属于哪一个 VLAN。 由于用于 VLAN 的以太网帧的首部增加了4个字节，因此以太网的最大帧长从原来的 1518 字节（1500字节的数据加上18字节的首部）变为1522 字节。</p> <h2 id="五高速以太网">五、高速以太网</h2> <p>下面简单介绍几种高速以太网技术。</p> <h3 id="51-100base-t-以太网">5.1 100BASE-T 以太网</h3> <p>100BASE-T 是在双绞线上传送 100 Mbit/s 基带信号的星形拓扑以太网，仍使用 IEEE 802。3 的 CSMA/CD 协议，它又称为快速以太网（Fast Ethernet）。用户只要使用 100 Mbit 的适 配器和 100 Mbit/s 的集线器或交换机，就可很方便地由 10BASE-T 以太网直接升级到 100 Mbit/s，而不必改变网络的拓扑结构。所有在 10BASE-T 上的应用软件和网络软件都可保持 不变。100BASE-T 的适配器有很强的自适应性，能够自动识别 10 Mbit/s 和 100 Mbit/s。 1995 年 IEEE已把100BASE-T的快速以太网定为正式标准，其代号为IEEE 802。3u，是对现 行的 IEEE 802。3 标准的补充。 100BASE-T 可使用以太网交换机提供很好的服务质量，可在全双工方式下工作而无冲 突发生。因此，CSMA/CD 协议对全双工方式工作的快速以太网是不起作用的（但在半双工 方式工作时则一定要使用 CSMA/CD 协议）。快速以太网使用的 MAC 帧格式仍然是IEEE 802。3 标准规定的帧格式。 然而 IEEE 802。3u 的标准未包括对同轴电缆的支持。这意味着想从细缆以太网升级到快速 以太网的用户必须重新布线。因此，现在 10/100 Mbit/s 以太网都使用无屏蔽双绞线布线。 100 Mbit/s 以太网的新标准改动了原 10 Mbit/s 以太网的某些规定。我们知道，以太网有 一个重要的参数 a，它必须保持为很小的数值。在3。3。4 节曾给出了参数a的公式（3-2）： τ a = T。 （3-2） 这里要是以太网单程端到端时延，是帧的发送时间。我们知道，To是帧长与发送速率 之比，可见为了保持参数a不变，可以使与发送速率的乘积不变。在帧长一定的条件下， 若数据率提高到10倍，可把网络电缆长度（因而使z）减小到原有数值的十分之一。 在 100 Mbit/s 的以太网中采用的方法是保持最短帧长不变，对于铜缆 100 Mbit/s 以太 网，一个网段的最大长度是100m，其最短帧长仍为64字节，即 512 比特。因此 100 Mbit/s 以太网的争用期是5。12 us，帧间最小间隔现在是0。96 us，都是10Mbit/s 以太网的1/10。 表 3-1 是 100 Mbit/s 以太网的新标准规定的三种不同的物理层标准。 表 3-1 100 Mbit/s 以太网的物理层标准 名称 媒体 网段最大长度 特点 100BASE-TX 铜缆 100m 两对UTP5类线或屏蔽双绞线 STP 100BASE-T4 铜缆 100m 4 对UTP 3类线或5类线 100BASE-FX 光缆 2000m 两根光纤，发送和接收各用一根 在标准中把上述的100BASE-TX 和 100BASE-FX 合在一起称为100BASE-X。 100BASE-T4 使用4对UTP3类线或5类线时，使用3对线同时传送数据（每一对线以 33号 Mbit/s 的速率传送数据），用1对线作为碰撞检测的接收信道。</p> <h3 id="52-吉比特以太网">5.2 吉比特以太网</h3> <p>吉比特以太网的产品已在1996年夏季间市。IEEE 在1997年通过了吉比特以太网的标 准 802。3z，并在1998年成为正式标准。几年来，吉比特以太网迅速占领了市场，成为以太 网的主流产品。 吉比特以太网的标准 IEEE 802。3z 有以下几个特点： （1） 允许在 1 Gbit/s 下以全双工和半双工两种方式工作。 （2） 使用 IEEE 802。3协议规定的帧格式。 （3）在半双工方式下使用CSMA/CD 协议，而在全双工方式不使用CSMA/CD 协议。 （4）与10BASE-T 和 100BASE-T 技术向后兼容。 吉比特以太网可用作现有网络的主干网，也可在高带宽（高速率）的应用场合中（如 医疗图像或CAD的图形等）用来连接计算机和服务器。 吉比特以太网的物理层使用两种成熟的技术：一种来自现有的以太网，另一种则是美 国国家标准协会ANSI 制定的光纤通道FC（Fibre Channel）。采用成熟技术就能大大缩短吉比 特以太网标准的开发时间。 表3-2 是吉比特以太网的物理层的标准。 表3-2 吉比特以太网物理层标准 名称 媒体 网段最大长度 特点 1000BASE-SX 光缆 550 m 多模光纤（50和62。5m） 1000BASE-LX 光缆 5000m 单模光纤（10um）多模光纤（50和62。5 um） 1000BASE-CX 铜缆 25 m 使用2对屏蔽双绞线电缆 STP 1000BASE-T 铜缆 100m 使用4对UTP5类线 现在 1000BASE-X（包括表3-2 中的前三项）的标准是IEEE 802。3z，而 1000BASE-T 的标准是IEEE 802。3ab。 吉比特以太网工作在半双工方式时，就必须进行碰撞检测。由于数据率提高了，因此 只有减小最大电缆长度或增大帧的最小长度，才能使参数a保持为较小的数值。若将吉比特 以太网最大电缆长度减小到10m，那么网络的实际价值就大大减小。而若将最短帧长提高 到640 字节，则在发送短数据时开销又嫌太大。因此，吉比特以太网仍然保持一个网段的最 大长度为100m，但采用了“载波延伸”（carrier extension）的办法，使最短帧长仍为64字节 （这样可以保持兼容性），同时将争用期增大为512字节。凡发送的 MAC 帧长不足 512 字 节时，就用一些特殊字符填充在帧的后面，使MAC 帧的发送长度增大到512字节，这对有 效载荷 并无影响。接收端在收到以太网的 MAC 帧后，要把所填充的特殊字符删除后才向 高层交付。当原来仅64字节长的短帧填充到512字节时，所填充的448字节就造成了很大 的开销。 为此，吉比特以太网还增加了一种功能称为分组突发（packet bursting）。这就是当很多短 帧要发送时，第一个短帧要采用上面所说的载波延伸的方法进行填充。但随后的一些短帧则 可一个接一个地发送，它们之间只需留有必要的帧间最小间隔即可。这样就形成一串分组的 突发，直到达到1500字节或稍多一些为止。当吉比特以太网工作在全双工方式时（即通信 双方可同时进行发送和接收数据），不使用载波延伸和分组突发。 吉比特以太网交换机可以直接与多个图形工作站相连。也可用作百兆以太网的主干网， 与百兆比特或吉比特交换机相连，然后再和大型服务器连接在一起。图3-29 是吉比特以太 网的一种配置举例。</p> <p><img src="" alt=""/> <em>图 3-29 吉比特以太网的配置举例</em></p> <h3 id="53-10-吉比特以太网10ge和更快的以太网">5.3 10 吉比特以太网（10GE）和更快的以太网</h3> <p>10GE 并非把吉比特以太网的速率简单地提高到10倍，因为还有许多技术上的问题要 解决。顺便指出，10吉比特就是10×10°比特，有人愿意称之为“万兆比特”。虽然“万” 是中国的一种常用的计量单位，但这与国际上通用的表示方法不一致，因此本书不予采用。 10GE 的帧格式与10Mbit/s，100 Mbit/s 和1Gbit/s 以太网的帧格式完全相同，并保留 了 802。3 标准规定的以太网最小帧长和最大帧长。这就使用户在将其已有的以太网进行升级 时，仍能和较低速率的以太网很方便地通信。 10GE 只工作在全双工方式，因此不存在争用问题，当然也不使用 CSMA/CD 协议。这 就使得 10GE 的传输距离大大提高了（因为不再受必须进行碰撞检测的限制）。 表3-3是10GE 的物理层标准。 表 3-3 10GE 的物理层标准 名称 媒体 网段最大长度 特点 10GBASE-SR 光缆 300m 多模光纤（0。85 um） 10GBASE-LR 光缆 10 km 单模光纤（1。3um） 10GBASE-ER 光缆 40 km 单模光纤（1。5um） 10GBASE-CX4 铜缆 15 m 10GBASE-T 铜缆 100m 使用 4 对双芯同轴电缆（twinax） 使用 46A 类 UTP 双绞线 表 3-3 中的前三项的标准是IEEE 802。3ae，在2002年6月完成。第四项的标准是 IEEE 802。3ak，完成于2004年。最后一项的标准是IEEE 802。3an，完成于2006年。 以太网的技术发展得很快。在10GE 之后又制定了 40GE/100GE（即40吉比特以太网 和 100 吉比特以太网）的标准 IEEE 802。3ba-2010 和 802。3bm-2015。表3-4是40GE 和 100GE 的物理层名称及传输距离，其中有两项带*号的是802。3bm 提出的。 需要指出的是，40GE/100GE 只工作在全双工的传输方式（因而不使用CSMA/CD 协 议），并且仍然保持了以太网的帧格式以及 802。3 标准规定的以太网最小和最大帧长。 100GE 在使用单模光纤传输时，仍然可以达到 40 km 的传输距离，但这需要波分复用（使 用4个波长复用一根光纤，每一个波长的有效传输速率是25Gbit/s）。</p> <p>物理层 表 3-4 40GB/100GB 以太网的物理层标准 40GB 以太网 100GB 以太网 在背板上传输至少超过1m 在铜缆上传输至少超过7m 在多模光纤上传输至少100m 在单模光纤上传输至少10km 在单模光纤上传输至少40km 40GBASE-KR4 40GBASE-CR4 40GBASE-SR4 40GBASE-LR4 *40GBASE-ER4 100GBASE-CR10 100GBASE-SR10， *100GBASE-SR4 100GBASE-LR4 100GBASE-ER4 现在以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从 而实现了端到端的以太网传输。这种工作方式的好处是： （1） 以太网是一种经过实践证明的成熟技术，无论是互联网服务提供者ISP还是端用户 都很愿意使用以太网。当然对ISP来说，使用以太网还需要在更大的范围进行试验。 （2） 以太网的互操作性也很好，不同厂商生产的以太网都能可靠地进行互操作。 （3） 在广域网中使用以太网时，其价格大约只有同步光纤网 SONET 的五分之一和异步 传递方式 ATM 的十分之一。以太网还能够适应多种传输媒体，如铜缆、双绞线以及各种光 缆。这就使具有不同传输媒体的用户在进行通信时不必重新布线。 （4） 端到端的以太网连接使帧的格式全都是以太网的格式，而不需要再进行帧的格式转 换，这就简化了操作和管理。但是，以太网和现有的其他网络，如帧中继或 ATM 网络，仍 然需要有相应的接口才能进行互连。 以太网从 10 Mbit/s 到 10 Gbit/s 甚至到100 Gbit/s 的演进，证明了以太网是： （1） 可扩展的速率从10Mbit/s 到 100 Gbit/s）。 （2） 灵活的（多种媒体、全/半双工、共享、交换）。 （3） 易于安装。 （4） 稳健性好。</p> <h3 id="54-使用以太网进行宽带接入">5.4 使用以太网进行宽带接入</h3> <p>现在人们也在使用以太网进行宽带接入互联网。为此，IEEE 在2001 年初成立了 802。3EFM 工作组，专门研究高速以太网的宽带接入技术问题。 以太网接入的一个重要特点是它可以提供双向的宽带通信，并且可以根据用户对带宽 的需求灵活地进行带宽升级（例如，把10兆的以太网交换机更新为吉比特的以太网交换 机）。当城域网和广域网都采用吉比特以太网或10 吉比特以太网时，采用以太网接入可以实 现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率且降 低了传输的成本。 然而以太网的帧格式标准中，在地址字段部分并没有用户名字段，也没有让用户键入 密码来鉴别用户身份的过程。如果网络运营商要利用以太网接入到互联网，就必须解决这个 问题。</p>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https://feng-zhang0712.github.io//blog/2024/2024-09-13-network-layer/" rel="alternate" type="text/html" title=""/><published>2024-09-19T15:26:10+00:00</published><updated>2024-09-19T15:26:10+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/2024-09-13-network-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/2024-09-13-network-layer/"><![CDATA[<p>本章的核心内容——网际协议 IP 是本书的一个重点内容。本章还要讨论网际控制报文协议 ICMP，几种常用的路由选择协议，IPv6 的主要特点，IP 多播的概念。本章最重要的内容是：</p> <ul> <li>虚拟互连网络的概念。</li> <li>IP 地址与物理地址的关系。</li> <li>传统的分类的 IP 地址（包括子网掩码）和无分类域间路由选择 CIDR。</li> <li>路由选择协议的工作原理。</li> </ul> <h2 id="一网络层提供的两种服务">一、网络层提供的两种服务</h2> <p>计算机网络发展的早期，人们曾认为，计算机网络应模仿打电话所使用的面向连接的通信方式。当两台计算机进行通信时，应当先建立连接（但在分组交换中是建立一条<strong>虚电路</strong> VC（Virtual Circuit）），以预留双方通信所需的一切网络资源。然后双方就沿着已建立的虚电路发送分组。图 4-1（a）是网络提供虚电路服务的示意图。主机 $H_1$ 和 $H_2$ 之间交换的分组都必须在事先建立的虚电路上传送。</p> <p>但互联网的先驱者却提出一种崭新的网络设计思路。他们认为，电信网提供的端到端可靠传输的服务对电话业务无疑是很合适的，因为电信网的终端（电话机）非常简单，没有智能，也没有差错处理能力。因此电信网必须负责把用户电话机产生的话音信号可靠地传送到对方的电话机，使还原后的话音质量符合技术规范的要求。但计算机网络的端系统是有智能的计算机。计算机有很强的差错处理能力（这点和传统的电话机有本质上的差别）。因此，互联网在设计上就采用了和电信网完全不同的思路。</p> <p>互联网采用的设计思路是这样的：<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong>。这里的“数据报”（datagram）指我们经常使用的“分组”。</p> <p>网络在发送分组时不需要先建立连接。每个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。<strong>网络层不提供服务质量的承诺</strong>。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器比较简单，且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。</p> <p>图 4-1（b）给出了网络提供数据报服务的示意图。主机 $H_1$ 向 $H_2$ 发送的分组各自独立地选择路由，并且在传送的过程中还可能丢失。</p> <p><img src="/assets/images/computer-networks/two-types-of-services-provided-by-the-network-layer.png" alt="网络层提供的两种服务"/> <em>图 4-1 网络层提供的两种服务</em></p> <p>| 对比的方面 | 虚电路服务 | 数据报服务 | | — | — | — | | 思路 | 可靠通信应当由网络来保证 | 可靠通信应当由用户主机来保证 | | 连接的建立 | 必须有 | 不需要 | | 终点地址 | 仅在连接建立阶段使用，每个分组使用短的虚电路号 | 每个分组都有终点的完整地址 | | 分组的转发 | 属于同一条虚电路的分组均按照同一路由进行转发 | 每个分组独立选择路由进行转发 | | 当结点出故障时 | 所有通过出故障的结点的虚电路均不能工作 | 出故障的结点可能会丢失分组，一些路由可能会发生变化 | | 分组的顺序 | 总是按发送顺序到达终点 | 到达终点的时间不一定按发送顺序 | | 端到端的差错处理和流量控制 | 可以由网络负责，也可以由用户主机负责 | 由用户主机负责 | <em>表 4-1 虚电路服务与数据报服务的对比</em></p> <h2 id="二网际协议-ip">二、网际协议 IP</h2> <p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一[STEV94][COME06][FORO10]，也是最重要的互联网标准协议之一（注意，这里所讲的 IP 是 IP 的第 4 个版本（IPv4）。但在讲述 IP 协议的各种原理时，往往不在 IP 后面加上版本号。在后面的 <a href="#六ipv6">第六节</a> 会介绍较新的版本 IPv6）。</p> <p>与 IP 协议配套使用的还有三个协议：</p> <ul> <li><strong>地址解析协议 ARP</strong>（Address Resolution Protocol）</li> <li><strong>网际控制报文协议 ICMP</strong>（Internet Control Message Protocol）</li> <li><strong>网际组管理协议 IGMP</strong>（Internet Group Management Protocol）</li> </ul> <p>图 4-2 画出了这三个协议和网际协议 IP 的关系。在这一层中，ARP 画在最下面，因为 IP 经常要使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层常常被称为<strong>网际层</strong>（internet layer），或 <strong>IP 层</strong>。</p> <p><img src="/assets/images/computer-networks/internet-protocol-ip-and-its-supporting-protocols.png" alt="网际协议 IP 及其配套协议"/> <em>图 4-2 网际协议 IP及其配套协议</em></p> <h3 id="21-虚拟互连网络">2.1 虚拟互连网络</h3> <p>将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p> <ul> <li>物理层使用的中间设备叫做<strong>转发器</strong>（repeater）。</li> <li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>（bridge）。</li> <li>网络层使用的中间设备叫做<strong>路由器</strong>（router）。</li> <li>在网络层以上使用的中间设备叫做<strong>网关</strong>（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li> </ul> <p>当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称之为网络互连。网关由于比较复杂，目前使用得较少。因此现在我们讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。注意，由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关（本书有时也这样用）。</p> <p>图 4-3（a）表示有许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的<strong>网际协议 IP</strong>（Internet Protocol），因此可以把互连以后的计算机网络看成如图 4-3（b）所示的一个<strong>虚拟互连网络</strong>（internet）。所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。这种使用 IP协 议的虚拟互连网络可简称为 IP 网。使用 IP 网的好处是：当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节（如具体的编址方案、路由选择协议，等等）。如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网（Internet）。</p> <p><img src="/assets/images/computer-networks/the-concept-of-ip-network.png" alt="IP 网的概念"/> <em>图 4-3 IP 网的概念</em></p> <p>在图 4-4 所示的互联网中的源主机 $H_1$ 要把一个 IP 数据报发送给目的主机 $H_2$。根据之前讲过的分组交换的存储转发概念，主机 $H_1$ 先要查找自己的路由表，看目的主机是否就在本网络上。如是，则不需要经过任何路由器而是<strong>直接交付</strong>，任务就完成了。如不是，则必须把 IP 数据报发送给某个路由器（图中的 $R_1$）。$R_1$ 在查找了自己的路由表后，知道应当把数据报转发给 $R_2$ 进行<strong>间接交付</strong>。这样一直转发下去，最后由路由器 $R_5$ 知道自己是和 $H_2$ 连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报直接交付目的主机 $H_2$。图中画出了源主机、目的主机以及各路由器的协议栈。我们注意到，主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向（用黑色粗线表示）。我们还可注意到，在 $R_4$ 和 $R_5$ 之间使用了卫星链路，而 $R_5$ 所连接的是个无线局域网。在 $R_1$ 到 $R_4$ 之间的三个网络则可以是任意类型的网络。总之，这里强调的是：<strong>互联网可以由多种异构网络互连组成</strong>。</p> <p>如果我们只从网络层考虑问题，那么IP 数据报就可以想象是在网络层中传送，其传送路径是：</p> \[H_1 → R_1 → R_2 → R_3 → R_4 → R_5 → H_2\] <p><img src="/assets/images/computer-networks/transmission-of-packets-over-the-internet.png" alt="分组在互联网中的传送"/> <em>图 4-4 分组在互联网中的传送</em></p> <h3 id="22-分类的-ip-地址">2.2 分类的 IP 地址</h3> <p>在 TCP/IP 体系中，IP 地址是一个最基本的概念。有关 IP 最重要的文档就是互联网的正式标准 RFC 791。</p> <h4 id="1ip-地址及其表示方法">（1）IP 地址及其表示方法</h4> <p>整个的互联网就是一个<strong>单一的、抽象的网络</strong>。IP 地址就是给互联网上的每台主机（或路由器）的每个接口分配一个在全世界范围内是唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上很方便地进行寻址。IP 地址现在由<strong>互联网名字和数字分配机构 ICANN</strong>（Internet Corporation for Assigned Names and Numbers）进行分配。</p> <p>IP 地址的编址方法共经过了三个历史阶段。</p> <ol> <li><strong>分类的 IP 地址</strong>：这是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li> <li><strong>子网的划分</strong>：这是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</li> <li><strong>构成超网</strong>：这是比较新的无分类编址方法。1993 年提出后很快就得到推广应用。</li> </ol> <p>所谓“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每类地址都由两个固定长度的字段组成。</p> <ol> <li><strong>网络号</strong>（net-id）：第一个字段。它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。</li> <li><strong>主机号</strong>（host-id）：第二个字段。它标志该主机（或路由器）。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li> </ol> <p>由此可见，一个 IP 地址<strong>在整个互联网范围内是唯一的</strong>。这种两级的 IP 地址可以记为：</p> \[IP 地址 ::= {&lt;网络号&gt;, &lt;主机号&gt;}\] <p>上式中的符号“::=”表示“<strong>定义为</strong>”。图 4-5 给出了各种 IP 地址的网络号字段和主机号字段，这里 A 类、B 类和 C 类地址都是单播地址（一对一通信），是最常用的。</p> <p><img src="/assets/images/computer-networks/the-network-number-field-and-host-number-field-in-the-ip-address.png" alt="IP 地址中的网络号字段和主机号字段"/> <em>图 4-5 IP 地址中的网络号字段和主机号字段</em></p> <p>从图 4-5 可以看出：</p> <ul> <li>A 类、B 类和 C 类地址的网络号字段（在图中这个字段是灰色的）分别为 1 个、2 个和 3 个字节长，而在网络号字段的最前面有 1~3 位的<strong>类别位</strong>，其数值分别规定为 0、10 和 110。</li> <li>A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。</li> <li>D 类地址（前 4 位是 1110）用于多播（一对多通信）。</li> <li>E 类地址（前 4 位是 1111）保留为以后用。</li> </ul> <p>这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、B 类和 C 类地址的区分已成为历史[RFC1812]，但由于很多文献和资料都还使用传统的分类的 IP 地址，而且从概念的演进上更清晰，因此我们在这里还要从分类的 IP 地址讲起。</p> <p>从 IP 地址的结构来看，IP 地址并不仅仅指明一台主机，而是还指明了主机连接到的网络。</p> <p>把 IP 地址划分为 A 类、B 类、C 类三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把 IP 地址划分为 A 类、B 类和 C 类是为了更好地满足不同用户的要求。当某个单位申请到一个 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。</p> <p>对主机或路由器来说，IP 地址都是 32 位的二进制代码。为了提高可读性，我们常把 32 位的 IP 地址中的每 8 位插入一个空格（但在机器中并没有这样的空格）。为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做<strong>点分十进制记法</strong>（dotted decimal notation）。图 4-6 是一个 B 类 IP 地址的表示方法。显然，128.11.3.31 比 10000000 00001011 00000011 00011111 书写起来要方便得多。</p> <p><img src="/assets/images/computer-networks/the-use-of-dotted-decimal-notation-improves-readability.png" alt="采用点分十进制记法能够提高可读性"/> <em>图 4-6 采用点分十进制记法能够提高可读性</em></p> <h4 id="2常用的三种类别的-ip-地址">（2）常用的三种类别的 IP 地址</h4> <p>A 类地址的网络号字段占 1 个字节，只有 7 位可供使用（该字段的第一位已固定为 0），但可指派的网络号是 126 个（即 $2^{-7} - 2$）。减 2 的原因是：第一，IP 地址中的全 0 表示“这个（this）”。网络号字段为全 0 的 IP 地址是个保留地址，意思是“<strong>本网络</strong>”；第二，网络号为 127（即 01111111）保留作为本地软件<strong>环回测试</strong>（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。</p> <p>A 类地址的主机号占 3 个字节，因此每个 A 类网络中的最大主机数是 $2^{24} - 2$，即 16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>单个网络地址</strong>（例如，一主机的 IP 地址为5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示“所有的（all）”，因此全 1 的主机号字段表示该网络上的所有主机。</p> <p>IP 地址空间共有 $2^{32}$（即 4294967296）个地址。整个 A 类地址空间共有 21 个地址，占整个 IP 地址空间的 50%。</p> <p>B 类地址的网络号字段有 2 个字节，但前面两位（10）已经固定了，只剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此这里不存在网络总数减 2 的问题。但实际上 B 类网络地址128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0 [COME06]。因此 B 类地址可指派的网络数为 $2^{14} - 1$，即 16383。B 类地址的每个网络上的最大主机数是 $2^{16} - 2$，即 65534。这里需要减 2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 $2^{30}$ 个地址，占整个 IP 地址空间的 25%。</p> <p>C 类地址有 3 个字节的网络号字段，最前面的 3 位是（110），还有 21 位可以进行分配。C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络地址是 192.0.1.0 [COME06]，因此 C 类地址可指派的网络总数是 $2^{21} - 1$，即 2097151。每个 C 类地址的最大主机数是 $2^8 - 2$，即 254。整个 C 类地址空间共约有 $2^{29}$ 个地址，占整个 IP 地址的 12.5%。</p> <p>这样，我们就可得出表 4-2 所示的 IP 地址的指派范围。</p> <p>| 网络类别 | 最大可指派的网络数 | 第一个可指派的网络号 | 最后一个可指派的网络号 | 每个网络中的最大主机数 | | — | — | — | — | — | | A | $126(2^7 - 2)$ | 1 | 126 | 16777214 | | B | $16383(2^{14} - 1)$ | 128.1 | 191.255 | 65534 | | C | $2097151(2^{21} - 1)$ | 192.0.1 | 223.255.255 | 254 | <em>表 4-2 IP 地址的指派范围</em></p> <p>表 4-3 给出了一般不使用的特殊 IP 地址，这些地址只能在特定的情况下使用。</p> <p>| 网络号 | 主机号 | 源地址使用 | 目的地址使用 | 代表的意思 | | — | — | — | — | — | | 0 | 0 | 可以 | 不可 | 在本网络上的本主机（见6。6节 DHCP 协议） | | 0 | host-id | 可以 | 不可 | 在本网络上的某台主机 host-id | | 全 1 | 全 1 | 不可 | 可以 | 只在本网络上进行广播（各路由器均不转发） | | net-id | 全 1 | 不可 | 可以 | 对 net-id 上的所有主机进行广播 | | 127 | 非全 0 或全 1 的任何数 | 可以 | 可以 | 用于本地软件环回测试 | <em>表 4-3 一般不使用的特殊 IP 地址</em></p> <p>IP 地址具有以下一些重要特点。</p> <ol> <li>每个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种<strong>分等级的地址结构</strong>。分两个等级的好处是： <ul> <li>第一，IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong>（第一级），而剩下的主机号（第二级）则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理；</li> <li>第二，路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong>（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而<strong>减小了路由表所占的存储空间以及查找路由表的时间</strong>。</li> </ul> </li> <li>实际上 IP 地址是标志一台主机（或路由器）和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>（multihomed host）。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。这好比一个建筑正好处在北京路和上海路的交叉口上，那么这个建筑就可以拥有两个门牌号码。例如，北京路 4 号和上海路 37 号。</li> <li>按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，<strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li> <li>在 IP 地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是<strong>平等</strong>的。所谓平等，是指互联网同等对待每个 IP 地址。图 4-7 画出了三个局域网（$LAN_1$，$LAN_2$ 和 $LAN_3$）通过三个路由器（$R_1$，$R_2$ 和 $R_3$）互连起来所构成的一个互联网（此互联网用虚线圆角方框表示）。其中局域网 $LAN_2$， 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有一个 IP 地址。</li> </ol> <p>我们应当注意到：</p> <ul> <li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。图中所示的网络号就是 IP 地址中的网络号字段的值，这也是文献中常见的一种表示方法。另一种表示方法是用主机号为全 0 的网络 IP 地址。</li> <li>用网桥（它只在链路层工作）互连的网段仍然是一个局域网，只能有一个网络号。</li> <li>路由器总是具有两个或两个以上的 IP 地址。即路由器的每个接口都有一个不同网络号的 IP 地址。</li> <li>当两个路由器直接相连时（例如通过一条租用线路），在连线两端的接口处，可以分配也可以不分配 IP 地址。如分配了 IP 地址，则这段连线就构成了一种只包含一段线路的特殊“网络”（如图中的 $N_1$，$N_2$ 和 $N_3$）。之所以叫做“网络”是因为它有 IP 地址。但为了节省 IP 地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配 IP 地址。通常把这样的特殊网络叫做<strong>无编号网络</strong>（unnumbered network）或<strong>无名网络</strong>（anonymous network）[COME06]。</li> </ul> <p><img src="/assets/images/computer-networks/an-ip-address-on-the-internet.png" alt="互联网中的 IP 地址"/> <em>图 4-7 互联网中的 IP 地址</em></p> <h3 id="23-ip-地址与硬件地址">2.3 IP 地址与硬件地址</h3> <p>图 4-8 说明了 IP 地址与硬件地址的区别。从层次的角度看，<strong>物理地址是数据链路层和物理层使用的地址</strong>，而 <strong>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</strong>。</p> <p><img src="/assets/images/computer-networks/differences-between-ip-addresses-and-hardware-addresses.png" alt="IP 地址与硬件地址的区别"/> <em>图 4-8 IP 地址与硬件地址的区别</em></p> <p>在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在MAC 帧的首部中。</p> <p>连接在通信链路上的设备（主机或路由器）在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。</p> <p>总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。</p> <p>图 4-9（a）画的是三个局域网用两个路由器 $R_1$ 和 $R_2$ 互连起来。现在主机 $H_1$ 要和主机 $H_2$ 通信。这两台主机的 IP 地址分别是 $IP_1$ 和 $IP_2$，而它们的硬件地址分别为 $HA_1$ 和 $HA2_1$（HA 表示 Hardware Address）。通信的路径是：$H_1$ → 经过 $R_1$ 转发 → 再经过 $R_2$ 转发 → $H_2$。路由器 $R_1$ 因同时连接到两个局域网上，因此它有两个硬件地址，即 $HA_3$ 和 $HA_4$。同理，路由器 $R_2$ 也有两个硬件地址 $HA_5$ 和 $HA_6$。</p> <p><img src="/assets/images/computer-networks/ip-addresses-and-hardware-addresses-at-different-levels.png" alt="从不同层次上看 IP 地址和硬件地址"/> <em>图 4-9 从不同层次上看 IP 地址和硬件地址</em></p> <p>图4-9（b）特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。</p> <p><img src="/assets/images/computer-networks/source-and-destination-addresses-of-different-levels-and-ranges.png" alt="图 4-9（b）中不同层次、不同区间的源地址和目的地址"/> <em>表 4-4 图 4-9（b）中不同层次、不同区间的源地址和目的地址</em></p> <p>这里要强调指出以下几点：</p> <ul> <li><strong>在 IP 层抽象的互联网上只能看到 IP 数据报</strong>。虽然 IP 数据报要经过路由器 $R_1$ 和 $R_2$ 的两次转发，但在它的首部中的源地址和目的地址始终分别是 $IP_1$ 和 $IP_2$。图中的数据报上写的“从 $IP_1$ 到 $IP_2$”就表示前者是源地址而后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li> <li>虽然在 IP 数据报首部有源站 IP 地址，但<strong>路由器只根据目的站的 IP 地址的网络号进行路由选择</strong>。</li> <li><strong>在局域网的链路层，只能看见 MAC 帧</strong>。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图 4-9（b）。开始在 $H_1$ 到 $R_1$ 间传送时，MAC 帧首部中写的是从硬件地址 $HA_1$，发送到硬件地址 $HA_3$，路由器 $R_1$ 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新添加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 $HA_4$ 和 $HA_5$。路由器 $R_2$ 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变成为 $HA_6$ 和 $HA_2$。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。</li> <li>尽管互连在一起的网络的硬件地址体系各不相同，但<strong>IP 层抽象的互联网却屏蔽了下层这些很复杂的细节</strong>。<strong>只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信</strong>。上述的这种“屏蔽”概念是一个很有用，很普遍的基本概念。例如，计算机中广泛使用的图形用户界面使得用户只需简单地点击几下鼠标就能让计算机完成很多任务。实际上计算机要完成这些任务必须执行很多条指令。但这些复杂的过程全都被设计良好的图形用户界面屏蔽掉了，使用户看不见这些复杂过程。</li> </ul> <p>以上这些概念是计算机网络的精髓所在，对这些重要概念务必仔细思考和掌握。到目前为止，还有两个重要问题没有解决：</p> <ol> <li>主机或路由器怎样知道应当在 MAC 帧的首部填入什么样的硬件地址？</li> <li>路由器中的路由表是怎样得出的？</li> </ol> <p>第一个问题就是下一节所要讲的内容，而第二个问题将在后面的 <a href="#五互联网的路由选择协议">第五节</a> 节详细讨论。</p> <h3 id="24-地址解析协议-arp">2.4 地址解析协议 ARP</h3> <p>在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址。地址解析协议 ARP 就是用来解决这样的问题的。图 4-10 说明了 ARP 协议的作用。</p> <p><img src="/assets/images/computer-networks/function-of-arp-protocol.png" alt="ARP 协议的作用"/> <em>图 4-10 ARP 协议的作用</em></p> <p>由于是 IP 协议使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。ARP 协议的用途是为了从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。注意，还有一个旧的协议叫做逆地址解析协议 RARP，它的作用是使只知道自己硬件地址的主机能够通过 RARP 协议找出其 IP 地址。现在的 DHCP 协议已经包含了 RARP 协议的功能。因此本书不再介绍 RARP 协议。</p> <p>我们知道，网络层使用的是 IP 地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但 IP 地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系（例如，IP 地址有 32 位，而局域网的硬件地址是 48 位）。此外，在一个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变。<strong>地址解析协议 ARP</strong> 解决这个问题的方法是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。</p> <p>每台主机都设有一个 <strong>ARP 高速缓存</strong>（ARP cache），里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p> <p>当主机 A 要向<strong>本局域网</strong>上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。也有可能查不到主机 B 的 IP 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 ARP，然后按以下步骤找出主机 B 的硬件地址。</p> <ol> <li>ARP 进程在本局域网上广播发送一个 ARP 请求分组（具体格式可参阅[COME06]的第 23 章）。图 4-11（a）是主机 A 广播发送 ARP 请求分组的示意图。ARP 请求分组的主要内容是：“我的 IP 地址是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18。我想知道 IP 地址为 209.0.0.6 的主机的硬件地址。”</li> <li>在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组。</li> <li>主机 B 的 IP 地址与 ARP 请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机 A 发送 ARP 响应分组（其格式见[COME06]），同时在这个 ARP 响应分组中写入自己的硬件地址。由于其余的所有主机的 IP 地址都与 ARP 请求分组中要查询的 IP 地址不一致，因此都不理睬这个 ARP 请求分组，见图 4-11（b）。ARP 响应分组的主要内容是：“我的 IP 地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A。”请注意：虽然 ARP 请求分组是广播发送的，但 ARP 响应分组是普通的单播，即从一个源地址发送到一个目的地址。</li> <li>主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的IP 地址到硬件地址的映射。</li> </ol> <p><img src="/assets/images/computer-networks/the-working-principle-of-the-address-resolution-protocol.png" alt="地址解析协议 ARP 的工作原理"/> <em>图 4-11 地址解析协议 ARP 的工作原理</em></p> <p>在上述第（3）步中，当主机 B 收到 A 的 ARP 请求分组时，同时会把主机 A 的地址映射写入主机 B 自己的 ARP 高速缓存中。以后主机 B 向 A 发送数据报时就很方便了。</p> <p>ARP 把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。</p> <p>ARP 对保存在高速缓存中的每个映射地址项目都设置生存时间（例如，10 ～ 20 分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目的生存时间是很重要的。设想有一种情况。主机 A 和 B 通信。A 的 ARP 高速缓存里保存有 B 的硬件地址。但 B 的网络适配器突然坏了，B 立即更换了一块，因此 B 的硬件地址就改变了。假定 A 还要和 B 继续通信。A 在其 ARP 高速缓存中查找到 B 原先的硬件地址，并使用该硬件地址向 B 发送数据帧。但 B 原先的硬件地址已经失效了，因此 A 无法找到主机 B。但是过了一段不长的生存时间，A 的 ARP 高速缓存中已经删除了 B 原先的硬件地址，于是 A 重新广播发送 ARP 请求分组，又找到了 B。</p> <p>注意，ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如，在前面的图 4-9 中，主机 H 就无法解析出另一个局域网上主机 $H_2$ 的硬件地址（实际上主机 $H_1$ 也不需要知道远程主机 $H_2$ 的硬件地址）。主机 $H_1$ 发送给 $H_2$ 的 IP 数据报首先需要通过与主机 $H_1$ 连接在同一个局域网上的路由器 $R_1$ 来转发。因此主机 $H_1$ 这时需要把路由器 $R_1$ 的 IP 地址 $IP_3$，解析为硬件地址 $HA_3$，以便能够把 IP 数据报传送到路由器 $R_1$。以后 $R_1$ 从转发表找出了下一跳路由器 $R_2$，同时使用 ARP 解析出 $R_2$ 的硬件地址 $HA_5$。于是 IP 数据报按照硬件地址 $HA_5$，转发到路由器 $R_2$。路由器 $R_2$ 在转发这个 IP 数据报时用类似方法解析出目的主机 $H_2$ 的硬件地址 $HA_2$，使 IP 数据报最终交付主机 $H_2$。</p> <p>从 IP 地址到硬件地址的解析是自动进行的，<strong>主机的用户对这种地址解析过程是不知道的</strong>。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地把这个 IP 地址解析为链路层所需要的硬件地址。</p> <p>下面我们归纳出使用ARP的四种典型情况（图4-12）。</p> <p><img src="/assets/images/computer-networks/four-typical-scenarios-for-using-arp.png" alt="使用 ARP 的四种典型情况"/> <em>图4 -12 使用 ARP 的四种典型情况</em></p> <ol> <li>发送方是主机（如 $H_1$），要把 IP 数据报发送到同一个网络上的另一台主机（如 $H_2$）。这时 $H_1$ 发送 ARP 请求分组（在网上广播），找到目的主机 $H_2$ 的硬件地址。</li> <li>发送方是主机（如 $H_1$），要把 IP 数据报发送到另一个网络上的一台主机（如 $H_3$ 或 $H_4$）。这时 $H_1$ 发送 ARP 请求分组（在网上广播），找到网上的一个路由器 $R_1$ 的硬件地址。剩下的工作由路由器 $R_1$ 来完成。$R_1$ 要做的事情是下面的（3）或（4）。</li> <li>发送方是路由器（如 $R_1$），要把 IP 数据报转发到与 $R_1$ 连接在同一个网络（网 2）上的主机（如 $H_3$）。这时 $R_1$ 发送 ARP 请求分组（在网 2 上广播），找到目的主机 $H_3$ 的硬件地址。</li> <li>发送方是路由器（如 $R_1$），要把 IP 数据报转发到网 3 上的一台主机（如 $H_4$）。$H_4$ 与 $R_1$ 不是连接在同一个网络上。这时 $R_1$ 发送 ARP 请求分组（在网 2 上广播），找到连接在网 2 上的一个路由器 R2 的硬件地址。剩下的工作由这个路由器 $R_2$ 来完成。</li> </ol> <p>在许多情况下需要多次使用 ARP。但这只是以上几种情况的反复使用而已。</p> <p>既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的 IP 地址，而不直接使用硬件地址进行通信？由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但 IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p> <h3 id="25-ip-数据报的格式">2.5 IP 数据报的格式</h3> <p>IP 数据报的格式能够说明 IP 协议都具有什么功能。在 TCP/IP 的标准中，各种数据格式常常以 32 位（即 4 字节）为单位来描述。图 4-13 是 IP 数据报的完整格式。</p> <p><img src="/assets/images/computer-networks/format-of-the-ip-datagram.png" alt="IP 数据报的格式"/> <em>图 4-13 IP 数据报的格式</em></p> <p>从图 4-13 可看出，一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。</p> <h4 id="1ip-数据报首部的固定部分中的各字段">（1）IP 数据报首部的固定部分中的各字段</h4> <ul> <li><strong>版本</strong>：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4（即 IPv4）。</li> <li><strong>首部长度</strong>：占 4 位，可表示的最大十进制数值是 15。请注意，首部长度字段所表示数的单位是 32 位字（1 个 32 位字长是 4 字节）。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 5（即二进制表示的首部长度是 0101）。而当首部长度为最大值 1111 时（即十进制数的 15），就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节（即首部长度为 0101），这时不使用任何选项。</li> <li><strong>区分服务</strong>：占 8 位，用来获得更好的服务。只有在使用区分服务时，这个字段才起作用。一般情况下不使用这个字段[RFC2474，3168，3260]。</li> <li> <p><strong>总长度</strong>：总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 $2^{16} - 1$ = 65535 字节。 然而实际上传送这样长的数据报在现实中是极少遇到的。</p> <p>我们知道，在 IP 层下面的每种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为<strong>最大传送单元 MTU</strong>（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的 MTU 值。例如，最常用的以太网就规定其 MTU 值是 1500 字节。若所传送的数据报长度超过数据链路层的 MTU 值，就必须把过长的数据报进行分片处理。</p> <p>虽然使用尽可能长的 IP 数据报会使传输效率得到提高（因为每个 IP 数据报中首部长度占数据报总长度的比例就会小些），但数据报短些也有好处。每个 IP 数据报越短，路由器转发的速度就越快。为此，IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p> <p>在进行分片时（见后面的“片偏移”字段），数据报首部中的“总长度”字段是指分片后的每个分片的首部长度与该分片的数据长度的总和。</p> </li> <li> <p><strong>标识</strong>（identification）：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p> </li> <li><strong>标志</strong>（flag）：占 3 位，但目前只有两位有意义。 <ul> <li>标志字段中的最低位记为 MF（More Fragment）。MF = 1 即表示后面“还有分片”的数据报。MF = 0 表示这已是若干数据报片中的最后一个。</li> <li>标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF = 0 时才允许分片。</li> </ul> </li> <li> <p><strong>片偏移</strong>：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位。这就是说，每个分片的长度一定是 8 字节（64 位）的整数倍。下面举一个例子。 【例 4-1】 一数据报的总长度为 3820 字节，其数据部分为 3800 字节长（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。于是分为 3 个数据报片，其数据部分的长度分别为 1400，1400 和 1000 字节。原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。图 4-14 给出分片后得出的结果（注意片偏移的数值）。</p> <p><img src="/assets/images/computer-networks/example-for-fragment-datagram.png" alt="数据报的分片举例"/> <em>图 4-14 数据报的分片举例</em></p> <p>表 4-5 是本例中数据报首部与分片有关的字段中的数值，其中标识字段的值是任意给定的（12345）。具有相同标识的数据报片在目的站就可无误地重装成原来的数据报。</p> <p>| | 总长度 | 标识 | MF | DF | 片偏移 | | :—: | :—: | :—: | :—: | :—: | :—: | | 原始数据报 | 3820 | 12345 | 0 | 0 | 0 | | 数据报片 1 | 1420 | 12345 | 1 | 0 | 0 | | 数据报片 2 | 1420 | 12345 | 1 | 0 | 175 | | 数据报片 3 | 1020 | 12345 | 0 | 0 | 350 | <em>表 4-5 IP 数据报首部中与分片有关的字段中的数值</em></p> <p>现在假定数据报片 2 经过某个网络时还需要再进行分片，即划分为数据报片 2-1（携带数据 800 字节）和数据报片 2-2（携带数据 600 字节）。那么这两个数据报片的总长度、标识、MF、DF 和片偏移分别为：820，12345，1，0， 175；620，12345，1，0，275。</p> </li> <li> <p><strong>生存时间</strong>：占 8 位，生存时间字段常用的英文缩写是 TTL（Time To Live），表明这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子（例如从路由器 $R_1$ 转发到 $R_2$，再转发到 $R_3$，然后又转发到 $R_1$），因而白白消耗网络资源。最初的设计是以秒作为 TTL 值的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于 1 秒，后来就把 TTL 字段的功能改为“<strong>跳数限制</strong>”（但名称不变）。路由器在每次转发数据报之前就把 TTL 值减 1。若 TTL 值减小到零，就丢弃这个数据报，不再转发。因此，现在 TTL 的单位不再是秒，而是<strong>跳数</strong>。TTL 的意义是指明数据报在互联网中至多可经过多少个路由器。显然，数据报能在互联网中经过的路由器的最大数值是 255。若把 TTL 的初始值设置为 1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前 TTL 值就减小到零，因而就会被这个路由器丢弃。</p> </li> <li> <p><strong>协议</strong>：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。</p> <p>常用的一些协议和相应的协议字段值如下：</p> <table> <thead> <tr> <th>协议名</th> <th>ICMP</th> <th>IGMP</th> <th>IP</th> <th>TCP</th> <th>EGP</th> <th>IGP</th> <th>UDP</th> <th>IPv6</th> <th>ESP</th> <th>OSPF</th> </tr> </thead> <tbody> <tr> <td>协议字段值</td> <td>1</td> <td>2</td> <td>4</td> <td>6</td> <td>8</td> <td>9</td> <td>17</td> <td>41</td> <td>50</td> <td>89</td> </tr> </tbody> </table> </li> <li> <p><strong>首部检验和</strong>：占 16 位。这个字段<strong>只检验数据报的首部</strong>，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的 CRC 检验码而采用下面的简单计算方法：在发送方，先把 IP 数据报首部划分为许多 16 位字的序列，并把检验和字段置零。用反码算术运算把所有 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有 16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为 0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。图 4-15 说明了 IP 数据报首部检验和的计算过程。</p> <p><img src="/assets/images/computer-networks/the-calculation-process-of-ip-datagram-header-check-sum.png" alt="IP 数据报首部检验和的计算过程"/> <em>图 4-15 IP 数据报首部检验和的计算过程</em></p> </li> <li><strong>源地址</strong>：占 32 位。</li> <li><strong>目的地址</strong>：占 32 位。</li> </ul> <h4 id="2ip-数据报首部的可变部分">（2）IP 数据报首部的可变部分</h4> <p>IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。</p> <p>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 IPv6 就把 IP 数据报的首部长度做成固定的。</p> <h3 id="26-ip-层转发分组的流程">2.6 IP 层转发分组的流程</h3> <p>图 4-16（a）是一个路由表的简单例子。有四个 A 类网络通过三个路由器连接在一起。每个网络上都可能有成千上万台主机（图中没有画出这些主机）。可以想象，若路由表指出到每台主机应怎样转发，则所得出的路由表就会过于庞大（如果每个网络有 1 万台主机，四个网络就有 4 万台主机，因而每个路由表就有 4 万个项目，即 4 万行。每一行对应于一台主机）。但若路由表指出到某个网络应如何转发，则每个路由器中的路由表就只包含 4 个项目（即只有 4 行，每一行对应于一个网络）。以路由器 $R_2$ 的路由表为例。由于 $R_2$ 同时连接在网络 2 和网络 3 上，因此只要目的主机在网络 2 或网络 3上，都可通过接口 0 或 1 由路由器 $R_2$ 直接交付（当然还要利用地址解析协议 ARP 才能找到这些主机相应的硬件地址）。若目的主机在网络 1 中，则下一跳路由器应为 $R_1$，其 IP 地址为 20.0.0.7。路由器 $R_2$ 和 $R_1$ 由于同时连接在网络 2 上，因此从路由器 $R_2$ 分组转发到路由器 $R_1$ 是很容易的。同理，若目的主机在网络 4 中，则路由器 $R_2$ 应把分组转发给 IP 地址为30.0.0.1 的路由器 $R_3$。我们应当注意到，图中的每个路由器都有两个不同的 IP 地址。</p> <p>可以把整个的网络拓扑简化为图 4-16（b）所示的那样。在简化图中，网络变成了一条链路，但每个路由器旁边都注明其 IP 地址。使用这样的简化图，可以使我们不必关心某个网络内部的具体拓扑以及连接在该网络上有多少台主机，因为这些对于研究分组转发问题并没有什么关系。这样的简化图强调了在互联网上转发分组时，是从一个路由器转发到下一个路由器。</p> <p>总之，在路由表中，对每一条路由最主要的是以下两个信息：</p> \[（目的网络地址，下一跳地址）\] <p><img src="/assets/images/computer-networks/an-example-of-routing-table.png" alt="路由表举例"/> <em>图 4-16 路由表举例</em></p> <p>于是，我们就根据目的网络地址来确定下一跳路由器，这样做可得出以下的结果。</p> <ul> <li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li> <li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li> </ul> <p>虽然互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做<strong>特定主机路由</strong>。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某台主机的特殊路由就十分有用。</p> <p>路由器还可采用<strong>默认路由</strong>（default route）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。实际上，默认路由在主机发送 IP 数据报时往往更能显示出它的好处。我们之前讲过，主机在发送每个 IP 数据报时都要查找自己的路由表。如果一台主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。例如，在图 4-17 的互联网中，连接在网络上的任何一台主机中的路由表只需要三个项目即可。第一个项目就是到本网络主机的路由，其目的网络就是本网络 $N_1$，因而不需要路由器转发，而是直接交付。第二个项目是到网络 $N_2$ 的路由，对应的下一跳路由器是 $R_2$。第三个项目就是<strong>默认路由</strong>。只要目的网络是其他网络（不是 $N_1$ 或 $N_2$），就一律选择默认路由，把数据报先间接交付路由器 $R_1$，让再 $R_1$ 转发给互联网中的下一个路由器，一直转发到目的网络上的路由器，最后进行直接交付。在实际上的路由器中，像图 4-17 路由表中所示的“直接”和“其他”的几个字符并没有出现在路由表中，而是被记为 0.0.0.0。</p> <p><img src="/assets/images/computer-networks/router-r1-acts-as-the-default-router-for-network-n1.png" alt="路由器 $R_1$ 充当网络 $N_1$ 的默认路由器"/> <em>图 4-17 路由器 $R_1$ 充当网络 $N_1$ 的默认路由器</em></p> <p>这里我们应当强调指出，在 IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。在 IP 数据报的首部写上的 IP 地址是源 IP 地址和目的 IP 地址，而没有中间经过的路由器的 IP 地址。既然 IP 数据报中没有下一跳路由器的 IP 地址，那么待转发的数据报又怎样能够找到下一跳路由器呢？</p> <p>当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（必须使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用 ARP 得到硬件地址、把硬件地址写入 MAC 帧的首部等过程，将不断地重复进行，造成了一定的开销。</p> <p>那么，能不能在路由表中不使用 IP 地址而直接使用硬件地址呢？不行。我们一定要弄清楚，使用抽象的 IP 地址，本来就是为了隐蔽各种底层网络的复杂性而便于分析和研究问题，这样就不可避免地要付出代价，例如在选择路由时多了一些开销。但反过来，如果在路由表中直接使用硬件地址，那就会带来更多的麻烦。</p> <p>根据以上所述，可归纳出<strong>分组转发算法</strong>如下：</p> <ol> <li>从数据报的首部提取目的主机的 IP 地址 D，得出目的网络地址为 N。</li> <li>若 N 就是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行（3）。</li> <li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。</li> <li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）。</li> <li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）。</li> <li>报告转发分组出错。</li> </ol> <p>这里我们要再强调一下，路由表并没有给分组指明到某个网络的完整路径（即先经过哪一个路由器，然后再经过哪一个路由器，等等）。路由表指出，到某个网络应当先到某个路由器（即下一跳路由器），在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</p> <h2 id="三-划分子网和构造超网">三、 划分子网和构造超网</h2> <p>4。3。1 划分子网 1。 从两级 IP 地址到三级 IP 地址 在今天看来，在ARPANET 的早期，IP 地址的设计确实不够合理。 第一，IP 地址空间的利用率有时很低。 每一个 A 类地址网络可连接的主机数超过1000万，而每一个B类地址网络可连接的主 机数也超过 6 万。有的单位申请到了一个 B 类地址网络，但所连接的主机数并不多，可是 又不愿意申请一个足够使用的 C 类地址，理由是考虑到今后可能的发展。IP 地址的浪费， 还会使 IP 地址空间的资源过早地被用完。 第二，给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 每一个路由器都应当能够从路由表查出应怎样到达其他网络的下一跳路由器。因此， 互联网中的网络数越多，路由器的路由表的项目数也就越多。这样，即使我们拥有足够多的 IP 地址资源可以给每一个物理网络分配一个网络号，也会导致路由器的路由表中的项目数 过多。这不仅增加了路由器的成本（需要更多的存储空间），而且使查找路由时耗费更多的 时间，同时也使路由器之间定期交换的路由信息急剧增加，因而使路由器和整个互联网的性 能都下降了。 第三，两级IP地址不够灵活。 有时情况紧急，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个 新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法， 使一个单位能随时灵活地增加本单位的网络，而不必事先到互联网管理机构去申请新的网络 号。原来的两级IP地址无法做到这一点。 为解决上述问题，从1985年起在IP 地址中又增加了一个“子网号字段”，使两级 IP 地 址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫 做划分子网（subnetting） [RFC 950]，或子网寻址或子网路由选择。划分子网已成为互联网的 正式标准协议。 划分子网的基本思路如下： （1） 一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网（subnet）。划 分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成， 因为这个单位对外仍然表现为一个网络。 • 135 •</p> <p>Page 146 （2） 划分子网的方法是从网络的主机号借用若干位作为子网号（subnet-id），当然主机号 也就相应减少了同样的位数。于是两级 IP 地址在本单位内部就变为三级 IP 地址：网络号、 子网号和主机号。也可以用以下记法来表示： IP 地址 ：：= = { <网络号>，<子网号>，<主机号>} （4-2） （3） 凡是从其他网络发送给本单位某台主机的IP数据报，仍然是根据IP数据报的目的 网络号找到连接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按目的网络 号和子网号找到目的子网，把IP数据报交付目的主机。 下面用例子说明划分子网的概念。图4-18 表示某单位拥有一个B类IP地址，网络地址 是145。13。0。0（网络号是145。13）。凡目的地址为145。13。x。x的数据报都被送到这个网络上的 路由器 Rı。 R2 R3 我的网络地址 是145。13。0。0 145。13。3。11 145。13。3。101 145。13。3。10 145。13。7。34 145。13。7。35 所有到网络145。13。0。0 的分组均到达此路由器 145。13。21。23 网络 145。13。0。0 145。13。21。9 145。13。21。8 145。13。7。56 图4-18 一个B类网络145。13。0。0 现把图 4-18 的网络划分为三个子网（图4-19）。这里假定子网号占用8位，因此在增加 了子网号后，主机号就只有 8 位。所划分的三个子网分别是：145。13。3。0，145。13。7。0 和 145。13。21。0 。在划分子网后，整个网络对外部仍表现为一个网络，其网络地址仍为 145。13。0。0。但网络 145。13。0。0 上的路由器 Rı 在收到外来的数据报后，再根据数据报的目的 地址把它转发到相应的子网。 145。13。3。101 所有到达网络145。13。0。0 的分组均到达此路由器 145。13。3。11 145。13。3。10 145。13。7。34 145。13。7。35 R2 R3 子网 145。13。3。0 子网 ： 145。13。7。0 子网 145。13。21。0 R₁ 145。13。7。56 145。13。21。23 145。13。21。8 145。13。21。9 网络 145。13。0。0 图4-19 把图4-18的网络145。13。0。0划分为三个子网，但对外仍是一个网络 • 136 •</主机号></子网号></网络号></p> <p>Page 147 总之，当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。 划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。 2。 子网掩码 现在剩下的问题就是：假定有一个数据报（其目的地址是 145。13。3。10）已经到达了路 由器 Rı。那么这个路由器如何把它转发到子网 145。13。3。0 呢？ 我们知道，从 IP数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子 网的划分。这是因为32位的IP地址本身以及数据报的首部都没有包含任何有关子网划分的 信息。因此必须另外想办法，这就是使用子网掩码（subnet mask）（见图4-20）。 （a）两级IP地址 145 13 3 10 。 （b） 的子网掩码 两级IP地址 11111 00000000 00000000 两级 IP 地址的网络号 11 子网号 41 主机号 （c）三级IP地址 145 13 3。 10 子网号为3的网络的网络号 主机号 （d） 三级IP地址 的子网掩码 11111111 11111111 111111 00000000 子网的 网络地址 145 13 3 0 图 4-20 IP 地址的各字段和子网掩码（以145。13。3。30为例） 图 4-20（a）是 IP 地址为 145。13。3。10 的主机本来的两级 IP 地址结构。图4-20（b）是这个两 级 IP 地址的子网掩码。图4-20（c）是同一地址的三级IP地址结构，也就是说，现在从原来 16 位的主机号中拿出8位作为子网号，而主机号由16位减少到8位。请注意，现在子网号 为 3 的网络的网络地址是145。13。3。0（既不是原来两级IP地址的网络地址 145。13。0。0，也不 是简单的子网号 3）。为了使路由器R，能够很方便地从数据报中的目的 IP 地址中提取出所 要找的子网的网络地址，路由器R，就要使用三级 IP 地址的子网掩码。图4-20（d）是三级 IP 地址的子网掩码，它也是32位，由一串 24 个1和跟随的一串8个0组成。子网掩码中的1 对应于 IP 地址中原来二级地址中的16位网络号加上新增加的8位子网号，而子网掩码中的 0 对应于现在的 8 位主机号。虽然 RFC 文档中没有规定子网掩码中的一串 1 必须是连续 的，但却极力推荐在子网掩码中选用连续的1，以免出现可能发生的差错。 图 4-20（e）表示 Rı 把三级IP地址的子网掩码和收到的数据报的目的IP地址 145。13。3。10 逐位相“与”（AND） （计算机进行这种逻辑 AND 运算是很容易的），得出了所要找的子网的 网络地址 145。13。3。0。 使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和IP 地址进行 逐位的“与”运算（AND），就立即得出网络地址来。这样在路由器处理到来的分组时就可采 用同样的算法。 归纳一下上述的要点。从网络145。13。0。0 外面看，这就是一个普通的B类网络，其子网 掩码为 16 个连 1 后面跟上 16 个连0。但进入到这个网络后（即到了路由器 Rı），就看到了 还有许多网络（即划分了子网后的许多网络），其网络地址是145。13。x。0（这里x可以表示不 同的数值），而这些网络的子网掩码都是24个连1后面跟上8个连0。总之，在这个 B 类网 • 137⚫</p> <p>Page 148 络的外面和里面，看到的网络是不一样的。 这里还要弄清一个问题，这就是：在不划分子网时，既然没有子网，为什么还要使用 子网掩码？这就是为了更便于查找路由表。现在互联网的标准规定：所有的网络都必须使用 子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网， 那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中的位置和IP地址中的网络 号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的IP 地址逐位相 “与”（AND），就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类 别位就能知道这是哪一类的IP 地址。显然， A类地址的默认子网掩码是255。0。0。0，或 0xFF000000。 B类地址的默认子网掩码是255。255。0。0，或0xFFFF0000。 C类地址的默认子网掩码是255。255。255。0，或 0xFFFFFF00。 图 4-21 是这三类IP地址的网络地址和相应的默认子网掩码。 网络地址 网络号 主机号为全 0 默认子网掩码 255。0。0。0 11111111 000000000000000000000000 网络地址 网络号 主机号为全 0 默认子网掩码 111 0000000000000000 255。255。0。0 网络地址 网络号 主机号为全 01 默认子网掩码 1 11111 00000000 255。255。255。0 A类地址 B类地址 C类地址 图4-21A类、B类和C类IP地址的默认子网掩码 子网掩码是一个网络或一个子网的重要属性。在 RFC 950 成为互联网的正式标准后， 路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻 路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该 网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。 我们以一个 B 类地址为例，说明可以有多少种子网划分的方法。在采用固定长度子网 时，所划分的所有子网的子网掩码都是相同的（见表4-6）。 表4-6B类地址的子网划分选择（使用固定长度子网） 子网号的位数 子网掩码 子网数 每个子网的主机数 2 255。255。192。0 2 16382 3 255。255。224。0 6 8190 4 255。255。240。0 14 4094 5 255。255。248。0 30 2046 6 255。255。252。0 62 1022 7 255。255。254。0 126 510 8 255。255。255。0 254 254 9 255。255。255。128 510 126 10 255。255。255。192 1022 62 • 138 •</p> <p>Page 149 续表 子网号的位数 子网掩码 子网数 每个子网的主机数 11 255。255。255。224 2046 30 12 255。255。255。240 4094 14 13 255。255。255。248 8190 6 14 255。255。255。252 16382 2 在表 4-6 中，子网数是根据子网号（subnet-id）计算出来的。若 subnet-id 有 n 位，则共有 2”种可能的排列。除去全0和全1这两种情况，就得出表中的子网数。 表中的“子网号的位数”中没有 0， 1，15和16这四种情况，因为这没有意义。 请读者注意，虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或 全 0，但随着无分类域间路由选择 CIDR 的广泛使用（在4。3。3节讨论），现在全1和全0的 子网号也可以使用了，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持 全0或全1的子网号这种较新的用法。 我们可以看出，若使用较少位数的子网号，则每一个子网上可连接的主机数就较多。 反之，若使用较多位数的子网号，则子网的数目较多但每个子网上可连接的主机数就较少。 因此我们可根据网络的具体情况（一共需要划分多少个子网，每个子网中最多有多少台主 机）来选择合适的子网掩码。 通过简单的计算，读者不难得到这样的结论：划分子网增加了灵活性，但却减少了能 够连接在网络上的主机总数。例如，本来一个B类地址最多可连接 65534台主机，但表 4-6 中任意一行的最后两项的乘积一定小于65534。 对A类和C类地址的子网划分也可得出类似的表格，读者可自行算出。 【例4-2】已知 IP 地址是 141。14。72。24，子网掩码是255。255。192。0。试求网络地址。 【解】 子网掩码是 11111111 11111111 11000000 00000000。请注意，掩码的前两个字节 都是全 1，因此网络地址的前两个字节可写为141。14。子网掩码的第四字节是全 0，因此网 络地址的第四字节是0。可见本题仅需对地址中的第三字节进行计算。我们只要把 IP 地址 和子网掩码的第三字节用二进制表示，就可以很容易地得出网络地址（图4-22）。 （a）点分十进制表示的IP 地址 141 14 72 24 （b）IP地址的第3字节是二进制 141 14 。01001000。 24 （c）子网掩码是255。255。192。0 1111111 1111 1100 0000 00000000 （d） IP 地址与子网掩码逐位相与 141 14 。01000000。 0 （e）网络地址（点分十进制表示） 141 14 64 0 图4-22 网络地址的计算 请注意，在一个IP地址中不允许把十进制和二进制混合使用。图4-22中（b）和（d）的写 法，仅仅为了说明解题的步骤，而并非表示平时可以这样书写IP地址。 【例4-3】在上例中，若子网掩码改为255。255。224。0。试求网络地址，并讨论所得结果。 • 139。</p> <p>Page 150 【解】 用同样方法可得出网络地址是141。14。64。0，和上例的结果相同（图4-23）。 （a）点分十进制表示的IP地址 （b） IP 地址的第 3字节是二进制 （c）子网掩码是255。255。224。0 141 14 72 • • 141 14 24 。01001000。 24 1111111111111111 11100000 00000000 （d） IP地址与子网掩码逐位相与 141 14 。01000000。 0 （e） 网络地址（点分十进制表示） 141 14 64 0 图 4-23 不同的子网掩码得出相同的网络地址 这个例子说明，同样的IP 地址和不同的子网掩码可以得出相同的网络地址。但是，不 同的掩码的效果是不同的。在例4-2中，子网号是2位，主机号是14位。在例 4-3 中，子 网号是 3 位，主机号是13位。因此这两个例子中可划分的子网数和每一个子网中的最大主 机数都是不一样的。 下面进一步讨论使用了子网掩码后应怎样查找路由表。 4。3。2 使用子网时分组的转发 在划分子网的情况下，分组转发的算法必须做相应的改动。 我们应当注意到，使用子网划分后，路由表必须包含以下三项内容：目的网络地址、 子网掩码和下一跳地址。 在划分子网的情况下，路由器转发分组的算法如下： （1） 从收到的数据报的首部提取目的 IP 地址 D。 （2） 先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网 掩码和 D 逐位相“与”（AND 操作），看结果是否和相应的网络地址匹配。若匹配，则把分 组进行直接交付（当然还需要把D转换成物理地址，把数据报封装成帧发送出去），转发任 务结束。否则就是间接交付，执行（3）。 （3） 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的 下一跳路由器；否则，执行（4）。 （4）对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩 码和 D 逐位相“与”（AND 操作），其结果为N。若N与该行的目的网络地址匹配，则把数 据报传送给该行指明的下一跳路由器；否则，执行（5）。 （5） 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否 则，执行（6）。 （6）报告转发分组出错。 【例 4-4】图 4-24 有三个子网，两个路由器，以及路由器 R中的部分路由表。现在 源主机 Hı 向目的主机 Hz 发送分组。试讨论 Rı 收到 Hı 向 Hz 发送的分组后查找路由表的 过程。 • 140 •</p> <p>Page 151 128。30。33。13 源主机 H 子网1：网络地址128。30。33。0 子网掩码 255。255。255。128 128。30。33。1 0 R₁ 128。30。33。130 R的部分路由表（未给出默认路由器） 目的网络地址 128。30。33。0 128。30。33。128 128。30。36。0 子网掩码 255。255。255。128 下一跳 接口0 255。255。255。128 接口1 R₂ 255。255。255。0 子网2：网络地址 128。30。33。128 子网掩码 255。255。255。128 0 128。30。33。129 128。30。33。138 R2 1 128。30。36。2 目的主机 H2 H3 128。30。36。12 子网3：网络地址 128。30。36。0 子网掩码 255。255。255。0 图4-24 主机H 向 Hz 发送分组 【解】源主机 H 向目的主机 Hz 发送的分组的目的地址是Hz 的IP地址 128。30。33。138。 源主机 H」首先要进行的操作是要判断：发送的这个分组，是在本子网上进行直接交付 还是要通过本子网上的路由器进行间接交付？ 源主机 Hı 把本子网的“子网掩码 255。255。255。128”与目的主机 H2 的“IP 地址 128。30。33。138”逐位相“与”（即逐位进行 AND 操作），得出 128。30。33。128，它不等于 H 的 网络地址（128。30。33。0）。这说明 Hz 与 H 不在同一个子网上。因此 H， 不能把分组直接交付 Hz，而必须交给子网上的默认路由器 Rı，由Rı 来转发。 路由器 Rı 在收到一个分组后，就在其路由表中逐行寻找有无匹配的网络地址。 先看 Rı 路由表中的第一行。用这一行的“子网掩码 255。255。255。128”和收到的分组的 “目的地址 128。30。33。138”逐位相“与”（即逐位进行 AND 操作），得出 128。30。33。128。然 后和这一行给出的目的网络地址 128。30。33。0 进行比较。但比较的结果不一致（即不匹配）。 用同样方法继续往下找第二行。用第二行的“子网掩码 255。255。255。128”和该分组的 “目的地址 128。30。33。138”逐位相“与”（即逐位进行 AND 操作），结果也是 128。30。33。128。这个结果和第二行的目的网络地址 128。30。33。128 相匹配，说明这个网络（子 网 2） 就是收到的分组所要寻找的目的网络。于是不需要再继续查找下去。R，把分组从接口 1直接交付主机Hz（它们都在一个子网上）。 4。3。3 无分类编址CIDR（构造超网） 1。网络前缀 划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然 面临三个必须尽早解决的问题，这就是： （1） B 类地址在1992年已分配了近一半，眼看很快就将全部分配完毕! （2） 互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。 （3） 整个 IPv4 的地址空间最终将全部耗尽。在2011 年 2 月 3 日，IANA 宣布 IPv4 地址 已经耗尽了。 当时预计前两个问题将在 1994 年变得非常严重。因此 IETF 很快就研究出采用无分类 • 141 •</p> <p>Page 152 编址的方法来解决前两个问题。IETF 认为上面的第三个问题属于更加长远的问题，因此专 门成立 IPv6 工作组负责研究解决新版本IP协议的问题。 其实早在 1987 年，RFC1009 就指明了在一个划分子网的网络中可同时使用几个不同的 子网掩码。使用变长子网掩码 VLSM （Variable Length Subnet Mask）可进一步提高 IP 地址资 源的利用率。在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是无分类 域间路由选择 CIDR （Classless Inter-Domain Routing，CIDR 的读音是“sider”）。 CIDR 最主要的特点有两个： （1） CIDR 消除了传统的A类、B类和C类地址以及划分子网的概念，因而能更加有效 地分配 IPv4 的地址空间，并且在新的IPv6使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是“网络前缀”（network-prefix）（或简称为 “前缀”），用来指明网络，后面部分则用来指明主机。因此 CIDR 使 IP 地址从三级编址 （使用子网掩码）又回到了两级编址，但这已是无分类的两级编址。其记法是： IP 地址 ：：= {<网络前缀>，<主机号>} （4-3） CIDR 还使用“斜线记法”（slash notation），或称为CIDR 记法，即在 IP 地址后面加上 斜线“/”，然后写上网络前缀所占的位数。 （2） CIDR 把网络前缀都相同的连续的IP地址组成一个“CIDR 地址块”。我们只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大 地址，以及地址块中的地址数。例如，已知 IP地址 128。14。35。7/20 是某 CIDR 地址块中的一 个地址，现在把它写成二进制表示，其中的前20位是网络前缀（用粗体和下划线表示出）， 而前缀后面的 12 位是主机号： 128。14。35。7/20 = 10000000 00001110 00100011 00000111 这个地址所在的地址块中的最小地址和最大地址可以很方便地得出： 最小地址 最大地址 128。14。32。0 128。14。47。255 10000000 00001110 00100000 00000000 10000000 00001110 00101111 11111111 当然，以上这两个特殊地址的主机是全和全 1 的地址。一般并不使用。通常只使 用在这两个特殊地址之间的地址。不难看出，这个地址块共有22个地址。我们可以用地址 块中的最小地址和网络前缀的位数指明这个地址块。例如，上面的地址块可记为 128。14。32。0/20。在不需要指出地址块的起始地址时，也可把这样的地址块简称为“/20 地址 块”。 为了更方便地进行路由选择，CIDR 使用 32 位的地址掩码（address mask）。地址掩码由 一串1和一串0组成，而1的个数就是网络前缀的长度。虽然CIDR 不使用子网了，但由于 目前仍有一些网络还使用子网划分和子网掩码，因此CIDR 使用的地址掩码也可继续称为子 网掩码。例如，/20 地址块的地址掩码是：11111111 11111111 11110000 00000000（20 个连续 的 1）。斜线记法中，斜线后面的数字就是地址掩码中1的个数。 请读者注意，“CIDR 不使用子网”是指 CIDR 并没有在32 位地址中指明若干位作为子 网字段。但分配到一个 CIDR 地址块的单位，仍然可以在本单位内根据需要划分出一些子 网。这些子网也都只有一个网络前缀和一台主机号字段，但子网的网络前缀比整个单位的网 • 142</主机号></网络前缀></p> <p>Page 153 络前缀要长些。例如，某单位分配到地址块/20，就可以再继续划分为8个子网（即需要从 主机号中借用3位来划分子网）。这时每一个子网的网络前缀就变成23位（原来的 20 位加 上从主机号借来的3位），比该单位的网络前缀多了3位。 斜线记法还有一个好处就是它除了表示一个 IP 地址外，还提供了其他一些重要信息。 我们举例说明如下。 例如，地址 192。199。170。82/27 不仅表示IP 地址是192。199。170。82，而且还表示这个地址 块的网络的前缀有 27 位（剩下的5位是主机号），因此这个地址块包含 32 个 IP 地址（2 32）。通过简单的计算还可得出，这个地址块的最小地址是192。199。170。64，最大地址是 192。199。170。95。具体的计算方法是这样的。找出地址掩码中1和0的交界处发生在地址中 的哪一个字节。现在是在第四个字节。因此只要把这一个字节的十进制 82 用二进制表示即 可。十进制 82 的二进制是01010010，取其前3位（这3 位加上前3个字节的 24 位等于前 缀的 27 位），再把后面5位都写成0，即 01000000，等于十进制的64。这就找出了地址块 的最小地址 192。199。170。64。再把地址的第四字节的最后 5 位都置 1，即 01011111，等于十 进制的95，这就找出了地址块中的最大地址192。199。170。95。 由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用CIDR 地址块来查找目的 网络。这种地址的聚合常称为路由聚合（route aggregation），它使得路由表中的一个项目可以 表示原来传统分类地址的很多个（例如上千个）路由。路由聚合也称为构成超网 （supernetting）。如果没有采用 CIDR，则在 1994 年 1995 年，互联网的一个路由表就会超 过7万个项目，而使用了 CIDR 后，在 1996 年一个路由表的项目数才只有3万多个。路由 聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 CIDR 记法有多种形式，例如，地址块 10。0。0。0/10 可简写为10/10，也就是把点分十进 制中低位连续的0省略。另一种简化表示方法是在网络前缀的后面加一个星号<em>，如： 00001010 00</em> 意思是：在星号<em>之前是网络前缀，而星号</em>表示IP地址中的主机号，可以是任意 值。 前缀位数不是8的整数倍时，需要进行简单的计算才能得到一些地址信息。 表 4-7 给出了最常用的CIDR 地址块。表中的K表示210即1024。网络前缀小于 13 或 大于27 都较少使用。在“包含的地址数”中没有把全1和全的主机号除外。 表4-7 常用的CIDR 地址块 CIDR 前缀长度 点分十进制 包含的地址数 /13 255。248。0。0 512 K /14 255。252。0。0 256K /15 255。254。0。0 128 K /16 255。255。0。0 64 K /17 255。255。128。0 32 K /18 255。255。192。0 16K /19 255。255。224。0 8K 相当于包含分类的网络数 8个B类或2048个C类 4个B类或1024个C类 2 个B类或512个C类 1个B类或256个C类 128 个C类 64个C类 32 个C类 /20 255。255。240。0 4K 16个C类 • 143 •</p> <p>Page 154 续表 CIDR 前缀长度 点分十进制 包含的地址数 相当于包含分类的网络数 /21 255。255。248。0 2K 8个C类 122 255。255。252。0 1K 4个C类 123 255。255。254。0 512 2个C类 /24 255。255。255。0 256 1个C类 125 255。255。255。128 128 1/2个C类 126 255。255。255。192 64 1/4个C类 127 255。255。255。224 32 1/8个C类 从表 4-7 可看出，每一个 CIDR 地址块中的地址数一定是2的整数次幂。除最后几行 外，CIDR 地址块都包含了多个C类地址（是一个C类地址的2倍，n是整数），这就是 “构成超网”这一名词的来源。 使用 CIDR 的一个好处就是可以更加有效地分配IPv4 的地址空间，可根据客户的需要 分配适当大小的 CIDR 地址块。然而在分类地址的环境中，向一个部门分配 IP 地址，就只 能以/8，/16 或/24为单位来分配。这就很不灵活。 图 4-25 给出的是 CIDR 地址块分配的例子。假定某ISP已拥有地址块206。0。64。0/18（相 当于有 64 个 C 类网络）。现在某大学需要 800 个 IP 地址。ISP 可以给该大学分配一个地址 块 206。0。68。0/22，它包括1024（即2’0） 个 IP 地址，相当于 4 个连续的 C类/24 地址块，占 该 ISP 拥有的地址空间的1/16。这个大学然后可自由地对本校的各系分配地址块，而各系还 可再划分本系的地址块。CIDR 的地址块分配有时不易看清，这是因为网络前缀和主机号的 界限不是恰好出现在整数字节处。只要写出地址的二进制表示（从图中的地址块的二进制表 示中可看出，实际上只需要将其中的一个关键字节转换为二进制的表示即可），弄清网络前 缀的位数，就不会把地址块的范围弄错。 • 144 • ISP 大学 206。0。64。0/18 互联网 206。0。68。0/22 206。0。68。0/23 206。0。70。0/24 206。0。71。0/25 206。0。71。128/25 206。0。68。0/25 206。0。70。0/26 206。0。71。0/26 206。0。68。128/25 206。0。70。64/26 206。0。71。64/26 206。0。71。128/26 206。0。71。192/26 206。0。69。0/25 206。0。70。128/26 206。0。69。128/25 206。0。70。192/26 三系 四系 一系 单位 地址块 ISP | 206。0。64。0/18 大学 206。0。68。0/22 一系 | 206。0。68。0/23 二系 | 206。0。70。0/24 三系 | 206。0。71。0/25 二系 二进制表示 地址数 11001110。00000000。01* 16384 11001110。00000000。010001* 1024 11001110。00000000。0100010* 512 11001110。00000000。01000110。* 256 11001110。00000000。01000111。0* 128 206。0。71。128/25 11001110。00000000。01000111。1* 128 图4-25 CIDR地址块划分举例</p> <p>Page 155 从图 4-25 可以清楚地看出地址聚合的概念。这个ISP共拥有64个C类网络。如果不采 用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，就只需用路由聚合后的一个项目 206。0。64。0/18 就能找到该 ISP。同理，这个大学共有4个系。在ISP内的路由器的路由表中，也需使用 206。0。68。0/22 这个项目。这个项目好比是大学的收发室。凡寄给这个大学任何一个系的邮件，邮递员都不 考虑大学各个系的地址，而是把这些邮件集中投递到大学的收发室，然后由大学的收发室再 进行下一步的投递。这样就减轻了邮递员的工作量（相当于简化了路由表的查找）。 从图 4-25 下面表格中的二进制地址可看出，把四个系的路由聚合为大学的一个路由 （即构成超网），是将网络前缀缩短。网络前缀越短，其地址块所包含的地址数就越多。而 在三级结构的IP地址中，划分子网是使网络前缀变长。 2。最长前缀匹配 在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个 部分组成，因此在路由表中的项目也要有相应的改变。这时，每个项目由“网络前缀”和 “下一跳地址”组成。但是在查找路由表时可能会得到不止一个匹配结果。这样就带来一个 问题：我们应当从这些匹配结果中选择哪一条路由呢？ 正确的答案是：应当从匹配结果中选择具有最长网络前缀的路由。这叫做最长前缀匹 配（longest-prefix matching），这是因为网络前缀越长，其地址块就越小，因而路由就越具体 （more specific）。最长前缀匹配又称为最长匹配或最佳匹配。为了说明最长前缀匹配的概 念，我们仍以前面的例子来讨论。 假定大学下属的四系希望 ISP 把转发给四系的数据报直接发到四系而不要经过大学的路 由器，但又不愿意改变自己使用的 IP 地址块。因此，在 ISP 的路由器的路由表中，至少要 有以下两个项目，即206。0。68。0/22（大学）和206。0。71。128/25（四系）。现在假定 ISP 收到一 个数据报，其目的 IP 地址为D=206。0。71。130。把D分别和路由表中这两个项目的掩码逐位 相“与”（AND操作）。将所得的逐位 AND 操作的结果按顺序写在下面。 D 和 11111111 11111111 1111110000000000 逐位相“与”=206。0。68。0/22 匹配 D 和 11111111 11111111 11111111 10000000 逐位相“与”=206。0。71。128/25 匹配 不难看出，现在同一个 IP 地址 D 可以在路由表中找到两个目的网络（大学和四系）和 该地址相匹配。根据最长前缀匹配的原理，应当选择后者，把收到的数据报转发到后一个目 的网络（四系），即选择两个匹配的地址中更具体的一个。 从以上的讨论可以看出，如果IP 地址的分配一开始就采用 CIDR，那么我们可以按网 络所在的地理位置来分配地址块，这样就可大大减少路由表中的路由项目。例如，可以将世 界划分为四大地区，每一地区分配一个 CIDR 地址块： 地址块 194/7 （194。0。0。0至195。255。255。255）分配给欧洲； 地址块 198/7（198。0。0。0至199。255。255。255）分配给北美洲； 地址块 200/7 （200。0。0。0至201。255。255。255）分配给中美洲和南美洲； 地址块 202/7 （202。0。0。0至203。255。255。255）分配给亚洲和太平洋地区。 上面的每一个地址块包含有约3200 万个地址。这种分配地址的方法就使得IP地址与地 理位置相关联。它的好处是可以大大压缩路由表中的项目数。例如，凡是从中国发往北美的 • 145 •</p> <p>Page 156 IP数据报（不管它是地址块198/7中的哪一个地址）都先送交位于美国的一个路由器，因此 在路由表中使用一个项目就行了。 但是，在使用 CIDR 之前，互联网的地址管理机构没有按地理位置来分配 IP 地址。现 在要把已分配出的IP 地址收回再重新分配是件十分困难的事，因为这牵涉到很多正在工作 的主机必须改变其 IP 地址。尽管这样，CIDR 的使用已经推迟了 IP 地址耗尽的日期。 3。使用二叉线索查找路由表 使用 CIDR 后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。当路 由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。例如， 连接路由器的线路的速率为10Gbit/s，而分组的平均长度为2000 bit，那么路由器就应当平均 每秒钟能够处理 500万个分组（常记为5Mpps）。或者说，路由器处理一个分组的平均时间只 有200 ns （1 ns = 10-秒）。因此，查找每一个路由所需的时间是非常短的。可见在路由表中 必须使用很好的数据结构和使用先进的快速查找算法，这一直是人们积极研究的热门课题。 对无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。例 如，给定一个目的地址 D。对每一个可能的网络前缀长度M，路由器从 D 中提取前 M 个位成 一个网络前缀，然后查找路由表中的网络前缀。所找到的最长匹配就对应于要查找的路由。 这种最简单的算法的明显缺点就是查找的次数太多。最坏的情况是路由表中没有这个 路由。在这种情况下，算法仍要进行32次（具有32位的网络前缀是一个特定主机路由）。 就是要找到一个传统的 B 类地址（即/16），也要查找 16次。对于经常使用的默认路由，这 种算法都要经历31次不必要的查找。 为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构 中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索（binary trie），它是一种 特殊结构的树。IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二 叉线索中的各个路径就代表路由表中存放的各个地址。 图 4-26 用一个例子来说明二叉线索的结构。图中给出了 5 个 IP 地址。为了简化二叉线 索的结构，可以先找出对应于每一个 IP 地址的唯一前缀（unique prefix）。所谓唯一前缀就是 在表中所有的 IP 地址中，该前缀是唯一的。这样就可以用这些唯一前缀来构造二叉线索。 在进行查找时，只要能够和唯一前缀相匹配就行了。 32位的IP地址 01000110 00000000 00000000 00000000 01010110 00000000 00000000 00000000 0 唯一前缀 0100 0101 01100001 00000000 00000000 00000000 10110000 00000010 00000000 00000000 011 10110 10111011 00001010 00000000 00000000 10111 1 图4-26 用5个前缀构成的二叉线索 ① 注：线索（trie）来自retrieval（检索），读音与“try”相同。 • 146 •</p> <p>Page 157 从二叉线索的根节点自顶向下的深度最多有32层，每一层对应于IP地址中的一位。 个 IP 地址存入二叉线索的规则很简单。先检查IP地址左边的第一位，如为0，则第一层的 节点就在根节点的左下方；如为 1，则在右下方。然后再检查地址的第二位，构造出第二层 的节点。依此类推，直到唯一前缀的最后一位。由于唯一前缀一般都小于32 位，因此用唯 一前缀构造的二叉线索的深度往往不到 32 层。图中较粗的折线就是前缀 0101 在这个二叉线 索中的路径。二叉线索中的小圆圈是中间节点，而在路径终点的小方框是叶节点（也叫做外 部节点）。每个叶节点代表一个唯一前缀。节点之间的连线旁边的数字表示这条边在唯一前 缀中对应的比特是0或1。 假定有一个 IP 地址是 10011011 01111010 00000000 00000000，需要查找该地址是否在 此二叉线索中。我们从最左边查起。很容易发现，查到第三个字符（即前缀 10 后面的 0） 时，在二叉线索中就找不到匹配的，说明这个地址不在这个二叉线索中。 以上只是给出了二叉线索这种数据结构的用法，而并没有说明“与唯一前缀匹配”和 “与网络前缀匹配”的关系。显然，要将二叉线索用于路由表中，还必须使二叉线索中的每 一个叶节点包含所对应的网络前缀和子网掩码。当搜索到一个叶节点时，就必须将寻找匹配 的目的地址和该叶节点的子网掩码进行逐位“与”运算，看结果是否与对应的网络前缀相匹 配。若匹配，就按下一跳的接口转发该分组。否则，就丢弃该分组。 总之，二叉线索只是提供了一种可以快速在路由表中找到匹配的叶节点的机制。但这 是否和网络前缀匹配，还要和子网掩码进行一次逻辑与的运算。 为了提高二叉线索的查找速度，广泛使用了各种压缩技术。例如，在图 4-26 中的最后 两个地址，其最前面的4位都是1011。因此，只要一个地址的前4位是1011，就可以跳过 前面4位（即压缩了4个层次）而直接从第5位开始比较。这样就可以减少查找的时间。当 然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由表时都可以提高查找 速度，因此这样做还是值得的。</p> <h2 id="四网际控制报文协议-icmp">四、网际控制报文协议 ICMP</h2> <p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协 议 ICMP （Internet Control Message Protocol） [RFC 792]。ICMP 允许主机或路由器报告差错情 况和提供有关异常情况的报告。ICMP 是互联网的标准协议。但ICMP 不是高层协议（看起 来好像是高层协议，因为ICMP报文是装在IP数据报中，作为其中的数据部分），而是IP 层的协议。ICMP报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出 去。ICMP 报文格式如图4-27所示。 位 O 8 16 31 前4个字节 是统一的格式 类型 代码 检验和 （这4个字节取决于ICMP报文的类型） ICMP 的数据部分（长度取决于类型） 首部 ICMP报文 数据部分 ·IP数据报 图4-27 ICMP 报文的格式 • 147 •</p> <p>Page 158 4。4。1 ICMP报文的种类 ICMP 报文的种类有两种，即ICMP差错报告报文和 ICMP 询问报文。 ICMP 报文的前4个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4个字节的内容与ICMP的类型有关。最后面是数据字段，其长度取决于ICMP的类型。表 4-8 给出了几种常用的ICMP报文类型。 表4-8 几种常用的ICMP报文类型 ICMP 报文种类 类型的值 ICMP 报文的类型 3 终点不可达 11 时间超过 差错报告报文 12 参数问题 5 改变路由（Redirect） 8或0 回送（Echo）请求或回答 询问报文 13 或 14 时间戳（Timestamp）请求或回答 ICMP 标准在不断更新。已不再使用的ICMP报文有：“信息请求与回答报文”、“地址 掩码请求与回答报文”、“路由器请求与通告报文”以及“源点抑制报文”[RFC 6633]。现在 不再把这几种报文列入。 ICMP 报文的代码字段是为了进一步区分某种类型中的几种不同情况。检验和字段用来 检验整个 ICMP报文。我们应当还记得，IP数据报首部的检验和并不检验 IP 数据报的内 容，因此不能保证经过传输的ICMP报文不产生差错。 表4-8 给出的 ICMP差错报告报文共有四种，即： （1）终点不可达 （2） 时间超过 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。 当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向 源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片 时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。 （3）参数问题 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时， 就丢弃该数据报，并向源点发送参数问题报文。 （4）改变路由（重定向） 路由器把改变路由报文发送给主机，让主机知道下次应将 数据报发送给另外的路由器（可通过更好的路由）。 下面对改变路由报文进行简短的解释。我们知道，在互联网的主机中也要有一个路由 表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报 发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连 接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个 默认路由器的IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个 默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由（通过和其他路由器交换 路由信息）。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络 上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由 表中增加一个项目：到某某目的地址应经过路由器R（而不是默认路由器）。 所有的 ICMP 差错报告报文中的数据字段都具有同样的格式（图4-28）。把收到的需要 进行差错报告的IP数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数 • 148 •</p> <p>Page 159 据字段。再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。 提取收到的数据报的数据字段前8个字节是为了得到运输层的端口号（对于TCP 和 UDP） 以及运输层报文的发送序号（对于TCP）。这些信息对源点通知高层协议是有用的（端口的 作用将在下一章的 5。1。3 节中介绍）。整个ICMP报文作为IP数据报的数据字段发送给源 点。 IP 数据报的数据字段 收到的 IP 数据报 IP数据报 首部 8 字节 ICMP的 前8字节 IP数据报 首部 8 字节 ICMP差错报告报文 首部 ICMP差错报告报文 装入ICMP报文的IP数据报 ·IP数据报。 图4-28 ICMP差错报告报文的数据字段的内容 下面是不应发送 ICMP 差错报告报文的几种情况。 对 ICMP差错报告报文，不再发送 ICMP差错报告报文。 对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP差错报告报文。 对具有多播地址的数据报，都不发送ICMP差错报告报文。 • 对具有特殊地址（如127。0。0。0或0。0。0。0）的数据报，不发送ICMP差错报告报文。 常用的 ICMP 询问报文有两种，即： （1）回送请求和回答 ICMP 回送请求报文是由主机或路由器向一个特定的目的主机 发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询 问报文用来测试目的站是否可达以及了解其有关状态。 （2） 时间戳请求和回答 ICMP 时间戳请求报文是请某台主机或路由器回答当前的日 期和时间。在 ICMP 时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900 年 1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。 4。4。2 ICMP 的应用举例 ICMP 的一个重要应用就是分组网间探测 PING （Packet InterNet Groper），用来测试两台 主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使 用网络层 ICMP 的一个例子。它没有通过运输层的TCP 或UDP。 Windows 操作系统的用户可在接入互联网后转入 MS DOS（点击“开始”，点击“运 行”，再键入“cmd”）。看见屏幕上的提示符后，就键入“ping hostname”（这里的 hostname 是要测试连通性的主机名或它的IP 地址），按回车键后就可看到结果。 图 4-29 给出了从南京的一台 PC 到新浪网的邮件服务器 mail。sina。com。cn 的连通性的测 试结果。PC 一连发出四个 ICMP 回送请求报文。如果邮件服务器 mail。sina。com。cn 正常工作 而且响应这个 ICMP 回送请求报文（有的主机为了防止恶意攻击就不理睬外界发送过来的这 种报文），那么它就发回 ICMP 回送回答报文。由于往返的 ICMP 报文上都有时间戳，因此 很容易得出往返时间。最后显示出的是统计结果：发送到哪个机器（IP 地址），发送的、收 到的和丢失的分组数（但不给出分组丢失的原因），以及往返时间的最小值、最大值和平均 149。</p> <p>Page 160 值。从得到的结果可以看出，第三个测试分组丢失了。 C：\Documents and Settings\XXR&gt;piny nail。sina。com。cn Pinging nail。sina。com。cn [202。108。43。230] with 32 bytes of data： Reply from 202。108。43。230： bytes=32 time=368ms TTL=242 Reply from 202。108。43。230；bytes=32 time=324ns TTL=242 Request timed out。 Reply from 202。108。43。230： bytes 32 time-374ms TTL-242 Ping statistics for 202。108。43。230： Packets： Sent = 4。 Received = 3， Lost 1 （25% loss）。 Approximate round trip times in milli-seconds： Minimum 368ms， Maximum 374ns， Average 372ns 图4-29 用PING 测试主机的连通性 另一个非常有用的应用是 traceroute（这是 UNIX 操作系统中名字），它用来跟踪一个分 组从源点到终点的路径。在 Windows 操作系统中这个命令是 tracert。下面简单介绍这个程 序的工作原理。 Traceroute 从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的 UDP 用户数据报。第一个数据报 Pı 的生存时间 TTL 设置为 1。当 Pı 到达路径上的第一个 路由器 Rı 时，路由器R， 先收下它，接着把 TTL 的值减 1。由于 TTL 等于零了，Rı 就把 Pı 丢弃了，并向源主机发送一个 ICMP 时间超过差错报告报文。 源主机接着发送第二个数据报P2，并把 TTL 设置为2。P，先到达路由器Rı，Rı 收下后 把 TTL 减 1 再转发给路由器R2R2 收到 P2时 TTL 为1，但减1 后 TTL 变为零了。R，就丢 弃 P2，并向源主机发送一个 ICMP时间超过差错报告报文。这样一直继续下去。当最后一 个数据报刚刚到达目的主机时，数据报的TTL 是 1。主机不转发数据报，也不把 TTL 值减 1。但因 IP 数据报中封装的是无法交付的运输层的 UDP 用户数据报，因此目的主机要向源 主机发送 ICMP 终点不可达差错报告报文（见下一章的5。2。2节）。 这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的 ICMP 报文正 好给出了源主机想知道的路由信息——到达目的主机所经过的路由器的IP地址，以及到达 其中的每一个路由器的往返时间。图 4-30 是从南京的一个 PC 向新浪网的邮件服务器 mail。sina。com。cn 发出的 tracert 命令后所获得的结果。图中每一行有三个时间出现，是因为 对应于每一个 TTL 值，源主机要发送三次同样的 IP 数据报。 我们还应注意到，从原则上讲，IP 数据报经过的路由器越多，所花费的时间也会越 多。但从图 4-30 可看出，有时正好相反。这是因为互联网的拥塞程度随时都在变化，也很 难预料到。因此，完全有这样的可能：经过更多的路由器反而花费更少的时间。 ① 注：无法交付的UDP用户数据报使用了非法的端口号（见下一章 5。2。2 节）。 • 150 •</p> <p>Page 161 IC：\Documents and Settings\22R&gt;tracert nail。sina。com。cn Tracing route to nail。sina。com。co [202。188。43。2301 over maximum of 30 hops： 1 24 ms 24 ms 23 ms 222。95。172。1 2 23 ms 24 ms 22 ms 3 23 ms 22 ms 4 24 ms 23 ms 5 22 ms 23 ms 6 28 ns 28 ms ？ 50 ns 50 ms 8 308 ms 311 ms 9 387 ns 305 ms 10 164 ms 164 ms 23 ms 24 ms 24 ns 28 ms 51 ms 310 ms 385 ns 165 ms 221。231。204。129 221。231。206。9 202。97。27。37 202。97。41。226 202。97。35。25 202。97。36。86 219。158。32。1 219。158。13。17 202。96。12。154 11 322 ms 320 ms 12 321 ms 322 ms 2988 ms 320 ms 61。135。148。50 freenai143-230。sina。com [202。108。43。2301 Trace conplete。 图4-30 用tracert 命令获得到目的主机的路由信息</p> <h2 id="五互联网的路由选择协议">五、互联网的路由选择协议</h2> <p>本节将讨论几种常用的路由选择协议，也就是要讨论路由表中的路由是怎样得出的。 4。5。1 有关路由选择协议的几个基本概念 1。理想的路由算法 路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。一个 理想的路由算法应具有如下的一些特点[BELL86]： （1）算法必须是正确的和完整的。这里，“正确”的含义是：沿着各路由表所指引的路 由，分组一定能够最终到达目的网络和目的主机。 （2）算法在计算上应简单。路由选择的计算不应使网络通信量增加太多的额外开销。 （3） 算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。当网络中的通 信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路 发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自 适应性为“稳健性”（robustness）。 ⑪ （4）算法应具有稳定性。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛 于一个可以接受的解，而不应使得出的路由不停地变化。 （5）算法应是公平的。路由选择算法应对所有用户（除对少数优先级高的用户）都是平 等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就 明显地不符合公平性的要求。 （6） 算法应是最佳的。路由选择算法应当能够找出最好的路由，使得分组平均时延最小 而网络的吞吐量最大。虽然我们希望得到“最佳”的算法，但这并不总是最重要的。对于某 ① 注：Robustness 一词在自动控制界的标准译名是“鲁棒性”，但在[MINGCI94]则译为“稳健性”。 • 151 •</p> <p>Page 162 些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，所谓 “最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。 一个实际的路由选择算法，应尽可能接近于理想的算法。在不同的应用条件下，对以 上提出的六个方面也可有不同的侧重。 应当指出，路由选择是个非常复杂的问题，因为它是网络中的所有结点共同协调工作 的结果。其次，路由选择的环境往往是不断变化的，而这种变化有时无法事先知道，例如， 网络中出了某些故障。此外，当网络发生拥塞时，就特别需要有能缓解这种拥塞的路由选择 策略，但恰好在这种条件下，很难从网络中的各结点获得所需的路由选择信息。 倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两 大类，即静态路由选择策略与动态路由选择策略。静态路由选择也叫做非自适应路由选择， 其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可 以采用静态路由选择，用人工配置每一条路由。动态路由选择也叫做自适应路由选择，其特 点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由 选择适用于较复杂的大网络。 2。分层次的路由选择协议 互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。由于 以下两个原因，互联网采用分层次的路由选择协议： （1） 互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路 由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会 使互联网的通信链路饱和。 （2） 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议 （这属于本部门内部的事情），但同时还希望连接到互联网上。 为此，可以把整个互联网划分为许多较小的自治系统（autonomous system），一般都记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内 部的路由选择协议和共同的度量。一个AS对其他AS表现出的是一个单一的和一致的路由 选择策略[RFC 4271]。 在目前的互联网中，一个大的 ISP 就是一个自治系统。这样，互联网就把路由选择协议 划分为两大类，即： （1） 内部网关协议 IGP （Interior Gateway Protocol） 选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选 择协议使用得最多，如 RIP 和 OSPF 协议。 即在一个自治系统内部使用的路由 若源主机和目的主机处在不同的 （2）外部网关协议 EGP （External Gateway Protocol） 自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统 的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是 外部网关协议 EGP。目前使用最多的外部网关协议是BGP 的版本4（BGP-4）。 自治系统之间的路由选择也叫做域间路由选择（interdomain routing），而在自治系统内部 的路由选择叫做域内路由选择（intradomain routing）。 图 4-31 是两个自治系统互连在一起的示意图。每个自治系统自己决定在本自治系统内 部运行哪一个内部路由选择协议（例如，可以是 RIP，也可以是 OSPF）。但每个自治系统都 • 152 •</p> <p>Page 163 有一个或多个路由器（图中的路由器R1和R2）除运行本系统的内部路由选择协议外，还要 运行自治系统间的路由选择协议（BGP-4）。 自治系统 B 自治系统 A R₁ 用外部网关协议 （例如，BGP-4）， R， 用内部网关协议 （例如，RIP） 用内部网关协议 （例如，OSPF） 图4-31 自治系统和内部网关协议、外部网关协议 这里我们要指出两点： （1） 互联网的早期 RFC 文档中未使用“路由器”而是使用“网关”这一名词。但是在 新的 RFC 文档中又改用“路由器”这一名词，因此有的书把原来的 IGP 和 EGP 分别改为 IRP（内部路由器协议）和ERP（外部路由器协议）。为了方便读者查阅 RFC 文档，本书仍 使用 RFC 原先使用的名字IGP 和 EGP。 （2） RFC 采用的名词 IGP 和 EGP 协议类别的名称。但 RFC 在使用名词 EGP 时出现了 一点混乱，因为最早的一个外部网关协议的协议名字正好也是EGP [RFC 827]。后来发现该 RFC 提出的 EGP 有不少缺点，就设计了一种更好的外部网关协议，叫做边界网关协议 BGP （Border Gateway Protocol），用来取代旧的 RFC 827 外部网关协议 EGP。实际上，旧协议 EGP 和新协议 BGP 都属于外部网关协议 EGP 这一类别。因此在遇到名词 EGP 时，应弄清 它是指旧协议 EGP（即RFC827）还是指外部网关协议 EGP 这个类别。 总之，使用分层次的路由选择方法，可将互联网的路由选择协议划分为： 内部网关协议 IGP：具体的协议有多种，如RIP 和OSPF等。 外部网关协议 EGP：目前使用的协议就是 BGP。 对于比较大的自治系统，还可将所有的网络再进行一次划分。例如，可以构筑一个链 路速率较高的主干网和许多速率较低的区域网。每个区域网通过路由器连接到主干网。当在 一个区域内找不到目的站时，就通过路由器经过主干网到达另一个区域网，或者通过外部路 由器到别的自治系统中去查找。下面对这两类协议分别进行介绍。 4。5。2 内部网关协议 RIP 1。工作原理 RIP （Routing Information Protocol）是内部网关协议IGP 中最先得到广泛使用的协议[RFC 1058]，它的中文名称叫做路由信息协议，但很少被使用。RIP 是一种分布式的基于距离向 量的路由选择协议，是互联网的标准协议，其最大优点就是简单。 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记 录（因此，这是一组距离，即“距离向量”）。RIP 协议将“距离”定义如下： 从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离 定义为所经过的路由器数加1。“加1”是因为到达目的网络后就进行直接交付，而到直接连 接的网络的距离已经定义为 1。例如在前面讲过的图 4-16 中，路由器R， 到网或网 2 的距 • 153 •</p> <p>Page 164 离都是1（直接连接），而到网3的距离是2，到网4的距离是3。 RIP 协议的“距离”也称为“跳数”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多 只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型 互联网。 需要注意的是，到直接连接的网络的距离也可定义为0（采用这种定义的理由是：路由 器在和直接连接在该网络上的主机通信时，不需要经过另外的路由器。既然每经过一个路由 器要将距离加 1，那么不再经过路由器的距离就应当为0）。作者编写的其他版本的教材过去 也曾使用过这种定义。但两种不同的定义对实现 RIP 协议并无影响，因为重要的是要找出 最短距离，将所有的距离都加1或都减1，对选择最佳路由其实是一样的。 RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由（即 最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。 本节讨论的 RIP 协议和下一节要讨论的OSPF协议，都是分布式路由选择协议。它们的 共同特点就是每一个路由器都要不断地和其他一些路由器交换路由信息。我们一定要弄清以 下三个要点，即和哪些路由器交换信息？交换什么信息？在什么时候交换信息？ RIP 协议的特点是： （1）仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器， 那么这两个路由器就是相邻的。RIP协议规定，不相邻的路由器不交换信息。 （2） 路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。也就 是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到每个网络应经 过的下一跳路由器”。 （3）按固定的时间间隔交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由 信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路 由信息。 这里要强调一点：路由器在刚刚开始工作时，它的路由表是空的。然后路由器就得出 到直接相连的几个网络的距离（这些距离定义为 1）。接着，每一个路由器也只和数目非常 有限的相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知 道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 看起来 RIP 协议有些奇怪，因为“我的路由表中的信息要依赖于你的，而你的信息又 依赖于我的。”然而事实证明，通过这样的方式——“我告诉别人一些信息，而别人又告诉 我一些信息。我再把我知道的更新后的信息告诉别人，别人也这样把更新后的信息再告诉 我”，最后在自治系统中所有的结点都得到了正确的路由选择信息。在一般情况下，RIP 协 议可以收敛，并且过程也较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选 择信息的过程。 路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳 地址。路由表更新的原则是找出到每个目的网络的最短距离。这种更新算法又称为距离向量 算法。下面就是 RIP 协议使用的距离向量算法。 • ① 注：这里的“距离”实际上指的是“最短距离”，但为方便起见往往省略“最短”二字。 154。</p> <p>Page 165 2。距离向量算法 对每一个相邻路由器发送过来的RIP报文，进行以下步骤： （1） 对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一 跳”字段中的地址都改为X，并把所有的“距离”字段的值加1（见后面的解释1）。每一个 项目都有三个关键数据，即：到目的网络N，距离是d，下一跳路由器是X。 （2）对修改后的RIP报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络N，则把该项目添加到路由表中（见解释2）。 否则（即在路由表中有目的网络N，这时就再查看下一跳路由器地址） 若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目（见解释3）。 否则（即这个项目是：到目的网络，但下一跳路由器不是X） 若收到的项目中的距离d小于路由表中的距离，则进行更新（见解释4）， 否则什么也不做。（见解释5） （3） 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路 由器，即把距离置为16（距离为16表示不可达）。 （4） 返回。 上面给出的距离向量算法的基础就是 Bellman-Ford 算法（或Ford-Fulkerson 算法）。这 种算法的要点是这样的： 设 X 是结点 A到B的最短路径上的一个结点。若把路径A→B拆成两段路径A→X 和 X→B，则每一段路径A→X和X→B也都分别是结点A到X和结点X到B的最短路径。 下面是对上述距离向量算法的五点解释。 解释：这样做是为了便于进行本路由表的更新。假设从位于地址X的相邻路由器发来 的 RIP 报文的某一个项目是：“Net2， 3， Y”，意思是“我经过路由器Y到网络 Net2 的距离是 3”，那么本路由器就可推断出：“我经过X到网络Net2的距离应为3+1=4”。于是，本路 由器就把收到的 RIP报文的这一个项目修改为“Net2， 4， X”，作为下一步和路由表中原有项 目进行比较时使用（只有比较后才能知道是否需要更新）。读者可注意到，收到的项目中的 Y对本路由器是没有用的，因为Y不是本路由器的下一跳路由器地址。 解释 2： 表明这是新的目的网络，应当加入到路由表中。例如，本路由表中没有到目的 网络 Net2 的路由，那么在路由表中就要加入新的项目“Net2， 4， X”。 解释 3：为什么要替换呢？因为这是最新的消息，要以最新的消息为准。到目的网络的 距离有可能增大或减小，但也可能没有改变。例如，不管原来路由表中的项目是“Net2， 3， X”还是“Net2，5，X”，都要更新为现在的“Net2， 4， X”。 解释4：例如，若路由表中已有项目“Net2， 5， P”，就要更新为“Net2， 4， X”。因为到网 络 Net2 的距离原来是5，现在减到4，更短了。 解释5： 若距离更大了，显然不应更新。若距离不变，更新后得不到好处，因此也不更新。 【例4-5】已知路由器R6有表4-9（a）所示的路由表。现在收到相邻路由器R4发来的路 由更新信息，如表4-9（b）所示。试更新路由器R6的路由表。 • 155 •</p> <p>Page 166 表4-9（a） 路由器 Rs 的路由表 目的网络 Net2 距离 3 下一跳路由器 R4 Net3 4 Rs 。。。 表4-9（b） R4发来的路由更新信息 目的网络 Netl 距离 3 Net2 4 Net3 下一跳路由器 R₁ R2 1 直接交付 【解】 如同路由器一样，我们不需要知道该网络的拓扑。 先把表4-9（b）中的距离都加1，并把下一跳路由器都改为R4。得出表4-9（c）。 表4-9（c） 修改后的表4-9（b） 目的网络 距离 下一跳路由器 Netl 4 R4 Net2 5 R4 Net3 2 R4 把这个表的每一行和表4-9（a）进行比较。 第一行在表4-9（a）中没有，因此要把这一行添加到表4-9（a）中。 第二行的 Net2 在表4-9（a）中有，且下一跳路由器也是 R4。因此要更新（距离增大了）。 第三行的 Net3 在表4-9（a）中有，但下一跳路由器不同。于是就要比较距离。新的路由 信息的距离是2，小于原来表中的4，因此要更新。 这样，得出更新后的R的路由表如表4-9（d）所示。 表4-9（d） 路由器R6更新后的路由表 目的网络 距离 下一跳路由器 Net1 4 R4 Net2 5 R4 Net3 2 R4 RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并 不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最 少）。这里还应注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由 于每一个路由器的位置不同，它们的路由表当然也应当是不同的。 • 156 •</p> <p>Page 167 3。 RIP 协议的报文格式 现在较新的 RIP 版本是1998年11 月公布的 RIP2 [RFC2453]（已成为互联网标准），新 版本协议本身并无多大变化，但性能上有些改进。RIP2 可以支持变长子网掩码和无分类域 间路由选择 CIDR。此外，RIP2还提供简单的鉴别过程支持多播。 图 4-32 是 RIP2 的报文格式，它和RIP1 的首部相同，但后面的路由部分不一样。从图 4-32 还可看出，RIP 协议使用运输层的用户数据报 UDP 进行传送（使用 UDP 的端口 520。 端口的意义见 5。2。2节）。 4 字节 命令 版本 必为0 4 字节 地址标识符 路由标记 网络地址 路由信息 子网掩码 下一跳路由器地址 （20字节/路由） 可重复出现 最多 25 个 首部 路由部分 距离（1-16） IP UDP 首部 首部 RIP报文 UDP 用户数据报 IP数据报 图4-32RIP2的报文格式 RIP 报文由首部和路由部分组成。 RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1表示请求路由信 息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为 0”是为了4字节字的对齐。 RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址 族标识符（又称为地址类别）字段用来标志所使用的地址协议。如采用 IP 地址就令这个字 段的值为2（原来考虑RIP也可用于其他非 TCP/IP 协议的情况）。路由标记填入自治系统号 ASN （Autonomous System Number），这是考虑使RIP 有可能收到本自治系统以外的路由选 择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的 距离。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是4+20× 25 = 504 字节。如超过，必须再用一个RIP报文来传送。 RIP2 还具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息（20 字 节）的位置用作鉴别。这时应将地址族标识符置为全1（即0xFFFF），而路由标记写入鉴别 类型，剩下的 16字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放 入24个路由信息。 ① 注：自治系统号ASN 原来规定为一个16位的号码（最大的号码是65535），由IANA分配。现在已经把ASN扩展到 32 位[RFC 6793]。 • 157 •</p> <p>Page 168 RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所 有的路由器。我们可以用图 4-33 的简单例子来说明。设三个网络通过两个路由器互连起 来，并且都已建立了各自的路由表。图中路由器交换的信息只给出了我们感兴趣的一行内 容。路由器 Rı 中的“1， 1， 直接”表示“到网1的距离是1，直接交付”。路由器 R№ 中的“1， 2， Rı”表示“到网1的距离是2，下一跳经过 Rı”。 现在假定路由器 R， 到网 1 的链路出了故障，Rı 无法到达网 1。于是路由器 Rı 把到网 1 的距离改为 16（表示到网 1 不可达），因而在 Rı的路由表中的相应项目变为“1，16，直 接”。但是，很可能要经过30秒钟后，才把更新信息发送给R2。然而R，可能已经先把自 己的路由表发送给了R，其中有“1， 2， Rı”这一项。 | 1，1，直接 1， 2， R₁ 正常情况 网1 网2 网了 R₁ R₂ 网1出故障 网 2 网了 R2 R₁ 1，16，直接 1， 2， R₁ 1， 3， R， 1，4， R₁ 1， 5， R， D ： 1， 16， R， → 1， 16， R₁ 图4-33 RIP协议的缺点：坏消息传播得慢 Rı 收到 R2 的更新报文后，误认为可经过R，到达网1，于是把收到的路由信息“1，2， Rı”修改为：“1， 3， Rı”，表明“我到网1的距离是 3，下一跳经过R”，并把更新后的信息 发送给 R2。 同理，R，接着又更新自己的路由表为“1， 4， Rı”，以为“我到网 1 距离是 4，下一跳经 过 Rı”。 这样的更新一直继续下去，直到 R 和R2 到网 1的距离都增大到16时，R 和R2 才知道 原来网1是不可达的。RIP 协议的这一特点叫做：好消息传播得快，而坏消息传播得慢。网 络出故障的传播时间往往需要较长的时间（例如数分钟）。这是RIP 的一个主要缺点。 但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。 为了使坏消息传播得更快些，可以采取多种措施。例如，让路由器记录收到某特定路 由信息的接口，而不让同一路由信息再通过此接口向反方向传送。 总之，RIP 协议最大的优点就是实现简单，开销较小。但 RIP 协议的缺点也较多。首 先，RIP 限制了网络的规模，它能使用的最大距离为15（16表示不可达）。其次，路由器之 间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最 后，“坏消息传播得慢，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使 用下一节所述的 OSPF 协议。然而目前在规模较小的网络中，使用 RIP 协议的仍占多数。 158 •</p> <p>Page 169 4。5。3 内部网关协议 OSPF 1。 OSPF 协议的基本特点 这个协议的名字是开放最短路径优先 OSPF （Open Shortest Path First）。它是为克服 RIP 的缺点在 1989年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 的第二个版本OSPF2 已成为互联网标准协议 [RFC 2328]。关于OSPF 可参阅专著[MOY98]，[HUIT95]。 请注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径 优先”。实际上，所有的在自治系统内部使用的路由选择协议（包括RIP 协议）都是要寻找 一条最短的路径。 OSPF 最主要的特征就是使用分布式的链路状态协议（link state protocol），而不是像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样： （1）向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法（flooding），这就是 路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息 发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区 域中所有的路由器都得到了这个信息的一个副本。更具体的做法后面还要讨论。我们应注 意，RIP 协议是仅仅向自己相邻的几个路由器发送信息。 （2） 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道 的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的 “度量”（metric）。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都 由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。我们应注 意，对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。 （3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。 从上述的三个方面可以看出，OSPF 和 RIP 的工作原理相差较大。 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链 路状态数据库（link-state database），这个数据库实际上就是全网的拓扑结构图。这个拓扑结 构图在全网范围内是一致的（这称为链路状态数据库的同步）。因此，每一个路由器都知道 全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使 用链路状态数据库中的数据，构造出自己的路由表（例如，使用 Dijkstra 的最短路径路由算 法）。我们注意到，RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由 器，但却不知道全网的拓扑结构（只有到了下一跳路由器，才能知道再下一跳应当怎样 走）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。 OSPF 的更新过程收敛得快是其重要优点。 ① 注：在前面我们已经说过，在讨论路由器之间是如何交换路由信息时，最好将路由器之间的网络简化为一条链路。 OSPF 的“链路状态”中的“链路”实际上就是指“和这两个路由器都有接口的网络”。 • 159 •</p> <p>Page 170 为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的 范围，叫做区域（area）。图4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。当然，一个区域也不能太大，在一个区域内的路 由器最好不超过200个。 至其他自治系统 自治系统 AS 主干区域 0。0。0。0 R， R6 网6。 R&gt; Rs 网13 7 网23 R2 网43 网83 XX3 5 区域 0。0。0。3 区域0。0。0。1 区域0。0。0。2 图4-34 OSPF划分为两种不同的区域 划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是 整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域 的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以 外的区域进行通信，OSPF 使用层次结构的区域划分。在上层的区域叫做主干区域（backbone area）。主干区域的标识符规定为0。0。0。0。主干区域的作用是用来连通其他在下层的区域。从 其他区域来的信息都由区域边界路由器（area border router）进行概括。在图4-34 中，路由器 R3，R4 和R，都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。 在主干区域内的路由器叫做主干路由器（backbone router），如 R3，R4，Rs，R6 和R7。一个主 干路由器可以同时是区域边界路由器，如R3，R4 和R7。在主干区域内还要有一个路由器专 门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做自治系统边界路由器 （如图中的R。）。 采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复 杂了。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议 能够用于规模很大的自治系统中。这里，我们再一次地看到划分层次在网络设计中的重要 性。 OSPF 不用 UDP 而是直接用 IP 数据报传送（其IP数据报首部的协议字段值为89）。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以 不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据 报，而整个数据报就必须重传。 OSPF 分组使用24字节的固定长度首部（见图4-35），分组的数据部分可以是五种类型 分组中的一种。下面简单介绍 OSPF 首部各字段的意义。 （1） 版本 当前的版本号是2。 （2） 类型 可以是五种类型分组中的一种。 （3）分组长度 包括 OSPF 首部在内的分组长度，以字节为单位。 （4）路由器标识符 标志发送该分组的路由器的接口的 IP 地址。 • 160 •</p> <p>Page 171 （5） 区域标识符 分组属于的区域的标识符。 （6） 检验和 用来检测分组中的差错。 （7） 鉴别类型 目前只有两种，0（不用）和1（口令）。 （8） 鉴别 鉴别类型为0时就填入0，鉴别类型为1则填入8个字符的口令。 位 0 8 16 31 版本 类型 分组长度 路由器标识符 区域标识符 检验和 鉴别类型 鉴 别 鉴 别 -24字节- OSPF 分组首部 类型1至类型5 的OSPF 分组 IP数据报首部一 OSPF 分组 IP数据报 图4-35 OSPF分组用IP数据报传送 除了以上的几个基本特点外，OSPF 还具有下列的一些特点： （1） OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实 时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此， OSPF 对于不同类型的业务可计算出不同的路由。链路的代价可以是1至65535中的任何一 个无量纲的数，因此十分灵活。商用的网络在使用OSPF时，通常根据链路带宽来计算链路 的代价。这种灵活性是RIP所没有的。 （2） 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路 径。这叫做多路径间的负载平衡（load balancing）。在代价相同的多条路径上分配通信量是 通信量工程中的简单形式。RIP只能找出到某个网络的一条路径。 （3） 所有在 OSPF 路由器之间交换的分组（例如，链路状态更新分组）都具有鉴别的功 能，因而保证了仅在可信赖的路由器之间交换链路状态信息。 （4） OSPF 支持可变长度的子网划分和无分类的编址 CIDR。 （5） 由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一 个 32 位的序号，序号越大状态就越新。OSPF规定，链路状态序号增长的速率不得超过每5 秒钟1次。这样，全部序号空间在600年内不会产生重复号。 2。 OSPF 的五种分组类型 OSPF 共有以下五种分组类型： （1） 类型 1，问候（Hello）分组，用来发现和维持邻站的可达性。 （2） 类型 2，数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库 中的所有链路状态项目的摘要信息。 （3） 类型 3，链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目 • 161 •</p> <p>Page 172 的详细信息。 （4）类型 4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。这 种分组是最复杂的，也是OSPF协议最核心的部分。路由器使用这种分组将其链路状态通知 给邻站。链路状态更新分组共有五种不同的链路状态[RFC2328]，这里从略。 （5） 类型 5，链路状态确认（Link State Acknowledgment）分组，对链路更新分组的确认。 OSPF 规定，每两个相邻路由器每隔10秒钟要交换一次问候分组。这样就能确知哪些 邻站是可达的。对相邻路由器来说，“可达”是最基本的要求，因为只有可达邻站的链路状 态信息才存入链路状态数据库（路由表就是根据链路状态数据库计算出来的）。在正常情况 下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由 器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重 新计算路由表。 其他的四种分组都是用来进行链路状态数据库的同步。所谓同步就是指不同路由器的 链路状态数据库的内容是一样的。两个同步的路由器叫做“完全邻接的”（fully adjacent）路 由器。不是完全邻接的路由器表明它们虽然在物理上是相邻的，但其链路状态数据库并没有 达到一致。 当一个路由器刚开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工 作，以及将数据发往相邻路由器所需的“代价”。如果所有的路由器都把自己的本地链路状 态信息对全网进行广播，那么各路由器只要将这些链路状态信息综合起来就可得出链路状态 数据库。但这样做开销太大，因此 OSPF 采用下面的办法。 OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态 摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了 数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对 方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网 同步的链路数据库就建立了。图 4-36 给出了OSPF 的基本操作，说明了两个路由器需要交 换各种类型的分组。 问候 确定可达性 达到数据库的同步 问候 数据库描述 数据库描述 数据库描述 数据库描述 新情况下的同步 链路状态请求 链路状态更新 链路状态确认 图4-36 OSPF 的基本操作 在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路 状态更新分组，用洪泛法向全网更新链路状态。OSPF 使用的是可靠的洪泛法，其要点见图 4-37 所示。设路由器R 用洪泛法发出链路状态更新分组。图中用一些小的箭头表示更新分 组。第一次先发给相邻的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上 • 162⚫</p> <p>Page 173 游路由器除外。可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要 发送一次确认）。图中的空心箭头表示确认分组。 更新报文 R R R ACK报文 R 图4-37 用可靠的洪泛法发送更新分组 为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规 模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。由于 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于100 ms。 若 N 个路由器连接在一个以太网上，则每个路由器要向其他（N - 1）个路由器发送链路 状态信息，因而共有 N（N-1）个链路状态要在这个以太网上传送。OSPF 协议对这种多点接 入的局域网采用了指定的路由器（designated router）的方法，使广播的信息量大大减少。指定 的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。 4。5。4 外部网关协议 BGP 1989 年，公布了新的外部网关协议——边界网关协议 BGP。为简单起见，后面我们把 目前使用最多的版本 BGP-4 经常简写为 BGP。最近已经陆续发布了一些 BGP-4 的更新文 档，但目前 BGP-4仍然是草案标准[RFC 4271]。 我们首先应当弄清，在不同自治系统 AS 之间的路由选择为什么不能使用前面讨论过的 内部网关协议，如 RIP 或OSPF？ 我们知道，内部网关协议（如RIP 或OSPF）主要是设法使数据报在一个AS中尽可能 有效地从源站传送到目的站。在一个AS 内部也不需要考虑其他方面的策略。然而 BGP 使 用的环境却不同。这主要是因为以下的两个原因： 第一，互联网的规模太大，使得自治系统 AS 之间路由选择非常困难。连接在互联网主 干网上的路由器，必须对任何有效的IP 地址都能在路由表中找到匹配的目的网络。目前在 互联网的主干网路由器中，一个路由表的项目数早已超过了5万个网络前缀。如果使用链路 状态协议，则每一个路由器必须维持一个很大的链路状态数据库。对于这样大的主干网用 • 163 •</p> <p>Page 174 Dijkstra算法计算最短路径时花费的时间也太长。另外，由于自治系统 AS 各自运行自己选 定的内部路由选择协议，并使用本AS 指明的路径度量，因此，当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。例如，对某AS 来说，代价 为1000可能表示一条比较长的路由。但对另一AS代价为1000却可能表示不可接受的坏路 由。因此，对于自治系统 AS之间的路由选择，要用“代价”作为度量来寻找最佳路由也是 很不现实的。比较合理的做法是在自治系统之间交换“可达性”信息（即“可到达”或“不 可到达”）。例如，告诉相邻路由器：“到达目的网络N可经过自治系统 ASx”。 第二，自治系统 AS 之间的路由选择必须考虑有关策略。由于相互连接的网络的性能相 差很大，根据最短距离（即最少跳数）找出来的路径，可能并不合适。也有的路径的使用代 价很高或很不安全。还有一种情况，如自治系统 AS要发送数据报给自治系统 ASz，本来最 好是经过自治系统 AS3。但 AS， 不愿意让这些数据报通过本自治系统的网络，因为“这是他 们的事情，和我们没有关系。”但另一方面，自治系统 AS，愿意让某些相邻自治系统的数据 报通过自己的网络，特别是对那些付了服务费的某些自治系统更是如此。因此，自治系统之 间的路由选择协议应当允许使用多种路由选择策略。这些策略包括政治、安全或经济方面的 考虑。例如，我国国内的站点在互相传送数据报时不应经过国外兜圈子，特别是，不要经过 某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置 的，但这些策略并不是自治系统之间的路由选择协议本身。还可举出一些策略的例子，如： “仅在到达下列这些地址时才经过ASx”，“AS和AS， 相比时应优先通过 ASx”，等等。显 然，使用这些策略是为了找出较好的路径而不是最佳路径。 由于上述情况，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的 路由（不能兜圈子），而并非要寻找一条最佳路由。BGP 采用了路径向量（path vector）路由选 择协议，它与距离向量协议（如RIP）和链路状态协议（如OSPF）都有很大的区别。 在配置 BGP 时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 “BGP 发言人”。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是BGP边界路由器，但也可以不是BGP 边界路由器。 一个 BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息，就要先建立TCP 连接 （端口号为 179），然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会 话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使 用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两 个 BGP 发言人，彼此成为对方的邻站（neighbor）或对等站（peer）。 图 4-38 表示 BGP 发言人和自治系统 AS的关系的示意图。在图中画出了三个自治系统 中的 5 个 BGP 发言人。每一个 BGP 发言人除了必须运行 BGP 协议外，还必须运行该自治 系统所使用的内部网关协议，如 OSPF 或 RIP。 ① 注：BGP 的文档中使用了一个新名词——BGP speaker （BGP 发言人）。“BGP 发言人”表明该路由器可以代表整个自 治系统 AS 与其他自治系统AS 交换路由信息。虽然 BGP 协议允许使用任何其他计算机作为BGP 发言人，但大多数AS实际上 是在一个路由器上运行 BGP 协议的。英文 speaker 在这里译为“发言人”容易引起误解，其实这里的 speaker 并不是人而是路由 器。不过现在还没有找到更为合适的译名。 • 164 •</p> <p>Page 175 BGP BGP ASı 发言人 发言人 AS2 BGP 发言人 BGP 发言人 AS3 BGP 发言人 AS4 AS5 图4-38 BGP发言人和自治系统 AS的关系 边界网关协议 BGP所交换的网络可达性的信息就是要到达某个网络（用网络前缀表 示）所要经过的一系列自治系统。当BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。图 4-39 表示从图 4-38 的 AS 上的一个 BGP 发言人构造出的自治系统连通图，它是树形结构，不存 在回路。 AS， AS， AS AS ASF 图4-39 自治系统AS的连通图举例 在第 1 章的 1。2。2 节我们已经介绍了当前互联网的多级结构特点（图1-4）。这种多级结 构的网络拓扑决定了BGP路由选择协议的特点。 图 4-40 给出了一个 BGP 发言人交换路径向量的例子。自治系统 AS2 的BGP 发言人通 知主干网的 BGP 发言人：“要到达网络 Nı，N2，N3 N4可经过ASz。”主干网在收到这个通 知后，就发出通知：“要到达网络 Nı， N2， N3 和 N4 可沿路径（ASı，ASz）。”同理，主干网还 可发出通知：“要到达网络 Ns， N｡ 和N，可沿路径（ASı， AS3）。” 地区 ISP （ASz） 本地ISP（AS） N，N2 主干网 （AS） 本地ISP（AS） N3， N4 本地ISP（AS） Ns 地区 ISP （AS3） 本地 ISP（AS） No，N7 图4-40 BGP发言人交换路径向量的例子 从上面的讨论可看出，BGP 协议交换路由信息的结点数量级是自治系统个数量级， 这要比这些自治系统中的网络数少很多。要在许多自治系统之间寻找一条较好的路径，就是 • 165 •</p> <p>Page 176 要寻找正确的 BGP 发言人（或边界路由器），而在每一个自治系统中 BGP 发言人（或边界 路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。 BGP 支持无分类域间路由选择 CIDR，因此 BGP 的路由表也就应当包括目的网络前 缀、下一跳路由器，以及到达该目的网络所要经过的自治系统序列。由于使用了路径向量的 信息，就可以很容易地避免产生兜圈子的路由。如果一个BGP 发言人收到了其他 BGP 发言 人发来的路径通知，它就要检查一下本自治系统是否在此通知的路径中。如果在这条路径 中，就不能采用这条路径（因为会兜圈子）。 在 BGP 刚刚运行时，BGP 的邻站是交换整个的BGP路由表。但以后只需要在发生变 化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。 在 RFC 4271 中规定了BGP-4 的四种报文： （1） OPEN（打开）报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。 （2）UPDATE（更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由。 （3）KEEPALIVE（保活）报文，用来周期性地证实邻站的连通性。 （4）NOTIFICATION（通知）报文，用来发送检测到的差错。 若两个邻站属于两个不同 AS，而其中一个邻站打算和另一个邻站定期地交换路由信 息，这就应当有一个商谈的过程（因为很可能对方路由器的负荷已很重因而不愿意再加重负 担）。因此，一开始向邻站进行商谈时就必须发送 OPEN 报文。如果邻站接受这种邻站关 系，就用 KEEPALIVE 报文响应。这样，两个 BGP 发言人的邻站关系就建立了。 一旦邻站关系建立了，就要继续维持这种关系。双方中的每一方都需要确信对方是存 在的，且一直在保持这种邻站关系。为此，这两个 BGP 发言人彼此要周期性地交换 KEEPALIVE 报文（一般每隔30秒）。KEEPALIVE 报文只有 19 字节长（只用 BGP 报文的 通用首部），因此不会造成网络上太大的开销。 UPDATE 报文是BGP 协议的核心内容。BGP 发言人可以用UPDATE 报文撤销它以前 曾经通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路 由时，每个更新报文只能增加一条。 BGP 可以很容易地解决距离向量路由选择算法中的“坏消息传播得慢”这一问题。当 某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很 容易选择出新的路由。距离向量算法往往不能给出正确的选择，是因为这些算法不能指出哪 些邻站到目的站的路由是独立的。 图 4-41 给出了 BGP报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度 为 19 字节。通用首部分为三个字段。标记（marker）字段为16字节长，用来鉴别收到的 BGP 报文（这是假定将来有人会发明出合理的鉴别方案）。当不使用鉴别时，标记字段要置为全 1。长度字段指出包括通用首部在内的整个 BGP报文以字节为单位的长度，最小值是 19， 最大值是 4096。类型字段的值为1到4，分别对应于上述四种 BGP报文中的一种。 OPEN 报文共有6个字段，即版本（1字节，现在的值是4）、本自治系统号（2 字节， 使用全球唯一的16 位自治系统号，由ICANN 地区登记机构分配）、保持时间（2 字节，以 秒计算的保持为邻站关系的时间）、BGP 标识符（4字节，通常就是该路由器的IP 地址）、 可选参数长度（1字节）和可选参数。 • 166 •</p> <p>Page 177 字节 16 2 1 H 标 记 长度 类型 BGP报文通用首部 BGP报文主体部分 | TCP 首部 BGP 报文 IP 首部 TCP报文 图4-41 BGP报文具有通用的首部 UPDATE 报文共有5个字段，即不可行路由长度（2字节，指明下一个字段的长度）、 撤销的路由（列出所有要撤销的路由）、路径属性总长度（2 字节，指明下一个字段的长 度）、路径属性（定义在这个报文中增加的路径的属性）和网络层可达性信息 NLRI （Network Layer Reachability Information）。最后这个字段定义发出此报文的网络，包括网络 前缀的位数、IP 地址前缀。 KEEPALIVE 报文只有BGP的19字节长的通用首部。 NOTIFICATION 报文有3 个字段，即差错代码（1 字节）、差错子代码（1 字节）和差 错数据（给出有关差错的诊断信息）。 在讨论完路由选择之后，我们再来介绍路由器的构成。 4。5。5 路由器的构成 1。路由器的结构 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。 从路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路 由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组， 直到该分组到达终点为止。路由器的转发分组正是网络层的主要工作。图 4-42 给出了一种 典型的路由器的构成框图。 路由选择处理机 路由选择协议 路由选择 路由表 输入端口 输出端口 23元 3 分组处理 转发表 分组转发 输入端口 输出端口 1-2-3 交换结构 3 2 -1 图4-42 典型的路由器的结构（图中的数字1~3表示相应层次的构件） • 167 •</p> <p>Page 178 部分。 从图 4-42 可以看出，整个的路由器结构可划分为两大部分：路由选择部分和分组转发 路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任 务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信 息而不断地更新和维护路由表。关于怎样根据路由选择协议构造和更新路由表，我们已在前 面的4。5。2至4。5。4节讨论过了。 分组转发部分是本节所要讨论的问题，它由三部分组成：交换结构、一组输入端口和 一组输出端口（请注意：这里的端口就是硬件接口）。下面分别讨论每一部分的组成。 交换结构（switching fabric）又称为交换组织，它的作用就是根据转发表（forwarding table） 对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构本 身就是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中 的网络”。 请注意“转发”和“路由选择”是有区别的。在互联网中，“转发”就是路由器根据转 发表把收到的 IP数据报从路由器合适的端口转发出去。“转发”仅仅涉及到一个路由器。但 “路由选择”则涉及到很多路由器，路由表则是许多路由器协同工作的结果。这些路由器按 照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态地改变所选择的路由，并 由此构造出整个的路由表。路由表一般仅包含从目的网络到下一跳（用 IP 地址表示）的映 射，而转发表是从路由表得出的。转发表必须包含完成转发功能所必需的信息。这就是说， 在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC 地址信息（如下一 跳的以太网地址）的映射。将转发表和路由表用不同的数据结构实现会带来一些好处，这是 因为在转发分组时，转发表的结构应当查找过程最优化，但路由表则需要对网络拓扑变化 的计算最优化。路由表总是用软件实现的，但转发表则甚至可用特殊的硬件来实现。请读者 注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，而可以笼统地都使 用路由表这一名词。 在图 4-42 中，路由器的输入和输出端口里面都各有三个方框，用方框中的 1， 2 和 3 分 别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按 照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理 模块。若接收到的分组是路由器之间交换路由信息的分组（如 RIP 或OSPF 分组等），则把 这种分组送交路由器的路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照 分组首部中的目的地址查找转发表，根据得出的结果，分组就经过交换结构到达合适的输出 端口。一个路由器的输入端口和输出端口就做在路由器的线路接口卡上。 输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分 散化，往往把复制的转发表放在每一个输入端口中（如图 4-42 中的虚线箭头所示）。路由选 择处理机负责对各转发表的副本进行更新。这些副本常称为“影子副本”（shadow copy）。分 散化交换可以避免在路由器中的某一点上出现瓶颈。 以上介绍的查找转发表和转发分组的概念虽然并不复杂，但在具体的实现中还是会遇 到不少困难。问题就在于路由器必须以很高的速率转发分组。最理想的情况是输入端口的处 理速率能够跟上线路把分组传送到路由器的速率。这种速率称为线速（line speed 或 wire speed）。可以粗略地估算一下。设线路是OC-48 链路，即 2。5 Gbit/s。若分组长度为256 字 节，那么线速就应当达到每秒能够处理 100 万以上的分组。现在常用 Mpps （百万分组每 • 168 •</p> <p>Page 179 秒）为单位来说明一个路由器对收到的分组的处理速率有多高。在路由器的设计中，怎样提 高查找转发表的速率是一个十分重要的研究课题。 当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个 后到的分组就必须在队列中排队等待，因而产生了一定的时延。图4-43 给出了在输入端口 的队列中排队的分组的示意图。 输入端口的处理 网络层处理 分组排队 数据链路层| · 物理层处理 处理 查表和转发 从线路接收分组 交换结构 图4-43 输入端口对线路上收到的分组的处理 我们再来观察在输出端口上的情况（图4-44）。输出端口从交换结构接收分组，然后把 它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上它就是一 个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组 就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给 物理层后发送到外部线路。 交换结构 向线路发送分组 输出端口的处理 网络层处理 分组排队 数据链路层 物理层处理· 处理 缓存管理 图4-44 输出端口把交换结构传送过来的分组发送到线路上 从以上的讨论可以看出，分组在路由器的输入端口和输出端口都可能会在队列中排队 等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少 到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。以前我们提到过的分 组丢失就是发生在路由器中的输入或输出队列产生溢出的时候。当然，设备或线路出故障也 可能使分组丢失。 2。交换结构 交换结构是路由器的关键构件[KURO13]。正是这个交换结构把分组从一个输入端口 转移到某个合适的输出端口。实现这样的交换有多种方法，图4-45 给出了三种常用的交 换方法。这三种方法都是将输入端口 I收到的分组转发到输出端口 Oz。下面简单介绍它 们的特点。 • 169。</p> <p>Page 180 存储器 （a）通过存储器 -0-0-0 总线 （b）通过总线 互连网络 （c）通过互连网络 图4-45 三种常用的交换方法 最早使用的路由器就是利用普通的计算机，用计算机的 CPU 作为路由器的路由选择处 理机。路由器的输入和输出端口的功能和传统的操作系统中的I/O设备一样。当路由器的某 个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复 制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适 的输出端口的缓存中。若存储器的带宽（读或写）为每秒M个分组，那么路由器的交换速 率（即分组从输入端口传送到输出端口的速率）一定小于M/2。这是因为存储器对分组的读 和写需要花费的时间是同一个数量级。 许多现代的路由器也通过存储器进行交换，图4-45（a）的示意图表示分组通过存储器进 行交换。与早期的路由器的区别就是，目的地址的查找和分组在存储器中的缓存都是在输入 端口中进行的。Cisco 公司的 Catalyst 8500 系列交换机（有的公司把路由器也称为交换机） 和 Bay Network 公司的 Accelar 1200系列路由器就采用了共享存储器的方法。 图4-45（b）是通过总线进行交换的示意图。采用这种方式时，数据报从输入端口通过共 享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。但是，由于总线是 共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线 忙（因为总线正在传送另一个分组），则被阻塞而不能通过交换结构，并在输入端口排队等 待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的 限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品 都采用这种通过总线的交换方式。例如，Cisco 公司的 Catalyst 1900系列交换机就使用了带 宽达到 1 Gbit/s 的总线（叫做Packet Exchange Bus）。 图4-45（c）画的是通过纵横交换结构（crossbar switch fabric）进行交换。这种交换机构常称 为互连网络（interconnection network），它有 2N 条总线，可以使 N个输入端口和 N 个输出端 口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收 到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口 的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个 • 170 •</p> <p>Page 181 输出端口。但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到 达的分组就被阻塞，必须在输入端口排队。采用这种交换方式的路由器例子是 Cisco 公司的 12000系列交换路由器，它使用的互连网络的带宽达60Gbit/s。</p> <h2 id="六ipv6">六、IPv6</h2> <p>IP 是互联网的核心协议。现在使用的IP（即IPv4）是在20世纪70年代末期设计的。 互联网经过几十年的飞速发展，到2011年2月，IPv4的地址已经耗尽，ISP已经不能再申 请到新的IP 地址块了。我国在2014年至2015年也逐步停止了向新用户和应用分配IPv4地 址，同时全面开始商用部署 IPv6。 解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的IP，即 IPv6。到目 前为止，IPv6 还只是草案标准阶段[RFC2460，4862，4443]。有关向IPv6 转换的进展情况见 有关网站[W-NGTRANS]。 4。6。1 IPv6 的基本首部 IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组，而不是IPv4 的数据 报。为方便起见，本书仍采用数据报这一名词（[COME06]和[TANE11]也是这样做的）。 IPv6 所引进的主要变化如下： （1）更大的地址空间。IPv6 把地址从IPv4 的32 位增大到4倍，即增大到128位，使地 址空间增大了 26倍。这样大的地址空间在可预见的将来是不会用完的。 （2） 扩展的地址层次结构。IPv6 由于地址空间很大，因此可以划分为更多的层次。 （3） 灵活的首部格式。IPv6 数据报的首部和IPv4 的并不兼容。IPv6 定义了许多可选的 扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路 由器对扩展首部不进行处理（除逐跳扩展首部外）。 （4） 改进的选项。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选 项。但 IPv6 的首部长度是固定的，其选项放在有效载荷中。我们知道，IPv4 所规定的选项 是固定不变的，其选项放在首部的可变部分。 （5） 允许协议继续扩充。这一点很重要，因为技术总是在不断地发展（如网络硬件的更 新）而新的应用也还会出现。但我们知道，IPv4 的功能是固定不变的。 （6） 支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。 （7）支持资源的预分配。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。 （8） IPv6 首部改为8字节对齐（即首部长度必须是8字节的整数倍）。原来的IPv4 首部 是4字节对齐。 IPv6 数据报由两大部分组成，即基本首部（base header）和后面的有效载荷（payload）。有 效载荷也称为净负荷。有效载荷允许有零个或多个扩展首部（extension header），再后面是数 据部分（图4-46）。但请注意， 所有的扩展首部并不属于IPv6 数据报的首部。 • 171 •</p> <p>Page 182 IPv6 数据报 发送在前 基本首部 有 效 载 荷 40字节 不超过65535字节 扩展 首部1 扩展 首部N 数 据部 分 图4-46 具有多个可选扩展首部的IPv6数据报的一般形式 与 IPv4 相比，IPv6对首部中的某些字段进行了如下的更改： • 取消了首部长度字段，因为它的首部长度是固定的（40字节）。 取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。 • 取消了总长度字段，改用有效载荷长度字段。 • 取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。 • 把 TTL 字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致）。 取消了协议字段，改用下一个首部字段。 取消了检验和字段，这样就加快了路由器处理数据报的速度。我们知道，在数据链 路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的 用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确 传送到目的进程为止。因此在网络层的差错检测可以精简掉。 • 取消了选项字段，而用扩展首部来实现选项功能。 由于把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有8个（虽然首 部长度增大了一倍）。 下面解释 IPv6 基本首部中各字段的作用（参见图4-47）。 IPv6的 位0 4 12 16 24 31 版本 通信量类 流标号 有效载荷长度 下一个首部 跳数限制 基本首部 （40B） IPv6的 有效载荷 （至64KB） 源地址 （128位） 目的地址 （128位） 有效载荷（扩展首部/数据） 图4-47 40字节长的IPv6基本首部 （1） 版本（version） 占4位。它指明了协议的版本，对IPv6 该字段是6。 （2） 通信量类（traffic class） 占8位。这是为了区分不同的IPv6 数据报的类别或优先 级。目前正在进行不同的通信量类性能的实验。 • 172 •</p> <p>Page 183 （3） 流标号（flow label） 占 20 位。IPv6的一个新的机制是支持资源预分配，并且允 许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流（flow）的抽象概念。所 谓“流”就是互联网络上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音 频或视频传输），而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属 于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别 有用。对于传统的电子邮件或非实时数据，流标号则没有用处，把它置为0即可。关于流标 号可参考[RFC 6437]。 （4）有效载荷长度（payload length） 占 16 位。它指明IPv6数据报除基本首部以外的字 节数（所有扩展首部都算在有效载荷之内）。这个字段的最大值是64KB（65535字节）。 （5） 下一个首部（next header） 占8位。它相当于IPv4 的协议字段或可选字段。 • 当IPv6 数据报没有扩展首部时，下一个首部字段的作用和IPv4 的协议字段一样， 它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议（例如：6 或17分别表示应交付运输层TCP或UDP）。 当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。 占8位。用来防止数据报在网络中无限期地存在。源点在每 （6） 跳数限制（hop limit） 个数据报发出时即设定某个跳数限制（最大为 255 跳）。每个路由器在转发数据报时，要先 把跳数限制字段中的值减1。当跳数限制的值为零时，就要把这个数据报丢弃。 （7） 源地址 （8） 目的地址 占 128 位。是数据报的发送端的 IP 地址。 占 128 位。是数据报的接收端的 IP 地址。 下面我们介绍一下 IPv6 的扩展首部。 大家知道，IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上 的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。然 而实际上很多的选项在途中的路由器上是不需要检查的（因为不需要使用这些选项的信 息）。IPv6 把原来IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端 的源点和终点的主机来处理，而数据报途中经过的路由器都不处理这些扩展首部（只有一个 首部例外，即逐跳选项扩展首部），这样就大大提高了路由器的处理效率。 在 RFC 2460 中定义了以下六种扩展首部：（1）逐跳选项；（2） 路由选择；（3）分片；（4） 鉴别；（5） 封装安全有效载荷；（6） 目的站选项。 每一个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的第一 个字段都是 8 位的“下一个首部”字段。此字段的值指出了在该扩展首部后面的字段是什 么。当使用多个扩展首部时，应按以上的先后顺序出现。高层首部总是放在最后面。 4。6。2 IPv6 的地址 一般来讲，一个IPv6 数据报的目的地址可以是以下三种基本类型地址之一： （1） 单播（unicast） 单播就是传统的点对点通信。 （2） 多播（multicast） 多播是一点对多点的通信，数据报发送到一组计算机中的每一 个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。 （3） 任播（anycast） 这是 IPv6 增加的一种类型。任播的终点是一组计算机，但数据报 只交付其中的一个，通常是距离最近的一个。 IPv6 把实现 IPv6 的主机和路由器均称为结点。由于一个结点可能会使用多条链路与其 • 173 •</p> <p>Page 184 他的一些结点相连，因此一个结点可能有多个与链路相连的接口。这样，IPv6 给结点的每 一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当 到达该结点的目的地址。 在 IPv6 中，每个地址占128位，地址空间大于3。4x108。如果整个地球表面（包括陆 地和水面）都覆盖着计算机，那么IPv6 允许每平方米拥有7x103 个IP地址。如果地址分配 速率是每微秒分配100万个地址，则需要 101°年的时间才能将所有可能的地址分配完毕。 可见在想象到的将来，IPv6的地址空间是不可能用完的。 巨大的地址范围还必须使维护互联网的人易于阅读和操纵这些地址。IPv4 所用的点分 十进制记法现在也不够方便了。例如，一个用点分十进制记法的128位的地址为： 104。230。140。100。255。255。255。255。0。0。17。128。150。10。255。255 为了使地址再稍简洁些，IPv6使用冒号十六进制记法（colon hexadecimal notation，简写 为 colon hex），它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如，如果前 面所给的点分十进制数记法的值改为冒号十六进制记法，就变成了： 68E6：8C64：FFFF：FFFF：0：1180：960A： FFFF 在十六进制记法中，允许把数字前面的0省略。上面就把 0000 中的前三个0省略了。 冒号十六进制记法还包含两个技术使它尤其有用。首先，冒号十六进制记法可以允许 零压缩（zero compression），即一连串连续的零可以为一对冒号所取代，例如： 可压缩为： FF05：0：0：0：0：0：0：B3 FF05：：B3 为了保证零压缩有一个不含混的解释，规定在任一地址中只能使用一次零压缩。该技 术对已建议的分配策略特别有用，因为会有许多地址包含较长连续的零串。 其次，冒号十六进制记法可结合使用点分十进制记法的后缀。我们下面会看到这种结 合在 IPv4 向 IPv6的转换阶段特别有用。例如，下面的串是一个合法的冒号十六进制记法： 0：0：0：0：0：0：128。10。2。1 请注意，在这种记法中，虽然为冒号所分隔的每个值是两个字节（16位）的量，但每个点 分十进制部分的值则指明一个字节（8位）的值。再使用零压缩即可得出： ：： 128。10。2。1 下面再给出几个使用零压缩的例子。 1080：0：0：0：8：800：200C：417A 记为 FF01：0：0：0：0：0：0：101 （多播地址） 记为 0：0：0：0：0：0：0：1（环回地址） 1080：：8：800：200C：417A FF01：：101 记为 ：： 1 记为 ： ： 0：0：0：0：0：0：0：0（未指明地址） CIDR 的斜线表示法仍然可用。例如，60 位的前缀 12AB00000000CD3（十六进制表 • 174 •</p> <p>Page 185 示的15个字符，每个字符代表4位二进制数字）可记为： 12AB 0000：0000：CD30：0000：0000：0000：0000/60 或12AB：：CD30：0：0：0：0/60 或12AB：0：0：CD30：：/60 （不能把16位地址CD30块中的最后的省略） 但不允许记为： 12AB：0：0：CD3/60 或 12AB：：CD30/60 （这是地址12AB：0：0：0：0：0：0：CD30的前60 位二进制） 或 12AB：：CD3/60 （这是地址12AB：0：0：0：0：0：0：0CD3的前60位二进制） IPv6 的地址分类见表4-10所示[RFC 4291]。 表4-10 IPv6 的地址分类 地址类型 未指明地址 环回地址 多播地址 二进制前缀 00。0 （128位），可记为：：128。 00。。。1 （128位），可记为：1/128。 11111111 （8位），可记为FF00：：/8。 本地链路单播地址 全球单播地址 1111111010 （10位），可记为FE80/10。 （除上述四种外，所有其他的二进制前缀） 对表 4-10 所列举的几种地址简单解释如下。 未指明地址 这是 16 字节的全 0 地址，可缩写为两个冒号“：：”。这个地址不能用 作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的 IP 地址。这类地址仅此一个。 环回地址 IPv6 的环回地址是0：0：0：0：0：0：0：1，可缩写为：：1。 它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。 多播地址 功能和 IPv4 的一样。这类地址占IPv6地址总数的1/256。 本地链路单播地址（Link-Local Unicast Address） 有些单位的网络使用TCP/IP 协议， 但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信， 但不能和互联网上的其他主机通信。这类地址占IPv6地址总数的 1/1024。 全球单播地址 IPv6 的这一类单播地址是使用得最多的一类。曾提出过多种方案来进 一步划分这128位的单播地址。根据2006年发布的草案标准 RFC 4291 的建议， IPv6 单播 地址的划分方法非常灵活，可以如图 4-48 所示的任何一种。这就是说，可把整个的 128 比 特都作为一个结点的地址。也可用n比特作为子网前缀，用剩下的（128-n）比特作为接口标 识符（相当于 IPv4 的主机号）。当然也可以划分为三级，用n比特作为全球路由选择前缀， 用 m 比特作为子网前缀，而用剩下的（128-n-m）比特作为接口标识符。 结点地址（128 bit） 子网前缀（nbit） 接口标识符（128-n）bit 全球路由选择前缀（nbit） 子网标识符（mbit） 接口标识符（128-n-m）bit 图4-48 IPv6的单播地址的几种划分方法 • 175 •</p> <p>Page 186 4。6。3 从IPv4 向 IPv6 过渡 由于现在整个互联网的规模太大，因此，“规定一个日期，从这一天起所有的路由器一 律都改用IPv6”，显然是不可行的。这样，向IPv6 过渡只能采用逐步演进的办法，同时， 还必须使新安装的IPv6系统能够向后兼容。这就是说，IPv6系统必须能够接收和转发 IPv4 分组，并且能够为IPv4分组选择路由。 下面介绍两种向IPv6 过渡的策略，即使用双协议栈和使用隧道技术[RFC 2473，2529， 3056， 4038， 4213]。 1。双协议栈 双协议栈（dual stack）是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有双 协议栈：一个 IPv4 和一个IPv6。因此双协议栈主机（或路由器）既能够和IPv6的系统通 信，又能够和 IPv4 的系统通信。双协议栈的主机（或路由器）记为IPv6/IPv4，表明它同时 具有两种 IP 地址：一个IPv6地址和一个 IPv4 地址。 双协议栈主机在和 IPv6 主机通信时采用IPv6 地址，而和 IPv4 主机通信时则采用IPv4 地址。但双协议栈主机怎样知道目的主机是采用哪一种地址呢？它是使用域名系统 DNS 来 查询的。若 DNS 返回的是IPv4地址，双协议栈的源主机就使用 IPv4 地址。但当 DNS 返回 的是 IPv6 地址，源主机就使用 IPv6 地址。 图 4-49 所示的情况是源主机A 和目的主机 F都使用IPv6，所以A向F发送 IPv6 数据 报，路径是 A→B→C→D→E→F。中间 B 到 E 这段路径是IPv4 网络，路由器 B 不能向 C 转发 IPv6 数据报，因为C只使用IPv4 协议。B 是IPv6/IPv4 路由器，它把IPv6 数据报首部 转换为IPv4 数据报首部后发送给CC再转发到D。当D转发到 IPv4 网络的出口路由器E 时（E 也是 IPv6/IPv4 路由器），再恢复成原来的IPv6 数据报。需要注意的是：IPv6 首部中 的某些字段却无法恢复。例如，原来 IPv6 首部中的流标号 X在最后恢复出的IPv6 数据报中 只能变为空缺。这种信息的损失是使用首部转换方法所不可避免的。 IPv6 A 双协议栈 IPv6/IPv4 B IPv4 网络 双协议栈 IPv6/IPv4 D E IPv6 F 流标号：X 源地址：A 目的地址：F 源地址：A 目的地址：F 源地址：A 目的地址：F 流标号：无 源地址：A 目的地址：F 数据部分 数据部分 数据部分 数据部分 IPv4 数据报 IPv4 数据报 IPv6 数据报 IPv6 数据报 图4-49 使用双协议栈进行从IPv4 到IPv6的过渡 2。隧道技术 向 IPv6 过渡的另一种方法是隧道技术（tunneling）。图 4-50 给出了隧道技术的工作原 • 176 •</p> <p>Page 187 理。这种方法的要点就是在IPv6 数据报要进入IPv4 网络时，把IPv6数据报封装成为IPv4 数据报。现在整个的IPv6数据报变成了IPv4 数据报的数据部分。这样的IPv4 数据报从路 由器 B 经过路由器C和D，传送到E，而原来的IPv6数据报就好像在IPv4 网络的隧道中传 输，什么都没有变化。当IPv4数据报离开IPv4 网络中的隧道时，再把数据部分（即原来的 IPv6 数据报）交给主机的IPv6 协议栈。图中的一条粗线表示在IPv4 网络中好像有一个从B 到E的“IPv6隧道”，路由器B是隧道的入口而E是出口。请注意，在隧道中传送的数据 报的源地址是B而目的地址是E。 要使双协议栈的主机知道IPv4 数据报里面封装的数据是一个IPv6 数据报，就必须把 IPv4 首部的协议字段的值设置为4141表示数据报的数据部分是IPv6数据报）。 双协议栈 IPv4 网络 双协议栈 IPv6 IPv6/IPv4 IPv6/IPv4 IPv6 B A IPv6 隧道 。IPv6 隧道 D IPv6 隧道 E F 流标号：X 源地址：A 目的地址：F 源地址：B 源地址：B 目的地址：E 目的地址：E 流标号：X 源地址：A 目的地址：F IPv6 IPv6 数据报 数据报 数据部分 IPv4 数据报 IPv4 数据报 数据部分 IPv4 网络 IPv6 数据报 IPv6 数据报 图4-50 使用隧道技术进行从IPv4 到IPv6的过渡 4。6。4 ICMPv6 和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数 据报。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6，它比 ICMPv4 要复杂得多。地址解析协议 ARP 和网际组管理协议 IGMP 的功能都已被合并到 ICMPv6 中（图4-51）。 ICMP IGMP IPv4 ARP 版本4中的网络层 ICMPv6 IPv6 版本6中的网络层 图4-51 新旧版本中的网络层的比较 ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播 通信。ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类 时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为ICMPv6 报 文，而把另一些报文定义为邻站发现 ND （Neighbor-Discovery）报文或多播听众交付 MLD （Multicast Listener Delivery）报文。其实所有这些报文都应当是ICMPv6 报文，只是功能和作 用不同而已。因此我们把这些报文都列入ICMPv6 的不同类别。使用这种分类方法的原因是 所有这些报文都具有相同的格式，并且所有报文类型都由 ICMPv6 协议处理。其实，像 ND • 177。</p> <p>Page 188 和 MLD 这样的协议都是运行在 ICMPv6 协议之下的。基于这样的考虑，可把ICMPv6 报文 分类如图4-52 所示。请注意，邻站发现报文和组成员关系报文分别是在ND 协议和 MLD 协 议的控制下进行发送和接收的。 ICMPv6 报文 差错报文 信息报文 邻站发现报文 ND triX 组成员关系报文 MLD 协议 图4-52 ICMPv6 报文的分类 关于 ICMPv6 的进一步讨论可参阅[FORO10]，这里从略。</p> <h2 id="七ip-多播">七、IP 多播</h2> <p>4。7。1 IP 多播的基本概念 1988年 Steve Deering 首次在其博士学位论文中提出 IP 多播的概念。1992年3月IETF 在互联网范围首次试验 IETF 会议声音的多播，当时有 20 个网点可同时听到会议的声音。IP 多播是需要在互联网上增加更多的智能才能提供的一种服务。现在 IP 多播（multicast，以 前曾译为组播）已成为互联网的一个热门课题。这是由于有许多的应用需要由一个源点发送 到许多个终点，即一对多的通信。例如，实时信息的交付（如新闻、股市行情等），软件更 新，交互式会议等。随着互联网的用户数目的急剧增加，以及多媒体通信的开展，有更多的 业务需要多播来支持。关于IP多播可参考[W-MCAST]。 与单播相比，在一对多的通信中，多播可大大节约网络资源。图 4-53（a）是视频服务器 用单播方式向 90 台主机传送同样的视频节目。为此，需要发送 90 个单播，即同一个视频分 组要发送 90 个副本。图4-53（b）是视频服务器用多播方式向属于同一个多播组的 90 个成员 传送节目。这时，视频服务器只需把视频分组当作多播数据报来发送，并且只需发送一次。 路由器 Rı 在转发分组时，需要把收到的分组复制成3个副本，分别向 R2、R， 和 R&amp; 各转发1 个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此不需要复制分组， 在局域网上的多播组成员都能收到这个视频分组。 当多播组的主机数很大时（如成千上万个），采用多播方式就可明显地减轻网络中各种 资源的消耗。在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多 播数据报的软件。能够运行多播协议的路由器称为多播路由器（multicast router）。多播路由器 当然也可以转发普通的单播IP数据报。 为了适应交互式音频和视频信息的多播，从1992 年起，在互联网上开始试验虚拟的多 播主干网 MBONE （Multicast Backbone On the InterNEt）。 MBONE 可把分组传播给地点分散 但属于一个组的许多台主机。现在多播主干网已经有了相当大的规模。 在互联网上进行多播就叫做IP 多播。IP多播所传送的分组需要使用多播 IP 地址。 我们知道，在互联网中每一台主机必须有一个全球唯一的IP地址。如果某台主机现在 想接收某个特定多播组的分组，那么怎样才能使这个多播数据报传送到这台主机？ • 178 •</p> <p>Page 189 视频服务器M 视频服务器 M 发送1次多播 发送90次单播 1个 90 个 R₁ 复制 R₁ 30个 30个 30个 R2 R3 R₁ R2 R3 Rai 个 30个 30个 30个 多播 多播 ♡ 多播 共有90个主机接收视频节目 （a）单播 多播组成员共有90个 （b） 多播 图4-53 单播与多播的比较 显然，这个多播数据报的目的地址一定不能写入这台主机的IP地址。这是因为在同一 时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入这样多的 主机的IP 地址。在多播数据报的目的地址写入的是多播组的标识符，然后设法让加入到这 个多播组的主机的IP地址与多播组的标识符关联起来。 其实多播组的标识符就是IP地址中的D类地址。D类IP地址的前四位是1110，因此 D 类地址范围是224。0。0。0 到239。255。255。255。我们就用每一个D类地址标志一个多播组。 这样，D 类地址共可标志 228个多播组，也就是说，在同一时间可以允许有超过2。6亿的多 播组在互联网上运行。多数据报也是“尽最大努力交付”，不保证一定能够交付多播组内 的所有成员。因此，多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的 地址，并且首部中的协议字段值是2，表明使用网际组管理协议 IGMP。 显然，多播地址只能用于目的地址，而不能用于源地址。此外，对多播数据报不产生 ICMP 差错报文。因此，若在PING命令后面键入多播地址，将永远不会收到响应。 IP 多播可以分为两种。一种是只在本局域网上进行硬件多播，另一种则是在互联网的 范围进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入 到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播 交付多播组的所有成员（如图4-53（b）所示）。下面就先讨论这种硬件多播。 4。7。2 在局域网上进行硬件多播 互联网号码指派管理局IANA 拥有的以太网地址块的高24位为00-00-5E，因此 TCP/IP 协议使用的以太网多播地址块的范围是从 00-00-5E-00-00-00 到 00-00-5E-FF-FF-FF。在第3 章 3。4。3 节已讲过，以太网硬件地址字段中的第1字节的最低位为1时即为多播地址，这种 多播地址数占IANA 分配到的地址数的一半。因此IANA 拥有的以太网多播地址的范围是从 01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF。不难看出，在每一个地址中，只有23 位可用作多 播。这只能和D 类IP地址中的23位有一一对应的关系。D类IP地址可供分配的有 28 位， 可见在这 28 位中的前 5 位不能用来构成以太网硬件地址（图4-54）。例如，IP 多播地址 224。128。64。32（即E0-80-40-20）和另一个IP多播地址 224。0。64。32（即E0-00-40-20）转换成 以太网的硬件多播地址都是 01-00-5E-00-40-20。由于多播 IP 地址与以太网硬件地址的映射 • 179 •</p> <p>Page 190 关系不是唯一的，因此收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本 主机要接收的数据报丢弃。 ·这5位不使用 0 8 16 24 31 D 类 1110 IP 地址 0 1 0 0 5 E 00000001 00000000 010111100 表示多播 最低23位来自D类IP地址 48位以太网地址 图4-54 D类IP地址与以太网多播地址的映射关系 下面就讨论进行IP多播所需要的协议。 4。7。3 网际组管理协议IGMP 和多播路由选择协议 1。 IP多需要两种协议 图4-55是在互联网上传送多播数据报的例子。图中标有IP地址的四台主机都参加了一 个多播组，其组地址是226。15。37。123。显然，多播数据报应当传送到路由器Rı，R和R3， 而不应当传送到路由器R4，因为与R4连接的局域网上现在没有这个多播组的成员。但这些 路由器又怎样知道多播组的成员信息呢？这就要利用一个协议，叫做网际组管理协议 IGMP （Internet Group Management Protocol）。 135。27。74。52 参加多播组 226。15。37。123 128。56。24。34 未参加 多播组 参加多播组 226。15。37。123 R₁ IGMP 130。12。14。56 参加多播组 IGMP 226。15。37。123 IGMP R2 多播组 Ra 226。15。37。123 130。12。14。43 IGMP 参加多播组 226。15。37。123 未参加 多播组 Ral 未参加 未参加 多播组 多播组 图 4-55 IGMP 使多播路由器知道多播组成员信息 图 4-55 强调了 IGMP 的本地使用范围。请注意，IGMP 并非在互联网范围内对所有多 播组成员进行管理的协议。IGMP 不知道IP多播组包含的成员数，也不知道这些成员都分 布在哪些网络上，等等。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上 是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。 显然，仅有 IGMP 协议是不能完成多任务的。连接在局域网上的多播路由器还必须 和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成 员。这就需要使用多播路由选择协议。 • 180。</p> <p>Page 191 然而多播路由选择协议要比单播路由选择协议复杂得多。我们可以通过一个简单的例 子来说明（图4-56）。 N 多播组① R N， G F B E ˙多播组② 图4-56 用来说明多播路由选择的例子 我们假定图 4-56中有两个多播组。多播组①的成员有主机 A，B和C，而多播组②的 成员有主机 D，E和F。这些主机分布在三个网络上（N1，N2和N3）。 路由器 R 不应当向网络N，转发多播组①的分组，因为网络N，上没有多播组①的成 员。但是每一台主机可以随时加入或离开一个多播组。例如，如果主机 G 现在加入了多播 组①，那么从这时起，路由器 R 就必须也向网络 N； 转发多播组①的分组。这就是说，多播 转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由 选择通常是在网络拓扑发生变化时才需要更新路由。 再看一种情况。主机 E 和 F 都是多播组②的成员。当 E 向 F 发送多播数据报时，路由 器 R 把这个多播数据报转发到网络 N3。但当 F E 发送多播数据报时，路由器R则把多播 数据报转发到网络 Nz。如果路由器 R 收到来自主机A的多播数据报（A不是多播组②的成 员，但也可向多播组发送多播数据报），那么路由器R 就应当把多播数据报转发到 N2 和 N3。由此可见，多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地 址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。 还有一种情况。主机 G 没有参加任何多播组，但 G 却可向任何多播组发送多播数据 报。例如，G 可向多播组①或②发送多播数据报。主机 G 所在的局域网上可以没有任何多 播组的成员。显然，多播数据报所经过的许多网络，也不一定非要有多播组成员。总之，多 播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。 正因为如此，IP多播就成为比较复杂的问题。下面介绍这两种协议的要点。 2。 网际组管理协议 IGMP IGMP 已有了三个版本。1989年公布的RFC1112（IGMPv1）早已成为了互联网的标准 协议。2002年10月公布的建议标准IGMPv3是最新的[RFC 3376]。 和网际控制报文协议 ICMP 相似，IGMP 使用IP数据报传递其报文（即IGMP 报文加 上 IP 首部构成IP数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独 的协议，而是属于整个网际协议IP的一个组成部分。 从概念上讲，IGMP 的工作可分为两个阶段。 第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到IGMP报文后，还要利用 多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。 第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主 机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路 • 181 •</p> <p>Page 192 由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路 由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给 其他的多播路由器。 IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些 具体措施如下： （1） 在主机和多播路由器之间的所有通信都是使用IP多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加IP多播的主 机不会收到 IGMP 报文。 （2） 多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报 文，而不需要对每一个组发送一个询问报文（虽然也允许对一个特定组发送询问报文）。默 认的询问速率是每125 秒发送一次（通信量并不太大）。 （3）当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个 来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。 （4） 在 IGMP 的询问报文中有一个数值，它指明一个最长响应时间（默认值为 10 秒）。当收到询问时，主机在0到之间随机选择发送响应所需经过的时延。因此，若一台 主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的 响应最先发送。 （5） 同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自 己就可以不再发送响应了。这样就抑制了不必要的通信量。 多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据 报是使用硬件多播。多播路由器只需要知道网络上是否至少还有一台主机是本组成员即可。 实际上，对询问报文每一个组只需有一台主机发送响应。 如果一台主机上有多个进程都加入了某个多播组，那么这台主机对发给这个多播组的 每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。 最后我们还要强调指出，多播数据报的发送者和接收者都不知道（也无法找出）一个 多播组的成员有多少，以及这些成员是哪些主机。互联网中的路由器和主机都不知道哪个应 用进程将要向哪个多播组发送多播数据报，因为任何应用进程都可以在任何时候向任何一个 多播组发送多播数据报，而这个应用进程并不需要加入这个多播组。 IGMP 的报文格式可参阅有关文档[RFC 3376]，这里从略。 3。 多播路由选择协议 虽然在 TCP/IP 中IP多播协议已成为建议标准，但多播路由选择协议（用来在多播路由 器之间传播路由信息）则尚未标准化。 在多播过程中一个多播组中的成员是动态变化的。例如在收听网上某个广播节目时， 随时会有主机加入或离开这个多播组。多播路由选择实际上就是要找出以源主机为根节点的 多播转发树。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据 报，但在多播转发树上的路由器不会收到重复的多播数据报（即多播数据报不应在互联网中 兜圈子）。不难看出，对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的 源点也会有不同的多播转发树。 已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法： • 182 •</p> <p>Page 193 （1）洪泛与剪除。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相 邻接的。一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈 子，采用了叫做反向路径广播 RPB （Reverse Path Broadcasting）的策略。RPB 的要点是：每 一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进 行这种检查很容易，只要从本路由器寻找到源点的最短路径上（之所以叫做反向路径，因为 在计算最短路径时是把源点当作终点）的第一个路由器是否就是刚才把多播数据报送来的路 由器。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就 丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上（也就是说， 存在几条同样长度的最短路径），那么只能选择一条最短路径，选择的准则就是看这几条最 短路径中的相邻路由器的IP地址最小。图4-57的例子说明了这一概念。 R₂ 源点 转发多播数据报 X 收到后即丢弃 Rs 剪除没有 R4 组成员的树枝 图4-57 反向路径广播RPB 和剪除 为简单起见，在图4-57中的网络用路由器之间的链路来表示。我们假定各路由器之间 的距离都是 1。路由器 Rı 收到源点发来的多播数据报后，向R 和R] 转发。R， 发现 R， 就在 自己到源点的最短路径上，因此向 R， 和R4 转发收到的数据报。R， 发现 R， 不在自己到源点 的最短路径上，因此丢弃 R2 发来的数据报。其他路由器也这样转发。R， 到源点有两条最短 路径：R┐→R4→R2→Rı →源点；R→ R5 → R3 → R｣ → 源点。我们再假定 R4 的IP地址比 Rs 的 IP 地址小，所以我们只使用前一条最短路径。因此R， 只转发 Ra传过来的数据报，而丢弃 Rs 传过来的数据报。最后就得出了用来转发多播数据报的多播转发树（图中用粗线表示）， 以后就按这个多播转发树来转发多播数据报。这样就避免了多播数据报兜圈子，同时每一个 路由器也不会接收重复的多播数据报。 如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播 组的成员，就应把它和下游的树枝一起剪除。例如，在图 4-57中虚线椭圆表示剪除的部 分。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。 （2） 隧道技术（tunneling）。隧道技术适用于多播组的位置在地理上很分散的情况。例如 在图 4-58 中，网1和网2都支持多播。现在网1中的主机向网2中的一些主机进行多播。 但路由器 Rı 和 R2 之间的网络并不支持多播，因而R 和R，不能按多播地址转发数据报。为 此，路由器 Rı 就对多数据报进行再次封装，即再加上普通数据报首部，使之成为向单一 目的站发送的单播（unicast）数据报，然后通过“隧道”（tunnel）从R，发送到 R2。 • 183 •</p> <p>Page 194 网1和网2中 网1 （支持多播） 网 2 的多播数据报 （支持多播） 首部 数据 不支持多播 的网络 R2 首部 IP数据报的数据 隧道 隧道通行的 单播IP数据报 图4-58 隧道技术在多播中的应用 单播数据报到达路由器R后，再由路由器R剥去其首部，使它又恢复成原来的多播数 据报，继续向多个目的站转发。这一点和英吉利海峡隧道运送汽车的情况相似。英吉利海峡 隧道不允许汽车在隧道中行驶。但是，可以把汽车放置在隧道中行驶的电气火车上来通过隧 道。过了隧道后，汽车又可以继续在公路上行驶。这种使用隧道技术传送数据报又叫做IP 中的 IP （IP-in-IP）。 （3）基于核心的发现技术。这种方法对于多播组的大小在较大范围内变化时都适合。这 种方法是对每一个多播组 G 指定一个核心（core）路由器，给出它的IP 单播地址。核心路由器 按照前面讲过的方法创建出对应于多播组G 的转发树。如果有一个路由器，向这个核心路 由器发送数据报，那么它在途中经过的每一个路由器都要检查其内容。当数据报到达参加了 多播组 G 的路由器 Rą 时，R， 就处理这个数据报。如果 Rı 发出的是一个多播数据报，其目 的地址是 G 的组地址，R，就向多播组G 的成员转发这个多播数据报。如果R 发出的数据 报是一个请求加入多播组 G 的数据报，R，就把这个信息加到它的路由中，并用隧道技术向 Rı转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多 了，扩大了多播转发树的覆盖范围。 目前还没有在整个互联网范围使用的多播路由选择协议。下面是一些建议使用的多播 路由选择协议。 距离向量多播路由选择协议 DVMRP （Distance Vector Multicast Routing Protocol）是在互 联网上使用的第一个多播路由选择协议[RFC 1075]。由于在 UNIX 系统中实现 RIP 的程序叫 做 routed，所以在 routed 的前面加表示多播的字母m，叫做mrouted，它使用 DVMRP 在路 由器之间传播路由信息。 基于核心的转发树 CBT （Core Based Tree） [RFC 2189，2201]。这个协议使用核心路由器 作为转发树的根节点。一个大的自治系统 AS 可划分为几个区域，每一个区域选择一个核心 路由器（也叫做中心路由器 center router，或汇聚点路由器 rendezvous router）。 开放最短通路优先的多播扩展 MOSPF （Multicast extensions to OSPF） [RFC 1585]。这个 协议是单播路由选择协议 OSPF 的扩充，使用于一个机构内。MOSPF 使用多播链路状态路 由选择创建出基于源点的多播转发树。 协议无关多播-稀疏方式 PIM-SM （Protocol Independent Multicast-Sparse Mode） [RFC 4601]。这个协议使用和 CBT 同样的方法构成多播转发树。采用“协议无关”这个名词是強 调：虽然在建立多播转发树时是使用单播数据报来和远程路由器联系的，但这并不要求使用 特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。 协议无关多播-密集方式 PIM-DM （Protocol Independent Multicast-Dense Mode） [RFC 3973]。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。 • 184 •</p> <p>Page 195 PIM-DM 不使用核心路由器，而是使用洪泛方式转发数据报。</p> <h2 id="八虚拟专用网vpn-和网络地址转换-nat">八、虚拟专用网VPN 和网络地址转换 NAT</h2> <p>4。8。1 虚拟专用网 VPN 由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机 数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。 实际上，在许多情况下，很多主机主要还是和本机构内的其他主机进行通信（例如，在大型 商场或宾馆中，有很多用于营业和管理的计算机。显然这些计算机并不都需要和互联网相 连）。假定在一个机构内部的计算机通信也是采用TCP/IP 协议，那么从原则上讲，对于这些 仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。这就是说，让这些计算机 使用仅在本机构有效的IP地址（这种地址称为本地地址），而不需要向互联网的管理机构申 请全球唯一的 IP 地址（这种地址称为全球地址）。这样就可以大大节约宝贵的全球IP 地址 资源。 但是，如果任意选择一些 IP 地址作为本机构内部使用的本地地址，那么在某种情况下 可能会引起一些麻烦。例如，有时机构内部的某台主机需要和互联网连接，那么这种仅在内 部使用的本地地址就有可能和互联网中某个IP 地址重合，这样就会出现地址的二义性问 题。 为了解决这一问题，RFC 1918 指明了一些专用地址（private address）。这些地址只能用 于一个机构的内部通信，而不能用于和互联网上的主机通信。换言之，专用地址只能用做本 地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一 律不进行转发。2013 年 4 月，RFC 6890 全面地给出了所有特殊用途的IPv4地址，但三个 专用地址块的指派并无变化，即 （1） 10。0。0。0 10。255。255。255 （或记为10。0。0。0/8，它又称为24位块） （2） 172。16。0。0 172。31。255。255 （或记为172。16。0。0/12，它又称为20位块） （3） 192。168。0。0 192。168。255。255 （或记为192。168。0。0/16，它又称为16位块） 上面的三个地址块分别相当于一个A类网络、16个连续的B类网络和256个连续的C 类网络。A 类地址本来早已用完了，而上面的地址 10。0。0。0 本来是分配给 ARPANET 的。由 于 ARPANET 已经关闭停止运行了，因此这个地址就用作专用地址。 采用这样的专用 IP 地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫 做专用网。显然，全世界可能有很多的专用互连网络具有相同的专用 IP 地址，但这并不会 引起麻烦，因为这些专用地址仅在本机构内部使用。专用 IP 地址也叫做可重用地址 （reusable address）。 有时一个很大的机构的许多部门分布的范围很广（例如，在世界各地），这些部门经常 要互相交换信息。这可以有两种方法。（1）租用电信公司的通信线路为本机构专用。这种方 法虽然简单方便，但线路的租金太高，一般难于承受。（2）利用公用的互联网作为本机构各 专用网之间的通信载体，这样的专用网又称为虚拟专用网 VPN（Virtual Private Network）。 之所以称为“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不 是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的互联 • 185 •</p> <p>Page 196 网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。加密需要采用的协议 将在7。6。1 节讨论。“虚拟”表示“好像是”，但实际上并不是，因为现在并没有真正使用通 信专线，而 VPN只是在效果上和真正的专用网一样。一个机构要构建自己的VPN 就必须为 它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其 他场所的地址。 图 4-59 以两个场所为例说明如何使用IP隧道技术实现虚拟专用网。 假定某个机构在两个相隔较远的场所建立了专用网 A 和 B，其网络地址分别为专用地 址 10。1。0。0 和 10。2。0。0。现在这两个场所需要通过公用的互联网构成一个 VPN。 显然，每一个场所至少要有一个路由器具有合法的全球IP地址，如图4-59（a）中的路由 器 Rı 和 R2。这两个路由器和互联网的接口地址必须是合法的全球IP 地址。路由器 R」 和 R2 在专用网内部网络的接口地址则是专用网的本地地址。 加密的从X到Y的内部数据报 源地址：125。1。2。3 目的地址：194。4。5。6 外部数据报的数据部分 外部数据报 数据报首部 场所A 125。1。2。3 194。4。5。6 场所 B X 隧道 Y 10。2。0。0 10。1。0。0 10。2。0。3 10。1。0。1 互联网 （a）使用隧道技术 场所 A 虚拟专用网VPN 场所 B X Y 10。2。0。0 10。1。0。0 10。2。0。3 10。1。0。1 （b）构成虚拟专用网 图4-59 用隧道技术实现虚拟专用网 在每一个场所 A或B内部的通信量都不经过互联网。但如果场所A的主机 X 要和另一 个场所 B 的主机Y通信，那么就必须经过路由器R 和R2。主机 X 向主机 Y 发送的 IP 数据 报的源地址是 10。1。0。1，而目的地址是10。2。0。3。这个数据报先作为本机构的内部数据报从X 发送到与互联网连接的路由器Rı。路由器 R， 收到内部数据报后，发现其目的网络必须通过 互联网才能到达，就把整个的内部数据报进行加密（这样就保证了内部数据报的安全），然 后重新加上数据报的首部，封装成为在互联网上发送的外部数据报，其源地址是路由器 Rı 的全球地址 125。1。2。3，而目的地址是路由器R的全球地址 194。4。5。6。路由器，收到数据报 后将其数据部分取出进行解密，恢复出原来的内部数据报（目的地址是10。2。0。3），交付主机 Y。可见，虽然 X 向 Y 发送的数据报是通过了公用的互联网，但在效果上就好像是在本部 门的专用网上传送一样。如果主机Y要向X发送数据报，那么所进行的步骤也是类似的。 请注意，数据报从R 传送到 R， 可能要经过互联网中的很多个网络和路由器。但从逻辑 • 186 •</p> <p>Page 197 上看，在 Rı到R，之间好像是一条直通的点对点链路，图4-59（a）中的“隧道”就是这个意 思。 如图 4-59（b）所示的、由场所 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为内联 网（intranet 或intranet VPN，即内联网VPN），表示场所A和B都属于同一个机构。 有时一个机构的 VPN 需要有某些外部机构（通常就是合作伙伴）参加进来。这样的 VPN 就称为外联网（extranet 或extranet VPN，即外联网 VPN）。 请注意，内联网和外联网都采用了互联网技术，即都是基于TCP/IP协议的。 还有一种类型的VPN，就是远程接入 VPN （remote access VPN）。我们知道，有的公司 可能并没有分布在不同场所的部门，但却有很多流动员工在外地工作。公司需要和他们保持 联系，有时还可能一起开电话会议或视频会议。远程接入 VPN 可以满足这种需求。在外地 工作的员工通过拨号接入互联网，而驻留在员工个人电脑中的 VPN 软件可以在员工的个人 电脑和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容也是保密的，员工 们感到好像就是使用公司内部的本地网络。 4。8。2网络地址转换 NAT 下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地 IP 地址 （即仅在本专用网内使用的专用地址），但现在又想和互联网上的主机通信（并不需要加 密），那么应当采取什么措施呢？ 最简单的办法就是设法再申请一些全球IP地址。但这在很多情况下是不容易做到的， 因为全球 IPv4 的地址已所剩不多了。目前使用得最多的方法是采用网络地址转换。 网络地址转换 NAT （Network Address Translation）方法是在1994年提出的。这种方法需 要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路 由器，它至少有一个有效的外部全球IP 地址。这样，所有使用本地地址的主机在和外界通 信时，都要在 NAT 路由器上将其本地地址转换成全球IP地址，才能和互联网连接。 图 4-60 给出了NAT 路由器的工作原理。在图中，专用网 192。168。0。0 内所有主机的 IP 地址都是本地 IP地址 192。168。x。x。NAT 路由器至少要有一个全球IP地址，才能和互联网相 连。图 4-60 表示出 NAT 路由器有一个全球 IP 地址 172。38。1。5（当然，NAT 路由器可以有多 个全球 IP 地址）。 全球IP地址 专用网192。168。0。0 172。38。1。5 主机B 源IP 地址 213。18。2。4 主机A 192。168。0。3 192。168。0。3 源 IP 地址 172。38。1。5 互联网 NAT 路由器 目的IP 地址 192。168。0。3 目的IP地址 172。38。1。5 图4-60 NAT路由器的工作原理 NAT 路由器收到从专用网内部的主机 A 发往互联网上主机 B 的 IP数据报：源IP地址 是 192。168。0。3，而目的 IP 地址是213。18。2。4。NAT 路由器把IP数据报的源 IP 地址 • 187•</p> <p>Page 198 192。168。0。3，转换为新的IP地址（即NAT 路由器的全球IP地址） 172。38。1。5，然后转发 出去。因此，主机B收到这个IP数据报时，以为A的IP地址是172。38。1。5。当B给A发 送应答时，IP数据报的目的IP地址是NAT路由器的IP地址172。38。1。5。B并不知道A的专 用地址 192。168。0。3。实际上，即使知道了，也不能使用，因为互联网上的路由器都不转发目 的地址是专用网本地IP地址的IP数据报。当NAT路由器收到互联网上的主机B发来的IP 数据报时，还要进行一次IP地址的转换。通过NAT 地址转换表，就可把IP数据报上的旧 的目的 IP 地址172。38。1。5，转换为新的目的IP地址192。168。0。3（主机A真正的本地IP地 址）。表 4-11 给出了NAT 地址转换表的举例。表中的前两行数据对应于图4-60中所举的例 子。第一列“方向”中的“出”表示离开专用网，而“入”表示进入专用网。表中后两行数 据（图4-60中没有画出对应的IP数据报）表示专用网内的另一主机192。168。0。7 向互联网发 送了IP数据报，而NAT路由器还有另外一个全球IP地址172。38。1。6。 表4-11 NAT地址转换表举例 方向 字段 旧的 IP 地址 新的 IP 地址 出 源 IP 地址 入 目的 IP 地址 192。168。0。3 172。38。1。5 172。38。1。5 192。168。0。3 出 入 源 IP 地址 目的 IP 地址 192。168。0。7 172。38。1。6 172。38。1。6 192。168。0。7 由此可见，当 NAT 路由器具有n个全球 IP 地址时，专用网内最多可以同时有n 台主机 接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的 全球IP地址。 显然，通过 NAT 路由器的通信必须由专用网内的主机发起。设想互联网上的主机要发 起通信，当 IP 数据报到达 NAT 路由器时，NAT 路由器就不知道应当把目的IP 地址转换成 专用网内的哪一个本地IP 地址。这就表明，这种专用网内部的主机不能充当服务器用，因 为互联网上的客户无法请求专用网内的服务器提供服务。 为了更加有效地利用 NAT 路由器上的全球IP 地址，现在常用的 NAT 转换表把运输层 的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的 全球 IP 地址，因而可以同时和互联网上的不同主机进行通信[COME06]。 由于运输层的端口号将在下一章 5。1。3 节讨论，因此，建议在学完运输层的有关内容 后，再学习下面的内容。从系统性考虑，把下面的这部分内容放在本章中介绍较为合适。 使用端口号的 NAT 也叫做网络地址与端口号转换 NAPT （Network Address and Port Translation），而不使用端口号的NAT 就叫做传统的NAT （traditional NAT）。但在许多文献中 并没有这样区分，而是不加区分地都使用 NAT 这个更加简洁的缩写词。表 4-12 说明了 NAPT 的地址转换机制。 表4-12 NAPT 地址转换表举例 方向 字段 出 源 IP 地址：TCP 源端口 出 源IP 地址：TCP 源端口 入 目的IP 地址：TCP 目的端口 入 目的 IP 地址：TCP 目的端口 192。168。0。4：30000 172。38。1。5：40001 172。38。1。5：40002 192。168。0。4：30000 旧的IP 地址和端口号 新的IP地址和端口号 192。168。0。3：30000 172。38。1。5：40001 172。38。1。5：40002 192。168。0。3：30000 • 188。 •</p> <p>Page 199 从表 4-12 可以看出，在专用网内主机 192。168。0。3 向互联网发送IP数据报，其 TCP 端 口号选择为 30000。NAPT 把源IP地址和TCP端口号都进行转换（如果使用UDP，则对 UDP 的端口号进行转换。原理是一样的）。另一台主机192。168。0。4 也选择了同样的 TCP 端 口号 30000。这纯属巧合（端口号仅在本主机中才有意义）。现在 NAPT 把专用网内不同的 源 IP 地址都转换为同样的全球IP地址。但对源主机所采用的TCP端口号（不管相同或不 同），则转换为不同的新的端口号。因此，当NAPT 路由器收到从互联网发来的应答时，就 可以从 IP 数据报的数据部分找出运输层的端口号，然后根据不同的目的端口号，从NAPT 转换表中找到正确的目的主机。 应当指出，从层次的角度看，NAPT的机制有些特殊。普通路由器在转发IP数据报 时，对于源 IP地址或目的IP地址都是不改变的。但NAT 路由器在转发IP数据报时，一定 要更换其IP地址（转换源IP地址或目的IP地址）。其次，普通路由器在转发分组时，是工 作在网络层。但NAPT 路由器还要查看和转换运输层的端口号，而这本来应当属于运输层 的范畴。也正因为这样，NAPT 曾遭受了一些人的批评，认为NAPT的操作没有严格按照 次的关系。但不管怎样，NAT（包括NAPT）已成为互联网的一个重要构件。有关 NAT 的 详细讨论可参阅建议标准 RFC3022 和IETF 关于 NAT 工作组的网站[W-NAT]。</p> <h2 id="九多协议标记交换-mpls">九、多协议标记交换 MPLS</h2> <p>IETF于1997年成立了MPLS工作组，为的是开发出一种新的协议。这种新的协议就是 多协议标记交换MPLS （MultiProtocol Label Switching）。“多协议”表示在MPLS 的上层可以 采用多种协议。IETF 还综合了许多公司的类似技术，如Cisco 公司的标记交换 TAG （TAG Switching），以及Ipsilon 公司的IP交换（IP Switching）等。2001年1月MPLS终于成为互联 网的建议标准[RFC 3031，3032][W-MPLS]。 MPLS 利用面向连接技术，使每个分组携带一个叫做标记（label）的小整数（这叫做打 上标记）。当分组到达交换机（即标记交换路由器）时，交换机读取分组的标记，并用标记 值来检索分组转发表。这样就比查找路由表来转发分组要快得多。 人们经常把 MPLS与异步传递方式 ATM （Asynchronous Transfer Mode）联系起来，这仅 仅是因为它们都采用了面向连接的工作方式。以前很多人都曾认为网络的发展方向是以 ATM 为核心的宽带综合业务数字 B-ISDN。然而价格低廉得多的高速IP路由器仍然占领了 市场，最终导致 ATM 技术和 B-ISDN 未能够成为网络的发展方向。MPLS 并没有取代IP， 而是作为一种IP增强技术，被广泛地应用在互联网中。 MPLS 具有以下三个方面的特点：（1）支持面向连接的服务质量。（2） 支持流量工程， 平衡网络负载。（3）有效地支持虚拟专用网 VPN。 下面讨论 MPLS 的基本工作原理。 ① 注：label 的标准译名本来是“标号”，但目前在MPLS 中的 label 常译为“标记”。在文献中也还有译为“标签”的。 • 189。</p> <p>Page 200 4。9。1 MPLS 的工作原理 1。基本工作过程 在传统的IP网络中，分组每到达一个路由器，都必须查找路由表，并按照“最长前缀 匹配”的原则找到下一跳的IP地址（请注意，前缀的长度是不确定的。当网络很大时，查 找含有大量项目的路由表要花费很多的时间。在出现突发性的通信量时，往往还会使缓存溢 出，这就会引起分组丢失、传输时延增大和服务质量下降。 MPLS 的一个重要特点就是在 MPLS 域的入口处，给每一个IP数据报打上固定长度 “标记”，然后对打上标记的IP数据报用硬件进行转发，这就使得IP数据报转发的过程大 大地加快了。采用硬件技术对打上标记的IP数据报进行转发就称为标记交换。“交换”也 表示在转发时不再上升到第三层查找转发表，而是根据标记在第二层（链路层）用硬件进行 转发。MPLS 可使用多种链路层协议，如PPP、以太网、ATM 以及帧中继等。图4-61 是 MPLS 协议的基本原理的示意图。 MPLS 域 打上标记 B 去除标记 LDP LDP ☑ LDP 3 2 打上标记 的分组 \的分组 打上标记 2 打上标记 的分组 MPLS MPLS 入口结点 X 出口结点 ☑ 普通IP分组 打上标记的分组 普通路由器 范 标记交换路由器 LSR 图4-61 MPLS 协议的基本原理 MPLS 域（MPLS domain）是指该域中有许多彼此相邻的路由器，并且所有的路由器都是 支持 MPLS 技术的标记交换路由器 LSR （Label Switching Router）。 LSR 同时具有标记交换和 路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择 功能构造转发表。 图4-61 中给出了MPLS 的基本工作过程如下： （1） MPLS 域中的各 LSR 使用专门的标记分配协议 LDP （Label Distribution Protocol）交换 报文，并找出和特定标记相对应的路径，即标记交换路径 LSP（Label Switched Path）。例如 在图中的路径 A→B→C→D。各LSR 根据这些路径构造出转发表。这个过程和路由器构造 自己的路由表相似[RFC 3031]，限于篇幅，这里不讨论转发表构造的详细步骤。但应注意的 是，MPLS 是面向连接的，因为在标记交换路径LSP上的第一个 LSR 就根据IP数据报的初 始标记确定了整个的标记交换路径，就像一条虚连接一样。 ① 注：有的公司愿意用“第三层交换”表示“第三层的路由选择功能加上第二层的交换功能”。但这样的术语不够明确， 因而编者不主张使用这一术语。 190。</p> <p>Page 201 （2） 当一个 IP 数据报进入到MPLS 域时，MPLS 入口结点（ingress node）就给它打上标记 （后面我们就会知道，这实际上是插入一个 MPLS 首部），并按照转发表把它转发给下一个 LSR。以后的所有LSR都按照标记进行转发。 给 IP 数据报打标记的过程叫做分类（classification）。严格的第三层（网络层）分类只使用 了 IP 首部中的字段，如源IP地址和目的IP地址等。大多数运营商实现了第四层（运输层） 分类（除了要检查IP首部外，运输层还要检查TCP或UDP 首部中的协议端口号），而有些运 营商则实现了第五层（应用层）分类（更进一步地检查数据报的内部并考虑其有效载荷）。 （3）由于在全网内统一分配全局标记数值是非常困难的，因此一个标记仅仅在两个标记 交换路由器 LSR 之间才有意义。分组每经过一个 LSR，LSR 就要做两件事：一是转发，二 是更换新的标记，即把入标记更换成为出标记。这就叫做标记对换（label swapping）。做这 两件事所需的数据都已清楚地写在转发表中。例如，图 4-61 中的标记交换路由器B 从入接 口0收到一个入标记为3的IP数据报，查找了如下的转发表： 入接口 0 入标记 出接口 出标记 3 1 1 为1。 标记交换路由器B就知道应当把该IP数据报从出接口 1 转发出去，同时把标记对换 当IP数据报进入下一个LSR时，这时的入标记就是刚才得到的出标记。因此，标记交 换路由器C接着在转发该IP数据报时，又把入标记1对换为出标记2。 （4） 当 IP 数据报离开 MPLS 域时，MPLS 出口结点（egress node）就把 MPLS 的标记去 除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。 上述的这种“由入口 LSR 确定进入 MPLS 域以后的转发路径”称为显式路由选择 （explicit routing），它和互联网中通常使用的“每一个路由器逐跳进行路由选择”有着很大的 区别。 下面再讨论 MPLS 中的几个重要概念。 2。 转发等价类 FEC MPLS 有个很重要的概念就是转发等价类 FEC （Forwarding Equivalence Class）。所谓 “转发等价类”就是路由器按照同样方式对待的IP 数据报的集合。这里“按照同样方式对 待”表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级 等。FEC 的例子是： （1） 目的 IP 地址与某一个特定 IP 地址的前缀匹配的IP 数据报（这就相当于普通的 IP 路由器）； （2） 所有源地址与目的地址都相同的 IP 数据报； （3） 具有某种服务质量需求的 IP 数据报。 总之，划分 FEC 的方法不受什么限制，这都由网络管理员来控制，因此非常灵活。入 口结点并不是给每一个IP数据报指派一个不同的标记，而是将属于同样 FEC 的 IP 数据报 ① 注：这里使用[RFC 3031]中的标准词汇。“对换”和“交换”的意思相近，但“对换”更强调两个标记互相对换（把入 标记更换为出标记）。虽然MPLS 中的LS是表示“标记交换”，但标记交换路由器LSR实现的功能是“标记对换”。 • 191。</p> <p>Page 202 都指派同样的标记。FEC 和标记是一一对应的关系。 图 4-62 给出一个把 FEC 用于负载平衡的例子。图4-62（a）的主机H 和H2分别向H，和 H4 发送大量数据。路由器A和C是数据传输必须经过的。但传统的路由选择协议只能选择 最短路径A→B→C，这就可能导致这段最短路径过载。 H B H₂ （a） 传统路由选择协议使最短路径A→B→C过载 H， H B H₁ H A H₂ Ha （b） 利用FEC使通信量较为均衡 图4-62 FEC用于负载平衡 图 4-62（b）表示在 MPLS 的情况下，入口结点 A 可设置两种 FEC：“源地址为 H 而目的 地址为 Hţ”和“源地址为 H， 而目的地址为 H4”，把前一种 FEC 的路径设置为 Hı→A→B→ C→H3，而后一种的路径设置为 H2→A→D→E→C→H4。这样可使网络的负载较为平衡。网 络管理员采用自定义的 FEC 就可以更好地管理网络的资源。这种均衡网络负载的做法也称 为流量工程 TE （Traffic Engineering）或通信量工程。 4。9。2 MPLS 首部的位置与格式 MPLS 并不要求下层的网络都使用面向连接的技术。因此一对 MPLS 路由器之间的物理 连接，既可以由一个专用电路组成，如 OC-48 线路，也可以使用像以太网这样的网络。但 是这些网络并不提供打标记的手段，而IPv4 数据报首部也没有多余的位置存放 MPLS 标 记。这就需要使用一种封装技术：在把IP数据报封装成以太网帧之前，先要插入一个 MPLS 首部。从层次的角度看，MPLS 首部就处在第二层和第三层之间（图 4-63）。在把加 上 MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为 884716，而在多播的情况下为884816。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的IP数据报。 网络层 MPLS 首部 插入 数据链路层 图4-63 MPLS 首部的位置 图4-64 给出了 MPLS 首部的格式。可见“给IP数据报打上标记”其实就是在以太网的 帧首部和 IP 数据报的首部之间插入一个4字节的 MPLS 首部。具体的标记就在“标记值” 这个字段中。 ① 注：流量工程是对网络上的通信量进行测量、建模和控制，使网络运行的性能得到最优化。 • 192 •</p> <p>Page 203 位 20 3 1 8 标记值 试验 S 生存时间 TTL 以太网帧 帧首部MPLS 首部IP首部 IP 数据 部 分 帧尾部 IP数据报 发送在前 图4-64 MPLS 首部的格式 占 20 位。由于一个 MPLS 标记占 20位，因此从理论上讲，在设置 MPLS 首部共包括以下四个字段： （1） 标记值 MPLS 时可以使用标记的所有 20 位，因而可以同时容纳高达220个流（即1048576个流）。 但是，实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管 理和设置每条交换路径。 （2） 试验 占3位，目前保留用于试验。 （3） 栈 S 占1位，在有“标记栈”时使用。 （4） 生存时间 TTL 占8位，用来防止 MPLS 分组在MPLS 域中兜圈子。 本章的重要概念 • TCP/IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数 据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组 可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。 • IP 网是虚拟的，因为从网络层上看，IP网就是一个统一的、抽象的网络（实际上 是异构的）。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统 一的、抽象的 IP 地址处理主机之间的通信问题。 在互联网上的交付有两种：在本网络上的直接交付（不经过路由器）和到其他网络 的间接交付（经过至少一个路由器，但最后一次一定是直接交付）。 一个 IP 地址在整个互联网范围内是唯一的。分类的IP 地址包括 A 类、B 类和 C 类地址（单播地址），以及D类地址（多播地址）。E类地址未使用。 分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络 号字段最前面的类别位指明IP地址的类别。 • IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络 号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的 网络号来转发分组。 • IP 地址标志一台主机（或路由器）和一条链路的接口。多归属主机同时连接到两 个或更多的网络上。这样的主机同时具有两个或更多的IP 地址，其网络号必须是 不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两 个不同的 IP 地址。 按照互联网的观点，用转发器或网桥连接起来的若干个局域网仍为一个网络。所有 分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广 域网）都是平等的。 物理地址（即硬件地址）是数据链路层和物理层使用的地址，而 IP 地址是网络层 • 193。</p> <p>Page 204 • • 194 • 和以上各层使用的地址，是一种逻辑地址（用软件实现的），在数据链路层看不见 数据报的IP 地址。 IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所 有IP数据报必须具有的（源地址、目的地址，总长度等重要字段都在固定首部 中）。一些长度可变的可选字段放在固定首部的后面。 IP 首部中的生存时间字段给出了IP数据报在互联网中所能经过的最大路由器数， 可防止IP 数据报在互联网中无限制地兜圈子。 地址解析协议 ARP 把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由 器的 IP 地址和硬件地址的映射问题。ARP 的高速缓存可以大大减少网络上的通信 量。 在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。 无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指 明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”。IP地址的分配都以CIDR 地址块为单位。 CIDR 的 32 位地址掩码（或子网掩码）由一串 1 和一串0组成，而1的个数就是 前缀的长度。只要把 IP 地址和地址掩码逐位进行“逻辑与（AND）”运算，就很 容易得出网络地址。A类地址的默认地址掩码是 255。0。0。0。B类地址的默认地址掩 码是255。255。0。0C类地址的默认地址掩码是255。255。255。0。 路由聚合（把许多前缀相同的地址用一个来代替）有利于减少路由表中的项目，减 少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 “转发”和“路由选择”有区别。“转发”是单个路由器的动作。“路由选择”是许 多路由器共同协作的过程，这些路由器相互交换信息，目的是生成路由表，再从路 由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转 发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使 用路由表这一名词。 自治系统（AS）就是在单一的技术管理下的一组路由器。一个自治系统对其他自 治系统表现出的是一个单一的和一致的路由选择策略。 路由选择协议有两大类：内部网关协议（或自治系统内部的路由选择协议），如 RIP 和 OSPF；外部网关协议（或自治系统之间的路由选择协议），如BGP-4。 RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按固定 的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自 治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器。 OSPF 是分布式的链路状态协议，适用于大型互联网。OSPF 只在链路状态发生变 化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由 器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路 的“度量”。“度量”可表示费用、距离、时延、带宽等，可统称为“代价”。所有 的路由器最终都能建立一个全网的拓扑结构图。 BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协</p> <p>Page 205 习题 • • • 议。BGP 力求寻找一条能够到达目的网络（可达）且比较好的路由（不兜圈子）， 而并非要寻找一条最佳路由。 网际控制报文协议ICMP是IP层的协议。ICMP报文作为IP数据报的数据，加上 首部后组成 IP数据报发送出去。使用ICMP并非为了实现可靠传输。ICMP 允许 主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两 种，即 ICMP差错报告报文和 ICMP 询问报文。 ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通 性。PING 使用了ICMP 回送请求与回送回答报文。 要解决 IP 地址耗尽的问题，最根本的办法就是采用具有更大地址空间的新版本的 IP 协议，即 IPv6。 IPv6 所带来的主要变化是：（1）更大的地址空间（采用128位的地址）； （2） 灵活的 首部格式；（3） 改进的选项；（4） 支持即插即用；（5）支持资源的预分配；（6） IPv6 首部改为8字节对齐。 IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有 的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。 IPv6 的地址使用冒号十六进制记法。 向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的IPv6系统能够向后兼容。 向 IPv6 过渡可以使用双协议栈或使用隧道技术。 • 与单播相比，在一对多的通信中，IP多播可大大节约网络资源。IP多播使用 D 类 IP 地址。IP 多播需要使用网际组管理协议 IGMP 和多播路由选择协议。 虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体。VPN 内 部使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球IP 地 址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送 的数据都必须加密。 使用网络地址转换NAT技术，可以在专用网络内部使用专用IP 地址，而仅在连接 到互联网的路由器使用全球IP地址。这样就大大节约了宝贵的 IP 地址。 MPLS 的特点： （1） 支持面向连接的服务质量；（2） 支持流量工程，平衡网络负 载；（3）有效地支持虚拟专用网 VPN。 MPLS 在入口结点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第 二层（链路层）用硬件进行转发（在标记交换路由器中进行标记对换），因而转发 速率大大加快。 4-01 网络层向上提供的服务有哪两种？试比较其优缺点。 4-02 网络互连有何实际意义？进行网络互连时，有哪些共同的问题需要解决？ 4-03 作为中间设备，转发器、网桥、路由器和网关有何区别？ 4-04 试简单说明下列协议的作用： 4-05 IP， ARP， RARP 和ICMP。 IP 地址分为几类？各如何表示？IP地址的主要特点是什么？ • 195 •</p>]]></content><author><name></name></author></entry><entry><title type="html">计算机网络 - 应用层</title><link href="https://feng-zhang0712.github.io//blog/2024/application-layer/" rel="alternate" type="text/html" title="计算机网络 - 应用层"/><published>2024-09-15T00:00:00+00:00</published><updated>2024-09-15T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/application-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/application-layer/"><![CDATA[]]></content><author><name></name></author><category term="computer"/><category term="computer"/><category term="networks"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">计算机网络 - 运输层</title><link href="https://feng-zhang0712.github.io//blog/2024/transport-layer/" rel="alternate" type="text/html" title="计算机网络 - 运输层"/><published>2024-09-14T00:00:00+00:00</published><updated>2024-09-14T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/transport-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/transport-layer/"><![CDATA[]]></content><author><name></name></author><category term="computer"/><category term="computer"/><category term="networks"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">响应式 Web 设计</title><link href="https://feng-zhang0712.github.io//blog/2024/responsive-web-design/" rel="alternate" type="text/html" title="响应式 Web 设计"/><published>2024-09-14T00:00:00+00:00</published><updated>2024-09-14T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/responsive-web-design</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/responsive-web-design/"><![CDATA[<h2 id="一简介">一、简介</h2> <p>响应式 Web 设计，指网页内容会随着访问它的视口及设备的不同而呈现不同的样式。</p> <p>在响应式设计的早期，人们会针对不同的流行的设备宽度设置<strong>断点</strong>，所谓“断点”，就是某个宽度临界点，跨过这个点布局就会发生显著变化。显然，这并不是一个好的做法，因为这样实际上把设计跟特定的屏幕大小绑定了。既然是响应式设计，那应该与显示它的设备无关才对，而不是只在某些屏幕中才最合适。断点应该由内容和设计本身决定，也就是，根据项目的实际需求设计决定。</p> <h2 id="二媒体查询">二、媒体查询</h2> <p><strong>媒体查询</strong>（Media Queries）主要用于设计响应式 Web 设计，使网页能够适应不同的设备和屏幕尺寸。即根据设备的特性（如屏幕宽度、高度、分辨率等）应用不同的样式。W3C 对媒体查询的定义是：媒体查询包含媒体类型和零个或多个检测媒体特性的表达式（比如，<code class="language-plaintext highlighter-rouge">width</code>、<code class="language-plaintext highlighter-rouge">height</code> 和 <code class="language-plaintext highlighter-rouge">color</code> 都是可用于媒体查询的特性）。使用媒体查询，可以不必修改内容本身，而让网页适配不同的设备。</p> <p>常用媒体特性如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">width</code>：视口的宽度。</li> <li><code class="language-plaintext highlighter-rouge">height</code>：视口的高度。</li> <li><code class="language-plaintext highlighter-rouge">device-width</code>：设备屏幕的宽度。</li> <li><code class="language-plaintext highlighter-rouge">device-height</code>：设备屏幕的高度。</li> <li><code class="language-plaintext highlighter-rouge">resolution</code>：设备屏幕的分辨率，通常以 <code class="language-plaintext highlighter-rouge">dpi</code>（每英寸点数）或 <code class="language-plaintext highlighter-rouge">dppx</code>（每像素点数）表示。</li> <li><code class="language-plaintext highlighter-rouge">orientation</code>：设备的方向，可以是 <code class="language-plaintext highlighter-rouge">portrait</code> 或 <code class="language-plaintext highlighter-rouge">landscape</code>。</li> <li><code class="language-plaintext highlighter-rouge">aspect-ratio</code>：视口的宽高比。不如，16∶9 的宽屏显示器可以写成 <code class="language-plaintext highlighter-rouge">aspect-ratio: 16/9</code>。</li> <li><code class="language-plaintext highlighter-rouge">color</code>：设备的颜色位深。</li> <li><code class="language-plaintext highlighter-rouge">color-index</code>：设备颜色查找表中的条目数，值必须是数值，且不能为负。</li> <li><code class="language-plaintext highlighter-rouge">monochrome</code>：单色帧缓冲中表示每个像素的位数，值必须是数值（整数），比如 <code class="language-plaintext highlighter-rouge">monochrome: 2</code>，且不能为负。</li> <li><code class="language-plaintext highlighter-rouge">scan</code>：针对电视的逐行扫描（progressive）和隔行扫描（interlace）。例如 720p HD TV（720p 中的 <code class="language-plaintext highlighter-rouge">p</code> 表示 progressive，即逐行）可以使用 <code class="language-plaintext highlighter-rouge">scan: progressive</code> 来判断； 而 1080i HD TV（1080i 中的 <code class="language-plaintext highlighter-rouge">i</code> 表示 interlace，即隔行）可以使用 <code class="language-plaintext highlighter-rouge">scan: interlace</code> 来判断。</li> <li><code class="language-plaintext highlighter-rouge">grid</code>：设备基于栅格还是位图。</li> </ul> <p>上面列表中的特性，除 <code class="language-plaintext highlighter-rouge">grid</code> 外，都可以加上 <code class="language-plaintext highlighter-rouge">min-</code> 或 <code class="language-plaintext highlighter-rouge">max-</code> 前缀以指定范围。</p> <h3 id="21-媒体查询的语法">2.1 媒体查询的语法</h3> <p>下面是一个最简单的媒体查询语法结构。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@media</span> <span class="n">media-type</span> <span class="n">and</span> <span class="p">(</span><span class="n">media-feature</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">/* CSS规则 */</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">media-type</code>：指定设备类型，如 <code class="language-plaintext highlighter-rouge">screen</code>、<code class="language-plaintext highlighter-rouge">print</code> 等。可以省略，表示适用于所有类型（此时 <code class="language-plaintext highlighter-rouge">media-type: all</code>）。</li> <li><code class="language-plaintext highlighter-rouge">media-feature</code>：指定的媒体特性，如 <code class="language-plaintext highlighter-rouge">max-width</code>、<code class="language-plaintext highlighter-rouge">min-width</code> 等。</li> </ul> <p>也可以在 <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性中指定设备类型。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"style sheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">media=</span><span class="s">"screen"</span> <span class="na">href=</span><span class="s">"style.css"</span><span class="nt">&gt;</span> 
</code></pre></div></div> <h3 id="22-组合媒体查询">2.2 组合媒体查询</h3> <p>多个媒体查询组合，使用逗号（<code class="language-plaintext highlighter-rouge">,</code>）分隔不同的查询条件。表示如果任意一个条件为真则应用样式。还可以使用逻辑运算符 <code class="language-plaintext highlighter-rouge">and</code>、<code class="language-plaintext highlighter-rouge">or</code>、<code class="language-plaintext highlighter-rouge">not</code> 组合多个条件。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* 适用于屏幕最大宽度为600px或屏幕高度为 800px 的设备 */</span>
<span class="k">@media</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">),</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-height</span><span class="p">:</span> <span class="m">800px</span><span class="p">)</span> <span class="p">{</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">lightblue</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c">/* 适用于屏幕宽度在 600px 到 1200px 之间且横向模式的设备 */</span>
<span class="k">@media</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">min-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span> <span class="m">1200px</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">orientation</span><span class="p">:</span> <span class="nb">landscape</span><span class="p">)</span> <span class="p">{</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">lightgreen</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以在使用 <code class="language-plaintext highlighter-rouge">@import</code> 导入 CSS 时使用媒体查询，有条件地向当前样式表中加载其他样式表。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@import</span> <span class="sx">url("phone.css")</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span><span class="m">360px</span><span class="p">);</span> 
</code></pre></div></div> <p>上面的代码表示，<code class="language-plaintext highlighter-rouge">phone.css</code> 样式表生效的条件是：设备类型必须是屏幕设备，且视口不超过 360px。</p> <p>注意，在针对所有设备的媒体查询中，可以使用简写语法，即省略关键字 <code class="language-plaintext highlighter-rouge">all</code>（以及紧随其后的 <code class="language-plaintext highlighter-rouge">and</code>）。换句话说，如果不指定关键字，则关键字就是 <code class="language-plaintext highlighter-rouge">all</code>。</p> <h3 id="23-视口的-meta-标签">2.3 视口的 meta 标签</h3> <p>视口的 <code class="language-plaintext highlighter-rouge">meta</code> 标签，是网页与移动浏览器的接口。网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。视口的 <code class="language-plaintext highlighter-rouge">meta</code> 标签主要使用以下几个属性控制页面在移动端的行为。</p> <ul> <li><code class="language-plaintext highlighter-rouge">width</code>：用于设置页面的宽度。</li> <li><code class="language-plaintext highlighter-rouge">height</code>：用于设置页面的高度，通常设置了 <code class="language-plaintext highlighter-rouge">width</code> 就不会再设置 <code class="language-plaintext highlighter-rouge">height</code>。</li> <li><code class="language-plaintext highlighter-rouge">initial-scale</code>：设置页面的初始缩放比例。</li> <li><code class="language-plaintext highlighter-rouge">user-scalable</code>：一个布尔值，用于设置页面是否可以缩放。</li> <li><code class="language-plaintext highlighter-rouge">minimum-scale</code>：设置页面的最小缩放比例，只有在 <code class="language-plaintext highlighter-rouge">user-scalable=true</code> 时，此属性才会生效。</li> <li><code class="language-plaintext highlighter-rouge">maximum-scale</code>：设置页面的最大缩放比例，只有在 <code class="language-plaintext highlighter-rouge">user-scalable=true</code> 时，此属性才会生效。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">meta</span> <span class="nt">name</span><span class="o">=</span><span class="s1">"viewport"</span> <span class="nt">content</span><span class="o">=</span><span class="s1">"width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=0.5, maximum-scale=3"</span> <span class="o">/&gt;</span> 
</code></pre></div></div> <p>上面的代码表示，在移动设备上，页面的宽度为设备宽度，页面初始的缩放比例为 1，允许用户进行缩放操作，且最小和最大缩放比例分别为 0.5 和 3。</p> <h2 id="三弹性布局网格布局与响应式图片">三、弹性布局、网格布局与响应式图片</h2> <p>布局的传统解决方案，基于盒状模型，依赖 <code class="language-plaintext highlighter-rouge">display</code> + <code class="language-plaintext highlighter-rouge">position</code> + <code class="language-plaintext highlighter-rouge">float</code> 等属性。而现代的布局方案，更多的是使用 Flex 和 Grid 布局。下面依次对他们进行介绍。</p> <h3 id="31-盒模型">3.1 盒模型</h3> <p>CSS 盒模型指一个元素在页面上所占据的空间。由四部分组成：<code class="language-plaintext highlighter-rouge">content</code>、<code class="language-plaintext highlighter-rouge">padding</code>、<code class="language-plaintext highlighter-rouge">border</code> 和 <code class="language-plaintext highlighter-rouge">margin</code>。盒模型主要分为两种：标准盒模型和替代盒模型。</p> <p>（1）标准盒模型（content-box）</p> <p>此模型元素的 <code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code>，只包含内容的宽高，不包含 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>。 此时 <code class="language-plaintext highlighter-rouge">padding</code>、<code class="language-plaintext highlighter-rouge">border</code> 和 <code class="language-plaintext highlighter-rouge">margin</code> 都在这个盒子的外部。</p> <p>（2）替代盒模型（border-box）</p> <p>也叫 IE 盒子模型，此模型元素的 <code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code>，包含 <code class="language-plaintext highlighter-rouge">content</code>、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>。此时 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code> 都在盒子内部。</p> <p>（3）可以通过 <code class="language-plaintext highlighter-rouge">box-sizing</code> 属性，设置一个元素显示为哪种盒模型。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">box-sizing</span><span class="o">:</span> <span class="nt">content-box</span> <span class="o">(</span><span class="nt">默认</span><span class="o">)</span> <span class="o">|</span> <span class="nt">border-box</span><span class="o">;</span>
</code></pre></div></div> <h3 id="32-布局相关属性">3.2 布局相关属性</h3> <p>先介绍几个跟布局相关的属性，他们是：<code class="language-plaintext highlighter-rouge">display</code>、<code class="language-plaintext highlighter-rouge">position</code> 和 <code class="language-plaintext highlighter-rouge">z-index</code>。</p> <p>（1）<code class="language-plaintext highlighter-rouge">display</code> 属性设置元素是否被视为块级或行级盒子以及用于子元素的布局。其语法格式如下（以下只列出了 display 属性的几个常用取值）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">display</span><span class="o">:</span> <span class="nt">flex</span> <span class="o">|</span> <span class="nt">grid</span> <span class="o">|</span> <span class="nt">none</span> <span class="o">|</span> <span class="nt">block</span> <span class="o">|</span> <span class="nt">inline</span> <span class="o">|</span> <span class="nt">inline-block</span> <span class="o">|</span> <span class="nt">table</span><span class="o">;</span>
</code></pre></div></div> <p>注意区分 <code class="language-plaintext highlighter-rouge">display: none</code>、<code class="language-plaintext highlighter-rouge">visibility: hidden</code> 及 <code class="language-plaintext highlighter-rouge">opacity: 0</code> 之间的区别。</p> <ul> <li><code class="language-plaintext highlighter-rouge">display: none</code>：用于将元素完全从页面中移除，包括占用的空间。</li> <li><code class="language-plaintext highlighter-rouge">visibility: hidden</code>：用于隐藏元素，但元素占用的空间会保留，且该元素仍会影响页面布局。</li> <li><code class="language-plaintext highlighter-rouge">opacity: 0</code>：元素依然参与正常布局，且依然“可见”，只是该元素变为透明样式，但用户依然可以与其交互 ·。</li> </ul> <p>（2）<code class="language-plaintext highlighter-rouge">position</code> 属性用于指定一个元素在页面的定位方式。其语法格式如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">position</span><span class="o">:</span> <span class="nt">static</span> <span class="o">(</span><span class="nt">默认</span><span class="o">)</span> <span class="o">|</span> <span class="nt">relative</span> <span class="o">|</span> <span class="nt">absolute</span> <span class="o">|</span> <span class="nt">fixed</span> <span class="o">|</span> <span class="nt">sticky</span><span class="o">;</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">static</code>：默认值，表示元素按照正常的文档流进行布局。使用 <code class="language-plaintext highlighter-rouge">static</code> 定位的元素不会被定位偏移（此时，<code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 属性无效）。</li> <li><code class="language-plaintext highlighter-rouge">relative</code>：定位的元素相对于其正常位置进行偏移。使用 <code class="language-plaintext highlighter-rouge">relative</code> 定位的元素仍然占据原来的空间，但可以通过 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 属性进行偏移。适用于需要微调元素位置的场景。</li> <li><code class="language-plaintext highlighter-rouge">absolute</code>：定位的元素脱离正常文档流，不再占据空间。使用 <code class="language-plaintext highlighter-rouge">absolute</code> 定位的元素相对于最近的非 <code class="language-plaintext highlighter-rouge">static</code> 的祖先元素进行定位。如果没有这样的祖先元素，则相对于网页的根元素 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 进行定位。适用于需要精确定位的场景。</li> <li><code class="language-plaintext highlighter-rouge">fixed</code>：定位的元素脱离正常文档流，不再占据空间。使用 <code class="language-plaintext highlighter-rouge">fixed</code> 定位的元素相对于 视口（浏览器窗口）进行定位，即使页面滚动，其位置也不会改变。适用于需要固定位置的元素，如导航栏、工具栏等。</li> <li> <p><code class="language-plaintext highlighter-rouge">sticky</code>：定位的元素根据用户的滚动位置进行切换，介于 <code class="language-plaintext highlighter-rouge">relative</code> 和 <code class="language-plaintext highlighter-rouge">fixed</code> 之间。使用 <code class="language-plaintext highlighter-rouge">sticky</code> 定位的元素在跨越特定阈值（即 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 设置的值）之前表现为 <code class="language-plaintext highlighter-rouge">relative</code> 定位，跨越阈值后表现为 <code class="language-plaintext highlighter-rouge">fixed</code> 定位。适用于需要在滚动时固定位置的元素，如表头、侧边栏等。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">#toolbar</span> <span class="p">{</span>
  <span class="nl">top</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="n">sticky</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码中，页面向下滚动时，<code class="language-plaintext highlighter-rouge">#toolbar</code> 的父元素开始脱离视口，一旦视口的顶部与 <code class="language-plaintext highlighter-rouge">#toolbar</code> 的距离小于 20px（门槛值），<code class="language-plaintext highlighter-rouge">#toolbar</code> 就自动变为 <code class="language-plaintext highlighter-rouge">fixed</code> 定位，保持与视口顶部 20px 的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），<code class="language-plaintext highlighter-rouge">#toolbar</code> 恢复成 <code class="language-plaintext highlighter-rouge">relative</code> 定位。</p> </li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">z-index</code> 属性用于控制重叠元素的层叠顺序。</p> <p><code class="language-plaintext highlighter-rouge">z-index</code> 只有在 <code class="language-plaintext highlighter-rouge">position</code> 属性值为 <code class="language-plaintext highlighter-rouge">relative</code>、<code class="language-plaintext highlighter-rouge">absolute</code>、<code class="language-plaintext highlighter-rouge">fixed</code> 或 <code class="language-plaintext highlighter-rouge">sticky</code> 时才有效。<code class="language-plaintext highlighter-rouge">z-index</code> 的值可以是正整数、负整数或零，值越大，元素的层级越高。</p> <h3 id="33-flex-布局">3.3 Flex 布局</h3> <p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span><span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 也可以为行内元素开启 Flex 布局 */</span>
<span class="nc">.box</span><span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意，设为 Flex 布局以后，子元素的 <code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">clear</code> 和 <code class="language-plaintext highlighter-rouge">vertical-align</code> 属性将失效。</p> <h4 id="331-基本概念">3.3.1 基本概念</h4> <p>采用 Flex 布局的元素，称为 Flex <strong>容器</strong>（container）。它的所有子元素自动成为容器成员，称为 Flex <strong>项目</strong>（item）。</p> <p>容器默认存在两根轴：水平的<strong>主轴</strong>（main axis）和垂直的<strong>交叉轴</strong>（cross axis）。主轴的开始位置（与边框的交叉点）叫做 <strong>main start</strong>，结束位置叫做 <strong>main end</strong>；交叉轴的开始位置叫做 <strong>cross start</strong>，结束位置叫做 <strong>cross end</strong>。</p> <p><strong>项目默认沿主轴排列</strong>。单个项目占据的主轴空间叫做 <strong>main size</strong>，占据的交叉轴空间叫做 <strong>cross size</strong>。</p> <h4 id="332-容器的属性">3.3.2 容器的属性</h4> <p>作用在容器上的属性有 6 个：<code class="language-plaintext highlighter-rouge">flex-direction</code>、<code class="language-plaintext highlighter-rouge">flex-wrap</code>、<code class="language-plaintext highlighter-rouge">flex-flow</code>、<code class="language-plaintext highlighter-rouge">justify-content</code>、<code class="language-plaintext highlighter-rouge">align-items</code> 和 <code class="language-plaintext highlighter-rouge">align-content</code>。下面，依次对他们进行讲解。</p> <p>（1）<code class="language-plaintext highlighter-rouge">flex-direction</code>：用于决定主轴的方向（即项目的排列方向）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">row</span> <span class="err">|</span> <span class="n">row-reverse</span> <span class="err">|</span> <span class="n">column</span> <span class="err">|</span> <span class="n">column-reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="flex-direction 属性"/></p> <ul> <li><code class="language-plaintext highlighter-rouge">row</code>（默认值）：主轴为水平方向，起点在左端。</li> <li><code class="language-plaintext highlighter-rouge">row-reverse</code>：主轴为水平方向，起点在右端。</li> <li><code class="language-plaintext highlighter-rouge">column</code>：主轴为垂直方向，起点在上沿。</li> <li><code class="language-plaintext highlighter-rouge">column-reverse</code>：主轴为垂直方向，起点在下沿。</li> </ul> <p>（2）<code class="language-plaintext highlighter-rouge">flex-wrap</code>：默认情况下，项目都排在一条线（又称”轴线”）上。<code class="language-plaintext highlighter-rouge">flex-wrap</code> 属性定义，如果一条轴线排不下，如何换行。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span><span class="p">{</span>
  <span class="nl">flex-wrap</span><span class="p">:</span> <span class="nb">nowrap</span> <span class="err">|</span> <span class="n">wrap</span> <span class="err">|</span> <span class="n">wrap-reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">nowrap</code>（默认）：不换行。</li> <li><code class="language-plaintext highlighter-rouge">wrap</code>：换行，第一行在上方。</li> <li><code class="language-plaintext highlighter-rouge">wrap-reverse</code>：换行，第一行在下方。</li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">flex-flow</code>：<code class="language-plaintext highlighter-rouge">flex-direction</code> 属性和 <code class="language-plaintext highlighter-rouge">flex-wrap</code> 属性的简写形式，默认值为 <code class="language-plaintext highlighter-rouge">row nowrap</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">flex-flow</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">flex-direction</span><span class="err">&gt;</span> <span class="err">||</span> <span class="err">&lt;</span><span class="n">flex-wrap</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（4）<code class="language-plaintext highlighter-rouge">justify-content</code>：定义项目在主轴上的对齐方式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-around</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="justify-content 属性"/></p> <p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>（默认值）：左对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：右对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>： 居中。</li> <li><code class="language-plaintext highlighter-rouge">space-between</code>：两端对齐，项目之间的间隔都相等。</li> <li><code class="language-plaintext highlighter-rouge">space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li> </ul> <p>（5）<code class="language-plaintext highlighter-rouge">align-items</code>：定义项目在交叉轴上的对齐方式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="nb">baseline</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="align-items 属性"/></p> <p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>：交叉轴的起点对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：交叉轴的终点对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：交叉轴的中点对齐。</li> <li><code class="language-plaintext highlighter-rouge">baseline</code>: 项目的第一行文字的基线对齐。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>（默认值）：如果项目未设置高度或设为 <code class="language-plaintext highlighter-rouge">auto</code>，将占满整个容器的高度。</li> </ul> <p>（6）align-content：定义多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="align-content 属性"/></p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>：与交叉轴的起点对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：与交叉轴的终点对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：与交叉轴的中点对齐。</li> <li><code class="language-plaintext highlighter-rouge">space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li> <li><code class="language-plaintext highlighter-rouge">space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>（默认值）：轴线占满整个交叉轴。</li> </ul> <h4 id="333-项目的属性">3.3.3 项目的属性</h4> <p>作用在项目上的属性有 6 个：<code class="language-plaintext highlighter-rouge">order</code>、<code class="language-plaintext highlighter-rouge">flex-grow</code>、<code class="language-plaintext highlighter-rouge">flex-shrink</code>、<code class="language-plaintext highlighter-rouge">flex-basis</code>、<code class="language-plaintext highlighter-rouge">flex</code> 和 <code class="language-plaintext highlighter-rouge">align-self</code>。下面，依次对他们进行讲解。</p> <p>（1）<code class="language-plaintext highlighter-rouge">order</code>：定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">order</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">integer</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">flex-grow</code>：定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-grow</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">number</span><span class="err">&gt;</span><span class="p">;</span> <span class="c">/* default 0 */</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果所有项目的 <code class="language-plaintext highlighter-rouge">flex-grow</code> 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code class="language-plaintext highlighter-rouge">flex-grow</code> 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p> <p>（3）<code class="language-plaintext highlighter-rouge">flex-shrink</code>：定义项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-shrink</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">number</span><span class="err">&gt;</span><span class="p">;</span> <span class="c">/* default 1 */</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果所有项目的 <code class="language-plaintext highlighter-rouge">flex-shrink</code> 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 <code class="language-plaintext highlighter-rouge">flex-shrink</code> 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</p> <p>（4）<code class="language-plaintext highlighter-rouge">flex-basis</code>：定义在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 <code class="language-plaintext highlighter-rouge">auto</code>，即项目的本来大小。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-basis</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">length</span><span class="err">&gt;</span> <span class="err">|</span> <span class="nb">auto</span><span class="p">;</span> <span class="c">/* default auto */</span>
<span class="p">}</span>
</code></pre></div></div> <p>它可以设为跟 <code class="language-plaintext highlighter-rouge">width</code> 或 <code class="language-plaintext highlighter-rouge">height</code> 属性一样的值（比如 350px），则项目将占据固定空间。</p> <p>（5）<code class="language-plaintext highlighter-rouge">flex</code>：<code class="language-plaintext highlighter-rouge">flex-grow</code>, <code class="language-plaintext highlighter-rouge">flex-shrink</code> 和 <code class="language-plaintext highlighter-rouge">flex-basis</code> 的简写，默认值为 <code class="language-plaintext highlighter-rouge">0 1 auto</code>。后两个属性可选。</p> <p>该属性有两个快捷值：<code class="language-plaintext highlighter-rouge">auto</code> (<code class="language-plaintext highlighter-rouge">1 1 auto</code>) 和 <code class="language-plaintext highlighter-rouge">none</code> (<code class="language-plaintext highlighter-rouge">0 0 auto</code>)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p> <p>（6）<code class="language-plaintext highlighter-rouge">align-self</code>：<code class="language-plaintext highlighter-rouge">align-self</code> 属性允许单个项目有与其他项目有不一样的对齐方式，可覆盖 <code class="language-plaintext highlighter-rouge">align-items</code> 属性。默认值为 <code class="language-plaintext highlighter-rouge">auto</code>，表示继承父元素的 <code class="language-plaintext highlighter-rouge">align-items</code> 属性，如果没有父元素，则等同于 <code class="language-plaintext highlighter-rouge">stretch</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="nb">auto</span> <span class="err">|</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="nb">baseline</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="align-self 属性"/></p> <p>该属性可能取 6 个值，除了 <code class="language-plaintext highlighter-rouge">auto</code>，其他都与 <code class="language-plaintext highlighter-rouge">align-items</code> 属性完全一致。</p> <h3 id="34-grid-布局">3.4 Grid 布局</h3> <p>网格布局（Grid）将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p> <p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”<strong>行</strong>“和”<strong>列</strong>“，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。</p> <h4 id="341-基本概念">3.4.1 基本概念</h4> <p>（1）采用网格布局的区域，称为<strong>容器</strong>（container）。容器内部采用网格定位的子元素，称为<strong>项目</strong>（item）。</p> <p>注意：项目只能是容器的<strong>顶层子元素</strong>，不包含项目的子元素。Grid 布局只对项目生效。</p> <p>（2）容器里面的水平区域称为”<strong>行</strong>“（row），垂直区域称为”<strong>列</strong>“（column）。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032502.png" alt="Grid 布局的行和列"/></p> <p>（3）行和列的交叉区域，称为”<strong>单元格</strong>“（cell）。正常情况下，<code class="language-plaintext highlighter-rouge">n</code> 行和 <code class="language-plaintext highlighter-rouge">m</code> 列会产生 <code class="language-plaintext highlighter-rouge">n x m</code> 个单元格。比如，3 行 3 列会产生 9 个单元格。</p> <p>（4）划分网格的线，称为”<strong>网格线</strong>“（grid line）。水平网格线划分出行，垂直网格线划分出列。</p> <p>正常情况下，<code class="language-plaintext highlighter-rouge">n</code> 行有 <code class="language-plaintext highlighter-rouge">n + 1</code> 根水平网格线，<code class="language-plaintext highlighter-rouge">m</code> 列有 <code class="language-plaintext highlighter-rouge">m + 1</code> 根垂直网格线，比如三行就有四根水平网格线。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032503.png" alt="Grid 布局的网格线"/></p> <p>上图是一个 4 x 4 的网格，共有 5 根水平网格线和 5 根垂直网格线。</p> <h4 id="342-容器属性">3.4.2 容器属性</h4> <p>（1）<code class="language-plaintext highlighter-rouge">display: grid</code>：指定一个容器采用网格布局。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032504.png" alt="display: grid 的效果"/></p> <p>上图是 <code class="language-plaintext highlighter-rouge">display: grid</code> 的<a href="https://jsbin.com/guvivum/edit?html,css,output">效果</a>。</p> <p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-grid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032505.png" alt="display: inline-grid 的效果"/></p> <p>上图是 <code class="language-plaintext highlighter-rouge">display: inline-grid</code> 的<a href="https://jsbin.com/qatitav/edit?html,css,output">效果</a>。</p> <p>注意，设为网格布局以后，容器子元素（项目）的 <code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">display: inline-block</code>、<code class="language-plaintext highlighter-rouge">display: table-cell</code>、<code class="language-plaintext highlighter-rouge">vertical-align</code> 和 <code class="language-plaintext highlighter-rouge">column-*</code> 等设置都将失效。</p> <p>（2）<code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性、<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性定义每列的列宽，<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性定义每行的行高。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/qiginur/edit?css,output">上面代码</a>指定了一个三行三列的网格，列宽和行高都是 100px。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032506.png" alt="grid-template-rows 属性，grid-template-columns 属性"/></p> <p>除了使用<strong>绝对单位</strong>，也可以使用<strong>百分比</strong>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">33.33%</span> <span class="m">33.33%</span> <span class="m">33.33%</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">33.33%</span> <span class="m">33.33%</span> <span class="m">33.33%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">repeat()</code>：函数用于重复一组值。上面的代码用 <code class="language-plaintext highlighter-rouge">repeat()</code> 改写如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">33.33%</span><span class="p">);</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">33.33%</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">repeat()</code> 接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。<code class="language-plaintext highlighter-rouge">repeat()</code> 也可以重复某种模式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">100</span><span class="nt">px</span> <span class="err">20</span><span class="nt">px</span> <span class="err">80</span><span class="nt">px</span><span class="o">);</span>
</code></pre></div> </div> <p>上面代码定义了 6 列，第一列和第四列的宽度为 100px，第二列和第五列为 20px，第三列和第六列为 80px。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032507.png" alt="repeat() 重复某种模式"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">auto-fill</code> 关键字：表示自动填充。有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每行（或每列）容纳尽可能多的单元格，这时可以使用 <code class="language-plaintext highlighter-rouge">auto-fill</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="n">auto-fill</span><span class="p">,</span> <span class="m">100px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p><a href="https://jsbin.com/himoku/edit?css,output">上面代码</a>表示每列宽度 100px，然后自动填充，直到容器不能放置更多的列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032508.png" alt="auto-fill"/></p> <p>除了 <code class="language-plaintext highlighter-rouge">auto-fill</code>，还有一个关键字 <code class="language-plaintext highlighter-rouge">auto-fit</code>，两者的行为基本是相同的。只有当容器足够宽，可以在一行容纳所有单元格，并且单元格宽度不固定的时候，才会有行为差异：<code class="language-plaintext highlighter-rouge">auto-fill</code> 会用空格子填满剩余宽度，<code class="language-plaintext highlighter-rouge">auto-fit</code> 则会尽量扩大单元格的宽度。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">fr</code>（fraction 的缩写，意为”片段”）关键字：用于表示比例关系。如果两列的宽度分别为 1fr 和 2fr，就表示后者是前者的两倍。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">1</span><span class="n">fr</span> <span class="m">1</span><span class="n">fr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p><a href="https://jsbin.com/hadexek/edit?html,css,output">上面代码</a>表示两个相同宽度的列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032509.png" alt="fr 表示的相同宽度的列"/></p> <p><code class="language-plaintext highlighter-rouge">fr</code> 可以与绝对长度的单位结合使用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">150px</span> <span class="m">1</span><span class="n">fr</span> <span class="m">2</span><span class="n">fr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码表示，第一列的宽度为 150px，第二列的宽度是第三列的一半。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032510.png" alt="fr 与绝对长度的单位结合使用"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">minmax()</code>：此函数用于产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="err">1</span><span class="nt">fr</span> <span class="err">1</span><span class="nt">fr</span> <span class="nt">minmax</span><span class="o">(</span><span class="err">100</span><span class="nt">px</span><span class="o">,</span> <span class="err">1</span><span class="nt">fr</span><span class="o">);</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">minmax(100px, 1fr)</code> 表示列宽不小于 100px，不大于 1fr。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">auto</code> 关键字：表示由浏览器自己决定长度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="err">100</span><span class="nt">px</span> <span class="nt">auto</span> <span class="err">100</span><span class="nt">px</span><span class="o">;</span>
</code></pre></div> </div> <p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了 <code class="language-plaintext highlighter-rouge">min-width</code>，且这个值大于最大宽度。</p> </li> <li> <p>网格线的名称：<code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性里面，还可以使用方括号，指定每根网格线的名字，方便以后的引用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">c3</span><span class="p">]</span> <span class="nb">auto</span> <span class="p">[</span><span class="n">c4</span><span class="p">];</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">r3</span><span class="p">]</span> <span class="nb">auto</span> <span class="p">[</span><span class="n">r4</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码指定网格布局为 3 行 x 3 列，因此有 4 根垂直网格线和 4 根水平网格线。方括号里面依次是这八根线的名字。</p> <p>网格布局允许同一根线有多个名字，比如 <code class="language-plaintext highlighter-rouge">[fifth-line row-5]</code>。</p> </li> <li> <p>布局实例</p> <p><code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性对于网页布局非常有用。两栏式布局只需要一行代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.wrapper</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">70%</span> <span class="m">30%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码将左边栏设为 70%，右边栏设为 30%。传统的十二网格布局，写起来也很容易。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="err">12</span><span class="o">,</span> <span class="err">1</span><span class="nt">fr</span><span class="o">);</span>
</code></pre></div> </div> </li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">grid-row-gap</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 属性、<code class="language-plaintext highlighter-rouge">grid-gap</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-row-gap</code> 属性设置行与行的间隔（行间距），<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 属性设置列与列的间隔（列间距）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">grid-row-gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="py">grid-column-gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/mezufab/edit?css,output">上面代码</a>中，<code class="language-plaintext highlighter-rouge">grid-row-gap</code> 用于设置行间距，grid-column-gap 用于设置列间距。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032511.png" alt="grid-row-gap 属性、grid-column-gap 属性"/></p> <p><code class="language-plaintext highlighter-rouge">grid-gap</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-column-gap</code> 和 <code class="language-plaintext highlighter-rouge">grid-row-gap</code> 的合并简写形式，语法如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-gap</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">grid-row-gap</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">grid-column-gap</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>因此，上面一段 CSS 代码等同于下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">grid-gap</span><span class="p">:</span> <span class="m">20px</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">grid-gap</code> 省略了第二个值，浏览器认为第二个值等于第一个值。</p> <p>注意，根据最新标准，上面三个属性名的 <code class="language-plaintext highlighter-rouge">grid-</code> 前缀已经删除，<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 和 <code class="language-plaintext highlighter-rouge">grid-row-gap</code> 写成 column-gap 和 <code class="language-plaintext highlighter-rouge">row-gap</code>，<code class="language-plaintext highlighter-rouge">grid-gap</code> 写成 <code class="language-plaintext highlighter-rouge">gap</code>。</p> <p>（4）<code class="language-plaintext highlighter-rouge">grid-template-areas</code> 属性</p> <p>网格布局允许指定”<strong>区域</strong>“（area），一个区域由单个或多个单元格组成。<code class="language-plaintext highlighter-rouge">grid-template-areas</code> 属性用于定义区域。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-areas</span><span class="p">:</span> <span class="s2">'a b c'</span>
                       <span class="s2">'d e f'</span>
                       <span class="s2">'g h i'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码先划分出 9 个单元格，然后将其定名为 <code class="language-plaintext highlighter-rouge">a</code> 到 <code class="language-plaintext highlighter-rouge">i</code> 的九个区域，分别对应这九个单元格。</p> <p>多个单元格合并成一个区域的写法如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s2">'a a a'</span>
                     <span class="s2">'b b b'</span>
                     <span class="s2">'c c c'</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码将9个单元格分成 <code class="language-plaintext highlighter-rouge">a</code>、<code class="language-plaintext highlighter-rouge">b</code>、<code class="language-plaintext highlighter-rouge">c</code> 三个区域。</p> <p>下面是一个布局实例。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s1">"header header header"</span>
                     <span class="s1">"main main sidebar"</span>
                     <span class="s1">"footer footer footer"</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码中，顶部是页眉区域 <code class="language-plaintext highlighter-rouge">header</code>，底部是页脚区域 <code class="language-plaintext highlighter-rouge">footer</code>，中间部分则为 <code class="language-plaintext highlighter-rouge">main</code> 和 <code class="language-plaintext highlighter-rouge">sidebar</code>。</p> <p>如果某些区域不需要利用，则使用”点”（<code class="language-plaintext highlighter-rouge">.</code>）表示。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s2">'a . c'</span>
                     <span class="s2">'d . f'</span>
                     <span class="s2">'g . i'</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p> <p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名 <code class="language-plaintext highlighter-rouge">-start</code>，终止网格线自动命名为区域名 <code class="language-plaintext highlighter-rouge">-end</code>。比如，区域名为 <code class="language-plaintext highlighter-rouge">header</code>，则起始位置的水平网格线和垂直网格线叫做 <code class="language-plaintext highlighter-rouge">header-start</code>，终止位置的水平网格线和垂直网格线叫做 <code class="language-plaintext highlighter-rouge">header-end</code>。</p> <p>（5）<code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性</p> <p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032506.png" alt="子元素排列顺序"/></p> <p>这个顺序由 <code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性决定，默认值是 <code class="language-plaintext highlighter-rouge">row</code>，即”<strong>先行后列</strong>“。也可以将它设成 <code class="language-plaintext highlighter-rouge">column</code>，变成”<strong>先列后行</strong>“。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">column</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/xutokec/edit?css,output">上面代码</a>设置了 <code class="language-plaintext highlighter-rouge">column</code> 以后，放置顺序就变成了下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032512.png" alt="按照 column 方式排列"/></p> <p><code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性除了设置成 <code class="language-plaintext highlighter-rouge">row</code> 和 <code class="language-plaintext highlighter-rouge">column</code>，还可以设成 <code class="language-plaintext highlighter-rouge">row dense</code> 和 <code class="language-plaintext highlighter-rouge">column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p> <p><a href="https://jsbin.com/wapejok/edit?css,output">下面的例子</a>让 1 号项目和 2 号项目各占据两个单元格，然后在默认的 grid-auto-flow: row 情况下，会产生下面这样的布局。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032513.png" alt="grid-auto-flow: row 时，元素的排列方式"/></p> <p>上图中，1 号项目后面的位置是空的，这是因为 3 号项目默认跟着 2 号项目，所以会排在 2 号项目后面。</p> <p>现在修改设置，设为 <code class="language-plaintext highlighter-rouge">row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">row</span> <span class="nt">dense</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/helewuy/edit?css,output">上面代码</a>的效果如下。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032514.png" alt="grid-auto-flow: row dense 时，元素的排列方式"/></p> <p>上图会先填满第一行，再填满第二行，所以 3 号项目会紧跟在 1 号项目的后面。8 号项目和 9 号项目就会排到第四行。</p> <p>如果将设置改为 <code class="language-plaintext highlighter-rouge">column dense</code>，表示”先列后行”，并且尽量填满空格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">column</span> <span class="nt">dense</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/pupoduc/1/edit?html,css,output">上面代码</a>的效果如下。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032515.png" alt="grid-auto-flow: column dense 时，元素的排列方式"/></p> <p>上图会先填满第一列，再填满第 2 列，所以 3 号项目在第一列，4 号项目在第二列。8 号项目和 9 号项目被挤到了第四列。</p> <p>（6）<code class="language-plaintext highlighter-rouge">justify-items</code> 属性、<code class="language-plaintext highlighter-rouge">align-items</code> 属性、<code class="language-plaintext highlighter-rouge">place-items</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">justify-items</code> 属性设置单元格内容的<strong>水平位置</strong>（左中右），<code class="language-plaintext highlighter-rouge">align-items</code> 属性设置单元格内容的<strong>垂直位置</strong>（上中下）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">justify-items</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性的写法完全相同，都可以取下面这些值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">start</code>：对齐单元格的起始边缘。</li> <li><code class="language-plaintext highlighter-rouge">end</code>：对齐单元格的结束边缘。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：单元格内部居中。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">justify-items</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/gijeqej/edit?css,output">上面代码</a>表示，单元格的内容左对齐，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032516.png" alt="justify-items: start 的效果"/></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/tecawur/edit?css,output">上面代码</a>表示，单元格的内容头部对齐，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032517.png" alt="align-items: start 的效果"/></p> <p><code class="language-plaintext highlighter-rouge">place-items</code> 属性是 <code class="language-plaintext highlighter-rouge">align-items</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-items</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-items</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-items</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-items</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>如果省略第二个值，则浏览器认为与第一个值相等。</p> <p>（7）<code class="language-plaintext highlighter-rouge">justify-content</code> 属性、<code class="language-plaintext highlighter-rouge">align-content</code> 属性、<code class="language-plaintext highlighter-rouge">place-content</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">justify-content</code> 属性是整个内容区域在容器里面的<strong>水平位置</strong>（左中右），<code class="language-plaintext highlighter-rouge">align-content</code> 属性是整个内容区域的<strong>垂直位置</strong>（上中下）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-evenly</span><span class="p">;</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-evenly</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以 <code class="language-plaintext highlighter-rouge">justify-content</code> 属性为例，<code class="language-plaintext highlighter-rouge">align-content</code> 属性的图完全一样，只是将水平方向改成垂直方向。）</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">start</code> - 对齐容器的起始边框。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032519.png" alt="justify-content: start 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">end</code> - 对齐容器的结束边框。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032518.png" alt="justify-content: end 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">center</code> - 容器内部居中。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032520.png" alt="justify-content: center 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">stretch</code> - 项目大小没有指定时，拉伸占据整个网格容器。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032521.png" alt="justify-content: stretch 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-around</code> - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032522.png" alt="justify-content: space-around 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-between</code> - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032523.png" alt="justify-content: space-between 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-evenly</code> - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032524.png" alt="justify-content: space-evenly 的效果"/></p> </li> </ul> <p><code class="language-plaintext highlighter-rouge">place-content</code> 属性是 <code class="language-plaintext highlighter-rouge">align-content</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-content</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-content</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-content</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-content</span><span class="o">&gt;</span>
</code></pre></div></div> <p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p> <p>（8）<code class="language-plaintext highlighter-rouge">grid-auto-columns</code> 属性、<code class="language-plaintext highlighter-rouge">grid-auto-rows</code> 属性</p> <p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p> <p><code class="language-plaintext highlighter-rouge">grid-auto-columns</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-auto-rows</code> 属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与 <code class="language-plaintext highlighter-rouge">grid-template-columns</code> 和 <code class="language-plaintext highlighter-rouge">grid-template-rows</code> 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p> <p><a href="https://jsbin.com/sayuric/edit?css,output">下面的例子</a>里面，划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-auto-rows</span><span class="p">:</span> <span class="m">50px</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面代码指定新增的行高统一为 50px（原始的行高为 100px）。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032525.png" alt="grid-auto-columns 属性、grid-auto-rows 属性"/></p> <p>（9）<code class="language-plaintext highlighter-rouge">grid-template</code> 属性、<code class="language-plaintext highlighter-rouge">grid</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-template</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-template-columns</code>、<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 和 <code class="language-plaintext highlighter-rouge">grid-template-areas</code> 这三个属性的合并简写形式。</p> <p>grid 属性是 <code class="language-plaintext highlighter-rouge">grid-template-rows</code>、<code class="language-plaintext highlighter-rouge">grid-template-columns</code>、<code class="language-plaintext highlighter-rouge">grid-template-areas</code>、<code class="language-plaintext highlighter-rouge">grid-auto-rows</code>、<code class="language-plaintext highlighter-rouge">grid-auto-columns</code>、<code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 这六个属性的合并简写形式。</p> <p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p> <h4 id="343-项目属性">3.4.3 项目属性</h4> <p>（1）<code class="language-plaintext highlighter-rouge">grid-column-start</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column-end</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row-start</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row-end</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row</code> 属性</p> <p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p> <ul> <li><code class="language-plaintext highlighter-rouge">grid-column-start</code>：左边框所在的垂直网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-column-end</code>：右边框所在的垂直网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-row-start</code>：上边框所在的水平网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-row-end</code>：下边框所在的水平网格线</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/yukobuf/edit?css,output">上面代码</a>指定，1 号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032526.png" alt="grid-column-start: 2且grid-column-end: 4时的效果"/></p> <p>上图中，只指定了 1 号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p> <p>除了 1 号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的 <code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性决定，这个属性的默认值是 <code class="language-plaintext highlighter-rouge">row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成 <code class="language-plaintext highlighter-rouge">column</code>、<code class="language-plaintext highlighter-rouge">row dense</code> 和 <code class="language-plaintext highlighter-rouge">column dense</code>，看看其他项目的位置发生了怎样的变化。</p> <p><a href="https://jsbin.com/nagobey/edit?html,css,output">下面的例子</a>是指定四个边框位置的效果。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">3</span><span class="p">;</span>
  <span class="py">grid-row-start</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="py">grid-row-end</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032527.png" alt="grid-column-start: 1 且 grid-column-end: 3 且 grid-row-start: 2 且 grid-row-end: 4时的效果"/></p> <p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="n">header-start</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="n">header-end</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p> <p>这四个属性的值还可以使用 <code class="language-plaintext highlighter-rouge">span</code> 关键字，表示”<strong>跨越</strong>“，即左右边框（上下边框）之间跨越多少个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/hehumay/edit?html,css,output">上面代码</a>表示，1 号项目的左边框距离右边框跨越 2 个网格。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032528.png" alt="`grid-column-start: span 2` 时的效果"/></p> <p>这与<a href="https://jsbin.com/mujihib/edit?html,css,output">下面的代码</a>效果完全一样。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">grid-column</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-column-start</code> 和 <code class="language-plaintext highlighter-rouge">grid-column-end</code> 的合并简写形式，<code class="language-plaintext highlighter-rouge">grid-row</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-row-start</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-row-end</code> 的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">start-line</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">end-line</span><span class="err">&gt;</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">start-line</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">end-line</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>下面是一个例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等同于 */</span>
<span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">3</span><span class="p">;</span>
  <span class="py">grid-row-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-row-end</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，项目 item-1 占据第一行，从第一根列线到第三根列线。</p> <p>这两个属性之中，也可以使用 span 关键字，表示跨越多少个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#b03532</span><span class="p">;</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等同于 */</span>
<span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#b03532</span><span class="p">;</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/volugow/edit?html,css,output">上面代码</a>中，项目 <code class="language-plaintext highlighter-rouge">item-1</code> 占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032529.png" alt="grid-column: 1 / 3 且 grid-row: 1 / 3 时 item-1 占据的区域"/></p> <p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，项目 <code class="language-plaintext highlighter-rouge">item-1</code> 占据左上角第一个网格。</p> <p>（2）<code class="language-plaintext highlighter-rouge">grid-area</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-area</code> 属性指定项目放在哪一个区域。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，1 号项目位于 <code class="language-plaintext highlighter-rouge">e</code> 区域，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032530.png" alt="grid-area: e 时的效果"/></p> <p><code class="language-plaintext highlighter-rouge">grid-area</code> 属性还可用作 <code class="language-plaintext highlighter-rouge">grid-row-start</code>、<code class="language-plaintext highlighter-rouge">grid-column-start</code>、<code class="language-plaintext highlighter-rouge">grid-row-end</code>、<code class="language-plaintext highlighter-rouge">grid-column-end</code> 的合并简写形式，直接指定项目的位置。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">row-start</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">column-start</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">row-end</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">column-end</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（3）<code class="language-plaintext highlighter-rouge">justify-self</code> 属性、<code class="language-plaintext highlighter-rouge">align-self</code> 属性、<code class="language-plaintext highlighter-rouge">place-self</code> 属性</p> <ul> <li><code class="language-plaintext highlighter-rouge">justify-self</code> 属性设置单元格内容的水平位置（左中右），跟 <code class="language-plaintext highlighter-rouge">justify-items</code> 属性的用法完全一致，但只作用于单个项目。</li> <li><code class="language-plaintext highlighter-rouge">align-self</code> 属性设置单元格内容的垂直位置（上中下），跟 <code class="language-plaintext highlighter-rouge">align-items</code> 属性的用法完全一致，也是只作用于单个项目。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="py">justify-self</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性都可以取下面四个值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">start</code>：对齐单元格的起始边缘。</li> <li><code class="language-plaintext highlighter-rouge">end</code>：对齐单元格的结束边缘。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：单元格内部居中。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li> </ul> <p>下面是 <code class="language-plaintext highlighter-rouge">justify-self: start</code> 的例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span>  <span class="p">{</span>
  <span class="py">justify-self</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032532.png" alt="justify-self: start 时的效果"/></p> <p><code class="language-plaintext highlighter-rouge">place-self</code> 属性是 <code class="language-plaintext highlighter-rouge">align-self</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-self</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-self</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-self</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-self</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>如果省略第二个值，<code class="language-plaintext highlighter-rouge">place-self</code> 属性会认为这两个值相等。</p> <h3 id="35-响应式图片">3.5 响应式图片</h3> <h3 id="351-srcset-属性">3.5.1 <code class="language-plaintext highlighter-rouge">srcset</code> 属性</h3> <p><code class="language-plaintext highlighter-rouge">srcset</code> 属性用来指定多张图像，适应<strong>不同像素密度</strong>的屏幕。它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，然后是像素密度的描述符。请看下面的例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-320w.jpg,
             foo-480w.jpg 1.5x,
             foo-640w.jpg 2x"</span>
     <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-640w.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">srcset</code> 属性给出了三个图像 URL，适应三种不同的像素密度。</p> <p>浏览器会根据当前设备的像素密度，选择需要加载的图像。如果 <code class="language-plaintext highlighter-rouge">srcset</code> 属性都不满足条件，那么就加载 <code class="language-plaintext highlighter-rouge">src</code> 属性指定的默认图像。</p> <h3 id="352-srcset-属性sizes-属性">3.5.2 <code class="language-plaintext highlighter-rouge">srcset</code> 属性、<code class="language-plaintext highlighter-rouge">sizes</code> 属性</h3> <p><code class="language-plaintext highlighter-rouge">sizes</code> 属性与 <code class="language-plaintext highlighter-rouge">srcset</code> 属性配合使用，可以实现根据不同的设备宽度应用不同尺寸的图像。其实现步骤如下。</p> <ol> <li><code class="language-plaintext highlighter-rouge">srcset</code> 属性列出所有可用的图像。</li> </ol> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-160.jpg 160w,
              foo-320.jpg 320w,
              foo-640.jpg 640w,
              foo-1280.jpg 1280w"</span>
      <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-1280.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">srcset</code> 属性列出四张可用的图像，每张图像的 URL 后面是一个空格，再加上宽度描述符。<strong>宽度描述符就是图像原始的宽度，加上字符 <code class="language-plaintext highlighter-rouge">w</code></strong>。上例的四种图片的原始宽度分别为 160px、320px、640px 和 1280px。</p> <ol> <li><code class="language-plaintext highlighter-rouge">sizes</code> 属性列出不同设备的图像显示宽度。</li> </ol> <p><code class="language-plaintext highlighter-rouge">sizes</code> 属性的值是一个逗号分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图像的显示宽度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">sizes</span><span class="o">=</span><span class="s1">"(max-width: 440px) 100vw,
              (max-width: 900px) 33vw,
              254px"</span>
      <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-160.jpg 160w,
              foo-320.jpg 320w,
              foo-640.jpg 640w,
              foo-1280.jpg 1280w"</span>
      <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-1280.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">sizes</code> 属性给出了三种屏幕条件，以及对应的图像显示宽度。宽度不超过 440px 的设备，图像显示宽度为 100%；宽度 441px 到 900px 的设备，图像显示宽度为 33%；宽度 900px 以上的设备，图像显示宽度为 254px。</p> <ol> <li>浏览器根据当前设备的宽度，从 <code class="language-plaintext highlighter-rouge">sizes</code> 属性获得图像的显示宽度，然后从 <code class="language-plaintext highlighter-rouge">srcset</code> 属性找出最接近该宽度的图像，进行加载。</li> </ol> <p>假定当前设备的屏幕宽度是 480px，浏览器从 <code class="language-plaintext highlighter-rouge">sizes</code> 属性查询得到，图片的显示宽度是 33vw（即 33%），等于 160px。<code class="language-plaintext highlighter-rouge">srcset</code> 属性里面，正好有宽度等于 160px 的图片，于是加载 <code class="language-plaintext highlighter-rouge">foo-160.jpg</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">sizes</code> 属性必须与 <code class="language-plaintext highlighter-rouge">srcset</code> 属性搭配使用。单独使用 <code class="language-plaintext highlighter-rouge">sizes</code> 属性是无效的。</p> <h3 id="353-picture-标签source-标签">3.5.3 <code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签、<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签</h3> <p>使用 <code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签和 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签，可以实现对不同尺寸及不同像素密度屏幕的适配。<picture> 标签是一个容器标签，内部使用 <source/> 和 <img/>，指定不同情况下加载的图像。</picture></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">media</span><span class="o">=</span><span class="s1">"(max-width: 500px)"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"cat-vertical.jpg"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 501px)"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"cat-horizontal.jpg"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">src</span><span class="o">=</span><span class="s1">"cat.jpg"</span> <span class="nt">alt</span><span class="o">=</span><span class="s1">"cat"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签内部有两个 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签和一个 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签。</p> <p><code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性给出媒体查询表达式，<code class="language-plaintext highlighter-rouge">srcset</code> 属性就是 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">srcset</code> 属性，给出加载的图像文件。<code class="language-plaintext highlighter-rouge">sizes</code> 属性其实这里也可以用，但由于有了 <code class="language-plaintext highlighter-rouge">media</code> 属性，就没有必要了。浏览器<strong>按照</strong> <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> <strong>标签出现的顺序</strong>，依次判断当前设备是否满足 <code class="language-plaintext highlighter-rouge">media</code> 属性的媒体查询表达式，如果满足就加载 <code class="language-plaintext highlighter-rouge">srcset</code> 属性指定的图片文件，并且不再执行后面的 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签和 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签。</p> <p><code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签是默认情况下加载的图像，用来满足上面所有 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 都不匹配的情况。</p> <p>上面例子中，设备宽度如果不超过 500px，就加载竖屏的图像，否则加载横屏的图像。</p> <p>下面给出一个例子，同时考虑屏幕尺寸和像素密度的适配。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@desktop.png,
                  homepage-person@desktop-2x.png 2x"</span>       
          <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 990px)"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@tablet.png,
                  homepage-person@tablet-2x.png 2x"</span> 
          <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 750px)"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@mobile.png,
               homepage-person@mobile-2x.png 2x"</span> 
       <span class="nt">alt</span><span class="o">=</span><span class="s1">"Shopify Merchant, Corrine Anestopoulos"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性给出屏幕尺寸的适配条件，每个条件都用 <code class="language-plaintext highlighter-rouge">srcset</code> 属性，再给出两种像素密度的图像 URL。</p> <h3 id="354-source-标签的-type-属性">3.5.4 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性</h3> <p>除了响应式图像，<code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签还可以用来选择不同格式的图像。比如，如果当前浏览器支持 Webp 格式，就加载这种格式的图像，否则加载 PNG 图像。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">type</span><span class="o">=</span><span class="s1">"image/svg+xml"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"logo.xml"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">type</span><span class="o">=</span><span class="s1">"image/webp"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"logo.webp"</span><span class="o">&gt;</span> 
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">src</span><span class="o">=</span><span class="s1">"logo.png"</span> <span class="nt">alt</span><span class="o">=</span><span class="s1">"ACME Corp"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性给出图像的 MIME 类型，<code class="language-plaintext highlighter-rouge">srcset</code> 是对应的图像 URL。</p> <p>浏览器按照 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签出现的顺序，依次检查是否支持 <code class="language-plaintext highlighter-rouge">type</code> 属性指定的图像格式，如果支持就加载图像，并且不再检查后面的 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签了。上面例子中，图像加载优先顺序依次为 svg 格式、webp 格式和 png 格式。</p> <h2 id="四h5-与响应式-web-设计">四、H5 与响应式 Web 设计</h2> <h3 id="41-h5-页面结构新特性">4.1 H5 页面结构新特性</h3> <p>（1）<code class="language-plaintext highlighter-rouge">doctype</code>：用于告诉浏览器文档类型。相比于 H4 的写法，新写法简化了很多。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">lang 属性</code>：用于指定文档使用的语言。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
</code></pre></div></div> <p>（3）<code class="language-plaintext highlighter-rouge">charset</code>：<code class="language-plaintext highlighter-rouge">charset</code> 属性用于指定字符编码。除非有特殊需要，否则 <code class="language-plaintext highlighter-rouge">charset</code> 的属性值一般都是 <code class="language-plaintext highlighter-rouge">utf-8</code>。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
</code></pre></div></div> <h3 id="42-h5-结构化元素">4.2 H5 结构化元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;main&gt;</code>：用于表示页面的主内容区。通常，每个页面的主内容区只能有一个，而且不能作为 <code class="language-plaintext highlighter-rouge">article</code>、<code class="language-plaintext highlighter-rouge">aside</code>、<code class="language-plaintext highlighter-rouge">header</code>、<code class="language-plaintext highlighter-rouge">footer</code>、<code class="language-plaintext highlighter-rouge">nav</code> 或 <code class="language-plaintext highlighter-rouge">header</code> 等其他 H5 语义元素的后代。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;section&gt;</code>：用于定义文档或应用中一个通用的区块。比如，某块内容包含自然标题（h1 ~ h6），就可以使用 <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> 标签作为容器。</p> <p>（3）<code class="language-plaintext highlighter-rouge">&lt;nav&gt;</code>：用于包装主导航链接。</p> <p>（4）<code class="language-plaintext highlighter-rouge">&lt;article&gt;</code>：用于包含一个独立的内容块。比如，有博客正文和新闻报道就可以放在 <code class="language-plaintext highlighter-rouge">&lt;article&gt;</code> 中。</p> <p>（5）<code class="language-plaintext highlighter-rouge">&lt;aside&gt;</code>：用于包含与其旁边内容不相关的内容。常用于侧边栏、突出引用、广告和导航元素。</p> <p>（6）<code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;figcaption&gt;</code>：<code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 常用于包含注解、图示、照片和代码等。<code class="language-plaintext highlighter-rouge">&lt;figcaption&gt;</code> 可作为 <code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 的嵌套元素使用。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;figure</span> <span class="na">class=</span><span class="s">"MoneyShot"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;img</span> <span class="na">class=</span><span class="s">"MoneyShotImg"</span> <span class="na">src=</span><span class="s">"img/scones.jpg"</span> <span class="na">alt=</span><span class="s">"Incredible scones"</span> <span class="nt">/&gt;</span> 
  <span class="nt">&lt;figcaption</span> <span class="na">class=</span><span class="s">"ImageCaption"</span><span class="nt">&gt;</span>
    Incredible scones, picture from Wikipedia
  <span class="nt">&lt;/figcaption&gt;</span> 
<span class="nt">&lt;/figure&gt;</span> 
</code></pre></div></div> <p>（7）<code class="language-plaintext highlighter-rouge">&lt;detail&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;summary&gt;</code>：这两个元素经常成对出现，比如，我们经常使用的“展开/收起”部件，就可以用它们来实现。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;details&gt;</span> 
  <span class="nt">&lt;summary&gt;</span>I ate 15 scones in one day<span class="nt">&lt;/summary&gt;</span> 
  <span class="nt">&lt;p&gt;</span>Of course I didn't. It would probably kill me if I did. What a way to go. Mmmmmm, scones!<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/details&gt;</span>
</code></pre></div></div> <p>在不添加任何样式的请款下，上面代码的（展开）效果如下。</p> <p><img src="/assets/images/css/detail-and-summary.png" alt="details and summary tag"/></p> <p>（8）<code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>：常用在站点页头作为“报头”。它可以在一个页面中出现多次（比如，页面中每个 <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> 中都可以有一个 <code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>）。</p> <p>（9）<code class="language-plaintext highlighter-rouge">&lt;footer&gt;</code>：常用于在相应区块中包含与区块相关的内容，可以包含指向其他文档的链接，或者版权声明。<code class="language-plaintext highlighter-rouge">&lt;footer&gt;</code> 同样可以在页面中出现多次。</p> <p>（10）<code class="language-plaintext highlighter-rouge">&lt;address&gt;</code>：用于标记联系人信息，比如地址信息。</p> <p>（11）<code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code> ~ <code class="language-plaintext highlighter-rouge">&lt;h6&gt;</code>：h1 到 h6 元素不能用于标记副标题、字幕、广告语，除非想把它们用作新区块或子区块的标题。</p> <h3 id="43-h5-文本级元素">4.3 H5 文本级元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;b&gt;</code>：表示只为引人注意而标记的文本，不传达更多的重要性信息，也不用于表达其他的愿望或情绪。比如，不用于文章摘要中的关键词、评测当中的产品名、交互式文本程序中的可执行命令，等等。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code>：表示内容中需要强调的部分。</p> <p>（3）<code class="language-plaintext highlighter-rouge">&lt;i&gt;</code>：表示一段文本，用于表示另一种愿望或情绪，或者以突出不同文本形式的方式表达偏离正文的意思。</p> <h3 id="44-新的媒体元素">4.4 新的媒体元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;video&gt;</code>：用于在页面中嵌入视频，<code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> 标签必须成对使用。如果浏览器不支持此标签，可以在其中潜入一段文字，用于提示。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">src=</span><span class="s">"myVideo.mp4"</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span><span class="nt">&gt;</span>
  What, do you mean you don't understand HTML5?
<span class="nt">&lt;/video&gt;</span> 
</code></pre></div></div> <p>对于某些旧版本浏览器，可以使用 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签以提供后备资源。比如，除了提供 MP4 版本的视频，如果想某些低版本浏览器也能看到视频，可以添加一个 Flash源 作为后备。或者，如果用户浏览器没有任何播放条件，还可以提供一个下载视频的链接。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span> <span class="na">controls</span> <span class="na">preload=</span><span class="s">"auto"</span> <span class="na">loop</span> <span class="na">poster=</span><span class="s">"myVideoPoster.png"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">"video/myVideo.mp4"</span> <span class="na">type=</span><span class="s">"video/mp4"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;object</span>
    <span class="na">width=</span><span class="s">"640"</span>
    <span class="na">height=</span><span class="s">"480"</span>
    <span class="na">type=</span><span class="s">"application/x-shockwaveflash"</span>
    <span class="na">data=</span><span class="s">"myFlashVideo.SWF"</span>
  <span class="nt">&gt;</span>
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"movie"</span> <span class="na">value=</span><span class="s">"myFlashVideo.swf"</span> <span class="nt">/&gt;</span> 
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"flashvars"</span> <span class="na">value=</span><span class="s">"controlbar=over&amp;amp;image=myVideoPoster.jpg&amp;amp;file=myVideo.mp4"</span> <span class="nt">/&gt;</span> 
    <span class="nt">&lt;img</span>
      <span class="na">src=</span><span class="s">"myVideoPoster.png"</span>
      <span class="na">width=</span><span class="s">"640"</span>
      <span class="na">height=</span><span class="s">"480"</span>
      <span class="na">alt=</span><span class="s">"__ TITLE__"</span>
      <span class="na">title=</span><span class="s">"No video playback capabilities, please download the video below"</span>
    <span class="nt">/&gt;</span> 
  <span class="nt">&lt;/object&gt;</span> 
  <span class="nt">&lt;p&gt;</span>
    <span class="nt">&lt;b&gt;</span>Download Video:<span class="nt">&lt;/b&gt;</span> MP4 Format: <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"myVideo.mp4"</span><span class="nt">&gt;</span>"MP4"<span class="nt">&lt;/a&gt;</span> 
  <span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/video&gt;</span>
</code></pre></div></div> <p>通常，很难对不同的视频播放画面做响应式设计，多数情况下，影片的播放比例并不相同。<a href="http://embedresponsively.com/">这里</a> 有一个网站，你可以把视频的 url 地址粘贴进去，就会得到一段响应式代码，从而使得在网页缩放时，视频依然会保持应有的比例。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;audio&gt;</code>：<code class="language-plaintext highlighter-rouge">&lt;audio&gt;</code> 用于在页面中嵌入音频，其用法与 <code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> 类似。</p> <h3 id="45-其他特性">4.5 其他特性</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 标签中可以放多个元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"index.html"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;h2&gt;</span>The home page<span class="nt">&lt;/h2&gt;</span> 
  <span class="nt">&lt;p&gt;</span>This paragraph also links to the home page<span class="nt">&lt;/p&gt;</span> 
  <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"home-image.png"</span> <span class="na">alt=</span><span class="s">"home-slice"</span> <span class="nt">/&gt;</span> 
<span class="nt">&lt;/a&gt;</span> 
</code></pre></div></div> <p>（2）WCAG 和 WAI-ARIA</p> <p>WCAG 和 WAI-ARIA 提供了与无障碍交互相关的标准。</p> <h2 id="五css3-新特性">五、CSS3 新特性</h2> <p>这部分并不会讨论 CSS3 中所有的新特性，而只是讨论跟响应式设计有关的新特性。</p> <h3 id="51-css-响应式多列布局">5.1 CSS 响应式多列布局</h3> <p>以下示例，以下面的代码布局为例进行讲解。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;main&gt;</span> 
  <span class="nt">&lt;p&gt;</span>lloremipsimLoremipsum dolor sit amet, consectetur ... <span class="nt">&lt;/p&gt;</span> 
  <span class="nt">&lt;p&gt;</span>lloremipsimLoremipsum dolor sit amet, consectetur ... <span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/main&gt;</span>
</code></pre></div></div> <p>（1）使用 CSS 多列布局可以通过几种方式让文本分成多列显示。比如，可以给每列设定固定的列宽。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-width</span><span class="p">:</span> <span class="m">12em</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码表示，设置没列的宽度为 12em，改变视口宽度时，列宽不变，列数动态改变。</p> <p>（2）固定列数，可变宽度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-count</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码表示，当页面缩放时，列数固定，宽度可变。</p> <p>（3）添加列间距和分隔线。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-gap</span><span class="p">:</span> <span class="m">2em</span><span class="p">;</span> 
  <span class="nl">column-rule</span><span class="p">:</span> <span class="nb">thin</span> <span class="nb">dotted</span> <span class="m">#999</span><span class="p">;</span> 
  <span class="nl">column-width</span><span class="p">:</span> <span class="m">12em</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码，用于给列间添加间距和分隔线。</p> <h3 id="52-断字">5.2 断字</h3> <p>（1）容器中的文字默认一行显示，如果文字太长，超出了容器的长度，就会显示在容器外面。可以使用下面的方式，对文字进行<strong>换行</strong>处理。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">word-wrap</span><span class="o">:</span> <span class="nt">break-word</span><span class="o">;</span>
</code></pre></div></div> <p>（2）可以对文字<strong>截短</strong>处理，并且使得超出容器宽度的部分，显示为 <code class="language-plaintext highlighter-rouge">...</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">p</span> <span class="p">{</span> 
 <span class="nl">width</span><span class="p">:</span> <span class="m">520px</span><span class="p">;</span> 
 <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span> 
 <span class="nl">text-overflow</span><span class="p">:</span> <span class="n">ellipsis</span><span class="p">;</span> 
 <span class="nl">white-space</span><span class="p">:</span> <span class="n">no-wrap</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>最后的 <code class="language-plaintext highlighter-rouge">white-space: nowrap</code> 声明是为了确保长出来的文本不会折行显示在外部元素中。</p> <h3 id="53-在-css-中创建分支">5.3 在 CSS 中创建分支</h3> <p>在响应式设计，经常会碰到某些设备不支持什么特性或技术的情况。此时，往往需要在 CSS 中创建一个分支。如果浏览器支持某特性，就应用一段代码；如果不支持，则应用另一段代码。这点类似于 JavaScript 中 <code class="language-plaintext highlighter-rouge">if...else</code> 语句。</p> <p>在 CSS 中创建分支有两种手段。一是完全基于 CSS，但支持的浏览器却不多； 二是借助 JavaScript 库，获得广泛兼容性。</p> <p>（1）特性查询</p> <p>CSS 原生的分支语法就是特性查询，比如下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">(</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span>

<span class="k">@supports</span> <span class="n">not</span> <span class="p">(</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-block</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码表示，如果浏览器支持 <code class="language-plaintext highlighter-rouge">display: flex</code>，就对 <code class="language-plaintext highlighter-rouge">.item</code> 选择器设置一种样式；否则，则设置为另一种样式。</p> <p>（2）组合条件</p> <p>假设我们只想在浏览器支持 flexbox 和 <code class="language-plaintext highlighter-rouge">pointer: coarse</code> 时应用某些规则，可以使用下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">((</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nb">pointer</span><span class="p">:</span> <span class="n">coarse</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">and</code> 关键字，其他支持的关键字还有 <code class="language-plaintext highlighter-rouge">or</code>。比如，除了前面两个条件满足之外，如果浏览器支持 3D 变形也想应用样式，那么可以使用下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">((</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nb">pointer</span><span class="p">:</span> <span class="n">coarse</span><span class="p">))</span> <span class="n">or</span> <span class="p">(</span><span class="n">transform</span><span class="p">:</span> <span class="n">translate3d</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>注意，某些低版本及 IE 浏览器，并不支持 <code class="language-plaintext highlighter-rouge">@support</code> 关键字。</p> <p>（3）在 <code class="language-plaintext highlighter-rouge">@supports</code> 得到广泛支持以前，还可以使用 Modernizr 这个 JavaScript 工具在 CSS 中实现分支。</p> <h3 id="54-新的-css3-选择器">5.4 新的 CSS3 选择器</h3> <p>（1）属性选择器，用于对某些元素的属性进行选择。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">border</span><span class="p">:</span> <span class="m">3px</span> <span class="nb">dashed</span> <span class="m">#e15f5f</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，表示选中任何包含 <code class="language-plaintext highlighter-rouge">alt</code> 属性的 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 元素。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">=</span><span class="s1">"sausages"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="c">/* 样式 */</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码，只会选择 <code class="language-plaintext highlighter-rouge">alt</code> 属性值为 <code class="language-plaintext highlighter-rouge">sausages</code> 的 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>元素。即同时指定了属性的值，进一步缩小了搜索范围。</p> <p>CSS3 支持依据属性选择器包含的子字符串来选择元素。这时分为三种情况：</p> <ul> <li>以 xxx 开头。</li> <li>包含 xxx。</li> <li>以 xxx 结尾。</li> </ul> <p>（2）选中属性值以某字符串开头的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"img/ace-film.jpg"</span> <span class="na">alt=</span><span class="s">"film-ace"</span><span class="nt">&gt;</span> 
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"img/rubbish-film.jpg"</span> <span class="na">alt=</span><span class="s">"film-rubbish"</span><span class="nt">&gt;</span> 
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">^=</span><span class="s1">"film"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="c">/* 样式 */</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">^</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">alt</code> 属性值中以 <code class="language-plaintext highlighter-rouge">film</code> 字符串开头的情况。即此时会选中 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 表情中，<code class="language-plaintext highlighter-rouge">alt</code> 属性以 <code class="language-plaintext highlighter-rouge">film</code> 开头的元素（在这里会同时选中上边的两个 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签）。</p> <p>（2）选中属性值包含某字符串的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"scones cream jam"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">data-ingredients</span><span class="o">*=</span><span class="s1">"cream"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的属性选择器，使用 <code class="language-plaintext highlighter-rouge">*</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">data-ingredients</code> 属性值中包含 <code class="language-plaintext highlighter-rouge">cream</code> 字符串的情况。此时 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 标签会被选中。</p> <p>（3）选中属性值以某字符串结尾的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"scones cream jam"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"toast jam butter"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"jam toast butter"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">data-ingredients</span><span class="err">$</span><span class="o">=</span><span class="s1">"jam"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的属性选择器，使用 <code class="language-plaintext highlighter-rouge">$</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">data-ingredients</code> 属性值中以 <code class="language-plaintext highlighter-rouge">jam</code> 字符串结尾的情况。此时，第一个 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 标签会被选中。</p> <h3 id="55-伪类选择器">5.5 伪类选择器</h3> <ul> <li><code class="language-plaintext highlighter-rouge">:last-child</code>：用于选择某个父元素中的最后一个子元素。</li> <li><code class="language-plaintext highlighter-rouge">:nth-child(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-last-child(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-of-type(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-last-of-type(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:not</code>：</li> <li><code class="language-plaintext highlighter-rouge">:empty</code>：</li> <li><code class="language-plaintext highlighter-rouge">:first-line</code>：</li> <li><code class="language-plaintext highlighter-rouge">:has</code>：</li> </ul> <h3 id="56-calc-函数">5.6 <code class="language-plaintext highlighter-rouge">calc()</code> 函数</h3> <h3 id="57-css3-的新颜色格式及透明度">5.7 CSS3 的新颜色格式及透明度</h3> <p>（1）可以使用 <code class="language-plaintext highlighter-rouge">rgb()</code> 或 <code class="language-plaintext highlighter-rouge">rgba()</code> 函数定义颜色，前者接收三个参数（取值为 0 ~ 255），分别表示红、绿、蓝三原色分量的值，后者除了这三个参数，还可以接受一个 alpha 透明度数值，取值为 0 ~ 1。</p> <p>（2）CSS3 还支持HSL（Hue Saturation Lightness，色相、饱和度、亮度）颜色系统。</p> <h2 id="六css3-高级技术">六、CSS3 高级技术</h2> <h2 id="七svg-与响应式-web-设计">七、SVG 与响应式 Web 设计</h2> <h2 id="八css3-过渡变形和动画">八、CSS3 过渡、变形和动画</h2> <h2 id="九表单">九、表单</h2> <h2 id="十参考">十、参考</h2> <ul> <li><a href="https://benfrain.com/">Ben Frain</a>，《响应式 Web 设计：HTML5和CSS实战》</li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a></li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程</a></li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2019/06/responsive-images.html">响应式图像教程</a></li> </ul>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="media queries"/><category term="responsive web design"/><category term="responsive images"/><category term="flex box layout"/><category term="grid layout"/><summary type="html"><![CDATA[一、简介]]></summary></entry><entry><title type="html">CSS Modules 用法教程</title><link href="https://feng-zhang0712.github.io//blog/2024/css-modules/" rel="alternate" type="text/html" title="CSS Modules 用法教程"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/css-modules</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/css-modules/"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2016/06/css_modules.html">CSS Modules 用法教程</a></p>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="css modules"/><summary type="html"><![CDATA[CSS Modules 用法教程]]></summary></entry><entry><title type="html">CSS 预处理器</title><link href="https://feng-zhang0712.github.io//blog/2024/css-preprocessor/" rel="alternate" type="text/html" title="CSS 预处理器"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/css-preprocessor</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/css-preprocessor/"><![CDATA[<h2 id="一概念">一、概念</h2> <p>CSS 预处理器是一种脚本语言，扩展了原生 CSS 的功能。通过预处理器，可以使用更高级的语法和特性来编写样式代码。预处理器文件（如 .sass）在编译过程中会被转换成标准的 CSS 文件。</p> <h2 id="二常见的-css-预处理器">二、常见的 CSS 预处理器</h2> <p>Sass：提供了两种语法，Sass（缩进语法）和 SCSS（类似 CSS 的语法）。Sass 是目前最流行的预处理器之一。 LESS：另一个流行的预处理器，语法上与 CSS 更接近，容易上手。</p> <h2 id="三预处理器的用途和优点">三、预处理器的用途和优点</h2> <h3 id="31-变量">3.1 变量</h3> <p>预处理器支持变量，可以用来存储重复使用的值（如颜色）等。</p> <h3 id="32-嵌套">3.2 嵌套</h3> <p>预处理器允许嵌套 CSS，可以更清晰地表示层次结构。</p> <h3 id="33-混合宏mixin">3.3. 混合宏（Mixin）</h3> <p>混合宏允许定义一组可重用的样式规则，类似于函数。可以通过传递参数自定义样式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@mixin</span> <span class="n">border-radius</span><span class="p">(</span><span class="err">$</span><span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">-webkit-border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
     <span class="nl">-moz-border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
          <span class="nl">border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button</span> <span class="p">{</span>
  <span class="err">@include</span> <span class="err">border-radius(10px);</span>
<span class="p">}</span>

</code></pre></div></div> <h3 id="34-继承">3.4 继承</h3> <p>预处理器支持继承样式，一个选择器可以继承另一个选择器的样式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="nt">button-styles</span> <span class="p">{</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">10px</span> <span class="m">20px</span><span class="p">;</span>
  <span class="nl">border</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
  <span class="nl">cursor</span><span class="p">:</span> <span class="nb">pointer</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button</span> <span class="p">{</span>
  <span class="err">@extend</span> <span class="err">%button-styles;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="m">#3498db</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button-secondary</span> <span class="p">{</span>
  <span class="err">@extend</span> <span class="err">%button-styles;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="m">#2ecc71</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="35-函数">3.5 函数</h3> <p>预处理器允许定义函数，进行复杂的计算和逻辑操作，然后返回值，供样式规则使用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@function</span> <span class="n">calculate-margin</span><span class="p">(</span><span class="err">$</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">@return</span> <span class="err">$</span><span class="n">value</span> <span class="err">*</span> <span class="m">1.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="n">calculate-margin</span><span class="p">(</span><span class="m">10px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="36-导入和拆分文件">3.6 导入和拆分文件</h3> <p>预处理器支持将样式拆分成多个文件，并使用 @import 语句导入。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* _variables.scss */</span>
<span class="err">$</span><span class="nt">primary-color</span><span class="o">:</span> <span class="err">#3498</span><span class="nt">db</span><span class="o">;</span>
<span class="err">$</span><span class="nt">secondary-color</span><span class="o">:</span> <span class="err">#2</span><span class="nt">ecc71</span><span class="o">;</span>

<span class="c">/* _mixins.scss */</span>
<span class="k">@mixin</span> <span class="n">flex-center</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* styles.scss */</span>
<span class="k">@import</span> <span class="s2">'variables'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s2">'mixins'</span><span class="p">;</span>
<span class="nc">.header</span> <span class="p">{</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="err">$</span><span class="n">primary-color</span><span class="p">;</span>
  <span class="err">@include</span> <span class="err">flex-center;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100vh</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="37-条件语句和循环">3.7 条件语句和循环</h3> <p>预处理器支持条件语句和循环。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="nt">themes</span><span class="o">:</span> <span class="o">(</span><span class="s2">'light'</span><span class="o">,</span> <span class="s2">'dark'</span><span class="o">);</span>
<span class="k">@each</span> <span class="err">$</span><span class="n">theme</span> <span class="n">in</span> <span class="err">$</span><span class="n">themes</span> <span class="p">{</span>
  <span class="nc">.theme-</span><span class="err">#</span><span class="p">{</span><span class="err">$theme</span><span class="p">}</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="n">if</span><span class="p">(</span><span class="err">$</span><span class="n">theme</span> <span class="err">==</span> <span class="s2">'light'</span><span class="p">,</span> <span class="m">#fff</span><span class="p">,</span> <span class="m">#333</span><span class="p">);</span>
    <span class="nl">color</span><span class="p">:</span> <span class="n">if</span><span class="p">(</span><span class="err">$</span><span class="n">theme</span> <span class="err">==</span> <span class="s2">'light'</span><span class="p">,</span> <span class="m">#333</span><span class="p">,</span> <span class="m">#fff</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="sass"/><summary type="html"><![CDATA[一、概念]]></summary></entry><entry><title type="html">React 中的事件</title><link href="https://feng-zhang0712.github.io//blog/2024/events-in-react/" rel="alternate" type="text/html" title="React 中的事件"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/events-in-react</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/events-in-react/"><![CDATA[<p>React 的事件代理机制（Event Delegation）是其性能优化的一种手段。通过事件代理，React 将所有的事件监听器统一绑定到根元素，而不是每个具体的 DOM 元素上。这种方法减少了实际绑定到 DOM 元素上的事件处理器数量，从而提升了性能，特别是在有大量动态生成的元素时。</p> <h3 id="事件代理的工作原理">事件代理的工作原理</h3> <ol> <li><strong>统一绑定事件处理器</strong>：React 会在组件挂载时，将所有事件处理器统一绑定到应用的根元素（例如 <code class="language-plaintext highlighter-rouge">document</code> 或 <code class="language-plaintext highlighter-rouge">root</code> DOM 节点）。</li> <li><strong>事件捕获和冒泡</strong>：当用户在具体的 DOM 元素上触发事件时，事件会按照捕获和冒泡的机制传播。React 利用这个机制，在事件冒泡到根元素时捕获事件。</li> <li><strong>事件分发</strong>：在根元素上捕获到事件后，React 解析事件的目标元素，并根据目标元素和事件类型，找到对应的 React 组件实例和事件处理器，然后调用该处理器。</li> </ol> <h3 id="优点">优点</h3> <ul> <li><strong>性能优化</strong>：减少了实际绑定在 DOM 元素上的事件处理器数量，降低了内存消耗和性能开销。</li> <li><strong>简化事件管理</strong>：通过统一的事件处理机制，简化了事件添加和移除的管理。</li> </ul> <h3 id="示例">示例</h3> <p>以下是一个简单的示例，展示了事件代理的基本概念：</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">ButtonList</span> <span class="kd">extends</span> <span class="nc">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 获取被点击的按钮元素</span>
    <span class="kd">const</span> <span class="nx">button</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Button </span><span class="p">${</span><span class="nx">button</span><span class="p">.</span><span class="nx">textContent</span><span class="p">}</span><span class="s2"> clicked!`</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 1<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 2<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 3<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">ButtonList</span><span class="p">;</span>
</code></pre></div></div> <p>在这个示例中，三个按钮的点击事件都通过 <code class="language-plaintext highlighter-rouge">div</code> 容器上的 <code class="language-plaintext highlighter-rouge">onClick</code> 处理器进行处理。点击任意按钮时，事件会冒泡到 <code class="language-plaintext highlighter-rouge">div</code> 容器，被捕获并处理。</p> <h3 id="深入理解">深入理解</h3> <ul> <li><strong>合成事件</strong>：React 使用合成事件（Synthetic Events）对象来封装浏览器的原生事件对象。合成事件对象提供了与原生事件对象相同的接口，但具备跨浏览器的兼容性。</li> <li><strong>事件池</strong>：React 维护一个事件池，用于存储和复用合成事件对象。事件处理器执行后，合成事件对象会被复用以提高性能。因此，在事件处理器中，不能异步访问合成事件对象；如果需要异步访问，可以调用 <code class="language-plaintext highlighter-rouge">event.persist()</code> 方法防止对象被复用。</li> </ul> <h3 id="注意事项">注意事项</h3> <ul> <li><strong>异步访问事件对象</strong>：在异步函数中访问合成事件对象时，需要调用 <code class="language-plaintext highlighter-rouge">event.persist()</code> 方法。例如：</li> </ul> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nf">persist</span><span class="p">();</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span> <span class="c1">// 异步访问事件对象</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li><strong>非冒泡事件</strong>：某些事件不会冒泡，例如 <code class="language-plaintext highlighter-rouge">onBlur</code> 和 <code class="language-plaintext highlighter-rouge">onFocus</code>。React 通过特殊处理，将这些事件也通过事件代理机制进行处理。</li> </ul> <h3 id="总结">总结</h3> <p>React 的事件代理机制通过在根元素上统一绑定事件处理器，有效地减少了实际绑定在 DOM 元素上的事件处理器数量，提升了性能，并简化了事件管理。这是 React 提升性能和简化事件管理的一种重要手段。</p>]]></content><author><name></name></author><category term="frontend"/><category term="react"/><category term="events"/><summary type="html"><![CDATA[React 的事件代理机制（Event Delegation）是其性能优化的一种手段。通过事件代理，React 将所有的事件监听器统一绑定到根元素，而不是每个具体的 DOM 元素上。这种方法减少了实际绑定到 DOM 元素上的事件处理器数量，从而提升了性能，特别是在有大量动态生成的元素时。]]></summary></entry><entry><title type="html">ES6 - Array</title><link href="https://feng-zhang0712.github.io//blog/2024/array/" rel="alternate" type="text/html" title="ES6 - Array"/><published>2024-09-12T00:00:00+00:00</published><updated>2024-09-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/array</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/array/"><![CDATA[]]></content><author><name></name></author><category term="frontend"/><category term="React"/><category term="es6"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">ES6 - async 函数</title><link href="https://feng-zhang0712.github.io//blog/2024/async/" rel="alternate" type="text/html" title="ES6 - async 函数"/><published>2024-09-12T00:00:00+00:00</published><updated>2024-09-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/async</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/async/"><![CDATA[<h2 id="一含义">一、含义</h2> <p>ES2017 标准引入了 <code class="language-plaintext highlighter-rouge">async</code> 函数，它是 Generator 函数的语法糖。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nf">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="nf">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
      <span class="nf">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">};</span>

<span class="c1">// 上面代码的函数 gen 可以写成 async 函数，就是下面这样。</span>
<span class="kd">const</span> <span class="nx">asyncReadFile</span> <span class="o">=</span> <span class="k">async</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div> <p>比较发现，<code class="language-plaintext highlighter-rouge">async</code> 函数就是将 Generator 函数的星号（*）替换成 <code class="language-plaintext highlighter-rouge">async</code>，将 <code class="language-plaintext highlighter-rouge">yield</code> 替换成 <code class="language-plaintext highlighter-rouge">await</code>，仅此而已。<code class="language-plaintext highlighter-rouge">async</code> 函数对 Generator 函数的改进，体现在以下四点。</p> <p>（1）<strong>内置执行器</strong></p> <p>Generator 函数的执行必须靠执行器，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一样。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">asyncReadFile</span><span class="p">();</span>
</code></pre></div></div> <p>上面的代码调用了 asyncReadFile 函数，然后它就会自动执行。这不像 Generator 函数，需要调用 next 方法才能真正执行，得到最后结果。</p> <p>（2）<strong>更好的语义</strong></p> <p><code class="language-plaintext highlighter-rouge">async</code> 和 <code class="language-plaintext highlighter-rouge">await</code>，比起星号（<code class="language-plaintext highlighter-rouge">*</code>）和 <code class="language-plaintext highlighter-rouge">yield</code>，语义更清楚。<code class="language-plaintext highlighter-rouge">async</code> 表示函数里有异步操作，<code class="language-plaintext highlighter-rouge">await</code> 表示紧跟在后面的表达式需要等待结果。</p> <p>（3）<strong>更广的适用性</strong></p> <p>co 模块约定，<code class="language-plaintext highlighter-rouge">yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而 <code class="language-plaintext highlighter-rouge">async</code> 函数的 <code class="language-plaintext highlighter-rouge">await</code> 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 <code class="language-plaintext highlighter-rouge">resolved</code> 的 Promise 对象）。</p> <p>（4）<strong>返回值是 Promise</strong></p> <p><code class="language-plaintext highlighter-rouge">async</code> 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象更方便。</p> <h2 id="二语法">二、语法</h2> <h3 id="21-返回-promise-对象">2.1 返回 Promise 对象</h3> <p><code class="language-plaintext highlighter-rouge">async</code> 函数返回一个 Promise 对象。</p> <p><code class="language-plaintext highlighter-rouge">async</code> 函数内部 <code class="language-plaintext highlighter-rouge">return</code> 语句返回的值，会成为 <code class="language-plaintext highlighter-rouge">then</code> 方法回调函数的参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">().</span><span class="nf">then</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
<span class="c1">// "hello world"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">async</code> 函数内部抛出错误，会导致返回的 Promise 对象变为 <code class="language-plaintext highlighter-rouge">reject</code> 状态。抛出的错误对象会被 <code class="language-plaintext highlighter-rouge">catch</code> 方法回调函数接收到。</p> <h3 id="22-promise-对象的状态变化">2.2 Promise 对象的状态变化</h3> <p>只有 <code class="language-plaintext highlighter-rouge">async</code> 函数内部的异步操作执行完，才会执行 <code class="language-plaintext highlighter-rouge">then</code> 方法指定的回调函数。</p> <h3 id="23-await-命令">2.3 await 命令</h3> <p>正常情况下，<code class="language-plaintext highlighter-rouge">await</code> 命令后面是一个 Promise 对象，返回该对象的结果。</p> <p>（1）如果 <code class="language-plaintext highlighter-rouge">await</code> 后面不是 Promise 对象，就直接返回对应的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 等同于</span>
  <span class="c1">// return 123;</span>
  <span class="k">return</span> <span class="k">await</span> <span class="mi">123</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">().</span><span class="nf">then</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// 123</span>
</code></pre></div></div> <p>（2）如果 <code class="language-plaintext highlighter-rouge">await</code> 命令后面是一个 <code class="language-plaintext highlighter-rouge">thenable</code> 对象（即定义了 <code class="language-plaintext highlighter-rouge">then</code> 方法的对象），那么 <code class="language-plaintext highlighter-rouge">await</code> 会将其等同于 Promise 对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Sleep</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">timeout</span> <span class="o">=</span> <span class="nx">timeout</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">startTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">();</span>
    <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nf">resolve</span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">timeout</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">(</span><span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">sleepTime</span> <span class="o">=</span> <span class="k">await</span> <span class="k">new</span> <span class="nc">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">sleepTime</span><span class="p">);</span>
<span class="p">})();</span>
<span class="c1">// 1000</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">await</code> 命令后面是一个 Sleep 对象的实例。这个实例不是 Promise 对象，但是因为定义了 <code class="language-plaintext highlighter-rouge">then</code> 方法，<code class="language-plaintext highlighter-rouge">await</code> 会将其视为 Promise 处理。</p> <p>（3）借助 <code class="language-plaintext highlighter-rouge">await</code> 命令可以实现休眠功能。下面给出了一个简化的 sleep 实现。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">sleep</span><span class="p">(</span><span class="nx">interval</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">interval</span><span class="p">);</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// 用法</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">one2FiveInAsync</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">one2FiveInAsync</span><span class="p">();</span>
</code></pre></div></div> <p>（4）当函数执行到 <code class="language-plaintext highlighter-rouge">await</code> 时，被等待的表达式会立即执行，所有依赖该表达式的值的代码会被暂停，并推送进微任务队列（microtask queue）。然后主线程被释放出来，用于事件循环中的下一个任务。即使等待的值是已经敲定的 promise 或不是 promise，也会发生这种情况。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">start</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">await</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">middle</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">end</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">foo</span><span class="p">(</span><span class="dl">"</span><span class="s2">First</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">foo</span><span class="p">(</span><span class="dl">"</span><span class="s2">Second</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// First start</span>
<span class="c1">// First middle</span>
<span class="c1">// Second start</span>
<span class="c1">// Second middle</span>
<span class="c1">// First end</span>
<span class="c1">// Second end</span>
</code></pre></div></div> <p>上面的代码，执行到 <code class="language-plaintext highlighter-rouge">await</code> 时，后面的代码会整体被安排进一个新的微任务，此后的函数体变为异步执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nf">queueMicrotask</span><span class="p">(</span><span class="kd">function</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">microtask</span><span class="dl">"</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">queueMicrotask</span><span class="p">(</span><span class="nx">test</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="p">(</span><span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">async function start</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">await</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">async function resume</span><span class="dl">"</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">await</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">async function end</span><span class="dl">"</span><span class="p">);</span>
<span class="p">})();</span>

<span class="nf">queueMicrotask</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">queueMicrotask() after calling async function</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">script sync part end</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// async function start</span>
<span class="c1">// script sync part end</span>
<span class="c1">// microtask 1</span>
<span class="c1">// async function resume 1</span>
<span class="c1">// queueMicrotask() after calling async function</span>
<span class="c1">// microtask 2</span>
<span class="c1">// async function resume 2</span>
<span class="c1">// microtask 3</span>
<span class="c1">// async function end</span>
</code></pre></div></div> <p>上面的代码，<code class="language-plaintext highlighter-rouge">test</code> 方法总会在异步函数恢复执行前被调用，呈现轮流的调度。微任务被执行的顺序通常就是入队的先后顺序，而 <code class="language-plaintext highlighter-rouge">console.log("queueMicrotask() after calling async function");</code> 比 <code class="language-plaintext highlighter-rouge">await</code> 晚入队，因此 <code class="language-plaintext highlighter-rouge">"queueMicrotask() after calling async function"</code> 在异步函数第一次恢复之后才输出。</p> <h3 id="24-使用注意点">2.4 使用注意点</h3> <ul> <li><code class="language-plaintext highlighter-rouge">await</code> 命令只能用在 <code class="language-plaintext highlighter-rouge">async</code> 函数之中，如果用在普通函数，就会报错。</li> <li><code class="language-plaintext highlighter-rouge">for</code> 循环和数组的 <code class="language-plaintext highlighter-rouge">reduce</code> 方法支持 <code class="language-plaintext highlighter-rouge">async</code> 函数。</li> <li><code class="language-plaintext highlighter-rouge">async</code> 函数可以保留运行堆栈。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">b</span><span class="p">().</span><span class="nf">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nf">c</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，函数 <code class="language-plaintext highlighter-rouge">a</code> 内部运行了一个异步任务 <code class="language-plaintext highlighter-rouge">b</code>。当 <code class="language-plaintext highlighter-rouge">b</code> 运行的时候，函数 <code class="language-plaintext highlighter-rouge">a</code> 不会中断，而是继续执行。等到 <code class="language-plaintext highlighter-rouge">b</code> 运行结束，可能 <code class="language-plaintext highlighter-rouge">a</code> 早就运行结束了，<code class="language-plaintext highlighter-rouge">b</code> 所在的上下文环境已经消失了。如果 <code class="language-plaintext highlighter-rouge">b</code> 或 <code class="language-plaintext highlighter-rouge">c</code> 报错，错误堆栈将不包括 <code class="language-plaintext highlighter-rouge">a</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">await</span> <span class="nf">b</span><span class="p">();</span>
  <span class="nf">c</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">b</code> 运行的时候，<code class="language-plaintext highlighter-rouge">a</code> 是暂停执行，上下文环境都保存着。一旦 <code class="language-plaintext highlighter-rouge">b</code> 或 <code class="language-plaintext highlighter-rouge">c</code> 报错，错误堆栈将包括 <code class="language-plaintext highlighter-rouge">a</code>。</p> <h2 id="三async-函数的实现原理">三、async 函数的实现原理</h2> <p><code class="language-plaintext highlighter-rouge">async</code> 函数的实现原理，就是将 <strong>Generator 函数</strong>和<strong>自动执行器</strong>，包装在一个函数里。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">spawn</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>所有的 <code class="language-plaintext highlighter-rouge">async</code> 函数都可以写成上面的第二种形式，其中的 <code class="language-plaintext highlighter-rouge">spawn</code> 函数就是自动执行器。</p> <p>下面是 <code class="language-plaintext highlighter-rouge">spawn</code> 函数的实现，基本就是前文自动执行器的翻版。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">spawn</span><span class="p">(</span><span class="nx">genF</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nf">genF</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nf">step</span><span class="p">(</span><span class="nx">nextF</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">next</span><span class="p">;</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="nx">next</span> <span class="o">=</span> <span class="nf">nextF</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">resolve</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nb">Promise</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="p">).</span><span class="nf">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">step</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">step</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="nf">step</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="四顶层-await">四、顶层 await</h2> <p>从 ES2022 开始，允许在模块的顶层独立使用 <code class="language-plaintext highlighter-rouge">await</code> 命令。它的主要目的是使用 <code class="language-plaintext highlighter-rouge">await</code> 解决模块异步加载的问题。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// awaiting.js</span>
<span class="kd">const</span> <span class="nx">dynamic</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span><span class="nx">someMission</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nf">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">output</span> <span class="o">=</span> <span class="nf">someProcess</span><span class="p">((</span><span class="k">await</span> <span class="nx">dynamic</span><span class="p">).</span><span class="k">default</span><span class="p">,</span> <span class="k">await</span> <span class="nx">data</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，两个异步操作在输出的时候，都加上了 <code class="language-plaintext highlighter-rouge">await</code> 命令。只有等到异步操作完成，这个模块才会输出值。加载这个模块的写法如下。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// usage.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">output</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./awaiting.js</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">outputPlusValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">output</span> <span class="o">+</span> <span class="nx">value</span> <span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">outputPlusValue</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</code></pre></div></div> <p>注意，顶层 <code class="language-plaintext highlighter-rouge">await</code> 只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的 <code class="language-plaintext highlighter-rouge">require()</code> 是同步加载，如果有顶层 <code class="language-plaintext highlighter-rouge">await</code>，就没法处理加载了。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://es6.ruanyifeng.com/#docs/async">async 函数</a></li> <li>MDN，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></li> </ul>]]></content><author><name></name></author><category term="frontend"/><category term="React"/><category term="es6"/><summary type="html"><![CDATA[一、含义]]></summary></entry></feed>