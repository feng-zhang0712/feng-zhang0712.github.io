<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-10T14:36:45+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/features/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/features</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/features/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/features/">《JavaScript 教程 - 语法专题》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一数据类型的转换">一、数据类型的转换</h2> <h3 id="1-强制转换">1. 强制转换</h3> <p>强制转换主要指使用 <code class="language-plaintext highlighter-rouge">Boolean()</code>、<code class="language-plaintext highlighter-rouge">Number()</code> 和 <code class="language-plaintext highlighter-rouge">String()</code> 三个函数，手动转换成布尔值、数字或者字符串。</p> <h4 id="11-boolean">1.1 Boolean()</h4> <p><code class="language-plaintext highlighter-rouge">Boolean()</code> 函数将任意类型的值转为布尔值。除了以下五个值的转换结果为 <code class="language-plaintext highlighter-rouge">false</code>，其他的值全部为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">undefined</code></li> <li><code class="language-plaintext highlighter-rouge">null</code></li> <li><code class="language-plaintext highlighter-rouge">0</code>（包含 <code class="language-plaintext highlighter-rouge">-0</code> 和 <code class="language-plaintext highlighter-rouge">+0</code>）</li> <li><code class="language-plaintext highlighter-rouge">NaN</code></li> <li><code class="language-plaintext highlighter-rouge">''</code>（空字符串）</li> </ul> <p>所有对象的布尔值都是 <code class="language-plaintext highlighter-rouge">true</code>，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于 <code class="language-plaintext highlighter-rouge">obj1</code> &amp;&amp; <code class="language-plaintext highlighter-rouge">obj2</code> 这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Boolean</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="12-number">1.2 Number()</h4> <p><code class="language-plaintext highlighter-rouge">Number()</code> 函数将任意类型的值转化成数值。</p> <h5 id="1原始类型值">（1）原始类型值</h5> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数值：转换后还是原来的值</span>
<span class="nc">Number</span><span class="p">(</span><span class="mi">324</span><span class="p">)</span> <span class="c1">// 324</span>

<span class="c1">// 字符串：如果可以被解析为数值，则转换为相应的数值</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">324</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 324</span>

<span class="c1">// 字符串：如果不可以被解析为数值，返回 NaN</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">324abc</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// NaN</span>

<span class="c1">// 空字符串转为0</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">''</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="c1">// 布尔值：true 转成 1，false 转成 0</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="c1">// undefined：转成 NaN</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// NaN</span>

<span class="c1">// null：转成 0</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 0</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Number()</code> 函数将字符串转为数值，要比 <code class="language-plaintext highlighter-rouge">parseInt()</code> 函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为 <code class="language-plaintext highlighter-rouge">NaN</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 42</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// NaN</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">parseInt()</code> 逐个解析字符，而 <code class="language-plaintext highlighter-rouge">Number()</code> 函数整体转换字符串的类型。</p> <p><code class="language-plaintext highlighter-rouge">parseInt()</code> 和 <code class="language-plaintext highlighter-rouge">Number()</code> 函数都会自动过滤一个字符串前导和后缀的空格。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="se">\t\</span><span class="s1">v</span><span class="se">\r</span><span class="s1">12.34</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 12</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="se">\t\</span><span class="s1">v</span><span class="se">\r</span><span class="s1">12.34</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 12.34</span>
</code></pre></div></div> <h5 id="2对象">（2）对象</h5> <p><code class="language-plaintext highlighter-rouge">Number()</code> 方法的参数是对象时，将返回 <code class="language-plaintext highlighter-rouge">NaN</code>，除非是包含单个数值的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// NaN</span>
<span class="nc">Number</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// NaN</span>
<span class="nc">Number</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// 5</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Number()</code> 方法的参数是对象时的转换规则是这样。</p> <ol> <li>调用对象自身的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法。如果返回原始类型的值，则直接对该值使用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数，不再进行后续步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法返回的还是对象，则改为调用对象自身的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数，不再进行后续步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回的是对象，就报错。</li> </ol> <p>默认情况下，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回对象本身，所以一般总是会调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，而 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回对象的类型字符串（比如 <code class="language-plaintext highlighter-rouge">[object Object]</code>）。当然，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，都是可以自定义的。</p> <h4 id="13-string">1.3 String()</h4> <p><code class="language-plaintext highlighter-rouge">String()</code> 函数可以将任意类型的值转化成字符串。</p> <h5 id="1原始类型值-1">（1）原始类型值</h5> <ul> <li><strong>数值</strong>：转为相应的字符串。</li> <li><strong>字符串</strong>：转换后还是原来的值。</li> <li><strong>布尔值</strong>：<code class="language-plaintext highlighter-rouge">true</code> 转为字符串 <code class="language-plaintext highlighter-rouge">"true"</code>，<code class="language-plaintext highlighter-rouge">false</code> 转为字符串 <code class="language-plaintext highlighter-rouge">"false"</code>。</li> <li><strong>undefined</strong>：转为字符串 <code class="language-plaintext highlighter-rouge">"undefined"</code>。</li> <li><strong>null</strong>：转为字符串 <code class="language-plaintext highlighter-rouge">"null"</code>。</li> </ul> <h5 id="2对象-1">（2）对象</h5> <p><code class="language-plaintext highlighter-rouge">String()</code> 方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// "[object Object]"</span>
<span class="nc">String</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// "1,2,3"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">String()</code> 方法的参数是对象时的转换规则跟 <code class="language-plaintext highlighter-rouge">Number()</code> 类似，只是互换了 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法和 <code class="language-plaintext highlighter-rouge">toString()</code> 方法的执行顺序。</p> <ul> <li>先调用对象自身的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。如果返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">String()</code> 函数，不再进行以下步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回的是对象，再调用原对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">String()</code> 函数，不再进行以下步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回的是对象，就报错。</li> </ul> <h3 id="2-自动转换">2. 自动转换</h3> <p>自动转换发生在三种情况：不同类型的数据互相运算、对非布尔值类型的数据求布尔值以及对非数值类型的值使用一元运算符（即 <code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">123</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span> <span class="c1">// "123abc"</span>

<span class="k">if </span><span class="p">(</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>  <span class="c1">// "hello"</span>

<span class="o">+</span> <span class="p">{</span><span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">}</span> <span class="c1">// NaN</span>
<span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1">// NaN</span>
</code></pre></div></div> <h4 id="21-自动转换为布尔值">2.1 自动转换为布尔值</h4> <p>预期为布尔值的地方（比如 <code class="language-plaintext highlighter-rouge">if</code> 语句的条件部分），系统内部会自动调用 <code class="language-plaintext highlighter-rouge">Boolean()</code> 函数将非布尔值的参数自动转换为布尔值。</p> <h4 id="22-自动转换为字符串">2.2 自动转换为字符串</h4> <p>预期为字符串的地方，就会将非字符串的值自动转为字符串。主要发生在字符串的加法运算时，当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p> <h4 id="23-自动转换为数值">2.3 自动转换为数值</h4> <p>预期为数值的地方，系统内部会自动调用 <code class="language-plaintext highlighter-rouge">Number()</code> 函数将参数值自动转换为数值。除了加法运算符（<code class="language-plaintext highlighter-rouge">+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p> <h2 id="二错误处理机制">二、错误处理机制</h2> <h3 id="1-error-实例对象">1. Error 实例对象</h3> <p>JavaScript 抛出的错误都是 <code class="language-plaintext highlighter-rouge">Error</code> 构造函数的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">err</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">出错了</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">err</span><span class="p">.</span><span class="nx">message</span> <span class="c1">// "出错了"</span>
</code></pre></div></div> <p>JavaScript 语言标准只提到，<code class="language-plaintext highlighter-rouge">Error</code> 实例对象必须有 <code class="language-plaintext highlighter-rouge">message</code> 属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对 <code class="language-plaintext highlighter-rouge">Error</code> 实例还提供 <code class="language-plaintext highlighter-rouge">name</code> 和 <code class="language-plaintext highlighter-rouge">stack</code> 属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p> <ul> <li><code class="language-plaintext highlighter-rouge">message</code>：错误提示信息</li> <li><code class="language-plaintext highlighter-rouge">name</code>：错误名称（非标准属性）</li> <li><code class="language-plaintext highlighter-rouge">stack</code>：错误的堆栈（非标准属性）</li> </ul> <h3 id="2-原生错误类型">2. 原生错误类型</h3> <p>JavaScript 在 <code class="language-plaintext highlighter-rouge">Error</code> 对象的基础上，定义了其他 6 种派生对象。</p> <h4 id="21-syntaxerror-对象">2.1 SyntaxError 对象</h4> <p><code class="language-plaintext highlighter-rouge">SyntaxError</code> 对象是解析代码时发生的语法错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 变量名错误</span>
<span class="kd">var</span> <span class="mi">1</span><span class="nx">a</span><span class="p">;</span>
<span class="c1">// Uncaught SyntaxError: Invalid or unexpected token</span>

<span class="c1">// 缺少括号</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Uncaught SyntaxError: Unexpected string</span>
</code></pre></div></div> <h4 id="22-referenceerror-对象">2.2 ReferenceError 对象</h4> <p><code class="language-plaintext highlighter-rouge">ReferenceError</code> 对象是引用一个不存在的变量时发生的错误。</p> <h4 id="23-rangeerror-对象">2.3 RangeError 对象</h4> <p><code class="language-plaintext highlighter-rouge">RangeError</code> 对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是 <code class="language-plaintext highlighter-rouge">Number</code> 对象的方法参数超出范围，以及函数堆栈超过最大值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组长度不得为负数</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Uncaught RangeError: Invalid array length</span>
</code></pre></div></div> <h4 id="24-typeerror-对象">2.4 TypeError 对象</h4> <p><code class="language-plaintext highlighter-rouge">TypeError</code> 对象是变量或参数不是预期类型时发生的错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="mi">123</span>
<span class="c1">// Uncaught TypeError: 123 is not a constructor</span>
</code></pre></div></div> <h4 id="25-urierror-对象">2.5 URIError 对象</h4> <p><code class="language-plaintext highlighter-rouge">URIError</code> 对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及 <code class="language-plaintext highlighter-rouge">encodeURI()</code>、<code class="language-plaintext highlighter-rouge">decodeURI()</code>、<code class="language-plaintext highlighter-rouge">encodeURIComponent()</code>、<code class="language-plaintext highlighter-rouge">decodeURIComponent()</code>、<code class="language-plaintext highlighter-rouge">escape()</code> 和 <code class="language-plaintext highlighter-rouge">unescape()</code> 这六个函数。</p> <h4 id="26-evalerror-对象">2.6 EvalError 对象</h4> <p><code class="language-plaintext highlighter-rouge">eval</code> 函数没有被正确执行时，会抛出 <code class="language-plaintext highlighter-rouge">EvalError</code> 错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p> <h3 id="3-自定义错误">3. 自定义错误</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">UserError</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">默认信息</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">UserError</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">UserError</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">();</span>
<span class="nx">UserError</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">UserError</span><span class="p">;</span>

<span class="k">new</span> <span class="nc">UserError</span><span class="p">(</span><span class="dl">'</span><span class="s1">这是自定义的错误！</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码自定义一个错误对象 <code class="language-plaintext highlighter-rouge">UserError</code>，让它<strong>继承</strong> <code class="language-plaintext highlighter-rouge">Error</code> 对象。然后，就可以生成这种自定义类型的错误了。</p> <h3 id="4-throw-语句">4. throw 语句</h3> <p><code class="language-plaintext highlighter-rouge">throw</code> 语句用于手动中断程序执行，抛出一个错误。可以是系统错误，也可以是自定义错误。实际上，<code class="language-plaintext highlighter-rouge">throw</code> 可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p> <h3 id="5-trycatch-和-trycatchfinally-结构">5. try…catch 和 try…catch…finally 结构</h3> <p><code class="language-plaintext highlighter-rouge">catch</code> 代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p> <p>下面的例子反映了 <code class="language-plaintext highlighter-rouge">try...catch...finally</code> 三者之间的执行顺序。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">throw</span> <span class="dl">'</span><span class="s1">bug</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 这句原本会延迟到 finally 代码块结束再执行</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 不会运行</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 这句会覆盖掉前面那句 return</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 不会运行</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 不会运行</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nf">f</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="c1">// 1</span>
<span class="c1">// 3</span>

<span class="nx">result</span>
<span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">catch</code> 代码块结束执行之前，会先执行 <code class="language-plaintext highlighter-rouge">finally</code> 代码块。</p> <h2 id="三编程风格">三、编程风格</h2> <h3 id="1-缩进">1. 缩进</h3> <p>不管是空格和 Tab 键，坚持使用一种方式。</p> <h3 id="2-区块">2. 区块</h3> <p>总是使用<strong>大括号</strong>表示区块。区块起首的大括号跟在关键字的后面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">block</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="3-圆括号">3. 圆括号</h3> <p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。建议可以用空格，区分这两种不同的括号。</p> <ul> <li>表示函数调用时，函数名与左括号之间没有空格。</li> <li>表示函数定义时，函数名与左括号之间没有空格。</li> <li>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</li> </ul> <h3 id="5-行尾的分号">5. 行尾的分号</h3> <h4 id="51-不使用分号的情况">5.1 不使用分号的情况</h4> <ul> <li><code class="language-plaintext highlighter-rouge">for</code> 和 <code class="language-plaintext highlighter-rouge">while</code> 循环</li> <li>分支语句：<code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">switch</code> 和 <code class="language-plaintext highlighter-rouge">try</code></li> <li>函数的声明语句</li> </ul> <h4 id="52-分号的自动添加">5.2 分号的自动添加</h4> <p>除了上边三种情况，所有语句都应该使用分号（即使如果没有使用分号，大多数情况下，JavaScript 会自动添加）。</p> <h3 id="6-全局变量">6. 全局变量</h3> <p>避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如 <code class="language-plaintext highlighter-rouge">UPPER_CASE</code>。</p> <h3 id="7-变量声明">7. 变量声明</h3> <p>变量最好放在代码块的头部。所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</p> <h3 id="8-with-语句">8. with 语句</h3> <p><code class="language-plaintext highlighter-rouge">with</code> 可以减少代码的书写，但是会造成混淆。因此，不要使用 <code class="language-plaintext highlighter-rouge">with</code> 语句。</p> <h3 id="9-相等和严格相等">9. 相等和严格相等</h3> <p>相等运算符会自动转换变量类型，造成很多意想不到的情况。建议不要使用相等运算符（<code class="language-plaintext highlighter-rouge">==</code>），只使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）。</p> <h3 id="10-语句的合并">10. 语句的合并</h3> <p>建议不要将不同目的的语句，合并成一行。</p> <h3 id="11-自增和自减运算符">11. 自增和自减运算符</h3> <p>建议自增（<code class="language-plaintext highlighter-rouge">++</code>）和自减（<code class="language-plaintext highlighter-rouge">--</code>）运算符尽量使用 <code class="language-plaintext highlighter-rouge">+=</code> 和 <code class="language-plaintext highlighter-rouge">-=</code> 代替。</p> <h3 id="12-switchcase-结构">12. switch…case 结构</h3> <p><code class="language-plaintext highlighter-rouge">switch...case</code> 结构要求，在每个 <code class="language-plaintext highlighter-rouge">case</code> 的最后一行必须是 <code class="language-plaintext highlighter-rouge">break</code> 语句，否则会接着运行下一个 <code class="language-plaintext highlighter-rouge">case</code>。这样不仅容易忘记，还会造成代码的冗长。</p> <p>而且，<code class="language-plaintext highlighter-rouge">switch...case</code> 不使用大括号，不利于代码形式的统一。此外，这种结构类似于 <code class="language-plaintext highlighter-rouge">goto</code> 语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch </span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid action.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码建议改写成对象结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">actions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">actions</span><span class="p">[</span><span class="nx">action</span><span class="p">]</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid action.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">actions</span><span class="p">[</span><span class="nx">action</span><span class="p">]();</span>
<span class="p">}</span>
</code></pre></div></div> <p>因此，建议 <code class="language-plaintext highlighter-rouge">switch...case</code> 结构可以用对象结构代替。</p> <h2 id="四console-对象与控制台">四、console 对象与控制台</h2> <h3 id="1-console-对象">1. console 对象</h3> <p><code class="language-plaintext highlighter-rouge">console</code> 对象可以输出各种信息到控制台。<code class="language-plaintext highlighter-rouge">console</code> 的常见用途有两个。</p> <ul> <li>调试程序，显示网页代码运行时的错误信息。</li> <li>提供了一个命令行接口，用来与网页代码互动。</li> </ul> <h3 id="2-console-对象的静态方法">2. console 对象的静态方法</h3> <h4 id="21-consolelogconsoleinfoconsoledebug">2.1 console.log()，console.info()，console.debug()</h4> <p><code class="language-plaintext highlighter-rouge">console.log</code> 方法用于在控制台输出信息。它可以接受一个或多个参数，不同类型的数据必须使用对应的占位符。</p> <ul> <li><code class="language-plaintext highlighter-rouge">%s</code> 字符串</li> <li><code class="language-plaintext highlighter-rouge">%d</code> 整数</li> <li><code class="language-plaintext highlighter-rouge">%i</code> 整数</li> <li><code class="language-plaintext highlighter-rouge">%f</code> 浮点数</li> <li><code class="language-plaintext highlighter-rouge">%o</code> 对象的链接</li> <li><code class="language-plaintext highlighter-rouge">%c</code> CSS 格式字符串</li> </ul> <p>使用 <code class="language-plaintext highlighter-rouge">%c</code> 占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">%cThis text is styled!</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">color: red; background: yellow; font-size: 24px;</span><span class="dl">'</span>
<span class="p">)</span>
</code></pre></div></div> <p>上面代码运行后，输出的内容将显示为黄底红字。</p> <p><code class="language-plaintext highlighter-rouge">console.info</code> 是 <code class="language-plaintext highlighter-rouge">console.log</code> 方法的别名，用法完全一样。只不过 <code class="language-plaintext highlighter-rouge">console.info</code> 方法会在输出信息的前面，加上一个蓝色图标。</p> <p><code class="language-plaintext highlighter-rouge">console.debug</code> 方法与 <code class="language-plaintext highlighter-rouge">console.log</code> 方法类似，会在控制台输出调试信息。但是，默认情况下，<code class="language-plaintext highlighter-rouge">console.debug</code> 输出的信息不会显示，只有在打开显示级别在 <code class="language-plaintext highlighter-rouge">verbose</code> 的情况下，才会显示。</p> <p><code class="language-plaintext highlighter-rouge">console</code> 对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义 <code class="language-plaintext highlighter-rouge">console.log</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">log</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">info</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">warn</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span> <span class="o">=</span> <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nf">bind</span><span class="p">(</span>
    <span class="nx">console</span><span class="p">,</span>
    <span class="k">new</span> <span class="nc">Date</span><span class="p">().</span><span class="nf">toISOString</span><span class="p">()</span>
  <span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">出错了！</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// 2014-05-18T09:00.000Z 出错了！</span>
</code></pre></div></div> <p>上面代码表示，使用自定义的 <code class="language-plaintext highlighter-rouge">console.log</code> 方法，可以在显示结果添加当前时间。</p> <h4 id="22-consolewarnconsoleerror">2.2 console.warn()，console.error()</h4> <p><code class="language-plaintext highlighter-rouge">warn</code> 方法和 <code class="language-plaintext highlighter-rouge">error</code> 方法也是在控制台输出信息，它们与 <code class="language-plaintext highlighter-rouge">log</code> 方法的不同之处在于，<code class="language-plaintext highlighter-rouge">warn</code> 方法输出信息时，在最前面加一个黄色三角，表示警告；<code class="language-plaintext highlighter-rouge">error</code> 方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p> <h4 id="23-consoletable">2.3 console.table()</h4> <p>对于某些复合类型的数据，<code class="language-plaintext highlighter-rouge">console.table</code> 方法可以将其转为表格显示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">languages</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">JavaScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.js</span><span class="dl">"</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TypeScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.ts</span><span class="dl">"</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">CoffeeScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.coffee</span><span class="dl">"</span> <span class="p">}</span>
<span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">table</span><span class="p">(</span><span class="nx">languages</span><span class="p">);</span>
</code></pre></div></div> <table> <thead> <tr> <th>-(index)-</th> <th>-name-</th> <th>-fileExtension-</th> </tr> </thead> <tbody> <tr> <td>0 -</td> <td>“JavaScript”</td> <td>“.js”</td> </tr> <tr> <td>1 -</td> <td>“TypeScript”</td> <td>“.ts”</td> </tr> <tr> <td>2 -</td> <td>“CoffeeScript”</td> <td>“.coffee”</td> </tr> </tbody> </table> <h4 id="24-consolecount">2.4 console.count()</h4> <p><code class="language-plaintext highlighter-rouge">count</code> 方法用于计数，输出它被调用了多少次。该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p> <h4 id="25-consoledirconsoledirxml">2.5 console.dir()，console.dirxml()</h4> <p><code class="language-plaintext highlighter-rouge">dir</code> 方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">({</span><span class="na">f1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="na">f2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">})</span>
<span class="c1">// Object {f1: "foo", f2: "bar"}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">dir</span><span class="p">({</span><span class="na">f1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="na">f2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">})</span>
<span class="c1">// Object</span>
<span class="c1">//   f1: "foo"</span>
<span class="c1">//   f2: "bar"</span>
<span class="c1">//   __proto__: Object</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">dirxml</code> 方法主要用于以目录树的形式，显示 DOM 节点。如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code class="language-plaintext highlighter-rouge">console.dirxml</code> 等同于 <code class="language-plaintext highlighter-rouge">console.dir</code>。</p> <h4 id="26-consoleassert">2.6 console.assert()</h4> <p><code class="language-plaintext highlighter-rouge">console.assert</code> 方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p> <p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为 <code class="language-plaintext highlighter-rouge">false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">assert</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="dl">'</span><span class="s1">判断条件不成立</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Assertion failed: 判断条件不成立</span>
</code></pre></div></div> <h4 id="27-consoletimeconsoletimeend">2.7 console.time()，console.timeEnd()</h4> <p>这两个方法用于计时，可以算出一个操作所花费的准确时间。<code class="language-plaintext highlighter-rouge">time</code> 方法表示计时开始，<code class="language-plaintext highlighter-rouge">timeEnd</code> 方法表示计时结束。它们的参数是计时器的名称。调用 <code class="language-plaintext highlighter-rouge">timeEnd</code> 方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">time</span><span class="p">(</span><span class="dl">'</span><span class="s1">Array initialize</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">array</span><span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">timeEnd</span><span class="p">(</span><span class="dl">'</span><span class="s1">Array initialize</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Array initialize: 1914.481ms</span>
</code></pre></div></div> <h4 id="28-consolegroupconsolegroupendconsolegroupcollapsed">2.8 console.group()，console.groupEnd()，console.groupCollapsed()</h4> <p><code class="language-plaintext highlighter-rouge">console.group</code> 和 <code class="language-plaintext highlighter-rouge">console.groupEnd</code> 这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p> <p><code class="language-plaintext highlighter-rouge">console.groupCollapsed</code> 方法与 <code class="language-plaintext highlighter-rouge">console.group</code> 方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p> <h4 id="29-consoletraceconsoleclear">2.9 console.trace()，console.clear()</h4> <p><code class="language-plaintext highlighter-rouge">console.trace</code> 方法显示当前执行的代码在堆栈中的调用路径。</p> <p><code class="language-plaintext highlighter-rouge">console.clear</code> 方法用于清除当前控制台的所有输出，将光标回置到第一行。</p> <h3 id="3-控制台命令行-api">3. 控制台命令行 API</h3> <p>浏览器控制台中，除了使用 <code class="language-plaintext highlighter-rouge">console</code> 对象，还可以使用一些控制台自带的命令行方法。</p> <p>（1）<code class="language-plaintext highlighter-rouge">$_</code></p> <p><code class="language-plaintext highlighter-rouge">$_</code> 属性返回上一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="c1">// 4</span>
<span class="nx">$_</span>
<span class="c1">// 4</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">$0</code> - <code class="language-plaintext highlighter-rouge">$4</code></p> <p>控制台保存了最近 5 个在 Elements 面板选中的 DOM 元素，<code class="language-plaintext highlighter-rouge">$0</code> 代表倒数第一个（最近一个），<code class="language-plaintext highlighter-rouge">$1</code> 代表倒数第二个，以此类推直到 <code class="language-plaintext highlighter-rouge">$4</code>。</p> <p>（3）<code class="language-plaintext highlighter-rouge">$(selector)</code></p> <p><code class="language-plaintext highlighter-rouge">$(selector)</code> 返回第一个匹配的元素，等同于 <code class="language-plaintext highlighter-rouge">document.querySelector()</code>。注意，如果页面脚本对 <code class="language-plaintext highlighter-rouge">$</code> 有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行 <code class="language-plaintext highlighter-rouge">$(selector)</code> 就会采用 jQuery 的实现，返回一个数组。</p> <p>（4）<code class="language-plaintext highlighter-rouge">$$(selector)</code></p> <p><code class="language-plaintext highlighter-rouge">$$(selector)</code> 返回选中的 DOM 对象，等同于 <code class="language-plaintext highlighter-rouge">document.querySelectorAll</code>。</p> <p>（5）<code class="language-plaintext highlighter-rouge">$x(path)</code></p> <p><code class="language-plaintext highlighter-rouge">$x(path)</code> 方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">$x</span><span class="p">(</span><span class="dl">"</span><span class="s2">//p[a]</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div> <p>上面代码返回所有包含a元素的p元素。</p> <p>（6）<code class="language-plaintext highlighter-rouge">inspect(object)</code></p> <p><code class="language-plaintext highlighter-rouge">inspect(object)</code> 方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在 Elements 面板中显示，比如 <code class="language-plaintext highlighter-rouge">inspect(document)</code> 会在 Elements 面板显示 <code class="language-plaintext highlighter-rouge">document</code> 元素。JavaScript 对象在控制台面板 Profiles 面板中显示，比如 <code class="language-plaintext highlighter-rouge">inspect(window)</code>。</p> <p>（7）<code class="language-plaintext highlighter-rouge">getEventListeners(object)</code></p> <p><code class="language-plaintext highlighter-rouge">getEventListeners(object)</code> 方法返回一个对象，该对象的成员为 <code class="language-plaintext highlighter-rouge">object</code> 登记了回调函数的各种事件（比如 <code class="language-plaintext highlighter-rouge">click</code> 或 <code class="language-plaintext highlighter-rouge">keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p> <p>（8）<code class="language-plaintext highlighter-rouge">keys(object)</code>，<code class="language-plaintext highlighter-rouge">values(object)</code></p> <p><code class="language-plaintext highlighter-rouge">keys(object)</code> 方法返回一个数组，包含 <code class="language-plaintext highlighter-rouge">object</code> 的所有键名。</p> <p><code class="language-plaintext highlighter-rouge">values(object)</code> 方法返回一个数组，包含 <code class="language-plaintext highlighter-rouge">object</code> 的所有键值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="dl">'</span><span class="s1">p1</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p2</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">};</span>

<span class="nf">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
<span class="c1">// ["p1", "p2"]</span>
<span class="nf">values</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
<span class="c1">// ["a", "b"]</span>
</code></pre></div></div> <p>（9）<code class="language-plaintext highlighter-rouge">monitorEvents(object[, events])</code>，<code class="language-plaintext highlighter-rouge">unmonitorEvents(object[, events])</code></p> <p><code class="language-plaintext highlighter-rouge">monitorEvents(object[, events])</code> 方法监听特定对象上发生的特定事件。事件发生时，会返回一个 <code class="language-plaintext highlighter-rouge">Event</code> 对象，包含该事件的相关信息。<code class="language-plaintext highlighter-rouge">unmonitorEvents</code> 方法用于停止监听。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="dl">"</span><span class="s2">resize</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">monitorEvents</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">resize</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">scroll</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div> <p>上面代码分别表示单个事件和多个事件的监听方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nx">$0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">mouse</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">unmonitorEvents</span><span class="p">(</span><span class="nx">$0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码表示如何停止监听。</p> <p>monitorEvents 允许监听同一大类的事件。所有事件可以分成四个大类。</p> <ul> <li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li> <li>key：”keydown”, “keyup”, “keypress”, “textInput”</li> <li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li> <li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#msg</span><span class="dl">"</span><span class="p">),</span> <span class="dl">"</span><span class="s2">key</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码表示监听所有 <code class="language-plaintext highlighter-rouge">key</code> 大类的事件。</p> <p>（10）其他方法</p> <p>命令行 API 还提供以下方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">clear()</code>：清除控制台的历史。</li> <li><code class="language-plaintext highlighter-rouge">copy(object)</code>：复制特定 DOM 元素到剪贴板。</li> <li><code class="language-plaintext highlighter-rouge">dir(object)</code>：显示特定对象的所有属性，是 <code class="language-plaintext highlighter-rouge">console.dir</code> 方法的别名。</li> <li><code class="language-plaintext highlighter-rouge">dirxml(object)</code>：显示特定对象的 XML 形式，是 <code class="language-plaintext highlighter-rouge">console.dirxml</code> 方法的别名。</li> </ul> <h3 id="4-debugger-语句">4. debugger 语句</h3> <p><code class="language-plaintext highlighter-rouge">debugger</code> 语句主要用于除错，作用是设置断点。</p> <h2 id="五参考">五、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/features/">JavaScript 教程 - 语法专题</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 语法专题》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/stdlib/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/stdlib</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/stdlib/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/stdlib/">《JavaScript 教程 - 标准库》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一object-对象">一、Object 对象</h2> <h3 id="1-object">1. Object()</h3> <p><code class="language-plaintext highlighter-rouge">Object</code> 本身是一个函数，可以当作工具方法使用，<strong>将任意值转为对象</strong>。</p> <p>（1）如果参数是对象，它总是返回该对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">isObject</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">===</span> <span class="nc">Object</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">isObject</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nf">isObject</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>（2）如果参数是原始类型的值，<code class="language-plaintext highlighter-rouge">Object</code> 方法将其转为对应的<strong>包装对象</strong>的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Number</span> <span class="c1">// true</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">String</span> <span class="c1">// true</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span>
<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Boolean</span> <span class="c1">// true</span>
</code></pre></div></div> <p>（3）如果参数为空（或者为 <code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code>），<code class="language-plaintext highlighter-rouge">Object()</code> 返回一个空对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">();</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nc">Object</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="2-object-构造函数">2. Object 构造函数</h3> <p><code class="language-plaintext highlighter-rouge">Object</code> 前面使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，可以当作构造函数使用。</p> <p><code class="language-plaintext highlighter-rouge">Object</code> 构造函数的首要用途，是直接通过它来生成新对象。通过 <code class="language-plaintext highlighter-rouge">var obj = new Object()</code> 的写法生成新对象，与字面量的写法 <code class="language-plaintext highlighter-rouge">var obj = {}</code> 是等价的。或者说，后者只是前者的一种简便写法。</p> <p><code class="language-plaintext highlighter-rouge">Object</code> 构造函数的用法与工具方法的行为相似，但两者语义不同。<code class="language-plaintext highlighter-rouge">Object(value)</code> 表示将 <code class="language-plaintext highlighter-rouge">value</code> 转成一个对象，<code class="language-plaintext highlighter-rouge">new Object(value)</code> 则表示新生成一个对象，它的值是 <code class="language-plaintext highlighter-rouge">value</code>。</p> <h3 id="3-object-的静态方法">3. Object 的静态方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Object.keys()</code>：返回一个数组，其包含给定对象中所有<strong>自身的</strong>（不包括继承的）、所有<strong>可枚举的</strong>属性名。</li> <li><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyNames()</code>：返回一个数组，其包含给定对象中所有<strong>自身的</strong>属性名（包括<strong>不可枚举</strong>的属性，但不包括使用 <code class="language-plaintext highlighter-rouge">symbol</code> 值作为名称的属性）。</li> <li><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li> <li><code class="language-plaintext highlighter-rouge">Object.defineProperty()</code>：通过描述对象，定义某个属性。</li> <li><code class="language-plaintext highlighter-rouge">Object.defineProperties()</code>：通过描述对象，定义多个属性。</li> <li><code class="language-plaintext highlighter-rouge">Object.preventExtensions()</code>：防止对象扩展。</li> <li><code class="language-plaintext highlighter-rouge">Object.isExtensible()</code>：判断对象是否可扩展。</li> <li><code class="language-plaintext highlighter-rouge">Object.seal()</code>：禁止对象配置。</li> <li><code class="language-plaintext highlighter-rouge">Object.isSealed()</code>：判断一个对象是否可配置。</li> <li><code class="language-plaintext highlighter-rouge">Object.freeze()</code>：冻结一个对象。</li> <li><code class="language-plaintext highlighter-rouge">Object.isFrozen()</code>：判断一个对象是否被冻结。</li> </ul> <h3 id="4-object-的实例方法">4. Object 的实例方法</h3> <p><code class="language-plaintext highlighter-rouge">Object</code> 的实例方法定义在 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 对象上，所有 <code class="language-plaintext highlighter-rouge">Object</code> 的实例对象都继承了这些方法。</p> <p><code class="language-plaintext highlighter-rouge">Object</code> 实例对象的方法，主要有以下 6 个。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Object.prototype.valueOf()</code>：返回当前对象对应的值。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code>：返回当前对象对应的字符串形式。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li> <li><code class="language-plaintext highlighter-rouge">Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li> </ul> <h4 id="41-objectprototypevalueof">4.1 Object.prototype.valueOf()</h4> <p><code class="language-plaintext highlighter-rouge">valueOf()</code> 方法的用于返回对象的“<strong>值</strong>”，默认返回对象本身。<code class="language-plaintext highlighter-rouge">valueOf()</code> 方法的主要用途是，JavaScript <strong>自动类型转换</strong>时会默认调用这个方法。</p> <p>可以自定义对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。</p> <h4 id="42-objectprototypetostring">4.2 Object.prototype.toString()</h4> <p><code class="language-plaintext highlighter-rouge">toString()</code> 方法用于返回对象的字符串形式，默认返回类型字符串。</p> <p>字符串、数组、函数、<code class="language-plaintext highlighter-rouge">Date</code> 对象都分别部署了自定义的 <code class="language-plaintext highlighter-rouge">toString</code> 方法，覆盖了 <code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "1,2,3"</span>

<span class="dl">'</span><span class="s1">123</span><span class="dl">'</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "123"</span>

<span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">123</span><span class="p">;</span>
<span class="p">}).</span><span class="nf">toString</span><span class="p">()</span>
<span class="c1">// "function () {</span>
<span class="c1">//   return 123;</span>
<span class="c1">// }"</span>

<span class="p">(</span><span class="k">new</span> <span class="nc">Date</span><span class="p">()).</span><span class="nf">toString</span><span class="p">()</span>
<span class="c1">// "Tue May 10 2016 09:11:31 GMT+0800 (CST)"</span>
</code></pre></div></div> <p>可以自定义对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。</p> <h3 id="43-tostring-的应用判断数据类型">4.3 toString() 的应用：判断数据类型</h3> <p><code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code> 方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "[object Object]"</span>
</code></pre></div></div> <p>由于实例对象可能会自定义 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，覆盖掉 <code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code> 方法，所以为了得到类型字符串，最好直接使用 <code class="language-plaintext highlighter-rouge">Object.prototype.toString()</code> 方法。通过函数的 <code class="language-plaintext highlighter-rouge">call()</code> 方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
</code></pre></div></div> <p>不同数据类型的 Object.prototype.toString 方法返回值如下。</p> <ul> <li>数值：返回 <code class="language-plaintext highlighter-rouge">[object Number]</code>。</li> <li>字符串：返回 <code class="language-plaintext highlighter-rouge">[object String]</code>。</li> <li>布尔值：返回 <code class="language-plaintext highlighter-rouge">[object Boolean]</code>。</li> <li><code class="language-plaintext highlighter-rouge">undefined</code>：返回 <code class="language-plaintext highlighter-rouge">[object Undefined]</code>。</li> <li><code class="language-plaintext highlighter-rouge">null</code>：返回 <code class="language-plaintext highlighter-rouge">[object Null]</code>。</li> <li>数组：返回 <code class="language-plaintext highlighter-rouge">[object Array]</code>。</li> <li><code class="language-plaintext highlighter-rouge">arguments</code> 对象：返回 <code class="language-plaintext highlighter-rouge">[object Arguments]</code>。</li> <li>函数：返回 <code class="language-plaintext highlighter-rouge">[object Function]</code>。</li> <li><code class="language-plaintext highlighter-rouge">Error</code> 对象：返回 <code class="language-plaintext highlighter-rouge">[object Error]</code>。</li> <li><code class="language-plaintext highlighter-rouge">Date</code> 对象：返回 <code class="language-plaintext highlighter-rouge">[object Date]</code>。</li> <li><code class="language-plaintext highlighter-rouge">RegExp</code> 对象：返回 <code class="language-plaintext highlighter-rouge">[object RegExp]</code>。</li> <li>其他对象：返回 <code class="language-plaintext highlighter-rouge">[object Object]</code>。</li> </ul> <p>利用这个特性，可以写出一个比 <code class="language-plaintext highlighter-rouge">typeof</code> 运算符更准确的类型判断函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\[</span><span class="sr">object </span><span class="se">(</span><span class="sr">.*</span><span class="se">?)\]</span><span class="sr">/</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="nf">toLowerCase</span><span class="p">();</span>
<span class="p">};</span>

<span class="nf">type</span><span class="p">({});</span> <span class="c1">// "object"</span>
<span class="nf">type</span><span class="p">([]);</span> <span class="c1">// "array"</span>
<span class="nf">type</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// "number"</span>
<span class="nf">type</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// "null"</span>
<span class="nf">type</span><span class="p">();</span> <span class="c1">// "undefined"</span>
<span class="nf">type</span><span class="p">(</span><span class="sr">/abcd/</span><span class="p">);</span> <span class="c1">// "regex"</span>
<span class="nf">type</span><span class="p">(</span><span class="k">new</span> <span class="nc">Date</span><span class="p">());</span> <span class="c1">// "date"</span>
</code></pre></div></div> <p>在上面这个 <code class="language-plaintext highlighter-rouge">type</code> 函数的基础上，还可以加上专门判断某种类型数据的方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\[</span><span class="sr">object </span><span class="se">(</span><span class="sr">.*</span><span class="se">?)\]</span><span class="sr">/</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="nf">toLowerCase</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">[</span><span class="dl">'</span><span class="s1">Null</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Undefined</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Object</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Array</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">String</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Number</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Boolean</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">Function</span><span class="dl">'</span><span class="p">,</span>
 <span class="dl">'</span><span class="s1">RegExp</span><span class="dl">'</span>
<span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">type</span><span class="p">[</span><span class="dl">'</span><span class="s1">is</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">t</span><span class="p">]</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">type</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="o">===</span> <span class="nx">t</span><span class="p">.</span><span class="nf">toLowerCase</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">});</span>

<span class="nx">type</span><span class="p">.</span><span class="nf">isObject</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nx">type</span><span class="p">.</span><span class="nf">isNumber</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">type</span><span class="p">.</span><span class="nf">isRegExp</span><span class="p">(</span><span class="sr">/abc/</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="44-objectprototypetolocalestring">4.4 Object.prototype.toLocaleString()</h3> <p><code class="language-plaintext highlighter-rouge">Object.prototype.toLocaleString()</code> 方法与 <code class="language-plaintext highlighter-rouge">toString()</code> 的返回结果相同，也是返回一个值的字符串形式。这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的 <code class="language-plaintext highlighter-rouge">toLocaleString()</code>，用来返回针对某些地域的特定的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">toString</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Henry Norman Bethune</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="na">toLocaleString</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">白求恩</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// Henry Norman Bethune</span>
<span class="nx">person</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">()</span> <span class="c1">// 白求恩</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">toString()</code> 方法返回对象的一般字符串形式，<code class="language-plaintext highlighter-rouge">toLocaleString()</code> 方法返回本地的字符串形式。</p> <p>目前，主要有三个对象自定义了 <code class="language-plaintext highlighter-rouge">toLocaleString()</code> 方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Number.prototype.toLocaleString()</code></li> <li><code class="language-plaintext highlighter-rouge">Array.prototype.toLocaleString()</code></li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toLocaleString()</code></li> </ul> <p>举例来说，日期的实例对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 和 <code class="language-plaintext highlighter-rouge">toLocaleString()</code> 返回值就不一样，而且 <code class="language-plaintext highlighter-rouge">toLocaleString()</code> 的返回值跟用户设定的所在地域相关。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">date</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"</span>
<span class="nx">date</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">()</span> <span class="c1">// "1/01/2018, 12:01:33 PM"</span>
</code></pre></div></div> <h3 id="45-objectprototypehasownproperty">4.5 Object.prototype.hasOwnProperty()</h3> <p><code class="language-plaintext highlighter-rouge">Object.prototype.hasOwnProperty()</code> 方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象<strong>自身</strong>是否具有该属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="mi">123</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h2 id="二属性描述对象">二、属性描述对象</h2> <h3 id="1-概述">1. 概述</h3> <p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“<strong>属性描述对象</strong>”（attributes object）。<strong>每个属性</strong>都有自己对应的属性描述对象，保存该属性的一些元信息。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="nx">writable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">configurable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="kd">get</span><span class="p">:</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="kd">set</span><span class="p">:</span> <span class="kc">undefined</span>
<span class="p">}</span>
</code></pre></div></div> <p>属性描述对象提供 6 个元属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">value</code>：该属性的属性值，默认为 <code class="language-plaintext highlighter-rouge">undefined</code>。</li> <li><code class="language-plaintext highlighter-rouge">writable</code>：布尔值，表示属性值（value）是否可改变（即是否可写），默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">enumerable</code>：布尔值，表示该属性是否可遍历，默认为 <code class="language-plaintext highlighter-rouge">true</code>。如果设为 <code class="language-plaintext highlighter-rouge">false</code>，会使得某些操作（比如 <code class="language-plaintext highlighter-rouge">for...in</code> 循环、<code class="language-plaintext highlighter-rouge">Object.keys()</code>）跳过该属性。</li> <li><code class="language-plaintext highlighter-rouge">configurable</code>：布尔值，表示属性的可配置性，默认为 <code class="language-plaintext highlighter-rouge">true</code>。如果设为 <code class="language-plaintext highlighter-rouge">false</code>，将阻止某些操作改写属性描述对象，比如无法删除该属性，也不得改变各种元属性（<code class="language-plaintext highlighter-rouge">value</code> 属性除外）。也就是说，<code class="language-plaintext highlighter-rouge">configurable</code> 属性控制了属性描述对象的可写性。</li> <li><code class="language-plaintext highlighter-rouge">get</code>：函数，表示该属性的取值函数（getter），默认为 <code class="language-plaintext highlighter-rouge">undefined</code>。</li> <li><code class="language-plaintext highlighter-rouge">set</code>：函数，表示该属性的存值函数（setter），默认为 <code class="language-plaintext highlighter-rouge">undefined</code>。</li> </ul> <h3 id="2-objectgetownpropertydescriptor">2. Object.getOwnPropertyDescriptor()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor()</code> 方法可以获取某个属性的描述对象。此方法只能用于对象<strong>自身</strong>的属性，不能用于继承的属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Object { value: "a",</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true</span>
<span class="c1">// }</span>
</code></pre></div></div> <h3 id="3-objectgetownpropertynames">3. Object.getOwnPropertyNames()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyNames()</code> 方法返回一个数组，其包含给定对象中所有自身的属性名（包括<strong>不可枚举的</strong>属性，但不包括使用 <code class="language-plaintext highlighter-rouge">symbol</code> 值作为名称的属性）。</p> <h3 id="4-objectdefinepropertyobjectdefineproperties">4. Object.defineProperty()，Object.defineProperties()</h3> <p><code class="language-plaintext highlighter-rouge">Object.defineProperty()</code> 方法用于通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。如果属性已经存在，<code class="language-plaintext highlighter-rouge">Object.defineProperty()</code> 方法相当于更新该属性的属性描述对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 123</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">246</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 123</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.defineProperties()</code> 方法用于一次性定义或修改多个属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperties</span><span class="p">({},</span> <span class="p">{</span>
  <span class="na">p1</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">p2</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">p3</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span>
    <span class="na">get</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">;</span>
    <span class="p">},</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p1</span> <span class="c1">// 123</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p2</span> <span class="c1">// "abc"</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p3</span> <span class="c1">// "123abc"</span>
</code></pre></div></div> <p>注意，一旦定义了取值函数 <code class="language-plaintext highlighter-rouge">get</code>（或存值函数 <code class="language-plaintext highlighter-rouge">set</code>），就不能将 <code class="language-plaintext highlighter-rouge">writable</code> 属性设为 <code class="language-plaintext highlighter-rouge">true</code>，或者同时定义 <code class="language-plaintext highlighter-rouge">value</code> 属性，否则会报错。</p> <h3 id="5-objectprototypepropertyisenumerable">5. Object.prototype.propertyIsEnumerable()</h3> <p>实例对象的 <code class="language-plaintext highlighter-rouge">propertyIsEnumerable()</code> 方法返回一个布尔值，用来判断某个属性是否<strong>可遍历</strong>。注意，这个方法只能用于判断对象<strong>自身的</strong>属性，对于继承的属性一律返回 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nf">propertyIsEnumerable</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">propertyIsEnumerable</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h3 id="6-元属性">6. 元属性</h3> <p>属性描述对象的各个属性称为“<strong>元属性</strong>”，因为它们可以看作是控制属性的属性。</p> <h4 id="61-value">6.1 value</h4> <p><code class="language-plaintext highlighter-rouge">value</code> 属性是目标属性的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">value</span>
<span class="c1">// 123</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="mi">246</span> <span class="p">});</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 246</span>
</code></pre></div></div> <h4 id="62-configurable">6.2 configurable</h4> <p><code class="language-plaintext highlighter-rouge">configurable</code>（可配置性）返回一个布尔值，用于是否可以修改属性描述对象。</p> <ul> <li><code class="language-plaintext highlighter-rouge">configurable</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 时，<code class="language-plaintext highlighter-rouge">writable</code>、<code class="language-plaintext highlighter-rouge">enumerable</code> 和 <code class="language-plaintext highlighter-rouge">configurable</code> 都不能被修改。</li> <li> <p>只要 <code class="language-plaintext highlighter-rouge">writable</code> 和 <code class="language-plaintext highlighter-rouge">configurable</code> 有一个为 <code class="language-plaintext highlighter-rouge">true</code>，就允许改动 <code class="language-plaintext highlighter-rouge">value</code>，<code class="language-plaintext highlighter-rouge">writable</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 时，直接对目标属性赋值，不报错，但不会成功。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 1</span>
</code></pre></div> </div> </li> <li>可配置性决定目标属性是否可以被删除（<code class="language-plaintext highlighter-rouge">delete</code>）。</li> </ul> <h4 id="63-enumerable">6.3 enumerable</h4> <p><code class="language-plaintext highlighter-rouge">enumerable</code>（可遍历性）返回一个布尔值，表示目标属性是否可遍历。如果一个属性的 <code class="language-plaintext highlighter-rouge">enumerable</code> 为 <code class="language-plaintext highlighter-rouge">false</code>，下面三个操作不会取到该属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">for..in</code></li> <li><code class="language-plaintext highlighter-rouge">Object.keys()</code></li> <li><code class="language-plaintext highlighter-rouge">JSON.stringify()</code></li> </ul> <p>因此，<code class="language-plaintext highlighter-rouge">enumerable</code> 可以用来设置“<strong>秘密</strong>”属性。</p> <h4 id="64-writable">6.4 writable</h4> <p><code class="language-plaintext highlighter-rouge">writable</code> 属性是布尔值，决定了目标属性<strong>值</strong>（value）是否可以被改变。正常模式下，对 <code class="language-plaintext highlighter-rouge">writable</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 的属性赋值不会报错，只会失败。但是，严格模式下会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">37</span><span class="p">;</span>
<span class="c1">// Uncaught TypeError: Cannot assign to read only property 'a' of object</span>
</code></pre></div></div> <p>如果原型对象的某个属性的 <code class="language-plaintext highlighter-rouge">writable</code> 为 <code class="language-plaintext highlighter-rouge">false</code>，那么子对象将无法自定义这个属性。但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">proto</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// "b"</span>
</code></pre></div></div> <h3 id="7-存取器">7. 存取器</h3> <p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">get</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">getter</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="na">set</span><span class="p">:</span> <span class="nf">function </span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setter: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// "getter"</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">123</span> <span class="c1">// "setter: 123"</span>
</code></pre></div></div> <p>JavaScript 还提供了存取器的另一种写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 写法二</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nf">p</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">getter</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="kd">set</span> <span class="nf">p</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setter: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面两种写法，虽然属性 <code class="language-plaintext highlighter-rouge">p</code> 的读取和赋值行为是一样的，但是有一些细微的区别。</p> <ul> <li>第一种写法，属性 <code class="language-plaintext highlighter-rouge">p</code> 的 <code class="language-plaintext highlighter-rouge">configurable</code> 和 <code class="language-plaintext highlighter-rouge">enumerable</code> 都为 <code class="language-plaintext highlighter-rouge">false</code>，从而导致属性 <code class="language-plaintext highlighter-rouge">p</code> 是不可遍历的；</li> <li>第二种写法，属性 <code class="language-plaintext highlighter-rouge">p</code> 的 <code class="language-plaintext highlighter-rouge">configurable</code> 和 <code class="language-plaintext highlighter-rouge">enumerable</code> 都为 <code class="language-plaintext highlighter-rouge">true</code>，因此属性 <code class="language-plaintext highlighter-rouge">p</code> 是可遍历的。</li> </ul> <p>实际开发中，写法二更常用。</p> <h3 id="8-对象的拷贝">8. 对象的拷贝</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">property</span> <span class="k">in</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">to</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">=</span> <span class="k">from</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">to</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">extend</span><span class="p">({},</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">})</span>
<span class="c1">// {a: 1}</span>

<span class="nf">extend</span><span class="p">({},</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">})</span>
<span class="c1">// {a: 1}</span>
</code></pre></div></div> <p>上面是一个对象的拷贝方法，它的问题在于，如果遇到存取器定义的属性，会只拷贝值。为了解决这个问题，可以通过 <code class="language-plaintext highlighter-rouge">Object.defineProperty()</code> 方法来拷贝属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">property</span> <span class="k">in</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">from</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="nx">property</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span>
      <span class="nx">to</span><span class="p">,</span>
      <span class="nx">property</span><span class="p">,</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">property</span><span class="p">)</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">to</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">extend</span><span class="p">({},</span> <span class="p">{</span> <span class="kd">get</span> <span class="nf">a</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">})</span>
<span class="c1">// { get a(){ return 1 } })</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">hasOwnProperty</code> 那一行用来过滤掉继承的属性，否则可能会报错，因为 <code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor()</code> 读不到继承属性的属性描述对象。</p> <h3 id="9-控制对象状态">9. 控制对象状态</h3> <p>JavaScript 提供了三种冻结方法，最弱的一种是 <code class="language-plaintext highlighter-rouge">Object.preventExtensions()</code>，其次是 <code class="language-plaintext highlighter-rouge">Object.seal()</code>，最强的是 <code class="language-plaintext highlighter-rouge">Object.freeze()</code>。</p> <h4 id="91-objectpreventextensionsobjectisextensible">9.1 Object.preventExtensions()，Object.isExtensible()</h4> <p><code class="language-plaintext highlighter-rouge">Object.preventExtensions()</code> 方法可以使得一个对象<strong>无法再添加新属性</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
<span class="p">});</span>
<span class="c1">// TypeError: Cannot define property:p, object is not extensible.</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// undefined</span>

</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.isExtensible()</code> 方法用于检查一个对象是否使用了 <code class="language-plaintext highlighter-rouge">Object.preventExtensions()</code> 方法。也就是说，检查是否可以为一个对象添加属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">isExtensible</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">isExtensible</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="92-objectsealobjectissealed">9.2 Object.seal()，Object.isSealed()</h4> <p><code class="language-plaintext highlighter-rouge">Object.seal()</code> 方法用于禁止对象<strong>添加新属性和删除旧属性</strong>。注意，它只禁止添加或删除属性，并<strong>不影响修改某个属性的值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">seal</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">p</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// "hello"</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// undefined</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.seal()</code> 实质是把属性描述对象的 <code class="language-plaintext highlighter-rouge">configurable</code> 属性设为 <code class="language-plaintext highlighter-rouge">false</code>，因此属性描述对象不再能改变了。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span>
<span class="p">};</span>

<span class="c1">// seal方法之前</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Object {</span>
<span class="c1">//   value: "a",</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true</span>
<span class="c1">// }</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">seal</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="c1">// seal方法之后</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Object {</span>
<span class="c1">//   value: "a",</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: false</span>
<span class="c1">// }</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">})</span>
<span class="c1">// TypeError: Cannot redefine property: p</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.isSealed()</code> 方法用于检查一个对象是否使用了 <code class="language-plaintext highlighter-rouge">Object.seal()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">seal</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">isSealed</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// true</span>

<span class="c1">// 这时，Object.isExtensible() 方法也返回 false。</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">isExtensible</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="93-objectfreezeobjectisfrozen">9.3 Object.freeze()，Object.isFrozen()</h4> <p><code class="language-plaintext highlighter-rouge">Object.freeze()</code> 方法可以使得一个对象<strong>无法添加新属性</strong>、<strong>无法删除旧属性</strong>、也<strong>无法改变属性的值</strong>，使得这个对象实际上变成了<strong>常量</strong>。</p> <p><code class="language-plaintext highlighter-rouge">Object.isFrozen()</code> 方法用于检查一个对象是否使用了 <code class="language-plaintext highlighter-rouge">Object.freeze()</code> 方法。<code class="language-plaintext highlighter-rouge">Object.isFrozen()</code> 的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p> <p>注意，使用 <code class="language-plaintext highlighter-rouge">Object.freeze()</code> 方法以后，<code class="language-plaintext highlighter-rouge">Object.isSealed()</code> 将会返回 <code class="language-plaintext highlighter-rouge">true</code>，<code class="language-plaintext highlighter-rouge">Object.isExtensible()</code> 返回 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">freeze</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">isSealed</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">isExtensible</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="94-局限性">9.4 局限性</h4> <p>上面三个方法锁定对象的可写性有两个局限性。</p> <p>（1）可以通过改变原型对象，来为对象增加属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">proto</span><span class="p">.</span><span class="nx">t</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">t</span>
<span class="c1">// hello</span>
</code></pre></div></div> <p>一种解决方案是，把 <code class="language-plaintext highlighter-rouge">obj</code> 的原型也冻结住。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">proto</span><span class="p">);</span>

<span class="nx">proto</span><span class="p">.</span><span class="nx">t</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">t</span> <span class="c1">// undefined</span>
</code></pre></div></div> <p>（2）如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">bar</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">]</span>
<span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">freeze</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span> <span class="c1">// ["a", "b", "c"]</span>
</code></pre></div></div> <h2 id="三array-对象">三、Array 对象</h2> <h3 id="1-构造函数">1. 构造函数</h3> <p><code class="language-plaintext highlighter-rouge">Array</code> 是 JavaScript 的原生对象，同时也是一个<strong>构造函数</strong>，可以用它生成新的数组。注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回 <code class="language-plaintext highlighter-rouge">undefined</code>，但实际上该位置没有任何值。虽然这时可以读取到 <code class="language-plaintext highlighter-rouge">length</code> 属性，但是取不到键名。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="nx">arr</span> <span class="c1">// [ empty x 2 ]</span>

<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Array()</code> 构造函数有一个很大的缺陷，不同的参数个数会导致不一致的行为。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 无参数时，返回一个空数组</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">()</span> <span class="c1">// []</span>

<span class="c1">// 单个正整数参数，表示返回的新数组的长度</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// [ empty ]</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// [ empty x 2 ]</span>

<span class="c1">// 非正整数的数值作为参数，会报错</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span> <span class="c1">// RangeError: Invalid array length</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// RangeError: Invalid array length</span>

<span class="c1">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span>
<span class="c1">// 则该参数是返回的新数组的成员</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ['abc']</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// [Array[1]]</span>

<span class="c1">// 多参数时，所有参数都是返回的新数组的成员</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// [1, 2]</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ['a', 'b', 'c']</span>
</code></pre></div></div> <p>不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bad</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// good</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</code></pre></div></div> <h3 id="2-静态方法">2. 静态方法</h3> <p><code class="language-plaintext highlighter-rouge">Array.isArray()</code> 方法返回一个布尔值，表示参数是否为数组。它可以弥补 <code class="language-plaintext highlighter-rouge">typeof</code> 运算符的不足。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="k">typeof</span> <span class="nx">arr</span> <span class="c1">// "object"</span>
<span class="nb">Array</span><span class="p">.</span><span class="nf">isArray</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="3-实例方法">3. 实例方法</h3> <h4 id="31-valueoftostring">3.1 valueOf()，toString()</h4> <p>数组的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回数组本身。数组的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法返回数组的字符串形式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">arr</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// [1, 2, 3]</span>
<span class="nx">arr</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "1,2,3"</span>
</code></pre></div></div> <h4 id="32-pushpop">3.2 push()，pop()</h4> <p><code class="language-plaintext highlighter-rouge">push()</code> 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的<strong>数组长度</strong>。该方法会改变原数组。<code class="language-plaintext highlighter-rouge">pop()</code> 方法用于删除数组的<strong>最后一个</strong>元素，并返回<strong>该元素</strong>。该方法会改变原数组。</p> <h4 id="33-shiftunshift">3.3 shift()，unshift()</h4> <p><code class="language-plaintext highlighter-rouge">shift()</code> 方法用于删除数组的<strong>第一个</strong>元素，并返回<strong>该元素</strong>。该方法会改变原数组。<code class="language-plaintext highlighter-rouge">unshift()</code> 方法用于在数组的<strong>第一个位置</strong>添加元素，并返回添加新元素后的<strong>数组长度</strong>。该方法会改变原数组。<code class="language-plaintext highlighter-rouge">unshift()</code> 方法可以接受多个参数，这些参数都会添加到目标数组头部。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>

<span class="nx">a</span><span class="p">.</span><span class="nf">unshift</span><span class="p">(</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 4</span>
<span class="nx">a</span> <span class="c1">// ['x', 'a', 'b', 'c']</span>
</code></pre></div></div> <h4 id="34-join">3.4 join()</h4> <p><code class="language-plaintext highlighter-rouge">join()</code> 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用<strong>逗号</strong>分隔。</p> <h4 id="35-concat">3.5 concat()</h4> <p><code class="language-plaintext highlighter-rouge">concat()</code> 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。<code class="language-plaintext highlighter-rouge">concat()</code> 接受任何类型的值作为参数，添加到目标数组尾部。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">].</span><span class="nf">concat</span><span class="p">([</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">])</span>
<span class="c1">// ["hello", "world"]</span>

<span class="p">[</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">].</span><span class="nf">concat</span><span class="p">([</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">!</span><span class="dl">'</span><span class="p">])</span>
<span class="c1">// ["hello", "world", "!"]</span>

<span class="p">[].</span><span class="nf">concat</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="c1">// [{ a: 1 }, { b: 2 }]</span>

<span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">concat</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="c1">// [2, {a: 1}]</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">concat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="c1">// [1, 2, 3, 4, 5, 6]</span>
</code></pre></div></div> <p>对于对象成员，<code class="language-plaintext highlighter-rouge">concat()</code> 方法执行的是<strong>浅拷贝</strong>。</p> <h4 id="36-reverse">3.6 reverse()</h4> <p><code class="language-plaintext highlighter-rouge">reverse()</code> 方法用于颠倒排列数组元素，返回改变后的数组。该方法将改变原数组。</p> <h4 id="37-slice">3.7 slice()</h4> <p><code class="language-plaintext highlighter-rouge">slice()</code> 方法用于<strong>提取</strong>目标数组的一部分，返回一个新数组，<strong>原数组不变</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">arr</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">);</span>
</code></pre></div></div> <p>它的第一个参数为起始位置（从 <code class="language-plaintext highlighter-rouge">0</code> 开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>

<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// ["a", "b", "c"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// ["b", "c"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// ["b"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// ["c"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">()</span> <span class="c1">// ["a", "b", "c"]</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">slice()</code> 方法的参数是负数，则表示倒数计算的位置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// ["b", "c"]</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// ["b"]</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">slice()</code> 方法的一个重要应用，是将类似数组的对象转为真正的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">({</span> <span class="mi">0</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="na">length</span><span class="p">:</span> <span class="mi">2</span> <span class="p">})</span>
<span class="c1">// ['a', 'b']</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">));</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
</code></pre></div></div> <h4 id="38-splice">3.8 splice()</h4> <p><code class="language-plaintext highlighter-rouge">splice()</code> 方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是<strong>被删除的元素</strong>。该方法会改变原数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">arr</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">addElement1</span><span class="p">,</span> <span class="nx">addElement2</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">splice()</code> 的第一个参数是删除的起始位置（从 <code class="language-plaintext highlighter-rouge">0</code> 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。起始位置如果是负数，就表示从倒数位置开始删除。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">e</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// ["e", "f"]</span>
<span class="nx">a</span> <span class="c1">// ["a", "b", "c", "d", 1, 2]</span>
</code></pre></div></div> <p>如果只是单纯地插入元素，<code class="language-plaintext highlighter-rouge">splice()</code> 方法的第二个参数可以设为 <code class="language-plaintext highlighter-rouge">0</code>。</p> <p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// [3, 4]</span>
<span class="nx">a</span> <span class="c1">// [1, 2]</span>
</code></pre></div></div> <h4 id="39-sort">3.9 sort()</h4> <p><code class="language-plaintext highlighter-rouge">sort()</code> 方法对数组成员进行排序，默认是按照<strong>字典顺序</strong>排序。排序后，原数组将被改变。<code class="language-plaintext highlighter-rouge">sort()</code> 方法不是按照大小排序，而是按照字典顺序。也就是说，<strong>数值会被先转成字符串</strong>，再按照字典顺序进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">].</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// ['a', 'b', 'c', 'd']</span>

<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [1, 2, 3, 4]</span>

<span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">101</span><span class="p">].</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [101, 11]</span>

<span class="p">[</span><span class="mi">10111</span><span class="p">,</span> <span class="mi">1101</span><span class="p">,</span> <span class="mi">111</span><span class="p">].</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [10111, 1101, 111]</span>
</code></pre></div></div> <p>如果想让 <code class="language-plaintext highlighter-rouge">sort()</code> 方法按照自定义方式排序，可以传入一个函数作为参数。自定义的排序函数应该返回<strong>数值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">10111</span><span class="p">,</span> <span class="mi">1101</span><span class="p">,</span> <span class="mi">111</span><span class="p">].</span><span class="nf">sort</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">})</span>
<span class="c1">// [111, 1101, 10111]</span>
</code></pre></div></div> <h4 id="310-foreachmap">3.10 forEach()，map()</h4> <p><code class="language-plaintext highlighter-rouge">forEach()</code> 方法用来历数组遍，没有返回值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">forEach()</code> 方法的第一个参数是一个回调函数，该函数接受三个参数：当前值、当前位置、整个数组。</li> <li><code class="language-plaintext highlighter-rouge">forEach()</code> 方法也可接受第二个参数，绑定参数函数的 <code class="language-plaintext highlighter-rouge">this</code> 变量。</li> </ul> <p><code class="language-plaintext highlighter-rouge">forEach()</code> 方法无法中断执行且会跳过数组的空位（但不会跳过 <code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code>）。</p> <p><code class="language-plaintext highlighter-rouge">map()</code> 方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p> <ul> <li><code class="language-plaintext highlighter-rouge">map()</code> 方法的第一个参数是一个回调函数，该函数接受三个参数：当前值、当前位置、整个数组。</li> <li><code class="language-plaintext highlighter-rouge">map()</code> 方法也可接受第二个参数，绑定参数函数的 <code class="language-plaintext highlighter-rouge">this</code> 变量。</li> </ul> <p><code class="language-plaintext highlighter-rouge">map()</code> 会跳过数组的空位。</p> <h4 id="311-filter">3.11 filter()</h4> <p><code class="language-plaintext highlighter-rouge">filter()</code> 方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 <code class="language-plaintext highlighter-rouge">true</code> 的成员组成一个新数组返回。该方法不会改变原数组。</p> <ul> <li><code class="language-plaintext highlighter-rouge">filter()</code> 方法的第一个参数是一个回调函数，该函数接受三个参数：当前值、当前位置、整个数组。</li> <li><code class="language-plaintext highlighter-rouge">filter()</code> 方法也可接受第二个参数，绑定参数函数的 <code class="language-plaintext highlighter-rouge">this</code> 变量。</li> </ul> <h4 id="312-someevery">3.12 some()，every()</h4> <p><code class="language-plaintext highlighter-rouge">some()</code> 和 <code class="language-plaintext highlighter-rouge">every()</code> 方法都接受一个函数作为参数，所有数组成员依次执行该函数。它们也可接受第二个参数，绑定参数函数的 <code class="language-plaintext highlighter-rouge">this</code> 变量。</p> <ul> <li><code class="language-plaintext highlighter-rouge">some()</code> 方法是只要一个成员的返回值是 <code class="language-plaintext highlighter-rouge">true</code>，则整个 <code class="language-plaintext highlighter-rouge">some()</code> 方法的返回值就是 <code class="language-plaintext highlighter-rouge">true</code>，否则返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">every()</code> 方法是所有成员的返回值都是 <code class="language-plaintext highlighter-rouge">true</code>，整个 <code class="language-plaintext highlighter-rouge">every()</code> 方法才返回 <code class="language-plaintext highlighter-rouge">true</code>，否则返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <h4 id="313-reducereduceright">3.13 reduce()，reduceRight()</h4> <p><code class="language-plaintext highlighter-rouge">reduce()</code> 方法和 <code class="language-plaintext highlighter-rouge">reduceRight()</code> 方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code class="language-plaintext highlighter-rouge">reduce()</code> 是从左到右处理（从第一个成员到最后一个成员），<code class="language-plaintext highlighter-rouge">reduceRight()</code> 则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nf">reduce</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">})</span>
<span class="c1">// 1 2</span>
<span class="c1">// 3 3</span>
<span class="c1">// 6 4</span>
<span class="c1">// 10 5</span>
<span class="c1">//最后结果：15</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">reduce()</code> 方法和 <code class="language-plaintext highlighter-rouge">reduceRight()</code> 方法的第一个参数都是一个函数。该函数接受以下四个参数。</p> <ul> <li>累积变量（必须）。第一次执行时，默认为数组的第一个成员；以后每次执行时，都是上一轮的返回值。</li> <li>当前变量（必须）。第一次执行时，默认为数组的第二个成员；以后每次执行时，都是下一个成员。</li> <li>当前位置（可选）。一个整数，表示第二个参数（当前变量）的位置，默认为 <code class="language-plaintext highlighter-rouge">1</code>。</li> <li>原数组（可选）。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">reduce()</code> 方法和 <code class="language-plaintext highlighter-rouge">reduceRight()</code> 方法的第二个参数，用于对累积变量指定初值。建议总是加上第二个参数，因为它可以防止空数组报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nf">reduce</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">10</span><span class="p">);</span>
<span class="c1">// 25</span>
</code></pre></div> </div> </li> </ul> <h4 id="314-indexoflastindexof">3.14 indexOf()，lastIndexOf()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">indexOf()</code> 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回 <code class="language-plaintext highlighter-rouge">-1</code>。<code class="language-plaintext highlighter-rouge">indexOf()</code> 方法还可以接受第二个参数，表示搜索的开始位置。</li> <li><code class="language-plaintext highlighter-rouge">lastIndexOf()</code> 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回 <code class="language-plaintext highlighter-rouge">-1</code>。</li> </ul> <p>注意，这两个方法不能用来搜索 <code class="language-plaintext highlighter-rouge">NaN</code> 的位置，即它们无法确定数组成员是否包含 <code class="language-plaintext highlighter-rouge">NaN</code>。这是因为这两个方法内部，使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）进行比较，而 <code class="language-plaintext highlighter-rouge">NaN</code> 是唯一一个不等于自身的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nf">indexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// -1</span>
<span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nf">lastIndexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// -1</span>
</code></pre></div></div> <h4 id="315-链式使用">3.15 链式使用</h4> <p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p> <h2 id="四包装对象">四、包装对象</h2> <h3 id="1-定义">1. 定义</h3> <p>“<strong>包装对象</strong>”指的是与数值、字符串、布尔值分别相对应的 <code class="language-plaintext highlighter-rouge">Boolean</code>、<code class="language-plaintext highlighter-rouge">Number</code>、<code class="language-plaintext highlighter-rouge">String</code> 三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">v1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Number</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="p">(</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">v3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="k">typeof</span> <span class="nx">v1</span> <span class="c1">// "object"</span>
<span class="k">typeof</span> <span class="nx">v2</span> <span class="c1">// "object"</span>
<span class="k">typeof</span> <span class="nx">v3</span> <span class="c1">// "object"</span>

<span class="nx">v1</span> <span class="o">===</span> <span class="mi">123</span> <span class="c1">// false</span>
<span class="nx">v2</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="nx">v3</span> <span class="o">===</span> <span class="kc">true</span> <span class="c1">// false</span>
</code></pre></div></div> <p>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。</p> <p>这三种包装对象作为构造函数使用（带有 <code class="language-plaintext highlighter-rouge">new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有 <code class="language-plaintext highlighter-rouge">new</code>），可以将任意类型的值，转为原始类型的值。</p> <h3 id="2-实例方法">2. 实例方法</h3> <p>三种包装对象共有方法：<code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code>。</p> <h3 id="3-原始类型与实例对象的自动转换">3. 原始类型与实例对象的自动转换</h3> <p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。</p> <p>比如，字符串可以调用 <code class="language-plaintext highlighter-rouge">length</code> 属性，返回字符串的长度。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">abc</code> 是一个字符串，本身不是对象，不能调用 <code class="language-plaintext highlighter-rouge">length</code> 属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用 <code class="language-plaintext highlighter-rouge">length</code> 属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</p> <p>自动转换生成的包装对象是<strong>只读的</strong>，无法修改。所以，字符串无法添加新属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello World</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// undefined</span>
</code></pre></div></div> <h3 id="4-自定义方法">4. 自定义方法</h3> <p>包装对象还可以自定义方法和属性，供原始类型的值直接调用。比如，我们可以新增一个 <code class="language-plaintext highlighter-rouge">double()</code> 方法，使得字符串和数字翻倍。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">double</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">();</span>
<span class="p">};</span>

<span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">.</span><span class="nf">double</span><span class="p">()</span>
<span class="c1">// abcabc</span>

<span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">double</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">double</span><span class="p">()</span> <span class="c1">// 246</span>
</code></pre></div></div> <h2 id="五boolean-对象">五、Boolean 对象</h2> <p><code class="language-plaintext highlighter-rouge">Boolean</code> 对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。<code class="language-plaintext highlighter-rouge">false</code> 对应的包装对象实例，布尔运算结果也是 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// true</span>

<span class="k">if </span><span class="p">(</span><span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">).</span><span class="nf">valueOf</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// 无输出</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Boolean</code> 对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时 <code class="language-plaintext highlighter-rouge">Boolean</code> 就是一个单纯的工具方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Boolean</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="dl">''</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// false</span>

<span class="nc">Boolean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="dl">'</span><span class="s1">false</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{})</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="sr">/foo/</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <p>使用双重的否运算符（<code class="language-plaintext highlighter-rouge">!</code>）也可以将任意值转为对应的布尔值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!!</span><span class="kc">undefined</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="kc">null</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="mi">0</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="dl">''</span> <span class="c1">// false</span>
<span class="o">!!</span><span class="kc">NaN</span> <span class="c1">// false</span>

<span class="o">!!</span><span class="mi">1</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="dl">'</span><span class="s1">false</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="p">[]</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="p">{}</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="kd">function</span><span class="p">(){}</span> <span class="c1">// true</span>
<span class="o">!!</span><span class="sr">/foo/</span> <span class="c1">// true</span>
</code></pre></div></div> <h2 id="六number-对象">六、Number 对象</h2> <p>Number 对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p> <h3 id="1-静态属性">1. 静态属性</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Number.POSITIVE_INFINITY</code>：正的无限，指向 <code class="language-plaintext highlighter-rouge">Infinity</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.NEGATIVE_INFINITY</code>：负的无限，指向 <code class="language-plaintext highlighter-rouge">-Infinity</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.NaN</code>：表示非数值，指向 <code class="language-plaintext highlighter-rouge">NaN</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.MIN_VALUE</code>：表示最小的正数（即最接近 <code class="language-plaintext highlighter-rouge">0</code> 的正数，在 64 位浮点数体系中为 <code class="language-plaintext highlighter-rouge">5e-324</code>），相应的，最接近 <code class="language-plaintext highlighter-rouge">0</code> 的负数为 <code class="language-plaintext highlighter-rouge">-Number.MIN_VALUE</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即 <code class="language-plaintext highlighter-rouge">9007199254740991</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即 <code class="language-plaintext highlighter-rouge">-9007199254740991</code>。\</li> </ul> <h3 id="2-实例方法-1">2. 实例方法</h3> <h4 id="21--numberprototypetostring">2.1 Number.prototype.toString()</h4> <p><code class="language-plaintext highlighter-rouge">Number()</code> 对象部署了自己的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，用来将一个数值转为字符串形式。</p> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toString()</code> 方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "1010"</span>
<span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1">// "12"</span>
<span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// "a"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">toString()</code> 方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用 <code class="language-plaintext highlighter-rouge">parseInt()</code> 方法。</p> <h4 id="22-numberprototypetofixed">2.2 Number.prototype.toFixed()</h4> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toFixed()</code> 方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "10.00"</span>
<span class="mf">10.005</span><span class="p">.</span><span class="nf">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "10.01"</span>
</code></pre></div></div> <h4 id="23-numberprototypetoexponential">2.3 Number.prototype.toExponential()</h4> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toExponential()</code> 方法用于将一个数转为科学计数法形式。<code class="language-plaintext highlighter-rouge">toExponential()</code> 方法的参数是小数点后有效数字的位数，范围为 0 到 100，超出这个范围，会抛出一个 <code class="language-plaintext highlighter-rouge">RangeError</code> 错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">()</span>  <span class="c1">// "1e+1"</span>
<span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// "1.0e+1"</span>
<span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "1.00e+1"</span>

<span class="p">(</span><span class="mi">1234</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">()</span>  <span class="c1">// "1.234e+3"</span>
<span class="p">(</span><span class="mi">1234</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// "1.2e+3"</span>
<span class="p">(</span><span class="mi">1234</span><span class="p">).</span><span class="nf">toExponential</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "1.23e+3"</span>
</code></pre></div></div> <h4 id="24-numberprototypetoprecision">2.4 Number.prototype.toPrecision()</h4> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toPrecision()</code> 方法用于将一个数转为指定位数的有效数字。该方法的参数为有效数字的位数，范围是 1 到 100，超出这个范围会抛出 <code class="language-plaintext highlighter-rouge">RangeError</code> 错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// "1e+1"</span>
<span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// "12"</span>
<span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// "12.3"</span>
<span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// "12.34"</span>
<span class="p">(</span><span class="mf">12.34</span><span class="p">).</span><span class="nf">toPrecision</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// "12.340"</span>
</code></pre></div></div> <h4 id="25-numberprototypetolocalestring">2.5 Number.prototype.toLocaleString()</h4> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toLocaleString()</code> 方法返回一个字符串，表示当前数字在该地区的当地书写形式。</p> <p><code class="language-plaintext highlighter-rouge">Number.prototype.toLocaleString()</code> 方法接受两个可选的参数。</p> <ul> <li>第一个参数是一个字符串形式的地区码。</li> <li> <p>第二个参数是一个配置对象，用来定制指定用途的返回字符串。该对象的 style 属性指定输出样式，默认值是 decimal，表示输出十进制形式。</p> <ul> <li>如果 <code class="language-plaintext highlighter-rouge">style</code> 属性值为 <code class="language-plaintext highlighter-rouge">percent</code>，表示输出百分数。</li> <li>如果 <code class="language-plaintext highlighter-rouge">style</code> 属性值为 <code class="language-plaintext highlighter-rouge">currency</code>，则可以搭配 <code class="language-plaintext highlighter-rouge">currency</code> 属性，输出指定格式的货币字符串形式。</li> </ul> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-Hans-CN-u-nu-hanidec</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// "一二三"</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-Hans-CN</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">style</span><span class="p">:</span> <span class="dl">'</span><span class="s1">percent</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// "12,300%"</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-Hans-CN</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">style</span><span class="p">:</span> <span class="dl">'</span><span class="s1">currency</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">currency</span><span class="p">:</span> <span class="dl">'</span><span class="s1">CNY</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// "￥123.00"</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">de-DE</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">style</span><span class="p">:</span> <span class="dl">'</span><span class="s1">currency</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">currency</span><span class="p">:</span> <span class="dl">'</span><span class="s1">EUR</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// "123,00 €"</span>

<span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">style</span><span class="p">:</span> <span class="dl">'</span><span class="s1">currency</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">currency</span><span class="p">:</span> <span class="dl">'</span><span class="s1">USD</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// "$123.00"</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">Number.prototype.toLocaleString()</code> 省略了参数，则由浏览器自行决定如何处理，通常会使用操作系统的地区设定。</p> <h3 id="3-自定义方法">3. 自定义方法</h3> <p><code class="language-plaintext highlighter-rouge">Number.prototype</code> 对象上面可以自定义方法，被 <code class="language-plaintext highlighter-rouge">Number</code> 的实例继承。</p> <h2 id="七string-对象">七、String 对象</h2> <h3 id="1-概述-1">1. 概述</h3> <p><code class="language-plaintext highlighter-rouge">String</code> 可以用作构造函数，还可以当作工具方法使用，将任意类型的值转为字符串。<code class="language-plaintext highlighter-rouge">String</code> 对象是一个类似数组的对象（很像数组，但不是数组）。</p> <h3 id="2-静态方法-stringfromcharcode">2. 静态方法 String.fromCharCode()</h3> <p><code class="language-plaintext highlighter-rouge">String.fromCharCode()</code> 方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。该方法不支持 Unicode 码点大于 <code class="language-plaintext highlighter-rouge">0xFFFF</code> 的字符，即传入的参数不能大于 <code class="language-plaintext highlighter-rouge">0xFFFF</code>（即十进制的 <code class="language-plaintext highlighter-rouge">65535</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mh">0x20BB7</span><span class="p">)</span>
<span class="c1">// "ஷ"</span>
<span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mh">0x20BB7</span><span class="p">)</span> <span class="o">===</span> <span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mh">0x0BB7</span><span class="p">)</span>
<span class="c1">// true</span>
</code></pre></div></div> <p>这种现象的根本原因在于，码点大于 <code class="language-plaintext highlighter-rouge">0xFFFF</code> 的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把 <code class="language-plaintext highlighter-rouge">0x20BB7</code> 拆成两个字符表示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="mh">0xD842</span><span class="p">,</span> <span class="mh">0xDFB7</span><span class="p">)</span>
<span class="c1">// "𠮷"</span>
</code></pre></div></div> <h3 id="3-实例属性-stringprototypelength">3. 实例属性 String.prototype.length</h3> <p><code class="language-plaintext highlighter-rouge">length</code> 属性返回字符串的长度。</p> <h3 id="4-实例方法">4. 实例方法</h3> <h4 id="41-stringprototypecharatstringprototypecharcodeat">4.1 String.prototype.charAt()，String.prototype.charCodeAt()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">charAt()</code> 方法返回指定位置的字符。</li> <li><code class="language-plaintext highlighter-rouge">charCodeAt()</code> 方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于 <code class="language-plaintext highlighter-rouge">String.fromCharCode()</code> 的逆操作。</li> </ul> <h4 id="42-stringprototypeconcat">4.2 String.prototype.concat()</h4> <p><code class="language-plaintext highlighter-rouge">concat()</code> 方法用于连接两个字符串，返回一个新字符串，不改变原字符串。该方法可以接受多个参数。如果参数不是字符串，<code class="language-plaintext highlighter-rouge">concat()</code> 方法会将其先转为字符串，然后再连接。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">.</span><span class="nf">concat</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "abc"</span>
<span class="dl">''</span><span class="p">.</span><span class="nf">concat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "123"</span>
</code></pre></div></div> <h4 id="43-stringprototypeslicestringprototypesubstringstringprototypesubstr">4.3 String.prototype.slice()，String.prototype.substring()，String.prototype.substr()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">slice()</code> 方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">JavaScript</span><span class="dl">'</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// "Java"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">substring()</code> 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice() 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。不建议使用 <code class="language-plaintext highlighter-rouge">substring()</code> 方法，因为如果第一个参数大于第二个参数，或者当参数是负数时，其行为表现很怪异。应该优先使用 <code class="language-plaintext highlighter-rouge">slice()</code>。</li> <li><code class="language-plaintext highlighter-rouge">substr()</code> 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 <code class="language-plaintext highlighter-rouge">slice()</code> 和 <code class="language-plaintext highlighter-rouge">substring()</code> 方法的作用相同。</li> </ul> <p>字符串的截取，应该优先使用 <code class="language-plaintext highlighter-rouge">slice()</code>。</p> <h4 id="44-stringprototypeindexofstringprototypelastindexof">4.4 String.prototype.indexOf()，String.prototype.lastIndexOf()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">indexOf()</code> 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回 -1，就表示不匹配。该方法还可以接受第二个参数，表示从该位置开始向后匹配。</li> <li><code class="language-plaintext highlighter-rouge">lastIndexOf()</code> 方法的用法跟 <code class="language-plaintext highlighter-rouge">indexOf()</code> 方法一致，主要的区别是 <code class="language-plaintext highlighter-rouge">lastIndexOf()</code> 从尾部开始匹配，<code class="language-plaintext highlighter-rouge">indexOf()</code> 则是从头部开始匹配。</li> </ul> <h4 id="45-stringprototypetrim">4.5 String.prototype.trim()</h4> <p><code class="language-plaintext highlighter-rouge">trim()</code> 方法用于去除字符串<strong>两端</strong>的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（<code class="language-plaintext highlighter-rouge">\t</code>、<code class="language-plaintext highlighter-rouge">\v</code>）、换行符（<code class="language-plaintext highlighter-rouge">\n</code>）和回车符（<code class="language-plaintext highlighter-rouge">\r</code>）。</p> <h4 id="46-stringprototypetolowercasestringprototypetouppercase">4.6 String.prototype.toLowerCase()，String.prototype.toUpperCase()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">toLowerCase()</code> 方法将字符串<strong>全部</strong>转为小写。</li> <li><code class="language-plaintext highlighter-rouge">toUpperCase()</code> 方法将字符串<strong>全部</strong>转为大写。</li> </ul> <p>它们都返回一个新字符串，不改变原字符串。</p> <h4 id="47-stringprototypematchstringprototypesearchstringprototypereplace">4.7 String.prototype.match()，String.prototype.search()，String.prototype.replace()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">match()</code> 方法用于确定原字符串是否匹配某个子字符串，返回一个<strong>数组</strong>，成员为匹配的<strong>第一个字符串</strong>。如果没有找到匹配，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">cat, bat, sat, fat</span><span class="dl">'</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="dl">'</span><span class="s1">at</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ["at"]</span>
<span class="dl">'</span><span class="s1">cat, bat, sat, fat</span><span class="dl">'</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="dl">'</span><span class="s1">xt</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// null</span>
</code></pre></div> </div> <p>返回的数组还有 <code class="language-plaintext highlighter-rouge">index</code> 属性和 <code class="language-plaintext highlighter-rouge">input</code> 属性，分别表示匹配字符串开始的位置和原始字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">matches</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">cat, bat, sat, fat</span><span class="dl">'</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="dl">'</span><span class="s1">at</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">matches</span><span class="p">.</span><span class="nx">index</span> <span class="c1">// 1</span>
<span class="nx">matches</span><span class="p">.</span><span class="nx">input</span> <span class="c1">// "cat, bat, sat, fat"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">search()</code> 方法的用法基本等同于 <code class="language-plaintext highlighter-rouge">match()</code>，但是返回值为匹配的<strong>第一个位置</strong>。如果没有找到匹配，则返回 <code class="language-plaintext highlighter-rouge">-1</code>。</li> <li><code class="language-plaintext highlighter-rouge">replace()</code> 方法用于替换匹配的子字符串，一般情况下只替换<strong>第一个</strong>匹配（除非使用带有g修饰符的正则表达式）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">cat, bat, sat, fat</span><span class="dl">'</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="dl">'</span><span class="s1">at</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="dl">'</span><span class="s1">aaa</span><span class="dl">'</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "baa"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">match()</code>、<code class="language-plaintext highlighter-rouge">search()</code> 和 <code class="language-plaintext highlighter-rouge">replace()</code> 方法都可以使用正则表达式作为参数。</p> <h4 id="48-stringprototypesplit">4.8 String.prototype.split()</h4> <p><code class="language-plaintext highlighter-rouge">split()</code> 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的<strong>数组</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ["a", "b", "c"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">''</span><span class="p">)</span> <span class="c1">// ["a", "|", "b", "|", "c"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span> <span class="c1">// ["a|b|c"]</span>
<span class="dl">'</span><span class="s1">a||c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ['a', '', 'c']</span>
<span class="dl">'</span><span class="s1">|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ["", "b", "c"]</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">split()</code> 方法还可以接受第二个参数，限定返回数组的最大成员数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// []</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// ["a"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// ["a", "b"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// ["a", "b", "c"]</span>
<span class="dl">'</span><span class="s1">a|b|c</span><span class="dl">'</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">|</span><span class="dl">'</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// ["a", "b", "c"]</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">split()</code> 方法还可以使用正则表达式作为参数。</p> <h4 id="49-stringprototypelocalecompare">4.9 String.prototype.localeCompare()</h4> <p><code class="language-plaintext highlighter-rouge">localeCompare()</code> 方法用于比较两个字符串。它返回一个整数：</p> <ul> <li>如果小于 <code class="language-plaintext highlighter-rouge">0</code>，表示第一个字符串小于第二个字符串。</li> <li>如果等于 <code class="language-plaintext highlighter-rouge">0</code>，表示两者相等。</li> <li>如果大于 <code class="language-plaintext highlighter-rouge">0</code>，表示第一个字符串大于第二个字符串。</li> </ul> <p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">B</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，字母 <code class="language-plaintext highlighter-rouge">B</code> 小于字母 <code class="language-plaintext highlighter-rouge">a</code>。因为 JavaScript 采用的是 Unicode 码点比较，<code class="language-plaintext highlighter-rouge">B</code> 的码点是 <code class="language-plaintext highlighter-rouge">66</code>，而 <code class="language-plaintext highlighter-rouge">a</code> 的码点是 <code class="language-plaintext highlighter-rouge">97</code>。</p> <p>但是，<code class="language-plaintext highlighter-rouge">localeCompare()</code> 方法会考虑自然语言的排序情况，将 <code class="language-plaintext highlighter-rouge">B</code> 排在 <code class="language-plaintext highlighter-rouge">a</code> 的前面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">.</span><span class="nf">localeCompare</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">localeCompare()</code> 方法返回整数 <code class="language-plaintext highlighter-rouge">1</code>，表示 <code class="language-plaintext highlighter-rouge">B</code> 较大。</p> <p><code class="language-plaintext highlighter-rouge">localeCompare()</code> 还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</p> <h2 id="八math-对象">八、Math 对象</h2> <p><code class="language-plaintext highlighter-rouge">Math</code> 是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在 <code class="language-plaintext highlighter-rouge">Math</code> 对象上调用。</p> <h3 id="1-静态属性-1">1. 静态属性</h3> <p>Math 对象的静态属性，提供以下一些数学常数。这些属性都是只读的，不能修改。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Math.E</code>：常数 <code class="language-plaintext highlighter-rouge">e</code>。</li> <li><code class="language-plaintext highlighter-rouge">Math.LN2</code>：2 的自然对数。</li> <li><code class="language-plaintext highlighter-rouge">Math.LN10</code>：10 的自然对数。</li> <li><code class="language-plaintext highlighter-rouge">Math.LOG2E</code>：以 2 为底的 <code class="language-plaintext highlighter-rouge">e</code> 的对数。</li> <li><code class="language-plaintext highlighter-rouge">Math.LOG10E</code>：以 10 为底的 <code class="language-plaintext highlighter-rouge">e</code> 的对数。</li> <li><code class="language-plaintext highlighter-rouge">Math.PI</code>：常数 <code class="language-plaintext highlighter-rouge">π</code>。</li> <li><code class="language-plaintext highlighter-rouge">Math.SQRT1_2</code>：0.5 的平方根。</li> <li><code class="language-plaintext highlighter-rouge">Math.SQRT2</code>：2 的平方根。</li> </ul> <h3 id="2-静态方法-1">2. 静态方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Math.abs()</code>：返回参数值的<strong>绝对值</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.ceil()</code>：返回大于或等于参数值的最小整数（天花板值，即向上取整）。</li> <li><code class="language-plaintext highlighter-rouge">Math.floor()</code>：返回小于或等于参数值的最大整数（地板值，即向下取整）。</li> <li><code class="language-plaintext highlighter-rouge">Math.min()</code>：返回参数中的<strong>最小值</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.max()</code>：返回参数中的<strong>最大值</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.pow()</code>：返回以第一个参数为底数、第二个参数为指数的<strong>幂运算</strong>值。</li> <li><code class="language-plaintext highlighter-rouge">Math.sqrt()</code>：返回参数值的<strong>平方根</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.log()</code>：返回以 <code class="language-plaintext highlighter-rouge">e</code> 为底的<strong>自然对数</strong>值。</li> <li><code class="language-plaintext highlighter-rouge">Math.exp()</code>：返回常数 <code class="language-plaintext highlighter-rouge">e</code> 的参数次方。</li> <li><code class="language-plaintext highlighter-rouge">Math.round()</code>：用于<strong>四舍五入</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Math.random()</code>：返回 0 到 1 之间的一个伪随机数，可能等于 0，但是一定小于 1。</li> </ul> <p><code class="language-plaintext highlighter-rouge">Math</code> 对象还提供一系列三角函数方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Math.sin()</code>：返回参数的正弦（参数为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.cos()</code>：返回参数的余弦（参数为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.tan()</code>：返回参数的正切（参数为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.asin()</code>：返回参数的反正弦（返回值为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.acos()</code>：返回参数的反余弦（返回值为弧度值）</li> <li><code class="language-plaintext highlighter-rouge">Math.atan()</code>：返回参数的反正切（返回值为弧度值）</li> </ul> <h2 id="九date-对象">九、Date 对象</h2> <h3 id="1-普通函数的用法">1. 普通函数的用法</h3> <p><code class="language-plaintext highlighter-rouge">Date</code> 对象可以作为普通函数直接调用，不管是否带有参数，返回的都是代表<strong><em>当前时间</em></strong>的字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Date</span><span class="p">()</span> <span class="c1">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span>
<span class="nc">Date</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span>
</code></pre></div></div> <h3 id="2-构造函数的用法">2. 构造函数的用法</h3> <p><code class="language-plaintext highlighter-rouge">Date</code> 作为构造函数使用，返回 Date 对象的实例。如果不加参数，实例代表的是当前时间。</p> <p>其他对象求值的时候，都是默认调用 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法，但是 <code class="language-plaintext highlighter-rouge">Date</code> 实例求值的时候，默认调用的是 <code class="language-plaintext highlighter-rouge">toString()</code> 方法。这导致对 <code class="language-plaintext highlighter-rouge">Date</code> 实例求值，返回的是一个字符串，代表该实例对应的时间。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">today</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">today</span> <span class="c1">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span>

<span class="c1">// 等同于</span>
<span class="nx">today</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span>
</code></pre></div></div> <p>作为构造函数时，<code class="language-plaintext highlighter-rouge">Date</code> 对象可以接受多种格式的参数，返回该参数对应的时间实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 参数为时间零点开始计算的毫秒数</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">1378218728000</span><span class="p">)</span>
<span class="c1">// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</span>

<span class="c1">// 参数为日期字符串</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span>

<span class="c1">// 参数为多个整数，</span>
<span class="c1">// 代表年、月、日、小时、分钟、秒、毫秒</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <p>关于 <code class="language-plaintext highlighter-rouge">Date</code> 构造函数的参数，有几点说明。</p> <ul> <li>第一点，参数可以是负整数，代表 1970 年元旦之前的时间。</li> <li> <p>第二点，只要是能被 <code class="language-plaintext highlighter-rouge">Date.parse()</code> 方法解析的字符串，都可以当作参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">2013-2-15</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">2013/2/15</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">02/15/2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">2013-FEB-15</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">FEB, 15, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">FEB 15, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">February, 15, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">February 15, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">15 Feb 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">15, February, 2013</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)</span>
</code></pre></div> </div> </li> <li>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，<code class="language-plaintext highlighter-rouge">Date</code> 会将其解释为毫秒数。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">)</span> <span class="c1">// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)</span>

<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span>
<span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <p>各个参数的取值范围如下。 - 年：使用四位数年份，比如 <code class="language-plaintext highlighter-rouge">2000</code>。如果写成两位数或个位数，则加上 <code class="language-plaintext highlighter-rouge">1900</code>，即 <code class="language-plaintext highlighter-rouge">10</code> 代表 <code class="language-plaintext highlighter-rouge">1910</code> 年。如果是负数，表示公元前。 - 月：<code class="language-plaintext highlighter-rouge">0</code> 表示一月，依次类推，<code class="language-plaintext highlighter-rouge">11</code> 表示 <code class="language-plaintext highlighter-rouge">12</code> 月。 - 日：<code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">31</code>。 - 小时：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">23</code>。 - 分钟：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">59</code>。 - 秒：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">59</code>。 - 毫秒：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">999</code>。</p> <p>注意，月份从 <code class="language-plaintext highlighter-rouge">0</code> 开始计算，但是，天数从 <code class="language-plaintext highlighter-rouge">1</code> 开始计算。另外，除了日期的默认值为 <code class="language-plaintext highlighter-rouge">1</code>，小时、分钟、秒钟和毫秒的默认值都是 <code class="language-plaintext highlighter-rouge">0</code>。</p> <p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为 <code class="language-plaintext highlighter-rouge">15</code>，就折算为下一年的 <code class="language-plaintext highlighter-rouge">4</code> 月。</p> <p>参数还可以使用负数，表示<strong>扣去</strong>的时间。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)</span>
  <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <h3 id="3-日期的运算">3. 日期的运算</h3> <p>类型自动转换时：</p> <ul> <li><code class="language-plaintext highlighter-rouge">Date</code> 实例如果转为数值，则等于对应的<strong>毫秒数</strong>。两个日期实例对象进行<strong>减法</strong>运算时，返回的是它们<strong>间隔的毫秒数</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Date</code> 实例如果转为字符串，则等于对应的<strong>日期字符串</strong>。两个日期实例对象进行<strong>加法</strong>运算时，返回的是两个字符串<strong>连接而成的新字符串</strong>。</li> </ul> <h3 id="4-静态方法">4. 静态方法</h3> <h4 id="41-datenow">4.1 Date.now()</h4> <p><code class="language-plaintext highlighter-rouge">Date.now()</code> 方法返回当前时间距离时间零点（1970 年 1 月 1 日 00:00:00 UTC）的<strong>毫秒数</strong>，相当于 Unix 时间戳乘以 1000。</p> <h4 id="42-dateparse">4.2 Date.parse()</h4> <p><code class="language-plaintext highlighter-rouge">Date.parse()</code> 方法用来解析日期字符串，返回该时间距离时间零点（1970 年 1 月 1 日 00:00:00）的<strong>毫秒数</strong>。</p> <p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即 <code class="language-plaintext highlighter-rouge">YYYY-MM-DDTHH:mm:ss.sssZ</code> 格式，其中最后的 <code class="language-plaintext highlighter-rouge">Z</code> 表示时区。但是，其他格式也可以被解析。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Aug 9, 1995</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">January 26, 2011 13:51:50</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mon, 25 Dec 1995 13:30:00 GMT</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mon, 25 Dec 1995 13:30:00 +0430</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">2011-10-10</span><span class="dl">'</span><span class="p">)</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">2011-10-10T14:48:00</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div> <h4 id="43-dateutc">4.3 Date.UTC()</h4> <p><code class="language-plaintext highlighter-rouge">Date.UTC()</code> 方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970 年 1 月 1 日 00:00:00 UTC）的<strong>毫秒数</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 格式</span>
<span class="nb">Date</span><span class="p">.</span><span class="nc">UTC</span><span class="p">(</span><span class="nx">year</span><span class="p">,</span> <span class="nx">month</span><span class="p">[,</span> <span class="nx">date</span><span class="p">[,</span> <span class="nx">hrs</span><span class="p">[,</span> <span class="nx">min</span><span class="p">[,</span> <span class="nx">sec</span><span class="p">[,</span> <span class="nx">ms</span><span class="p">]]]]])</span>

<span class="c1">// 用法</span>
<span class="nb">Date</span><span class="p">.</span><span class="nc">UTC</span><span class="p">(</span><span class="mi">2011</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">567</span><span class="p">)</span> <span class="c1">// 1293847384567</span>
</code></pre></div></div> <p>该方法的参数用法与 <code class="language-plaintext highlighter-rouge">Date</code> 构造函数完全一致，比如月从 <code class="language-plaintext highlighter-rouge">0</code> 开始计算，日期从 <code class="language-plaintext highlighter-rouge">1</code> 开始计算。区别在于 <code class="language-plaintext highlighter-rouge">Date.UTC()</code> 方法的参数，会被解释为 <strong>UTC 时间</strong>（世界标准时间），<code class="language-plaintext highlighter-rouge">Date</code> 构造函数的参数会被解释为<strong>当前时区</strong>的时间。</p> <h3 id="5-实例方法">5. 实例方法</h3> <p><code class="language-plaintext highlighter-rouge">Date</code> 的实例对象，有几十个自己的方法，除了 <code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code>，可以分为以下三类。</p> <ul> <li>to 类：从 <code class="language-plaintext highlighter-rouge">Date</code> 对象返回一个字符串，表示指定的时间。</li> <li>get 类：获取 <code class="language-plaintext highlighter-rouge">Date</code> 对象的日期和时间。</li> <li>set 类：设置 <code class="language-plaintext highlighter-rouge">Date</code> 对象的日期和时间。</li> </ul> <h4 id="51-dateprototypevalueof">5.1 Date.prototype.valueOf()</h4> <p><code class="language-plaintext highlighter-rouge">valueOf()</code> 方法返回实例对象距离时间零点（1970 年 1 月 1 日 00:00:00 UTC）对应的<strong>毫秒数</strong>，该方法等同于 <code class="language-plaintext highlighter-rouge">getTime()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// 1362790014817</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">getTime</span><span class="p">()</span> <span class="c1">// 1362790014817</span>
</code></pre></div></div> <p>预期为数值的场合，<code class="language-plaintext highlighter-rouge">Date</code> 实例会自动调用该方法，所以可以用下面的方法计算时间的间隔。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="kd">var</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">elapsed</span> <span class="o">=</span> <span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span><span class="p">;</span>
</code></pre></div></div> <h4 id="52-to-类方法">5.2 to 类方法</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Date.prototype.toString()</code>：返回一个完整的日期字符串。<code class="language-plaintext highlighter-rouge">toString()</code> 是默认的调用方法，如果直接读取 <code class="language-plaintext highlighter-rouge">Date</code> 实例，就相当于调用这个方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span>
<span class="nx">d</span> <span class="c1">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toUTCString()</code>：返回对应的 UTC 时间，也就是比北京时间晚 8 个小时。</li> <li> <p><code class="language-plaintext highlighter-rouge">Date.prototype.toISOString()</code>：返回对应时间的 ISO8601 写法。此方法返回的总是 UTC 时区的时间。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toISOString</span><span class="p">()</span><span class="c1">// "2012-12-31T16:00:00.000Z"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toJSON()</code>：返回一个符合 JSON 格式的 ISO 日期字符串，与 toISOString 方法的返回结果完全相同。</li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toDateString()</code>：返回日期字符串（不含小时、分和秒）。</li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toTimeString()</code>：返回时间字符串（不含年月日）。</li> </ul> <p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toLocaleString([locales[, options]])</code>：完整的本地时间。</li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toLocaleDateString([locales[, options]])</code>：本地日期（不含小时、分和秒）。</li> <li><code class="language-plaintext highlighter-rouge">Date.prototype.toLocaleTimeString([locales[, options]])</code>：本地时间（不含年月日）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">()</span>
<span class="c1">// 中文版浏览器为"2013/1/1 00:00:00"</span>
<span class="c1">// 英文版浏览器为"1/1/2013 12:00:00 AM"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">()</span>
<span class="c1">// 中文版浏览器为"2013/1/1"</span>
<span class="c1">// 英文版浏览器为"1/1/2013"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">()</span>
<span class="c1">// 中文版浏览器为"00:00:00"</span>
<span class="c1">// 英文版浏览器为"12:00:00 AM"</span>
</code></pre></div></div> <p>这三个方法的两个参数中，<code class="language-plaintext highlighter-rouge">locales</code> 是一个指定所用语言的字符串，<code class="language-plaintext highlighter-rouge">options</code> 是一个配置对象。下面是 <code class="language-plaintext highlighter-rouge">locales</code> 的例子，分别采用 <code class="language-plaintext highlighter-rouge">en-US</code> 和 <code class="language-plaintext highlighter-rouge">zh-CN</code> 语言设定。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "1/1/2013, 12:00:00 AM"</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-CN</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "2013/1/1 00:00:00"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "1/1/2013"</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-CN</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "2013/1/1"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "12:00:00 AM"</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">zh-CN</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "00:00:00"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">options</code> 配置对象有以下属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">dateStyle</code>：可能的值为 <code class="language-plaintext highlighter-rouge">full</code>、<code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">medium</code>、<code class="language-plaintext highlighter-rouge">short</code>。</li> <li><code class="language-plaintext highlighter-rouge">timeStyle</code>：可能的值为 <code class="language-plaintext highlighter-rouge">full</code>、<code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">medium</code>、<code class="language-plaintext highlighter-rouge">short</code>。</li> <li><code class="language-plaintext highlighter-rouge">month</code>：可能的值为 <code class="language-plaintext highlighter-rouge">numeric</code>、<code class="language-plaintext highlighter-rouge">2-digit</code>、<code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">short</code>、<code class="language-plaintext highlighter-rouge">narrow</code>。</li> <li><code class="language-plaintext highlighter-rouge">year</code>：可能的值为 <code class="language-plaintext highlighter-rouge">numeric</code>、<code class="language-plaintext highlighter-rouge">2-digit</code>。</li> <li><code class="language-plaintext highlighter-rouge">weekday</code>：可能的值为 <code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">short</code>、<code class="language-plaintext highlighter-rouge">narrow</code>。</li> <li><code class="language-plaintext highlighter-rouge">day</code>、<code class="language-plaintext highlighter-rouge">hour</code>、<code class="language-plaintext highlighter-rouge">minute</code>、<code class="language-plaintext highlighter-rouge">second</code>：可能的值为 <code class="language-plaintext highlighter-rouge">numeric</code>、<code class="language-plaintext highlighter-rouge">2-digit</code>。</li> <li><code class="language-plaintext highlighter-rouge">timeZone</code>：可能的值为 IANA 的时区数据库。</li> <li><code class="language-plaintext highlighter-rouge">timeZoneName</code>：可能的值为 <code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">short</code>。</li> <li><code class="language-plaintext highlighter-rouge">hour12</code>：24 小时周期还是 12 小时周期，可能的值为 <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">weekday</span><span class="p">:</span> <span class="dl">'</span><span class="s1">long</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">year</span><span class="p">:</span> <span class="dl">'</span><span class="s1">numeric</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">month</span><span class="p">:</span> <span class="dl">'</span><span class="s1">long</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">day</span><span class="p">:</span> <span class="dl">'</span><span class="s1">numeric</span><span class="dl">'</span>
<span class="p">})</span>
<span class="c1">// "Tuesday, January 1, 2013"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleDateString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">day</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2-digit</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">month</span><span class="p">:</span> <span class="dl">"</span><span class="s2">long</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">year</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2-digit</span><span class="dl">"</span>
<span class="p">});</span>
<span class="c1">// "January 01, 13"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">timeZone</span><span class="p">:</span> <span class="dl">'</span><span class="s1">UTC</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">timeZoneName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">short</span><span class="dl">'</span>
<span class="p">})</span>
<span class="c1">// "4:00:00 PM UTC"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">timeZone</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Asia/Shanghai</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">timeZoneName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">long</span><span class="dl">'</span>
<span class="p">})</span>
<span class="c1">// "12:00:00 AM China Standard Time"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">hour12</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">})</span>
<span class="c1">// "00:00:00"</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">toLocaleTimeString</span><span class="p">(</span><span class="dl">'</span><span class="s1">en-US</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">hour12</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">})</span>
<span class="c1">// "12:00:00 AM"</span>
</code></pre></div></div> <h4 id="53-get-类方法">5.3 get 类方法</h4> <p><code class="language-plaintext highlighter-rouge">Date</code> 对象提供了一系列 <code class="language-plaintext highlighter-rouge">get*</code> 方法，用来获取实例对象某个方面的值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getTime()</code>：返回实例距离 1970 年 1 月 1 日 00:00:00 的毫秒数，等同于 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法。</li> <li><code class="language-plaintext highlighter-rouge">getDate()</code>：返回实例对象对应每个月的几号（从 1 开始）。</li> <li><code class="language-plaintext highlighter-rouge">getDay()</code>：返回星期几，星期日为0，星期一为 1，以此类推。</li> <li><code class="language-plaintext highlighter-rouge">getFullYear()</code>：返回四位的年份。</li> <li><code class="language-plaintext highlighter-rouge">getMonth()</code>：返回月份（0 表示 1 月，11 表示 12月）。</li> <li><code class="language-plaintext highlighter-rouge">getHours()</code>：返回小时（0-23）。</li> <li><code class="language-plaintext highlighter-rouge">getMilliseconds()</code>：返回毫秒（0-999）。</li> <li><code class="language-plaintext highlighter-rouge">getMinutes()</code>：返回分钟（0-59）。</li> <li><code class="language-plaintext highlighter-rouge">getSeconds()</code>：返回秒（0-59）。</li> <li><code class="language-plaintext highlighter-rouge">getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。</li> </ul> <p>所有这些 get* 方法返回的都是整数，不同方法返回值的范围不一样。</p> <ul> <li>分钟和秒：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">59</code></li> <li>小时：<code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">23</code></li> <li>星期：<code class="language-plaintext highlighter-rouge">0</code>（星期天）到 <code class="language-plaintext highlighter-rouge">6</code>（星期六）</li> <li>日期：<code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">31</code></li> <li>月份：<code class="language-plaintext highlighter-rouge">0</code>（一月）到 <code class="language-plaintext highlighter-rouge">11</code>（十二月）</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nf">getDate</span><span class="p">()</span> <span class="c1">// 6</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">getMonth</span><span class="p">()</span> <span class="c1">// 0</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">getFullYear</span><span class="p">()</span> <span class="c1">// 2013</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">getTimezoneOffset</span><span class="p">()</span> <span class="c1">// -480</span>
</code></pre></div></div> <p>上面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getUTCDate()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCFullYear()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCMonth()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCDay()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCHours()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCMinutes()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCSeconds()</code></li> <li><code class="language-plaintext highlighter-rouge">getUTCMilliseconds()</code></li> </ul> <h4 id="54-set-类方法">5.4 set 类方法</h4> <p><code class="language-plaintext highlighter-rouge">Date</code> 对象提供了一系列 <code class="language-plaintext highlighter-rouge">set*</code> 方法，用来设置实例对象的各个方面。</p> <ul> <li><code class="language-plaintext highlighter-rouge">setDate(date)</code>：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。</li> <li><code class="language-plaintext highlighter-rouge">setFullYear(year [, month, date])</code>：设置四位年份。</li> <li><code class="language-plaintext highlighter-rouge">setHours(hour [, min, sec, ms])</code>：设置小时（0-23）。</li> <li><code class="language-plaintext highlighter-rouge">setMilliseconds(ms)</code>：设置毫秒（0-999）。</li> <li><code class="language-plaintext highlighter-rouge">setMinutes(min [, sec, ms])</code>：设置分钟（0-59）。</li> <li><code class="language-plaintext highlighter-rouge">setMonth(month [, date])</code>：设置月份（0-11）。</li> <li><code class="language-plaintext highlighter-rouge">setSeconds(sec [, ms])</code>：设置秒（0-59）。</li> <li><code class="language-plaintext highlighter-rouge">setTime(milliseconds)</code>：设置毫秒时间戳。</li> </ul> <p>这些方法基本是跟 <code class="language-plaintext highlighter-rouge">get*</code> 方法一一对应的，但是没有 <code class="language-plaintext highlighter-rouge">setDay</code> 方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从 <code class="language-plaintext highlighter-rouge">0 开始算的，即 </code>0<code class="language-plaintext highlighter-rouge"> 是 </code>1<code class="language-plaintext highlighter-rouge"> 月，</code>11<code class="language-plaintext highlighter-rouge"> 是 </code>12` 月。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date </span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d</span> <span class="c1">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">setDate</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="c1">// 1357660800000</span>
<span class="nx">d</span> <span class="c1">// Wed Jan 09 2013 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">set*</code> 方法的参数都会自动折算。以 <code class="language-plaintext highlighter-rouge">setDate()</code> 为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d1</span><span class="p">.</span><span class="nf">setDate</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="c1">// 1359648000000</span>
<span class="nx">d1</span> <span class="c1">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span>

<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date </span><span class="p">(</span><span class="dl">'</span><span class="s1">January 6, 2013</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">d2</span><span class="p">.</span><span class="nf">setDate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 1356796800000</span>
<span class="nx">d2</span> <span class="c1">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">d1.setDate(32)</code> 将日期设为 <code class="language-plaintext highlighter-rouge">1</code> 月份的 <code class="language-plaintext highlighter-rouge">32</code> 号，因为 <code class="language-plaintext highlighter-rouge">1</code> 月份只有 <code class="language-plaintext highlighter-rouge">31</code> 号，所以自动折算为 <code class="language-plaintext highlighter-rouge">2</code> 月 <code class="language-plaintext highlighter-rouge">1</code> 日。<code class="language-plaintext highlighter-rouge">d2.setDate(-1)</code> 表示设为上个月的倒数第二天，即 <code class="language-plaintext highlighter-rouge">12</code> 月 <code class="language-plaintext highlighter-rouge">30</code> 日。</p> <p>set 类方法和 get 类方法，可以结合使用，得到相对时间。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>

<span class="c1">// 将日期向后推1000天</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">setDate</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">getDate</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">);</span>
<span class="c1">// 将时间设为6小时后</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">setHours</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">getHours</span><span class="p">()</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
<span class="c1">// 将年份设为去年</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">setFullYear</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">getFullYear</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">set*</code> 系列方法除了 <code class="language-plaintext highlighter-rouge">setTime()</code>，都有对应的 UTC 版本，即设置 UTC 时区的时间。</p> <ul> <li><code class="language-plaintext highlighter-rouge">setUTCDate()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCFullYear()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCHours()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCMilliseconds()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCMinutes()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCMonth()</code></li> <li><code class="language-plaintext highlighter-rouge">setUTCSeconds()</code></li> </ul> <h2 id="十regexp-对象">十、RegExp 对象</h2> <h2 id="十一json-对象">十一、JSON 对象</h2> <h2 id="十二参考">十二、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/stdlib/">JavaScript 教程 - 标准库</a></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 标准库》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/operators/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-08T00:00:00+00:00</published><updated>2024-10-08T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/operators</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/operators/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/operators/">《JavaScript 教程 - 运算符》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一算术运算符">一、算术运算符</h2> <h3 id="11-概述">1.1 概述</h3> <p>JavaScript 共提供 10 个算术运算符，用来完成基本的算术运算。包括 <code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">**</code>（指数运算符）、<code class="language-plaintext highlighter-rouge">%</code>（余数运算符）、<code class="language-plaintext highlighter-rouge">++x</code>（或者 <code class="language-plaintext highlighter-rouge">x++</code>，即自增运算符）、<code class="language-plaintext highlighter-rouge">--x</code>（或者 <code class="language-plaintext highlighter-rouge">x--</code>，即）自减运算符、<code class="language-plaintext highlighter-rouge">+x</code>（数值运算符） 和 <code class="language-plaintext highlighter-rouge">-x</code>（负数值运算符）。</p> <h3 id="12-加法运算符">1.2 加法运算符</h3> <h4 id="基本规则">基本规则</h4> <p>相比于其他运算符，加法运算符（<code class="language-plaintext highlighter-rouge">+</code>）比较特殊，即可当作算数运算符，又可对字符串进行连接操作。</p> <p>只要有一个是运算子是字符串，进行的就是字符串的连接操作（此时，如果另一个运算子不是字符串，会被转为字符串）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// "1a"</span>
<span class="kc">false</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="c1">// "falsea"</span>
</code></pre></div></div> <p>加法运算符是在<strong>运行时</strong>决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“<strong>重载</strong>”（overload）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1">// "345"</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span> <span class="c1">// "75"</span>
</code></pre></div></div> <p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：<strong>所有运算子一律转为数值，再进行相应的数学运算</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">-</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">*</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// 2</span>
<span class="mi">1</span> <span class="o">/</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span> <span class="c1">// 0.5</span>
</code></pre></div></div> <h4 id="对象的相加">对象的相加</h4> <p>如果运算子是对象，必须先转成原始类型的值，然后再相加。它的规则是：首先自动调用对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法，如果此时返回的是原始类型的值，则进行相应的操作，如果 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法得到的是对象类型，再自动调用对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法，将对象转为字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "[object Object]2"</span>
</code></pre></div></div> <p>上面代码中，对象 <code class="language-plaintext highlighter-rouge">obj</code> 转成原始类型的值是 <code class="language-plaintext highlighter-rouge">[object Object]</code>，再加 <code class="language-plaintext highlighter-rouge">2</code> 就得到了上面的结果。</p> <p>（1）首先，自动调用对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// { p: 1 }</span>
</code></pre></div></div> <p>（2）一般来说，对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法总是返回对象自身，这时再自动调用对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法，将其转为字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">().</span><span class="nf">toString</span><span class="p">()</span> <span class="c1">// "[object Object]"</span>
</code></pre></div></div> <p>对象的 <code class="language-plaintext highlighter-rouge">toString</code> 方法默认返回 <code class="language-plaintext highlighter-rouge">[object Object]</code>，所以就得到了最前面那个例子的结果。</p> <p>注意，如果 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法返回的是原始类型的值，就不再调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法，否则会调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法，尝试将对象转为字符串。</p> <p>知道了这个规则以后，就可以自己定义 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法或 <code class="language-plaintext highlighter-rouge">toString</code> 方法，得到想要的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">valueOf</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，我们定义 <code class="language-plaintext highlighter-rouge">obj</code> 对象的 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法返回 <code class="language-plaintext highlighter-rouge">1</code>，于是 <code class="language-plaintext highlighter-rouge">obj + 2</code> 就得到了 <code class="language-plaintext highlighter-rouge">3</code>。这个例子中，由于 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法直接返回一个原始类型的值，所以不再调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <p>下面是自定义 <code class="language-plaintext highlighter-rouge">toString</code> 方法的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">toString</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "hello2"</span>
</code></pre></div></div> <p>上面代码中，对象 obj 的 <code class="language-plaintext highlighter-rouge">toString</code> 方法返回字符串 <code class="language-plaintext highlighter-rouge">hello</code>。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。</p> <p>这里有一个特例，如果运算子是一个 <code class="language-plaintext highlighter-rouge">Date</code> 对象的实例，那么会优先执行 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// "hello2"</span>
</code></pre></div></div> <p>上面代码中，对象 <code class="language-plaintext highlighter-rouge">obj</code> 是一个 <code class="language-plaintext highlighter-rouge">Date</code> 对象的实例，并且自定义了 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法和 <code class="language-plaintext highlighter-rouge">toString</code> 方法，结果 <code class="language-plaintext highlighter-rouge">toString</code> 方法优先执行。</p> <h3 id="13-余数运算符">1.3 余数运算符</h3> <p>对于余数运算符（<code class="language-plaintext highlighter-rouge">%</code>）来说，运算结果的正负号由第一个运算子的正负号决定。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="mi">1</span> <span class="o">%</span> <span class="mi">2</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">%</span> <span class="o">-</span><span class="mi">2</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>所以，为了得到负数的正确余数值，可以先使用绝对值函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 错误的写法</span>
<span class="kd">function</span> <span class="nf">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// 正确的写法</span>
<span class="kd">function</span> <span class="nf">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nf">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">6.5</span> <span class="o">%</span> <span class="mf">2.1</span>
<span class="c1">// 0.19999999999999973</span>
</code></pre></div></div> <h3 id="14-自增和自减运算符">1.4 自增和自减运算符</h3> <p>对于自增和自减运算符，运算之后，变量的值发生变化，这种效应叫做运算的<strong>副作用</strong>（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。</p> <p>自增和自减运算符放置的位置不同，会导致不同的行为。</p> <ul> <li>如果放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。</li> <li>如果放在变量之后，会先返回变量操作前的值，再进行自增/自减操作。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">x</span><span class="o">++</span> <span class="c1">// 1</span>
<span class="o">++</span><span class="nx">y</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">x</code> 是先返回当前值，然后自增，所以得到 <code class="language-plaintext highlighter-rouge">1</code>；<code class="language-plaintext highlighter-rouge">y</code> 是先自增，然后返回新的值，所以得到 <code class="language-plaintext highlighter-rouge">2</code>。</p> <h3 id="15-数值运算符负数值运算符">1.5 数值运算符，负数值运算符</h3> <p>数值运算符（<code class="language-plaintext highlighter-rouge">+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。</p> <p>数值运算符的作用在于可以将任何值转为数值（与 <code class="language-plaintext highlighter-rouge">Number</code> 函数的作用相同）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span><span class="kc">true</span> <span class="c1">// 1</span>
<span class="o">+</span><span class="p">[]</span> <span class="c1">// 0</span>
<span class="o">+</span><span class="p">{}</span> <span class="c1">// NaN</span>
</code></pre></div></div> <p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行 <code class="language-plaintext highlighter-rouge">NaN</code> 也是数值）。</p> <p>负数值运算符（<code class="language-plaintext highlighter-rouge">-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。</p> <h3 id="16-指数运算符">1.6 指数运算符</h3> <p>指数运算符（<code class="language-plaintext highlighter-rouge">**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="c1">// 16</span>
</code></pre></div></div> <p>注意，指数运算符是<strong>右结合</strong>。即多个指数运算符连用时，先进行最右边的计算。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于 2 ** (3 ** 2)</span>
<span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">**</span> <span class="mi">2</span>
<span class="c1">// 512</span>
</code></pre></div></div> <p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。</p> <h2 id="二比较运算符">二、比较运算符</h2> <h3 id="21-概述">2.1 概述</h3> <p>JavaScript 提供了 8 个比较运算符，他们是：<code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;=</code>、<code class="language-plaintext highlighter-rouge">&lt;=</code>、<code class="language-plaintext highlighter-rouge">==</code>、<code class="language-plaintext highlighter-rouge">===</code>、<code class="language-plaintext highlighter-rouge">!=</code> 和 <code class="language-plaintext highlighter-rouge">!==</code>。</p> <p>这八个比较运算符分成两类：相等比较和非相等比较。对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p> <h3 id="22-非相等运算符字符串的比较">2.2 非相等运算符：字符串的比较</h3> <p>字符串按照字典顺序进行比较。首先比较首字符的 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点。如果相等，再比较第二个字符的 <code class="language-plaintext highlighter-rouge">Unicode</code> 码点，以此类推。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">dog</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">Cat</span><span class="dl">'</span> <span class="c1">// true' c 的 Unicode 码点是 99，C 的 Unicode 码点是 67</span>
<span class="dl">'</span><span class="s1">大</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">小</span><span class="dl">'</span> <span class="c1">// false “大”的 Unicode 码点是 22823，“小”是23567</span>
</code></pre></div></div> <h3 id="23-非相等运算符非字符串的比较">2.3 非相等运算符：非字符串的比较</h3> <p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。</p> <h4 id="1原始类型值">（1）原始类型值</h4> <p>如果两个运算子都是原始类型的值，则先转成数值再比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">4</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="c1">// 等同于 5 &gt; Number('4')</span>
<span class="c1">// 即 5 &gt; 4</span>

<span class="kc">true</span> <span class="o">&gt;</span> <span class="kc">false</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number(true) &gt; Number(false)</span>
<span class="c1">// 即 1 &gt; 0</span>

<span class="mi">2</span> <span class="o">&gt;</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 2 &gt; Number(true)</span>
<span class="c1">// 即 2 &gt; 1</span>
</code></pre></div></div> <p>任何值（包括 <code class="language-plaintext highlighter-rouge">NaN</code> 本身）与 <code class="language-plaintext highlighter-rouge">NaN</code> 使用非相等运算符进行比较，返回的都是 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="mi">1</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
</code></pre></div></div> <h4 id="2对象">（2）对象</h4> <p>如果运算子是对象，会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用 <code class="language-plaintext highlighter-rouge">valueOf</code> 方法；如果返回的还是对象，再接着调用 <code class="language-plaintext highlighter-rouge">toString</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">11</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; '11'</span>
<span class="c1">// 即 '2' &gt; '11'</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">11</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="c1">// 等同于 (function () { return '1' })() &gt; '11'</span>
<span class="c1">// 即 '1' &gt; '11'</span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span>
<span class="c1">// 即 '2' &gt; '1'</span>
</code></pre></div></div> <h3 id="24-严格相等运算符">2.4 严格相等运算符</h3> <ul> <li>相等运算符（<code class="language-plaintext highlighter-rouge">==</code>）比较两个值是否<strong>相等</strong>。如果两个值不是同一类型，相等运算符会将它们转换成同一个类型，再用严格相等运算符进行比较。</li> <li>严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）比较两个值是否为“<strong>同一个值</strong>”。如果两个值不是同一类型，严格相等运算符直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <p>对于严格相等运算符：</p> <ul> <li>如果两个值的类型不同，直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回 <code class="language-plaintext highlighter-rouge">true</code>，值不同就返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li>复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向<strong>同一个地址</strong>。</li> <li><code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 与自身严格相等。</li> </ul> <h3 id="25-严格不相等运算符">2.5 严格不相等运算符</h3> <p>严格不相等运算符（<code class="language-plaintext highlighter-rouge">!==</code>）先求严格相等运算符的结果，然后取相反值。</p> <h3 id="26-相等运算符">2.6 相等运算符</h3> <p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。比较不同类型的数据时，相等运算符会先将数据进行<strong>类型转换</strong>，然后再用严格相等运算符比较。</p> <ul> <li> <p>原始类型的值会转换成数值再进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 1 === Number(true)</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="c1">// 等同于 2 === Number(false)</span>

<span class="dl">'</span><span class="s1">true</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
<span class="c1">// 等同于 Number('true') === Number(true)</span>
<span class="c1">// 等同于 NaN === 1</span>

<span class="dl">''</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number('') === 0</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="dl">''</span> <span class="o">==</span> <span class="kc">false</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number('') === Number(false)</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number('1') === Number(true)</span>
<span class="c1">// 等同于 1 === 1</span>

<span class="dl">'</span><span class="se">\n</span><span class="s1">  123  </span><span class="se">\t</span><span class="dl">'</span> <span class="o">==</span> <span class="mi">123</span> <span class="c1">// true</span>
<span class="c1">// 因为字符串转为数字时，省略前置和后置的空格</span>
</code></pre></div> </div> </li> <li> <p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。先调用对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用 <code class="language-plaintext highlighter-rouge">toString()</code> 方法，得到字符串形式，再进行比较。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组与数值的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">// true</span>

<span class="c1">// 数组与字符串的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1,2</span><span class="dl">'</span> <span class="c1">// true</span>

<span class="c1">// 对象与布尔值的比较</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 只有与自身比较，或者互相比较时，才会返回 <code class="language-plaintext highlighter-rouge">true</code>；与其他类型的值比较时，结果都为 <code class="language-plaintext highlighter-rouge">false</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">undefined</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="c1">// true</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
<span class="kc">undefined</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
</code></pre></div> </div> </li> <li> <p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">==</span> <span class="dl">''</span>             <span class="c1">// true</span>
<span class="mi">0</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span>            <span class="c1">// true</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">true</span>           <span class="c1">// false</span>
<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span>          <span class="c1">// false</span>

<span class="kc">false</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">false</span><span class="dl">'</span>    <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span>        <span class="c1">// true</span>

<span class="kc">false</span> <span class="o">==</span> <span class="kc">undefined</span>  <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="kc">null</span>       <span class="c1">// false</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">undefined</span>   <span class="c1">// true</span>

<span class="dl">'</span><span class="s1"> </span><span class="se">\t\r\n</span><span class="s1"> </span><span class="dl">'</span> <span class="o">==</span> <span class="mi">0</span>     <span class="c1">// true</span>
</code></pre></div> </div> </li> </ul> <p>建议不要使用相等运算符（<code class="language-plaintext highlighter-rouge">==</code>），最好只使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）。</p> <h3 id="27-不相等运算符">2.7 不相等运算符</h3> <p>不相等运算符（<code class="language-plaintext highlighter-rouge">!=</code>）先求相等运算符的结果，然后取相反值。</p> <h2 id="三布尔运算符">三、布尔运算符</h2> <h3 id="31-概述">3.1 概述</h3> <p>布尔运算符用于将表达式转为布尔值，共包含四个运算符：<code class="language-plaintext highlighter-rouge">!</code>（取反运算符）、<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>（且运算符）、<code class="language-plaintext highlighter-rouge">||</code>（或运算符）和 <code class="language-plaintext highlighter-rouge">?:</code>（三元运算符）。</p> <h3 id="32-取反运算符">3.2 取反运算符（!）</h3> <ul> <li><code class="language-plaintext highlighter-rouge">undefined</code>、<code class="language-plaintext highlighter-rouge">null</code>、<code class="language-plaintext highlighter-rouge">false</code>、<code class="language-plaintext highlighter-rouge">0</code>、<code class="language-plaintext highlighter-rouge">NaN</code> 和空字符串（<code class="language-plaintext highlighter-rouge">''</code>）取反后为 <code class="language-plaintext highlighter-rouge">true</code>，其他值都为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li> <p>对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 <code class="language-plaintext highlighter-rouge">Boolean()</code> 函数的作用相同。这是一种常用的类型转换的写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!!</span><span class="nx">x</span>
<span class="c1">// 等同于</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> <h3 id="33-且运算符">3.3 且运算符（&amp;&amp;）</h3> <p>且运算符（<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>）的运算规则是：如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>，则返回第二个运算子的<strong>值</strong>（注意是值，不是布尔值）；如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">false</code>，则直接返回第一个运算子的<strong>值</strong>，且不再对第二个运算子求值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">''</span> <span class="c1">// ""</span>
<span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "f"</span>
<span class="dl">''</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// ""</span>
</code></pre></div></div> <p>这种跳过第二个运算子的机制，被称为“<strong>短路</strong>”。有时候可以用它取代 if 结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 等价于</span>
<span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nf">doSomething</span><span class="p">();</span>
</code></pre></div></div> <p>且运算符可以多个连用，这时返回第一个布尔值为 <code class="language-plaintext highlighter-rouge">false</code> 的表达式的值。如果所有表达式的布尔值都为 <code class="language-plaintext highlighter-rouge">true</code>，则返回最后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="dl">''</span> <span class="o">&amp;&amp;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
<span class="c1">// ''</span>

<span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="mi">3</span>
<span class="c1">// 3</span>
</code></pre></div></div> <h3 id="34-或运算符">3.4 或运算符（||）</h3> <p>或运算符（<code class="language-plaintext highlighter-rouge">||</code>）的运算规则是：如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>，则返回第一个运算子的<strong>值</strong>，且不再对第二个运算子求值；如果第一个运算子的布尔值为 <code class="language-plaintext highlighter-rouge">false</code>，则返回第二个运算子的<strong>值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">||</span> <span class="dl">''</span> <span class="c1">// "t"</span>
<span class="dl">'</span><span class="s1">t</span><span class="dl">'</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "t"</span>
<span class="dl">''</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">f</span><span class="dl">'</span> <span class="c1">// "f"</span>
<span class="dl">''</span> <span class="o">||</span> <span class="dl">''</span> <span class="c1">// ""</span>
</code></pre></div></div> <p>或运算符可以多个连用，这时返回第一个布尔值为 <code class="language-plaintext highlighter-rouge">true</code> 的表达式的值。如果所有表达式都为 <code class="language-plaintext highlighter-rouge">false</code>，则返回最后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="dl">''</span> <span class="o">||</span> <span class="mi">4</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="o">||</span> <span class="kc">true</span>
<span class="c1">// 4</span>

<span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="dl">''</span>
<span class="c1">// ''</span>
</code></pre></div></div> <h2 id="四二进制位运算符">四、二进制位运算符</h2> <h3 id="41-概述">4.1 概述</h3> <p>二进制位运算符用于直接对二进制位进行计算，共有 7 个。</p> <ul> <li>二进制<strong>或</strong>运算符（or）：符号为 <code class="language-plaintext highlighter-rouge">|</code>，表示若两个二进制位都为 <code class="language-plaintext highlighter-rouge">0</code>，则结果为 <code class="language-plaintext highlighter-rouge">0</code>，否则为 <code class="language-plaintext highlighter-rouge">1</code>。</li> <li>二进制<strong>与</strong>运算符（and）：符号为 <code class="language-plaintext highlighter-rouge">&amp;</code>，表示若两个二进制位都为 <code class="language-plaintext highlighter-rouge">1</code>，则结果为 <code class="language-plaintext highlighter-rouge">1</code>，否则为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li>二进制<strong>否</strong>运算符（not）：符号为 <code class="language-plaintext highlighter-rouge">~</code>，表示对一个二进制位取反。</li> <li><strong>异或</strong>运算符（xor）：符号为 <code class="language-plaintext highlighter-rouge">^</code>，表示若两个二进制位不相同，则结果为 <code class="language-plaintext highlighter-rouge">1</code>，否则为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><strong>左移</strong>运算符（left shift）：符号为 <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>。</li> <li><strong>右移</strong>运算符（right shift）：符号为 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>。</li> <li>头部补零的右移运算符（zero filled right shift）：符号为 <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>。</li> </ul> <p>这些位运算符直接处理每个比特位（bit）。</p> <p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是以 <strong>32 位带符号的整数</strong>进行运算的，并且返回值也是一个 32 位带符号的整数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div> <p>上面这行代码的意思，就是将 <code class="language-plaintext highlighter-rouge">i</code>（不管是整数或小数）转为 32 位整数。</p> <p>利用这个特性，可以写出一个函数，将任意数值转为32位整数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">toInt32</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">toInt32</span><span class="p">(</span><span class="mf">1.001</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="mf">1.999</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// -1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nf">toInt32</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// -1</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">toInt32()</code> 方法将任意值与 <code class="language-plaintext highlighter-rouge">0</code> 进行一次或运算，这个位运算会自动将一个值转为 32 位整数。上面代码中，<code class="language-plaintext highlighter-rouge">toInt32()</code> 用于将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于 2 的 32 次方的整数，大于 32 位的数位都会被舍去。</p> <h3 id="42-二进制或运算符">4.2 二进制或运算符</h3> <p>二进制或运算符（<code class="language-plaintext highlighter-rouge">|</code>）<strong>逐位</strong>比较两个运算子，两个二进制位之中只要有一个为 <code class="language-plaintext highlighter-rouge">1</code>，就返回 <code class="language-plaintext highlighter-rouge">1</code>，否则返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">|</span> <span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">3</code> 的二进制形式分别是 <code class="language-plaintext highlighter-rouge">00</code> 和 <code class="language-plaintext highlighter-rouge">11</code>，所以进行二进制或运算会得到 <code class="language-plaintext highlighter-rouge">11</code>（即 <code class="language-plaintext highlighter-rouge">3</code>）。</p> <p>位运算<strong>只对整数有效</strong>，遇到小数时，会将小数部分舍去，只保留整数部分。所以，<strong>将一个小数与 <code class="language-plaintext highlighter-rouge">0</code> 进行二进制或运算，等同于对该数去除小数部分，即取整数位</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">2.9</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// 2</span>
<span class="o">-</span><span class="mf">2.9</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// -2</span>
</code></pre></div></div> <h3 id="43-二进制与运算符">4.3 二进制与运算符</h3> <p>二进制与运算符（<code class="language-plaintext highlighter-rouge">&amp;</code>）<strong>逐位</strong>比较两个运算子，两个二进制位之中只要有一个位为 <code class="language-plaintext highlighter-rouge">0</code>，就返回 <code class="language-plaintext highlighter-rouge">0</code>，否则返回 <code class="language-plaintext highlighter-rouge">1</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="c1">// 0</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">0</code>（二进制 <code class="language-plaintext highlighter-rouge">00</code>）和 <code class="language-plaintext highlighter-rouge">3</code>（二进制 <code class="language-plaintext highlighter-rouge">11</code>）进行二进制与运算会得到 <code class="language-plaintext highlighter-rouge">00</code>（即 <code class="language-plaintext highlighter-rouge">0</code>）。</p> <h3 id="44-二进制否运算符">4.4 二进制否运算符</h3> <p>二进制否运算符（<code class="language-plaintext highlighter-rouge">~</code>）将每个二进制位都变为相反值（<code class="language-plaintext highlighter-rouge">0</code> 变为 <code class="language-plaintext highlighter-rouge">1</code>，<code class="language-plaintext highlighter-rouge">1</code> 变为 <code class="language-plaintext highlighter-rouge">0</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~</span> <span class="mi">3</span> <span class="c1">// -4</span>
</code></pre></div></div> <p>上面表达式对 <code class="language-plaintext highlighter-rouge">3</code> 进行二进制否运算，得到 <code class="language-plaintext highlighter-rouge">-4</code>。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为 32 位的二进制整数再进行运算。</p> <p><code class="language-plaintext highlighter-rouge">3</code> 的 32 位整数形式是 <code class="language-plaintext highlighter-rouge">00000000000000000000000000000011</code>，二进制否运算以后得到 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111100</code>。由于第一位（符号位）是 1，所以这个数是一个负数。JavaScript 内部采用<strong>补码</strong>形式表示负数，即需要将这个数减去 <code class="language-plaintext highlighter-rouge">1</code>，再取一次反，然后加上负号，才能得到这个负数对应的 10 进制值。这个数减去 1 等于 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111011</code>，再取一次反得到 <code class="language-plaintext highlighter-rouge">00000000000000000000000000000100</code>，再加上负号就是 <code class="language-plaintext highlighter-rouge">-4</code>。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于 <code class="language-plaintext highlighter-rouge">-1</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~</span> <span class="o">-</span><span class="mi">3</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面表达式可以这样算，<code class="language-plaintext highlighter-rouge">-3</code> 的取反值等于 <code class="language-plaintext highlighter-rouge">-1</code> 减去 <code class="language-plaintext highlighter-rouge">-3</code>，结果为 <code class="language-plaintext highlighter-rouge">2</code>。</p> <p>对一个整数连续两次二进制否运算，得到它自身。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~~</span><span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>所有的位运算都只对<strong>整数</strong>有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，<strong>对一个小数连续进行两次二进制否运算，能达到取整效果</strong>。使用二进制<strong>否</strong>运算取整，是所有取整方法中最快的一种。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~~</span><span class="mf">2.9</span> <span class="c1">// 2</span>
<span class="o">~~</span><span class="mf">47.11</span> <span class="c1">// 47</span>
<span class="o">~~</span><span class="mf">1.9999</span> <span class="c1">// 1</span>
<span class="o">~~</span><span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>对字符串进行二进制否运算，JavaScript 引擎会先调用 <code class="language-plaintext highlighter-rouge">Number</code> 函数，将字符串转为数值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于 ~Number('011')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">011</span><span class="dl">'</span>  <span class="c1">// -12</span>

<span class="c1">// 相当于 ~Number('42 cats')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number('0xcafebabe')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">0xcafebabe</span><span class="dl">'</span> <span class="c1">// 889275713</span>

<span class="c1">// 相当于 ~Number('deadbeef')</span>
<span class="o">~</span><span class="dl">'</span><span class="s1">deadbeef</span><span class="dl">'</span> <span class="c1">// -1</span>
</code></pre></div></div> <p>对于其他类型的值，二进制否运算也是先用 <code class="language-plaintext highlighter-rouge">Number</code> 转为数值，然后再进行处理。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于 ~Number([])</span>
<span class="o">~</span><span class="p">[]</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number(NaN)</span>
<span class="o">~</span><span class="kc">NaN</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number(null)</span>
<span class="o">~</span><span class="kc">null</span> <span class="c1">// -1</span>
</code></pre></div></div> <h3 id="45-异或运算符">4.5 异或运算符</h3> <p>异或运算（<code class="language-plaintext highlighter-rouge">^</code>）在两个二进制位不同时返回 <code class="language-plaintext highlighter-rouge">1</code>，相同时返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">^</span> <span class="mi">3</span> <span class="c1">// 3</span>
</code></pre></div></div> <p>上面表达式中，<code class="language-plaintext highlighter-rouge">0</code>（二进制 <code class="language-plaintext highlighter-rouge">00</code>）与 <code class="language-plaintext highlighter-rouge">3</code>（二进制 <code class="language-plaintext highlighter-rouge">11</code>）进行异或运算，它们每一个二进制位都不同，所以得到 <code class="language-plaintext highlighter-rouge">11</code>（即 <code class="language-plaintext highlighter-rouge">3</code>）。</p> <p>“异或运算”有一个特殊运用，连续对两个数 <code class="language-plaintext highlighter-rouge">a</code> 和 <code class="language-plaintext highlighter-rouge">b</code> 进行三次异或运算，<code class="language-plaintext highlighter-rouge">a^=b; b^=a; a^=b;</code>，可以<strong>互换</strong>它们的值。这意味着，<strong>“异或运算”可以在不引入临时变量的前提下，互换两个变量的值</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>

<span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">b</span> <span class="o">^=</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">;</span>

<span class="nx">a</span> <span class="c1">// 99</span>
<span class="nx">b</span> <span class="c1">// 10</span>
</code></pre></div></div> <p>这是互换两个变量的值的最快方法。</p> <p><strong>异或运算也可以用来取整</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">12.9</span> <span class="o">^</span> <span class="mi">0</span> <span class="c1">// 12</span>
</code></pre></div></div> <h3 id="46-左移运算符">4.6 左移运算符</h3> <p>左移运算符（<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>）表示将一个数的二进制值向左移动指定的位数，尾部补 <code class="language-plaintext highlighter-rouge">0</code>，即乘以 <code class="language-plaintext highlighter-rouge">2</code> 的指定次方。向左移动的时候，最高位的符号位是一起移动的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 4 的二进制形式为100，</span>
<span class="c1">// 左移一位为1000（即十进制的8）</span>
<span class="c1">// 相当于乘以2的1次方</span>
<span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1">// 8</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1">// -8</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">-4</code> 左移一位得到 <code class="language-plaintext highlighter-rouge">-8</code>，是因为 -4 的二进制形式是 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111100</code>，左移一位后得到 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111000</code>，该数转为十进制（减去 <code class="language-plaintext highlighter-rouge">1</code> 后取反，再加上负号）即为 <code class="language-plaintext highlighter-rouge">-8</code>。</p> <p><strong>如果左移 <code class="language-plaintext highlighter-rouge">0</code> 位，就相当于将该数值转为 32 位整数，等同于取整，对于正数和负数都有效</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">13.5</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="c1">// 13</span>

<span class="o">-</span><span class="mf">13.5</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="c1">// -13</span>
</code></pre></div></div> <p>左移运算符用于二进制数值非常方便。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">color</span> <span class="o">=</span> <span class="p">{</span><span class="na">r</span><span class="p">:</span> <span class="mi">186</span><span class="p">,</span> <span class="na">g</span><span class="p">:</span> <span class="mi">218</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">85</span><span class="p">};</span>

<span class="c1">// RGB to HEX</span>
<span class="c1">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span>
<span class="kd">var</span> <span class="nx">rgb2hex</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">r</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">g</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// 先转成十六进制，然后返回字符串</span>
    <span class="p">.</span><span class="nf">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">// 去除字符串的最高位，返回后面六个字符串</span>
<span class="p">}</span>

<span class="nf">rgb2hex</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">r</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
<span class="c1">// "#bada55"</span>
</code></pre></div></div> <p>上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。</p> <h3 id="47-右移运算符">4.7 右移运算符</h3> <p>右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补 <code class="language-plaintext highlighter-rouge">0</code>；如果是负数，头部全部补 <code class="language-plaintext highlighter-rouge">1</code>。右移运算符基本上相当于除以 <code class="language-plaintext highlighter-rouge">2</code> 的指定次方（最高位即符号位参与移动）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>
<span class="cm">/*
// 因为 4 的二进制形式为 00000000000000000000000000000100
// 右移一位得到 00000000000000000000000000000010
// 即为十进制的 2
*/</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// -2</span>
<span class="cm">/*
// 因为 -4 的二进制形式为 11111111111111111111111111111100
// 右移一位，头部补 1，得到 11111111111111111111111111111110
// 即为十进制的 -2
*/</span>
</code></pre></div></div> <p>右移运算可以模拟 2 的整除运算。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>
<span class="c1">// 相当于 5 / 2 = 2</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>
<span class="c1">// 5</span>
<span class="c1">// 相当于 21 / 4 = 5</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
<span class="c1">// 2</span>
<span class="c1">// 相当于 21 / 8 = 2</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
<span class="c1">// 1</span>
<span class="c1">// 相当于 21 / 16 = 1</span>
</code></pre></div></div> <h3 id="48-头部补零的右移运算符">4.8 头部补零的右移运算符</h3> <p>头部补零的右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>）与右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补 <code class="language-plaintext highlighter-rouge">0</code>，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）完全一致，区别主要在于负数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2147483646</span>
<span class="cm">/*
// 因为 -4 的二进制形式为11111111111111111111111111111100
// 带符号位的右移一位，得到 01111111111111111111111111111110
// 即为十进制的 2147483646
*/</span>
</code></pre></div></div> <p>这个运算实际上将一个值转为 32 位无符号整数。</p> <p>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">0</span> <span class="c1">// 4294967295</span>
</code></pre></div></div> <p>上面代码表示，<code class="language-plaintext highlighter-rouge">-1</code> 作为 32 位整数时，内部的储存形式使用无符号整数格式解读，值为 <code class="language-plaintext highlighter-rouge">4294967295</code>（即 <code class="language-plaintext highlighter-rouge">(2^32)-1</code>，等于 <code class="language-plaintext highlighter-rouge">11111111111111111111111111111111</code>）。</p> <h3 id="49-开关作用">4.9 开关作用</h3> <p>位运算符可以用作设置对象属性的开关。</p> <p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">FLAG_A</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 0001</span>
<span class="kd">var</span> <span class="nx">FLAG_B</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 0010</span>
<span class="kd">var</span> <span class="nx">FLAG_C</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 0100</span>
<span class="kd">var</span> <span class="nx">FLAG_D</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// 1000</span>
</code></pre></div></div> <p>上面代码设置 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">C</code>、<code class="language-plaintext highlighter-rouge">D</code> 四个开关，每个开关分别占有一个二进制位。</p> <ul> <li> <p>可以用二进制<strong>与</strong>运算，检查当前设置是否打开了指定开关。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">flags</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 二进制的0101</span>

<span class="k">if </span><span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">FLAG_C</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span>
</code></pre></div> </div> <p>上面代码检验是否打开了开关 <code class="language-plaintext highlighter-rouge">C</code>。如果打开，会返回 <code class="language-plaintext highlighter-rouge">true</code>，否则返回 <code class="language-plaintext highlighter-rouge">false</code>。</p> </li> <li> <p>现在假设需要打开 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">D</code> 三个开关，我们可以构造一个掩码变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mask</span> <span class="o">=</span> <span class="nx">FLAG_A</span> <span class="o">|</span> <span class="nx">FLAG_B</span> <span class="o">|</span> <span class="nx">FLAG_D</span><span class="p">;</span>
<span class="c1">// 0001 | 0010 | 1000 =&gt; 1011</span>
</code></pre></div> </div> <p>上面代码对 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">D</code> 三个变量进行二进制或运算，得到掩码值为二进制的 <code class="language-plaintext highlighter-rouge">1011</code>。</p> <p>有了掩码，二进制<strong>或</strong>运算可以确保打开指定的开关。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags | mask;
</code></pre></div> </div> <p>上面代码中，计算后得到的 <code class="language-plaintext highlighter-rouge">flags</code> 变量，代表三个开关的二进制位都打开了。</p> </li> <li> <p>二进制<strong>与</strong>运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags &amp; mask;
</code></pre></div> </div> </li> <li> <p>异或运算可以<strong>切换</strong>（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = flags ^ mask;
</code></pre></div> </div> </li> <li> <p>二进制<strong>否</strong>运算可以翻转当前设置，即原设置为 <code class="language-plaintext highlighter-rouge">0</code>，运算后变为 <code class="language-plaintext highlighter-rouge">1</code>；原设置为 <code class="language-plaintext highlighter-rouge">1</code>，运算后变为 <code class="language-plaintext highlighter-rouge">0</code>。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flags = ~flags;
</code></pre></div> </div> </li> </ul> <h2 id="五其他运算符运算顺序">五、其他运算符，运算顺序</h2> <h3 id="51-void-运算符">5.1 void 运算符</h3> <p><code class="language-plaintext highlighter-rouge">void</code> 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 <code class="language-plaintext highlighter-rouge">undefined</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="mi">0</span> <span class="c1">// undefined</span>
<span class="k">void</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// undefined</span>
</code></pre></div></div> <p>上面是 <code class="language-plaintext highlighter-rouge">void</code> 运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为 <code class="language-plaintext highlighter-rouge">void</code> 运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，<code class="language-plaintext highlighter-rouge">void 4 + 7</code> 实际上等同于 <code class="language-plaintext highlighter-rouge">(void 4) + 7</code>。</p> <p><code class="language-plaintext highlighter-rouge">void</code> 运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">javascript: void(document.form.submit())</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="nx">提交</span>
<span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div></div> <p>上面的代码中，用户点击链接提交表单，但是不产生页面跳转。</p> <h3 id="52-逗号运算符">5.2 逗号运算符</h3> <p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span> <span class="c1">// "b"</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="o">++</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 10</span>
</code></pre></div></div> <p>上面代码中，逗号运算符返回后一个表达式的值。</p> <p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hi!</span><span class="dl">'</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
<span class="c1">// Hi!</span>

<span class="nx">value</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，先执行逗号之前的操作，然后返回逗号后面的值。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/operators/">JavaScript 教程 - 运算符</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="javascript"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 运算符》一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。]]></summary></entry><entry><title type="html">webpack 构建流程</title><link href="https://feng-zhang0712.github.io//blog/2024/build-flow/" rel="alternate" type="text/html" title="webpack 构建流程"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/build-flow</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/build-flow/"><![CDATA[<p>webpack 的构建流程，主要包括初始化、编译、打包、优化和生成输出五个阶段。</p> <h3 id="41-初始化阶段">4.1 初始化阶段</h3> <p>在初始化阶段，webpack 根据配置文件和命令行参数进行初始化工作。包括以下步骤。</p> <ul> <li><strong>读取配置</strong>：读取 webpack 配置文件（<code class="language-plaintext highlighter-rouge">webpack.config.js</code>）并解析配置项。</li> <li><strong>注册插件</strong>：根据配置文件中的 <code class="language-plaintext highlighter-rouge">plugins</code> 项注册所有插件。</li> <li><strong>创建编译器对象</strong>：初始化 <code class="language-plaintext highlighter-rouge">Compiler</code> 对象，这是 webpack 构建的核心引擎，负责整个构建过程的协调工作。</li> <li><strong>应用插件</strong>：调用每个插件的 <code class="language-plaintext highlighter-rouge">apply</code> 方法，将插件挂载到 webpack 的钩子上。</li> <li><strong>触发环境钩子</strong>：触发 <code class="language-plaintext highlighter-rouge">environment</code> 和 <code class="language-plaintext highlighter-rouge">afterEnvironment</code> 等初始化阶段的钩子。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./webpack.config.js</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">webpack</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">webpack</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">compiler</span> <span class="o">=</span> <span class="nf">webpack</span><span class="p">(</span><span class="nx">config</span><span class="p">);</span>

<span class="nx">compiler</span><span class="p">.</span><span class="nf">run</span><span class="p">((</span><span class="nx">err</span><span class="p">,</span> <span class="nx">stats</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">stats</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></div></div> <p>初始化阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">initialize</code>：初始化 webpack。</li> <li><code class="language-plaintext highlighter-rouge">environment</code>：设置环境变量。</li> <li><code class="language-plaintext highlighter-rouge">afterEnvironment</code>：环境变量设置完成。</li> <li><code class="language-plaintext highlighter-rouge">entryOption</code>：处理入口选项。</li> </ul> <h3 id="42-编译阶段">4.2 编译阶段</h3> <p>编译阶段主要负责将源代码转换为 webpack 的模块化表示形式。</p> <ul> <li><strong>确定入口点</strong>：根据配置中的 <code class="language-plaintext highlighter-rouge">entry</code> 项确定入口模块。</li> <li><strong>递归解析模块</strong>：从入口点出发，递归解析依赖的模块。每个模块都会经过相应的 Loader 处理，转换为 webpack 能够理解的模块。</li> <li><strong>生成模块依赖图</strong>：构建模块与模块之间的依赖关系图。</li> </ul> <p>以下是编译阶段的详细流程。</p> <ol> <li><strong>创建 Compilation 对象</strong>：<code class="language-plaintext highlighter-rouge">Compiler</code> 对象会创建一个新的 <code class="language-plaintext highlighter-rouge">Compilation</code> 对象，用来存储当前编译的状态和结果。</li> <li><strong>触发 Compilation 钩子</strong>：触发 <code class="language-plaintext highlighter-rouge">thisCompilation</code> 和 <code class="language-plaintext highlighter-rouge">compilation</code> 钩子，通知插件开始编译。</li> <li><strong>构建模块</strong>： <ul> <li><strong>从入口开始</strong>：从入口模块开始，使用 <code class="language-plaintext highlighter-rouge">loader</code> 对模块进行转换。</li> <li><strong>递归解析</strong>：解析模块的依赖（如 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 语句）并递归处理依赖的模块。</li> <li><strong>生成抽象语法树（AST）</strong>：解析模块代码并生成 AST。</li> <li><strong>应用 Loader</strong>：按照配置的 <code class="language-plaintext highlighter-rouge">loader</code> 对模块进行处理。</li> <li><strong>添加模块到依赖图</strong>：将处理后的模块添加到依赖图中。</li> </ul> </li> </ol> <p>编译阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">beforeCompile</code>：编译开始前。</li> <li><code class="language-plaintext highlighter-rouge">compile</code>：编译阶段开始。</li> <li><code class="language-plaintext highlighter-rouge">thisCompilation</code>：新的 Compilation 创建前。</li> <li><code class="language-plaintext highlighter-rouge">compilation</code>：新的 Compilation 创建后。</li> </ul> <h3 id="43-打包阶段">4.3 打包阶段</h3> <p>打包阶段负责将编译后的模块根据依赖图进行打包，生成一个或多个 Chunk。</p> <ul> <li><strong>生成 Chunk</strong>：根据入口和依赖关系生成 Chunk，每个 Chunk 代表一个输出文件。</li> <li><strong>添加 Chunk 到 Compilation</strong>：将生成的 Chunk 添加到 <code class="language-plaintext highlighter-rouge">Compilation</code> 对象中。</li> </ul> <p>打包阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">make</code>：从入口点开始构建模块。</li> <li><code class="language-plaintext highlighter-rouge">afterCompile</code>：编译完成。</li> </ul> <h3 id="44-优化阶段">4.4 优化阶段</h3> <p>在优化阶段，webpack 会对生成的 Chunk 进行优化，如代码压缩、提取公共模块等。</p> <ul> <li><strong>代码拆分</strong>：提取公共模块、动态导入模块等。</li> <li><strong>压缩代码</strong>：根据配置对代码进行压缩和混淆。</li> <li><strong>其他优化</strong>：如 Tree Shaking、Scope Hoisting 等。</li> </ul> <h3 id="45-生成输出阶段">4.5 生成输出阶段</h3> <p>生成输出阶段负责将优化后的代码输出到指定的目录。</p> <ul> <li><strong>生成输出资源</strong>：根据 Chunk 生成最终的输出文件（如 JavaScript、CSS、HTML 等）。</li> <li><strong>写入文件系统</strong>：将生成的文件写入到输出目录（通常是 <code class="language-plaintext highlighter-rouge">dist</code> 目录）。</li> </ul> <p>以下是生成输出阶段的详细流程。</p> <ol> <li><strong>触发 <code class="language-plaintext highlighter-rouge">emit</code> 钩子</strong>：在写入文件前触发 <code class="language-plaintext highlighter-rouge">emit</code> 钩子，通知插件进行最后的修改或添加额外的文件。</li> <li><strong>写入文件到输出目录</strong>：将生成的文件写入到输出目录。</li> <li><strong>触发 <code class="language-plaintext highlighter-rouge">afterEmit</code> 钩子</strong>：写入文件后触发 <code class="language-plaintext highlighter-rouge">afterEmit</code> 钩子，通知插件输出过程已完成。</li> </ol> <p>生成输出阶段的主要钩子如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">emit</code>：生成资源到输出目录前。</li> <li><code class="language-plaintext highlighter-rouge">afterEmit</code>：生成资源到输出目录后。</li> </ul> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 的构建流程，主要包括初始化、编译、打包、优化和生成输出五个阶段。]]></summary></entry><entry><title type="html">webpack 常用配置项</title><link href="https://feng-zhang0712.github.io//blog/2024/concepts/" rel="alternate" type="text/html" title="webpack 常用配置项"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/concepts</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/concepts/"><![CDATA[<p>webpack 是一个静态模块（比如各种资源文件）打包工具。webpack 会从一个或多个入口点构建依赖图(dependency graph)，然后将项目中所需的每个模块组合成一个或多个 bundles。</p> <h3 id="11-module">1.1 Module</h3> <p>Module（模块） 是 webpack 构建系统的基本单位。在 webpack 中，几乎所有的文件都被视为模块，包括 JavaScript、CSS、HTML、图片、字体等。模块是代码的最小单元，通过导入和导出实现代码的复用和分离。</p> <p>模块封装了特定功能，独立于其他模块。模块之间可以相互依赖，通过 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 引入其他模块。不仅限于 JavaScript 文件，任何资源文件都可以作为模块。</p> <h3 id="12-chunk">1.2 Chunk</h3> <p>Chunk（代码块） 是 webpack 在打包过程中生成的中间产物。每个 Chunk 包含一组紧密相关的模块。最终，一个或多个 Chunk 会被合并成一个 Bundle。</p> <p>Chunk 是 webpack 在打包过程中动态生成的。它使得代码拆分成为可能，可以根据不同的策略（如按需加载）生成多个 Chunk。Chunk 可以通过懒加载或动态导入的方式按需加载，以优化应用的加载性能。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/index.js</span>
<span class="k">import</span><span class="p">(</span><span class="cm">/* webpackChunkName: "moduleA" */</span> <span class="dl">'</span><span class="s1">./moduleA</span><span class="dl">'</span><span class="p">).</span><span class="nf">then</span><span class="p">(({</span> <span class="nx">greeting</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">greeting</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <h3 id="13-bundle">1.3 Bundle</h3> <p>Bundle（包） 是 webpack 打包后的输出文件，它包含了应用程序的所有模块代码。Bundle 是浏览器可以执行的最终文件，通常是一个或多个 JavaScript 文件。</p> <p>Bundle 是 webpack 打包的最终结果。在小型项目中，所有模块可能会被打包成一个单一的 Bundle 文件。在大型项目中，可以使用代码拆分（code splitting）将模块打包成多个 Bundle 文件，以优化加载性能。</p> <h3 id="14-webpack-中的占位符">1.4 webpack 中的占位符</h3> <ol> <li><strong><code class="language-plaintext highlighter-rouge">[name]</code></strong>：表示模块的名称。通常用于多入口配置中，根据入口名称生成文件名。</li> <li><strong><code class="language-plaintext highlighter-rouge">[id]</code></strong>：表示模块的 ID。用于生成文件名中的模块 ID，适用于需要唯一标识模块的场景。</li> <li><strong><code class="language-plaintext highlighter-rouge">[hash]</code></strong>：表示编译时的哈希值。常用于生成具有唯一性的文件名，防止缓存问题。</li> <li><strong><code class="language-plaintext highlighter-rouge">[chunkhash]</code></strong>：表示代码块的哈希值。用于根据代码块内容生成哈希值，适用于代码分割和缓存优化。</li> <li><strong><code class="language-plaintext highlighter-rouge">[contenthash]</code></strong>：表示文件内容的哈希值。适用于根据文件内容生成哈希值，通常用于生成 CSS 文件名。</li> <li><strong><code class="language-plaintext highlighter-rouge">[ext]</code></strong>：表示文件的扩展名。用于保持文件的原始扩展名，适用于文件处理和加载。</li> <li><strong><code class="language-plaintext highlighter-rouge">[path]</code></strong>：表示包含文件的路径。用于生成包含文件路径的文件名，适用于文件管理和组织。</li> <li><strong><code class="language-plaintext highlighter-rouge">[query]</code></strong>：表示文件请求中的查询字符串。用于生成包含查询字符串的文件名，适用于动态加载和参数传递。</li> </ol> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 是一个静态模块（比如各种资源文件）打包工具。webpack 会从一个或多个入口点构建依赖图(dependency graph)，然后将项目中所需的每个模块组合成一个或多个 bundles。]]></summary></entry><entry><title type="html">webpack 常用配置项</title><link href="https://feng-zhang0712.github.io//blog/2024/configuration/" rel="alternate" type="text/html" title="webpack 常用配置项"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/configuration</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/configuration/"><![CDATA[<h3 id="21-entry">2.1 Entry</h3> <p><code class="language-plaintext highlighter-rouge">entry</code> 指定 webpack 构建的入口。webpack 会从入口文件开始构建依赖图。在书写形式上，分为单入口、多入口和数组入口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 单入口文件写法</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/index.js</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 多个入口文件写法，它们将分别生成各自的打包文件</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">app</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/app.js</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">admin</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/admin.js</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 数组入口文件写法，表示多个入口文件将被打包到一个文件中</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">./src/index.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">./src/vendor.js</span><span class="dl">'</span><span class="p">],</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="22-output">2.2 Output</h3> <p><code class="language-plaintext highlighter-rouge">output</code> 指定打包文件的输出位置和文件名。</p> <h3 id="23-module">2.3 Module</h3> <p><code class="language-plaintext highlighter-rouge">module</code> 定义处理不同类型文件模块的规则。即如何处理除 <code class="language-plaintext highlighter-rouge">.js</code> 文件以外的其他资源，例如 CSS、图片、字体等。<code class="language-plaintext highlighter-rouge">module</code> 配置项主要包含 <code class="language-plaintext highlighter-rouge">rules</code> 和 <code class="language-plaintext highlighter-rouge">noParse</code> 两个属性。</p> <h4 id="1-modulerules">(1) <code class="language-plaintext highlighter-rouge">module.rules</code></h4> <p><code class="language-plaintext highlighter-rouge">module.rules</code> 属性是 <code class="language-plaintext highlighter-rouge">module</code> 配置项的核心部分，它是一个数组，每个元素都是一个规则对象，用于定义如何使用 Loader 加载和转换不同类型的模块。<code class="language-plaintext highlighter-rouge">module.rules</code> 对象的主要属性如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">test</code>：一个正则表达式，用于匹配文件路径。</li> <li><code class="language-plaintext highlighter-rouge">exclude</code>：排除的文件路径，通常用于排除 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录。</li> <li><code class="language-plaintext highlighter-rouge">include</code>：包含的文件路径，通常用于指定处理哪些目录下的文件。</li> <li><code class="language-plaintext highlighter-rouge">use</code>：指定使用的加载器（详细方式），可以是单个加载器或加载器数组。</li> <li><code class="language-plaintext highlighter-rouge">loader</code>：指定使用的加载器（简写方式）。</li> <li><code class="language-plaintext highlighter-rouge">options</code>：加载器的选项参数。</li> <li><code class="language-plaintext highlighter-rouge">type</code>：指定模块的类型，例如 <code class="language-plaintext highlighter-rouge">json</code> 等。</li> </ul> <p>以下是一个 <code class="language-plaintext highlighter-rouge">module.rules</code> 配置项的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">png|jpg|gif</span><span class="se">)</span><span class="sr">$/</span><span class="p">,</span> <span class="c1">// 匹配图片文件</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 保持文件名和扩展名</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">images/</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 输出路径</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">woff|woff2|eot|ttf|otf</span><span class="se">)</span><span class="sr">$/</span><span class="p">,</span> <span class="c1">// 匹配字体文件</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 保持文件名和扩展名</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">fonts/</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 输出路径</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>Loader 本质上是一个函数，主要用于在 webpack 构建过程中，将不同类型的文件转换为模块。Loader 可以处理 JavaScript 以外的资源文件，例如 CSS、SCSS、TypeScript、图片等。它们允许你在 <code class="language-plaintext highlighter-rouge">import</code> 或 <code class="language-plaintext highlighter-rouge">require</code> 模块时预处理文件。以下是一些 webpack 中常见的 Loader。</p> <ul> <li><code class="language-plaintext highlighter-rouge">babel-loader</code>：用于将最新的 ES 语法转换为浏览器是别的 JavaScript。</li> <li><code class="language-plaintext highlighter-rouge">style-loader</code>：将 css 添加到样式标签 <code class="language-plaintext highlighter-rouge">style</code> 中。</li> <li><code class="language-plaintext highlighter-rouge">css-loader</code>：允许将 css 文件通过 require 的方式引入，并返回 css 代码。</li> <li><code class="language-plaintext highlighter-rouge">sass-loader:</code>：处理 sass 文件。</li> <li><code class="language-plaintext highlighter-rouge">postcss-loader</code>：用 postcss 来处理 CSS。</li> <li><code class="language-plaintext highlighter-rouge">file-loader</code>：分发文件到 output 目录并返回相对路径。</li> <li><code class="language-plaintext highlighter-rouge">url-loader</code>：和 <code class="language-plaintext highlighter-rouge">file-loader</code> 类似，可以选择性的把图片转成 base64 格式的字符串，并打包到 js 中，比较合适对小图片的处理。</li> <li><code class="language-plaintext highlighter-rouge">html-minify-loader</code>：压缩 HTML。</li> </ul> <p>注意，大部分 Loader 在使用之前要先下载。</p> <h4 id="2modulenoparse">（2）<code class="language-plaintext highlighter-rouge">module.noParse</code></h4> <p><code class="language-plaintext highlighter-rouge">module.noParse</code> 用于配置哪些模块文件不需要解析。通过 <code class="language-plaintext highlighter-rouge">noParse</code>，可以跳过对大型库或文件的解析。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">noParse</span><span class="p">:</span> <span class="sr">/jquery|lodash/</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，告诉 webpack 在进行代码解析式，不解析 <code class="language-plaintext highlighter-rouge">jquery</code> 和 <code class="language-plaintext highlighter-rouge">lodash</code> 库。</p> <h3 id="24-plugins">2.4 Plugins</h3> <p>Plugin 用于扩展 webpack 的功能。它们可以在整个编译生命周期的不同阶段执行更广泛的任务，如 <strong>打包优化</strong>、<strong>环境变量注入</strong>、<strong>代码压缩</strong> 等。Plugin 可以比 Loader 处理更加复杂和多样化的任务。</p> <p>Plugin 是具有 <code class="language-plaintext highlighter-rouge">apply</code> 方法的 JavaScript 对象。这个 <code class="language-plaintext highlighter-rouge">apply</code> 方法在 webpack 启动时被调用，并且插件可以通过 webpack 的钩子机制（hooks）在编译过程的各个阶段插入自己的逻辑。</p> <p>以下是一些 webpack 中常见的 Plugin。</p> <ul> <li><code class="language-plaintext highlighter-rouge">DefinePlugin</code>：允许在编译时创建配置的全局对象，它是一个 webpack 内置的插件，不需要安装。</li> <li><code class="language-plaintext highlighter-rouge">html-webpack-plugin</code>：用于简化 HTML 文件的创建、管理以及注入打包后的 JavaScript 文件。</li> <li><code class="language-plaintext highlighter-rouge">mini-css-extract-plugin</code>：将 CSS 从 JavaScript 中提取出来，生成独立的 CSS 文件。</li> <li><code class="language-plaintext highlighter-rouge">css-minimizer-webpack-plugin</code></li> <li><code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code></li> </ul> <h3 id="25-mode">2.5 Mode</h3> <p><code class="language-plaintext highlighter-rouge">mode</code> 用于设置构建模式，影响 webpack 内置的优化功能。webpack 提供了三种模式。</p> <ul> <li><code class="language-plaintext highlighter-rouge">development</code>：用于开发环境。在这个模式下， 主要侧重于提升构建速度和开发体验。在此模式下， webpack 不会压缩代码，并且会启用 Source Map、HMR（热模块替换）和详细的日志。</li> <li><code class="language-plaintext highlighter-rouge">production</code>：用于生产环境。在这个模式下， 主要侧重于优化代码体积和运行性能。在此模式下， webpack 会启用代码压缩和混淆、自动移除未使用的代码（Tree Shaking）和启用各种优化（如代码拆分、作用域提升）等。</li> <li><code class="language-plaintext highlighter-rouge">none</code>：不应用任何默认优化或配置。在这个模式下，只会按照配置文件中的指示进行打包，而不进行额外的优化和处理。</li> </ul> <h3 id="26-resolve">2.6 Resolve</h3> <p><code class="language-plaintext highlighter-rouge">resolve</code> 控制模块解析的行为。包括定义模块路径的查找方式、文件扩展名的解析顺序、别名等。<code class="language-plaintext highlighter-rouge">resolve</code> 的主要配置项如下。</p> <h4 id="1resolvealias">（1）<code class="language-plaintext highlighter-rouge">resolve.alias</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.alias</code> 用于为模块路径创建别名。通过别名，可以简化模块引用的路径。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">alias</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">@components</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/components/</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">import</span> <span class="nx">Button</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@components/Button</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p>上面的代码中，我们为 <code class="language-plaintext highlighter-rouge">src/components/</code> 目录指定了一个别名 <code class="language-plaintext highlighter-rouge">@components</code>，这样在导入模块时，就可以使用 <code class="language-plaintext highlighter-rouge">import xxx from '@components/xxx'</code> 的形式，而不必每次都写前边的路径。</p> <h4 id="2resolveextensions">（2）<code class="language-plaintext highlighter-rouge">resolve.extensions</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.extensions</code> 定义在解析模块时可以省略的文件扩展名。默认值是 <code class="language-plaintext highlighter-rouge">['.js', '.json']</code>。</p> <h4 id="3resolvemodules">（3）<code class="language-plaintext highlighter-rouge">resolve.modules</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.modules</code> 指定解析模块时要搜索的目录。默认值是 [‘node_modules’]。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">modules</span><span class="p">:</span> <span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">import</span> <span class="nx">Util</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">utils/util</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 实际引入的是 'src/utils/util.js'</span>
</code></pre></div></div> <p>上面的代码，我们指定了 <code class="language-plaintext highlighter-rouge">resolve.modules</code> 的目录为 <code class="language-plaintext highlighter-rouge">src</code> 和 <code class="language-plaintext highlighter-rouge">node_modules</code>。这样，在导入模块时，webpack 会首先去 <code class="language-plaintext highlighter-rouge">src</code> 目录下寻找，如果找不到，就去 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录下寻找。</p> <h4 id="4resolvefallback">（4）<code class="language-plaintext highlighter-rouge">resolve.fallback</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.fallback</code> 指定当模块在指定目录中找不到时，应该回退到哪个目录进行查找。常用于处理某些模块在特定环境下的缺失问题。</p> <h4 id="5resolveplugins">（5）<code class="language-plaintext highlighter-rouge">resolve.plugins</code></h4> <p><code class="language-plaintext highlighter-rouge">resolve.plugins</code> 用于配置一些自定义的解析插件。可以定义自己的解析规则或使用现成的解析插件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">alias</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">@components</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/components/</span><span class="dl">'</span><span class="p">),</span>
      <span class="dl">'</span><span class="s1">@utils</span><span class="dl">'</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src/utils/</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
    <span class="na">extensions</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.jsx</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.json</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.ts</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">.tsx</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">modules</span><span class="p">:</span> <span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">src</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">fallback</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">:</span> <span class="nx">require</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">path-browserify</span><span class="dl">'</span><span class="p">),</span>
      <span class="dl">'</span><span class="s1">crypto</span><span class="dl">'</span><span class="p">:</span> <span class="nx">require</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">crypto-browserify</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">},</span>
     <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
      <span class="c1">// 在此添加解析插件</span>
    <span class="p">],</span>

    <span class="c1">// 其他配置...</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="27-devtool">2.7 Devtool</h3> <p><code class="language-plaintext highlighter-rouge">devtool</code> 用于控制生成 source map 的方式。source map 用于将编译后的代码映射回源代码，有助于调试和错误追踪。常见的 <code class="language-plaintext highlighter-rouge">devtool</code> 配置有如下几个。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">cheap-module-source-map</code></strong>：类似于 cheap-source-map，对 loader 处理后的代码也生成 source map。优点是构建速度较快，适合调试经过 loader 处理的代码。缺点是调试时无法准确定位到列，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">source-map</code></strong>：生成独立的 <code class="language-plaintext highlighter-rouge">.map</code> 文件，提供完整的 source map。优点是可以查看源文件及其位置。缺点是构建速度慢，适合生产环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">eval</code></strong>：使用 <code class="language-plaintext highlighter-rouge">eval</code> 生成每个模块的 source map。优点是构建速度最快，缺点是生成的 source map 不支持断点调试，适合快速开发和调试。</li> <li><strong><code class="language-plaintext highlighter-rouge">inline-source-map</code></strong>：将 source map 作为 Data URL 内嵌在编译后的代码中。优点是调试体验好，构建速度较快。缺点是会增加文件体积，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">cheap-source-map</code></strong>：生成独立的 source map 文件，但不包含列信息。优点是构建速度较快，适合开发环境。缺点是调试时无法准确定位到列，适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">eval-source-map</code></strong>：每个模块使用 eval 生成 source map，并将 source map 作为 Data URL 内嵌。优点是构建速度快，调试体验好。适合开发环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">hidden-source-map</code></strong>：生成独立的 source map 文件，但不在编译后的代码中引用。优点是保护源代码，但仍然可以使用 source map 进行调试。缺点是需要手动关联 source map 文件，适合生产环境。</li> <li><strong><code class="language-plaintext highlighter-rouge">nosources-source-map</code></strong>：生成独立的 source map 文件，但隐藏源文件内容。优点是保护源代码内容，但提供错误信息的映射。缺点是不能查看源代码，适合生产环境。</li> </ul> <p>多数情况下，在开发中主要使用 <code class="language-plaintext highlighter-rouge">cheap-module-source-map</code>；而在生产环境中，主要使用 <code class="language-plaintext highlighter-rouge">source-map</code>。</p> <h3 id="28-devserver">2.8 DevServer</h3> <p><code class="language-plaintext highlighter-rouge">devServer</code> 用于配置开发服务器。即设置开发环境中的本地服务器，以便进行实时预览、热模块替换（HMR）、代理请求等操作。<code class="language-plaintext highlighter-rouge">devServer</code> 常见的配置项如下。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">contentBase</code></strong>：指定开发服务器的根目录，即服务器将从哪个目录提供文件。</li> <li><strong><code class="language-plaintext highlighter-rouge">https</code></strong>：是否启用 HTTPS 协议。</li> <li><strong><code class="language-plaintext highlighter-rouge">host</code></strong>：指定开发服务器的主机名。</li> <li><strong><code class="language-plaintext highlighter-rouge">port</code></strong>：指定开发服务器的端口号。</li> <li><strong><code class="language-plaintext highlighter-rouge">open</code></strong>：是否自动打开浏览器。</li> <li><strong><code class="language-plaintext highlighter-rouge">hot</code></strong>：是否启用模块热替换（HMR）。</li> <li><strong><code class="language-plaintext highlighter-rouge">proxy</code></strong>：配置代理，将特定请求转发到其他服务器。</li> <li><strong><code class="language-plaintext highlighter-rouge">compress</code></strong>：是否启用 gzip 压缩。</li> <li><strong><code class="language-plaintext highlighter-rouge">before</code></strong> 和 <strong><code class="language-plaintext highlighter-rouge">after</code></strong>：在开发服务器启动之前或之后执行特定的中间件函数。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">devServer</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">contentBase</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">dist</span><span class="dl">'</span><span class="p">),</span> <span class="c1">// 指定根目录</span>
    <span class="na">https</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">// 使用 HTTP 协议</span>
    <span class="na">host</span><span class="p">:</span> <span class="dl">'</span><span class="s1">0.0.0.0</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 指定主机名</span>
    <span class="na">port</span><span class="p">:</span> <span class="mi">3000</span><span class="p">,</span> <span class="c1">// 指定端口号</span>
    <span class="na">open</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 自动打开浏览器</span>
    <span class="na">hot</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用模块热替换</span>
    <span class="na">proxy</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">/api</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">target</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http://localhost:3000</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">changeOrigin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">},</span>
    <span class="na">compress</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用 gzip 压缩</span>
    <span class="na">before</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">server</span><span class="p">,</span> <span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/some/path</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">({</span> <span class="na">custom</span><span class="p">:</span> <span class="dl">'</span><span class="s1">response</span><span class="dl">'</span> <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">},</span>
    <span class="na">after</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">server</span><span class="p">,</span> <span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Dev server is running!</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="c1">// 其他配置项...</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="29-optimization">2.9 Optimization</h3> <p><code class="language-plaintext highlighter-rouge">optimization</code> 控制构建过程中的优化行为。以下是常见的 <code class="language-plaintext highlighter-rouge">optimization</code> 配置项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">splitChunks</code></strong>：用于将代码拆分成更小的块，以实现代码的按需加载和更好的缓存策略。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimize</code></strong>：是否启用代码压缩。一般在生产环境中使用。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimizer</code></strong>：自定义代码压缩工具和压缩选项。默认使用 TerserPlugin 进行 JavaScript 代码压缩。</li> <li><strong><code class="language-plaintext highlighter-rouge">providedExports</code></strong>：用于告诉 webpack 是否分析每个模块提供的导出内容。默认值为 true。</li> <li><strong><code class="language-plaintext highlighter-rouge">usedExports</code></strong>：用于启用 Tree Shaking，去除未使用的导出。默认值为 true。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TerserPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">terser-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">splitChunks</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 对所有类型的代码进行分离</span>
    <span class="p">},</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用代码压缩</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span><span class="k">new</span> <span class="nc">TerserPlugin</span><span class="p">({</span>
      <span class="na">terserOptions</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">compress</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">drop_console</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除 console 语句</span>
        <span class="p">},</span>
      <span class="p">},</span>
    <span class="p">})],</span>
    <span class="na">runtimeChunk</span><span class="p">:</span> <span class="dl">'</span><span class="s1">single</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 提取运行时代码到单独的 chunk</span>
    <span class="na">moduleIds</span><span class="p">:</span> <span class="dl">'</span><span class="s1">deterministic</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 使用确定性的模块 ID</span>
    <span class="na">chunkIds</span><span class="p">:</span> <span class="dl">'</span><span class="s1">deterministic</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 使用确定性的 chunk ID</span>
    <span class="na">mangleWasmImports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 压缩 WebAssembly 导入名称</span>
    <span class="na">removeAvailableModules</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除可用的模块</span>
    <span class="na">removeEmptyChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 移除空的 chunk</span>
    <span class="na">mergeDuplicateChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 合并重复的 chunk</span>
    <span class="na">flagIncludedChunks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 标记包含的 chunk</span>
    <span class="na">providedExports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">usedExports</span><span class="p">:</span> <span class="kc">true</span>
    <span class="na">sideEffects</span><span class="p">:</span> <span class="kc">true</span>
    <span class="na">nodeEnv</span><span class="p">:</span> <span class="dl">'</span><span class="s1">production</span><span class="dl">'</span>
    <span class="na">realContentHash</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[2.1 Entry]]></summary></entry><entry><title type="html">webpack 项目优化</title><link href="https://feng-zhang0712.github.io//blog/2024/optimization/" rel="alternate" type="text/html" title="webpack 项目优化"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/optimization</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/optimization/"><![CDATA[<h3 id="61-启用代码压缩">6.1 启用代码压缩</h3> <h4 id="1压缩-html-代码">（1）压缩 HTML 代码</h4> <p><code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 用于简化 HTML 文件的创建、管理以及注入打包后的 JavaScript 文件。下面列出了一些 <code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 常用的配置项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">title</code></strong>：页面的标题，会被插入到 <code class="language-plaintext highlighter-rouge">&lt;title&gt;</code> 标签中。</li> <li><strong><code class="language-plaintext highlighter-rouge">filename</code></strong>：生成的 HTML 文件的名称，默认是 <code class="language-plaintext highlighter-rouge">index.html</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">template</code></strong>：指定模板文件的路径。</li> <li><strong><code class="language-plaintext highlighter-rouge">inject</code></strong>：注入选项，默认为 <code class="language-plaintext highlighter-rouge">true</code>，表示将打包的资源注入到生成的 HTML 文件中。它可以是 <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code>、<code class="language-plaintext highlighter-rouge">'head'</code> 或者 <code class="language-plaintext highlighter-rouge">'body'</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">favicon</code></strong>：指定 favicon 文件的路径。</li> <li><strong><code class="language-plaintext highlighter-rouge">meta</code></strong>：注入页面的 <code class="language-plaintext highlighter-rouge">meta</code> 标签，可以是一个对象。</li> <li><strong><code class="language-plaintext highlighter-rouge">hash</code></strong>：如果为 <code class="language-plaintext highlighter-rouge">true</code>，则会在所有的资源文件后面加一个唯一的 hash，防止缓存。</li> <li><strong><code class="language-plaintext highlighter-rouge">minify</code></strong>：用于控制生成的 HTML 文件的代码压缩。这个属性接受一个对象，内含多个配置选项，分别控制不同的压缩行为。</li> </ul> <p>通过配置 <code class="language-plaintext highlighter-rouge">html-webpack-plugin</code> 的 <code class="language-plaintext highlighter-rouge">minify</code> 属性来压缩 HTML 代码。以下是 <code class="language-plaintext highlighter-rouge">minify</code> 属性的常用选项。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">collapseWhitespace</code></strong>：压缩 HTML 中的空白。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeComments</code></strong>：移除 HTML 中的注释。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeRedundantAttributes</code></strong>：移除多余的属性（如 <code class="language-plaintext highlighter-rouge">&lt;input type="text"&gt;</code> 中的 <code class="language-plaintext highlighter-rouge">type="text"</code>）。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeScriptTypeAttributes</code></strong>：移除 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签中的 <code class="language-plaintext highlighter-rouge">type="text/javascript"</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">removeStyleLinkTypeAttributes</code></strong>：移除 <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;style&gt;</code> 标签中的 <code class="language-plaintext highlighter-rouge">type="text/css"</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">useShortDoctype</code></strong>：将文档类型简化为 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">minifyCSS</code></strong>：压缩内联的 CSS。</li> <li><strong><code class="language-plaintext highlighter-rouge">minifyJS</code></strong>：压缩内联的 JavaScript。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HtmlWebpackPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">html-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nc">HtmlWebpackPlugin</span><span class="p">({</span>
      <span class="na">template</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/index.html</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">minify</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">collapseWhitespace</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeComments</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeRedundantAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeScriptTypeAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">removeStyleLinkTypeAttributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">useShortDoctype</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minifyCSS</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minifyJS</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">]</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="2压缩-css-代码">（2）压缩 CSS 代码</h4> <p><code class="language-plaintext highlighter-rouge">css-minimizer-webpack-plugin</code> 是一个用于压缩 CSS 代码的 Webpack 插件，它基于 cssnano 提供的优化功能，能够有效地减少 CSS 文件的体积，从而提升加载性能。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">test</code></strong>：匹配需要压缩的文件，默认值是 <code class="language-plaintext highlighter-rouge">/\.css$/i</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">parallel</code></strong>：启用并行压缩以提升构建速度，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">minimizerOptions</code></strong>：传递给 cssnano 的配置选项。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">CssMinimizerPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">css-minimizer-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">`...`</span><span class="p">,</span>
      <span class="k">new</span> <span class="nc">CssMinimizerPlugin</span><span class="p">({</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.</span><span class="sr">css$/i</span><span class="p">,</span>
        <span class="na">parallel</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">minimizerOptions</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">preset</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">'</span><span class="s1">default</span><span class="dl">'</span><span class="p">,</span>
            <span class="p">{</span>
              <span class="na">discardComments</span><span class="p">:</span> <span class="p">{</span> <span class="na">removeAll</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span> <span class="c1">// 移除所有注释</span>
            <span class="p">},</span>
          <span class="p">],</span>
        <span class="p">},</span>
      <span class="p">}),</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="3压缩-javascript-代码">（3）压缩 JavaScript 代码</h4> <p><code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code> 用于压缩和优化 JavaScript 代码。它基于 Terser，一个 JavaScript 解析器、压缩器、美化器和 AST 工具包。<code class="language-plaintext highlighter-rouge">terser-webpack-plugin</code> 是 Webpack 内置的 JavaScript 压缩插件，在生产环境下默认使用，可以通过自定义配置优化其行为。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">test</code></strong>：匹配需要压缩的文件，默认值是 <code class="language-plaintext highlighter-rouge">/\.m?js(\?.*)?$/i</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">parallel</code></strong>：启用并行压缩以提升构建速度，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">extractComments</code></strong>：提取注释到单独的文件中，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><strong><code class="language-plaintext highlighter-rouge">terserOptions</code></strong>：传递给 Terser 的配置选项，详细配置见 Terser Options。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">TerserPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">terser-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">minimizer</span><span class="p">:</span> <span class="p">[</span>
      <span class="k">new</span> <span class="nc">TerserPlugin</span><span class="p">({</span>
        <span class="na">parallel</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">extractComments</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">terserOptions</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">compress</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">drop_console</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="p">},</span>
          <span class="na">format</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">comments</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="p">},</span>
        <span class="p">},</span>
      <span class="p">}),</span>
    <span class="p">],</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="62-图片压缩">6.2 图片压缩</h3> <p><code class="language-plaintext highlighter-rouge">file-loader</code> 的主要作用是将文件导出到输出目录，并返回文件的 URL。它可以处理各种类型的文件，包括图片、字体、音频、视频等。以下是几个常用的 <code class="language-plaintext highlighter-rouge">file-loader</code> 配置项。</p> <ul> <li><code class="language-plaintext highlighter-rouge">name</code>：设置文件的命名格式，可以使用占位符（如 <code class="language-plaintext highlighter-rouge">[name]</code>、<code class="language-plaintext highlighter-rouge">[ext]</code>、<code class="language-plaintext highlighter-rouge">[hash]</code> 等）。</li> <li><code class="language-plaintext highlighter-rouge">outputPath</code>：设置文件输出目录，可以是相对于输出路径的相对路径。</li> <li><code class="language-plaintext highlighter-rouge">publicPath</code>：设置文件的公共路径（通常用于 CDN）。</li> <li><code class="language-plaintext highlighter-rouge">emitFile</code>：是否输出文件，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</li> </ul> <p><code class="language-plaintext highlighter-rouge">image-webpack-loader</code> 是一个图片压缩加载器，可以结合 <code class="language-plaintext highlighter-rouge">file-loader</code> 使用，处理后的图片会自动进行压缩优化，从而减少文件体积，提高加载性能。以下是几个常用的 <code class="language-plaintext highlighter-rouge">image-webpack-loader</code> 配置项。</p> <ul> <li><code class="language-plaintext highlighter-rouge">mozjpeg</code>：配置 <code class="language-plaintext highlighter-rouge">mozjpeg</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">progressive</code>：是否开启渐进式 JPEG。</li> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量，范围是 0-100。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">optipng</code>：配置 <code class="language-plaintext highlighter-rouge">optipng</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">enabled</code>：是否开启 <code class="language-plaintext highlighter-rouge">optipng</code> 压缩。</li> <li><code class="language-plaintext highlighter-rouge">optimizationLevel</code>：优化级别，范围是 0-7。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">pngquant</code>：配置 <code class="language-plaintext highlighter-rouge">pngquant</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量范围，如 [0.65, 0.90]。</li> <li><code class="language-plaintext highlighter-rouge">speed</code>：压缩速度，范围是 1-11。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">gifsicle</code>：配置 <code class="language-plaintext highlighter-rouge">gifsicle</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">interlaced</code>：是否开启交错模式。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">webp</code>：配置 <code class="language-plaintext highlighter-rouge">webp</code> 压缩工具的选项。 <ul> <li><code class="language-plaintext highlighter-rouge">quality</code>：图像质量，范围是 0-100。</li> </ul> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HtmlWebpackPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">html-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.(</span><span class="sr">png|jpe</span><span class="se">?</span><span class="sr">g|gif|svg</span><span class="se">)</span><span class="sr">$/i</span><span class="p">,</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">file-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].[hash].[ext]</span><span class="dl">'</span><span class="p">,</span>
              <span class="na">outputPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">images/</span><span class="dl">'</span><span class="p">,</span>
            <span class="p">},</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="na">loader</span><span class="p">:</span> <span class="dl">'</span><span class="s1">image-webpack-loader</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">mozjpeg</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">progressive</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
                <span class="na">quality</span><span class="p">:</span> <span class="mi">65</span><span class="p">,</span>
              <span class="p">},</span>
              <span class="na">optipng</span><span class="p">:</span> <span class="p">{</span> <span class="na">enabled</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span>
              <span class="na">pngquant</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">quality</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.90</span><span class="p">],</span>
                <span class="na">speed</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
              <span class="p">},</span>
              <span class="na">gifsicle</span><span class="p">:</span> <span class="p">{</span> <span class="na">interlaced</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
              <span class="na">webp</span><span class="p">:</span> <span class="p">{</span> <span class="na">quality</span><span class="p">:</span> <span class="mi">75</span> <span class="p">},</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="63-tree-shaking">6.3 Tree Shaking</h3> <p>Tree Shaking 通过在编译时分析模块的依赖关系，移除那些没有被引用的代码，从而减少最终打包文件的体积。为了启用 Tree Shaking，需要使用 ES6 模块语法（import/export）并配置 optimization。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">usedExports</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 启用 Tree Shaking</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="64-代码分离code-splitting">6.4 代码分离（Code Splitting）</h3> <p>将代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件。默认情况下，所有的 JavaScript 代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度。代码分离可以分出出更小的 bundle，以及控制资源加载优先级，提供代码的加载性能。</p> <p>SplitChunksPlugin 是 Webpack 提供的一个内置插件，可以用于实现代码分离（code splitting）。SplitChunksPlugin 的常用配置如下。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">chunks</code></strong>：可以是 <code class="language-plaintext highlighter-rouge">'all'</code>、<code class="language-plaintext highlighter-rouge">'async'</code> 或 <code class="language-plaintext highlighter-rouge">'initial'</code>。指定要分离的块类型。</li> <li><strong><code class="language-plaintext highlighter-rouge">minSize</code></strong>：生成块的最小大小（以字节为单位），默认值为 30000。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxSize</code></strong>：生成块的最大大小（以字节为单位），超过此大小会进一步分离。</li> <li><strong><code class="language-plaintext highlighter-rouge">minChunks</code></strong>：最少引用次数，文件被引用次数超过此值时才会被分离，默认值为 1。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxAsyncRequests</code></strong>：按需加载时的最大并行请求数，默认值为 6。</li> <li><strong><code class="language-plaintext highlighter-rouge">maxInitialRequests</code></strong>：入口点的最大并行请求数，默认值为 4。</li> <li><strong><code class="language-plaintext highlighter-rouge">automaticNameDelimiter</code></strong>：生成名称时的分隔符，默认值为 ~。</li> <li><strong><code class="language-plaintext highlighter-rouge">name</code></strong>：指定分离块的名称，可以是 <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code> 或者一个函数。</li> <li><strong><code class="language-plaintext highlighter-rouge">cacheGroups</code></strong>：指定缓存组，为不同的分离规则定义不同的缓存组。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">splitChunks</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">minSize</span><span class="p">:</span> <span class="mi">20000</span><span class="p">,</span>
      <span class="na">maxSize</span><span class="p">:</span> <span class="mi">70000</span><span class="p">,</span>
      <span class="na">minChunks</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">maxAsyncRequests</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
      <span class="na">maxInitialRequests</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="na">automaticNameDelimiter</span><span class="p">:</span> <span class="dl">'</span><span class="s1">~</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">cacheGroups</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">vendors</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">[\\/]</span><span class="sr">node_modules</span><span class="se">[\\/]</span><span class="sr">/</span><span class="p">,</span>
          <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">vendors</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="na">default</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">minChunks</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
          <span class="na">priority</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
          <span class="na">reuseExistingChunk</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="p">},</span>
      <span class="p">},</span>
    <span class="p">},</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，我们定义了两个缓存组。<code class="language-plaintext highlighter-rouge">vendors</code> 缓存组用来将所有来自 <code class="language-plaintext highlighter-rouge">node_modules</code> 目录的模块分离到一个名为 <code class="language-plaintext highlighter-rouge">vendors</code> 的块中。<code class="language-plaintext highlighter-rouge">default</code> 缓存组用来将被至少两次引用的模块分离到一个默认块中，并且优先级较低。</p> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[6.1 启用代码压缩]]></summary></entry><entry><title type="html">webpack 的发布-订阅模式</title><link href="https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model/" rel="alternate" type="text/html" title="webpack 的发布-订阅模式"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/publish-subscribe-model/"><![CDATA[<h3 id="31-什么是发布-订阅模式">3.1 什么是发布-订阅模式？</h3> <p><strong>发布-订阅模式</strong> 是一种设计模式，其中一个主体（发布者）维护一系列依赖其状态的观察者（订阅者）。发布者在状态变化时向观察者发送通知，而观察者可以选择性地对这些通知做出响应。</p> <p>webpack 的插件系统基于发布-订阅模式。这个模式允许 webpack 在构建过程的不同阶段广播事件，插件可以订阅这些事件并在适当的时机执行特定的任务。</p> <p>在 webpack 中，发布者是 webpack 本身，它在构建过程的不同阶段广播事件。订阅者是 webpack 插件，它们订阅感兴趣的事件并在这些事件触发时执行特定逻辑。</p> <h3 id="32-webpack-生命周期广播事件">3.2 webpack 生命周期广播事件</h3> <p>webpack 在其构建生命周期的不同阶段会广播一系列事件。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">initialize</code></strong>：初始化阶段，webpack 构建过程开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">environment</code></strong>：设置环境变量。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterEnvironment</code></strong>：环境变量设置完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">entryOption</code></strong>：处理入口选项。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterPlugins</code></strong>：插件初始化完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterResolvers</code></strong>：解析器初始化完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">beforeRun</code></strong>：构建过程开始前。</li> <li><strong><code class="language-plaintext highlighter-rouge">run</code></strong>：构建过程开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">beforeCompile</code></strong>：编译前准备阶段。</li> <li><strong><code class="language-plaintext highlighter-rouge">compile</code></strong>：编译阶段开始。</li> <li><strong><code class="language-plaintext highlighter-rouge">thisCompilation</code></strong>：新的 Compilation 创建前。</li> <li><strong><code class="language-plaintext highlighter-rouge">compilation</code></strong>：新的 Compilation 创建后。</li> <li><strong><code class="language-plaintext highlighter-rouge">make</code></strong>：从入口点开始构建模块。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterCompile</code></strong>：编译完成。</li> <li><strong><code class="language-plaintext highlighter-rouge">emit</code></strong>：生成资源到输出目录前。</li> <li><strong><code class="language-plaintext highlighter-rouge">afterEmit</code></strong>：生成资源到输出目录后。</li> <li><strong><code class="language-plaintext highlighter-rouge">done</code></strong>：构建过程完成。</li> </ul> <h3 id="33-插件如何与广播事件协调工作">3.3 插件如何与广播事件协调工作</h3> <p>webpack 插件通过订阅这些事件来协调工作。插件在注册时将其逻辑挂载到特定的事件上，当事件被触发时，插件的逻辑会自动执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyPlugin</span> <span class="p">{</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 插件的逻辑</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is my plugin!</span><span class="dl">'</span><span class="p">);</span>
      <span class="nf">callback</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">MyPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>上面代码是一个自定义的插件，其中：</p> <ul> <li><code class="language-plaintext highlighter-rouge">apply</code> 方法用于注册插件。</li> <li><code class="language-plaintext highlighter-rouge">compiler</code> 对象是 webpack 编译器实例，提供了绑定事件的钩子（hooks）。</li> <li><code class="language-plaintext highlighter-rouge">compiler.hooks.emit</code> 表示 <code class="language-plaintext highlighter-rouge">emit</code> 事件的钩子。<code class="language-plaintext highlighter-rouge">tapAsync</code> 方法用于异步钩子，注册一个回调函数，该函数将在 <code class="language-plaintext highlighter-rouge">emit</code> 事件被触发时执行。</li> </ul> <h3 id="34-webpack-插件与生命周期事件的工作流程">3.4 webpack 插件与生命周期事件的工作流程</h3> <ol> <li>插件注册：插件通过 <code class="language-plaintext highlighter-rouge">apply</code> 方法注册到 webpack 编译器。在 <code class="language-plaintext highlighter-rouge">apply</code> 方法中，插件通过 <code class="language-plaintext highlighter-rouge">compiler</code> 对象的钩子（hooks）订阅感兴趣的事件。</li> <li>事件触发：webpack 在构建过程的不同阶段触发事件。当事件被触发时，所有订阅了该事件的插件都将依次执行其注册的回调函数。</li> <li>回调执行：插件的回调函数执行其特定的逻辑。例如，修改编译资源、生成额外的文件、优化输出等。</li> </ol> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">class</span> <span class="nc">MyPlugin</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">options</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 生成一个额外的文件</span>
      <span class="kd">const</span> <span class="nx">content</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">This is a generated file</span><span class="dl">'</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">outputPath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nx">compiler</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">output</span><span class="p">.</span><span class="nx">path</span><span class="p">,</span> <span class="dl">'</span><span class="s1">generated-file.txt</span><span class="dl">'</span><span class="p">);</span>

      <span class="nx">compilation</span><span class="p">.</span><span class="nx">assets</span><span class="p">[</span><span class="dl">'</span><span class="s1">generated-file.txt</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">source</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">content</span><span class="p">,</span>
        <span class="na">size</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">content</span><span class="p">.</span><span class="nx">length</span>
      <span class="p">};</span>

      <span class="c1">// 写入文件到输出目录</span>
      <span class="nx">fs</span><span class="p">.</span><span class="nf">writeFile</span><span class="p">(</span><span class="nx">outputPath</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">The file has been saved!</span><span class="dl">'</span><span class="p">);</span>
        <span class="nf">callback</span><span class="p">();</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">MyPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>上面的代码，是一个自定义的插件，它会在 <code class="language-plaintext highlighter-rouge">emit</code> 阶段生成一个额外的文件。</p> <ul> <li>插件在 <code class="language-plaintext highlighter-rouge">emit</code> 阶段生成一个名为 <code class="language-plaintext highlighter-rouge">generated-file.txt</code> 的文件，并将其内容设置为 <code class="language-plaintext highlighter-rouge">"This is a generated file"</code>。</li> <li>通过 <code class="language-plaintext highlighter-rouge">compilation.assets</code> 将生成的文件添加到 webpack 的资源管理中。</li> <li>异步写入文件到输出目录，当写入完成后调用 <code class="language-plaintext highlighter-rouge">callback</code> 以通知 webpack 继续构建过程。</li> </ul> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[3.1 什么是发布-订阅模式？]]></summary></entry><entry><title type="html">webpack 中的 Loader</title><link href="https://feng-zhang0712.github.io//blog/2024/loader/" rel="alternate" type="text/html" title="webpack 中的 Loader"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/loader</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/loader/"><![CDATA[<p>loader 本质上是导出为函数的 JavaScript 模块。<a href="https://github.com/webpack/loader-runner">loader runner</a> 会调用此函数，然后将上一个 loader 产生的结果或者资源文件传入进去。函数中的 <code class="language-plaintext highlighter-rouge">this</code> 作为上下文会被 webpack 填充，并且 loader runner 中包含一些实用的方法，比如可以使 loader 调用方式变为异步，或者获取 <code class="language-plaintext highlighter-rouge">query</code> 参数。</p> <p>如果是单个处理结果，可以在 <a href="#1同步-loader">同步模式</a> 中直接返回。如果有多个处理结果，则必须调用 <code class="language-plaintext highlighter-rouge">this.callback()</code>。在 <a href="#2异步-loader">异步模式</a> 中，必须调用 <code class="language-plaintext highlighter-rouge">this.async()</code> 来告知 loader runner 等待异步结果，它会返回 <code class="language-plaintext highlighter-rouge">this.callback()</code> 回调函数。随后 loader 必须返回 <code class="language-plaintext highlighter-rouge">undefined</code> 并且调用该回调函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *
 * @param {string|Buffer} content 源文件的内容
 * @param {object} [map] 可以被 https://github.com/mozilla/source-map 使用的 SourceMap 数据
 * @param {any} [meta] meta 数据，可以是任何内容
 */</span>
<span class="kd">function</span> <span class="nf">webpackLoader</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>loader 分为几种不同的类型，他们是同步 Loader、异步 Loader、Raw Loader 和 Pitching Loader。</p> <h2 id="loader-分类">Loader 分类</h2> <h3 id="1同步-loader">（1）同步 Loader</h3> <p>通过 <code class="language-plaintext highlighter-rouge">return</code> 或者 <code class="language-plaintext highlighter-rouge">this.callback()</code> 同步地返回处理后的 <code class="language-plaintext highlighter-rouge">content</code> 值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">return</code> 返回处理之后的 <code class="language-plaintext highlighter-rouge">content</code>，然后交由 webpack 或者之后的 <code class="language-plaintext highlighter-rouge">loader</code> 继续处理。</p> <p>除了使用 <code class="language-plaintext highlighter-rouge">return</code> 关键词，还可以使用 <code class="language-plaintext highlighter-rouge">this.callback()</code>，后者的优点是更灵活，因为它允许传递多个参数，而不仅仅是 <code class="language-plaintext highlighter-rouge">content</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">),</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">);</span>

  <span class="c1">// 当调用 callback() 函数时，总是返回 undefined</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="2异步-loader">（2）异步 Loader</h3> <p>异步 loader 使用 <code class="language-plaintext highlighter-rouge">this.async()</code> 来获取 callback 函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="k">async</span><span class="p">();</span>
  <span class="nf">someAsyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nf">callback</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="3raw-loader">（3）Raw Loader</h3> <p>默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。通过设置 <code class="language-plaintext highlighter-rouge">raw</code> 为 <code class="language-plaintext highlighter-rouge">true</code>，loader 可以接收原始的 Buffer。每个 loader 都可以用 String 或者 Buffer 的形式传递它的处理结果。complier 会把它们在 loader 之间相互转换。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">assert</span><span class="p">(</span><span class="nx">content</span> <span class="k">instanceof</span> <span class="nx">Buffer</span><span class="p">);</span>

  <span class="c1">// 返回值也可以是一个 `Buffer`</span>
  <span class="c1">// 即使不是 "raw"，loader 也没问题</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">raw</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div> <h3 id="4pitching-loader">（4）Pitching Loader</h3> <p>loader <strong>总是</strong>从右到左被调用。有些情况下，loader 只关心 request 后面的<strong>元数据</strong>（metadata），并且忽略前一个 loader 的结果。在实际（从右到左）执行 loader 之前，会先<strong>从左到右</strong>调用 loader 上的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>假如我们有以下配置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">//...</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a-loader</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b-loader</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c-loader</span><span class="dl">'</span><span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的代码，会按照下面的顺序执行。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|- a-loader `pitch`
  |- b-loader `pitch`
    |- c-loader `pitch`
      |- requested module is picked up as a dependency
    |- c-loader normal execution
  |- b-loader normal execution
|- a-loader normal execution
</code></pre></div></div> <p>从上面代码可以看出，在同一组 loader 配置中，<code class="language-plaintext highlighter-rouge">pitch()</code> 方法会优先执行。loader 模块中引入 “pitching” 阶段，主要是基于以下两个原因。</p> <ol> <li> <p>传递给 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法的 <code class="language-plaintext highlighter-rouge">data</code>，在执行阶段也会暴露在 <code class="language-plaintext highlighter-rouge">this.data</code> 之下，并且可以用于在循环时，捕获并共享前面的信息。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
 <span class="p">};</span>

 <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">data</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
 <span class="p">};</span>
</code></pre></div> </div> </li> <li> <p>如果某个 loader 在 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法中给出一个结果，那么这个过程会回过身来，并跳过剩下的 loader。在我们上面的例子中，如果 <code class="language-plaintext highlighter-rouge">b-loader</code> 的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法返回了一些东西，<code class="language-plaintext highlighter-rouge">b-loader</code> 之后的 <code class="language-plaintext highlighter-rouge">pitch()</code> 方法以及所有的 loader 方法，都将不再执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nf">someSyncOperation</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
 <span class="p">};</span>

 <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">remainingRequest</span><span class="p">,</span> <span class="nx">precedingRequest</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if </span><span class="p">(</span><span class="nf">someCondition</span><span class="p">())</span> <span class="p">{</span>
     <span class="k">return </span><span class="p">(</span>
       <span class="dl">'</span><span class="s1">module.exports = require(</span><span class="dl">'</span> <span class="o">+</span>
       <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="dl">'</span><span class="s1">-!</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">remainingRequest</span><span class="p">)</span> <span class="o">+</span>
       <span class="dl">'</span><span class="s1">);</span><span class="dl">'</span>
     <span class="p">);</span>
   <span class="p">}</span>
 <span class="p">};</span>
</code></pre></div> </div> <p>上面的代码，将会按照下面的顺序执行。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> |- a-loader `pitch`
   |- b-loader `pitch` returns a module
 |- a-loader normal execution
</code></pre></div> </div> </li> </ol> <h2 id="loader-context">Loader Context</h2> <p>loader context 表示在 loader 内使用 <code class="language-plaintext highlighter-rouge">this</code> 可以访问的一些方法或属性。</p> <h3 id="thisasync">this.async()</h3> <p>用于告诉 loader-runner 这个 loader 将会异步地回调。返回 <code class="language-plaintext highlighter-rouge">this.callback()</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="k">async</span><span class="p">();</span>
</code></pre></div></div> <h3 id="thiscallback">this.callback()</h3> <p>用于同步或异步调用，并返回多个结果。预期的参数是：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nf">callback</span><span class="p">(</span>
  <span class="nx">err</span><span class="p">:</span> <span class="nb">Error</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">content</span><span class="p">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">Buffer</span><span class="p">,</span>
  <span class="nx">sourceMap</span><span class="p">?:</span> <span class="nx">SourceMap</span><span class="p">,</span> <span class="c1">// 表示一个可以被 this module 解析的 source map</span>
  <span class="nx">meta</span><span class="p">?:</span> <span class="nx">any</span> <span class="c1">// 此参数会被 webpack 忽略，可以是任何东西（例如一些元数据）</span>
<span class="p">);</span>
</code></pre></div></div> <p>注意，在使用了 <code class="language-plaintext highlighter-rouge">this.callback()</code> 的情况下，就不应该在使用 <code class="language-plaintext highlighter-rouge">return</code> 返回 <code class="language-plaintext highlighter-rouge">content</code>，而是应该返回 <code class="language-plaintext highlighter-rouge">undefined</code>，从而避免含糊的 loader 结果。</p> <h3 id="thisemitfile">this.emitFile()</h3> <p>用于产生一个文件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">emitFile</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">content</span><span class="p">:</span> <span class="nx">Buffer</span><span class="o">|</span><span class="nx">string</span><span class="p">,</span> <span class="nx">sourceMap</span><span class="p">:</span> <span class="p">{...})</span>
</code></pre></div></div> <h3 id="thisgetoptionsschema">this.getOptions(schema)</h3> <p>用于提取给定的 loader 选项，接受一个可选的 JSON schema 作为参数。</p> <h3 id="thisutils">this.utils</h3> <p>用于访问 <code class="language-plaintext highlighter-rouge">contextify</code> 与 <code class="language-plaintext highlighter-rouge">absolutify</code> 功能。</p> <ul> <li><code class="language-plaintext highlighter-rouge">contextify</code>：返回一个新的请求字符串，尽可能避免使用绝对路径。</li> <li><code class="language-plaintext highlighter-rouge">absolutify</code>：尽可能使用相对路径返回一个新的请求字符串。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">contextify</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">absolutify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span> <span class="dl">'</span><span class="s1">./index.js</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nf">absolutify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">resourcePath</span><span class="p">);</span>
  <span class="c1">// …</span>
  <span class="k">return</span> <span class="nx">content</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>这里只是列举出了几个常用的 Loader Context API，更多方法请参考 <a href="https://webpack.docschina.org/api/loaders/">Loader Interface</a>。</p> <h2 id="编写-loader">编写 Loader</h2> <h3 id="用法准则">用法准则</h3> <p>编写 loader 时应该遵循以下准则。它们按重要程度排序，有些仅适用于某些场景。</p> <h4 id="1保持简单">（1）保持<strong>简单</strong></h4> <p>loaders 应该只做单一任务。这不仅使每个 loader 易维护，也可以在更多场景链式调用。</p> <h4 id="2使用链式传递">（2）使用<strong>链式</strong>传递</h4> <p>利用 loader 可以链式调用的优势。写五个简单的 loader 实现五项任务，而不是一个 loader 实现五项任务。功能隔离不仅使 loader 更简单，可能还可以将它们用于你原先没有想到的功能。</p> <h4 id="3模块化的输出">（3）<strong>模块化</strong>的输出</h4> <p>保证输出模块化。loader 生成的模块与普通模块遵循相同的设计原则。</p> <h4 id="4确保无状态">（4）确保<strong>无状态</strong></h4> <p>确保 loader 在不同模块转换之间不保存状态。每次运行都应该独立于其他编译模块以及相同模块之前的编译结果。</p> <h4 id="5使用-loader-utilities">（5）使用 <strong>loader utilities</strong></h4> <p>充分利用 <code class="language-plaintext highlighter-rouge">loader-utils</code> 包。它提供了许多有用的工具，但最常用的一种工具是获取传递给 loader 的选项。<code class="language-plaintext highlighter-rouge">schema-utils</code> 包配合 <code class="language-plaintext highlighter-rouge">loader-utils</code>，用于保证 loader 选项，进行与 JSON Schema 结构一致的校验。</p> <h4 id="6记录-loader-的依赖">（6）记录 <strong>loader 的依赖</strong></h4> <p>如果一个 loader 使用外部资源（例如，从文件系统读取），必须声明它。这些信息用于使缓存 loaders 无效，以及在观察模式(watch mode)下重编译。</p> <h4 id="7解析模块依赖关系">（7）解析<strong>模块依赖关系</strong></h4> <p>根据模块类型，可能会有不同的模式指定依赖关系。例如在 CSS 中，使用 <code class="language-plaintext highlighter-rouge">@import</code> 和 <code class="language-plaintext highlighter-rouge">url(...)</code> 语句来声明依赖。这些依赖关系应该由模块系统解析。</p> <p>可以通过以下两种方式中的一种来实现：</p> <ul> <li>通过把它们转化成 <code class="language-plaintext highlighter-rouge">require</code> 语句。</li> <li>使用 <code class="language-plaintext highlighter-rouge">this.resolve</code> 函数解析路径。</li> </ul> <p><code class="language-plaintext highlighter-rouge">css-loader</code> 是第一种方式的一个例子。它将 <code class="language-plaintext highlighter-rouge">@import</code> 语句替换为 <code class="language-plaintext highlighter-rouge">require</code> 其他样式文件，将 <code class="language-plaintext highlighter-rouge">url(...)</code> 替换为 <code class="language-plaintext highlighter-rouge">require</code> 引用文件，从而实现将依赖关系转化为 <code class="language-plaintext highlighter-rouge">require</code> 声明。</p> <p>对于 <code class="language-plaintext highlighter-rouge">less-loader</code>，无法将每个 <code class="language-plaintext highlighter-rouge">@import</code> 转化为 <code class="language-plaintext highlighter-rouge">require</code>，因为所有 <code class="language-plaintext highlighter-rouge">.less</code> 的文件中的变量和混合跟踪必须一次编译。因此，<code class="language-plaintext highlighter-rouge">less-loader</code> 将 less 编译器进行了扩展，自定义路径解析逻辑。然后，利用第二种方式，通过 webpack 的 <code class="language-plaintext highlighter-rouge">this.resolve</code> 解析依赖。</p> <h4 id="8提取通用代码">（8）提取<strong>通用代码</strong></h4> <p>避免在 loader 处理的每个模块中生成通用代码。相反，你应该在 loader 中创建一个运行时文件，并生成 <code class="language-plaintext highlighter-rouge">require</code> 语句以引用该共享模块：</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/loader-runtime.js</span>

<span class="kd">const</span> <span class="p">{</span> <span class="nx">someOtherModule</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./some-other-module</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">runtime</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">someOtherModule</span><span class="p">(</span><span class="nx">params</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// src/loader.js</span>
<span class="k">import</span> <span class="nx">runtime</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./loader-runtime.js</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">loader</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nf">runtime</span><span class="p">({</span>
    <span class="nx">source</span><span class="p">,</span>
    <span class="na">y</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">(),</span>
  <span class="p">})}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="9避免绝对路径">（9）避免<strong>绝对路径</strong></h4> <p>不要在模块代码中插入绝对路径，因为当项目根路径变化时，文件绝对路径也会变化。<code class="language-plaintext highlighter-rouge">loader-utils</code> 中的 <a href="https://github.com/webpack/loader-utils#stringifyrequest">stringifyRequest</a> 方法，可以将绝对路径转化为相对路径。</p> <h4 id="10使用-peer-dependencies">（10）使用 <strong>peer dependencies</strong></h4> <p>如果你的 loader 简单包裹另外一个包，你应该把这个包作为一个 peerDependency 引入。这种方式允许应用程序开发者在必要情况下，在 <code class="language-plaintext highlighter-rouge">package.json</code> 中指定所需的确定版本。</p> <p>例如，<code class="language-plaintext highlighter-rouge">sass-loader</code> 指定 <code class="language-plaintext highlighter-rouge">node-sass</code> 作为同等依赖，引用如下：</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"peerDependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"node-sass"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.0.0"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h2 id="参考">参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[loader 本质上是导出为函数的 JavaScript 模块。loader runner 会调用此函数，然后将上一个 loader 产生的结果或者资源文件传入进去。函数中的 this 作为上下文会被 webpack 填充，并且 loader runner 中包含一些实用的方法，比如可以使 loader 调用方式变为异步，或者获取 query 参数。]]></summary></entry><entry><title type="html">webpack 中的 Plugin</title><link href="https://feng-zhang0712.github.io//blog/2024/plugin/" rel="alternate" type="text/html" title="webpack 中的 Plugin"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/plugin</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/plugin/"><![CDATA[<p>webpack 在代码编译过程中，会触发一系列 Tapable 钩子事件，插件所做的，就是在相应的钩子上注册事件，执行不同的任务。当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行。</p> <h2 id="一钩子">一、钩子</h2> <p>钩子（hooks）的本质是事件。webpack 把编译过程中触发的各类关键事件封装成事件接口暴露了出来。这些接口就被称为钩子，钩子是 webpack 插件中的关键概念。</p> <p><a href="https://github.com/webpack/tapable">Tapable</a> 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。</p> <p>Tapable 统一暴露了三个方法给插件，用于注册不同的钩子事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">tap()</code>：可以注册同步钩子和异步钩子。</li> <li> <p><code class="language-plaintext highlighter-rouge">tapAsync()</code>：回调方式注册异步钩子。</p> <p>使用 <code class="language-plaintext highlighter-rouge">tapAsync()</code> 方法来绑定插件时，<strong>必须</strong>调用函数的最后一个参数 <code class="language-plaintext highlighter-rouge">callback()</code> 指定的回调函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">HelloAsyncPlugin</span> <span class="p">{</span>
    <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span>
        <span class="dl">'</span><span class="s1">HelloAsyncPlugin</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="c1">// 执行某些异步操作...</span>
          <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">异步任务完成...</span><span class="dl">'</span><span class="p">);</span>
            <span class="nf">callback</span><span class="p">();</span>
          <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloAsyncPlugin</span><span class="p">;</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">tapPromise()</code>：Promise 方式注册异步钩子。</p> <p>使用 <code class="language-plaintext highlighter-rouge">tapPromise()</code> 方法来绑定插件时，<strong>必须</strong>返回一个 Promise，异步任务完成后调用 Promise 的 <code class="language-plaintext highlighter-rouge">resolve()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">HelloAsyncPlugin</span> <span class="p">{</span>
    <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapPromise</span><span class="p">(</span><span class="dl">'</span><span class="s1">HelloAsyncPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 返回一个 pormise ，异步任务完成后 resolve</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">异步任务完成...</span><span class="dl">'</span><span class="p">);</span>
            <span class="nf">resolve</span><span class="p">();</span>
          <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloAsyncPlugin</span><span class="p">;</span>
</code></pre></div> </div> </li> </ul> <p>目前，<a href="https://github.com/webpack/tapable/blob/master/lib/index.js">Tapable</a> 中定义了十种 Hooks。</p> <ul> <li>SyncHook</li> <li>SyncBailHook</li> <li>SyncWaterfallHook</li> <li>SyncLoopHook</li> <li>AsyncParallelHook</li> <li>AsyncParallelBailHook</li> <li>AsyncSeriesHook</li> <li>AsyncSeriesBailHook</li> <li>AsyncSeriesLoopHook</li> <li>AsyncSeriesWaterfallHook</li> </ul> <p>上面的钩子，按照执行方式，分为<strong>同步钩子</strong>和<strong>异步钩子</strong>，他们的名称分别以前缀 <code class="language-plaintext highlighter-rouge">Sync</code> 和 <code class="language-plaintext highlighter-rouge">Async</code> 开头。<a href="https://webpack.docschina.org/">webpack 文档中</a>列出的所有的 <a href="https://webpack.docschina.org/api/compiler-hooks/">compiler 钩子</a> 和 <a href="https://webpack.docschina.org/api/compilation-hooks/">compilation 钩子</a>，都继承自这些 Hooks。</p> <p>下面，分别对这些 Hooks 进行介绍。</p> <h3 id="synchook">SyncHook</h3> <h3 id="asyncparallelhook">AsyncParallelHook</h3> <h3 id="asyncserieshook">AsyncSeriesHook</h3> <h2 id="二compiler-对象">二、Compiler 对象</h2> <p><code class="language-plaintext highlighter-rouge">compiler</code> 对象中保存着完整的 webpack 环境配置，每次启动 webpack 构建时它都是一个独一无二、仅仅会创建一次的对象。这个对象会在首次启动 webpack 时创建，我们可以通过 <code class="language-plaintext highlighter-rouge">compiler</code> 对象上访问到 webapck 的主环境配置，比如 loader、plugin 等等配置信息。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-object-structure-480.webp 480w,/assets/images/webpack/compiler-object-structure-800.webp 800w,/assets/images/webpack/compiler-object-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-object-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler 对象的结构 </div> <p>webpack 中的很多<a href="https://webpack.docschina.org/api/compiler-hooks/#hooks">生命周期函数钩子</a>，由 <code class="language-plaintext highlighter-rouge">compiler</code> 暴露，可以通过以下方式注册监听。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">someHook</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
<span class="p">});</span>
</code></pre></div></div> <p>compiler 对象有以下主要属性。</p> <h3 id="compileroptions">compiler.options</h3> <p><code class="language-plaintext highlighter-rouge">compiler.options</code>：用于访问本次启动 webpack 时候所有的配置文件，比如 <code class="language-plaintext highlighter-rouge">loaders</code>、<code class="language-plaintext highlighter-rouge">entry</code> 、<code class="language-plaintext highlighter-rouge">output</code>、<code class="language-plaintext highlighter-rouge">plugin</code> 等等完整配置信息。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-options-structure-480.webp 480w,/assets/images/webpack/compiler-options-structure-800.webp 800w,/assets/images/webpack/compiler-options-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-options-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler.options 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler.options 对象的结构 </div> <h3 id="compilerhooks">compiler.hooks</h3> <p><code class="language-plaintext highlighter-rouge">compiler.hooks</code>：用于注册 tapable 的不同种类 Hook，从而可以在 <code class="language-plaintext highlighter-rouge">compiler</code> 生命周期中植入不同的逻辑。</p> <div class="row justify-content-center"> <div class="col-10"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compiler-hooks-structure-480.webp 480w,/assets/images/webpack/compiler-hooks-structure-800.webp 800w,/assets/images/webpack/compiler-hooks-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compiler-hooks-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compiler.hooks 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compiler.hooks 对象的结构 </div> <h3 id="compilerinputfilesystem-和-compileroutputfilesystem">compiler.inputFileSystem 和 compiler.outputFileSystem</h3> <p><code class="language-plaintext highlighter-rouge">compiler.inputFileSystem</code> 和 <code class="language-plaintext highlighter-rouge">compiler.outputFileSystem</code>：用于进行文件操作，相当于 Nodejs 中 <code class="language-plaintext highlighter-rouge">fs</code>。</p> <h2 id="三compilation-对象">三、Compilation 对象</h2> <p><code class="language-plaintext highlighter-rouge">compilation</code> 对象代表一次资源的构建，<code class="language-plaintext highlighter-rouge">compilation</code> 实例能够访问所有的模块和它们的依赖。一个 <code class="language-plaintext highlighter-rouge">compilation</code> 对象会对构建依赖图中所有模块进行编译。在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、分块(chunk)、哈希(hash)和重新创建(restore)。</p> <div class="row justify-content-center"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/webpack/compilation-object-structure-480.webp 480w,/assets/images/webpack/compilation-object-structure-800.webp 800w,/assets/images/webpack/compilation-object-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/images/webpack/compilation-object-structure.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="compilation 对象的结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> compilation 对象的结构 </div> <p>Compilation 类扩展自 Tapable，并提供了很多<a href="https://webpack.docschina.org/api/compilation-hooks/">生命周期钩子</a>。他们的使用方式，跟使用 <code class="language-plaintext highlighter-rouge">compiler</code> 注册监听钩子的方式相同。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">compilation</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">someHook</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyPlugin</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
<span class="p">});</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">compilation</code> 对象有以下主要属性。</p> <h3 id="compilationmodules">compilation.modules</h3> <p><code class="language-plaintext highlighter-rouge">compilation.modules</code> 用于访问所有模块，打包的每一个文件都是一个模块。</p> <h3 id="compilationchunks">compilation.chunks</h3> <p><code class="language-plaintext highlighter-rouge">compilation.chunks</code> chunk 即是多个 modules 组成而来的一个代码块。入口文件引入的资源组成一个 chunk，通过代码分割的模块又是另外的 chunk。</p> <h3 id="compilationassets">compilation.assets</h3> <p><code class="language-plaintext highlighter-rouge">compilation.assets</code> 用于访问本次打包生成所有文件的结果。</p> <h3 id="compilationhooks">compilation.hooks</h3> <p><code class="language-plaintext highlighter-rouge">compilation.hooks</code> 用于注册 tapable 的不同种类 Hook，用于在 <code class="language-plaintext highlighter-rouge">compilation</code> 编译模块阶段进行逻辑添加以及修改。</p> <h2 id="四自定义-plugin">四、自定义 Plugin</h2> <p>webpack 插件由以下几个部分组成。</p> <ul> <li>一个 JavaScript 命名<strong>函数</strong>或<strong>类</strong>。</li> <li>在插件函数的 prototype 上定义一个 <code class="language-plaintext highlighter-rouge">apply</code> 方法。</li> <li>指定一个绑定到 webpack 自身的事件钩子。</li> <li>处理 webpack 内部实例的特定数据。</li> <li>功能完成后调用 webpack 提供的回调。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyExampleWebpackPlugin</span> <span class="p">{</span>
  <span class="c1">// 在插件函数的 prototype 上定义一个 `apply` 方法，以 compiler 为参数。</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 指定一个挂载到 webpack 自身的事件钩子。</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">emit</span><span class="p">.</span><span class="nf">tapAsync</span><span class="p">(</span>
      <span class="dl">'</span><span class="s1">MyExampleWebpackPlugin</span><span class="dl">'</span><span class="p">,</span>
      <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">这是一个示例插件！</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
          <span class="dl">'</span><span class="s1">这里表示了资源的单次构建的 `compilation` 对象：</span><span class="dl">'</span><span class="p">,</span>
          <span class="nx">compilation</span>
        <span class="p">);</span>

        <span class="c1">// 用 webpack 提供的插件 API 处理构建过程</span>
        <span class="nx">compilation</span><span class="p">.</span><span class="nf">addModule</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>

        <span class="nf">callback</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>插件是由「具有 <code class="language-plaintext highlighter-rouge">apply</code> 方法的 prototype 对象」所实例化出来的。这个 <code class="language-plaintext highlighter-rouge">apply</code> 方法在安装插件时，会被 <code class="language-plaintext highlighter-rouge">compiler</code> 调用一次。apply 方法可以接收一个 <code class="language-plaintext highlighter-rouge">compiler</code> 对象的引用，从而可以在回调函数中访问到 <code class="language-plaintext highlighter-rouge">compiler</code> 对象。一个插件结构如下。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HelloWorldPlugin</span> <span class="p">{</span>
  <span class="nf">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">tap</span><span class="p">(</span>
      <span class="dl">'</span><span class="s1">Hello World Plugin</span><span class="dl">'</span><span class="p">,</span>
      <span class="p">(</span>
        <span class="nx">stats</span> <span class="cm">/* 绑定 done 钩子后，stats 会作为参数传入。 */</span>
      <span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">HelloWorldPlugin</span><span class="p">;</span>
</code></pre></div></div> <p>然后就可以在 webpack 配置文件中使用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">HelloWorldPlugin</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello-world</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span><span class="k">new</span> <span class="nc">HelloWorldPlugin</span><span class="p">({</span> <span class="na">options</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})],</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="五参考">五、参考</h2> <ul> <li>webpack 文档，<a href="https://webpack.docschina.org/">webpack</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="frontend"/><category term="webpack"/><summary type="html"><![CDATA[webpack 在代码编译过程中，会触发一系列 Tapable 钩子事件，插件所做的，就是在相应的钩子上注册事件，执行不同的任务。当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行。]]></summary></entry></feed>