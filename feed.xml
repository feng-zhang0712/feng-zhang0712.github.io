<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-19T03:49:41+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html"></title><link href="https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer/" rel="alternate" type="text/html" title=""/><published>2024-09-19T03:49:41+00:00</published><updated>2024-09-19T03:49:41+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/2024-09-11-data-link-layer/"><![CDATA[<h2 id="一介绍">一、介绍</h2> <p>数据链路层属于计算机网络的低层。数据链路层使用的信道主要有以下两种类型：</p> <ul> <li><strong>点对点信道</strong>。这种信道使用一对一的点对点通信方式。</li> <li><strong>广播信道</strong>。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li> </ul> <p>本章中我们研究的是在同一个局域网中，分组怎样从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，局域网仍属于数据链路层的范围。</p> <p>下面看一下两台主机通过互联网进行通信时数据链路层所处的地位（图 3-1）。图 3-1（a）表示用户主机 $H_1$ 通过电话线上网，中间经过三个路由器（$R_1$，$R_1$ 和 $R_1$）连接到远程主机 $H_2$。所经过的网络可以是多种的，如电话网、局域网和广域网。当主机 $H_1$ 向 $H_2$ 发送数据时，从协议的层次上看，数据的流动如图 3-1（b）所示。主机 $H_1$ 和 $H_2$ 都有完整的五层协议栈，但路由器在转发分组时使用的协议栈只有下面的三层。数据进入路由器后要先从物理层上到网络层，在转发表中找到下一跳的地址后，再下到物理层转发出去。因此，数据从主机 $H_1$ 传送到主机 $H_2$ 需要在路径中的各结点的协议栈向上和向下流动多次，如图中的浅灰色箭头所示。</p> <p>然而当我们专门研究数据链路层的问题时，在许多情况下我们可以只关心在协议栈中水平方向的各数据链路层。于是，当主机 $H_1$ 向主机 $H_2$ 发送数据时，我们可以想象数据就是在数据链路层从左向右沿水平方向传送的，如图3 -2 中从左到右的粗箭头所示，即通过以下这样的链路：</p> <p>$H_1$ 的链路层 → $R_1$ 的链路层 → $R_2$ 的链路层 → $R_3$ 的链路层 → $H_2$ 的链路层</p> <p><img src="/assets/images/computer-networks/data-flow-at-the-data-link-layer.png" alt="数据在数据链路层的流动"/> <em>图 3-2 只考虑数据在数据链路层的流动</em></p> <p>图 3-2 指出，从数据链路层来看，$H_1$ 到 $H_2$ 的通信可以看成由四段不同的链路层通信组成，即：$H_1$ → $R_1$，$R_1$ → $R_2$，$R_2$ → $R_3$ 和 $R_3$ → $H_2$。这四段不同的链路层可能采用不同的数据链路层协议。</p> <h2 id="二使用点对点信道的数据链路层">二、使用点对点信道的数据链路层</h2> <h3 id="21-数据链路和帧">2.1 数据链路和帧</h3> <p>“链路”和“数据链路”并不是一回事。</p> <ul> <li><strong>链路</strong>（link）：指从一个结点到相邻结点的一段物理线路（有线或无线），中间没有任何其他的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。</li> <li><strong>数据链路</strong>（data link）：是另一个概念。这是因为当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用<strong>网络适配器</strong>（既有硬件，也包括软件）来实现这些协议。一般的适配器都包括了数据链路层和物理层这两层的功能。</li> </ul> <p>数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是 <strong>IP 数据报</strong>（或简称为数据报、分组或包）。</p> <p>为了把主要精力放在点对点信道的数据链路层协议上，可以采用如图 3-3（a）所示的三层模型。在这种三层模型中，不管在哪段链路上的通信（主机和路由器之间或两个路由器之间），我们都看成是结点和结点的通信（如图中的结点 A 和 B），而每个结点只有下三层：网络层、数据链路层和物理层。</p> <p><img src="/assets/images/computer-networks/data-link-layer-using-point-to-point-channel.png" alt="使用点对点信道的数据链路层"/> <em>图 3-3 使用点对点信道的数据链路层</em></p> <p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p> <ol> <li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。</li> <li>结点 A 把封装好的帧发送给结点 B 的数据链路层。</li> <li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。</li> </ol> <p>数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方，如图 3-3（b）所示。</p> <h3 id="22-三个基本问题">2.2 三个基本问题</h3> <p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：<strong>封装成帧</strong>、<strong>透明传输</strong>和<strong>差错检测</strong>。</p> <h4 id="1封装成帧">（1）封装成帧</h4> <p><strong>封装成帧</strong>（framing）就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束（图 3-4 表示用帧首部和帧尾部封装成帧的一般概念）。我们知道，分组交换的一个重要概念就是：所有在互联网上传送的数据都以分组（即 IP 数据报）为传送单位。网络层的 IP 数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行<strong>帧定界</strong>（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限</strong> —— <strong>最大传送单元 MTU</strong>（Maximum Transfer Unit）。图 3-4 给出了帧的首部和尾部的位置，以及帧的数据部分与 MTU 的关系。</p> <p><img src="/assets/images/computer-networks/encapsulate-frames-with-frame-headers-and-tails.png" alt="用帧首部和尾部封装成帧"/> <em>图 3-4 用帧首部和尾部封装成帧</em></p> <p>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的<strong>帧定界符</strong>。我们知道，ASCII 码是 7 位编码，一共可组合成 128 个不同的 ASCII 码，其中可打印的有 95 个，而不可打印的控制字符有 33 个。图 3-5 的例子可说明帧定界的概念。控制字符 SOH（Start Of Header）放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT （End Of Transmission）表示帧的结束。请注意，SOH 和 EOT 都是控制字符的名称。它们的十六进制编码分别是 01（二进制是 00000001）和 04（二进制是 00000100）。</p> <p><img src="/assets//images/computer-networks/method-of-delimiting-frames-with-control-characters.png" alt="用控制字符进行帧定界的方法举例"/> <em>图 3-5 用控制字符进行帧定界的方法举例</em></p> <p>当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧（只有首部开始符 SOH 而没有传输结束符 EOT），必须丢弃。而后面收到的数据有明确的帧定界符（SOH 和 EOT），因此这是一个完整的帧，应当收下。</p> <h4 id="2透明传输">（2）透明传输</h4> <p>由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。</p> <p>当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现像 SOH 或 EOT 这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p> <p>但当数据部分是非 ASCII 码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 这种控制字符一样（见图 3-6），数据链路层就会错误地“找到帧的边界”，把部分帧收下（误认为是个完整的帧），而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符 SOH）。</p> <p><img src="/assets/images/computer-networks/the-data-section-happens-to-have-the-same-code-as-the-eot.png" alt="数据部分恰好出现与 EOT 一样的代码"/> <em>图 3-6 数据部分恰好出现与EOT 一样的代码</em></p> <p>像图 3-6 所示的帧的传输显然就不是“透明传输”，因为当遇到数据中碰巧出现字符“EOT”时就传不过去了。数据中的“EOT”将被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端当作无效帧而丢弃。但实际上在数据中出现的字符“EOT”并非控制字符而仅仅是二进制数据 00000100。</p> <p>前面提到的“透明”是一个很重要的术语。它表示：<strong>某个实际存在的事物看起来却好像不存在一样</strong>（例如，你看不见在你前面有块 100%透明的玻璃的存在）。“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。</p> <p>为了解决透明传输问题，必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。具体的方法是：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个<strong>转义字符</strong>“ESC”（其十六进制编码是 1B，二进制是 00011011）。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为<strong>字节填充</strong>（byte stuffing）或<strong>字符填充</strong>（character stuffing）。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。图 3-7 表示用字节填充法解决透明传输的问题。</p> <p><img src="/assets/images/computer-networks/using-byte-filling-method-to-solve-the-problem-of-transparent-transmission.png" alt="用字节填充法解决透明传输的问题"/> <em>图 3-7 用字节填充法解决透明传输的问题</em></p> <h4 id="4差错检测">（4）差错检测</h4> <p>现实的通信链路都不会是理想的。这就是说，比特在传输过程中可能会产生差错：1 可能会变成 0，而 0 也可能变成 1。这就叫做<strong>比特差错</strong>。比特差错是传输差错中的一种。在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率 BER</strong> （Bit Error Rate）。例如，误码率为 $10^{-10}$ 时，表示平均每传送 $10_{10}$ 个比特就会出现一个比特的差错。误码率与信噪比有很大的关系。如果设法提高信噪比，就可以使误码率减小。实际的通信链路并不是理想的，它不可能使误码率下降到零。因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了<strong>循环冗余检验 CRC</strong>（Cyclic Redundancy Check）的检错技术。</p> <p>下面我们通过一个简单的例子来说明循环冗余检验的原理。</p> <p>在发送端，先把数据划分为组，假定每组 k 个比特。现假定待传送的数据 M = 101001（k = 6）。CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位<strong>冗余码</strong>，然后构成一个帧发送出去，一共发送（k + n）位。在所要发送的数据后面增加 n 位的冗余码，虽然增大了数据传输的开销，但却可以进行差错检测。当传输可能出现差错时，付出这种代价往往是很值得的。</p> <p>这 n 位冗余码可用以下方法得出。用二进制的<strong>模 2 运算</strong>进行 $2^n$ 乘 M 的运算，这相当于在 M 后面添加 n 个 O。得到的（k + n）位的数除以收发双方事先商定的长度为（n + 1）位的除数 P，得出商是 Q 而余数是 R（n 位，比 P 少一位）（关于除数 P 下面还要介绍）。在图 3-8 所示的例子中，M = 101001（即 k = 6）。假定除数P = 1101（即 n = 3）。经模 2 除法运算后的结果是：商 Q = 110101 （这个商并没有什么用处），而余数 R = 001。这个余数 R 就作为冗余码拼接在数据 M 的后面发送出去。这种为了进行检错而添加的冗余码常称为<strong>帧检验序列 FCS</strong>（Frame Check Sequence）。因此加上 FCS 后发送的帧是 101001001（即 $2^nM$ + FCS），共有（k + n）位。</p> <p>顺便说一下，循环冗余检验 CRC 和帧检验序列 FCS 并不是同一个概念。CRC 是一种检错方法，而 FCS 是添加在数据后面的冗余码，在检错方法上可以选用 CRC，但也可不选用 CRC。</p> <p><img src="/assets/images/computer-networks/examples-that-illustrate-the-principle-of-cyclic-redundancy-checking.png" alt="说明循环冗余检验原理的例子"/> <em>图 3-8 说明循环冗余检验原理的例子</em></p> <p>在接收端把接收到的数据帧为单位进行 CRC 检验：把收到的每个帧都除以同样的除数 P（模 2 运算），然后检查得到的余数 R。</p> <p>如果在传输过程中无差错，那么经过 CRC 检验后得出的余数 R 肯定是 0（读者可以自己验算一下。被除数现在是 101001001，而除数是 P = 1101，看余数 R 是否为 0）。</p> <p>但如果出现误码，那么余数 R 仍等于零的概率是非常非常小的（这可以通过不太复杂的概率计算得出，例如，可参考[TANE11]）。</p> <p>总之，在接收端对收到的每一帧经过 CRC 检验后，有以下两种情况：</p> <ul> <li>若得出的余数 R = 0，则判定这个帧没有差错，就接受（accept）。</li> <li>若余数 R ≠ 0，则判定这个帧有差错（但无法确定究竟是哪一位或哪几位出现了差错），就丢弃。</li> </ul> <p>一种较方便的方法是用多项式来表示循环冗余检验过程。在上面的例子中，用多项式 P(X) = $X_3$ + $X_2$ + 1 表示上面的除数 P = 1101（最高位对应于 $X_3$，最低位对应于 $X_0$）。多项式 P(X) 称为<strong>生成多项式</strong>。现在广泛使用的生成多项式 P(X) 有以下几种：</p> <p>\(CRC-16 = X_{16} + X_{15} + X_2 + 1\) \(CRC-CCITT = X_{16} + X_{12} + X_5 + 1\) \(CRC-32 = X_{32} + X_{26} + X_{23} + X_{22} + X_{16} + X_{12} + X_{11} + X_{10} + X_8 + X_7 + X_5 + X_4 + X_2 + X + 1\)</p> <p>在数据链路层，发送端帧检验序列 FCS 的生成和接收端的 CRC 检验都是用硬件完成的，处理很迅速，因此并不会延误数据的传输。</p> <p>从以上的讨论不难看出，如果我们在传送数据时不以帧为单位来传送，那么就无法加入冗余码以进行差错检验。因此，如果要在数据链路层进行差错检验，就必须把数据划分为帧，每一帧都加上冗余码，一帧接一帧地传送，然后在接收方逐帧进行差错检验。</p> <p>最后再强调一下，在数据链路层若<strong>仅仅</strong>使用循环冗余检验 CRC 差错检测技术，则只能做到对帧的<strong>无差错接受</strong>，即：“<strong>凡是接收端数据链路层接受的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错</strong>”。接收端丢弃的帧虽然曾<strong>收到</strong>了，但最终还是因为有差错被丢弃，即没有被<strong>接受</strong>。以上所述的可以近似地表述为（通常都是这样认为）：“<strong>凡是接收端数据链路层接受的帧均无差错</strong>”。</p> <p>注意，我们现在并没有要求数据链路层向网络层提供“<strong>可靠传输</strong>”的服务。所谓“可靠传输”就是：数据链路层的发送端发送什么，在接收端就收到什么。传输差错可分为两大类：一类就是前面所说的最基本的比特差错，而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了<strong>帧丢失</strong>、<strong>帧重复</strong>或<strong>帧失序</strong>。例如，发送方连续传送三个帧：[#1]-[#2]-[#3]。假定接收端收到的每个帧都没有比特差错，但却出现下面的几种情况：</p> <ul> <li><strong>帧丢失</strong>：收到[#1]-[#3]（丢失[#2]）。</li> <li><strong>帧重复</strong>：收到[#1]-[#2]-[#2]-[#3]（收到两个[#2]）。</li> <li><strong>帧失序</strong>：收到[#1]-[#3]-[#2]（后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样）。</li> </ul> <p>以上三种情况都属于“<strong>出现传输差错</strong>”，但都不是这些帧里有“比特差错”。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂。</p> <p>总之，我们应当明确，“无比特差错”与“无传输差错”并不是同样的概念。在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</p> <p>我们知道，过去 OSI 的观点是：必须让数据链路层向上提供可靠传输。因此在 CRC 检错的基础上，增加了<strong>帧编号</strong>、<strong>确认</strong>和<strong>重传机制</strong>。收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。这种方法在历史上曾经起到很好的作用。但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。因此，现在互联网就采取了区别对待的方法：</p> <ul> <li>对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，运输层的 TCP 协议）来完成。</li> <li>对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</li> </ul> <p>实践证明，这样做可以提高通信效率。</p> <h2 id="二点对点协议-ppp">二、点对点协议 PPP</h2> <p>在通信线路质量较差的年代，在数据链路层使用可靠传输协议曾经是一种好办法。因此，能实现可靠传输的<strong>高级数据链路控制 HDLC</strong>（High-level Data Link Control）就成为当时比较流行的数据链路层协议。但现在 HDLC 已很少使用了。对于点对点的链路，简单得多的<strong>点对点协议 PPP</strong>（Point-to-Point Protocol）则是目前使用得最广泛的数据链路层协议。</p> <h3 id="21-ppp-协议的特点">2.1 PPP 协议的特点</h3> <p>我们知道，互联网用户通常都要连接到某个 ISP 才能接入到互联网。PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议（图 3-9）。</p> <p><img src="/assets/images/computer-networks/the-link-between-the-user-and-the-isp-uses-ppp.png" alt="用户到 ISP 的链路使用 PPP 协议"/> <em>图 3-9 用户到 ISP 的链路使用 PPP 协议</em></p> <p>PPP 协议是 IETF 在 1992 年制定的。经过 1993 年和 1994 年的修订，现在的 PPP 协议在 1994 年就已成为互联网的正式标准[RFC 1661]。</p> <h4 id="1ppp-协议应满足的需求">（1）PPP 协议应满足的需求</h4> <p>IETF 认为，在设计 PPP 协议时必须考虑以下多方面的需求[RFC 1547]：</p> <ol> <li><strong>简单</strong>：IETF 在设计互联网体系结构时把其中最复杂的部分放在 TCP 协议中，而网际协议 IP 则相对比较简单，它提供的是不可靠的数据报服务。在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。IETF 把“简单”作为<strong>首要的需求</strong>。简单的设计还可使协议在实现时不容易出错，从而使不同厂商在协议的不同实现上的互操作性提高了。我们知道，协议标准化的一个主要目的就是提高协议的互操作性。总之，这种数据链路层的协议非常简单：接收方每收到一个帧，就进行 CRC 检验。如 CRC 检验正确，就收下这个帧；反之，就丢弃这个帧，<strong>其他什么也不做</strong>。</li> <li><strong>封装成帧</strong>：PPP 协议必须规定特殊的字符作为帧定界符（即标志一个帧的开始和结束的字符），以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</li> <li><strong>透明性</strong>：PPP 协议必须保证数据传输的透明性。这就是说，如果数据中碰巧出现了和帧定界符一样的比特组合时，就要采取有效的措施来解决这个问题。</li> <li><strong>多种网络层协议</strong>：PPP 协议必须能够<strong>在同一条物理链路上同时支持多种网络层协议</strong>（如 IP 和 IPX 等）的运行。当点对点链路所连接的是局域网或路由器时，PPP 协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。</li> <li><strong>多种类型链路</strong>：除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。例如，串行的（一次只发送一个比特）或并行的（一次并行地发送多个比特），同步的或异步的，低速的或高速的，电的或光的，交换的动态的）或非交换的（静态的）点对点链路。</li> <li><strong>差错检测</strong>：PPP 协议必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong>。若在数据链路层不进行差错检测，那么已出现差错的无用帧就还要在网络中继续向前转发，因而会白白浪费许多的网络资源。</li> <li><strong>检测连接状态</strong>：PPP 协议必须具有一种机制能够及时（不超过几分钟）自动检测出链路是否处于正常工作状态。当出现故障的链路隔了一段时间后又重新恢复正常工作时，就特别需要有这种及时检测功能。</li> <li><strong>最大传送单元</strong>：PPP 协议必须对每种类型的点对点链路设置<strong>最大传送单元 MTU</strong> 的标准默认值。这样做是为了促进各种实现之间的互操作性。如果高层协议发送的分组过长并超过 MTU 的数值，PPP 就要丢弃这样的帧，并返回差错。需要强调的是，MTU 是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，而不是帧的总长度。</li> <li><strong>网络层地址协商</strong>：PPP 协议必须提供一种机制使通信的两个网络层（例如，两个 IP 层）的实体能够通过协商知道或能够配置彼此的网络层地址。协商的算法应尽可能简单，并且能够在所有的情况下得出协商结果。这对拨号连接的链路特别重要，因为如果仅仅在链路层建立了连接而不知道对方网络层地址，则还不能够保证网络层可以传送分组。</li> <li><strong>数据压缩协商</strong>：PPP 协议必须提供一种方法来协商使用数据压缩算法。但PPP协议并不要求将数据压缩算法进行标准化。</li> </ol> <p>在 TCP/IP 协议族中，可靠传输运输层的 TCP 协议负责，因此数据链路层的 PPP 协议不需要进行纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路（即一个主站轮流和链路上的多个从站进行通信），而只支持点对点的链路通信。此外，PPP 协议只支持全双工链路。</p> <h4 id="2ppp-协议的组成">（2）PPP 协议的组成</h4> <p>PPP 协议有三个组成部分：</p> <ol> <li>一个将 IP 数据报封装到串行链路的方法。PPP 既支持异步链路（无奇偶检验的 8 比特数据），也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。</li> <li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议 LCP</strong>（Link Control Protocol）。通信的双方可协商一些选项。在 RFC 1661 中定义了11种类型的 LCP 分组。</li> <li>一套<strong>网络控制协议 NCP</strong>（Network Control Protocol），其中的每个协议支持不同的网络层协议，如 IP、OSI 的网络层、DECnet，以及 AppleTalk 等。</li> </ol> <h3 id="22-ppp-协议的帧格式">2.2 PPP 协议的帧格式</h3> <h4 id="1各字段的意义">（1）各字段的意义</h4> <p>PPP 的帧格式如图 3-10 所示。PPP 帧的首部和尾部分别为四个字段和两个字段。首部的第一个字段和尾部的第二个字段都是标志字段 <strong>F</strong>（Flag），规定为 0x7E（符号“0x”表示它后面的字符是用十六进制表示的。十六进制的 7E 的二进制表示是 01111110）。标志字段表示一个帧的开始或结束。因此标志字段就是 PPP 帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃。</p> <p><img src="/assets/images/computer-networks/ppp-frame-format.png" alt="PPP 帧的格式"/> <em>图 3-10 PPP 帧的格式</em></p> <ul> <li>首部中的地址字段 A 规定为 0xFF（即 11111111）。</li> <li>控制字段 C 规定为 0x03 （即 00000011）（最初曾考虑以后再对这 A 和 C 两个字段的值进行其他定义，但至今也没有给出。可见这两个字段实际上并没有携带 PPP 帧的信息）。</li> <li>PPP 首部的第四个字段是 2 字节的协议字段。 <ul> <li>当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。</li> <li>若为 0xC021，则信息字段是 PPP 链路控制协议 LCP 的数据。</li> <li>而 0x8021 表示这是网络层的控制数据。</li> </ul> </li> <li>信息字段的长度是可变的，不超过 1500 字节。</li> <li>尾部中的第一个字段（2 字节）是使用 CRC 的帧检验序列 FCS。</li> </ul> <h4 id="2字节填充">（2）字节填充</h4> <p>当信息字段中出现和标志字段一样的比特（0x7E）组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。当 PPP 使用异步传输时，它把转义符定义为 0x7D（即 01111101），并使用<strong>字节填充</strong>，填充方法如下：</p> <ol> <li>把信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列（0x7D， 0x5E）。</li> <li>若信息字段中出现一个 0x7D 的字节（即出现了和转义字符一样的比特组合），则把 0x7D 转变成为 2 字节序列（0x7D， 0x5D）。</li> <li>若信息字段中出现 ASCII 码的控制字符（即数值小于0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。例如，出现 0x03 就要把它转变为2字节序列（0x7D， 0x23）。</li> </ol> <p>由于在发送端进行了字节填充，因此在链路上传送的信息字节数就超过了原来的信息字节数。但接收端在收到数据后再进行与发送端字节填充相反的变换，就可以正确地恢复出原来的信息。</p> <h4 id="3零比特填充">（3）零比特填充</h4> <p>PPP 协议用在使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符地传送）时。在这种情况下，PPP 协议采用零比特填充方法来实现透明传输。</p> <p>零比特填充的具体做法是：在发送端，先扫描整个信息字段。只要发现有 5 个连续 1，则立即填入一个 0。因此经过这种零比特填充后的数据，就可以保证在信息字段中不会出现 6 个连续 1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除，以还原成原来的信息比特流（图 3-11）。这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</p> <p><img src="/assets/images/computer-networks/fill-and-deletion-of-zero-bits.png" alt="零比特的填充与删除"/> <em>图 3-11 零比特的填充与删除</em></p> <h3 id="23-ppp-协议的工作状态">2.3 PPP 协议的工作状态</h3> <p>当用户拨号接入 ISP 后，就建立了一条从用户个人电脑到 ISP 的物理连接。这时，用户个人电脑向 ISP 发送一系列的链路控制协议 LCP 分组（封装成多个 PPP 帧），以便建立 LCP 连接。这些分组及其响应选择了将要使用的一些 PPP 参数。接着还要进行网络层配置，网络控制协议 NCP 给新接入的用户个人电脑分配一个临时的 IP 地址。这样，用户个人电脑就成为互联网上的一个有 IP 地址的主机了。</p> <p>当用户通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p> <p>上述过程可用图 3-12 的状态图来描述。</p> <p>PPP 链路的起始和终止状态永远是图 3-12 中的“<strong>链路静止</strong>”（Link Dead）状态，这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接。</p> <p>当用户个人电脑通过调制解调器呼叫路由器时（通常是在屏幕上用鼠标点击一个连接按钮），路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP 就进入“<strong>链路建立</strong>”（Link Establish）状态，其目的是建立链路层的 LCP 连接。这时 LCP 开始协商一些<strong>配置选项</strong>，即发送 LCP 的<strong>配置请求帧</strong>（Configure-Request）。这是个 PPP 帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：</p> <ul> <li>配置确认帧（Configure-Ack）：所有选项都接受。</li> <li>配置否认帧（Configure-Nak）：所有选项都理解但不能接受。</li> <li>配置拒绝帧（Configure-Reject）：选项有的无法识别或不能接受，需要协商。</li> </ul> <p><img src="/assets/images/computer-networks/ppp-status-diagram.png" alt="PPP 协议的状态图"/> <em>图 3-12 PPP 协议的状态图</em></p> <p>LCP 配置选项包括链路上的最大帧长、所使用的鉴别协议（authentication protocol）的规约（如果有的话），以及不使用 PPP 帧中的地址和控制字段（因为这两个字段的值是固定的，没有任何信息量，可以在 PPP 帧的首部中省略这两个字节）。</p> <p>协商结束后双方就建立了 LCP 链路，接着就进入“<strong>鉴别</strong>”（Authenticate）状态。在这一状态，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用<strong>口令鉴别协议 PAP</strong>（Password Authentication Protocol），则需要发起通信的一方发送身份标识符和口令。系统可允许用户若干次。如果需要有更好的安全性，则可使用更加复杂的<strong>口令握手鉴别协议 CHAP</strong>（Challenge-Handshake Authentication Protocol）。若鉴别身份失败，则转到“<strong>链路终止</strong>”（Link Terminate）状态。若鉴别成功，则进入“<strong>网络层协议</strong>”（Network-Layer Protocol）状态。</p> <p>在“<strong>网络层协议</strong>”状态，PPP 链路的两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP 协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个 PPP 协议进行通信。</p> <p>如果在 PPP 链路上运行的是 IP 协议，则对 PPP 链路的每一端配置 IP 协议模块（如分配IP地址）时就要使用 NCP 中支持 IP 的协议 —— <strong>IP 控制协议 IPCP</strong>（IP Control Protocol）。IPCP 分组也封装成 PPP 帧（其中的协议字段为 0x8021）在 PPP 链路上传送。在低速链路上运行时，双方还可以协商使用压缩的 TCP 和 IP 首部，以减少在链路上发送的比特数。</p> <p>当网络层配置完毕后，链路就进入可进行数据通信的“<strong>链路打开</strong>”（Link Open）状态。链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可发送<strong>回送请求</strong> LCP 分组（Echo-Request）和<strong>回送回答</strong> LCP 分组（Echo-Reply），以检查链路的状态。</p> <p>数据传输结束后，可以由链路的一端发出<strong>终止请求</strong> LCP 分组（Terminate-Request）请求终止链路连接，在收到对方发来的<strong>终止确认</strong> LCP 分组（Terminate-Ack）后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，也会从“链路打开”<strong>状态转到</strong>“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”状态。</p> <p>图 3-12 右方的灰色方框给出了对 PPP 协议的几个状态的说明。从设备之间无链路开始，到先建立物理链路，再建立链路控制协议 LCP 链路。经过鉴别后再建立网络控制协议 NCP 链路，然后才能交换数据。由此可见，PPP协 议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p> <h2 id="三使用广播信道的数据链路层">三、使用广播信道的数据链路层</h2> <p>广播信道可以进行一对多的通信。下面要讨论的局域网使用的就是广播信道。</p> <h3 id="31-局域网的数据链路层">3.1 局域网的数据链路层</h3> <p>局域网最主要的特点是：<strong>网络为一个单位所拥有，且地理范围和站点数目均有限</strong>。在局域网刚刚出现时，局域网比广域网具有较高的数据率、较低的时延和较小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率。</p> <p>局域网可按网络拓扑进行分类。</p> <ul> <li><strong>星形网</strong>：集线器（hub）的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了非常广泛的应用。</li> <li><strong>环形网</strong>。</li> <li><strong>总线网</strong>：各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。总线网以传统以太网最为著名。</li> </ul> <p><img src="/assets/images/computer-networks/lan-topology.png" alt="局域网的拓扑"/> <em>图 3-13 局域网的拓扑</em></p> <p>局域网工作的层次跨越了数据链路层和物理层。</p> <p>共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法：</p> <ul> <li><strong>静态划分信道</strong>：如频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价较高，不适合于局域网使用。</li> <li> <p><strong>动态媒体接入控制</strong>：又称为<strong>多点接入</strong>（multiple access），其特点是信道并非在用户通信时固定分配给用户。这里又分为以下两类：</p> <ul> <li><strong>随机接入</strong>：所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生<strong>碰撞</strong>（即发生了冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</li> <li><strong>受控接入</strong>：用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询</strong>（polling），或称为<strong>轮询</strong>。</li> </ul> </li> </ul> <h4 id="适配器的作用">适配器的作用</h4> <p>计算机与外界局域网的连接是通过<strong>通信适配器</strong>（adapter，简称为“<strong>网卡</strong>”）进行的。在这种通信适配器上面装有处理器和存储器（包括 RAM 和 ROM）。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。</p> <p>适配器所实现的功能包含了数据链路层及物理层这两个层次的功能。现在的芯片的集成度都很高，以致很难把一个适配器的功能严格按照层次的关系精确划分开。</p> <p>当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。当计算机要发送 IP 数据报时，就由协议栈把 IP 数据报向下交给适配器，组装成帧后发送到局域网。图 3-15 表示适配器的作用。注意，计算机的硬件地址就在适配器的 ROM 中，而计算机的软件地址 —— IP 地址，则在计算机的存储器中。</p> <p><img src="/assets/images/computer-networks/computers-communicate-with-local-area-networks-through-adapters.png" alt="计算机通过适配器和局域网进行通信"/> <em>图 3-15 计算机通过适配器和局域网进行通信</em></p> <h3 id="32-csmacd-协议">3.2 CSMA/CD 协议</h3> <p>为了通信的简便，以太网采取了以下两种措施：</p> <p>第一，采用较为灵活的<strong>无连接</strong>的工作方式，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编号，也不要求对方发回确认。这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，<strong>以太网提供的服务是尽最大努力的交付</strong>，即<strong>不可靠的交付</strong>。当目的站收到有差错的数据帧时（例如，用 CRC 查出有差错），就把帧丢弃，其他什么也不做。<strong>对有差错帧是否需要重传则由高层来决定</strong>。例如，如果高层使用 TCP 协议，那么 TCP 就会发现丢失了一些数据。于是经过一定的时间后，TCP 就把这些数据重新传递给以太网进行重传。但<strong>以太网并不知道这是重传帧，而是当作新的数据帧来发送</strong>。</p> <p>我们知道，总线上只要有一台计算机在发送数据，总线的传输资源就被占用。因此，<strong>在同一时间只能允许一台计算机发送数据</strong>，否则各计算机之间就会互相干扰，使得所发送数据被破坏。因此，如何协调总线上各计算机的工作就是以太网要解决的一个重要问题。以太 网采用最简单的随机接入，但有很好的协议用来减少冲突发生的概率。这好比有一屋子的人在开讨论会，没有会议主持人控制发言。想发言的随时可发言，不需要举手示意。但我们还必须有个协议来协调大家的发言。这就是：如果你听见有人在发言，那么你就必须等别人讲完了才能发言（否则就干扰了别人的发言）。但有时碰巧两个或更多的人同时发言了，那么一旦发现冲突，大家都必须立即停止发言，等听到没有人发言了你再发言。以太网采用的协调方法和上面的办法非常像，它使用的协议是 CSMA/CD，意思是<strong>载波监听多点接入</strong>/<strong>碰撞检测</strong>（Carrier Sense Multiple Access with Collision Detection）。</p> <p>第二，以太网发送的数据都使用<strong>曼彻斯特编码</strong>的信号。我们知道，二进制基带数字信号通常就是高、低电压交替出现的信号。使用这种信号的最大问题就是当出现一长串的连 1 或 0 时，接收端就无法从收到的比特流中提取位同步（即比特同步）信号。如图 3-16 所示，曼彻斯特编码的编码方法是把每个码元再分成两个相等的间隔。码元 1 是前一个间隔为低电压而后一个间隔为高电压。码 0 则正好相反，从高电压变到低电压（也可采用相反的约定，即 1 是“前高后低”而 0 是“前低后高”）。这样就保证了在每个码元的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来。但是从曼彻斯特编码的波形图也不难看出其缺点，这就是它所占的频带宽度比原始的基带信号增加了一倍（因为每秒传送的码数加倍了）。</p> <p><img src="/assets/images/computer-networks/manchester-encoding.png" alt="曼彻斯特编码"/> <em>图 3-16 曼彻斯特编码</em></p> <p>下面介绍 CSMA/CD 协议的要点。</p> <ul> <li>“<strong>多点接入</strong>”就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。</li> <li>“<strong>载波监听</strong>”就是用电子技术检测总线上有没有其他计算机也在发送。其实总线上并没有什么“载波”，这里只不过借用一下“载波”这个名词而已。因此载波监听就是<strong>检测信道</strong>，这是个很重要的措施。<strong>不管在发送前，还是在发送中，每个站都必须不停地检测信道</strong>。在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。这就称为碰撞检测。</li> <li>“<strong>碰撞检测</strong>”也就是“<strong>边发送边监听</strong>”，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大（互相叠加）。当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“<strong>冲突检测</strong>”。这时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。因此，任何一个正在发送数据的站，一旦发现总线上出现了碰撞，其适配器就要立即停止发送，免得继续进行无效的发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</li> </ul> <p>既然每个站在发送数据前已经监听到信道为“空闲”，那么为什么还会出现数据在总线上的碰撞呢？这是因为电磁波在总线上总是以有限的速率传播。这和我们开讨论会时相似。一听见会场安静，我们就立即发言，但偶尔也会发生几个人同时抢着发言而产生冲突的情况。图 3-17 所示的例子可以说明这种情况。设图中的局域网两端的站 A 和 B 相距 1km，用同轴电缆相连。<strong>电磁波在 1km 电缆的传播时延约为 $5\mu s$</strong>（这个数字应当记住）。因此，A 向 B 发出的数据，在约 $5\mu s$ 后才能传送到 B。换言之，B 若在 A 发送的数据到达 B 之前发送自己的帧（因为这时 B 的载波监听检测不到 A 所发送的信息），则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。在局域网的分析中，常把总线上的<strong>单程端到端传播时延</strong>记为 $\tau$ 。发送数据的站希望尽早知道是否发生了碰撞。那么，A 发送数据后，最迟要经过<strong>两倍的总线端到端的传播时延</strong>（$2\tau$）(或总线的端到端往返传播时延)才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延（这两个站之间的距离最大）为端到端传播时延。</p> <p><img src="/assets/images/computer-networks/influence-of-propagation-delay-on-carrier-monitoring.png" alt="传播时延对载波监听的影响"/> <em>图 3-17 传播时延对载波监听的影响</em></p> <p>显然，在使用 CSMA/CD 协议时，一个站<strong>不可能同时进行发送和接收</strong>（<strong>但必须边发送边监听信道</strong>）。因此使用 CSMA/CD 协议的以太网不可能进行全双工通信而只能进行<strong>双向交替通信</strong>（<strong>半双工通信</strong>）。</p> <p>下面是图 3-17 中的一些重要的时刻。</p> <ul> <li>在 t = 0 时，A 发送数据。B 检测到信道为空闲。</li> <li>在t = $\tau$ - $\delta$ 时（这里），A 发送的数据还没有到达 B 时，由于 B 检测到信道是空闲的，因此 B 发送数据。</li> <li>经过时间 $\delta$/2 后，即在 t = $\tau$ - $\delta$/2 时，A 发送的数据和 B 发送的数据发生了碰撞。但这时 A 和 B 都不知道发生了碰撞。</li> <li>在 t = $\tau$ 时，B 检测到发生了碰撞，于是停止发送数据。</li> <li>在 t = 2$\tau$ - $\delta$ 时，A 也检测到发生了碰撞，因而也停止发送数据。</li> </ul> <p>A 和 B 发送数据均失败，它们都要推迟一段时间再重新发送。</p> <p>由此可见，<strong>每个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性</strong>。这一小段时间是<strong>不确定的</strong>，它取决于另一个发送数据的站到本站的距离。因此，以太网<strong>不能保证</strong>某一时间内一定能够把自己的数据帧成功地发送出去（因为存在产生碰撞的可能）。以太网的这一特点称为<strong>发送的不确定性</strong>。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</p> <p>从图 3-17 可看出，最先发送数据帧的 A 站，在发送数据帧后至多经过时间 $2\tau$ 就可知道所发送的数据帧是否遭受了碰撞。这就是 $\delta$ → 0 的情况。因此以太网的端到端往返时间 $2\tau$ 称为<strong>争用期</strong>（contention period），它是一个很重要的参数。争用期又称为<strong>碰撞窗口</strong>（collision window）。这是因为一个站在发送完数据后，只有通过争用期的“考验”，即<strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。这时，就可以放心把这一帧数据顺利发送完毕。</p> <p>以太网使用<strong>截断二进制指数退避</strong>（truncated binary exponential backoff）算法来确定碰撞后重传的时机。截断二进制指数退避算法并不复杂。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是<strong>推迟</strong>（这叫做<strong>退避</strong>）一个随机的时间。这点很容易理解，因为如果几个发生碰撞的站都在监听信道，那么都会同时发现信道变成了空闲。如果大家都同时再重新发送，那么肯定又会发生碰撞。为了使各站进行重传时再次发生冲突的概率减小，具体的退避算法如下：</p> <ol> <li>协议规定了基本退避时间为争用期 $2\tau$，具体的<strong>争用期时间是 $51.2\mu s$</strong>。对于 10 Mbit/s 以太网，在争用期内可发送 512 bit，即 64 字节。也可以说争用期是 <strong>512 比特时间</strong>。1 比特时间就是发送 1 比特所需的时间。所以这种时间单位与数据密切相关。为了方便，也可以<strong>直接使用比特作为争用期的单位</strong>。争用期是 512 bit，即争用期是发送 512 bit 所需的时间。 （2） 从离散的整数集合[0, 1, …, ($2^k -1$)]中随机取出一个数，记为 r。重传应推后的时间就是 r 倍的争用期。上面的参数 k 按下面的公式计算：</li> </ol> \[k = Min[重传次数，10]\] <p>可见当重传次数不超过 10 时，参数等于重传次数；但当重传次数超过 10 时，k 就不再增大而一直等于 10。 （3） 当重传达 16 次仍不能成功时（这表明同时打算发送数据的站太多，以致连续发生冲突），则丢弃该帧，并向高层报告。</p> <p>例如，在第 1 次重传时，k = 1，随机数 r 从整数 {0，1} 中选一个数。因此重传的站可选择的重传推迟时间是 0 或 $2\tau$，在这两个时间中随机选择一个。</p> <p>若再发生碰撞，则在第 2 次重传时，k = 2，随机数 r 就从整数 {0, 1, 2, 3} 中选一个数。因此重传推迟的时间是在 0，$2\tau$，$4\tau$ 和 $6\tau$ 这 4 个时间中随机选取一个。</p> <p>同样，若再发生碰撞，则重传时 k = 3，随机数 r 就从整数 {0, 1, 2, 3, 4, 5, 6, 7} 中选一个数。依此类推。</p> <p>若连续多次发生冲突，就表明可能有较多的站参与争用信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为<strong>动态退避</strong>），因而减小发生碰撞的概率，有利于整个系统的稳定。</p> <p>我们还应注意到，适配器每发送一个新的帧，就要执行一次 CSMA/CD 算法。适配器对过去发生过的碰撞并无记忆功能。因此，当好几个适配器正在执行指数退避算法时，很可能有某个适配器发送的新帧能够碰巧立即成功地插入到信道中，得到了发送权，而已经推迟好几次发送的站，有可能很不巧，还要继续执行退避算法，继续等待。</p> <p>现在考虑一种情况。某个站发送了一个很短的帧，但在发送完毕之前并没有检测出碰撞。假定这个帧在继续向前传播到达目的站之前和别的站发送的帧发生了碰撞，因而目的站将收到有差错的帧（当然会把它丢弃）。可是发送站却不知道这个帧发生了碰撞，因而不会重传这个帧。这种情况显然是我们所不希望的。为了避免发生这种情况，以太网规定了一个最短帧长 64 字节，即 512 bit。如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于 64 字节。对于 10 Mbit/s 以太网，发送 512 bit 的时间需要 $51.2\mu s$**，也就是上面提到的争用期。</p> <p>由此可见，以太网在发送数据时，如果在争用期（共发送了 64 字节）没有发生碰撞，那么后续发送的数据就一定不会发生冲突。换句话说，如果发生碰撞，就一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节，因此<strong>凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧</strong>。只要收到了这种无效帧，就应当立即将其丢弃。</p> <p>前面已经讲过，信号在以太网上传播1 km 大约需要 $5\mu s$。以太网上最大的端到端时延必须小于争用期的一半（即 $25.6\mu s$），这相当于以太网的最大端到端长度约为 5km。实际上的以太网覆盖范围远远没有这样大。因此，实用的以太网都能在争用期 $51.2\mu s$ 内检测到可能发生的碰撞。以太网的争用期确定为 $51.2\mu s$，不仅考虑到以太网的端到端时延，而且还包括其他的许多因素，如存在的转发器所增加的时延，以及下面要讲到的强化碰撞的干扰信号的持续时间等。</p> <p><strong>强化碰撞</strong>指当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送 32 比特或 48 比特的人为干扰信号（jamming signal），以便让所有用户都知道现在已经发生了碰撞（图 3-18）。对于 10 Mbit/s 以太网，发送 32（或 48） 比特只需要 3.2（或 4.8）$\mu s$。</p> <p><img src="/assets/images/computer-networks/the-addition-of-artificial-interference-signals.png" alt="人为干扰信号的加入"/> <em>图 3-18 人为干扰信号的加入</em></p> <p>从图 3-18 可以看出，A 站从发送数据开始到发现碰撞并停止发送的时间间隔是 $T_B$。A 站得知碰撞已经发生时所发送的强化碰撞的干扰信号的持续时间是 $T_J$。图中的 B 站在得知发生碰撞后，也要发送人为干扰信号，但为简单起见，图 3-18 没有画出 B 站所发送的人为干扰信号。发生碰撞使 A 浪费时间 $T_B + T_J$。可是整个信道被占用的时间还要增加一个单程端到端的传播时延 $\tau$。因此总线被占用的时间是 $T_B + T_J + \tau$。</p> <p>以太网还规定了帧间最小间隔为 $9.6\mu s$，相当于 96 比特时间。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p> <p>根据以上所讨论的，可以把 CSMA/CD 协议的要点归纳如下：</p> <ol> <li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须<strong>先检测信道</strong>。</li> <li>检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。</li> <li> <p>在发送过程中仍不停地检测信道，即网络适配器要<strong>边发送边监听</strong>。这里只有两种可能性：</p> <ul> <li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到（1）。</li> <li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤（2），继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。</li> </ul> </li> </ol> <p>以太网每发送完一帧，一定要把已发送的帧暂时保留一下。如果在争用期内检测出发生了碰撞，那么还要在推迟一段时间后再把这个暂时保留的帧重传一次。</p> <h3 id="33-使用集线器的星形拓扑">3.3 使用集线器的星形拓扑</h3> <p>传统以太网使用更便宜和更灵活的双绞线。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong>（hub），如图 3-19 所示。双绞线以太网总是和集线器配合使用。每个站需要用两对无屏蔽双绞线（放在一根电缆内），分别用于发送和接收。双绞线的两端使用 RJ-45 插头。由于集线器使用了大规模集成电路芯片，因此集线器的可靠性就大大提高了。1990 年 IEEE 制定出星形以太网 10BASE-T 的标准 802.3i。“10”代表 10 Mbit/s 的数据率，BASE 表示连接线上的信号是基带信号，T 代表双绞线。</p> <p><img src="/assets/images/computer-networks/twisted-pair-ethernet-using-a-hub.png" alt="使用集线器的双绞线以太网"/> <em>图 3-19 使用集线器的双绞线以太网</em></p> <p>但 10BASE-T 以太网的通信距离稍短，每个站到集线器的距离不超过 100m。这种性价比很高的 10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，从此以太网的拓扑就从总线型变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。</p> <p>使双绞线能够传送高速数据的主要措施是把双绞线的绞合度做得非常精确。这样不仅可使特性阻抗均匀以减少失真，而且大大减少了电磁波辐射和无线电频率的干扰。在多对双绞线的电缆中，还要使用更加复杂的绞合方法。集线器的一些特点如下：</p> <ul> <li>从表面上看，使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一个传统以太网那样运行。也就是说，<strong>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD 协议</strong>（更具体些说，是各站中的适配器执行 CSMA/CD 协议）。网络中的各站必须竞争对传输媒体的控制，并且<strong>在同一时刻至多只允许一个站发送数据</strong>。</li> <li>一个集线器有许多<strong>接口</strong>，例如 8 至 16 个，每个接口通过 RJ-45 插头（与电话机使用的插头 RJ-11 相似，但略大一些）用两对双绞线与一台计算机上的适配器相连（这种插座可连接 4 对双绞线，实际上只用 2 对，即发送和接收各使用一对双绞线）。因此，一个集线器很像一个多接口的转发器。</li> <li><strong>集线器工作在物理层</strong>，它的每个接口仅仅<strong>简单地转发比特</strong> —- 收到 1 就转发 1，收到 0 就转发 0，不进行碰撞检测。若两个接口同时有信号输入（即发生碰撞），那么所有的接口都将收不到正确的帧。图 3-20 是具有三个接口的集线器的示意图。</li> <li>集线器采用了专门的芯片，进行自适应串音回波抵消。这样就可使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰（这种干扰即近端串音）。每个比特在转发之前还要进行再生整形并重新定时。</li> </ul> <p><img src="/assets/images/computer-networks/a-hub-with-three-interfaces.png" alt="具有三个接口的集线器"/> <em>图 3-20 具有三个接口的集线器</em></p> <h3 id="34-以太网的信道利用率">3.4 以太网的信道利用率</h3> <p>假定一个 10 Mbit/s 以太网同时有 10 个站在工作，那么每个站所能发送数据的平均速率似乎应当是总数据率的 1/10（即 1Mbit/s）。其实不然，因为多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到 100%。</p> <p>图 3-21 的例子是以太网的信道被占用的情况。一个站在发送帧时出现了碰撞。经过一个争用期 $2\tau$ 后（$\tau$ 是以太网单程端到端传播时延），可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 $T_0$。它等于帧长（bit）除以发送速率（10 Mbit/s）。</p> <p><img src="/assets/images/computer-networks/the-ethernet-channel-is-occupied.png" alt="以太网的信道被占用的情况"/> <em>图 3-21 以太网的信道被占用的情况</em></p> <p>我们应当注意到，成功发送一个帧需要占用信道的时间是 $T_0 + \tau$，比这个帧的发送时间要多一个单程端到端时延。这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是 $\tau$。因此，必须在经过时间 $T_o + \tau$ 后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</p> <p>从图 3-21 可看出，要提高以太网的信道利用率，就必须减小 $\tau$ 与 $T_0$ 之比。在以太网中定义了参数 a，它是以太网单<strong>程端到端时延 $\tau$ 与帧的发送时间 $T_0$ 之比</strong>：</p> \[a = \frac{\tau}{T_0}\] <p>当 a → 0 时，表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常非常少。反之，参数 a 越大，表明争用期所占的比例越大，这就使得每发生一次碰撞就浪费了不少的信道资源，使得信道利用率明显降低。因此，以太网的参数 a 的值应当尽可能小些。从（3-2）式可看出，这就要求（3-2）式分子 $\tau$ 的数值要小些，而分母 $T_0$ 的数值要大些。这就是说，当数据率一定时，以太网的连线的长度受到限制（否则 $\tau$ 的数值会太大），同时以太网的帧长不能太短（否则 $T_0$ 的值会太小，使 a 值太大）。</p> <p>现在考虑一种理想化的情况。假定以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），并且能够非常有效地利用网络的传输资源，即总线一旦空闲就有某一个站立即发送数据。这样，发送一帧占用线路的时间是 $T_0 + \tau$，而帧本身的发送时间是 $T_0$。于是我们可计算出极限信道利用率 $S_{max}$ 为：</p> \[S{max} = \frac{T_o}{T_0 + \tau} = \frac{1}{1 + a}\] <p>上式的意义是：虽然实际的以太网不可能有这样高的极限信道利用率，但上式指出了<strong>只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率</strong>。反之，若参数 a 远大于 1（即每发生一次碰撞，就要浪费相对较多的传输数据的时间），则极限信道利用率就远小于 1，而这时实际的信道利用率就更小了。据统计，当以太网的利用率达到 30% 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p> <h3 id="35-以太网的-mac-层">3.5 以太网的 MAC 层</h3> <h4 id="1mac-层的硬件地址">（1）MAC 层的硬件地址</h4> <p>在局域网中，硬件地址又称为物理地址或 MAC 地址（因为这种地址用在 MAC 帧中）。</p> <p>IEEE 802 标准为局域网规定了一种 48 位的全球地址（一般都简称为“地址”），是指局域网上的每台计算机中<strong>固化在适配器的 ROM 中的地址</strong>。</p> <p>严格地讲，局域网的“地址”应当是每个站的“<strong>名字</strong>”或<strong>标识符</strong>[PERL00]。人们习惯于把这种 48 位的“名字”称为“地址”。</p> <p>请注意，如果连接在局域网上的主机或路由器安装有多个适配器，那么这样的主机或 路由器就有多个“地址”。更准确些说，这种48位“地址”应当是某个接口的标识符。</p> <p>现在 IEEE 的<strong>注册管理机构 RA</strong>（Registration Authority）是局域网全球地址的法定管理机构[W-IEEERA]，它负责分配地址字段的 6 个字节中的前三个字节（即高位 24 位）。世界上凡要生产局域网适配器的厂家都必须向 IEEE 购买由这三个字节构成的这个号（即地址块），这个号的正式名称是<strong>组织唯一标识符 OUI</strong>（Organizationally Unique Identifier），通常也叫做<strong>公司标识符</strong>（company_id）。地址字段中的后三个字节（即低位 24位）则由厂家自行指派，称为<strong>扩展标识符</strong>（extended identifier），只要保证生产出的适配器没有重复地址即可。可见用一个地址块可以生成 $2^{24}$ 个不同的地址。用这种方式得到的 48 位地址称为 EUI-48，这里 EUI 表示<strong>扩展的唯一标识符</strong>（Extended Unique Identifier）。EUI-48 的使用范围并不局限于局域网的硬件地址，而是可以用于软件接口。但应注意，24 位的 OUI 不能够单独用来标志一个公司，因为一个公司可能有几个 OUI，也可能有几个小公司合起来购买一个 OUI。在生产适配器时，这种 6 字节的 MAC 地址已被固化在适配器的 ROM 中。因此，MAC 地址也叫做<strong>硬件地址</strong>（hardware address）或<strong>物理地址</strong>。可见“MAC 地址”实际上就是<strong>适配器地址</strong>或<strong>适配器标识符 EUI-48</strong>。当这块适配器插入（或嵌入）到某台计算机后，适配器上的标识符 EUI-48 就成为这台计算机的 MAC 地址了。</p> <p>IEEE 规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual/Group。当 I/G 位为 0 时，地址字段表示一个<strong>单个站地址</strong>。当 I/G 位为 1 时表示组地址，用来进行多播。因此，IEEE 只分配地址字段前三个字节中的 23 位。当 I/G 位分别为 0 和 1 时，一个地址块可分别生成 $2^{24}$ 个单个站地址和 $2^{24}$ 个组地址。</p> <p>IEEE 还考虑到可能有人并不愿意向 IEEE 的 RA 购买 OUI。为此，IEEE 把地址字段第 1 字节的最低第二位规定为 G/L 位，表示 Global/Local。当 G/L 位为 0 时是全球管理（保证在全球没有相同的地址），厂商向 IEEE 购买的 OUI 都属于<strong>全球管理</strong>。当地址字段的 G/L 位为 1 时是<strong>本地管理</strong>，这时用户可任意分配网络上的地址。采用 2 字节地址字段时全都是本地管理。但应当指出，以太网几乎不理会这个 G/L 位。</p> <p>这样，在全球管理时，对每个站的地址可用 46 位的二进制数字来表示（最低位和最低第 2 位均为 0 时）。剩下的 46 位组成的地址空间可以有 $2^{46}$ 个地址，已经超过 70 万亿个，可保证世界上的每一个适配器都可有一个唯一的地址。</p> <p>当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。</p> <p>我们知道适配器有过滤功能。但适配器从网络上每收到一个 MAC 帧就先用硬件检查 MAC 帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。这里“发往本站的帧”包括以下三种帧：</p> <ul> <li><strong>单播</strong>（unicast）帧 （一对一），即收到的帧的 MAC 地址与本站的硬件地址相同。</li> <li><strong>广播</strong>（broadcast）帧（一对全体），即发送给本局域网上所有站点的帧（全 1 地址）。</li> <li><strong>多播</strong>（multicast）帧（一对多），即发送给本局域网上一部分站点的帧。</li> </ul> <p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。有的适配器可用编程方法识别多播地址。当操作系统启动时，它就把适配器初始化，使适配器能够识别某些多播地址。显然，只有目的地址才能使用广播地址和多播地址。</p> <p>以太网适配器还可设置为一种特殊的工作方式，即<strong>混杂方式</strong>（promiscuous mode）。工作在混杂方式的适配器只要“听到”有帧在以太网上传输就都悄悄地接收下来，而不管这些帧是发往哪个站。请注意，这样做实际上是“窃听”其他站点的通信而并不中断其他站点的通信。网络上的黑客（hacker 或 cracker）常利用这种方法非法获取网上用户的口令。因此，以太网上的用户不愿意网络上有工作在混杂方式的适配器。</p> <p>但混杂方式有时却非常有用。例如，网络维护和管理人员需要用这种方式来监视和分析以太网上的流量，以便找出提高网络性能的具体措施。有一种很有用的网络工具叫做<strong>嗅探器</strong>（Sniffer）就使用了设置为混杂方式的网络适配器。此外，这种嗅探器还可帮助学习网络的人员更好地理解各种网络协议的工作原理。因此，混杂方式就像一把双刃剑，是利是弊要看你怎样使用它。</p> <h4 id="2mac-帧的格式">（2）MAC 帧的格式</h4> <p>常用的以太网 MAC 帧格式有两种标准，一种是 DIX Ethernet V2 标准（即以太网 V2 标准），另一种是 IEEE 的 802.3 标准。这里只介绍使用得最多的以太网 V2 的 MAC 帧格式（图 3-22）。图中假定网络层使用的是 IP 协议。实际上使用其他的协议也是可以的。</p> <p><img src="/assets/images/computer-networks/mac-frame-format-of-ethernet-v2.png" alt="以太网 V2 的 MAC 帧格式"/> <em>图 3-22 以太网 V2 的 MAC 帧格式</em></p> <p>以太网 V2 的 MAC 帧较为简单，由五个字段组成。</p> <ol> <li>第一个字段为 6 字节长的<strong>目的地址</strong>字段。</li> <li>第二个字段为 6 字节长的<strong>源地址</strong>字段。</li> <li>第三个字段是 2 字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。例如，当类型字段的值是 0x0800 时，就表示上层使用的是 IP 数据报。若类型字段的值为 0x8137，则表示该帧是由 Novell IPX 发过来的。</li> <li>第四个字段是数据字段，其长度在 46 到 1500 字节之间（46 字节是这样得出的：最小长度 64 字节减去 18 字节的首部和尾部就得出数据字段的最小长度）。</li> <li>最后一个字段是 4 字节的帧检验序列 FCS（使用 CRC 检验）。当传输媒体的误码率为 $1 x 10^{-8}$ 时，MAC 子层可使未检测到的差错小于 $1 x 10^{-14}$。</li> </ol> <p>这里我们要指出，在以太网 V2 的 MAC 帧格式中，其首部并没有一个帧长度（或数据长度）字段。那么，MAC 子层又怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议呢？我们在前面讲述图 3-16 的曼彻斯特编码时已经讲过，这种曼彻斯特编码的一个重要特点就是：在曼彻斯特编码的每个码元（不管码元是 1 或 0）的正中间一定有一次电压的转换（从高到低或从低到高）。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了（既不发送 1，也不发送 0）。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数 4 字节（FCS 字段长度是4字节），就能确定数据字段的结束位置。</p> <p>当数据字段的长度小于 46 字节时，MAC 子层就会在数据字段的后面加入一个整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。我们应当注意到，MAC 帧的首部并没有指出数据字段的长度是多少。在有填充字段的情况下，接收端的 MAC 子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。现在的问题是：上层协议如何知道填充字段的长度呢?（IP 层应当丢弃没有用处的填充字段。可见，上层协议必须具有识别有效的数据字段长度的功能。我们知道，当上层使用 IP 协议时，其首部就有一个“总长度”字段。因此，“总长度”加上填充字段的长度，应当等于 MAC 帧数据字段的长度。例如，当 IP 数据报的总长度为 42 字节时，填充字段共有 4 字节。当 MAC 帧把 46 字节的数据上交给 IP 层后，IP 层就把其中最后 4 字节的填充字段丢弃。</p> <p>从图 3-22 可看出，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节。这是因为当一个站在刚开始接收 MAC 帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此 MAC 帧的最前面的若干位就无法接收，结果使整个的 MAC 成为无用的帧。为了接收端迅速实现同步，从 MAC 子层向下传到物理层时还要在帧的前面插入 8 字节（由硬件生成），它由两个字段构成。</p> <ul> <li>第一个字段是 7 个字节的前同步码（1 和 0 交替码），它的作用是使接收端的适配器在接收 MAC 帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现同步”（同步就是比特同步的意思）。</li> <li>第二个字段是帧开始定界符，定义为 10101011。它的前六位的作用和前同步码一样，最后的两个连续的就是告诉接收端适配器：“MAC 帧的信息马上就要来了，请适配器注意接收”。</li> </ul> <p>MAC 帧的 FCS 字段的检验范围不包括前同步码和帧开始定界符。顺便指出，在使用 SONET/SDH 进行同步传输时则不需要用前同步码，因为在同步传输时收发双方的位同步总是一直保持着的。</p> <p>还需注意，在以太网上传送数据时是以帧为单位传送的。以太网在传送帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个 MAC 帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。</p> <p>IEEE 802.3 标准规定凡出现下列情况之一的即为无效的 MAC 帧：</p> <ul> <li>帧的长度不是整数个字节。</li> <li>用收到的帧检验序列 FCS 查出有差错。</li> <li>收到的帧的 MAC 客户数据字段的长度不在 46~1500 字节之间。考虑到 MAC 帧首部和尾部的长度共有 18 字节，可以得出有效的 MAC 帧长度为 64~1518 字节之间。</li> </ul> <p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p> <p>最后要提一下，IEEE 802.3 标准规定的 MAC 帧格式与上面所讲的以太网 V2 MAC 帧格式的区别就是两个地方。</p> <p>第一，IEEE 802.3 规定的 MAC 帧的第三个字段是“长度/类型”。当这个字段值大于 0x0600 时（相当于十进制的 1536），就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。只有当这个字段值小于 0x0600 时才表示“长度”，即 MAC 帧的数据部分长度。显然，在这种情况下，若数据字段的长度与长度字段的值不一致，则该帧为无效的 MAC 帧。实际上，前面我们已经讲过，由于以太网采用了曼彻斯特编码，长度字段并无实际意义。</p> <p>第二，当“长度/类型”字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</p> <p>由于现在广泛使用的局域网只有以太网，因此 LLC 帧已经失去了原来的意义。现在市场上流行的都是以太网 V2 的 MAC 帧，但大家也常常把它称为 IEEE 802.3 标准的 MAC 帧。</p> <h2 id="四扩展的以太网">四、扩展的以太网</h2> <p>在许多情况下，我们希望对以太网的覆盖范围进行扩展。本节先讨论在物理层对以太网扩 展，然后讨论在数据链路层对以太网扩展。这种扩展的以太网在网络层看来仍然是一个网络。</p> <h3 id="41-在物理层扩展以太网">4.1 在物理层扩展以太网</h3> <p>以太网上的主机之间的距离不能太远（例如，10BASE-T 以太网的两台主机之间的距离 不超过200 米），否则主机发送的信号经过铜线的传输就会衰减到使 CSMA/CD 协议无法正 常工作。在过去广泛使用粗缆或细缆以太网时，常使用工作在物理层的转发器来扩展以太网 的地理覆盖范围。那时，两个网段可用一个转发器连接起来。IEEE 802。3 标准还规定，任意 两个站之间最多可以经过三个电缆网段。但随着双绞线以太网成为以太网的主流类型，扩展 以太网的覆盖范围已很少使用转发器了。 现在，扩展主机和集线器之间的距离的一种简单方法就是使用光纤（通常是一对光 纤）和一对光纤调制解调器，如图3-23所示。</p> <p><img src="" alt=""/> <em>图 3-23 主机使用光纤和一对光纤调制解调器连接到集线器</em></p> <p>光纤调制解调器的作用就是进行电信号和光信号的转换。由于光纤带来的时延很小， 并且带宽很宽，因此使用这种方法可以很容易地使主机和几公里以外的集线器相连接。 如果使用多个集线器，就可以连接成覆盖更大范围的多级星形结构的以太网。例如， 一个学院的三个系各有一个 10BASE-T 以太网（图3-24（a）），可通过一个主干集线器把各系 的以太网连接起来，成为一个更大的以太网（图3-24（b））。</p> <p><img src="" alt=""/> <em>图 3-24 用多个集线器连成更大的以太网</em></p> <p>这样做可以有以下两个好处。第一，使这个学院不同系的以太网上的计算机能够进行 跨系的通信。第二，扩大了以太网覆盖的地理范围。例如，在一个系的 10BASE-T 以太网 中，主机与集线器的最大距离是100m，因而两台主机之间的最大距离是200 m。但在通过 主干集线器相连接后，不同系的主机之间的距离就可扩展了，因为集线器之间的距离可以是 100m（使用双绞线）或甚至更远（如使用光纤）。 但这种多级结构的集线器以太网也带来了一些缺点。 （1） 如图 3-24（a）所示的例子，在三个系的以太网互连起来之前，每一个系的 10BASE-T 以太网是一个独立的碰撞域（collision domain，又称为冲突域），即在任一时刻，在每一个 碰撞域中只能有一个站在发送数据。每一个系的以太网的最大吞吐量是10 Mbit/s，因此三 个系总的最大吞吐量共有 30 Mbit/s。在三个系的以太网通过集线器互连起来后就把三个碰 撞域变成一个碰撞域（范围扩大到三个系），如图3-24（b）所示，而这时的最大吞吐量仍然是 一个系的吞吐量 10 Mbit/s。这就是说，当某个系的两个站在通信时所传送的数据会通过所 有的集线器进行转发，使得其他系的内部在这时都不能通信（一发送数据就会碰撞）。 （2） 如果不同的系使用不同的以太网技术（如数据率不同），那么就不可能用集线器将 它们互连起来。如果在图 3-24 中，一个系使用 10 Mbit/s 的适配器，而另外两个系使用 10/100Mbit/s 的适配器，那么用集线器连接起来后，大家都只能工作在10 Mbit/s 的速率。 集线器基本上是个多接口（即多端口）的转发器，它并不能把帧进行缓存。</p> <h3 id="42-在数据链路层扩展以太网">4.2 在数据链路层扩展以太网</h3> <p>扩展以太网更常用的方法是在数据链路层进行。最初人们使用的是网桥（bridge）。网桥 对收到的帧根据其 MAC 帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所 有的接口转发此帧，而是根据此帧的目的 MAC 地址，查找网桥中的地址表，然后确定将该 帧转发到哪一个接口，或者是把它丢弃（即过滤）。 1990 年问世的交换式集线器（switching hub），很快就淘汰了网桥。交换式集线器常称为 以太网交换机（switch）或第二层交换机（L2 switch），强调这种交换机工作在数据链路层。 “交换机”并无准确的定义和明确的概念。著名网络专家 Perlman认为：“交换机”应 当是一个市场名词，而交换机的出现的确使数据的转发更加快速了[PERL00]。本书也使用 这个广泛被接受的名词——以太网交换机。下面简单地介绍以太网交换机的特点。 1。以太网交换机的特点 以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口，和工作 在物理层的转发器、集线器有很大的差别。以太网交换机的每个接口都直接与一个单台主机 或另一个以太网交换机相连，并且一般都工作在全双工方式。以太网交换机还具有并行性， 即能同时连通多对接口，使多对主机能同时通信（而网桥只能一次分析和转发一个帧）。相 互通信的主机都是独占传输媒体，无碰撞地传输数据。 以太网交换机的接口还有存储器，能在输出端口繁忙时把到来的帧进行缓存。因此， 如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的接口 繁忙时，发送帧的这两台主机的接口会把收到的帧暂存一下，以后再发送出去。 以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过自学 习算法自动地逐渐建立起来的。以太网交换机由于使用了专用的交换结构芯片，用硬件转 发，其转发速率要比使用软件转发的网桥快很多。 以太网交换机的性能远远超过普通的集线器，而且价格并不贵，这就使工作在物理层 的集线器逐渐地退出了市场。 对于传统的 10 Mbit/s 的共享式以太网，若共有10 个用户，则每个用户占有的平均带宽 只有1Mbit/s。若使用以太网交换机来连接这些主机，虽然在每个接口到主机的带宽还是 10 Mbit/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此 对于拥有 10 个接口的交换机的总容量则为100 Mbit/s。这正是交换机的最大优点。 从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不 需要作任何改动。 以太网交换机一般都具有多种速率的接口，例如，可以具有 10 Mbit/s、100 Mbit/s 和 1 Gbit/s 的接口的各种组合，这就大大方便了各种不同情况的用户。 虽然许多以太网交换机对收到的帧采用存储转发方式进行转发，但也有一些交换机采 用直通（cut-through）的交换方式。直通交换不必把整个数据帧先缓存后再进行处理，而是在 接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的 转发速度。如果在这种交换机的内部采用基于硬件的交叉矩阵，交换时延就非常小。直通交 换的一个缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他 的站。在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线 路速率匹配、协议转换或差错检测时。现在有的厂商已生产出能支持两种交换方式的以太网 交换机。以太网交换机的发展与建筑物结构化布线系统的普及应用密切相关。在结构化布线 系统中，广泛地使用了以太网交换机。 2。以太网交换机的自学习功能 我们用一个简单例子来说明以太网交换机是怎样进行自学习的。 假定在图 3-25 中的以太网交换机有4个接口，各连接一台计算机，其MAC地址分别 是 A，B，C 和 D。在一开始，以太网交换机里面的交换表是空的（图3-25（a））。</p> <p><img src="" alt=""/> <em>图 3-25 以太网交换机中的交换表</em></p> <p>A 先向 B 发送一帧，从接口进入到交换机。交换机收到帧后，先查找交换表，没有 查到应从哪个接口转发这个帧（在 MAC 地址这一列中，找不到目的地址为 B 的项目）。接 着，交换机把这个帧的源地址 A和接口1写入交换表中，并向除接口 1 以外的所有接口广 播这个帧（这个帧就是从接口1进来的，当然不应当把它再从接口1转发出去）。 C 和 D 将丢弃这个帧，因为目的地址不对。只 B 才收下这个目的地址正确的帧。这也 称为过滤。 从新写入交换表的项目（A， 1）可以看出，以后不管从哪一个接口收到帧，只要其目的地 址是 A，就应当把收到的帧从接口 1 转发出去。这样做的依据是：既然 A 发出的帧是从接 口1进入到交换机的，那么从交换机的接口1转发出的帧也应当可以到达 A。 假定接下来 B 通过接口 3 向 A 发送一帧。交换机查找交换表，发现交换表中的 MAC 地址有 A。表明要发送给A 的帧（即目的地址为A 的帧）应从接口1转发。于是就把这个 帧传送到接口1转发给A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的 项目（B， 3），表明今后如有发送给B的帧，就应当从接口3转发出去。 经过一段时间后，只要主机 C 和 D 也向其他主机发送帧，以太网交换机中的交换表就 会把转发到C或D应当经过的接口号（24）写入到交换表中。这样，交换表中的项目就 齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口。 考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需 要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就 自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。 以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配 置，因此非常方便。 但有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的 链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈 子。我们用图 3-26 的简单例子来说明这个问题。</p> <p><img src="" alt=""/> <em>图 3-26 在两个交换机之间兜圈子的帧</em></p> <p>在图 3-26 中，假定一开始主机A通过接口交换机#1 向主机B发送一帧。交换机#1 收 到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向：离开交换机#1 的 接口 3→ 交换机#2的接口→ 接口2→ 交换机#1 的接口4→ 接口3→ 交换机#2的接口 1 这样就无限制地循环圈子下去，白白消耗了网络资源。 为了解决这种兜圈子问题，IEEE 802。1D 标准制定了一个生成树协议 STP （Spanning Tree Protocol）。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一 台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。 3。从总线以太网到星形以太网 大家知道，传统的电话网是星形结构，其中心就是电话交换机。那么在20世纪70 年 代中期出现的局域网，为什么不采用这种星形结构呢?这是因为在当时的技术条件下，还很 难用廉价的方法制造出高可靠性的以太网交换机。所以那时的以太网就采用无源的总线结 构。这种总线式以太网一问世就受到广大用户的欢迎，并获得了很快的发展。 然而随着以太网上站点数目的增多，使得总线结构以太网的可靠性下降。与此同时， 大规模集成电路以及专用芯片的发展，使得星形结构的以太网交换机可以做得既便宜又可 靠。在这种情况下，采用以太网交换机的星形结构又成为以太网的首选拓扑，而传统的总线 以太网也很快从市场上消失了。 总线以太网使用 CSMA/CD 协议，以半双工方式工作。但以太网交换机不使用共享总 线，没有碰撞问题，因此不使用CSMA/CD 协议，而是以全双工方式工作。既然连以太网的 重要协议 CSMA/CD 都不使用了（相关的“争用期”也没有了），为什么还叫做以太网呢? 原因就是它的帧结构未改变，仍然采用以太网的帧结构。</p> <h3 id="43-虚拟局域网">4.3 虚拟局域网</h3> <p>利用以太网交换机可以很方便地实现虚拟局域网VLAN （Virtual LAN）。在IEEE 802。1Q 标准中，对虚拟局域网 VLAN 是这样定义的： 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段 具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算 机属于哪一个 VLAN。 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。 图 3-27 画的是使用了四个交换机的网络拓扑。设有10台计算机分配在三个楼层中，构 成了三个局域网，即： LANı： （A1， A2， B1， Cı），LAN2： （A3， B2， Cz），LAN3： （A4，B3， C3） 但这 10 个用户划分为三个工作组，也就是说划分为三个虚拟局域网 VLAN。即： VLANı： （A1，A2，A3， A4）， VLAN2： （B1， B2， B3）; VLAN3： （C1，C2，C3）。</p> <p>图 3-27 三个虚拟局域网 VLAN、VLAN 和 VLAN 的构成</p> <p>从图 3-27 可看出，每一个VLAN 的计算机可处在不同的局域网中，也可以不在同一层 利用以太网交换机可以很方便地将这10台计算机划分为三个虚拟局域网：VLAN， VLAN， 和VLAN，。在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他成员 所发出的广播。例如，计算机 B1~B，同属于虚拟局域网 VLANz。当B，向工作组内成员发 送数据时，计算机B2和B;将会收到广播的信息，虽然它们没有和B，连在同一个以太网交 换机上。相反，B，向工作组内成员发送数据时，计算机A1，A2和C都不会收到B，发出的 广播信息，虽然他们都与B连接在同一个以太网交换机上。以太网交换机不向虚拟局域网 以外的计算机传送B的广播信息。这样，虚拟局域网限制了接收广播信息的计算机数，使 得网络不会因传播过多的广播信息（即所谓的“广播风暴”而引起性能恶化。 由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非 常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。 以太网交换机的种类很多。例如，“具有第三层特性的第二层交换机”和“多层交换 机”。前者具有某些第三层的功能，如数据报的分片和对多播通信量的管理，而后者可根据 第三层的IP 地址对分组进行过滤。 1988 年 IEEE 批准了 802。3ac标准，这个标准定义了以太网的帧格式的扩展，以便支 持虚拟局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符（见 图 3-28），称为 VLAN 标记（tag），用来指明发送该帧的计算机属于哪一个虚拟局域网。插入 VLAN 标记得出的帧称为 802。1Q 帧。显然，如果还使用原来的以太网帧格式，那么就无法 区分是否划分了虚拟局域网。图3-27 标注出在几个粗线链路上传输的帧是 802。1Q 帧。在其 他链路上传输的仍然是普通的以太网帧。 802。1Q帧 字节 6 以太网 6 4 2 46-1500 4 MAC帧目的地址 源地址 VLAN标记 类型 数据 FCS 802。1Q 标记类型 标记控制信息 10000001 00000000 VID 2 字节 2 字节 用户优先级 CFI 图 3-28 插入 VLAN 标记后变成了 802。1Q 帧 VLAN 标记字段的长度是4字节，插入在以太网 MAC 帧的源地址字段和类型字段之 间。VLAN 标记的前两个字节总是设置为0x8100（即二进制的 10000001 00000000），称为 IEEE 802。1Q 标记类型。 当数据链路层检测到 MAC 帧的源地址字段后面的两个字节的值是0x8100时，就知道 现在插入了 4 字节的 VLAN 标记。于是就接着检查后面两个字节的内容。在后面的两个字 节中，前 3 位是用户优先级字段，接着的一位是规范格式指示符 CFI （Canonical Format Indicator），最后的12位是该虚拟局域网 VLAN 标识符 VID （VLAN ID），它唯一地标志了 这个以太网帧属于哪一个 VLAN。 由于用于 VLAN 的以太网帧的首部增加了4个字节，因此以太网的最大帧长从原来的 1518 字节（1500字节的数据加上18字节的首部）变为1522 字节。</p> <h2 id="五高速以太网">五、高速以太网</h2> <p>下面简单介绍几种高速以太网技术。</p> <h3 id="51-100base-t-以太网">5.1 100BASE-T 以太网</h3> <p>100BASE-T 是在双绞线上传送 100 Mbit/s 基带信号的星形拓扑以太网，仍使用 IEEE 802。3 的 CSMA/CD 协议，它又称为快速以太网（Fast Ethernet）。用户只要使用 100 Mbit 的适 配器和 100 Mbit/s 的集线器或交换机，就可很方便地由 10BASE-T 以太网直接升级到 100 Mbit/s，而不必改变网络的拓扑结构。所有在 10BASE-T 上的应用软件和网络软件都可保持 不变。100BASE-T 的适配器有很强的自适应性，能够自动识别 10 Mbit/s 和 100 Mbit/s。 1995 年 IEEE已把100BASE-T的快速以太网定为正式标准，其代号为IEEE 802。3u，是对现 行的 IEEE 802。3 标准的补充。 100BASE-T 可使用以太网交换机提供很好的服务质量，可在全双工方式下工作而无冲 突发生。因此，CSMA/CD 协议对全双工方式工作的快速以太网是不起作用的（但在半双工 方式工作时则一定要使用 CSMA/CD 协议）。快速以太网使用的 MAC 帧格式仍然是IEEE 802。3 标准规定的帧格式。 然而 IEEE 802。3u 的标准未包括对同轴电缆的支持。这意味着想从细缆以太网升级到快速 以太网的用户必须重新布线。因此，现在 10/100 Mbit/s 以太网都使用无屏蔽双绞线布线。 100 Mbit/s 以太网的新标准改动了原 10 Mbit/s 以太网的某些规定。我们知道，以太网有 一个重要的参数 a，它必须保持为很小的数值。在3。3。4 节曾给出了参数a的公式（3-2）： τ a = T。 （3-2） 这里要是以太网单程端到端时延，是帧的发送时间。我们知道，To是帧长与发送速率 之比，可见为了保持参数a不变，可以使与发送速率的乘积不变。在帧长一定的条件下， 若数据率提高到10倍，可把网络电缆长度（因而使z）减小到原有数值的十分之一。 在 100 Mbit/s 的以太网中采用的方法是保持最短帧长不变，对于铜缆 100 Mbit/s 以太 网，一个网段的最大长度是100m，其最短帧长仍为64字节，即 512 比特。因此 100 Mbit/s 以太网的争用期是5。12 us，帧间最小间隔现在是0。96 us，都是10Mbit/s 以太网的1/10。 表 3-1 是 100 Mbit/s 以太网的新标准规定的三种不同的物理层标准。 表 3-1 100 Mbit/s 以太网的物理层标准 名称 媒体 网段最大长度 特点 100BASE-TX 铜缆 100m 两对UTP5类线或屏蔽双绞线 STP 100BASE-T4 铜缆 100m 4 对UTP 3类线或5类线 100BASE-FX 光缆 2000m 两根光纤，发送和接收各用一根 在标准中把上述的100BASE-TX 和 100BASE-FX 合在一起称为100BASE-X。 100BASE-T4 使用4对UTP3类线或5类线时，使用3对线同时传送数据（每一对线以 33号 Mbit/s 的速率传送数据），用1对线作为碰撞检测的接收信道。</p> <h3 id="52-吉比特以太网">5.2 吉比特以太网</h3> <p>吉比特以太网的产品已在1996年夏季间市。IEEE 在1997年通过了吉比特以太网的标 准 802。3z，并在1998年成为正式标准。几年来，吉比特以太网迅速占领了市场，成为以太 网的主流产品。 吉比特以太网的标准 IEEE 802。3z 有以下几个特点： （1） 允许在 1 Gbit/s 下以全双工和半双工两种方式工作。 （2） 使用 IEEE 802。3协议规定的帧格式。 （3）在半双工方式下使用CSMA/CD 协议，而在全双工方式不使用CSMA/CD 协议。 （4）与10BASE-T 和 100BASE-T 技术向后兼容。 吉比特以太网可用作现有网络的主干网，也可在高带宽（高速率）的应用场合中（如 医疗图像或CAD的图形等）用来连接计算机和服务器。 吉比特以太网的物理层使用两种成熟的技术：一种来自现有的以太网，另一种则是美 国国家标准协会ANSI 制定的光纤通道FC（Fibre Channel）。采用成熟技术就能大大缩短吉比 特以太网标准的开发时间。 表3-2 是吉比特以太网的物理层的标准。 表3-2 吉比特以太网物理层标准 名称 媒体 网段最大长度 特点 1000BASE-SX 光缆 550 m 多模光纤（50和62。5m） 1000BASE-LX 光缆 5000m 单模光纤（10um）多模光纤（50和62。5 um） 1000BASE-CX 铜缆 25 m 使用2对屏蔽双绞线电缆 STP 1000BASE-T 铜缆 100m 使用4对UTP5类线 现在 1000BASE-X（包括表3-2 中的前三项）的标准是IEEE 802。3z，而 1000BASE-T 的标准是IEEE 802。3ab。 吉比特以太网工作在半双工方式时，就必须进行碰撞检测。由于数据率提高了，因此 只有减小最大电缆长度或增大帧的最小长度，才能使参数a保持为较小的数值。若将吉比特 以太网最大电缆长度减小到10m，那么网络的实际价值就大大减小。而若将最短帧长提高 到640 字节，则在发送短数据时开销又嫌太大。因此，吉比特以太网仍然保持一个网段的最 大长度为100m，但采用了“载波延伸”（carrier extension）的办法，使最短帧长仍为64字节 （这样可以保持兼容性），同时将争用期增大为512字节。凡发送的 MAC 帧长不足 512 字 节时，就用一些特殊字符填充在帧的后面，使MAC 帧的发送长度增大到512字节，这对有 效载荷 并无影响。接收端在收到以太网的 MAC 帧后，要把所填充的特殊字符删除后才向 高层交付。当原来仅64字节长的短帧填充到512字节时，所填充的448字节就造成了很大 的开销。 为此，吉比特以太网还增加了一种功能称为分组突发（packet bursting）。这就是当很多短 帧要发送时，第一个短帧要采用上面所说的载波延伸的方法进行填充。但随后的一些短帧则 可一个接一个地发送，它们之间只需留有必要的帧间最小间隔即可。这样就形成一串分组的 突发，直到达到1500字节或稍多一些为止。当吉比特以太网工作在全双工方式时（即通信 双方可同时进行发送和接收数据），不使用载波延伸和分组突发。 吉比特以太网交换机可以直接与多个图形工作站相连。也可用作百兆以太网的主干网， 与百兆比特或吉比特交换机相连，然后再和大型服务器连接在一起。图3-29 是吉比特以太 网的一种配置举例。</p> <p><img src="" alt=""/> <em>图 3-29 吉比特以太网的配置举例</em></p> <h3 id="53-10-吉比特以太网10ge和更快的以太网">5.3 10 吉比特以太网（10GE）和更快的以太网</h3> <p>10GE 并非把吉比特以太网的速率简单地提高到10倍，因为还有许多技术上的问题要 解决。顺便指出，10吉比特就是10×10°比特，有人愿意称之为“万兆比特”。虽然“万” 是中国的一种常用的计量单位，但这与国际上通用的表示方法不一致，因此本书不予采用。 10GE 的帧格式与10Mbit/s，100 Mbit/s 和1Gbit/s 以太网的帧格式完全相同，并保留 了 802。3 标准规定的以太网最小帧长和最大帧长。这就使用户在将其已有的以太网进行升级 时，仍能和较低速率的以太网很方便地通信。 10GE 只工作在全双工方式，因此不存在争用问题，当然也不使用 CSMA/CD 协议。这 就使得 10GE 的传输距离大大提高了（因为不再受必须进行碰撞检测的限制）。 表3-3是10GE 的物理层标准。 表 3-3 10GE 的物理层标准 名称 媒体 网段最大长度 特点 10GBASE-SR 光缆 300m 多模光纤（0。85 um） 10GBASE-LR 光缆 10 km 单模光纤（1。3um） 10GBASE-ER 光缆 40 km 单模光纤（1。5um） 10GBASE-CX4 铜缆 15 m 10GBASE-T 铜缆 100m 使用 4 对双芯同轴电缆（twinax） 使用 46A 类 UTP 双绞线 表 3-3 中的前三项的标准是IEEE 802。3ae，在2002年6月完成。第四项的标准是 IEEE 802。3ak，完成于2004年。最后一项的标准是IEEE 802。3an，完成于2006年。 以太网的技术发展得很快。在10GE 之后又制定了 40GE/100GE（即40吉比特以太网 和 100 吉比特以太网）的标准 IEEE 802。3ba-2010 和 802。3bm-2015。表3-4是40GE 和 100GE 的物理层名称及传输距离，其中有两项带*号的是802。3bm 提出的。 需要指出的是，40GE/100GE 只工作在全双工的传输方式（因而不使用CSMA/CD 协 议），并且仍然保持了以太网的帧格式以及 802。3 标准规定的以太网最小和最大帧长。 100GE 在使用单模光纤传输时，仍然可以达到 40 km 的传输距离，但这需要波分复用（使 用4个波长复用一根光纤，每一个波长的有效传输速率是25Gbit/s）。</p> <p>物理层 表 3-4 40GB/100GB 以太网的物理层标准 40GB 以太网 100GB 以太网 在背板上传输至少超过1m 在铜缆上传输至少超过7m 在多模光纤上传输至少100m 在单模光纤上传输至少10km 在单模光纤上传输至少40km 40GBASE-KR4 40GBASE-CR4 40GBASE-SR4 40GBASE-LR4 *40GBASE-ER4 100GBASE-CR10 100GBASE-SR10， *100GBASE-SR4 100GBASE-LR4 100GBASE-ER4 现在以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从 而实现了端到端的以太网传输。这种工作方式的好处是： （1） 以太网是一种经过实践证明的成熟技术，无论是互联网服务提供者ISP还是端用户 都很愿意使用以太网。当然对ISP来说，使用以太网还需要在更大的范围进行试验。 （2） 以太网的互操作性也很好，不同厂商生产的以太网都能可靠地进行互操作。 （3） 在广域网中使用以太网时，其价格大约只有同步光纤网 SONET 的五分之一和异步 传递方式 ATM 的十分之一。以太网还能够适应多种传输媒体，如铜缆、双绞线以及各种光 缆。这就使具有不同传输媒体的用户在进行通信时不必重新布线。 （4） 端到端的以太网连接使帧的格式全都是以太网的格式，而不需要再进行帧的格式转 换，这就简化了操作和管理。但是，以太网和现有的其他网络，如帧中继或 ATM 网络，仍 然需要有相应的接口才能进行互连。 以太网从 10 Mbit/s 到 10 Gbit/s 甚至到100 Gbit/s 的演进，证明了以太网是： （1） 可扩展的速率从10Mbit/s 到 100 Gbit/s）。 （2） 灵活的（多种媒体、全/半双工、共享、交换）。 （3） 易于安装。 （4） 稳健性好。</p> <h3 id="54-使用以太网进行宽带接入">5.4 使用以太网进行宽带接入</h3> <p>现在人们也在使用以太网进行宽带接入互联网。为此，IEEE 在2001 年初成立了 802。3EFM 工作组，专门研究高速以太网的宽带接入技术问题。 以太网接入的一个重要特点是它可以提供双向的宽带通信，并且可以根据用户对带宽 的需求灵活地进行带宽升级（例如，把10兆的以太网交换机更新为吉比特的以太网交换 机）。当城域网和广域网都采用吉比特以太网或10 吉比特以太网时，采用以太网接入可以实 现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率且降 低了传输的成本。 然而以太网的帧格式标准中，在地址字段部分并没有用户名字段，也没有让用户键入 密码来鉴别用户身份的过程。如果网络运营商要利用以太网接入到互联网，就必须解决这个 问题。</p>]]></content><author><name></name></author></entry><entry><title type="html">计算机网络 - 应用层</title><link href="https://feng-zhang0712.github.io//blog/2024/application-layer/" rel="alternate" type="text/html" title="计算机网络 - 应用层"/><published>2024-09-15T00:00:00+00:00</published><updated>2024-09-15T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/application-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/application-layer/"><![CDATA[]]></content><author><name></name></author><category term="computer"/><category term="computer"/><category term="networks"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">计算机网络 - 运输层</title><link href="https://feng-zhang0712.github.io//blog/2024/transport-layer/" rel="alternate" type="text/html" title="计算机网络 - 运输层"/><published>2024-09-14T00:00:00+00:00</published><updated>2024-09-14T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/transport-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/transport-layer/"><![CDATA[]]></content><author><name></name></author><category term="computer"/><category term="computer"/><category term="networks"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">响应式 Web 设计</title><link href="https://feng-zhang0712.github.io//blog/2024/responsive-web-design/" rel="alternate" type="text/html" title="响应式 Web 设计"/><published>2024-09-14T00:00:00+00:00</published><updated>2024-09-14T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/responsive-web-design</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/responsive-web-design/"><![CDATA[<h2 id="一简介">一、简介</h2> <p>响应式 Web 设计，指网页内容会随着访问它的视口及设备的不同而呈现不同的样式。</p> <p>在响应式设计的早期，人们会针对不同的流行的设备宽度设置<strong>断点</strong>，所谓“断点”，就是某个宽度临界点，跨过这个点布局就会发生显著变化。显然，这并不是一个好的做法，因为这样实际上把设计跟特定的屏幕大小绑定了。既然是响应式设计，那应该与显示它的设备无关才对，而不是只在某些屏幕中才最合适。断点应该由内容和设计本身决定，也就是，根据项目的实际需求设计决定。</p> <h2 id="二媒体查询">二、媒体查询</h2> <p><strong>媒体查询</strong>（Media Queries）主要用于设计响应式 Web 设计，使网页能够适应不同的设备和屏幕尺寸。即根据设备的特性（如屏幕宽度、高度、分辨率等）应用不同的样式。W3C 对媒体查询的定义是：媒体查询包含媒体类型和零个或多个检测媒体特性的表达式（比如，<code class="language-plaintext highlighter-rouge">width</code>、<code class="language-plaintext highlighter-rouge">height</code> 和 <code class="language-plaintext highlighter-rouge">color</code> 都是可用于媒体查询的特性）。使用媒体查询，可以不必修改内容本身，而让网页适配不同的设备。</p> <p>常用媒体特性如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">width</code>：视口的宽度。</li> <li><code class="language-plaintext highlighter-rouge">height</code>：视口的高度。</li> <li><code class="language-plaintext highlighter-rouge">device-width</code>：设备屏幕的宽度。</li> <li><code class="language-plaintext highlighter-rouge">device-height</code>：设备屏幕的高度。</li> <li><code class="language-plaintext highlighter-rouge">resolution</code>：设备屏幕的分辨率，通常以 <code class="language-plaintext highlighter-rouge">dpi</code>（每英寸点数）或 <code class="language-plaintext highlighter-rouge">dppx</code>（每像素点数）表示。</li> <li><code class="language-plaintext highlighter-rouge">orientation</code>：设备的方向，可以是 <code class="language-plaintext highlighter-rouge">portrait</code> 或 <code class="language-plaintext highlighter-rouge">landscape</code>。</li> <li><code class="language-plaintext highlighter-rouge">aspect-ratio</code>：视口的宽高比。不如，16∶9 的宽屏显示器可以写成 <code class="language-plaintext highlighter-rouge">aspect-ratio: 16/9</code>。</li> <li><code class="language-plaintext highlighter-rouge">color</code>：设备的颜色位深。</li> <li><code class="language-plaintext highlighter-rouge">color-index</code>：设备颜色查找表中的条目数，值必须是数值，且不能为负。</li> <li><code class="language-plaintext highlighter-rouge">monochrome</code>：单色帧缓冲中表示每个像素的位数，值必须是数值（整数），比如 <code class="language-plaintext highlighter-rouge">monochrome: 2</code>，且不能为负。</li> <li><code class="language-plaintext highlighter-rouge">scan</code>：针对电视的逐行扫描（progressive）和隔行扫描（interlace）。例如 720p HD TV（720p 中的 <code class="language-plaintext highlighter-rouge">p</code> 表示 progressive，即逐行）可以使用 <code class="language-plaintext highlighter-rouge">scan: progressive</code> 来判断； 而 1080i HD TV（1080i 中的 <code class="language-plaintext highlighter-rouge">i</code> 表示 interlace，即隔行）可以使用 <code class="language-plaintext highlighter-rouge">scan: interlace</code> 来判断。</li> <li><code class="language-plaintext highlighter-rouge">grid</code>：设备基于栅格还是位图。</li> </ul> <p>上面列表中的特性，除 <code class="language-plaintext highlighter-rouge">grid</code> 外，都可以加上 <code class="language-plaintext highlighter-rouge">min-</code> 或 <code class="language-plaintext highlighter-rouge">max-</code> 前缀以指定范围。</p> <h3 id="21-媒体查询的语法">2.1 媒体查询的语法</h3> <p>下面是一个最简单的媒体查询语法结构。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@media</span> <span class="n">media-type</span> <span class="n">and</span> <span class="p">(</span><span class="n">media-feature</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">/* CSS规则 */</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">media-type</code>：指定设备类型，如 <code class="language-plaintext highlighter-rouge">screen</code>、<code class="language-plaintext highlighter-rouge">print</code> 等。可以省略，表示适用于所有类型（此时 <code class="language-plaintext highlighter-rouge">media-type: all</code>）。</li> <li><code class="language-plaintext highlighter-rouge">media-feature</code>：指定的媒体特性，如 <code class="language-plaintext highlighter-rouge">max-width</code>、<code class="language-plaintext highlighter-rouge">min-width</code> 等。</li> </ul> <p>也可以在 <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性中指定设备类型。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"style sheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">media=</span><span class="s">"screen"</span> <span class="na">href=</span><span class="s">"style.css"</span><span class="nt">&gt;</span> 
</code></pre></div></div> <h3 id="22-组合媒体查询">2.2 组合媒体查询</h3> <p>多个媒体查询组合，使用逗号（<code class="language-plaintext highlighter-rouge">,</code>）分隔不同的查询条件。表示如果任意一个条件为真则应用样式。还可以使用逻辑运算符 <code class="language-plaintext highlighter-rouge">and</code>、<code class="language-plaintext highlighter-rouge">or</code>、<code class="language-plaintext highlighter-rouge">not</code> 组合多个条件。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* 适用于屏幕最大宽度为600px或屏幕高度为 800px 的设备 */</span>
<span class="k">@media</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">),</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-height</span><span class="p">:</span> <span class="m">800px</span><span class="p">)</span> <span class="p">{</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">lightblue</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c">/* 适用于屏幕宽度在 600px 到 1200px 之间且横向模式的设备 */</span>
<span class="k">@media</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">min-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span> <span class="m">1200px</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">orientation</span><span class="p">:</span> <span class="nb">landscape</span><span class="p">)</span> <span class="p">{</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">lightgreen</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以在使用 <code class="language-plaintext highlighter-rouge">@import</code> 导入 CSS 时使用媒体查询，有条件地向当前样式表中加载其他样式表。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@import</span> <span class="sx">url("phone.css")</span> <span class="n">screen</span> <span class="n">and</span> <span class="p">(</span><span class="n">max-width</span><span class="p">:</span><span class="m">360px</span><span class="p">);</span> 
</code></pre></div></div> <p>上面的代码表示，<code class="language-plaintext highlighter-rouge">phone.css</code> 样式表生效的条件是：设备类型必须是屏幕设备，且视口不超过 360px。</p> <p>注意，在针对所有设备的媒体查询中，可以使用简写语法，即省略关键字 <code class="language-plaintext highlighter-rouge">all</code>（以及紧随其后的 <code class="language-plaintext highlighter-rouge">and</code>）。换句话说，如果不指定关键字，则关键字就是 <code class="language-plaintext highlighter-rouge">all</code>。</p> <h3 id="23-视口的-meta-标签">2.3 视口的 meta 标签</h3> <p>视口的 <code class="language-plaintext highlighter-rouge">meta</code> 标签，是网页与移动浏览器的接口。网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。视口的 <code class="language-plaintext highlighter-rouge">meta</code> 标签主要使用以下几个属性控制页面在移动端的行为。</p> <ul> <li><code class="language-plaintext highlighter-rouge">width</code>：用于设置页面的宽度。</li> <li><code class="language-plaintext highlighter-rouge">height</code>：用于设置页面的高度，通常设置了 <code class="language-plaintext highlighter-rouge">width</code> 就不会再设置 <code class="language-plaintext highlighter-rouge">height</code>。</li> <li><code class="language-plaintext highlighter-rouge">initial-scale</code>：设置页面的初始缩放比例。</li> <li><code class="language-plaintext highlighter-rouge">user-scalable</code>：一个布尔值，用于设置页面是否可以缩放。</li> <li><code class="language-plaintext highlighter-rouge">minimum-scale</code>：设置页面的最小缩放比例，只有在 <code class="language-plaintext highlighter-rouge">user-scalable=true</code> 时，此属性才会生效。</li> <li><code class="language-plaintext highlighter-rouge">maximum-scale</code>：设置页面的最大缩放比例，只有在 <code class="language-plaintext highlighter-rouge">user-scalable=true</code> 时，此属性才会生效。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">meta</span> <span class="nt">name</span><span class="o">=</span><span class="s1">"viewport"</span> <span class="nt">content</span><span class="o">=</span><span class="s1">"width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=0.5, maximum-scale=3"</span> <span class="o">/&gt;</span> 
</code></pre></div></div> <p>上面的代码表示，在移动设备上，页面的宽度为设备宽度，页面初始的缩放比例为 1，允许用户进行缩放操作，且最小和最大缩放比例分别为 0.5 和 3。</p> <h2 id="三弹性布局网格布局与响应式图片">三、弹性布局、网格布局与响应式图片</h2> <p>布局的传统解决方案，基于盒状模型，依赖 <code class="language-plaintext highlighter-rouge">display</code> + <code class="language-plaintext highlighter-rouge">position</code> + <code class="language-plaintext highlighter-rouge">float</code> 等属性。而现代的布局方案，更多的是使用 Flex 和 Grid 布局。下面依次对他们进行介绍。</p> <h3 id="31-盒模型">3.1 盒模型</h3> <p>CSS 盒模型指一个元素在页面上所占据的空间。由四部分组成：<code class="language-plaintext highlighter-rouge">content</code>、<code class="language-plaintext highlighter-rouge">padding</code>、<code class="language-plaintext highlighter-rouge">border</code> 和 <code class="language-plaintext highlighter-rouge">margin</code>。盒模型主要分为两种：标准盒模型和替代盒模型。</p> <p>（1）标准盒模型（content-box）</p> <p>此模型元素的 <code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code>，只包含内容的宽高，不包含 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>。 此时 <code class="language-plaintext highlighter-rouge">padding</code>、<code class="language-plaintext highlighter-rouge">border</code> 和 <code class="language-plaintext highlighter-rouge">margin</code> 都在这个盒子的外部。</p> <p>（2）替代盒模型（border-box）</p> <p>也叫 IE 盒子模型，此模型元素的 <code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code>，包含 <code class="language-plaintext highlighter-rouge">content</code>、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>。此时 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code> 都在盒子内部。</p> <p>（3）可以通过 <code class="language-plaintext highlighter-rouge">box-sizing</code> 属性，设置一个元素显示为哪种盒模型。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">box-sizing</span><span class="o">:</span> <span class="nt">content-box</span> <span class="o">(</span><span class="nt">默认</span><span class="o">)</span> <span class="o">|</span> <span class="nt">border-box</span><span class="o">;</span>
</code></pre></div></div> <h3 id="32-布局相关属性">3.2 布局相关属性</h3> <p>先介绍几个跟布局相关的属性，他们是：<code class="language-plaintext highlighter-rouge">display</code>、<code class="language-plaintext highlighter-rouge">position</code> 和 <code class="language-plaintext highlighter-rouge">z-index</code>。</p> <p>（1）<code class="language-plaintext highlighter-rouge">display</code> 属性设置元素是否被视为块级或行级盒子以及用于子元素的布局。其语法格式如下（以下只列出了 display 属性的几个常用取值）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">display</span><span class="o">:</span> <span class="nt">flex</span> <span class="o">|</span> <span class="nt">grid</span> <span class="o">|</span> <span class="nt">none</span> <span class="o">|</span> <span class="nt">block</span> <span class="o">|</span> <span class="nt">inline</span> <span class="o">|</span> <span class="nt">inline-block</span> <span class="o">|</span> <span class="nt">table</span><span class="o">;</span>
</code></pre></div></div> <p>注意区分 <code class="language-plaintext highlighter-rouge">display: none</code>、<code class="language-plaintext highlighter-rouge">visibility: hidden</code> 及 <code class="language-plaintext highlighter-rouge">opacity: 0</code> 之间的区别。</p> <ul> <li><code class="language-plaintext highlighter-rouge">display: none</code>：用于将元素完全从页面中移除，包括占用的空间。</li> <li><code class="language-plaintext highlighter-rouge">visibility: hidden</code>：用于隐藏元素，但元素占用的空间会保留，且该元素仍会影响页面布局。</li> <li><code class="language-plaintext highlighter-rouge">opacity: 0</code>：元素依然参与正常布局，且依然“可见”，只是该元素变为透明样式，但用户依然可以与其交互 ·。</li> </ul> <p>（2）<code class="language-plaintext highlighter-rouge">position</code> 属性用于指定一个元素在页面的定位方式。其语法格式如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">position</span><span class="o">:</span> <span class="nt">static</span> <span class="o">(</span><span class="nt">默认</span><span class="o">)</span> <span class="o">|</span> <span class="nt">relative</span> <span class="o">|</span> <span class="nt">absolute</span> <span class="o">|</span> <span class="nt">fixed</span> <span class="o">|</span> <span class="nt">sticky</span><span class="o">;</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">static</code>：默认值，表示元素按照正常的文档流进行布局。使用 <code class="language-plaintext highlighter-rouge">static</code> 定位的元素不会被定位偏移（此时，<code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 属性无效）。</li> <li><code class="language-plaintext highlighter-rouge">relative</code>：定位的元素相对于其正常位置进行偏移。使用 <code class="language-plaintext highlighter-rouge">relative</code> 定位的元素仍然占据原来的空间，但可以通过 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 属性进行偏移。适用于需要微调元素位置的场景。</li> <li><code class="language-plaintext highlighter-rouge">absolute</code>：定位的元素脱离正常文档流，不再占据空间。使用 <code class="language-plaintext highlighter-rouge">absolute</code> 定位的元素相对于最近的非 <code class="language-plaintext highlighter-rouge">static</code> 的祖先元素进行定位。如果没有这样的祖先元素，则相对于网页的根元素 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 进行定位。适用于需要精确定位的场景。</li> <li><code class="language-plaintext highlighter-rouge">fixed</code>：定位的元素脱离正常文档流，不再占据空间。使用 <code class="language-plaintext highlighter-rouge">fixed</code> 定位的元素相对于 视口（浏览器窗口）进行定位，即使页面滚动，其位置也不会改变。适用于需要固定位置的元素，如导航栏、工具栏等。</li> <li> <p><code class="language-plaintext highlighter-rouge">sticky</code>：定位的元素根据用户的滚动位置进行切换，介于 <code class="language-plaintext highlighter-rouge">relative</code> 和 <code class="language-plaintext highlighter-rouge">fixed</code> 之间。使用 <code class="language-plaintext highlighter-rouge">sticky</code> 定位的元素在跨越特定阈值（即 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">bottom</code> 和 <code class="language-plaintext highlighter-rouge">left</code> 设置的值）之前表现为 <code class="language-plaintext highlighter-rouge">relative</code> 定位，跨越阈值后表现为 <code class="language-plaintext highlighter-rouge">fixed</code> 定位。适用于需要在滚动时固定位置的元素，如表头、侧边栏等。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">#toolbar</span> <span class="p">{</span>
  <span class="nl">top</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="n">sticky</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码中，页面向下滚动时，<code class="language-plaintext highlighter-rouge">#toolbar</code> 的父元素开始脱离视口，一旦视口的顶部与 <code class="language-plaintext highlighter-rouge">#toolbar</code> 的距离小于 20px（门槛值），<code class="language-plaintext highlighter-rouge">#toolbar</code> 就自动变为 <code class="language-plaintext highlighter-rouge">fixed</code> 定位，保持与视口顶部 20px 的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），<code class="language-plaintext highlighter-rouge">#toolbar</code> 恢复成 <code class="language-plaintext highlighter-rouge">relative</code> 定位。</p> </li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">z-index</code> 属性用于控制重叠元素的层叠顺序。</p> <p><code class="language-plaintext highlighter-rouge">z-index</code> 只有在 <code class="language-plaintext highlighter-rouge">position</code> 属性值为 <code class="language-plaintext highlighter-rouge">relative</code>、<code class="language-plaintext highlighter-rouge">absolute</code>、<code class="language-plaintext highlighter-rouge">fixed</code> 或 <code class="language-plaintext highlighter-rouge">sticky</code> 时才有效。<code class="language-plaintext highlighter-rouge">z-index</code> 的值可以是正整数、负整数或零，值越大，元素的层级越高。</p> <h3 id="33-flex-布局">3.3 Flex 布局</h3> <p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span><span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 也可以为行内元素开启 Flex 布局 */</span>
<span class="nc">.box</span><span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意，设为 Flex 布局以后，子元素的 <code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">clear</code> 和 <code class="language-plaintext highlighter-rouge">vertical-align</code> 属性将失效。</p> <h4 id="331-基本概念">3.3.1 基本概念</h4> <p>采用 Flex 布局的元素，称为 Flex <strong>容器</strong>（container）。它的所有子元素自动成为容器成员，称为 Flex <strong>项目</strong>（item）。</p> <p>容器默认存在两根轴：水平的<strong>主轴</strong>（main axis）和垂直的<strong>交叉轴</strong>（cross axis）。主轴的开始位置（与边框的交叉点）叫做 <strong>main start</strong>，结束位置叫做 <strong>main end</strong>；交叉轴的开始位置叫做 <strong>cross start</strong>，结束位置叫做 <strong>cross end</strong>。</p> <p><strong>项目默认沿主轴排列</strong>。单个项目占据的主轴空间叫做 <strong>main size</strong>，占据的交叉轴空间叫做 <strong>cross size</strong>。</p> <h4 id="332-容器的属性">3.3.2 容器的属性</h4> <p>作用在容器上的属性有 6 个：<code class="language-plaintext highlighter-rouge">flex-direction</code>、<code class="language-plaintext highlighter-rouge">flex-wrap</code>、<code class="language-plaintext highlighter-rouge">flex-flow</code>、<code class="language-plaintext highlighter-rouge">justify-content</code>、<code class="language-plaintext highlighter-rouge">align-items</code> 和 <code class="language-plaintext highlighter-rouge">align-content</code>。下面，依次对他们进行讲解。</p> <p>（1）<code class="language-plaintext highlighter-rouge">flex-direction</code>：用于决定主轴的方向（即项目的排列方向）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">row</span> <span class="err">|</span> <span class="n">row-reverse</span> <span class="err">|</span> <span class="n">column</span> <span class="err">|</span> <span class="n">column-reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="flex-direction 属性"/></p> <ul> <li><code class="language-plaintext highlighter-rouge">row</code>（默认值）：主轴为水平方向，起点在左端。</li> <li><code class="language-plaintext highlighter-rouge">row-reverse</code>：主轴为水平方向，起点在右端。</li> <li><code class="language-plaintext highlighter-rouge">column</code>：主轴为垂直方向，起点在上沿。</li> <li><code class="language-plaintext highlighter-rouge">column-reverse</code>：主轴为垂直方向，起点在下沿。</li> </ul> <p>（2）<code class="language-plaintext highlighter-rouge">flex-wrap</code>：默认情况下，项目都排在一条线（又称”轴线”）上。<code class="language-plaintext highlighter-rouge">flex-wrap</code> 属性定义，如果一条轴线排不下，如何换行。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span><span class="p">{</span>
  <span class="nl">flex-wrap</span><span class="p">:</span> <span class="nb">nowrap</span> <span class="err">|</span> <span class="n">wrap</span> <span class="err">|</span> <span class="n">wrap-reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">nowrap</code>（默认）：不换行。</li> <li><code class="language-plaintext highlighter-rouge">wrap</code>：换行，第一行在上方。</li> <li><code class="language-plaintext highlighter-rouge">wrap-reverse</code>：换行，第一行在下方。</li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">flex-flow</code>：<code class="language-plaintext highlighter-rouge">flex-direction</code> 属性和 <code class="language-plaintext highlighter-rouge">flex-wrap</code> 属性的简写形式，默认值为 <code class="language-plaintext highlighter-rouge">row nowrap</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">flex-flow</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">flex-direction</span><span class="err">&gt;</span> <span class="err">||</span> <span class="err">&lt;</span><span class="n">flex-wrap</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（4）<code class="language-plaintext highlighter-rouge">justify-content</code>：定义项目在主轴上的对齐方式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-around</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="justify-content 属性"/></p> <p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>（默认值）：左对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：右对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>： 居中。</li> <li><code class="language-plaintext highlighter-rouge">space-between</code>：两端对齐，项目之间的间隔都相等。</li> <li><code class="language-plaintext highlighter-rouge">space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li> </ul> <p>（5）<code class="language-plaintext highlighter-rouge">align-items</code>：定义项目在交叉轴上的对齐方式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="nb">baseline</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="align-items 属性"/></p> <p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>：交叉轴的起点对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：交叉轴的终点对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：交叉轴的中点对齐。</li> <li><code class="language-plaintext highlighter-rouge">baseline</code>: 项目的第一行文字的基线对齐。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>（默认值）：如果项目未设置高度或设为 <code class="language-plaintext highlighter-rouge">auto</code>，将占满整个容器的高度。</li> </ul> <p>（6）align-content：定义多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.box</span> <span class="p">{</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="align-content 属性"/></p> <ul> <li><code class="language-plaintext highlighter-rouge">flex-start</code>：与交叉轴的起点对齐。</li> <li><code class="language-plaintext highlighter-rouge">flex-end</code>：与交叉轴的终点对齐。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：与交叉轴的中点对齐。</li> <li><code class="language-plaintext highlighter-rouge">space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li> <li><code class="language-plaintext highlighter-rouge">space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>（默认值）：轴线占满整个交叉轴。</li> </ul> <h4 id="333-项目的属性">3.3.3 项目的属性</h4> <p>作用在项目上的属性有 6 个：<code class="language-plaintext highlighter-rouge">order</code>、<code class="language-plaintext highlighter-rouge">flex-grow</code>、<code class="language-plaintext highlighter-rouge">flex-shrink</code>、<code class="language-plaintext highlighter-rouge">flex-basis</code>、<code class="language-plaintext highlighter-rouge">flex</code> 和 <code class="language-plaintext highlighter-rouge">align-self</code>。下面，依次对他们进行讲解。</p> <p>（1）<code class="language-plaintext highlighter-rouge">order</code>：定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">order</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">integer</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">flex-grow</code>：定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-grow</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">number</span><span class="err">&gt;</span><span class="p">;</span> <span class="c">/* default 0 */</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果所有项目的 <code class="language-plaintext highlighter-rouge">flex-grow</code> 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code class="language-plaintext highlighter-rouge">flex-grow</code> 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p> <p>（3）<code class="language-plaintext highlighter-rouge">flex-shrink</code>：定义项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-shrink</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">number</span><span class="err">&gt;</span><span class="p">;</span> <span class="c">/* default 1 */</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果所有项目的 <code class="language-plaintext highlighter-rouge">flex-shrink</code> 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 <code class="language-plaintext highlighter-rouge">flex-shrink</code> 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</p> <p>（4）<code class="language-plaintext highlighter-rouge">flex-basis</code>：定义在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 <code class="language-plaintext highlighter-rouge">auto</code>，即项目的本来大小。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">flex-basis</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">length</span><span class="err">&gt;</span> <span class="err">|</span> <span class="nb">auto</span><span class="p">;</span> <span class="c">/* default auto */</span>
<span class="p">}</span>
</code></pre></div></div> <p>它可以设为跟 <code class="language-plaintext highlighter-rouge">width</code> 或 <code class="language-plaintext highlighter-rouge">height</code> 属性一样的值（比如 350px），则项目将占据固定空间。</p> <p>（5）<code class="language-plaintext highlighter-rouge">flex</code>：<code class="language-plaintext highlighter-rouge">flex-grow</code>, <code class="language-plaintext highlighter-rouge">flex-shrink</code> 和 <code class="language-plaintext highlighter-rouge">flex-basis</code> 的简写，默认值为 <code class="language-plaintext highlighter-rouge">0 1 auto</code>。后两个属性可选。</p> <p>该属性有两个快捷值：<code class="language-plaintext highlighter-rouge">auto</code> (<code class="language-plaintext highlighter-rouge">1 1 auto</code>) 和 <code class="language-plaintext highlighter-rouge">none</code> (<code class="language-plaintext highlighter-rouge">0 0 auto</code>)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p> <p>（6）<code class="language-plaintext highlighter-rouge">align-self</code>：<code class="language-plaintext highlighter-rouge">align-self</code> 属性允许单个项目有与其他项目有不一样的对齐方式，可覆盖 <code class="language-plaintext highlighter-rouge">align-items</code> 属性。默认值为 <code class="language-plaintext highlighter-rouge">auto</code>，表示继承父元素的 <code class="language-plaintext highlighter-rouge">align-items</code> 属性，如果没有父元素，则等同于 <code class="language-plaintext highlighter-rouge">stretch</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="nb">auto</span> <span class="err">|</span> <span class="n">flex-start</span> <span class="err">|</span> <span class="n">flex-end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="nb">baseline</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="align-self 属性"/></p> <p>该属性可能取 6 个值，除了 <code class="language-plaintext highlighter-rouge">auto</code>，其他都与 <code class="language-plaintext highlighter-rouge">align-items</code> 属性完全一致。</p> <h3 id="34-grid-布局">3.4 Grid 布局</h3> <p>网格布局（Grid）将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p> <p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”<strong>行</strong>“和”<strong>列</strong>“，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。</p> <h4 id="341-基本概念">3.4.1 基本概念</h4> <p>（1）采用网格布局的区域，称为<strong>容器</strong>（container）。容器内部采用网格定位的子元素，称为<strong>项目</strong>（item）。</p> <p>注意：项目只能是容器的<strong>顶层子元素</strong>，不包含项目的子元素。Grid 布局只对项目生效。</p> <p>（2）容器里面的水平区域称为”<strong>行</strong>“（row），垂直区域称为”<strong>列</strong>“（column）。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032502.png" alt="Grid 布局的行和列"/></p> <p>（3）行和列的交叉区域，称为”<strong>单元格</strong>“（cell）。正常情况下，<code class="language-plaintext highlighter-rouge">n</code> 行和 <code class="language-plaintext highlighter-rouge">m</code> 列会产生 <code class="language-plaintext highlighter-rouge">n x m</code> 个单元格。比如，3 行 3 列会产生 9 个单元格。</p> <p>（4）划分网格的线，称为”<strong>网格线</strong>“（grid line）。水平网格线划分出行，垂直网格线划分出列。</p> <p>正常情况下，<code class="language-plaintext highlighter-rouge">n</code> 行有 <code class="language-plaintext highlighter-rouge">n + 1</code> 根水平网格线，<code class="language-plaintext highlighter-rouge">m</code> 列有 <code class="language-plaintext highlighter-rouge">m + 1</code> 根垂直网格线，比如三行就有四根水平网格线。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032503.png" alt="Grid 布局的网格线"/></p> <p>上图是一个 4 x 4 的网格，共有 5 根水平网格线和 5 根垂直网格线。</p> <h4 id="342-容器属性">3.4.2 容器属性</h4> <p>（1）<code class="language-plaintext highlighter-rouge">display: grid</code>：指定一个容器采用网格布局。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032504.png" alt="display: grid 的效果"/></p> <p>上图是 <code class="language-plaintext highlighter-rouge">display: grid</code> 的<a href="https://jsbin.com/guvivum/edit?html,css,output">效果</a>。</p> <p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-grid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032505.png" alt="display: inline-grid 的效果"/></p> <p>上图是 <code class="language-plaintext highlighter-rouge">display: inline-grid</code> 的<a href="https://jsbin.com/qatitav/edit?html,css,output">效果</a>。</p> <p>注意，设为网格布局以后，容器子元素（项目）的 <code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">display: inline-block</code>、<code class="language-plaintext highlighter-rouge">display: table-cell</code>、<code class="language-plaintext highlighter-rouge">vertical-align</code> 和 <code class="language-plaintext highlighter-rouge">column-*</code> 等设置都将失效。</p> <p>（2）<code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性、<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性定义每列的列宽，<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性定义每行的行高。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/qiginur/edit?css,output">上面代码</a>指定了一个三行三列的网格，列宽和行高都是 100px。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032506.png" alt="grid-template-rows 属性，grid-template-columns 属性"/></p> <p>除了使用<strong>绝对单位</strong>，也可以使用<strong>百分比</strong>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">33.33%</span> <span class="m">33.33%</span> <span class="m">33.33%</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">33.33%</span> <span class="m">33.33%</span> <span class="m">33.33%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">repeat()</code>：函数用于重复一组值。上面的代码用 <code class="language-plaintext highlighter-rouge">repeat()</code> 改写如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">33.33%</span><span class="p">);</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">33.33%</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">repeat()</code> 接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。<code class="language-plaintext highlighter-rouge">repeat()</code> 也可以重复某种模式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="err">2</span><span class="o">,</span> <span class="err">100</span><span class="nt">px</span> <span class="err">20</span><span class="nt">px</span> <span class="err">80</span><span class="nt">px</span><span class="o">);</span>
</code></pre></div> </div> <p>上面代码定义了 6 列，第一列和第四列的宽度为 100px，第二列和第五列为 20px，第三列和第六列为 80px。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032507.png" alt="repeat() 重复某种模式"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">auto-fill</code> 关键字：表示自动填充。有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每行（或每列）容纳尽可能多的单元格，这时可以使用 <code class="language-plaintext highlighter-rouge">auto-fill</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">(</span><span class="n">auto-fill</span><span class="p">,</span> <span class="m">100px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p><a href="https://jsbin.com/himoku/edit?css,output">上面代码</a>表示每列宽度 100px，然后自动填充，直到容器不能放置更多的列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032508.png" alt="auto-fill"/></p> <p>除了 <code class="language-plaintext highlighter-rouge">auto-fill</code>，还有一个关键字 <code class="language-plaintext highlighter-rouge">auto-fit</code>，两者的行为基本是相同的。只有当容器足够宽，可以在一行容纳所有单元格，并且单元格宽度不固定的时候，才会有行为差异：<code class="language-plaintext highlighter-rouge">auto-fill</code> 会用空格子填满剩余宽度，<code class="language-plaintext highlighter-rouge">auto-fit</code> 则会尽量扩大单元格的宽度。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">fr</code>（fraction 的缩写，意为”片段”）关键字：用于表示比例关系。如果两列的宽度分别为 1fr 和 2fr，就表示后者是前者的两倍。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">1</span><span class="n">fr</span> <span class="m">1</span><span class="n">fr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p><a href="https://jsbin.com/hadexek/edit?html,css,output">上面代码</a>表示两个相同宽度的列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/1_bg2019032509.png" alt="fr 表示的相同宽度的列"/></p> <p><code class="language-plaintext highlighter-rouge">fr</code> 可以与绝对长度的单位结合使用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">150px</span> <span class="m">1</span><span class="n">fr</span> <span class="m">2</span><span class="n">fr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码表示，第一列的宽度为 150px，第二列的宽度是第三列的一半。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032510.png" alt="fr 与绝对长度的单位结合使用"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">minmax()</code>：此函数用于产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="err">1</span><span class="nt">fr</span> <span class="err">1</span><span class="nt">fr</span> <span class="nt">minmax</span><span class="o">(</span><span class="err">100</span><span class="nt">px</span><span class="o">,</span> <span class="err">1</span><span class="nt">fr</span><span class="o">);</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">minmax(100px, 1fr)</code> 表示列宽不小于 100px，不大于 1fr。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">auto</code> 关键字：表示由浏览器自己决定长度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="err">100</span><span class="nt">px</span> <span class="nt">auto</span> <span class="err">100</span><span class="nt">px</span><span class="o">;</span>
</code></pre></div> </div> <p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了 <code class="language-plaintext highlighter-rouge">min-width</code>，且这个值大于最大宽度。</p> </li> <li> <p>网格线的名称：<code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-template-rows</code> 属性里面，还可以使用方括号，指定每根网格线的名字，方便以后的引用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">c3</span><span class="p">]</span> <span class="nb">auto</span> <span class="p">[</span><span class="n">c4</span><span class="p">];</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="m">100px</span> <span class="p">[</span><span class="n">r3</span><span class="p">]</span> <span class="nb">auto</span> <span class="p">[</span><span class="n">r4</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码指定网格布局为 3 行 x 3 列，因此有 4 根垂直网格线和 4 根水平网格线。方括号里面依次是这八根线的名字。</p> <p>网格布局允许同一根线有多个名字，比如 <code class="language-plaintext highlighter-rouge">[fifth-line row-5]</code>。</p> </li> <li> <p>布局实例</p> <p><code class="language-plaintext highlighter-rouge">grid-template-columns</code> 属性对于网页布局非常有用。两栏式布局只需要一行代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.wrapper</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">70%</span> <span class="m">30%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码将左边栏设为 70%，右边栏设为 30%。传统的十二网格布局，写起来也很容易。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="err">12</span><span class="o">,</span> <span class="err">1</span><span class="nt">fr</span><span class="o">);</span>
</code></pre></div> </div> </li> </ul> <p>（3）<code class="language-plaintext highlighter-rouge">grid-row-gap</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 属性、<code class="language-plaintext highlighter-rouge">grid-gap</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-row-gap</code> 属性设置行与行的间隔（行间距），<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 属性设置列与列的间隔（列间距）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">grid-row-gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="py">grid-column-gap</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/mezufab/edit?css,output">上面代码</a>中，<code class="language-plaintext highlighter-rouge">grid-row-gap</code> 用于设置行间距，grid-column-gap 用于设置列间距。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032511.png" alt="grid-row-gap 属性、grid-column-gap 属性"/></p> <p><code class="language-plaintext highlighter-rouge">grid-gap</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-column-gap</code> 和 <code class="language-plaintext highlighter-rouge">grid-row-gap</code> 的合并简写形式，语法如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-gap</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">grid-row-gap</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">grid-column-gap</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>因此，上面一段 CSS 代码等同于下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">grid-gap</span><span class="p">:</span> <span class="m">20px</span> <span class="m">20px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">grid-gap</code> 省略了第二个值，浏览器认为第二个值等于第一个值。</p> <p>注意，根据最新标准，上面三个属性名的 <code class="language-plaintext highlighter-rouge">grid-</code> 前缀已经删除，<code class="language-plaintext highlighter-rouge">grid-column-gap</code> 和 <code class="language-plaintext highlighter-rouge">grid-row-gap</code> 写成 column-gap 和 <code class="language-plaintext highlighter-rouge">row-gap</code>，<code class="language-plaintext highlighter-rouge">grid-gap</code> 写成 <code class="language-plaintext highlighter-rouge">gap</code>。</p> <p>（4）<code class="language-plaintext highlighter-rouge">grid-template-areas</code> 属性</p> <p>网格布局允许指定”<strong>区域</strong>“（area），一个区域由单个或多个单元格组成。<code class="language-plaintext highlighter-rouge">grid-template-areas</code> 属性用于定义区域。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-areas</span><span class="p">:</span> <span class="s2">'a b c'</span>
                       <span class="s2">'d e f'</span>
                       <span class="s2">'g h i'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码先划分出 9 个单元格，然后将其定名为 <code class="language-plaintext highlighter-rouge">a</code> 到 <code class="language-plaintext highlighter-rouge">i</code> 的九个区域，分别对应这九个单元格。</p> <p>多个单元格合并成一个区域的写法如下。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s2">'a a a'</span>
                     <span class="s2">'b b b'</span>
                     <span class="s2">'c c c'</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码将9个单元格分成 <code class="language-plaintext highlighter-rouge">a</code>、<code class="language-plaintext highlighter-rouge">b</code>、<code class="language-plaintext highlighter-rouge">c</code> 三个区域。</p> <p>下面是一个布局实例。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s1">"header header header"</span>
                     <span class="s1">"main main sidebar"</span>
                     <span class="s1">"footer footer footer"</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码中，顶部是页眉区域 <code class="language-plaintext highlighter-rouge">header</code>，底部是页脚区域 <code class="language-plaintext highlighter-rouge">footer</code>，中间部分则为 <code class="language-plaintext highlighter-rouge">main</code> 和 <code class="language-plaintext highlighter-rouge">sidebar</code>。</p> <p>如果某些区域不需要利用，则使用”点”（<code class="language-plaintext highlighter-rouge">.</code>）表示。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-template-areas</span><span class="o">:</span> <span class="s2">'a . c'</span>
                     <span class="s2">'d . f'</span>
                     <span class="s2">'g . i'</span><span class="o">;</span>
</code></pre></div></div> <p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p> <p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名 <code class="language-plaintext highlighter-rouge">-start</code>，终止网格线自动命名为区域名 <code class="language-plaintext highlighter-rouge">-end</code>。比如，区域名为 <code class="language-plaintext highlighter-rouge">header</code>，则起始位置的水平网格线和垂直网格线叫做 <code class="language-plaintext highlighter-rouge">header-start</code>，终止位置的水平网格线和垂直网格线叫做 <code class="language-plaintext highlighter-rouge">header-end</code>。</p> <p>（5）<code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性</p> <p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032506.png" alt="子元素排列顺序"/></p> <p>这个顺序由 <code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性决定，默认值是 <code class="language-plaintext highlighter-rouge">row</code>，即”<strong>先行后列</strong>“。也可以将它设成 <code class="language-plaintext highlighter-rouge">column</code>，变成”<strong>先列后行</strong>“。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">column</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/xutokec/edit?css,output">上面代码</a>设置了 <code class="language-plaintext highlighter-rouge">column</code> 以后，放置顺序就变成了下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032512.png" alt="按照 column 方式排列"/></p> <p><code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性除了设置成 <code class="language-plaintext highlighter-rouge">row</code> 和 <code class="language-plaintext highlighter-rouge">column</code>，还可以设成 <code class="language-plaintext highlighter-rouge">row dense</code> 和 <code class="language-plaintext highlighter-rouge">column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p> <p><a href="https://jsbin.com/wapejok/edit?css,output">下面的例子</a>让 1 号项目和 2 号项目各占据两个单元格，然后在默认的 grid-auto-flow: row 情况下，会产生下面这样的布局。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032513.png" alt="grid-auto-flow: row 时，元素的排列方式"/></p> <p>上图中，1 号项目后面的位置是空的，这是因为 3 号项目默认跟着 2 号项目，所以会排在 2 号项目后面。</p> <p>现在修改设置，设为 <code class="language-plaintext highlighter-rouge">row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">row</span> <span class="nt">dense</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/helewuy/edit?css,output">上面代码</a>的效果如下。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032514.png" alt="grid-auto-flow: row dense 时，元素的排列方式"/></p> <p>上图会先填满第一行，再填满第二行，所以 3 号项目会紧跟在 1 号项目的后面。8 号项目和 9 号项目就会排到第四行。</p> <p>如果将设置改为 <code class="language-plaintext highlighter-rouge">column dense</code>，表示”先列后行”，并且尽量填满空格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">grid-auto-flow</span><span class="o">:</span> <span class="nt">column</span> <span class="nt">dense</span><span class="o">;</span>
</code></pre></div></div> <p><a href="https://jsbin.com/pupoduc/1/edit?html,css,output">上面代码</a>的效果如下。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032515.png" alt="grid-auto-flow: column dense 时，元素的排列方式"/></p> <p>上图会先填满第一列，再填满第 2 列，所以 3 号项目在第一列，4 号项目在第二列。8 号项目和 9 号项目被挤到了第四列。</p> <p>（6）<code class="language-plaintext highlighter-rouge">justify-items</code> 属性、<code class="language-plaintext highlighter-rouge">align-items</code> 属性、<code class="language-plaintext highlighter-rouge">place-items</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">justify-items</code> 属性设置单元格内容的<strong>水平位置</strong>（左中右），<code class="language-plaintext highlighter-rouge">align-items</code> 属性设置单元格内容的<strong>垂直位置</strong>（上中下）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">justify-items</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性的写法完全相同，都可以取下面这些值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">start</code>：对齐单元格的起始边缘。</li> <li><code class="language-plaintext highlighter-rouge">end</code>：对齐单元格的结束边缘。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：单元格内部居中。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="py">justify-items</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/gijeqej/edit?css,output">上面代码</a>表示，单元格的内容左对齐，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032516.png" alt="justify-items: start 的效果"/></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/tecawur/edit?css,output">上面代码</a>表示，单元格的内容头部对齐，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032517.png" alt="align-items: start 的效果"/></p> <p><code class="language-plaintext highlighter-rouge">place-items</code> 属性是 <code class="language-plaintext highlighter-rouge">align-items</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-items</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-items</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-items</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-items</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>如果省略第二个值，则浏览器认为与第一个值相等。</p> <p>（7）<code class="language-plaintext highlighter-rouge">justify-content</code> 属性、<code class="language-plaintext highlighter-rouge">align-content</code> 属性、<code class="language-plaintext highlighter-rouge">place-content</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">justify-content</code> 属性是整个内容区域在容器里面的<strong>水平位置</strong>（左中右），<code class="language-plaintext highlighter-rouge">align-content</code> 属性是整个内容区域的<strong>垂直位置</strong>（上中下）。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-evenly</span><span class="p">;</span>
  <span class="nl">align-content</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span> <span class="err">|</span> <span class="n">space-around</span> <span class="err">|</span> <span class="n">space-between</span> <span class="err">|</span> <span class="n">space-evenly</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以 <code class="language-plaintext highlighter-rouge">justify-content</code> 属性为例，<code class="language-plaintext highlighter-rouge">align-content</code> 属性的图完全一样，只是将水平方向改成垂直方向。）</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">start</code> - 对齐容器的起始边框。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032519.png" alt="justify-content: start 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">end</code> - 对齐容器的结束边框。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032518.png" alt="justify-content: end 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">center</code> - 容器内部居中。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032520.png" alt="justify-content: center 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">stretch</code> - 项目大小没有指定时，拉伸占据整个网格容器。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032521.png" alt="justify-content: stretch 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-around</code> - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032522.png" alt="justify-content: space-around 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-between</code> - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032523.png" alt="justify-content: space-between 的效果"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">space-evenly</code> - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032524.png" alt="justify-content: space-evenly 的效果"/></p> </li> </ul> <p><code class="language-plaintext highlighter-rouge">place-content</code> 属性是 <code class="language-plaintext highlighter-rouge">align-content</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-content</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-content</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-content</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-content</span><span class="o">&gt;</span>
</code></pre></div></div> <p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p> <p>（8）<code class="language-plaintext highlighter-rouge">grid-auto-columns</code> 属性、<code class="language-plaintext highlighter-rouge">grid-auto-rows</code> 属性</p> <p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p> <p><code class="language-plaintext highlighter-rouge">grid-auto-columns</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-auto-rows</code> 属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与 <code class="language-plaintext highlighter-rouge">grid-template-columns</code> 和 <code class="language-plaintext highlighter-rouge">grid-template-rows</code> 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p> <p><a href="https://jsbin.com/sayuric/edit?css,output">下面的例子</a>里面，划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">grid</span><span class="p">;</span>
  <span class="py">grid-template-columns</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-template-rows</span><span class="p">:</span> <span class="m">100px</span> <span class="m">100px</span> <span class="m">100px</span><span class="p">;</span>
  <span class="py">grid-auto-rows</span><span class="p">:</span> <span class="m">50px</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面代码指定新增的行高统一为 50px（原始的行高为 100px）。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032525.png" alt="grid-auto-columns 属性、grid-auto-rows 属性"/></p> <p>（9）<code class="language-plaintext highlighter-rouge">grid-template</code> 属性、<code class="language-plaintext highlighter-rouge">grid</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-template</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-template-columns</code>、<code class="language-plaintext highlighter-rouge">grid-template-rows</code> 和 <code class="language-plaintext highlighter-rouge">grid-template-areas</code> 这三个属性的合并简写形式。</p> <p>grid 属性是 <code class="language-plaintext highlighter-rouge">grid-template-rows</code>、<code class="language-plaintext highlighter-rouge">grid-template-columns</code>、<code class="language-plaintext highlighter-rouge">grid-template-areas</code>、<code class="language-plaintext highlighter-rouge">grid-auto-rows</code>、<code class="language-plaintext highlighter-rouge">grid-auto-columns</code>、<code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 这六个属性的合并简写形式。</p> <p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p> <h4 id="343-项目属性">3.4.3 项目属性</h4> <p>（1）<code class="language-plaintext highlighter-rouge">grid-column-start</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column-end</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row-start</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row-end</code> 属性、<code class="language-plaintext highlighter-rouge">grid-column</code> 属性、<code class="language-plaintext highlighter-rouge">grid-row</code> 属性</p> <p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p> <ul> <li><code class="language-plaintext highlighter-rouge">grid-column-start</code>：左边框所在的垂直网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-column-end</code>：右边框所在的垂直网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-row-start</code>：上边框所在的水平网格线</li> <li><code class="language-plaintext highlighter-rouge">grid-row-end</code>：下边框所在的水平网格线</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/yukobuf/edit?css,output">上面代码</a>指定，1 号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032526.png" alt="grid-column-start: 2且grid-column-end: 4时的效果"/></p> <p>上图中，只指定了 1 号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p> <p>除了 1 号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的 <code class="language-plaintext highlighter-rouge">grid-auto-flow</code> 属性决定，这个属性的默认值是 <code class="language-plaintext highlighter-rouge">row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成 <code class="language-plaintext highlighter-rouge">column</code>、<code class="language-plaintext highlighter-rouge">row dense</code> 和 <code class="language-plaintext highlighter-rouge">column dense</code>，看看其他项目的位置发生了怎样的变化。</p> <p><a href="https://jsbin.com/nagobey/edit?html,css,output">下面的例子</a>是指定四个边框位置的效果。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">3</span><span class="p">;</span>
  <span class="py">grid-row-start</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="py">grid-row-end</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032527.png" alt="grid-column-start: 1 且 grid-column-end: 3 且 grid-row-start: 2 且 grid-row-end: 4时的效果"/></p> <p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="n">header-start</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="n">header-end</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p> <p>这四个属性的值还可以使用 <code class="language-plaintext highlighter-rouge">span</code> 关键字，表示”<strong>跨越</strong>“，即左右边框（上下边框）之间跨越多少个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/hehumay/edit?html,css,output">上面代码</a>表示，1 号项目的左边框距离右边框跨越 2 个网格。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032528.png" alt="`grid-column-start: span 2` 时的效果"/></p> <p>这与<a href="https://jsbin.com/mujihib/edit?html,css,output">下面的代码</a>效果完全一样。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">grid-column</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-column-start</code> 和 <code class="language-plaintext highlighter-rouge">grid-column-end</code> 的合并简写形式，<code class="language-plaintext highlighter-rouge">grid-row</code> 属性是 <code class="language-plaintext highlighter-rouge">grid-row-start</code> 属性和 <code class="language-plaintext highlighter-rouge">grid-row-end</code> 的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">start-line</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">end-line</span><span class="err">&gt;</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">start-line</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">end-line</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>下面是一个例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等同于 */</span>
<span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-column-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-column-end</span><span class="p">:</span> <span class="m">3</span><span class="p">;</span>
  <span class="py">grid-row-start</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="py">grid-row-end</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，项目 item-1 占据第一行，从第一根列线到第三根列线。</p> <p>这两个属性之中，也可以使用 span 关键字，表示跨越多少个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#b03532</span><span class="p">;</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等同于 */</span>
<span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#b03532</span><span class="p">;</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="n">span</span> <span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><a href="https://jsbin.com/volugow/edit?html,css,output">上面代码</a>中，项目 <code class="language-plaintext highlighter-rouge">item-1</code> 占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032529.png" alt="grid-column: 1 / 3 且 grid-row: 1 / 3 时 item-1 占据的区域"/></p> <p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="nl">grid-column</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">grid-row</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，项目 <code class="language-plaintext highlighter-rouge">item-1</code> 占据左上角第一个网格。</p> <p>（2）<code class="language-plaintext highlighter-rouge">grid-area</code> 属性</p> <p><code class="language-plaintext highlighter-rouge">grid-area</code> 属性指定项目放在哪一个区域。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，1 号项目位于 <code class="language-plaintext highlighter-rouge">e</code> 区域，效果如下图。</p> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032530.png" alt="grid-area: e 时的效果"/></p> <p><code class="language-plaintext highlighter-rouge">grid-area</code> 属性还可用作 <code class="language-plaintext highlighter-rouge">grid-row-start</code>、<code class="language-plaintext highlighter-rouge">grid-column-start</code>、<code class="language-plaintext highlighter-rouge">grid-row-end</code>、<code class="language-plaintext highlighter-rouge">grid-column-end</code> 的合并简写形式，直接指定项目的位置。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="err">&lt;</span><span class="n">row-start</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">column-start</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">row-end</span><span class="err">&gt;</span> <span class="p">/</span> <span class="err">&lt;</span><span class="n">column-end</span><span class="err">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span> <span class="p">{</span>
  <span class="py">grid-area</span><span class="p">:</span> <span class="m">1</span> <span class="p">/</span> <span class="m">1</span> <span class="p">/</span> <span class="m">3</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>（3）<code class="language-plaintext highlighter-rouge">justify-self</code> 属性、<code class="language-plaintext highlighter-rouge">align-self</code> 属性、<code class="language-plaintext highlighter-rouge">place-self</code> 属性</p> <ul> <li><code class="language-plaintext highlighter-rouge">justify-self</code> 属性设置单元格内容的水平位置（左中右），跟 <code class="language-plaintext highlighter-rouge">justify-items</code> 属性的用法完全一致，但只作用于单个项目。</li> <li><code class="language-plaintext highlighter-rouge">align-self</code> 属性设置单元格内容的垂直位置（上中下），跟 <code class="language-plaintext highlighter-rouge">align-items</code> 属性的用法完全一致，也是只作用于单个项目。</li> </ul> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item</span> <span class="p">{</span>
  <span class="py">justify-self</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
  <span class="nl">align-self</span><span class="p">:</span> <span class="n">start</span> <span class="err">|</span> <span class="n">end</span> <span class="err">|</span> <span class="nb">center</span> <span class="err">|</span> <span class="n">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这两个属性都可以取下面四个值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">start</code>：对齐单元格的起始边缘。</li> <li><code class="language-plaintext highlighter-rouge">end</code>：对齐单元格的结束边缘。</li> <li><code class="language-plaintext highlighter-rouge">center</code>：单元格内部居中。</li> <li><code class="language-plaintext highlighter-rouge">stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li> </ul> <p>下面是 <code class="language-plaintext highlighter-rouge">justify-self: start</code> 的例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.item-1</span>  <span class="p">{</span>
  <span class="py">justify-self</span><span class="p">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://cdn.beekka.com/blogimg/asset/201903/bg2019032532.png" alt="justify-self: start 时的效果"/></p> <p><code class="language-plaintext highlighter-rouge">place-self</code> 属性是 <code class="language-plaintext highlighter-rouge">align-self</code> 属性和 <code class="language-plaintext highlighter-rouge">justify-self</code> 属性的合并简写形式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">place-self</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">align-self</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">justify-self</span><span class="o">&gt;;</span>
</code></pre></div></div> <p>如果省略第二个值，<code class="language-plaintext highlighter-rouge">place-self</code> 属性会认为这两个值相等。</p> <h3 id="35-响应式图片">3.5 响应式图片</h3> <h3 id="351-srcset-属性">3.5.1 <code class="language-plaintext highlighter-rouge">srcset</code> 属性</h3> <p><code class="language-plaintext highlighter-rouge">srcset</code> 属性用来指定多张图像，适应<strong>不同像素密度</strong>的屏幕。它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，然后是像素密度的描述符。请看下面的例子。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-320w.jpg,
             foo-480w.jpg 1.5x,
             foo-640w.jpg 2x"</span>
     <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-640w.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">srcset</code> 属性给出了三个图像 URL，适应三种不同的像素密度。</p> <p>浏览器会根据当前设备的像素密度，选择需要加载的图像。如果 <code class="language-plaintext highlighter-rouge">srcset</code> 属性都不满足条件，那么就加载 <code class="language-plaintext highlighter-rouge">src</code> 属性指定的默认图像。</p> <h3 id="352-srcset-属性sizes-属性">3.5.2 <code class="language-plaintext highlighter-rouge">srcset</code> 属性、<code class="language-plaintext highlighter-rouge">sizes</code> 属性</h3> <p><code class="language-plaintext highlighter-rouge">sizes</code> 属性与 <code class="language-plaintext highlighter-rouge">srcset</code> 属性配合使用，可以实现根据不同的设备宽度应用不同尺寸的图像。其实现步骤如下。</p> <ol> <li><code class="language-plaintext highlighter-rouge">srcset</code> 属性列出所有可用的图像。</li> </ol> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-160.jpg 160w,
              foo-320.jpg 320w,
              foo-640.jpg 640w,
              foo-1280.jpg 1280w"</span>
      <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-1280.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">srcset</code> 属性列出四张可用的图像，每张图像的 URL 后面是一个空格，再加上宽度描述符。<strong>宽度描述符就是图像原始的宽度，加上字符 <code class="language-plaintext highlighter-rouge">w</code></strong>。上例的四种图片的原始宽度分别为 160px、320px、640px 和 1280px。</p> <ol> <li><code class="language-plaintext highlighter-rouge">sizes</code> 属性列出不同设备的图像显示宽度。</li> </ol> <p><code class="language-plaintext highlighter-rouge">sizes</code> 属性的值是一个逗号分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图像的显示宽度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">sizes</span><span class="o">=</span><span class="s1">"(max-width: 440px) 100vw,
              (max-width: 900px) 33vw,
              254px"</span>
      <span class="nt">srcset</span><span class="o">=</span><span class="s1">"foo-160.jpg 160w,
              foo-320.jpg 320w,
              foo-640.jpg 640w,
              foo-1280.jpg 1280w"</span>
      <span class="nt">src</span><span class="o">=</span><span class="s1">"foo-1280.jpg"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">sizes</code> 属性给出了三种屏幕条件，以及对应的图像显示宽度。宽度不超过 440px 的设备，图像显示宽度为 100%；宽度 441px 到 900px 的设备，图像显示宽度为 33%；宽度 900px 以上的设备，图像显示宽度为 254px。</p> <ol> <li>浏览器根据当前设备的宽度，从 <code class="language-plaintext highlighter-rouge">sizes</code> 属性获得图像的显示宽度，然后从 <code class="language-plaintext highlighter-rouge">srcset</code> 属性找出最接近该宽度的图像，进行加载。</li> </ol> <p>假定当前设备的屏幕宽度是 480px，浏览器从 <code class="language-plaintext highlighter-rouge">sizes</code> 属性查询得到，图片的显示宽度是 33vw（即 33%），等于 160px。<code class="language-plaintext highlighter-rouge">srcset</code> 属性里面，正好有宽度等于 160px 的图片，于是加载 <code class="language-plaintext highlighter-rouge">foo-160.jpg</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">sizes</code> 属性必须与 <code class="language-plaintext highlighter-rouge">srcset</code> 属性搭配使用。单独使用 <code class="language-plaintext highlighter-rouge">sizes</code> 属性是无效的。</p> <h3 id="353-picture-标签source-标签">3.5.3 <code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签、<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签</h3> <p>使用 <code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签和 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签，可以实现对不同尺寸及不同像素密度屏幕的适配。<picture> 标签是一个容器标签，内部使用 <source/> 和 <img/>，指定不同情况下加载的图像。</picture></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">media</span><span class="o">=</span><span class="s1">"(max-width: 500px)"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"cat-vertical.jpg"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 501px)"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"cat-horizontal.jpg"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">src</span><span class="o">=</span><span class="s1">"cat.jpg"</span> <span class="nt">alt</span><span class="o">=</span><span class="s1">"cat"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签内部有两个 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签和一个 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签。</p> <p><code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性给出媒体查询表达式，<code class="language-plaintext highlighter-rouge">srcset</code> 属性就是 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">srcset</code> 属性，给出加载的图像文件。<code class="language-plaintext highlighter-rouge">sizes</code> 属性其实这里也可以用，但由于有了 <code class="language-plaintext highlighter-rouge">media</code> 属性，就没有必要了。浏览器<strong>按照</strong> <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> <strong>标签出现的顺序</strong>，依次判断当前设备是否满足 <code class="language-plaintext highlighter-rouge">media</code> 属性的媒体查询表达式，如果满足就加载 <code class="language-plaintext highlighter-rouge">srcset</code> 属性指定的图片文件，并且不再执行后面的 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签和 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签。</p> <p><code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签是默认情况下加载的图像，用来满足上面所有 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 都不匹配的情况。</p> <p>上面例子中，设备宽度如果不超过 500px，就加载竖屏的图像，否则加载横屏的图像。</p> <p>下面给出一个例子，同时考虑屏幕尺寸和像素密度的适配。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@desktop.png,
                  homepage-person@desktop-2x.png 2x"</span>       
          <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 990px)"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@tablet.png,
                  homepage-person@tablet-2x.png 2x"</span> 
          <span class="nt">media</span><span class="o">=</span><span class="s1">"(min-width: 750px)"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"homepage-person@mobile.png,
               homepage-person@mobile-2x.png 2x"</span> 
       <span class="nt">alt</span><span class="o">=</span><span class="s1">"Shopify Merchant, Corrine Anestopoulos"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">media</code> 属性给出屏幕尺寸的适配条件，每个条件都用 <code class="language-plaintext highlighter-rouge">srcset</code> 属性，再给出两种像素密度的图像 URL。</p> <h3 id="354-source-标签的-type-属性">3.5.4 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性</h3> <p>除了响应式图像，<code class="language-plaintext highlighter-rouge">&lt;picture&gt;</code> 标签还可以用来选择不同格式的图像。比如，如果当前浏览器支持 Webp 格式，就加载这种格式的图像，否则加载 PNG 图像。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">picture</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">type</span><span class="o">=</span><span class="s1">"image/svg+xml"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"logo.xml"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nt">source</span> <span class="nt">type</span><span class="o">=</span><span class="s1">"image/webp"</span> <span class="nt">srcset</span><span class="o">=</span><span class="s1">"logo.webp"</span><span class="o">&gt;</span> 
  <span class="o">&lt;</span><span class="nt">img</span> <span class="nt">src</span><span class="o">=</span><span class="s1">"logo.png"</span> <span class="nt">alt</span><span class="o">=</span><span class="s1">"ACME Corp"</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">picture</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性给出图像的 MIME 类型，<code class="language-plaintext highlighter-rouge">srcset</code> 是对应的图像 URL。</p> <p>浏览器按照 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签出现的顺序，依次检查是否支持 <code class="language-plaintext highlighter-rouge">type</code> 属性指定的图像格式，如果支持就加载图像，并且不再检查后面的 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签了。上面例子中，图像加载优先顺序依次为 svg 格式、webp 格式和 png 格式。</p> <h2 id="四h5-与响应式-web-设计">四、H5 与响应式 Web 设计</h2> <h3 id="41-h5-页面结构新特性">4.1 H5 页面结构新特性</h3> <p>（1）<code class="language-plaintext highlighter-rouge">doctype</code>：用于告诉浏览器文档类型。相比于 H4 的写法，新写法简化了很多。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
</code></pre></div></div> <p>（2）<code class="language-plaintext highlighter-rouge">lang 属性</code>：用于指定文档使用的语言。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
</code></pre></div></div> <p>（3）<code class="language-plaintext highlighter-rouge">charset</code>：<code class="language-plaintext highlighter-rouge">charset</code> 属性用于指定字符编码。除非有特殊需要，否则 <code class="language-plaintext highlighter-rouge">charset</code> 的属性值一般都是 <code class="language-plaintext highlighter-rouge">utf-8</code>。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
</code></pre></div></div> <h3 id="42-h5-结构化元素">4.2 H5 结构化元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;main&gt;</code>：用于表示页面的主内容区。通常，每个页面的主内容区只能有一个，而且不能作为 <code class="language-plaintext highlighter-rouge">article</code>、<code class="language-plaintext highlighter-rouge">aside</code>、<code class="language-plaintext highlighter-rouge">header</code>、<code class="language-plaintext highlighter-rouge">footer</code>、<code class="language-plaintext highlighter-rouge">nav</code> 或 <code class="language-plaintext highlighter-rouge">header</code> 等其他 H5 语义元素的后代。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;section&gt;</code>：用于定义文档或应用中一个通用的区块。比如，某块内容包含自然标题（h1 ~ h6），就可以使用 <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> 标签作为容器。</p> <p>（3）<code class="language-plaintext highlighter-rouge">&lt;nav&gt;</code>：用于包装主导航链接。</p> <p>（4）<code class="language-plaintext highlighter-rouge">&lt;article&gt;</code>：用于包含一个独立的内容块。比如，有博客正文和新闻报道就可以放在 <code class="language-plaintext highlighter-rouge">&lt;article&gt;</code> 中。</p> <p>（5）<code class="language-plaintext highlighter-rouge">&lt;aside&gt;</code>：用于包含与其旁边内容不相关的内容。常用于侧边栏、突出引用、广告和导航元素。</p> <p>（6）<code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;figcaption&gt;</code>：<code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 常用于包含注解、图示、照片和代码等。<code class="language-plaintext highlighter-rouge">&lt;figcaption&gt;</code> 可作为 <code class="language-plaintext highlighter-rouge">&lt;figure&gt;</code> 的嵌套元素使用。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;figure</span> <span class="na">class=</span><span class="s">"MoneyShot"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;img</span> <span class="na">class=</span><span class="s">"MoneyShotImg"</span> <span class="na">src=</span><span class="s">"img/scones.jpg"</span> <span class="na">alt=</span><span class="s">"Incredible scones"</span> <span class="nt">/&gt;</span> 
  <span class="nt">&lt;figcaption</span> <span class="na">class=</span><span class="s">"ImageCaption"</span><span class="nt">&gt;</span>
    Incredible scones, picture from Wikipedia
  <span class="nt">&lt;/figcaption&gt;</span> 
<span class="nt">&lt;/figure&gt;</span> 
</code></pre></div></div> <p>（7）<code class="language-plaintext highlighter-rouge">&lt;detail&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;summary&gt;</code>：这两个元素经常成对出现，比如，我们经常使用的“展开/收起”部件，就可以用它们来实现。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;details&gt;</span> 
  <span class="nt">&lt;summary&gt;</span>I ate 15 scones in one day<span class="nt">&lt;/summary&gt;</span> 
  <span class="nt">&lt;p&gt;</span>Of course I didn't. It would probably kill me if I did. What a way to go. Mmmmmm, scones!<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/details&gt;</span>
</code></pre></div></div> <p>在不添加任何样式的请款下，上面代码的（展开）效果如下。</p> <p><img src="/assets/images/css/detail-and-summary.png" alt="details and summary tag"/></p> <p>（8）<code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>：常用在站点页头作为“报头”。它可以在一个页面中出现多次（比如，页面中每个 <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> 中都可以有一个 <code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>）。</p> <p>（9）<code class="language-plaintext highlighter-rouge">&lt;footer&gt;</code>：常用于在相应区块中包含与区块相关的内容，可以包含指向其他文档的链接，或者版权声明。<code class="language-plaintext highlighter-rouge">&lt;footer&gt;</code> 同样可以在页面中出现多次。</p> <p>（10）<code class="language-plaintext highlighter-rouge">&lt;address&gt;</code>：用于标记联系人信息，比如地址信息。</p> <p>（11）<code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code> ~ <code class="language-plaintext highlighter-rouge">&lt;h6&gt;</code>：h1 到 h6 元素不能用于标记副标题、字幕、广告语，除非想把它们用作新区块或子区块的标题。</p> <h3 id="43-h5-文本级元素">4.3 H5 文本级元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;b&gt;</code>：表示只为引人注意而标记的文本，不传达更多的重要性信息，也不用于表达其他的愿望或情绪。比如，不用于文章摘要中的关键词、评测当中的产品名、交互式文本程序中的可执行命令，等等。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code>：表示内容中需要强调的部分。</p> <p>（3）<code class="language-plaintext highlighter-rouge">&lt;i&gt;</code>：表示一段文本，用于表示另一种愿望或情绪，或者以突出不同文本形式的方式表达偏离正文的意思。</p> <h3 id="44-新的媒体元素">4.4 新的媒体元素</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;video&gt;</code>：用于在页面中嵌入视频，<code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> 标签必须成对使用。如果浏览器不支持此标签，可以在其中潜入一段文字，用于提示。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">src=</span><span class="s">"myVideo.mp4"</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span><span class="nt">&gt;</span>
  What, do you mean you don't understand HTML5?
<span class="nt">&lt;/video&gt;</span> 
</code></pre></div></div> <p>对于某些旧版本浏览器，可以使用 <code class="language-plaintext highlighter-rouge">&lt;source&gt;</code> 标签以提供后备资源。比如，除了提供 MP4 版本的视频，如果想某些低版本浏览器也能看到视频，可以添加一个 Flash源 作为后备。或者，如果用户浏览器没有任何播放条件，还可以提供一个下载视频的链接。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span> <span class="na">controls</span> <span class="na">preload=</span><span class="s">"auto"</span> <span class="na">loop</span> <span class="na">poster=</span><span class="s">"myVideoPoster.png"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">"video/myVideo.mp4"</span> <span class="na">type=</span><span class="s">"video/mp4"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;object</span>
    <span class="na">width=</span><span class="s">"640"</span>
    <span class="na">height=</span><span class="s">"480"</span>
    <span class="na">type=</span><span class="s">"application/x-shockwaveflash"</span>
    <span class="na">data=</span><span class="s">"myFlashVideo.SWF"</span>
  <span class="nt">&gt;</span>
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"movie"</span> <span class="na">value=</span><span class="s">"myFlashVideo.swf"</span> <span class="nt">/&gt;</span> 
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"flashvars"</span> <span class="na">value=</span><span class="s">"controlbar=over&amp;amp;image=myVideoPoster.jpg&amp;amp;file=myVideo.mp4"</span> <span class="nt">/&gt;</span> 
    <span class="nt">&lt;img</span>
      <span class="na">src=</span><span class="s">"myVideoPoster.png"</span>
      <span class="na">width=</span><span class="s">"640"</span>
      <span class="na">height=</span><span class="s">"480"</span>
      <span class="na">alt=</span><span class="s">"__ TITLE__"</span>
      <span class="na">title=</span><span class="s">"No video playback capabilities, please download the video below"</span>
    <span class="nt">/&gt;</span> 
  <span class="nt">&lt;/object&gt;</span> 
  <span class="nt">&lt;p&gt;</span>
    <span class="nt">&lt;b&gt;</span>Download Video:<span class="nt">&lt;/b&gt;</span> MP4 Format: <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"myVideo.mp4"</span><span class="nt">&gt;</span>"MP4"<span class="nt">&lt;/a&gt;</span> 
  <span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/video&gt;</span>
</code></pre></div></div> <p>通常，很难对不同的视频播放画面做响应式设计，多数情况下，影片的播放比例并不相同。<a href="http://embedresponsively.com/">这里</a> 有一个网站，你可以把视频的 url 地址粘贴进去，就会得到一段响应式代码，从而使得在网页缩放时，视频依然会保持应有的比例。</p> <p>（2）<code class="language-plaintext highlighter-rouge">&lt;audio&gt;</code>：<code class="language-plaintext highlighter-rouge">&lt;audio&gt;</code> 用于在页面中嵌入音频，其用法与 <code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> 类似。</p> <h3 id="45-其他特性">4.5 其他特性</h3> <p>（1）<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 标签中可以放多个元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"index.html"</span><span class="nt">&gt;</span> 
  <span class="nt">&lt;h2&gt;</span>The home page<span class="nt">&lt;/h2&gt;</span> 
  <span class="nt">&lt;p&gt;</span>This paragraph also links to the home page<span class="nt">&lt;/p&gt;</span> 
  <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"home-image.png"</span> <span class="na">alt=</span><span class="s">"home-slice"</span> <span class="nt">/&gt;</span> 
<span class="nt">&lt;/a&gt;</span> 
</code></pre></div></div> <p>（2）WCAG 和 WAI-ARIA</p> <p>WCAG 和 WAI-ARIA 提供了与无障碍交互相关的标准。</p> <h2 id="五css3-新特性">五、CSS3 新特性</h2> <p>这部分并不会讨论 CSS3 中所有的新特性，而只是讨论跟响应式设计有关的新特性。</p> <h3 id="51-css-响应式多列布局">5.1 CSS 响应式多列布局</h3> <p>以下示例，以下面的代码布局为例进行讲解。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;main&gt;</span> 
  <span class="nt">&lt;p&gt;</span>lloremipsimLoremipsum dolor sit amet, consectetur ... <span class="nt">&lt;/p&gt;</span> 
  <span class="nt">&lt;p&gt;</span>lloremipsimLoremipsum dolor sit amet, consectetur ... <span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/main&gt;</span>
</code></pre></div></div> <p>（1）使用 CSS 多列布局可以通过几种方式让文本分成多列显示。比如，可以给每列设定固定的列宽。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-width</span><span class="p">:</span> <span class="m">12em</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码表示，设置没列的宽度为 12em，改变视口宽度时，列宽不变，列数动态改变。</p> <p>（2）固定列数，可变宽度。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-count</span><span class="p">:</span> <span class="m">4</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码表示，当页面缩放时，列数固定，宽度可变。</p> <p>（3）添加列间距和分隔线。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">main</span> <span class="p">{</span> 
  <span class="nl">column-gap</span><span class="p">:</span> <span class="m">2em</span><span class="p">;</span> 
  <span class="nl">column-rule</span><span class="p">:</span> <span class="nb">thin</span> <span class="nb">dotted</span> <span class="m">#999</span><span class="p">;</span> 
  <span class="nl">column-width</span><span class="p">:</span> <span class="m">12em</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码，用于给列间添加间距和分隔线。</p> <h3 id="52-断字">5.2 断字</h3> <p>（1）容器中的文字默认一行显示，如果文字太长，超出了容器的长度，就会显示在容器外面。可以使用下面的方式，对文字进行<strong>换行</strong>处理。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">word-wrap</span><span class="o">:</span> <span class="nt">break-word</span><span class="o">;</span>
</code></pre></div></div> <p>（2）可以对文字<strong>截短</strong>处理，并且使得超出容器宽度的部分，显示为 <code class="language-plaintext highlighter-rouge">...</code>。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">p</span> <span class="p">{</span> 
 <span class="nl">width</span><span class="p">:</span> <span class="m">520px</span><span class="p">;</span> 
 <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span> 
 <span class="nl">text-overflow</span><span class="p">:</span> <span class="n">ellipsis</span><span class="p">;</span> 
 <span class="nl">white-space</span><span class="p">:</span> <span class="n">no-wrap</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>最后的 <code class="language-plaintext highlighter-rouge">white-space: nowrap</code> 声明是为了确保长出来的文本不会折行显示在外部元素中。</p> <h3 id="53-在-css-中创建分支">5.3 在 CSS 中创建分支</h3> <p>在响应式设计，经常会碰到某些设备不支持什么特性或技术的情况。此时，往往需要在 CSS 中创建一个分支。如果浏览器支持某特性，就应用一段代码；如果不支持，则应用另一段代码。这点类似于 JavaScript 中 <code class="language-plaintext highlighter-rouge">if...else</code> 语句。</p> <p>在 CSS 中创建分支有两种手段。一是完全基于 CSS，但支持的浏览器却不多； 二是借助 JavaScript 库，获得广泛兼容性。</p> <p>（1）特性查询</p> <p>CSS 原生的分支语法就是特性查询，比如下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">(</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span>

<span class="k">@supports</span> <span class="n">not</span> <span class="p">(</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-block</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码表示，如果浏览器支持 <code class="language-plaintext highlighter-rouge">display: flex</code>，就对 <code class="language-plaintext highlighter-rouge">.item</code> 选择器设置一种样式；否则，则设置为另一种样式。</p> <p>（2）组合条件</p> <p>假设我们只想在浏览器支持 flexbox 和 <code class="language-plaintext highlighter-rouge">pointer: coarse</code> 时应用某些规则，可以使用下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">((</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nb">pointer</span><span class="p">:</span> <span class="n">coarse</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">and</code> 关键字，其他支持的关键字还有 <code class="language-plaintext highlighter-rouge">or</code>。比如，除了前面两个条件满足之外，如果浏览器支持 3D 变形也想应用样式，那么可以使用下面的代码。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@supports</span> <span class="p">((</span><span class="n">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="nb">pointer</span><span class="p">:</span> <span class="n">coarse</span><span class="p">))</span> <span class="n">or</span> <span class="p">(</span><span class="n">transform</span><span class="p">:</span> <span class="n">translate3d</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">))</span> <span class="p">{</span> 
  <span class="nc">.item</span> <span class="p">{</span> 
    <span class="nl">display</span><span class="p">:</span> <span class="n">inline-flex</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>注意，某些低版本及 IE 浏览器，并不支持 <code class="language-plaintext highlighter-rouge">@support</code> 关键字。</p> <p>（3）在 <code class="language-plaintext highlighter-rouge">@supports</code> 得到广泛支持以前，还可以使用 Modernizr 这个 JavaScript 工具在 CSS 中实现分支。</p> <h3 id="54-新的-css3-选择器">5.4 新的 CSS3 选择器</h3> <p>（1）属性选择器，用于对某些元素的属性进行选择。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">border</span><span class="p">:</span> <span class="m">3px</span> <span class="nb">dashed</span> <span class="m">#e15f5f</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，表示选中任何包含 <code class="language-plaintext highlighter-rouge">alt</code> 属性的 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 元素。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">=</span><span class="s1">"sausages"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="c">/* 样式 */</span> 
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码，只会选择 <code class="language-plaintext highlighter-rouge">alt</code> 属性值为 <code class="language-plaintext highlighter-rouge">sausages</code> 的 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>元素。即同时指定了属性的值，进一步缩小了搜索范围。</p> <p>CSS3 支持依据属性选择器包含的子字符串来选择元素。这时分为三种情况：</p> <ul> <li>以 xxx 开头。</li> <li>包含 xxx。</li> <li>以 xxx 结尾。</li> </ul> <p>（2）选中属性值以某字符串开头的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"img/ace-film.jpg"</span> <span class="na">alt=</span><span class="s">"film-ace"</span><span class="nt">&gt;</span> 
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"img/rubbish-film.jpg"</span> <span class="na">alt=</span><span class="s">"film-rubbish"</span><span class="nt">&gt;</span> 
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">alt</span><span class="o">^=</span><span class="s1">"film"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="c">/* 样式 */</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的代码，使用 <code class="language-plaintext highlighter-rouge">^</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">alt</code> 属性值中以 <code class="language-plaintext highlighter-rouge">film</code> 字符串开头的情况。即此时会选中 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 表情中，<code class="language-plaintext highlighter-rouge">alt</code> 属性以 <code class="language-plaintext highlighter-rouge">film</code> 开头的元素（在这里会同时选中上边的两个 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 标签）。</p> <p>（2）选中属性值包含某字符串的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"scones cream jam"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">data-ingredients</span><span class="o">*=</span><span class="s1">"cream"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的属性选择器，使用 <code class="language-plaintext highlighter-rouge">*</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">data-ingredients</code> 属性值中包含 <code class="language-plaintext highlighter-rouge">cream</code> 字符串的情况。此时 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 标签会被选中。</p> <p>（3）选中属性值以某字符串结尾的元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"scones cream jam"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"toast jam butter"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;p</span> <span class="na">data-ingredients=</span><span class="s">"jam toast butter"</span><span class="nt">&gt;</span>Will I get selected?<span class="nt">&lt;/p&gt;</span> 
</code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">data-ingredients</span><span class="err">$</span><span class="o">=</span><span class="s1">"jam"</span><span class="o">]</span> <span class="p">{</span> 
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div> <p>上面的属性选择器，使用 <code class="language-plaintext highlighter-rouge">$</code> 符号，匹配 <code class="language-plaintext highlighter-rouge">data-ingredients</code> 属性值中以 <code class="language-plaintext highlighter-rouge">jam</code> 字符串结尾的情况。此时，第一个 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 标签会被选中。</p> <h3 id="55-伪类选择器">5.5 伪类选择器</h3> <ul> <li><code class="language-plaintext highlighter-rouge">:last-child</code>：用于选择某个父元素中的最后一个子元素。</li> <li><code class="language-plaintext highlighter-rouge">:nth-child(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-last-child(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-of-type(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:nth-last-of-type(n)</code>：</li> <li><code class="language-plaintext highlighter-rouge">:not</code>：</li> <li><code class="language-plaintext highlighter-rouge">:empty</code>：</li> <li><code class="language-plaintext highlighter-rouge">:first-line</code>：</li> <li><code class="language-plaintext highlighter-rouge">:has</code>：</li> </ul> <h3 id="56-calc-函数">5.6 <code class="language-plaintext highlighter-rouge">calc()</code> 函数</h3> <h3 id="57-css3-的新颜色格式及透明度">5.7 CSS3 的新颜色格式及透明度</h3> <p>（1）可以使用 <code class="language-plaintext highlighter-rouge">rgb()</code> 或 <code class="language-plaintext highlighter-rouge">rgba()</code> 函数定义颜色，前者接收三个参数（取值为 0 ~ 255），分别表示红、绿、蓝三原色分量的值，后者除了这三个参数，还可以接受一个 alpha 透明度数值，取值为 0 ~ 1。</p> <p>（2）CSS3 还支持HSL（Hue Saturation Lightness，色相、饱和度、亮度）颜色系统。</p> <h2 id="六css3-高级技术">六、CSS3 高级技术</h2> <h2 id="七svg-与响应式-web-设计">七、SVG 与响应式 Web 设计</h2> <h2 id="八css3-过渡变形和动画">八、CSS3 过渡、变形和动画</h2> <h2 id="九表单">九、表单</h2> <h2 id="十参考">十、参考</h2> <ul> <li><a href="https://benfrain.com/">Ben Frain</a>，《响应式 Web 设计：HTML5和CSS实战》</li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a></li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程</a></li> <li>阮一峰，<a href="https://www.ruanyifeng.com/blog/2019/06/responsive-images.html">响应式图像教程</a></li> </ul>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="media queries"/><category term="responsive web design"/><category term="responsive images"/><category term="flex box layout"/><category term="grid layout"/><summary type="html"><![CDATA[一、简介]]></summary></entry><entry><title type="html">计算机网络 - 网络层</title><link href="https://feng-zhang0712.github.io//blog/2024/network-layer/" rel="alternate" type="text/html" title="计算机网络 - 网络层"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/network-layer</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/network-layer/"><![CDATA[]]></content><author><name></name></author><category term="computer"/><category term="computer"/><category term="networks"/><category term="network layer"/><category term="OSI"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">CSS Modules 用法教程</title><link href="https://feng-zhang0712.github.io//blog/2024/css-modules/" rel="alternate" type="text/html" title="CSS Modules 用法教程"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/css-modules</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/css-modules/"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2016/06/css_modules.html">CSS Modules 用法教程</a></p>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="css modules"/><summary type="html"><![CDATA[CSS Modules 用法教程]]></summary></entry><entry><title type="html">CSS 预处理器</title><link href="https://feng-zhang0712.github.io//blog/2024/css-preprocessor/" rel="alternate" type="text/html" title="CSS 预处理器"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/css-preprocessor</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/css-preprocessor/"><![CDATA[<h2 id="一概念">一、概念</h2> <p>CSS 预处理器是一种脚本语言，扩展了原生 CSS 的功能。通过预处理器，可以使用更高级的语法和特性来编写样式代码。预处理器文件（如 .sass）在编译过程中会被转换成标准的 CSS 文件。</p> <h2 id="二常见的-css-预处理器">二、常见的 CSS 预处理器</h2> <p>Sass：提供了两种语法，Sass（缩进语法）和 SCSS（类似 CSS 的语法）。Sass 是目前最流行的预处理器之一。 LESS：另一个流行的预处理器，语法上与 CSS 更接近，容易上手。</p> <h2 id="三预处理器的用途和优点">三、预处理器的用途和优点</h2> <h3 id="31-变量">3.1 变量</h3> <p>预处理器支持变量，可以用来存储重复使用的值（如颜色）等。</p> <h3 id="32-嵌套">3.2 嵌套</h3> <p>预处理器允许嵌套 CSS，可以更清晰地表示层次结构。</p> <h3 id="33-混合宏mixin">3.3. 混合宏（Mixin）</h3> <p>混合宏允许定义一组可重用的样式规则，类似于函数。可以通过传递参数自定义样式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@mixin</span> <span class="n">border-radius</span><span class="p">(</span><span class="err">$</span><span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">-webkit-border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
     <span class="nl">-moz-border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
          <span class="nl">border-radius</span><span class="p">:</span> <span class="err">$</span><span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button</span> <span class="p">{</span>
  <span class="err">@include</span> <span class="err">border-radius(10px);</span>
<span class="p">}</span>

</code></pre></div></div> <h3 id="34-继承">3.4 继承</h3> <p>预处理器支持继承样式，一个选择器可以继承另一个选择器的样式。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="nt">button-styles</span> <span class="p">{</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">10px</span> <span class="m">20px</span><span class="p">;</span>
  <span class="nl">border</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
  <span class="nl">cursor</span><span class="p">:</span> <span class="nb">pointer</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button</span> <span class="p">{</span>
  <span class="err">@extend</span> <span class="err">%button-styles;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="m">#3498db</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.button-secondary</span> <span class="p">{</span>
  <span class="err">@extend</span> <span class="err">%button-styles;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="m">#2ecc71</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#fff</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="35-函数">3.5 函数</h3> <p>预处理器允许定义函数，进行复杂的计算和逻辑操作，然后返回值，供样式规则使用。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@function</span> <span class="n">calculate-margin</span><span class="p">(</span><span class="err">$</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">@return</span> <span class="err">$</span><span class="n">value</span> <span class="err">*</span> <span class="m">1.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.container</span> <span class="p">{</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="n">calculate-margin</span><span class="p">(</span><span class="m">10px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="36-导入和拆分文件">3.6 导入和拆分文件</h3> <p>预处理器支持将样式拆分成多个文件，并使用 @import 语句导入。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* _variables.scss */</span>
<span class="err">$</span><span class="nt">primary-color</span><span class="o">:</span> <span class="err">#3498</span><span class="nt">db</span><span class="o">;</span>
<span class="err">$</span><span class="nt">secondary-color</span><span class="o">:</span> <span class="err">#2</span><span class="nt">ecc71</span><span class="o">;</span>

<span class="c">/* _mixins.scss */</span>
<span class="k">@mixin</span> <span class="n">flex-center</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
  <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* styles.scss */</span>
<span class="k">@import</span> <span class="s2">'variables'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s2">'mixins'</span><span class="p">;</span>
<span class="nc">.header</span> <span class="p">{</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="err">$</span><span class="n">primary-color</span><span class="p">;</span>
  <span class="err">@include</span> <span class="err">flex-center;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100vh</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="37-条件语句和循环">3.7 条件语句和循环</h3> <p>预处理器支持条件语句和循环。</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="nt">themes</span><span class="o">:</span> <span class="o">(</span><span class="s2">'light'</span><span class="o">,</span> <span class="s2">'dark'</span><span class="o">);</span>
<span class="k">@each</span> <span class="err">$</span><span class="n">theme</span> <span class="n">in</span> <span class="err">$</span><span class="n">themes</span> <span class="p">{</span>
  <span class="nc">.theme-</span><span class="err">#</span><span class="p">{</span><span class="err">$theme</span><span class="p">}</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="n">if</span><span class="p">(</span><span class="err">$</span><span class="n">theme</span> <span class="err">==</span> <span class="s2">'light'</span><span class="p">,</span> <span class="m">#fff</span><span class="p">,</span> <span class="m">#333</span><span class="p">);</span>
    <span class="nl">color</span><span class="p">:</span> <span class="n">if</span><span class="p">(</span><span class="err">$</span><span class="n">theme</span> <span class="err">==</span> <span class="s2">'light'</span><span class="p">,</span> <span class="m">#333</span><span class="p">,</span> <span class="m">#fff</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="frontend"/><category term="css"/><category term="sass"/><summary type="html"><![CDATA[一、概念]]></summary></entry><entry><title type="html">React 中的事件</title><link href="https://feng-zhang0712.github.io//blog/2024/events-in-react/" rel="alternate" type="text/html" title="React 中的事件"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/events-in-react</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/events-in-react/"><![CDATA[<p>React 的事件代理机制（Event Delegation）是其性能优化的一种手段。通过事件代理，React 将所有的事件监听器统一绑定到根元素，而不是每个具体的 DOM 元素上。这种方法减少了实际绑定到 DOM 元素上的事件处理器数量，从而提升了性能，特别是在有大量动态生成的元素时。</p> <h3 id="事件代理的工作原理">事件代理的工作原理</h3> <ol> <li><strong>统一绑定事件处理器</strong>：React 会在组件挂载时，将所有事件处理器统一绑定到应用的根元素（例如 <code class="language-plaintext highlighter-rouge">document</code> 或 <code class="language-plaintext highlighter-rouge">root</code> DOM 节点）。</li> <li><strong>事件捕获和冒泡</strong>：当用户在具体的 DOM 元素上触发事件时，事件会按照捕获和冒泡的机制传播。React 利用这个机制，在事件冒泡到根元素时捕获事件。</li> <li><strong>事件分发</strong>：在根元素上捕获到事件后，React 解析事件的目标元素，并根据目标元素和事件类型，找到对应的 React 组件实例和事件处理器，然后调用该处理器。</li> </ol> <h3 id="优点">优点</h3> <ul> <li><strong>性能优化</strong>：减少了实际绑定在 DOM 元素上的事件处理器数量，降低了内存消耗和性能开销。</li> <li><strong>简化事件管理</strong>：通过统一的事件处理机制，简化了事件添加和移除的管理。</li> </ul> <h3 id="示例">示例</h3> <p>以下是一个简单的示例，展示了事件代理的基本概念：</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">ButtonList</span> <span class="kd">extends</span> <span class="nc">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 获取被点击的按钮元素</span>
    <span class="kd">const</span> <span class="nx">button</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Button </span><span class="p">${</span><span class="nx">button</span><span class="p">.</span><span class="nx">textContent</span><span class="p">}</span><span class="s2"> clicked!`</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 1<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 2<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>Button 3<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">ButtonList</span><span class="p">;</span>
</code></pre></div></div> <p>在这个示例中，三个按钮的点击事件都通过 <code class="language-plaintext highlighter-rouge">div</code> 容器上的 <code class="language-plaintext highlighter-rouge">onClick</code> 处理器进行处理。点击任意按钮时，事件会冒泡到 <code class="language-plaintext highlighter-rouge">div</code> 容器，被捕获并处理。</p> <h3 id="深入理解">深入理解</h3> <ul> <li><strong>合成事件</strong>：React 使用合成事件（Synthetic Events）对象来封装浏览器的原生事件对象。合成事件对象提供了与原生事件对象相同的接口，但具备跨浏览器的兼容性。</li> <li><strong>事件池</strong>：React 维护一个事件池，用于存储和复用合成事件对象。事件处理器执行后，合成事件对象会被复用以提高性能。因此，在事件处理器中，不能异步访问合成事件对象；如果需要异步访问，可以调用 <code class="language-plaintext highlighter-rouge">event.persist()</code> 方法防止对象被复用。</li> </ul> <h3 id="注意事项">注意事项</h3> <ul> <li><strong>异步访问事件对象</strong>：在异步函数中访问合成事件对象时，需要调用 <code class="language-plaintext highlighter-rouge">event.persist()</code> 方法。例如：</li> </ul> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nf">persist</span><span class="p">();</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span> <span class="c1">// 异步访问事件对象</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li><strong>非冒泡事件</strong>：某些事件不会冒泡，例如 <code class="language-plaintext highlighter-rouge">onBlur</code> 和 <code class="language-plaintext highlighter-rouge">onFocus</code>。React 通过特殊处理，将这些事件也通过事件代理机制进行处理。</li> </ul> <h3 id="总结">总结</h3> <p>React 的事件代理机制通过在根元素上统一绑定事件处理器，有效地减少了实际绑定在 DOM 元素上的事件处理器数量，提升了性能，并简化了事件管理。这是 React 提升性能和简化事件管理的一种重要手段。</p>]]></content><author><name></name></author><category term="frontend"/><category term="react"/><category term="events"/><summary type="html"><![CDATA[React 的事件代理机制（Event Delegation）是其性能优化的一种手段。通过事件代理，React 将所有的事件监听器统一绑定到根元素，而不是每个具体的 DOM 元素上。这种方法减少了实际绑定到 DOM 元素上的事件处理器数量，从而提升了性能，特别是在有大量动态生成的元素时。]]></summary></entry><entry><title type="html">ES6 - Array</title><link href="https://feng-zhang0712.github.io//blog/2024/array/" rel="alternate" type="text/html" title="ES6 - Array"/><published>2024-09-12T00:00:00+00:00</published><updated>2024-09-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/array</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/array/"><![CDATA[]]></content><author><name></name></author><category term="frontend"/><category term="React"/><category term="es6"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">ES6 - async 函数</title><link href="https://feng-zhang0712.github.io//blog/2024/async/" rel="alternate" type="text/html" title="ES6 - async 函数"/><published>2024-09-12T00:00:00+00:00</published><updated>2024-09-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/async</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/async/"><![CDATA[<h2 id="一含义">一、含义</h2> <p>ES2017 标准引入了 <code class="language-plaintext highlighter-rouge">async</code> 函数，它是 Generator 函数的语法糖。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nf">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="nf">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
      <span class="nf">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">};</span>

<span class="c1">// 上面代码的函数 gen 可以写成 async 函数，就是下面这样。</span>
<span class="kd">const</span> <span class="nx">asyncReadFile</span> <span class="o">=</span> <span class="k">async</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div> <p>比较发现，<code class="language-plaintext highlighter-rouge">async</code> 函数就是将 Generator 函数的星号（*）替换成 <code class="language-plaintext highlighter-rouge">async</code>，将 <code class="language-plaintext highlighter-rouge">yield</code> 替换成 <code class="language-plaintext highlighter-rouge">await</code>，仅此而已。<code class="language-plaintext highlighter-rouge">async</code> 函数对 Generator 函数的改进，体现在以下四点。</p> <p>（1）<strong>内置执行器</strong></p> <p>Generator 函数的执行必须靠执行器，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一样。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">asyncReadFile</span><span class="p">();</span>
</code></pre></div></div> <p>上面的代码调用了 asyncReadFile 函数，然后它就会自动执行。这不像 Generator 函数，需要调用 next 方法才能真正执行，得到最后结果。</p> <p>（2）<strong>更好的语义</strong></p> <p><code class="language-plaintext highlighter-rouge">async</code> 和 <code class="language-plaintext highlighter-rouge">await</code>，比起星号（<code class="language-plaintext highlighter-rouge">*</code>）和 <code class="language-plaintext highlighter-rouge">yield</code>，语义更清楚。<code class="language-plaintext highlighter-rouge">async</code> 表示函数里有异步操作，<code class="language-plaintext highlighter-rouge">await</code> 表示紧跟在后面的表达式需要等待结果。</p> <p>（3）<strong>更广的适用性</strong></p> <p>co 模块约定，<code class="language-plaintext highlighter-rouge">yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而 <code class="language-plaintext highlighter-rouge">async</code> 函数的 <code class="language-plaintext highlighter-rouge">await</code> 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 <code class="language-plaintext highlighter-rouge">resolved</code> 的 Promise 对象）。</p> <p>（4）<strong>返回值是 Promise</strong></p> <p><code class="language-plaintext highlighter-rouge">async</code> 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象更方便。</p> <h2 id="二语法">二、语法</h2> <h3 id="21-返回-promise-对象">2.1 返回 Promise 对象</h3> <p><code class="language-plaintext highlighter-rouge">async</code> 函数返回一个 Promise 对象。</p> <p><code class="language-plaintext highlighter-rouge">async</code> 函数内部 <code class="language-plaintext highlighter-rouge">return</code> 语句返回的值，会成为 <code class="language-plaintext highlighter-rouge">then</code> 方法回调函数的参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">().</span><span class="nf">then</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
<span class="c1">// "hello world"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">async</code> 函数内部抛出错误，会导致返回的 Promise 对象变为 <code class="language-plaintext highlighter-rouge">reject</code> 状态。抛出的错误对象会被 <code class="language-plaintext highlighter-rouge">catch</code> 方法回调函数接收到。</p> <h3 id="22-promise-对象的状态变化">2.2 Promise 对象的状态变化</h3> <p>只有 <code class="language-plaintext highlighter-rouge">async</code> 函数内部的异步操作执行完，才会执行 <code class="language-plaintext highlighter-rouge">then</code> 方法指定的回调函数。</p> <h3 id="23-await-命令">2.3 await 命令</h3> <p>正常情况下，<code class="language-plaintext highlighter-rouge">await</code> 命令后面是一个 Promise 对象，返回该对象的结果。</p> <p>（1）如果 <code class="language-plaintext highlighter-rouge">await</code> 后面不是 Promise 对象，就直接返回对应的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 等同于</span>
  <span class="c1">// return 123;</span>
  <span class="k">return</span> <span class="k">await</span> <span class="mi">123</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">().</span><span class="nf">then</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// 123</span>
</code></pre></div></div> <p>（2）如果 <code class="language-plaintext highlighter-rouge">await</code> 命令后面是一个 <code class="language-plaintext highlighter-rouge">thenable</code> 对象（即定义了 <code class="language-plaintext highlighter-rouge">then</code> 方法的对象），那么 <code class="language-plaintext highlighter-rouge">await</code> 会将其等同于 Promise 对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Sleep</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">timeout</span> <span class="o">=</span> <span class="nx">timeout</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">startTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">();</span>
    <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nf">resolve</span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">timeout</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">(</span><span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">sleepTime</span> <span class="o">=</span> <span class="k">await</span> <span class="k">new</span> <span class="nc">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">sleepTime</span><span class="p">);</span>
<span class="p">})();</span>
<span class="c1">// 1000</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">await</code> 命令后面是一个 Sleep 对象的实例。这个实例不是 Promise 对象，但是因为定义了 <code class="language-plaintext highlighter-rouge">then</code> 方法，<code class="language-plaintext highlighter-rouge">await</code> 会将其视为 Promise 处理。</p> <p>（3）借助 <code class="language-plaintext highlighter-rouge">await</code> 命令可以实现休眠功能。下面给出了一个简化的 sleep 实现。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">sleep</span><span class="p">(</span><span class="nx">interval</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">interval</span><span class="p">);</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// 用法</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">one2FiveInAsync</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">one2FiveInAsync</span><span class="p">();</span>
</code></pre></div></div> <p>（4）当函数执行到 <code class="language-plaintext highlighter-rouge">await</code> 时，被等待的表达式会立即执行，所有依赖该表达式的值的代码会被暂停，并推送进微任务队列（microtask queue）。然后主线程被释放出来，用于事件循环中的下一个任务。即使等待的值是已经敲定的 promise 或不是 promise，也会发生这种情况。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">start</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">await</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">middle</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">end</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">foo</span><span class="p">(</span><span class="dl">"</span><span class="s2">First</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">foo</span><span class="p">(</span><span class="dl">"</span><span class="s2">Second</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// First start</span>
<span class="c1">// First middle</span>
<span class="c1">// Second start</span>
<span class="c1">// Second middle</span>
<span class="c1">// First end</span>
<span class="c1">// Second end</span>
</code></pre></div></div> <p>上面的代码，执行到 <code class="language-plaintext highlighter-rouge">await</code> 时，后面的代码会整体被安排进一个新的微任务，此后的函数体变为异步执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nf">queueMicrotask</span><span class="p">(</span><span class="kd">function</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">microtask</span><span class="dl">"</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">queueMicrotask</span><span class="p">(</span><span class="nx">test</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="p">(</span><span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">async function start</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">await</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">async function resume</span><span class="dl">"</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">await</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">async function end</span><span class="dl">"</span><span class="p">);</span>
<span class="p">})();</span>

<span class="nf">queueMicrotask</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">queueMicrotask() after calling async function</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">script sync part end</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// async function start</span>
<span class="c1">// script sync part end</span>
<span class="c1">// microtask 1</span>
<span class="c1">// async function resume 1</span>
<span class="c1">// queueMicrotask() after calling async function</span>
<span class="c1">// microtask 2</span>
<span class="c1">// async function resume 2</span>
<span class="c1">// microtask 3</span>
<span class="c1">// async function end</span>
</code></pre></div></div> <p>上面的代码，<code class="language-plaintext highlighter-rouge">test</code> 方法总会在异步函数恢复执行前被调用，呈现轮流的调度。微任务被执行的顺序通常就是入队的先后顺序，而 <code class="language-plaintext highlighter-rouge">console.log("queueMicrotask() after calling async function");</code> 比 <code class="language-plaintext highlighter-rouge">await</code> 晚入队，因此 <code class="language-plaintext highlighter-rouge">"queueMicrotask() after calling async function"</code> 在异步函数第一次恢复之后才输出。</p> <h3 id="24-使用注意点">2.4 使用注意点</h3> <ul> <li><code class="language-plaintext highlighter-rouge">await</code> 命令只能用在 <code class="language-plaintext highlighter-rouge">async</code> 函数之中，如果用在普通函数，就会报错。</li> <li><code class="language-plaintext highlighter-rouge">for</code> 循环和数组的 <code class="language-plaintext highlighter-rouge">reduce</code> 方法支持 <code class="language-plaintext highlighter-rouge">async</code> 函数。</li> <li><code class="language-plaintext highlighter-rouge">async</code> 函数可以保留运行堆栈。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">b</span><span class="p">().</span><span class="nf">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nf">c</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，函数 <code class="language-plaintext highlighter-rouge">a</code> 内部运行了一个异步任务 <code class="language-plaintext highlighter-rouge">b</code>。当 <code class="language-plaintext highlighter-rouge">b</code> 运行的时候，函数 <code class="language-plaintext highlighter-rouge">a</code> 不会中断，而是继续执行。等到 <code class="language-plaintext highlighter-rouge">b</code> 运行结束，可能 <code class="language-plaintext highlighter-rouge">a</code> 早就运行结束了，<code class="language-plaintext highlighter-rouge">b</code> 所在的上下文环境已经消失了。如果 <code class="language-plaintext highlighter-rouge">b</code> 或 <code class="language-plaintext highlighter-rouge">c</code> 报错，错误堆栈将不包括 <code class="language-plaintext highlighter-rouge">a</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">await</span> <span class="nf">b</span><span class="p">();</span>
  <span class="nf">c</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">b</code> 运行的时候，<code class="language-plaintext highlighter-rouge">a</code> 是暂停执行，上下文环境都保存着。一旦 <code class="language-plaintext highlighter-rouge">b</code> 或 <code class="language-plaintext highlighter-rouge">c</code> 报错，错误堆栈将包括 <code class="language-plaintext highlighter-rouge">a</code>。</p> <h2 id="三async-函数的实现原理">三、async 函数的实现原理</h2> <p><code class="language-plaintext highlighter-rouge">async</code> 函数的实现原理，就是将 <strong>Generator 函数</strong>和<strong>自动执行器</strong>，包装在一个函数里。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">spawn</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>所有的 <code class="language-plaintext highlighter-rouge">async</code> 函数都可以写成上面的第二种形式，其中的 <code class="language-plaintext highlighter-rouge">spawn</code> 函数就是自动执行器。</p> <p>下面是 <code class="language-plaintext highlighter-rouge">spawn</code> 函数的实现，基本就是前文自动执行器的翻版。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">spawn</span><span class="p">(</span><span class="nx">genF</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nf">genF</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nf">step</span><span class="p">(</span><span class="nx">nextF</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">next</span><span class="p">;</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="nx">next</span> <span class="o">=</span> <span class="nf">nextF</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">resolve</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nb">Promise</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="p">).</span><span class="nf">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">step</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">step</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="nf">step</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="四顶层-await">四、顶层 await</h2> <p>从 ES2022 开始，允许在模块的顶层独立使用 <code class="language-plaintext highlighter-rouge">await</code> 命令。它的主要目的是使用 <code class="language-plaintext highlighter-rouge">await</code> 解决模块异步加载的问题。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// awaiting.js</span>
<span class="kd">const</span> <span class="nx">dynamic</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span><span class="nx">someMission</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nf">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">output</span> <span class="o">=</span> <span class="nf">someProcess</span><span class="p">((</span><span class="k">await</span> <span class="nx">dynamic</span><span class="p">).</span><span class="k">default</span><span class="p">,</span> <span class="k">await</span> <span class="nx">data</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，两个异步操作在输出的时候，都加上了 <code class="language-plaintext highlighter-rouge">await</code> 命令。只有等到异步操作完成，这个模块才会输出值。加载这个模块的写法如下。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// usage.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">output</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./awaiting.js</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">outputPlusValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">output</span> <span class="o">+</span> <span class="nx">value</span> <span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">outputPlusValue</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</code></pre></div></div> <p>注意，顶层 <code class="language-plaintext highlighter-rouge">await</code> 只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的 <code class="language-plaintext highlighter-rouge">require()</code> 是同步加载，如果有顶层 <code class="language-plaintext highlighter-rouge">await</code>，就没法处理加载了。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://es6.ruanyifeng.com/#docs/async">async 函数</a></li> <li>MDN，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></li> </ul>]]></content><author><name></name></author><category term="frontend"/><category term="React"/><category term="es6"/><summary type="html"><![CDATA[一、含义]]></summary></entry></feed>