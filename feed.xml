<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://feng-zhang0712.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://feng-zhang0712.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-27T12:53:10+00:00</updated><id>https://feng-zhang0712.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">《Web API 教程 - Geolocation API》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/geolocation/" rel="alternate" type="text/html" title="《Web API 教程 - Geolocation API》摘录"/><published>2024-11-21T00:00:00+00:00</published><updated>2024-11-21T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/geolocation</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/geolocation/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/webapi/geolocation">《Web API 教程 - Geolocation API》</a>一章中知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <p>Geolocation API 用于获取用户的地理位置。</p> <p>由于该功能涉及用户隐私，所以浏览器会提示用户，是否同意给出地理位置，用户可能会拒绝。另外，这个 API 只能在 HTTPS 环境使用。</p> <p>浏览器通过 <code class="language-plaintext highlighter-rouge">navigator.geolocation</code> 属性提供该 API。</p> <h2 id="一geolocation-对象">一、Geolocation 对象</h2> <p><code class="language-plaintext highlighter-rouge">navigator.geolocation</code> 属性返回一个 Geolocation 对象。该对象具有以下三个方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Geolocation.getCurrentPosition(success, error, options)</code>：返回一个 Position 对象，表示用户的当前位置。</li> <li><code class="language-plaintext highlighter-rouge">Geolocation.watchPosition(success, error, options)</code>：指定一个监听函数，每当用户的位置发生变化，就执行该监听函数。</li> <li><code class="language-plaintext highlighter-rouge">Geolocation.clearWatch(id)</code>：取消 <code class="language-plaintext highlighter-rouge">watchPosition()</code> 指定的监听函数。</li> </ul> <h3 id="11-geolocationgetcurrentposition">1.1 Geolocation.getCurrentPosition()</h3> <p><code class="language-plaintext highlighter-rouge">navigator.geolocation.getCurrentPosition(success, error, options)</code> 用于获取用户的位置。</p> <ul> <li><code class="language-plaintext highlighter-rouge">success</code>：用户同意给出位置时的回调函数，它的参数是一个 Position 对象。</li> <li><code class="language-plaintext highlighter-rouge">error</code>：用户拒绝给出位置时的回调函数，它的参数是一个 PositionError 对象。该参数可选。</li> <li><code class="language-plaintext highlighter-rouge">options</code>：参数对象，该参数可选。</li> </ul> <p>Position 对象有两个属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Position.coords</code>：返回一个 Coordinates 对象，表示当前位置的坐标。</li> <li><code class="language-plaintext highlighter-rouge">Position.timestamp</code>：返回一个对象，代表当前时间戳。</li> </ul> <p>PositionError 对象主要有两个属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">PositionError.code</code>：整数，表示发生错误的原因。<code class="language-plaintext highlighter-rouge">1</code> 表示无权限，有可能是用户拒绝授权；<code class="language-plaintext highlighter-rouge">2</code> 表示无法获得位置，可能设备有故障；<code class="language-plaintext highlighter-rouge">3</code> 表示超时。</li> <li><code class="language-plaintext highlighter-rouge">PositionError.message</code>：字符串，表示错误的描述。</li> </ul> <p>参数对象 <code class="language-plaintext highlighter-rouge">option</code> 可以指定三个属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">enableHighAccuracy</code>：布尔值，是否返回高精度结果。如果设为 <code class="language-plaintext highlighter-rouge">true</code>，可能导致响应时间变慢或（移动设备的）功耗增加；反之，如果设为 <code class="language-plaintext highlighter-rouge">false</code>，设备可以更快速地响应。默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">timeout</code>：正整数，表示等待查询的最长时间，单位为毫秒。默认值为 <code class="language-plaintext highlighter-rouge">Infinity</code>。</li> <li><code class="language-plaintext highlighter-rouge">maximumAge</code>：正整数，表示可接受的缓存最长时间，单位为毫秒。如果设为 <code class="language-plaintext highlighter-rouge">0</code>，表示不返回缓存值，必须查询当前的实际位置；如果设为 <code class="language-plaintext highlighter-rouge">Infinity</code>，必须返回缓存值，不管缓存了多少时间。默认值为 <code class="language-plaintext highlighter-rouge">0</code>。</li> </ul> <h3 id="12-geolocationwatchposition">1.2 Geolocation.watchPosition()</h3> <p><code class="language-plaintext highlighter-rouge">navigator.geolocation.watchPosition(success, error, options)</code></p> <ul> <li><code class="language-plaintext highlighter-rouge">success</code>：监听成功的回调函数，该函数的参数为一个 Position 对象。</li> <li><code class="language-plaintext highlighter-rouge">error</code>：该参数可选，表示监听失败的回调函数，该函数的参数是一个 PositionError 对象。</li> <li><code class="language-plaintext highlighter-rouge">options</code>：该参数可选，表示监听的参数配置对象。</li> </ul> <p>该方法返回一个整数值，表示监听函数的编号。该整数用来供 <code class="language-plaintext highlighter-rouge">Geolocation.clearWatch(id)</code> 取消监听。</p> <h3 id="13-geolocationclearwatch">1.3 Geolocation.clearWatch()</h3> <p><code class="language-plaintext highlighter-rouge">navigator.geolocation.clearWatch(id)</code> 用来取消 <code class="language-plaintext highlighter-rouge">watchPosition()</code> 指定的监听函数。它的参数是 <code class="language-plaintext highlighter-rouge">watchPosition()</code> 返回的监听函数的编号。</p> <h2 id="二coordinates-对象">二、Coordinates 对象</h2> <p>Coordinates 对象是地理位置的坐标接口，<code class="language-plaintext highlighter-rouge">Position.coords</code> 属性返回的就是这个对象。</p> <p>它有以下属性，全部为只读属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Coordinates.latitude</code>：浮点数，表示纬度。</li> <li><code class="language-plaintext highlighter-rouge">Coordinates.longitude</code>：浮点数，表示经度。</li> <li><code class="language-plaintext highlighter-rouge">Coordinates.altitude</code>：浮点数，表示海拔（单位：米）。</li> <li><code class="language-plaintext highlighter-rouge">Coordinates.accuracy</code>：浮点数，表示经度和纬度的精度（单位：米）。</li> <li><code class="language-plaintext highlighter-rouge">Coordinates.altitudeAccuracy</code>：浮点数，表示海拔的精度（单位：米）。</li> <li><code class="language-plaintext highlighter-rouge">Coordinates.speed</code>：浮点数，表示设备的速度（单位：米/秒）。</li> <li><code class="language-plaintext highlighter-rouge">Coordinates.heading</code>：浮点数，表示设备前进的方向（单位：度）。方向按照顺时针，北方是 <code class="language-plaintext highlighter-rouge">0</code> 度，东方是 <code class="language-plaintext highlighter-rouge">90</code> 度，西方是 <code class="language-plaintext highlighter-rouge">270</code> 度。如果 <code class="language-plaintext highlighter-rouge">Coordinates.speed</code> 为 <code class="language-plaintext highlighter-rouge">0</code>，<code class="language-plaintext highlighter-rouge">heading</code> 属性返回 <code class="language-plaintext highlighter-rouge">NaN</code>。</li> </ul> <h2 id="三参考">三、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/webapi/geolocation">Web API 教程 - Geolocation API</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[本文是对《Web API 教程 - Geolocation API》一章中知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry><entry><title type="html">ES6 - 数值的扩展</title><link href="https://feng-zhang0712.github.io//blog/2024/number/" rel="alternate" type="text/html" title="ES6 - 数值的扩展"/><published>2024-11-14T00:00:00+00:00</published><updated>2024-11-14T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/number</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/number/"><![CDATA[<blockquote> <p>本文是对<a href="https://es6.ruanyifeng.com/#docs/number">《ECMAScript 6 入门 - 数值的扩展</a>一章中知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一二进制和八进制表示法">一、二进制和八进制表示法</h2> <p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 <code class="language-plaintext highlighter-rouge">0b</code>（或 <code class="language-plaintext highlighter-rouge">0B</code>）和 <code class="language-plaintext highlighter-rouge">0o</code>（或 <code class="language-plaintext highlighter-rouge">0O</code>）表示。</p> <h2 id="二数值分隔符">二、数值分隔符</h2> <p>ES2021 开始允许 JavaScript 的数值使用下划线（<code class="language-plaintext highlighter-rouge">_</code>）作为分隔符。</p> <p>数值分隔符有如下特点。</p> <ul> <li>数值分隔符没有指定间隔的位数。</li> <li>小数和科学计数法也可以使用数值分隔符。</li> <li>除了十进制，其他进制的数值也可以使用分隔符，但是，分隔符不能紧跟着进制的前缀 <code class="language-plaintext highlighter-rouge">0b</code>、<code class="language-plaintext highlighter-rouge">0B</code>、<code class="language-plaintext highlighter-rouge">0o</code>、<code class="language-plaintext highlighter-rouge">0O</code>、<code class="language-plaintext highlighter-rouge">0x</code>、<code class="language-plaintext highlighter-rouge">0X</code>。</li> <li>数值分隔符只是一种书写便利，对于 JavaScript 内部数值的存储和输出，并没有影响。</li> </ul> <p>使用数值分隔符时要注意：</p> <ul> <li>不能放在数值的最前面（leading）或最后面（trailing）。</li> <li>小数点的前后不能有分隔符。</li> <li>不能两个或两个以上的分隔符连在一起。</li> <li>科学计数法里面，表示指数的 <code class="language-plaintext highlighter-rouge">e</code> 或 <code class="language-plaintext highlighter-rouge">E</code> 前后不能有分隔符。</li> </ul> <h2 id="三numberisfinite-numberisnan">三、Number.isFinite(), Number.isNaN()</h2> <ul> <li><code class="language-plaintext highlighter-rouge">Number.isFinite(value)</code> 用来检查一个数值是否为有限的（finite），即不是 <code class="language-plaintext highlighter-rouge">Infinity</code>。如果参数类型不是数值，一律返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">Number.isNaN(value)</code> 用来检查一个值是否为 <code class="language-plaintext highlighter-rouge">NaN</code>。如果参数类型不是 <code class="language-plaintext highlighter-rouge">NaN</code>，一律返回 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <p>它们与传统的全局方法 <code class="language-plaintext highlighter-rouge">isFinite()</code> 和 <code class="language-plaintext highlighter-rouge">isNaN()</code> 的区别在于，传统方法先调用 <code class="language-plaintext highlighter-rouge">Number()</code> 将非数值的值转为数值，再进行判断，而这两个新方法<strong>只对数值有效</strong>。</p> <h2 id="四numberparseint-numberparsefloat">四、Number.parseInt(), Number.parseFloat()</h2> <p><code class="language-plaintext highlighter-rouge">Number.parseInt(string, radix)</code> 和 <code class="language-plaintext highlighter-rouge">Number.parseFloat(string)</code> 的行为完全一致，只是将全局方法 <code class="language-plaintext highlighter-rouge">parseInt()</code> 和 <code class="language-plaintext highlighter-rouge">parseFloat()</code> 移植到了 <code class="language-plaintext highlighter-rouge">Number</code> 对象上面。</p> <h2 id="五numberisinteger">五、Number.isInteger()</h2> <p><code class="language-plaintext highlighter-rouge">Number.isInteger(value)</code> 用来判断一个数值是否为整数。如果参数不是数值，则返回 <code class="language-plaintext highlighter-rouge">false</code>。</p> <h2 id="六numberepsilon">六、Number.EPSILON</h2> <p>Number.EPSILON 表示 JavaScript 能够表示的最小精度。</p> <h2 id="七安全整数和-numberissafeinteger">七、安全整数和 Number.isSafeInteger()</h2> <p>JavaScript 能够准确表示的整数范围在 <code class="language-plaintext highlighter-rouge">-2^53</code> 到 <code class="language-plaintext highlighter-rouge">2^53</code> 之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了 <code class="language-plaintext highlighter-rouge">Number.MAX_SAFE_INTEGER</code> 和 <code class="language-plaintext highlighter-rouge">Number.MIN_SAFE_INTEGER</code> 这两个常量，用来表示这个范围的上下限。<code class="language-plaintext highlighter-rouge">Number.isSafeInteger(value)</code> 则是用来判断一个整数是否落在这个范围之内。</p> <h2 id="八math-对象的扩展">八、Math 对象的扩展</h2> <p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Math.trunc()</code> 用于去除一个数的小数部分，返回整数部分。</li> <li><code class="language-plaintext highlighter-rouge">Math.sign()</code> 用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</li> <li><code class="language-plaintext highlighter-rouge">Math.cbrt()</code> 用于计算一个数的立方根。</li> <li><code class="language-plaintext highlighter-rouge">Math.clz32()</code> 将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</li> <li><code class="language-plaintext highlighter-rouge">Math.imul()</code> 返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</li> <li><code class="language-plaintext highlighter-rouge">Math.fround()</code> 返回一个数的 32 位单精度浮点数形式。</li> <li><code class="language-plaintext highlighter-rouge">Math.hypot()</code> 返回所有参数的平方和的平方根。</li> <li><code class="language-plaintext highlighter-rouge">Math.expm1(x)</code> 返回 $ e^x - 1 $，即 <code class="language-plaintext highlighter-rouge">Math.exp(x) - 1</code>。</li> <li><code class="language-plaintext highlighter-rouge">Math.log1p(x)</code> 返回 <code class="language-plaintext highlighter-rouge">1 + x</code> 的自然对数，即 <code class="language-plaintext highlighter-rouge">Math.log(1 + x)</code>。如果 <code class="language-plaintext highlighter-rouge">x</code> 小于 -1，返回 NaN。</li> <li><code class="language-plaintext highlighter-rouge">Math.log10(x)</code> 返回以 10 为底的 <code class="language-plaintext highlighter-rouge">x</code> 的对数。如果 <code class="language-plaintext highlighter-rouge">x</code> 小于 0，则返回 NaN。</li> <li><code class="language-plaintext highlighter-rouge">Math.log2(x)</code> 返回以 2 为底的 <code class="language-plaintext highlighter-rouge">x</code> 的对数。如果 <code class="language-plaintext highlighter-rouge">x</code> 小于 0，则返回 NaN。</li> <li><code class="language-plaintext highlighter-rouge">Math.sinh(x)</code> 返回x的双曲正弦（hyperbolic sine）</li> <li><code class="language-plaintext highlighter-rouge">Math.cosh(x)</code> 返回x的双曲余弦（hyperbolic cosine）</li> <li><code class="language-plaintext highlighter-rouge">Math.tanh(x)</code> 返回x的双曲正切（hyperbolic tangent）</li> <li><code class="language-plaintext highlighter-rouge">Math.asinh(x)</code> 返回x的反双曲正弦（inverse hyperbolic sine）</li> <li><code class="language-plaintext highlighter-rouge">Math.acosh(x)</code> 返回x的反双曲余弦（inverse hyperbolic cosine）</li> <li><code class="language-plaintext highlighter-rouge">Math.atanh(x)</code> 返回x的反双曲正切（inverse hyperbolic tangent）</li> </ul> <h2 id="九bigint-数据类型">九、BigInt 数据类型</h2> <p>ES2020 引入了一种新的数据类型 BigInt（大整数）。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。BigInt 可以使用各种进制表示，后缀要加上 <code class="language-plaintext highlighter-rouge">n</code>。</p> <ul> <li>BigInt 与普通整数是两种值，它们之间并不相等。</li> <li>typeof 运算符对于 BigInt 类型的数据返回 <code class="language-plaintext highlighter-rouge">'bigint'</code>。</li> <li>BigInt 可以使用负号（<code class="language-plaintext highlighter-rouge">-</code>），但是不能使用正号（<code class="language-plaintext highlighter-rouge">+</code>），因为会与 <code class="language-plaintext highlighter-rouge">asm.js</code> 冲突。</li> </ul> <p>BigInt 的静态方法如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">BigInt.asUintN(width, BigInt)</code>： 给定的 BigInt 转为 <code class="language-plaintext highlighter-rouge">0</code> 到 $ 2^{width} - 1 $ 之间对应的值。</li> <li><code class="language-plaintext highlighter-rouge">BigInt.asIntN(width, BigInt)</code>：给定的 BigInt 转为 $ -2^{width} - 1 $ 到 $ 2^{width} - 1 - 1 $ 之间对应的值。</li> <li><code class="language-plaintext highlighter-rouge">BigInt.parseInt(string[, radix])</code>：近似于 <code class="language-plaintext highlighter-rouge">Number.parseInt()</code>，将一个字符串转换成指定进制的 BigInt。</li> </ul> <p>BigInt 的实例方法如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">BigInt.prototype.toString()</code></li> <li><code class="language-plaintext highlighter-rouge">BigInt.prototype.valueOf()</code></li> <li><code class="language-plaintext highlighter-rouge">BigInt.prototype.toLocaleString()</code></li> </ul> <h3 id="91-转换规则">9.1 转换规则</h3> <p>可以使用 <code class="language-plaintext highlighter-rouge">BigInt()</code> 将布尔值、数值和字符串类型的值转为 BigInt 类型，也可将 BigInt 类型的值通过 <code class="language-plaintext highlighter-rouge">Boolean()</code>、<code class="language-plaintext highlighter-rouge">Number()</code> 和 <code class="language-plaintext highlighter-rouge">String()</code> 转为布尔值、数值和字符串类型。</p> <p>取反运算符（<code class="language-plaintext highlighter-rouge">!</code>）也可以将 BigInt 转为布尔值。</p> <h3 id="92-数学运算">9.2 数学运算</h3> <p>BigInt 类型的 <code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">*</code> 和 <code class="language-plaintext highlighter-rouge">**</code> 这四个二元运算符，与 Number 类型的行为一致。除法运算 <code class="language-plaintext highlighter-rouge">/</code> 会舍去小数部分，返回一个整数。</p> <p>几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。</p> <ul> <li>不带符号的右移位运算符 <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code></li> <li>一元的求正运算符 <code class="language-plaintext highlighter-rouge">+</code></li> </ul> <p>BigInt 不能与普通数值进行混合运算。</p> <h3 id="93-其他运算">9.3 其他运算</h3> <p>比较运算符（比如 <code class="language-plaintext highlighter-rouge">&gt;</code>）和相等运算符（<code class="language-plaintext highlighter-rouge">==</code>）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。</p> <p>BigInt 与字符串混合运算时，会先转为字符串，再进行运算。</p> <h2 id="十参考">十、参考</h2> <ul> <li>阮一峰，<a href="https://es6.ruanyifeng.com/#docs/number">数值的扩展</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="ES6"/><category term="Number"/><summary type="html"><![CDATA[本文是对《ECMAScript 6 入门 - 数值的扩展一章中知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry><entry><title type="html">《Web API 教程 - Canvas API》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/canvas/" rel="alternate" type="text/html" title="《Web API 教程 - Canvas API》摘录"/><published>2024-11-13T00:00:00+00:00</published><updated>2024-11-13T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/canvas</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/canvas/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/webapi/canvas">《Web API 教程 - Canvas API》</a>一章中知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一概述">一、概述</h2> <p><code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上 <code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 是一个可以用 JavaScript 操作的位图（bitmap）。</p> <p>它与 SVG 图像的区别在于：</p> <ul> <li><code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 是脚本调用各种方法生成图像。</li> <li>SVG 是一个 XML 文件，通过各种子元素生成图像。</li> </ul> <p>使用 Canvas API 之前，需要在网页里面新建一个 <code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;canvas</span> <span class="na">id=</span><span class="s">"myCanvas"</span> <span class="na">width=</span><span class="s">"400"</span> <span class="na">height=</span><span class="s">"250"</span><span class="nt">&gt;</span>
  您的浏览器不支持 Canvas
<span class="nt">&lt;/canvas&gt;</span>
</code></pre></div></div> <p>每个 <code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 元素都有一个对应的 <code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D</code> 对象（上下文对象）。Canvas API 就定义在这个对象上面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 元素节点对象的 <code class="language-plaintext highlighter-rouge">getContext()</code>，返回的就是 <code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D</code> 对象。</p> <p>注意，Canvas API 需要 <code class="language-plaintext highlighter-rouge">getContext</code> 方法指定参数 <code class="language-plaintext highlighter-rouge">2d</code>，表示该 <code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 节点生成 2D 的平面图像。如果参数是 <code class="language-plaintext highlighter-rouge">webgl</code>，就表示用于生成 3D 的立体图案，这部分属于 WebGL API。</p> <p>按照用途，Canvas API 分成两大部分：<strong>绘制图形</strong>和<strong>图像处理</strong>。</p> <h2 id="二canvas-api绘制图形">二、Canvas API：绘制图形</h2> <p>Canvas 画布提供了一个作图的平面空间，该空间的每个点都有自己的坐标。原点 <code class="language-plaintext highlighter-rouge">(0, 0)</code> 位于图像左上角，<code class="language-plaintext highlighter-rouge">x</code> 轴的正向是原点向右，<code class="language-plaintext highlighter-rouge">y</code> 轴的正向是原点向下。</p> <h3 id="21-路径">2.1 路径</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.beginPath()</code>：开始绘制路径。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.closePath()</code>：结束路径，返回到当前路径的起始点，会从当前点到起始点绘制一条直线。如果图形已经封闭，或者只有一个点，那么此方法不会产生任何效果。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.moveTo(x, y)</code>：设置路径的起点，即将一个新路径的起始点移动到 <code class="language-plaintext highlighter-rouge">(x，y)</code> 坐标。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.lineTo(x, y)</code>：使用直线从当前点连接到 <code class="language-plaintext highlighter-rouge">(x, y)</code> 坐标。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.fill(path, fillRule)</code>：在路径<strong>内部</strong>填充颜色（形成实心线条，默认为黑色）。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.stroke(path)</code>：路<strong>径线</strong>条着色（形成空心线条，默认为黑色）。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.fillStyle</code>：指定路径填充的颜色和样式（默认为黑色）。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.strokeStyle</code>：指定路径线条的颜色和样式（默认为黑色）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nf">beginPath</span><span class="p">();</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">moveTo</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">lineTo</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">lineTo</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">fill</span><span class="p">();</span>
<span class="c1">// 或者</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">strokeStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">stroke</span><span class="p">();</span>
</code></pre></div></div> <h3 id="22-线型">2.2 线型</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.lineWidth</code>：指定线条的宽度，默认为 1.0。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.lineCap</code>：指定线条末端的样式，有三个可能的值：<code class="language-plaintext highlighter-rouge">butt</code>（默认值，末端为矩形）、<code class="language-plaintext highlighter-rouge">round</code>（末端为圆形）、<code class="language-plaintext highlighter-rouge">square</code>（末端为突出的矩形，矩形宽度不变，高度为线条宽度的一半）。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.lineJoin</code>：指定线段交点的样式，有三个可能的值：<code class="language-plaintext highlighter-rouge">round</code>（交点为扇形）、<code class="language-plaintext highlighter-rouge">bevel</code>（交点为三角形底边）、<code class="language-plaintext highlighter-rouge">miter</code>（默认值，交点为菱形）。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.miterLimit</code>：指定交点菱形的长度，默认为 10。该属性只在 <code class="language-plaintext highlighter-rouge">lineJoin</code> 属性的值等于 <code class="language-plaintext highlighter-rouge">miter</code> 时有效。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.setLineDash(segments)</code>：数组，用于指定虚线里面线段和间距的长度。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.getLineDash()</code>：返回一个数组，表示虚线里面线段和间距的长度。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nf">beginPath</span><span class="p">();</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">moveTo</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">lineTo</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">lineTo</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nx">lineWidth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">lineCap</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">round</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">lineJoin</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">round</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">setLineDash</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">stroke</span><span class="p">();</span>
</code></pre></div></div> <p>上面代码中，线条的宽度为 3，线条的末端和交点都改成圆角，并且设置为虚线。</p> <h3 id="23-矩形">2.3 矩形</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.rect(x, y, width, height)</code>：绘制矩形路径。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.fillRect(x, y, width, height)</code>：填充一个矩形。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.strokeRect(x, y, width, height)</code>：绘制矩形边框。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.clearRect(x, y, width, height)</code>：指定矩形区域的像素都变成透明。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">green</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">fillRect</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码绘制一个绿色的正方形，左上角坐标为 <code class="language-plaintext highlighter-rouge">(10, 10)</code>，宽和高都为 100。</p> <h3 id="24-弧线">2.4 弧线</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.arc(x, y, radius, startAngle, endAngle, counterclockwise)</code>：通过指定圆心和半径绘制弧形。此方法主要用来绘制圆形或扇形。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.arcTo(x1, y1, x2, y2, radius)</code>：通过指定两根切线和半径绘制弧形。此方法主要用来绘制圆弧。</li> </ul> <h3 id="25-文本">2.5 文本</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.font</code>：指定字型大小和字体，默认值为 <code class="language-plaintext highlighter-rouge">10px sans-serif</code>。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.textAlign</code>：文本的对齐方式，默认值为 <code class="language-plaintext highlighter-rouge">start</code>。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.direction</code>：文本的方向，默认值为 <code class="language-plaintext highlighter-rouge">inherit</code>。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.textBaseline</code>：文本的垂直位置，默认值为 <code class="language-plaintext highlighter-rouge">alphabetic</code>。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.fillText(text, x, y, maxWidth)</code>：在指定位置绘制实心字符。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.strokeText(text, x, y, maxWidth)</code>：在指定位置绘制空心字符。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.measureText(text)</code>：返回一个 TextMetrics 对象。</li> </ul> <h3 id="26-渐变色和图像填充">2.6 渐变色和图像填充</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.createLinearGradient(x0, y0, x1, y1)</code>：定义线性渐变样式。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.createRadialGradient(x0, y0, r0, x1, y1, r1)</code>：定义辐射渐变样式。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.createPattern(image, repetition)</code>：定义图像填充样式。</li> </ul> <p><code class="language-plaintext highlighter-rouge">createLinearGradient</code> 方法的返回值是一个 CanvasGradient 对象，该对象只有一个 <code class="language-plaintext highlighter-rouge">addColorStop()</code>，用来指定渐变点的颜色。<code class="language-plaintext highlighter-rouge">addColorStop()</code> 接受两个参数，第一个参数是 0 到 1 之间的一个位置量，0 表示起点，1 表示终点，第二个参数是一个字符串，表示 CSS 颜色。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">gradient</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">createLinearGradient</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">gradient</span><span class="p">.</span><span class="nf">addColorStop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">green</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">gradient</span><span class="p">.</span><span class="nf">addColorStop</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="nx">gradient</span><span class="p">;</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">fillRect</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，定义了渐变样式 <code class="language-plaintext highlighter-rouge">gradient</code> 以后，将这个样式指定给 <code class="language-plaintext highlighter-rouge">fillStyle</code> 属性，然后 <code class="language-plaintext highlighter-rouge">fillRect()</code> 就会生成以这个样式填充的矩形区域。</p> <h3 id="27-阴影">2.7 阴影</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.shadowBlur</code>：阴影的模糊程度，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.shadowColor</code>：阴影的颜色，默认为 <code class="language-plaintext highlighter-rouge">black</code>。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.shadowOffsetX</code>：阴影的水平位移，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.shadowOffsetY</code>：阴影的垂直位移，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> </ul> <h2 id="三canvas-api图像处理">三、Canvas API：图像处理</h2> <h3 id="31-canvasrenderingcontext2ddrawimage">3.1 CanvasRenderingContext2D.drawImage()</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">drawImage</span><span class="p">(</span><span class="nx">image</span><span class="p">,</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">)</span>
<span class="nf">drawImage</span><span class="p">(</span><span class="nx">image</span><span class="p">,</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">,</span> <span class="nx">dWidth</span><span class="p">,</span> <span class="nx">dHeight</span><span class="p">)</span>
<span class="nf">drawImage</span><span class="p">(</span><span class="nx">image</span><span class="p">,</span> <span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">,</span> <span class="nx">sWidth</span><span class="p">,</span> <span class="nx">sHeight</span><span class="p">,</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">,</span> <span class="nx">dWidth</span><span class="p">,</span> <span class="nx">dHeight</span><span class="p">)</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">image</code>：图像元素</li> <li><code class="language-plaintext highlighter-rouge">sx</code>：图像内部的横坐标，用于映射到画布的放置点上。</li> <li><code class="language-plaintext highlighter-rouge">sy</code>：图像内部的纵坐标，用于映射到画布的放置点上。</li> <li><code class="language-plaintext highlighter-rouge">sWidth</code>：图像在画布上的宽度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的宽度。</li> <li><code class="language-plaintext highlighter-rouge">sHeight</code>：图像在画布上的高度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的高度。</li> <li><code class="language-plaintext highlighter-rouge">dx</code>：画布内部的横坐标，用于放置图像的左上角</li> <li><code class="language-plaintext highlighter-rouge">dy</code>：画布内部的纵坐标，用于放置图像的右上角</li> <li><code class="language-plaintext highlighter-rouge">dWidth</code>：图像在画布内部的宽度，会产生缩放效果。</li> <li><code class="language-plaintext highlighter-rouge">dHeight</code>：图像在画布内部的高度，会产生缩放效果。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Image</span><span class="p">();</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">image.png</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">drawImage</span><span class="p">(</span><span class="nx">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码将一个 PNG 图像放入画布。这时，图像将是原始大小，如果画布小于图像，就会只显示出图像左上角，正好等于画布大小的那一块。</p> <h3 id="32-像素读写">3.2 像素读写</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.getImageData(sx, sy, sw, sh, settings)</code>：将画布读取成一个 ImageData 对象</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.putImageData(imageData, dx, dy)</code>：将 ImageData 对象写入画布</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.createImageData(width, height, settings)</code>：生成一个空的 ImageData 对象</li> </ul> <h3 id="33-canvasrenderingcontext2dsavecanvasrenderingcontext2drestore">3.3 CanvasRenderingContext2D.save()，CanvasRenderingContext2D.restore()</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.save()</code> 用于将画布的当前样式保存到堆栈，相当于在内存之中产生一个样式快照。</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.restore()</code> 将画布的样式恢复到上一个保存的快照，如果没有已保存的快照，则不产生任何效果。</li> </ul> <h3 id="34-canvasrenderingcontext2dcanvas">3.4 CanvasRenderingContext2D.canvas</h3> <p><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.canvas</code> 属性指向当前 <code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D</code> 对象所在的 <code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 元素。该属性只读。</p> <h3 id="35-图像变换">3.5 图像变换</h3> <ul> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.rotate(angle)</code>：图像旋转</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.scale(x, y)</code>：图像缩放</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.translate(x, y)</code>：图像平移</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.transform(a, b, c, d, e, f)</code>：通过一个变换矩阵完成图像变换</li> <li><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D.setTransform(a, b, c, d, e, f | matrix)</code>：取消前面的图像变换</li> </ul> <h2 id="四-元素的方法">四、<canvas> 元素的方法</canvas></h2> <ul> <li><code class="language-plaintext highlighter-rouge">HTMLCanvasElement.toDataURL(type, encoderOptions)</code> 将 Canvas 数据转为 Data URI 格式的图像，该方法的返回值是一个 Data URI 格式的字符串。</li> <li><code class="language-plaintext highlighter-rouge">HTMLCanvasElement.toBlob(callback, type, quality)</code> 用于将 <code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 图像转成一个 Blob 对象，默认类型是 <code class="language-plaintext highlighter-rouge">image/png</code>。它的使用格式如下。该方法没有返回值。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">blobToImg</span><span class="p">(</span><span class="nx">blob</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">newImg</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">img</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">URL</span><span class="p">.</span><span class="nf">createObjectURL</span><span class="p">(</span><span class="nx">blob</span><span class="p">);</span>

  <span class="nx">newImg</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 使用完毕，释放 URL 对象</span>
    <span class="nx">URL</span><span class="p">.</span><span class="nf">revokeObjectURL</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nx">newImg</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">newImg</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">canvas</span><span class="p">.</span><span class="nf">toBlob</span><span class="p">(</span><span class="nx">blobToImg</span><span class="p">);</span>
</code></pre></div></div> <p>上面的例子将 <code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 图像复制成 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 图像。</p> <h2 id="五canvas-使用实例">五、Canvas 使用实例</h2> <h3 id="51-动画效果">5.1 动画效果</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">posX</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">posY</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="nf">setInterval</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">fillRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

  <span class="nx">posX</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">posY</span> <span class="o">+=</span> <span class="mf">0.25</span><span class="p">;</span>

  <span class="nx">ctx</span><span class="p">.</span><span class="nf">beginPath</span><span class="p">();</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">;</span>

  <span class="nx">ctx</span><span class="p">.</span><span class="nf">arc</span><span class="p">(</span><span class="nx">posX</span><span class="p">,</span> <span class="nx">posY</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">closePath</span><span class="p">();</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">fill</span><span class="p">();</span>
<span class="p">},</span> <span class="mi">30</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码会产生一个小圆点，每隔 30 毫秒就向右下方移动的效果。<code class="language-plaintext highlighter-rouge">setInterval()</code> 函数的一开始，之所以要将画布重新渲染黑色底色，是为了抹去上一步的小圆点。</p> <h3 id="52-像素处理">5.2 像素处理</h3> <p>通过 <code class="language-plaintext highlighter-rouge">getImageData()</code> 和 <code class="language-plaintext highlighter-rouge">putImageData()</code>，可以处理每个像素，进而操作图像内容，因此可以改写图像。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">imageData</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">getImageData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
  <span class="nf">filter</span><span class="p">(</span><span class="nx">imageData</span><span class="p">);</span>
  <span class="nx">context</span><span class="p">.</span><span class="nf">putImageData</span><span class="p">(</span><span class="nx">imageData</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">filter</code> 是一个处理像素的函数。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/webapi/canvas">Web API 教程 - Canvas API</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[本文是对《Web API 教程 - Canvas API》一章中知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry><entry><title type="html">88. 合并两个有序数组</title><link href="https://feng-zhang0712.github.io//blog/2024/88-merge-sorted-array/" rel="alternate" type="text/html" title="88. 合并两个有序数组"/><published>2024-11-04T00:00:00+00:00</published><updated>2024-11-04T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/88-merge-sorted-array</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/88-merge-sorted-array/"><![CDATA[<h2 id="问题描述">问题描述</h2> <p>给你两个按非递减顺序排列的整数数组 <code class="language-plaintext highlighter-rouge">nums1</code> 和 <code class="language-plaintext highlighter-rouge">nums2</code>，另有两个整数 <code class="language-plaintext highlighter-rouge">m</code> 和 <code class="language-plaintext highlighter-rouge">n</code>，分别表示 <code class="language-plaintext highlighter-rouge">nums1</code> 和 <code class="language-plaintext highlighter-rouge">nums2</code> 中的元素数目。请你合并 <code class="language-plaintext highlighter-rouge">nums2</code> 到 <code class="language-plaintext highlighter-rouge">nums1</code> 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 <code class="language-plaintext highlighter-rouge">nums1</code> 中。为了应对这种情况，<code class="language-plaintext highlighter-rouge">nums1</code> 的初始长度为 <code class="language-plaintext highlighter-rouge">m + n</code>，其中前 <code class="language-plaintext highlighter-rouge">m</code> 个元素表示应合并的元素，后 <code class="language-plaintext highlighter-rouge">n</code> 个元素为 <code class="language-plaintext highlighter-rouge">0</code>，应忽略。<code class="language-plaintext highlighter-rouge">nums2</code> 的长度为 <code class="language-plaintext highlighter-rouge">n</code>。</p> <p>原始题目连接：<a href="https://leetcode.cn/problems/merge-sorted-array/description/">合并两个有序数组</a>。</p> <h2 id="方法一">方法一</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">nums1</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">nums1</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">nums1</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">m</span><span class="p">,</span> <span class="p">...</span><span class="nx">nums2</span><span class="p">);</span>
  <span class="nx">nums1</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="方法-2">方法 2</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">nums1</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">sortedArr</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">while </span><span class="p">(</span><span class="nx">p1</span> <span class="o">+</span> <span class="nx">p2</span> <span class="o">&lt;</span> <span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">p1</span> <span class="o">&lt;</span> <span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">p2</span> <span class="o">&gt;=</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">sortedArr</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">p1</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">p1</span> <span class="o">&gt;=</span> <span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">p2</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">sortedArr</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">p2</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">sortedArr</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">p2</span><span class="p">]</span> <span class="p">?</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">p1</span><span class="o">++</span><span class="p">]</span> <span class="p">:</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">p2</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="nx">idx</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">sortedArr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sortedArr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[问题描述]]></summary></entry><entry><title type="html">《JavaScript 教程 - 浏览器模型》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/bom/" rel="alternate" type="text/html" title="《JavaScript 教程 - 浏览器模型》摘录"/><published>2024-10-18T00:00:00+00:00</published><updated>2024-10-18T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/bom</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/bom/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/bom/">《JavaScript 教程 - 浏览器模型》</a>一章中部分知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一浏览器模型概述">一、浏览器模型概述</h2> <h3 id="1-代码嵌入网页的方法">1. 代码嵌入网页的方法</h3> <p>网页中嵌入 JavaScript 代码，主要有四种方法。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素直接嵌入代码。</p> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性用来指定脚本类型。<code class="language-plaintext highlighter-rouge">type</code> 属性可以设为两种值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">text/javascript</code>：这是<strong>默认值</strong>，也是历史上一贯设定的值。如果你省略 <code class="language-plaintext highlighter-rouge">type</code> 属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li> <li><code class="language-plaintext highlighter-rouge">application/javascript</code>：对于较新的浏览器，建议设为这个值。</li> </ul> <p><strong>如果 <code class="language-plaintext highlighter-rouge">type</code> 属性的值，浏览器不认识，那么它不会执行其中的代码</strong>。利用这一点，可以在 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的 <code class="language-plaintext highlighter-rouge">type</code> 属性即可。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签通过 <code class="language-plaintext highlighter-rouge">src</code> 属性加载外部脚本。为了防止攻击者篡改外部脚本，<code class="language-plaintext highlighter-rouge">script</code> 标签允许设置一个 <code class="language-plaintext highlighter-rouge">integrity</code> 属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://www.example.com/script.js"</span>
  <span class="na">integrity=</span><span class="s">"sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs="</span><span class="nt">&gt;</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div> </div> </li> <li> <p>事件属性：网页元素的事件属性（比如 <code class="language-plaintext highlighter-rouge">onclick</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">"myBtn"</span> <span class="na">onclick=</span><span class="s">"console.log(this.id)"</span><span class="nt">&gt;</span>点击<span class="nt">&lt;/button&gt;</span>
</code></pre></div> </div> </li> <li> <p>URL 协议：URL 支持 <code class="language-plaintext highlighter-rouge">javascript:</code> 协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"javascript:console.log('Hello')"</span><span class="nt">&gt;</span>点击<span class="nt">&lt;/a&gt;</span>
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">javascript:</code> 协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以 <code class="language-plaintext highlighter-rouge">javascript:</code> 网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上 <code class="language-plaintext highlighter-rouge">void</code>，或者在脚本最后加上 <code class="language-plaintext highlighter-rouge">void 0</code>。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"javascript: void new Date().toLocaleTimeString();"</span><span class="nt">&gt;</span>点击<span class="nt">&lt;/a&gt;</span>
<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"javascript: new Date().toLocaleTimeString();void 0;"</span><span class="nt">&gt;</span>点击<span class="nt">&lt;/a&gt;</span>
</code></pre></div> </div> <p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p> </li> </ul> <h3 id="2-script-元素">2. script 元素</h3> <h4 id="21-工作原理">2.1 工作原理</h4> <p>正常的网页加载流程是这样的。</p> <ol> <li>对于 HTML 网页，浏览器边下载边解析。</li> <li>解析过程中，浏览器发现 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li> <li>如果 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li> <li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li> </ol> <p><strong>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染</strong>。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p> <p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“<strong>假死</strong>”状态，这被称为“<strong>阻塞效应</strong>”。</p> <p>为了避免这种情况，较好的做法是将 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签都放在页面底部，而不是头部。这样做有几个好处。</p> <ul> <li>即使遇到脚本失去响应，网页主体的渲染也已经完成，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</li> <li>避免因 DOM 结构生成之前调用 DOM 节点而导致的 JavaScript 报错，因为这时 DOM 已经生成了。</li> </ul> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;script&gt;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">);</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div> <p>上面代码执行时会报错，因为此时 <code class="language-plaintext highlighter-rouge">document.body</code> 元素还未生成。有几种方式可以解决这个问题。</p> <ul> <li>设定 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件的回调函数。</li> <li>使用 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">onload</code> 属性。</li> <li>将脚本放在页面底部。</li> </ul> <p>如果有多个 <code class="language-plaintext highlighter-rouge">script</code> 标签，比如下面这样。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"a.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"b.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div> <p>浏览器会同时<strong>并行</strong>下载 <code class="language-plaintext highlighter-rouge">a.js</code> 和 <code class="language-plaintext highlighter-rouge">b.js</code>，但是，执行时会保证先执行 <code class="language-plaintext highlighter-rouge">a.js</code>，然后再执行 <code class="language-plaintext highlighter-rouge">b.js</code>，即使后者先下载完成，也是如此。也就是说，<strong>脚本的执行顺序由它们在页面中的出现顺序决定</strong>，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p> <p><strong>解析和执行 CSS，也会产生阻塞</strong>。</p> <p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载 6～20 个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p> <h4 id="22-defer-属性">2.2 defer 属性</h4> <p><code class="language-plaintext highlighter-rouge">defer</code> 属性可以延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。<code class="language-plaintext highlighter-rouge">defer</code> 属性的运行流程如下。</p> <ol> <li>浏览器开始解析 HTML 网页。</li> <li>解析过程中，发现带有 <code class="language-plaintext highlighter-rouge">defer</code> 属性的 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素。</li> <li>浏览器继续往下解析 HTML 网页，同时并行下载 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素加载的外部脚本。</li> <li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li> </ol> <p>有了 <code class="language-plaintext highlighter-rouge">defer</code> 属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件触发前执行（即刚刚读取完 <code class="language-plaintext highlighter-rouge">&lt;/html&gt;</code> 标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p> <ul> <li>对于内置而不是加载外部脚本的 <code class="language-plaintext highlighter-rouge">script</code> 标签，以及动态生成的 <code class="language-plaintext highlighter-rouge">script</code> 标签，<code class="language-plaintext highlighter-rouge">defer</code> 属性不起作用。</li> <li>使用 <code class="language-plaintext highlighter-rouge">defer</code> 加载的外部脚本不应该使用 <code class="language-plaintext highlighter-rouge">document.write</code> 方法。</li> </ul> <h4 id="23-async-属性">2.3 async 属性</h4> <p><code class="language-plaintext highlighter-rouge">async</code> 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p> <ol> <li>浏览器开始解析 HTML 网页。</li> <li>解析过程中，发现带有 <code class="language-plaintext highlighter-rouge">async</code> 属性的 <code class="language-plaintext highlighter-rouge">script</code> 标签。</li> <li>浏览器继续往下解析 HTML 网页，同时并行下载 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签中的外部脚本。</li> <li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li> <li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li> </ol> <p><code class="language-plaintext highlighter-rouge">async</code> 属性可以保证脚本下载的同时，浏览器继续渲染。</p> <ul> <li>一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。</li> <li>使用 <code class="language-plaintext highlighter-rouge">async</code> 属性的脚本文件里面的代码，不应该使用 <code class="language-plaintext highlighter-rouge">document.write</code> 方法。</li> </ul> <p>一般来说，如果脚本之间没有依赖关系，就使用 <code class="language-plaintext highlighter-rouge">async</code> 属性，如果脚本之间有依赖关系，就使用 <code class="language-plaintext highlighter-rouge">defer</code> 属性。如果同时使用 <code class="language-plaintext highlighter-rouge">async</code> 和 <code class="language-plaintext highlighter-rouge">defer</code> 属性，后者不起作用，浏览器行为由 <code class="language-plaintext highlighter-rouge">async</code> 属性决定。</p> <h4 id="24-脚本的动态加载">2.4 脚本的动态加载</h4> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素还可以动态生成，这种方法的好处是，<strong>动态生成的 <code class="language-plaintext highlighter-rouge">script</code> 标签不会阻塞页面渲染，也就不会造成浏览器假死</strong>。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。可以通过设置 <code class="language-plaintext highlighter-rouge">async</code> 属性为 <code class="language-plaintext highlighter-rouge">false</code> 解决这个问题。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">a.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b.js</span><span class="dl">'</span><span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">script</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
  <span class="nx">script</span><span class="p">.</span><span class="k">async</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="25-加载使用的协议">2.5 加载使用的协议</h4> <p>如果不指定协议，浏览器默认采用 HTTP 协议下载。如果要采用 HTTPS 协议下载，必需写明。但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"//example.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div> <h3 id="3-浏览器的组成">3. 浏览器的组成</h3> <p>浏览器的核心是两部分：<strong>渲染引擎</strong>和 <strong>JavaScript 解释器</strong>（又称 JavaScript 引擎）。</p> <h4 id="31-渲染引擎">3.1 渲染引擎</h4> <p>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。</p> <p>渲染引擎处理网页，通常分成四个阶段。</p> <ol> <li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li> <li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li> <li>布局：计算出渲染树的布局（layout）。</li> <li>绘制：将渲染树绘制到屏幕。</li> </ol> <p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p> <h4 id="32-重流和重绘">3.2 重流和重绘</h4> <p>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p> <p>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（<code class="language-plaintext highlighter-rouge">a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p> <p>重流和重绘并不一定一起发生，<strong>重流必然导致重绘，重绘不一定需要重流</strong>。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p> <p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘 <code class="language-plaintext highlighter-rouge">table</code> 布局和 <code class="language-plaintext highlighter-rouge">flex</code> 布局，开销都会比较大。</p> <p>下面是一些优化技巧。</p> <ul> <li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li> <li>缓存 DOM 信息。</li> <li>不要一项一项地改变样式，而是使用 CSS <code class="language-plaintext highlighter-rouge">class</code> 一次性改变样式。</li> <li>使用 <code class="language-plaintext highlighter-rouge">documentFragment</code> 操作 DOM</li> <li>动画使用 <code class="language-plaintext highlighter-rouge">absolute</code> 定位或 <code class="language-plaintext highlighter-rouge">fixed</code> 定位，这样可以减少对其他元素的影响。</li> <li>只在必要时才显示隐藏元素。</li> <li>使用 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li> <li>使用虚拟 DOM（virtual DOM）库。</li> </ul> <h4 id="33-javascript-引擎">3.3 JavaScript 引擎</h4> <p>JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。</p> <p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p> <p>为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p> <p>早期，浏览器内部对 JavaScript 的处理过程如下：</p> <ol> <li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li> <li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li> <li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li> <li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li> </ol> <p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p> <p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。</p> <h2 id="二window-对象">二、window 对象</h2> <h3 id="1-概述">1. 概述</h3> <p>浏览器里面，<code class="language-plaintext highlighter-rouge">window</code> 对象指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p> <h3 id="2-window-对象的属性">2. window 对象的属性</h3> <h4 id="21-通用属性">2.1 通用属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.name</code> 字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的 <code class="language-plaintext highlighter-rouge">target</code> 属性使用。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.closed</code> 布尔值，表示窗口是否关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">popup</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">();</span>
<span class="k">if </span><span class="p">((</span><span class="nx">popup</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">popup</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 窗口仍然打开着</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">window.opener</code> 属性表示打开当前窗口的<strong>父窗口</strong>。通过 <code class="language-plaintext highlighter-rouge">opener</code> 属性，可以获得父窗口的全局属性和方法，但只限于两个窗口<strong>同源</strong>的情况，且其中一个窗口由另一个打开。<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 元素添加 <code class="language-plaintext highlighter-rouge">rel="noopener"</code> 属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"https://an.evil.site"</span> <span class="na">target=</span><span class="s">"_blank"</span> <span class="na">rel=</span><span class="s">"noopener"</span><span class="nt">&gt;</span>
恶意网站
<span class="nt">&lt;/a&gt;</span>
</code></pre></div> </div> <p>如果两个窗口之间不需要通信，建议将子窗口的 <code class="language-plaintext highlighter-rouge">opener</code> 属性显式设为 <code class="language-plaintext highlighter-rouge">null</code>，这样可以减少一些安全隐患。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">newWin</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">example.html</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">newWindow</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">height=400,width=400</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">newWin</span><span class="p">.</span><span class="nx">opener</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">window.self</code> 和 <code class="language-plaintext highlighter-rouge">window.window</code> 属性都指向窗口（<code class="language-plaintext highlighter-rouge">window</code>）本身。这两个属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.frames</code> 属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括 <code class="language-plaintext highlighter-rouge">frame</code> 元素和 <code class="language-plaintext highlighter-rouge">iframe</code> 元素。</p> <p><code class="language-plaintext highlighter-rouge">window.frames[0]</code> 表示页面中第一个框架窗口。如果 <code class="language-plaintext highlighter-rouge">iframe</code> 元素设置了 <code class="language-plaintext highlighter-rouge">id</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 属性，那么就可以用属性值，引用这个 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口。比如 <code class="language-plaintext highlighter-rouge">&lt;iframe name="myIFrame"&gt;</code> 可以用 <code class="language-plaintext highlighter-rouge">frames['myIFrame']</code> 或者 <code class="language-plaintext highlighter-rouge">frames.myIFrame</code> 来引用。</p> <p><code class="language-plaintext highlighter-rouge">frames</code> 属性实际上是 <code class="language-plaintext highlighter-rouge">window</code> 对象的别名。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">frames</span> <span class="o">===</span> <span class="nb">window</span> <span class="c1">// true</span>
</code></pre></div> </div> <p>因此，<code class="language-plaintext highlighter-rouge">frames[0]</code> 也可以用 <code class="language-plaintext highlighter-rouge">window[0]</code> 表示。但是，从语义上看，<code class="language-plaintext highlighter-rouge">frames</code> 更清晰，而且考虑到 <code class="language-plaintext highlighter-rouge">window</code> 还是全局对象，因此推荐表示多窗口时，总是使用 <code class="language-plaintext highlighter-rouge">frames[0]</code> 的写法。</p> </li> <li><code class="language-plaintext highlighter-rouge">window.length</code> 属性返回当前网页包含的框架总数。如果当前网页不包含 <code class="language-plaintext highlighter-rouge">frame</code> 和 <code class="language-plaintext highlighter-rouge">iframe</code> 元素，那么 <code class="language-plaintext highlighter-rouge">window.length</code> 就返回 0。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.frameElement</code> 属性主要用于当前窗口嵌在另一个网页的情况（嵌入 <code class="language-plaintext highlighter-rouge">&lt;object&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 或 <code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 元素），返回当前窗口所在的那个元素节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;iframe src="about.html"&gt;&lt;/iframe&gt;</span>

<span class="c1">// 下面的脚本在 about.html 里面</span>
<span class="kd">var</span> <span class="nx">frameEl</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">frameElement</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">frameEl</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">frameEl</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">other.html</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">frameEl</code> 变量就是 <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素。</p> </li> <li><code class="language-plaintext highlighter-rouge">window.top</code> 属性指向<strong>最顶层窗口</strong>，主要用于在框架窗口（<code class="language-plaintext highlighter-rouge">frame</code>）里面获取顶层窗口。</li> <li><code class="language-plaintext highlighter-rouge">window.parent</code> 属性指向<strong>父窗口</strong>。如果当前窗口没有父窗口，<code class="language-plaintext highlighter-rouge">window.parent</code> 指向自身。</li> <li><code class="language-plaintext highlighter-rouge">window.status</code> 属性用于读写浏览器状态栏的文本。很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</li> <li><code class="language-plaintext highlighter-rouge">window.devicePixelRatio</code> 属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。它表示一个 CSS 像素由多少个物理像素组成。</li> </ul> <h4 id="22-位置大小属性">2.2 位置大小属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.screenX</code> 和 <code class="language-plaintext highlighter-rouge">window.screenY</code> 属性：返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.innerHeight</code> 和 <code class="language-plaintext highlighter-rouge">window.innerWidth</code> 属性：返回<strong>网页在当前窗口中可见部分的</strong>高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。</p> <p>用户放大网页的时候（比如将网页从 100% 的大小放大为 200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是 960px），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。注意，这两个属性值包括滚动条的高度和宽度。</p> </li> <li><code class="language-plaintext highlighter-rouge">window.outerHeight</code> 和 <code class="language-plaintext highlighter-rouge">window.outerWidth</code> 属性：返回<strong>浏览器窗口的高度和宽度</strong>，包括浏览器菜单和边框（单位像素）。这两个属性只读。</li> <li><code class="language-plaintext highlighter-rouge">window.scrollX</code> 和 <code class="language-plaintext highlighter-rouge">window.scrollY</code> 属性返回页面的水平/垂直滚动距离，单位都为像素。这两个属性只读。</li> <li><code class="language-plaintext highlighter-rouge">window.pageXOffset</code> 和 <code class="language-plaintext highlighter-rouge">window.pageYOffset</code> 属性是 <code class="language-plaintext highlighter-rouge">window.scrollX</code> 和 <code class="language-plaintext highlighter-rouge">window.scrollY</code> 别名。</li> </ul> <h4 id="23-组件属性">2.3 组件属性</h4> <p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p> <ul> <li><code class="language-plaintext highlighter-rouge">window.menubar</code>：菜单栏对象</li> <li><code class="language-plaintext highlighter-rouge">window.toolbar</code>：工具栏对象</li> <li><code class="language-plaintext highlighter-rouge">window.locationbar</code>：地址栏对象</li> <li><code class="language-plaintext highlighter-rouge">window.scrollbars</code>：窗口的滚动条对象</li> <li><code class="language-plaintext highlighter-rouge">window.statusbar</code>：状态栏对象</li> <li><code class="language-plaintext highlighter-rouge">window.personalbar</code>：用户安装的个人工具栏对象</li> </ul> <p>这些对象的 <code class="language-plaintext highlighter-rouge">visible</code> 属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p> <h4 id="24-全局对象属性">2.4 全局对象属性</h4> <p>全局对象属性指向一些浏览器原生的全局对象。</p> <ul> <li><code class="language-plaintext highlighter-rouge">window.document</code>：指向 <code class="language-plaintext highlighter-rouge">document</code> 对象。注意，这个属性有同源限制。只有来自<strong>同源</strong>的脚本才能读取这个属性。</li> <li><code class="language-plaintext highlighter-rouge">window.location</code>：指向 <code class="language-plaintext highlighter-rouge">Location</code> 对象，用于获取当前窗口的 URL 信息。它等同于 <code class="language-plaintext highlighter-rouge">document.location</code> 属性。</li> <li><code class="language-plaintext highlighter-rouge">window.navigator</code>：指向 <code class="language-plaintext highlighter-rouge">Navigator</code> 对象，用于获取<strong>环境信息</strong>。</li> <li><code class="language-plaintext highlighter-rouge">window.history</code>：指向 <code class="language-plaintext highlighter-rouge">History</code> 对象，表示浏览器的浏览历史。</li> <li><code class="language-plaintext highlighter-rouge">window.localStorage</code>：指向本地储存的 <code class="language-plaintext highlighter-rouge">localStorage</code> 数据。</li> <li><code class="language-plaintext highlighter-rouge">window.sessionStorage</code>：指向本地储存的 <code class="language-plaintext highlighter-rouge">sessionStorage</code> 数据。</li> <li><code class="language-plaintext highlighter-rouge">window.console</code>：指向 <code class="language-plaintext highlighter-rouge">console</code> 对象，用于操作控制台。</li> <li><code class="language-plaintext highlighter-rouge">window.screen</code>：指向 <code class="language-plaintext highlighter-rouge">Screen</code> 对象，表示屏幕信息。</li> </ul> <h4 id="25-windowissecurecontext">2.5 window.isSecureContext</h4> <p><code class="language-plaintext highlighter-rouge">window.isSecureContext</code> 布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是 <code class="language-plaintext highlighter-rouge">true</code>，否则就是 <code class="language-plaintext highlighter-rouge">false</code>。</p> <h3 id="3-window-对象的方法">3. window 对象的方法</h3> <h4 id="31-windowalertwindowconfirmwindowprompt">3.1 window.alert()，window.confirm()，window.prompt()</h4> <p><code class="language-plaintext highlighter-rouge">window.alert()</code>、<code class="language-plaintext highlighter-rouge">window.confirm()</code>、<code class="language-plaintext highlighter-rouge">window.prompt()</code> 都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p> <ul> <li><code class="language-plaintext highlighter-rouge">window.alert(message)</code> 方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。无返回值。</li> <li><code class="language-plaintext highlighter-rouge">window.confirm(message)</code> 方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。返回一个布尔值，表示是否选择了确定（<code class="language-plaintext highlighter-rouge">true</code>）还是取消（<code class="language-plaintext highlighter-rouge">false</code>）。</li> <li><code class="language-plaintext highlighter-rouge">window.prompt(message, defaultValue)</code> 方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。返回一个包含用户输入文本的字符串，或 <code class="language-plaintext highlighter-rouge">null</code>。</li> </ul> <h4 id="32-windowopen-windowclosewindowstop">3.2 window.open(), window.close()，window.stop()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">window.open(url, target, [windowFeatures])</code> 方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用。</p> <ul> <li><code class="language-plaintext highlighter-rouge">url</code>：字符串，表示新窗口的网址。如果省略，默认网址就是 <code class="language-plaintext highlighter-rouge">about:blank</code>。</li> <li><code class="language-plaintext highlighter-rouge">target</code>：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用 <code class="language-plaintext highlighter-rouge">_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code class="language-plaintext highlighter-rouge">_self</code> 表示当前窗口，<code class="language-plaintext highlighter-rouge">_top</code> 表示顶层窗口，<code class="language-plaintext highlighter-rouge">_parent</code> 表示上一层窗口。</li> <li><code class="language-plaintext highlighter-rouge">windowFeatures</code>：字符串，内容为逗号分隔的键值对，表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。关于此参数支持的配置项，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open#windowfeatures">windowfeatures 属性</a>。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">window.close()</code> 方法用于关闭当前窗口，一般只用来关闭 <code class="language-plaintext highlighter-rouge">window.open</code> 方法新建的窗口。该方法只对顶层窗口有效，<code class="language-plaintext highlighter-rouge">iframe</code> 框架之中的窗口使用该方法无效。</li> <li><code class="language-plaintext highlighter-rouge">window.stop()</code> 方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</li> </ul> <h4 id="33-windowmovetowindowmoveby">3.3 window.moveTo()，window.moveBy()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.moveTo(x, y)</code> 方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</li> <li><code class="language-plaintext highlighter-rouge">window.moveBy(deltaX, deltaY)</code> 方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</li> </ul> <p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用 <code class="language-plaintext highlighter-rouge">window.open()</code> 方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。</p> <h4 id="34-windowresizetowindowresizeby">3.4 window.resizeTo()，window.resizeBy()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.resizeTo(aWidth, aHeight)</code> 方法用于缩放窗口到指定大小。它接受两个参数，第一个是缩放后的窗口宽度（<code class="language-plaintext highlighter-rouge">aWidth</code> 属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code class="language-plaintext highlighter-rouge">aHeight</code> 属性）。</li> <li><code class="language-plaintext highlighter-rouge">window.resizeBy(xDelta, yDelta)</code> 方法用于缩放窗口。它与 <code class="language-plaintext highlighter-rouge">window.resizeTo()</code> 的区别是，它按照相对的量缩放，<code class="language-plaintext highlighter-rouge">window.resizeTo()</code> 需要给出缩放后的绝对大小。它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</li> </ul> <h4 id="35-windowscrolltowindowscrollwindowscrollby">3.5 window.scrollTo()，window.scroll()，window.scrollBy()</h4> <ul> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scrollTo(x-coord, y-coord)</code></td> <td><code class="language-plaintext highlighter-rouge">window.scrollTo(options)</code> 方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。它也可以接受一个配置对象作为参数，配置对象 <code class="language-plaintext highlighter-rouge">options</code> 有三个属性。</td> </tr> </tbody> </table> <ul> <li><code class="language-plaintext highlighter-rouge">top</code>：滚动后页面左上角的垂直坐标，即 <code class="language-plaintext highlighter-rouge">y</code> 坐标。</li> <li><code class="language-plaintext highlighter-rouge">left</code>：滚动后页面左上角的水平坐标，即 <code class="language-plaintext highlighter-rouge">x</code> 坐标。</li> <li><code class="language-plaintext highlighter-rouge">behavior</code>：字符串，表示滚动的方式，有三个可能值（<code class="language-plaintext highlighter-rouge">smooth</code>、<code class="language-plaintext highlighter-rouge">instant</code>、<code class="language-plaintext highlighter-rouge">auto</code>），默认值为 <code class="language-plaintext highlighter-rouge">auto</code>。</li> </ul> </li> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scrollBy(x-coord, y-coord)</code></td> <td><code class="language-plaintext highlighter-rouge">window.scrollBy(options)</code> 方法用于将网页滚动指定距离（单位像素）。</td> </tr> </tbody> </table> </li> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scroll(x-coord, y-coord)</code></td> <td><code class="language-plaintext highlighter-rouge">window.scroll(options)</code> 方法是 <code class="language-plaintext highlighter-rouge">window.scrollTo()</code> 方法的别名。</td> </tr> </tbody> </table> </li> </ul> <p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Element.scrollTop</code></li> <li><code class="language-plaintext highlighter-rouge">Element.scrollLeft</code></li> <li><code class="language-plaintext highlighter-rouge">Element.scrollIntoView()</code></li> </ul> <h4 id="36-windowprint">3.6 window.print()</h4> <p><code class="language-plaintext highlighter-rouge">window.print()</code> 方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p> <h4 id="37-windowfocuswindowblur">3.7 window.focus()，window.blur()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.focus()</code> 方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</li> <li><code class="language-plaintext highlighter-rouge">window.blur()</code> 方法将焦点从窗口移除。</li> </ul> <h4 id="38-windowgetselection">3.8 window.getSelection()</h4> <p><code class="language-plaintext highlighter-rouge">window.getSelection()</code> 方法返回一个 <code class="language-plaintext highlighter-rouge">Selection</code> 对象，表示用户现在选中的文本。使用 <code class="language-plaintext highlighter-rouge">Selection</code> 对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法可以得到选中的文本。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">selObj</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">getSelection</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">selectedText</span> <span class="o">=</span> <span class="nx">selObj</span><span class="p">.</span><span class="nf">toString</span><span class="p">();</span>
</code></pre></div></div> <h4 id="39-windowgetcomputedstylewindowmatchmedia">3.9 window.getComputedStyle()，window.matchMedia()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">window.getComputedStyle(element, pseudoElt)</code> 方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象。</li> <li><code class="language-plaintext highlighter-rouge">window.matchMedia(mediaQueryString)</code> 方法用来检查 CSS 的 <code class="language-plaintext highlighter-rouge">mediaQuery</code> 语句。</li> </ul> <h4 id="310-windowrequestanimationframe">3.10 window.requestAnimationFrame()</h4> <p><code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 可以在浏览器下一次重绘之前，执行用户提供的回调函数。重绘通常是 16ms（如果屏幕刷新率是 60FPS） 执行一次，浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code class="language-plaintext highlighter-rouge">requestAnimationFrame()</code> 会暂停执行。</p> <p>如果某个函数会改变网页的布局，一般就放在 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">callback</code> 是一个回调函数。<code class="language-plaintext highlighter-rouge">callback</code> 执行时，它的参数就是系统传入的一个高精度时间戳（<code class="language-plaintext highlighter-rouge">performance.now()</code> 的返回值），单位是毫秒，表示距离网页加载的时间。</p> <p><code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 接受一个回调函数作为参数，返回值是一个整数，这个整数可以传入 <code class="language-plaintext highlighter-rouge">window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">animate</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">absolute</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">step</span><span class="p">(</span><span class="nx">timestamp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">start</span><span class="p">)</span> <span class="nx">start</span> <span class="o">=</span> <span class="nx">timestamp</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">progress</span> <span class="o">=</span> <span class="nx">timestamp</span> <span class="o">-</span> <span class="nx">start</span><span class="p">;</span>
  <span class="c1">// 元素不断向右移，最大不超过200像素</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">progress</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
  <span class="c1">// 如果距离第一次执行不超过 2000 毫秒，</span>
  <span class="c1">// 就继续执行动画</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">progress</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">step</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">step</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码定义了一个网页动画，持续时间是 2 秒，会让元素向右移动。</p> <h4 id="311-windowrequestidlecallback">3.11 window.requestIdleCallback()</h4> <p><code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 能够保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用 <code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 将其推迟执行，以保证网页性能。</p> <p>它跟 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在 16ms 之内完成；<code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 可以保证回调函数在系统资源空闲时执行。</p> <p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">requestIdleCallback</span><span class="p">(</span><span class="nx">callback</span><span class="p">[,</span> <span class="nx">options</span><span class="p">])</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">callback</code> 参数是一个回调函数。该回调函数执行时，系统会传入一个 <code class="language-plaintext highlighter-rouge">IdleDeadline</code> 对象作为参数。<code class="language-plaintext highlighter-rouge">IdleDeadline</code> 对象有一个属性和一个方法。 <ul> <li><code class="language-plaintext highlighter-rouge">didTimeout</code> 属性（布尔值，表示是否为超时调用）。</li> <li><code class="language-plaintext highlighter-rouge">timeRemaining()</code> 方法（返回该空闲时段剩余的毫秒数）。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">options</code> 参数是一个配置对象，目前只有 <code class="language-plaintext highlighter-rouge">timeout</code> 一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</li> </ul> <p><code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 方法返回一个整数。该整数可以传入 <code class="language-plaintext highlighter-rouge">window.cancelIdleCallback()</code> 取消回调函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">requestIdleCallback</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while </span><span class="p">(</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">timeRemaining</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">doWorkIfNeeded</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div> <p>如果由于超时导致回调函数执行，则 <code class="language-plaintext highlighter-rouge">deadline.timeRemaining()</code> 返回 <code class="language-plaintext highlighter-rouge">0</code>，<code class="language-plaintext highlighter-rouge">deadline.didTimeout</code> 返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>如果多次执行 <code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p> <h3 id="4-事件">4. 事件</h3> <h4 id="41-load-事件和-onload-属性">4.1 load 事件和 onload 属性</h4> <p><code class="language-plaintext highlighter-rouge">load</code> 事件发生在文档在浏览器窗口加载完毕时。<code class="language-plaintext highlighter-rouge">window.onload</code> 属性可以指定这个事件的回调函数。</p> <h4 id="42-error-事件和-onerror-属性">4.2 error 事件和 onerror 属性</h4> <p><code class="language-plaintext highlighter-rouge">error</code> 事件发生在浏览器脚本发生错误时，<code class="language-plaintext highlighter-rouge">window.onerror</code> 属性可以指定该事件的回调函数。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p> <h4 id="43-window-对象的事件监听属性">4.3 window 对象的事件监听属性</h4> <p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code class="language-plaintext highlighter-rouge">window</code> 对象还具有以下的事件监听函数属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">window.onbeforeprint</code>：<code class="language-plaintext highlighter-rouge">beforeprint</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onafterprint</code>：<code class="language-plaintext highlighter-rouge">afterprint</code>事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onbeforeunload</code>：<code class="language-plaintext highlighter-rouge">beforeunload</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onunload</code>：<code class="language-plaintext highlighter-rouge">unload</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onhashchange</code>：<code class="language-plaintext highlighter-rouge">hashchange</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onlanguagechange</code>: <code class="language-plaintext highlighter-rouge">languagechange</code> 的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onmessage</code>：<code class="language-plaintext highlighter-rouge">message</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onmessageerror</code>：<code class="language-plaintext highlighter-rouge">MessageError</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.ononline</code>：<code class="language-plaintext highlighter-rouge">online</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onoffline</code>：<code class="language-plaintext highlighter-rouge">offline</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onpageshow</code>：<code class="language-plaintext highlighter-rouge">pageshow</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onpagehide</code>：<code class="language-plaintext highlighter-rouge">pagehide</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onpopstate</code>：<code class="language-plaintext highlighter-rouge">popstate</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onstorage</code>：<code class="language-plaintext highlighter-rouge">storage</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">window.onunhandledrejection</code>：未处理的 <code class="language-plaintext highlighter-rouge">Promise</code> 对象的 <code class="language-plaintext highlighter-rouge">reject</code> 事件的监听函数。</li> </ul> <h3 id="5-多窗口操作">5. 多窗口操作</h3> <h4 id="51-窗口的引用">5.1 窗口的引用</h4> <p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p> <ul> <li><code class="language-plaintext highlighter-rouge">top</code>：顶层窗口，即最上层的那个窗口</li> <li><code class="language-plaintext highlighter-rouge">parent</code>：父窗口</li> <li><code class="language-plaintext highlighter-rouge">self</code>：当前窗口，即自身</li> </ul> <p>与这些变量对应，浏览器还提供一些特殊的窗口名，供 <code class="language-plaintext highlighter-rouge">window.open()</code> 方法、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 标签、<code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> 标签等引用。</p> <ul> <li><code class="language-plaintext highlighter-rouge">_top</code>：顶层窗口</li> <li><code class="language-plaintext highlighter-rouge">_parent</code>：父窗口</li> <li><code class="language-plaintext highlighter-rouge">_blank</code>：新窗口</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">somepage.html</span><span class="dl">"</span> <span class="nx">target</span><span class="o">=</span><span class="dl">"</span><span class="s2">_top</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">Link</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div></div> <p>上面代码就表示在顶层窗口打开链接。</p> <h4 id="52-iframe-元素">5.2 iframe 元素</h4> <ul> <li><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素的 <code class="language-plaintext highlighter-rouge">contentWindow</code> 属性，可以获得 <code class="language-plaintext highlighter-rouge">iframe</code> 节点包含的 <code class="language-plaintext highlighter-rouge">window</code> 对象。</li> <li><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素的 <code class="language-plaintext highlighter-rouge">contentDocument</code> 属性，可以拿到子窗口的 <code class="language-plaintext highlighter-rouge">document</code> 对象。</li> <li><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素遵守<strong>同源策略</strong>，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用 <code class="language-plaintext highlighter-rouge">window.postMessage</code> 方法。</li> <li><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 窗口内部，使用 <code class="language-plaintext highlighter-rouge">window.parent</code> 引用父窗口。如果当前页面没有父窗口，则 <code class="language-plaintext highlighter-rouge">window.parent</code> 属性返回自身。因此，可以通过 <code class="language-plaintext highlighter-rouge">window.parent</code> 是否等于 <code class="language-plaintext highlighter-rouge">window.self</code>，判断当前窗口是否为 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">parent</span> <span class="o">!==</span> <span class="nb">window</span><span class="p">.</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 当前窗口是子窗口</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="53-windowframes-属性">5.3 window.frames 属性</h4> <p><code class="language-plaintext highlighter-rouge">window.frames</code> 属性返回一个类似数组的对象，成员是所有子窗口的 <code class="language-plaintext highlighter-rouge">window</code> 对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code class="language-plaintext highlighter-rouge">frames[0]</code> 返回第一个子窗口，<code class="language-plaintext highlighter-rouge">frames[1].frames[2]</code>返 回第二个子窗口内部的第三个子窗口。</p> <p>注意，<code class="language-plaintext highlighter-rouge">window.frames</code> 每个成员的值，是框架内的窗口（即框架的 <code class="language-plaintext highlighter-rouge">window</code> 对象），而不是 <code class="language-plaintext highlighter-rouge">iframe</code> 标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用 <code class="language-plaintext highlighter-rouge">window.frames[0].document</code> 的写法。</p> <p>另外，如果 <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素设置了 <code class="language-plaintext highlighter-rouge">name</code> 或 <code class="language-plaintext highlighter-rouge">id</code> 属性，那么属性值会自动成为全局变量，并且可以通过 <code class="language-plaintext highlighter-rouge">window.frames</code> 属性引用，返回子窗口的 <code class="language-plaintext highlighter-rouge">window</code> 对象。</p> <h2 id="三navigator-对象screen-对象">三、Navigator 对象，Screen 对象</h2> <p><code class="language-plaintext highlighter-rouge">window.navigator</code> 属性指向一个包含浏览器和系统信息的 Navigator 对象。脚本通过这个属性了解用户的环境信息。</p> <h3 id="1-navigator-对象的属性">1. Navigator 对象的属性</h3> <ul> <li> <p><code class="language-plaintext highlighter-rouge">navigator.userAgent</code> 属性返回浏览器的 User Agent 字符串，表示用户<strong>设备信息</strong>，包含了浏览器的厂商、版本、操作系统等信息。</p> <p>下面是 Chrome 浏览器的 userAgent。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">navigator</span><span class="p">.</span><span class="nx">userAgent</span>
<span class="c1">// "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36"</span>
</code></pre></div> </div> <p>通过 <code class="language-plaintext highlighter-rouge">userAgent</code> 属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。不过，通过 <code class="language-plaintext highlighter-rouge">userAgent</code> 可以大致准确地识别手机浏览器，方法就是测试是否包含 <code class="language-plaintext highlighter-rouge">mobi</code> 字符串。</p> </li> <li><code class="language-plaintext highlighter-rouge">Navigator.plugins</code> 属性返回一个类似数组的对象，成员是 Plugin 实例对象，表示浏览器安装的插件，比如 Flash、ActiveX 等。</li> <li><code class="language-plaintext highlighter-rouge">Navigator.platform</code> 属性返回用户的操作系统信息，比如 MacIntel、Win32、Linux x86_64 等。</li> <li><code class="language-plaintext highlighter-rouge">Navigator.onLine</code> 属性返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。用户变成在线会触发 <code class="language-plaintext highlighter-rouge">online</code> 事件，变成离线会触发 <code class="language-plaintext highlighter-rouge">offline</code> 事件，可以通过 <code class="language-plaintext highlighter-rouge">window.ononline</code> 和 <code class="language-plaintext highlighter-rouge">window.onoffline</code> 指定这两个事件的回调函数。</li> <li><code class="language-plaintext highlighter-rouge">Navigator.language</code> 属性返回一个字符串，表示浏览器的首选语言。该属性只读。</li> <li><code class="language-plaintext highlighter-rouge">Navigator.languages</code> 属性返回一个数组，表示用户可以接受的语言。<code class="language-plaintext highlighter-rouge">Navigator.language</code> 总是这个数组的第一个成员。HTTP 请求头信息的 Accept-Language 字段，就来自这个数组。</li> <li><code class="language-plaintext highlighter-rouge">Navigator.geolocation</code> 属性返回一个 Geolocation 对象，包含用户地理位置的信息。注意，该 API 只有在 HTTPS 协议下可用。</li> <li><code class="language-plaintext highlighter-rouge">Navigator.cookieEnabled</code> 属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。注意，这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关。</li> </ul> <h3 id="2-navigator-对象的方法">2. Navigator 对象的方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Navigator.javaEnabled()</code> 布尔值，表示浏览器是否能运行 Java Applet 小程序。注意，该方法目前<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/javaEnabled">已弃用</a>。</li> <li><code class="language-plaintext highlighter-rouge">Navigator.sendBeacon(url, data)</code> 方法用于向服务器异步发送数据。</li> </ul> <h3 id="3-screen-对象">3. Screen 对象</h3> <p>Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。<code class="language-plaintext highlighter-rouge">window.screen</code> 属性指向这个对象。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Screen.height</code>：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。</li> <li><code class="language-plaintext highlighter-rouge">Screen.width</code>：浏览器窗口所在的屏幕的宽度（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">Screen.availHeight</code>：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于 <code class="language-plaintext highlighter-rouge">height</code> 减去那些被系统组件的高度。</li> <li><code class="language-plaintext highlighter-rouge">Screen.availWidth</code>：浏览器窗口可用的屏幕宽度（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">Screen.pixelDepth</code>：整数，表示屏幕的色彩位数，比如 24 表示屏幕提供 24 位色彩。</li> <li><code class="language-plaintext highlighter-rouge">Screen.colorDepth</code>：<code class="language-plaintext highlighter-rouge">Screen.pixelDepth</code> 的别名。严格地说，<code class="language-plaintext highlighter-rouge">colorDepth</code> 表示应用程序的颜色深度，<code class="language-plaintext highlighter-rouge">pixelDepth</code> 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。</li> <li><code class="language-plaintext highlighter-rouge">Screen.orientation</code>：返回一个对象，表示屏幕的方向。该对象的 <code class="language-plaintext highlighter-rouge">type</code> 属性是一个字符串，表示屏幕的具体方向。 <ul> <li><code class="language-plaintext highlighter-rouge">landscape-primary</code> 表示横放。</li> <li><code class="language-plaintext highlighter-rouge">landscape-secondary</code> 表示颠倒的横放。</li> <li><code class="language-plaintext highlighter-rouge">portrait-primary</code> 表示竖放。</li> <li><code class="language-plaintext highlighter-rouge">portrait-secondary</code> 表示颠倒的竖放。</li> </ul> </li> </ul> <h2 id="四cookie">四、Cookie</h2> <h3 id="1-概述-1">1. 概述</h3> <p><strong>Cookie 是服务器保存在浏览器的一小段文本信息</strong>，一般大小不能超过 4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。</p> <p>HTTP 协议不带有状态，有些请求需要区分状态，就通过 Cookie 附带字符串，让服务器返回不一样的回应。举例来说，用户登录以后，服务器往往会在网站上留下一个 Cookie，记录用户编号（比如 <code class="language-plaintext highlighter-rouge">id=1234</code>），以后每次浏览器向服务器请求数据，就会带上这个字符串，服务器从而知道是谁在请求，应该回应什么内容。</p> <p><strong>Cookie 的目的就是区分用户，以及放置状态信息</strong>，它的使用场景主要如下。</p> <ul> <li>对话（session）管理：保存登录状态、购物车等需要记录的信息。</li> <li>个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。</li> <li>追踪用户：记录和分析用户行为。</li> </ul> <p>Cookie 不是一种理想的客户端存储机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端存储建议使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。</p> <p>每个 Cookie 都有以下几方面的元数据。</p> <ul> <li>所属域名（默认为当前域名）</li> <li>生效的路径（默认为当前网址）</li> <li>Cookie 的名字</li> <li>Cookie 的值（真正的数据写在这里面）</li> <li>到期时间（超过这个时间会失效）</li> </ul> <p>举例来说，用户访问网址 <code class="language-plaintext highlighter-rouge">www.example.com</code>，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为 <code class="language-plaintext highlighter-rouge">www.example.com</code>，生效路径为根路径 <code class="language-plaintext highlighter-rouge">/</code>。</p> <p>如果 Cookie 的生效路径设为 <code class="language-plaintext highlighter-rouge">/forums</code>，那么这个 Cookie 只有在访问 <code class="language-plaintext highlighter-rouge">www.example.com/forums</code> 及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。</p> <p><code class="language-plaintext highlighter-rouge">window.navigator.cookieEnabled</code> 布尔值，表示浏览器是否打开 Cookie 功能。<code class="language-plaintext highlighter-rouge">document.cookie</code> 属性返回当前网页的 Cookie。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nb">navigator</span><span class="p">.</span><span class="nx">cookieEnabled</span> <span class="c1">// true</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="c1">// "id=foo;key=bar"</span>
</code></pre></div></div> <ul> <li>一般来说，单个域名设置的 Cookie 不应超过 30 个，每个 Cookie 的大小不能超过 4KB。超过限制以后，Cookie 将被忽略，不会被设置。</li> <li>Cookie 是按照域名区分的，<code class="language-plaintext highlighter-rouge">foo.com</code> 只能读取自己放置的 Cookie，无法读取其他网站（比如 <code class="language-plaintext highlighter-rouge">bar.com</code>）放置的 Cookie。一般情况下，一级域名也不能读取二级域名留下的 Cookie，比如 <code class="language-plaintext highlighter-rouge">mydomain.com</code> 不能读取 <code class="language-plaintext highlighter-rouge">subdomain.mydomain.com</code> 设置的 Cookie。但是有一个例外，设置 Cookie 的时候（不管是一级域名设置的，还是二级域名设置的），明确将 <code class="language-plaintext highlighter-rouge">domain</code> 属性设为一级域名，则这个域名下面的各级域名可以共享这个 Cookie。</li> <li>区分 Cookie 时不考虑协议和端口。</li> </ul> <h3 id="2-cookie-与-http-协议">2. Cookie 与 HTTP 协议</h3> <h4 id="21-http-回应cookie-的生成">2.1 HTTP 回应：Cookie 的生成</h4> <p>服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个 <code class="language-plaintext highlighter-rouge">Set-Cookie</code> 字段。HTTP 回应可以包含多个 <code class="language-plaintext highlighter-rouge">Set-Cookie</code> 字段，即在浏览器生成多个 Cookie。</p> <p>如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的 <code class="language-plaintext highlighter-rouge">domain</code>、<code class="language-plaintext highlighter-rouge">path</code>、<code class="language-plaintext highlighter-rouge">key</code> 和 <code class="language-plaintext highlighter-rouge">secure</code> 都匹配。只要有一个属性不同，就会生成一个全新的 Cookie。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Set-Cookie: key1=value1; domain=example.com; path=/blog
</span></code></pre></div></div> <h4 id="22-http-请求cookie-的发送">2.2 HTTP 请求：Cookie 的发送</h4> <p>浏览器向服务器发送 HTTP 请求时，可以带上相应的 Cookie。<code class="language-plaintext highlighter-rouge">Cookie</code> 字段可以包含多个 Cookie，使用分号（<code class="language-plaintext highlighter-rouge">;</code>）分隔。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/sample_page.html</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">www.example.org</span>
<span class="na">Cookie</span><span class="p">:</span> <span class="s">yummy_cookie=choco; tasty_cookie=strawberry</span>
</code></pre></div></div> <h3 id="3-cookie-的属性">3. Cookie 的属性</h3> <h4 id="31-expiresmax-age">3.1 Expires，Max-Age</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Expires</code> 属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用 <code class="language-plaintext highlighter-rouge">Date.prototype.toUTCString()</code> 进行格式转换。如果不设置该属性，或者设为 <code class="language-plaintext highlighter-rouge">null</code>，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据<strong>本地时间</strong>，决定 Cookie 是否过期，而本地时间是不精确的。</li> <li><code class="language-plaintext highlighter-rouge">Max-Age</code> 属性指定从现在开始 Cookie 存在的秒数，比如 <code class="language-plaintext highlighter-rouge">60 * 60 * 24 * 365</code>（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</li> </ul> <p>如果同时指定了 <code class="language-plaintext highlighter-rouge">Expires</code> 和 <code class="language-plaintext highlighter-rouge">Max-Age</code>，那么 <code class="language-plaintext highlighter-rouge">Max-Age</code> 的值将优先生效。</p> <h4 id="32-domainpath">3.2 Domain，Path</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Domain</code> 属性指定 Cookie 属于哪个域名，以后浏览器向服务器发送 HTTP 请求时，通过这个属性判断是否要附带某个 Cookie。</p> <p><code class="language-plaintext highlighter-rouge">Domain</code> 属性只能是当前域名或者当前域名的上级域名，但设为上级域名时，<strong>不能设为顶级域名或公共域名</strong>。举例来说，当前域名为 <code class="language-plaintext highlighter-rouge">x.y.z.com</code>，那么 <code class="language-plaintext highlighter-rouge">Domain</code> 属性可以设为 <code class="language-plaintext highlighter-rouge">x.y.z.com</code>，或者 <code class="language-plaintext highlighter-rouge">y.z.com</code>，或者 <code class="language-plaintext highlighter-rouge">z.com</code>，但不能设为 <code class="language-plaintext highlighter-rouge">foo.x.y.z.com</code>，或者 <code class="language-plaintext highlighter-rouge">another.domain.com</code>。另一个例子是，当前域名为 <code class="language-plaintext highlighter-rouge">wangdoc.github.io</code>，则 <code class="language-plaintext highlighter-rouge">Domain</code> 属性只能设为 <code class="language-plaintext highlighter-rouge">wangdoc.github.io</code>，不能设为 <code class="language-plaintext highlighter-rouge">github.io</code>，因为后者是一个公共域名。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Path</code> 属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。</p> </li> </ul> <h4 id="33-securehttponly">3.3 Secure，HttpOnly</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Secure</code> 属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。</li> <li><code class="language-plaintext highlighter-rouge">HttpOnly</code> 属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是 <code class="language-plaintext highlighter-rouge">document.cookie</code> 属性、<code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> 对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</li> </ul> <h4 id="34-samesite">3.4 SameSite</h4> <p>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 <strong>CSRF 攻击</strong>。</p> <p>这种第三方网站引导而附带发送的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。比如，Facebook 在第三方网站插入一张看不见的图片。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"facebook.com"</span> <span class="na">style=</span><span class="s">"visibility:hidden;"</span><span class="nt">&gt;</span>
</code></pre></div></div> <p>浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。</p> <p>Cookie 的 <code class="language-plaintext highlighter-rouge">SameSite</code> 属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值：<code class="language-plaintext highlighter-rouge">Strict</code>、<code class="language-plaintext highlighter-rouge">Lax</code> 和 <code class="language-plaintext highlighter-rouge">None</code>。</p> <h5 id="1strict">（1）Strict</h5> <p><code class="language-plaintext highlighter-rouge">Strict</code> 最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。只有当前网页的 URL 与请求目标一致，才会带上 Cookie。这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Set-Cookie: CookieName=CookieValue; SameSite=Strict;
</span></code></pre></div></div> <h5 id="2lax">（2）Lax</h5> <p><code class="language-plaintext highlighter-rouge">Lax</code> 规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Set-Cookie: CookieName=CookieValue; SameSite=Lax;
</span></code></pre></div></div> <p>导航到目标网址的 GET 请求，只包括三种情况：链接、预加载请求、GET 表单。设置了 <code class="language-plaintext highlighter-rouge">Strict</code> 或 <code class="language-plaintext highlighter-rouge">Lax</code> 以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 <code class="language-plaintext highlighter-rouge">SameSite</code> 属性。</p> <table> <thead> <tr> <th style="text-align: center">请求类型</th> <th style="text-align: center">正常情况</th> <th style="text-align: center">Lax</th> <th style="text-align: center">示例</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">链接</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">&lt;a href="..."&gt;&lt;/a&gt;</code></td> </tr> <tr> <td style="text-align: center">预加载</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">&lt;link rel="prerender" href="..."/&gt;</code></td> </tr> <tr> <td style="text-align: center">GET 表单</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">&lt;form method="GET" action="..."&gt;</code></td> </tr> <tr> <td style="text-align: center">POST 表单</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center">不发送</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">&lt;form method="POST" action="..."&gt;</code></td> </tr> <tr> <td style="text-align: center">iframe</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center">不发送</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">&lt;iframe src="..."&gt;&lt;/iframe&gt;</code></td> </tr> <tr> <td style="text-align: center">AJAX</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center">不发送</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">$.get("...")</code></td> </tr> <tr> <td style="text-align: center">Image</td> <td style="text-align: center">发送 Cookie</td> <td style="text-align: center">不发送</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">&lt;img src="..."&gt;</code></td> </tr> </tbody> </table> <h5 id="3none">（3）None</h5> <p>网站可以选择显式关闭 <code class="language-plaintext highlighter-rouge">SameSite</code> 属性，将其设为 <code class="language-plaintext highlighter-rouge">None</code>。不过，前提是必须同时设置 <code class="language-plaintext highlighter-rouge">Secure</code> 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p> <h3 id="4-documentcookie">4. document.cookie</h3> <p><code class="language-plaintext highlighter-rouge">document.cookie</code> 属性用于读写当前网页的 Cookie。document.cookie 一次只能写入一个 Cookie，而且写入并不是覆盖，而是<strong>添加</strong>。写入的时候，Cookie 的值必须写成 <code class="language-plaintext highlighter-rouge">key=value</code> 的形式。</p> <p>浏览器向服务器发送 Cookie 的时候，<code class="language-plaintext highlighter-rouge">Cookie</code> 字段是使用一行将所有 Cookie 全部发送；服务器向浏览器设置 Cookie 的时候，<code class="language-plaintext highlighter-rouge">Set-Cookie</code> 字段是一行设置一个 Cookie。</p> <p>删除一个现存 Cookie 的唯一方法，是设置它的 <code class="language-plaintext highlighter-rouge">expires</code> 属性为一个过去的日期。</p> <h2 id="五xmlhttprequest-对象">五、XMLHttpRequest 对象</h2> <h3 id="51-简介">5.1 简介</h3> <p>AJAX 是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。AJAX 指通过 JavaScript 脚本发起 HTTP 通信。</p> <p>XMLHttpRequest 对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。它实可以使用多种协议（比如 <code class="language-plaintext highlighter-rouge">file</code> 或 <code class="language-plaintext highlighter-rouge">ftp</code>），发送任何格式的数据（包括字符串和二进制）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="p">);</span>
<span class="p">};</span>
<span class="c1">// 第三个参数 true，表示请求是异步的。</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">GET</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://www.example.com/page.php</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="c1">// 使用 send() 方法，实际发出请求。</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</code></pre></div></div> <p>注意，AJAX 只能向<strong>同源</strong>网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错。</p> <h3 id="52-xmlhttprequest-的实例属性">5.2 XMLHttpRequest 的实例属性</h3> <h4 id="1xmlhttprequestreadystate">（1）XMLHttpRequest.readyState</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.readyState</code> 返回一个整数，表示实例对象的当前状态。该属性只读。通信过程中，每当实例对象发生状态变化，它的 <code class="language-plaintext highlighter-rouge">readyState</code> 属性的值就会改变。这个值每次变化，都会触发 <code class="language-plaintext highlighter-rouge">readyStateChange</code> 事件。它可能返回以下值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">0</code> 表示 XMLHttpRequest 实例已经生成，但是实例的 <code class="language-plaintext highlighter-rouge">open()</code> 还没有被调用。</li> <li><code class="language-plaintext highlighter-rouge">1</code> 表示 <code class="language-plaintext highlighter-rouge">open()</code> 已经调用，但是实例的 <code class="language-plaintext highlighter-rouge">send()</code> 还没有调用，仍然可以使用实例的 <code class="language-plaintext highlighter-rouge">setRequestHeader()</code> 方法，设定 HTTP 请求的头信息。</li> <li><code class="language-plaintext highlighter-rouge">2</code> 表示实例的 <code class="language-plaintext highlighter-rouge">send()</code> 已经调用，并且服务器返回的头信息和状态码已经收到。</li> <li><code class="language-plaintext highlighter-rouge">3</code> 表示正在接收服务器传来的数据体（<code class="language-plaintext highlighter-rouge">body</code> 部分）。这时，如果实例的 <code class="language-plaintext highlighter-rouge">responseType</code> 属性等于 <code class="language-plaintext highlighter-rouge">text</code> 或者空字符串，<code class="language-plaintext highlighter-rouge">responseText</code> 属性就会包含已经收到的部分信息。</li> <li><code class="language-plaintext highlighter-rouge">4</code> 表示服务器返回的数据已经完全接收，或者本次接收已经失败。</li> </ul> <h4 id="2xmlhttprequestonreadystatechange">（2）XMLHttpRequest.onreadystatechange</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.onreadystatechange</code> 属性指向一个监听函数。<code class="language-plaintext highlighter-rouge">readystatechange</code> 事件发生时（实例的 <code class="language-plaintext highlighter-rouge">readyState</code> 属性变化），就会执行这个属性。</p> <h4 id="3xmlhttprequestresponse">（3）XMLHttpRequest.response</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.response</code> 属性表示服务器返回的数据体（即 HTTP 回应的 <code class="language-plaintext highlighter-rouge">body</code> 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由 <code class="language-plaintext highlighter-rouge">XMLHttpRequest.responseType</code> 属性决定。该属性只读。</p> <h4 id="4xmlhttprequestresponsetype">（4）XMLHttpRequest.responseType</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.responseType</code> 属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用 <code class="language-plaintext highlighter-rouge">open()</code> 方法之后、调用 <code class="language-plaintext highlighter-rouge">send()</code> 方法之前，设置这个属性的值，告诉浏览器如何解读返回的数据。如果 <code class="language-plaintext highlighter-rouge">responseType</code> 设为空字符串，就等同于默认值text。</p> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.responseType</code> 属性可以等于以下值。</p> <ul> <li>空字符串：等同于 <code class="language-plaintext highlighter-rouge">text</code>，表示服务器返回文本数据。</li> <li><code class="language-plaintext highlighter-rouge">arraybuffer</code>：<code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 对象，表示服务器返回二进制数组。</li> <li><code class="language-plaintext highlighter-rouge">blob</code>：<code class="language-plaintext highlighter-rouge">Blob</code> 对象，表示服务器返回二进制对象。</li> <li><code class="language-plaintext highlighter-rouge">document</code>：<code class="language-plaintext highlighter-rouge">Document</code> 对象，表示服务器返回一个文档对象。</li> <li><code class="language-plaintext highlighter-rouge">json</code>：<code class="language-plaintext highlighter-rouge">JSON</code> 对象。</li> <li><code class="language-plaintext highlighter-rouge">text</code>：字符串。</li> </ul> <h4 id="5xmlhttprequestresponsetext">（5）XMLHttpRequest.responseText</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.responseText</code> 属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。</p> <h4 id="6xmlhttprequestresponsexml">（6）XMLHttpRequest.responseXML</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.responseXML</code> 属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。</p> <p>该属性生效的前提是 HTTP 回应的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 头信息等于 <code class="language-plaintext highlighter-rouge">text/xml</code> 或 <code class="language-plaintext highlighter-rouge">application/xml</code>。这要求在发送请求前，<code class="language-plaintext highlighter-rouge">XMLHttpRequest.responseType</code> 属性要设为 <code class="language-plaintext highlighter-rouge">document</code>。如果 HTTP 回应的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 头信息不等于 <code class="language-plaintext highlighter-rouge">text/xml</code> 和 <code class="language-plaintext highlighter-rouge">application/xml</code>，但是想从 <code class="language-plaintext highlighter-rouge">responseXML</code> 拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用 <code class="language-plaintext highlighter-rouge">XMLHttpRequest.overrideMimeType()</code> 方法，强制进行 XML 解析。</p> <p>该属性得到的数据，是直接解析后的文档 DOM 树。</p> <h4 id="7xmlhttprequestresponseurl">（7）XMLHttpRequest.responseURL</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.responseURL</code> 属性是字符串，表示发送数据的服务器的网址。</p> <h4 id="8xmlhttprequeststatusxmlhttprequeststatustext">（8）XMLHttpRequest.status，XMLHttpRequest.statusText</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.status</code> 属性返回一个整数，表示服务器回应的 HTTP 状态码。</p> <ul> <li><code class="language-plaintext highlighter-rouge">200</code>, OK，访问正常</li> <li><code class="language-plaintext highlighter-rouge">301</code>, Moved Permanently，永久移动</li> <li><code class="language-plaintext highlighter-rouge">302</code>, Moved temporarily，暂时移动</li> <li><code class="language-plaintext highlighter-rouge">304</code>, Not Modified，未修改</li> <li><code class="language-plaintext highlighter-rouge">307</code>, Temporary Redirect，暂时重定向</li> <li><code class="language-plaintext highlighter-rouge">401</code>, Unauthorized，未授权</li> <li><code class="language-plaintext highlighter-rouge">403</code>, Forbidden，禁止访问</li> <li><code class="language-plaintext highlighter-rouge">404</code>, Not Found，未发现指定网址</li> <li><code class="language-plaintext highlighter-rouge">500</code>, Internal Server Error，服务器发生错误</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.statusText</code> 属性返回一个字符串，表示服务器发送的状态提示。</p> </li> </ul> <h4 id="9xmlhttprequesttimeoutxmlhttprequesteventtargetontimeout">（9）XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout</h4> <ul> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.timeout</code> 属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于 <code class="language-plaintext highlighter-rouge">0</code>，就表示没有时间限制。</li> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequestEventTarget.ontimeout</code> 属性用于设置一个监听函数，如果发生 <code class="language-plaintext highlighter-rouge">timeout</code> 事件，就会执行这个监听函数。</li> </ul> <h4 id="10事件监听属性">（10）事件监听属性</h4> <p>XMLHttpRequest 对象可以对以下事件指定监听函数。</p> <ul> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.onloadstart</code>：<code class="language-plaintext highlighter-rouge">loadstart</code> 事件（HTTP 请求发出）的监听函数</li> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.onload</code>：<code class="language-plaintext highlighter-rouge">load</code> 事件（请求成功完成）的监听函数</li> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.onloadend</code>：<code class="language-plaintext highlighter-rouge">loadend</code> 事件（请求完成，不管成功或失败）的监听函数</li> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.onprogress</code>：<code class="language-plaintext highlighter-rouge">progress</code> 事件（正在发送和加载数据）的监听函数</li> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.ontimeout</code>：<code class="language-plaintext highlighter-rouge">timeout</code> 事件（用户指定的时限超过了，请求还未完成）的监听函数</li> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.onabort</code>：<code class="language-plaintext highlighter-rouge">abort</code> 事件（请求中止，比如用户调用了 <code class="language-plaintext highlighter-rouge">abort()</code> 方法）的监听函数</li> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.onerror</code>：<code class="language-plaintext highlighter-rouge">error</code> 事件（请求失败）的监听函数</li> </ul> <h4 id="11xmlhttprequestwithcredentials">（11）XMLHttpRequest.withCredentials</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.withCredentials</code> 布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</p> <p>如果需要跨域 AJAX 请求发送 Cookie，需要 <code class="language-plaintext highlighter-rouge">withCredentials</code> 属性设为 <code class="language-plaintext highlighter-rouge">true</code>。服务器还必须显式返回 <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials</code> 这个头信息。</p> <h4 id="12xmlhttprequestupload">（12）XMLHttpRequest.upload</h4> <p>通过 XMLHttpRequest 发送文件之后，通过 <code class="language-plaintext highlighter-rouge">XMLHttpRequest.upload</code> 属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：<code class="language-plaintext highlighter-rouge">loadstart</code>、<code class="language-plaintext highlighter-rouge">loadend</code>、<code class="language-plaintext highlighter-rouge">load</code>、<code class="language-plaintext highlighter-rouge">abort</code>、<code class="language-plaintext highlighter-rouge">error</code>、<code class="language-plaintext highlighter-rouge">progress</code>、<code class="language-plaintext highlighter-rouge">timeout</code>。</p> <h3 id="53-xmlhttprequest-的实例方法">5.3 XMLHttpRequest 的实例方法</h3> <h4 id="1xmlhttprequestopen">（1）XMLHttpRequest.open()</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.open(method, url, async, user, password)</code> 用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">open</span><span class="p">(</span>
  <span class="nx">string</span> <span class="nx">method</span><span class="p">,</span>
  <span class="nx">string</span> <span class="nx">url</span><span class="p">,</span>
  <span class="nx">optional</span> <span class="nx">boolean</span> <span class="k">async</span><span class="p">,</span>
  <span class="nx">optional</span> <span class="nx">string</span> <span class="nx">user</span><span class="p">,</span>
  <span class="nx">optional</span> <span class="nx">string</span> <span class="nx">password</span>
<span class="p">);</span>
</code></pre></div></div> <h4 id="2xmlhttprequestsend">（2）XMLHttpRequest.send()</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.send(body)</code> 用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。</p> <p><code class="language-plaintext highlighter-rouge">send</code> 方法的参数 <code class="language-plaintext highlighter-rouge">body</code> 可以接受多种格式的数据。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">send</span><span class="p">();</span>
<span class="k">void</span> <span class="nf">send</span><span class="p">(</span><span class="nx">ArrayBufferView</span> <span class="nx">data</span><span class="p">);</span>
<span class="k">void</span> <span class="nf">send</span><span class="p">(</span><span class="nx">Blob</span> <span class="nx">data</span><span class="p">);</span>
<span class="k">void</span> <span class="nf">send</span><span class="p">(</span><span class="nx">Document</span> <span class="nx">data</span><span class="p">);</span>
<span class="k">void</span> <span class="nf">send</span><span class="p">(</span><span class="nb">String</span> <span class="nx">data</span><span class="p">);</span>
<span class="k">void</span> <span class="nf">send</span><span class="p">(</span><span class="nx">FormData</span> <span class="nx">data</span><span class="p">);</span>
</code></pre></div></div> <h4 id="3xmlhttprequestsetrequestheader">（3）XMLHttpRequest.setRequestHeader()</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.setRequestHeader(header, value)</code> 用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在 <code class="language-plaintext highlighter-rouge">open()</code> 之后、<code class="language-plaintext highlighter-rouge">send()</code> 之前调用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nf">setRequestHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <h4 id="4xmlhttprequestoverridemimetype">（4）XMLHttpRequest.overrideMimeType()</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.overrideMimeType(mimeType)</code> 用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是 <code class="language-plaintext highlighter-rouge">text/xml</code>，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成 <code class="language-plaintext highlighter-rouge">text/plain</code>，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nf">overrideMimeType</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div> <p>注意，该方法必须在 <code class="language-plaintext highlighter-rouge">send()</code> 之前调用。</p> <p>修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用 <code class="language-plaintext highlighter-rouge">responseType</code> 属性告诉服务器，就像下面的例子。只有在服务器无法返回某种数据类型时，才使用 <code class="language-plaintext highlighter-rouge">overrideMimeType()</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">arraybuffer</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">GET</span><span class="dl">'</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">arraybuffer</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">send</span><span class="p">();</span>
</code></pre></div></div> <h4 id="5xmlhttprequestgetresponseheaderxmlhttprequestgetallresponseheaders">（5）XMLHttpRequest.getResponseHeader()，XMLHttpRequest.getAllResponseHeaders()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.getResponseHeader(name)</code> 返回 HTTP 响应中头信息指定字段的值。</li> <li><code class="language-plaintext highlighter-rouge">XMLHttpRequest.getAllResponseHeaders()</code> 返回一个字符串，表示服务器发来的所有 HTTP 头信息。</li> </ul> <h4 id="6xmlhttprequestabort">（6）XMLHttpRequest.abort()</h4> <p><code class="language-plaintext highlighter-rouge">XMLHttpRequest.abort()</code> 用来终止已经发出的 HTTP 请求。调用这个方法以后，<code class="language-plaintext highlighter-rouge">readyState</code> 属性变为 <code class="language-plaintext highlighter-rouge">4</code>，<code class="language-plaintext highlighter-rouge">status</code> 属性变为 <code class="language-plaintext highlighter-rouge">0</code>。</p> <h3 id="54-xmlhttprequest-实例的事件">5.4 XMLHttpRequest 实例的事件</h3> <ul> <li><code class="language-plaintext highlighter-rouge">readyState</code> 属性的值发生改变，就会触发 <code class="language-plaintext highlighter-rouge">readyStateChange</code> 事件。可以通过 <code class="language-plaintext highlighter-rouge">onReadyStateChange</code> 属性，指定这个事件的监听函数。</li> <li> <p>上传文件时，XMLHttpRequest 实例对象本身和实例的 <code class="language-plaintext highlighter-rouge">upload</code> 属性，都有一个 <code class="language-plaintext highlighter-rouge">progress</code> 事件，会不断返回上传的进度。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">progress</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">oEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">oEvent</span><span class="p">.</span><span class="nx">lengthComputable</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">percentComplete</span> <span class="o">=</span> <span class="nx">oEvent</span><span class="p">.</span><span class="nx">loaded</span> <span class="o">/</span> <span class="nx">oEvent</span><span class="p">.</span><span class="nx">total</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">无法计算进展</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nf">open</span><span class="p">();</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">load</code> 事件表示服务器传来的数据接收完毕，<code class="language-plaintext highlighter-rouge">error</code> 事件表示请求出错，<code class="language-plaintext highlighter-rouge">abort</code> 事件表示请求被中断（比如用户取消请求）。</li> <li> <p><code class="language-plaintext highlighter-rouge">abort</code>、<code class="language-plaintext highlighter-rouge">load</code> 和 <code class="language-plaintext highlighter-rouge">error</code> 这三个事件，会伴随一个 <code class="language-plaintext highlighter-rouge">loadend</code> 事件，表示请求结束，但不知道其是否成功。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">loadend</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">请求结束，状态未知</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div> </div> </li> <li>服务器超过指定时间还没有返回结果，就会触发 <code class="language-plaintext highlighter-rouge">timeout</code> 事件。</li> </ul> <h3 id="55-navigatorsendbeacon">5.5 Navigator.sendBeacon()</h3> <p>用户卸载网页的时候，有时需要向服务器发一些数据。如果使用 <code class="language-plaintext highlighter-rouge">unload</code> 事件或 <code class="language-plaintext highlighter-rouge">beforeunload</code> 事件的监听函数，或者使用 <code class="language-plaintext highlighter-rouge">setTimeout()</code>，会导致很多问题。为此，浏览器引入了 <code class="language-plaintext highlighter-rouge">Navigator.sendBeacon(url, data)</code>。这个方法还是<strong>异步</strong>发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">unload</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">succeed</span> <span class="o">=</span> <span class="nb">navigator</span><span class="p">.</span><span class="nf">sendBeacon</span><span class="p">(</span><span class="dl">'</span><span class="s1">/log</span><span class="dl">'</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">({</span>
    <span class="na">some</span><span class="p">:</span> <span class="dl">"</span><span class="s2">data</span><span class="dl">"</span>
  <span class="p">}));</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Navigator.sendBeacon(url, data)</code> 的返回值是一个布尔值，成功发送数据为 <code class="language-plaintext highlighter-rouge">true</code>，否则为 <code class="language-plaintext highlighter-rouge">false</code>。</p> <p><strong>该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据</strong>。它不能指定回调函数。这个方法的优先级较低，不会占用页面资源。一般是在浏览器空闲的时候，才会发送。</p> <h2 id="六同源限制">六、同源限制</h2> <h3 id="61-概述">6.1 概述</h3> <p>同源指协议、域名和端口都相同的地址。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。对于非同源，共有三种行为受到限制。</p> <ul> <li>无法接触非同源网页的 DOM。</li> <li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。</li> <li>无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</li> </ul> <h3 id="62-cookie">6.2 Cookie</h3> <p>Cookie 是服务器写入浏览器的一小段信息，只有<strong>同源</strong>的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置 <code class="language-plaintext highlighter-rouge">document.domain</code> 共享 Cookie。</p> <p>举例来说，A 网页的网址是 <code class="language-plaintext highlighter-rouge">http://w1.example.com/a.html</code>，B 网页的网址是 <code class="language-plaintext highlighter-rouge">http://w2.example.com/b.html</code>，那么只要设置相同的 <code class="language-plaintext highlighter-rouge">document.domain</code>，两个网页就可以共享 Cookie。因为浏览器通过 <code class="language-plaintext highlighter-rouge">document.domain</code> 属性来检查是否同源。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 两个网页都需要设置</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">domain</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">example.com</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p>注意，A 和 B 两个网页都需要设置 <code class="language-plaintext highlighter-rouge">document.domain</code> 属性，才能达到同源的目的。因为设置 <code class="language-plaintext highlighter-rouge">document.domain</code> 的同时，会把端口重置为 <code class="language-plaintext highlighter-rouge">null</code>，因此如果只设置一个网页的 <code class="language-plaintext highlighter-rouge">document.domain</code>，会导致两个网址的端口不同，还是达不到同源的目的。这种方法只适用于 Cookie 和 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍 PostMessage API。</p> <p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如 <code class="language-plaintext highlighter-rouge">example.com</code>。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Set-Cookie: key=value; domain=example.com; path=/
</span></code></pre></div></div> <p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。</p> <h3 id="63-iframe-和多窗口通信">6.3 iframe 和多窗口通信</h3> <p>iframe 窗口中的脚本，可以获得父窗口和子窗口。但是，只有在<strong>同源</strong>的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。</p> <ul> <li>片段识别符（fragment identifier）</li> <li>跨文档通信 API（Cross-document messaging）</li> </ul> <h4 id="1片段识别符">（1）片段识别符</h4> <p><strong>片段标识符</strong>（fragment identifier）指的是，URL 的 <code class="language-plaintext highlighter-rouge">#</code> 号后面的部分。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符（同样的，子窗口也可以改变父窗口的片段标识符）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">src</span> <span class="o">=</span> <span class="nx">originURL</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myIFrame</span><span class="dl">'</span><span class="p">).</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
</code></pre></div></div> <p>子窗口通过监听 <code class="language-plaintext highlighter-rouge">hashchange</code> 事件得到通知。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onhashchange</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="2windowpostmessage">（2）window.postMessage()</h4> <p>HTML5 引入了跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 <strong><code class="language-plaintext highlighter-rouge">window.postMessage</code> 方法，允许跨窗口通信，不论这两个窗口是否同源</strong>。举例来说，父窗口 <code class="language-plaintext highlighter-rouge">a.com</code> 向子窗口 <code class="language-plaintext highlighter-rouge">b.com</code> 发消息，调用 <code class="language-plaintext highlighter-rouge">postMessage</code> 方法就可以了。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 父窗口打开一个子窗口</span>
<span class="kd">var</span> <span class="nx">popup</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://b.com</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">title</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 父窗口向子窗口发消息</span>
<span class="nx">popup</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://b.com</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">postMessage</code> 方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为 <code class="language-plaintext highlighter-rouge">*</code>，表示不限制域名，向所有窗口发送（子窗口向父窗口发送消息的写法类似）。</p> <p>父窗口和子窗口都可以通过 <code class="language-plaintext highlighter-rouge">message</code> 事件，监听对方的消息。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 父窗口和子窗口都可以用下面的代码监听 message 消息</span>
<span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="c1">// 消息内容</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">source</span><span class="p">);</span> <span class="c1">// 发送消息的窗口</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">origin</span><span class="p">);</span> <span class="c1">// 消息发送者的源（origin），即协议、域名、端口</span>
<span class="p">},</span><span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <h4 id="3localstorage">（3）LocalStorage</h4> <p>通过 <code class="language-plaintext highlighter-rouge">window.postMessage</code> 可以读写其他窗口的 LocalStorage。</p> <p>父窗口发送消息代码如下。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">win</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">iframe</span><span class="dl">'</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">contentWindow</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Jack</span><span class="dl">'</span> <span class="p">};</span>
<span class="c1">// 存入对象</span>
<span class="nx">win</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span>
  <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">({</span><span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">storage</span><span class="dl">'</span><span class="p">,</span> <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">set</span><span class="dl">'</span><span class="p">,</span> <span class="na">data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">}),</span>
  <span class="dl">'</span><span class="s1">http://b.com</span><span class="dl">'</span>
<span class="p">);</span>
<span class="c1">// 读取对象</span>
<span class="nx">win</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span>
  <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">({</span><span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">storage</span><span class="dl">'</span><span class="p">,</span> <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">}),</span>
  <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span>
<span class="p">);</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">origin</span> <span class="o">!=</span> <span class="dl">'</span><span class="s1">http://a.com</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">).</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>子窗口接收消息的代码如下。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">origin</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">http://b.com</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">payload</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="k">switch </span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">method</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">set</span><span class="dl">'</span><span class="p">:</span>
      <span class="nx">localStorage</span><span class="p">.</span><span class="nf">setItem</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">data</span><span class="p">));</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">get</span><span class="dl">'</span><span class="p">:</span>
      <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
      <span class="nx">parent</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://a.com</span><span class="dl">'</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">remove</span><span class="dl">'</span><span class="p">:</span>
      <span class="nx">localStorage</span><span class="p">.</span><span class="nf">removeItem</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="64-ajax">6.4 AJAX</h3> <p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制：JSONP、WebSocket 和 CORS。</p> <h4 id="1jsonp">（1）JSONP</h4> <p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。它的做法如下。</p> <ol> <li> <p>第一步，网页添加一个 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。请求的脚本网址有个 <code class="language-plaintext highlighter-rouge">callback</code> 参数（<code class="language-plaintext highlighter-rouge">?callback=bar</code>），用来告诉服务器，客户端的回调函数名称（<code class="language-plaintext highlighter-rouge">bar</code>）。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"http://api.foo.com?callback=bar"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div> </div> </li> <li>第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（<code class="language-plaintext highlighter-rouge">bar({...})</code>）。</li> <li>第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签请求的脚本内容。这时，客户端只要定义了 <code class="language-plaintext highlighter-rouge">bar()</code>，就能在该函数体内，拿到服务器返回的 JSON 数据。</li> </ol> <p>下面看一个实例。首先，网页动态插入 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，由它向跨域网址发出请求。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">script</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">type</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">text/javascript</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://example.com/ip?callback=foo</span><span class="dl">'</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Your public IP address is: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">ip</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码通过动态添加 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，向服务器 <code class="language-plaintext highlighter-rouge">example.com</code> 发出请求。注意，该请求的查询字符串有一个 <code class="language-plaintext highlighter-rouge">callback</code> 参数，用来指定回调函数的名字，这对于 JSONP 是必需的。</p> <p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">foo</span><span class="p">({</span>
  <span class="dl">'</span><span class="s1">ip</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">8.8.8.8</span><span class="dl">'</span>
<span class="p">});</span>
</code></pre></div></div> <p>由于 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了 <code class="language-plaintext highlighter-rouge">foo</code> 函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 <code class="language-plaintext highlighter-rouge">JSON.parse</code> 的步骤。</p> <p>JSONP 的缺点是只能发送 GET 请求。</p> <h4 id="2websocket">（2）WebSocket</h4> <p>WebSocket 是一种通信协议，使用 <code class="language-plaintext highlighter-rouge">ws://</code>（非加密）和 <code class="language-plaintext highlighter-rouge">wss://</code>（加密）作为协议前缀。<strong>该协议不实行同源政策</strong>，只要服务器支持，就可以通过它进行跨源通信。</p> <p>下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自<a href="https://en.wikipedia.org/wiki/WebSocket">维基百科</a>）。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/chat</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">server.example.com</span>
<span class="na">Upgrade</span><span class="p">:</span> <span class="s">websocket</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Upgrade</span>
<span class="na">Sec-WebSocket-Key</span><span class="p">:</span> <span class="s">x3JJHMbDL1EzLkh9GBhXDw==</span>
<span class="na">Sec-WebSocket-Protocol</span><span class="p">:</span> <span class="s">chat, superchat</span>
<span class="na">Sec-WebSocket-Version</span><span class="p">:</span> <span class="s">13</span>
<span class="na">Origin</span><span class="p">:</span> <span class="s">http://example.com</span>
</code></pre></div></div> <p>上面代码中，有一个字段是 <code class="language-plaintext highlighter-rouge">Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p> <p>正是因为有了 <code class="language-plaintext highlighter-rouge">Origin</code> 这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">101</span> <span class="ne">Switching Protocols</span>
<span class="na">Upgrade</span><span class="p">:</span> <span class="s">websocket</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Upgrade</span>
<span class="na">Sec-WebSocket-Accept</span><span class="p">:</span> <span class="s">HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span>
<span class="na">Sec-WebSocket-Protocol</span><span class="p">:</span> <span class="s">chat</span>
</code></pre></div></div> <h4 id="3cors">（3）CORS</h4> <p>见下一章。</p> <h2 id="七cors-通信">七、CORS 通信</h2> <p>CORS 是一个 W3C 标准，全称是“跨源资源共享”（Cross-origin resource sharing），或者通俗地称为“跨域资源共享”。它允许浏览器向跨源的服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。</p> <h3 id="1-简介">1. 简介</h3> <p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。</p> <p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，<strong>实现 CORS 通信的关键是服务器</strong>。只要服务器实现了 CORS 接口，就可以跨源通信。</p> <h3 id="2-两种请求">2. 两种请求</h3> <p>CORS 请求分成两类：<strong>简单请求</strong>（simple request）和<strong>非简单请求</strong>（not-so-simple request）。</p> <p>只要同时满足以下两大条件，就属于简单请求。</p> <ol> <li> <p>请求方法是以下三种方法之一。</p> <ul> <li><code class="language-plaintext highlighter-rouge">HEAD</code></li> <li><code class="language-plaintext highlighter-rouge">GET</code></li> <li><code class="language-plaintext highlighter-rouge">POST</code></li> </ul> </li> <li> <p>HTTP 的头信息不超出以下几种字段。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Accept</code></li> <li><code class="language-plaintext highlighter-rouge">Accept-Language</code></li> <li><code class="language-plaintext highlighter-rouge">Content-Language</code></li> <li><code class="language-plaintext highlighter-rouge">Last-Event-ID</code></li> <li><code class="language-plaintext highlighter-rouge">Content-Type</code>：只限于三个值 <code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code>、<code class="language-plaintext highlighter-rouge">multipart/form-data</code>、<code class="language-plaintext highlighter-rouge">text/plain</code></li> </ul> </li> </ol> <p>凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。</p> <p>这样划分的原因是，表单在历史上一直可以跨源发出请求。简单请求就是<strong>表单请求</strong>，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。</p> <h3 id="3-简单请求">3. 简单请求</h3> <h4 id="31-基本流程">3.1 基本流程</h4> <p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 <code class="language-plaintext highlighter-rouge">Origin</code> 字段，用来说明本次请求来自哪个域（协议 + 域名 + 端口）。</p> <p>如果 <code class="language-plaintext highlighter-rouge">Origin</code> 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> 字段，就知道出错了，从而抛出一个错误，被 <code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> 的 <code class="language-plaintext highlighter-rouge">onerror</code> 回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 <code class="language-plaintext highlighter-rouge">200</code>。</p> <p>如果 <code class="language-plaintext highlighter-rouge">Origin</code> 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
</span></code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> 字段是必须的。它的值要么是请求时 <code class="language-plaintext highlighter-rouge">Origin</code> 字段的值，要么是一个 <code class="language-plaintext highlighter-rouge">*</code>，表示接受任意域名的请求。</li> <li><code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials</code> 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 <code class="language-plaintext highlighter-rouge">true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为 <code class="language-plaintext highlighter-rouge">true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</li> <li><code class="language-plaintext highlighter-rouge">Access-Control-Expose-Headers</code> 该字段可选。CORS 请求时，XMLHttpRequest 对象的 <code class="language-plaintext highlighter-rouge">getResponseHeader()</code> 只能拿到 6 个服务器返回的基本字段：<code class="language-plaintext highlighter-rouge">Cache-Control</code>、<code class="language-plaintext highlighter-rouge">Content-Language</code>、<code class="language-plaintext highlighter-rouge">Content-Type</code>、<code class="language-plaintext highlighter-rouge">Expires</code>、<code class="language-plaintext highlighter-rouge">Last-Modified</code>、<code class="language-plaintext highlighter-rouge">Pragma</code>。如果想拿到其他字段，就必须在 <code class="language-plaintext highlighter-rouge">Access-Control-Expose-Headers</code> 里面指定。上面的例子指定，<code class="language-plaintext highlighter-rouge">getResponseHeader('FooBar')</code> 可以返回 <code class="language-plaintext highlighter-rouge">FooBar</code> 字段的值。</li> </ul> <h4 id="32-withcredentials-属性">3.2 withCredentials 属性</h4> <p>CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 <strong>CSRF 攻击</strong>的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定 <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials</code> 字段，告诉浏览器可以发送 Cookie。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Access-Control-Allow-Credentials: true
</span></code></pre></div></div> <p>同时，开发者必须在 AJAX 请求中打开 <code class="language-plaintext highlighter-rouge">withCredentials</code> 属性。否则，即使服务器要求发送 Cookie，浏览器也不会发送。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div> <h3 id="4-非简单请求">4. 非简单请求</h3> <h4 id="41-预检请求">4.1 预检请求</h4> <p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为<strong>预检请求</strong>（preflight）。浏览器先询问服务器，当前网页所在的<strong>域名</strong>是否在服务器的许可名单之中，以及可以使用哪些 <strong>HTTP 方法</strong>和<strong>头信息</strong>字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量 DELETE 和 PUT 请求，这些传统的表单不可能跨源发出的请求。</p> <p>下面是一段浏览器的 JavaScript 脚本。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://api.alice.com/cors</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">PUT</span><span class="dl">'</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">setRequestHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">X-Custom-Header</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">send</span><span class="p">();</span>
</code></pre></div></div> <p>上面代码中，HTTP 请求的方法是 PUT，并且发送一个自定义头信息 <code class="language-plaintext highlighter-rouge">X-Custom-Header</code>。</p> <p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">OPTIONS</span> <span class="nn">/cors</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Origin</span><span class="p">:</span> <span class="s">http://api.bob.com</span>
<span class="na">Access-Control-Request-Method</span><span class="p">:</span> <span class="s">PUT</span>
<span class="na">Access-Control-Request-Headers</span><span class="p">:</span> <span class="s">X-Custom-Header</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">api.alice.com</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-US</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0...</span>
</code></pre></div></div> <p>“预检”请求用的请求方法是 <code class="language-plaintext highlighter-rouge">OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是 <code class="language-plaintext highlighter-rouge">Origin</code>，表示请求来自哪个源。除了 <code class="language-plaintext highlighter-rouge">Origin</code> 字段，“预检”请求的头信息包括两个特殊字段。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Access-Control-Request-Method</code> 字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 <code class="language-plaintext highlighter-rouge">PUT</code>。</li> <li><code class="language-plaintext highlighter-rouge">Access-Control-Request-Headers</code> 字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 <code class="language-plaintext highlighter-rouge">X-Custom-Header</code>。</li> </ul> <h4 id="42-预检请求的回应">4.2 预检请求的回应</h4> <p>服务器收到“预检”请求以后，检查了 <code class="language-plaintext highlighter-rouge">Origin</code>、<code class="language-plaintext highlighter-rouge">Access-Control-Request-Method</code> 和 <code class="language-plaintext highlighter-rouge">Access-Control-Request-Headers</code> 字段以后，确认允许跨源请求，就可以做出回应。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Mon, 01 Dec 2008 01:15:39 GMT</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">Apache/2.0.61 (Unix)</span>
<span class="na">Access-Control-Allow-Origin</span><span class="p">:</span> <span class="s">http://api.bob.com</span>
<span class="na">Access-Control-Allow-Methods</span><span class="p">:</span> <span class="s">GET, POST, PUT</span>
<span class="na">Access-Control-Allow-Headers</span><span class="p">:</span> <span class="s">X-Custom-Header</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html; charset=utf-8</span>
<span class="na">Content-Encoding</span><span class="p">:</span> <span class="s">gzip</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">0</span>
<span class="na">Keep-Alive</span><span class="p">:</span> <span class="s">timeout=2, max=100</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Keep-Alive</span>
</code></pre></div></div> <p>上面的 HTTP 回应中，关键的是 <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> 字段，表示 <code class="language-plaintext highlighter-rouge">http://api.bob.com</code> 可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p> <p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">OPTIONS</span> <span class="nn">http://api.bob.com</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Status</span><span class="p">:</span> <span class="s">200</span>
<span class="na">Access-Control-Allow-Origin</span><span class="p">:</span> <span class="s">https://notyourdomain.com</span>
<span class="na">Access-Control-Allow-Method</span><span class="p">:</span> <span class="s">POST</span>
</code></pre></div></div> <p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 <code class="language-plaintext highlighter-rouge">onerror</code> 回调函数捕获。控制台会打印出如下的报错信息。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre></div></div> <p>服务器回应的其他 CORS 相关字段如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Access-Control-Allow-Methods</code> 字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨源请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。</li> <li><code class="language-plaintext highlighter-rouge">Access-Control-Allow-Headers</code> 如果浏览器请求包括 <code class="language-plaintext highlighter-rouge">Access-Control-Request-Headers</code> 字段，则 <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Headers</code> 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</li> <li><code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials</code> 字段与简单请求时的含义相同。</li> <li><code class="language-plaintext highlighter-rouge">Access-Control-Max-Age</code> 字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 2 0天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</li> </ul> <h3 id="43-浏览器的正常请求和回应">4.3 浏览器的正常请求和回应</h3> <p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 <code class="language-plaintext highlighter-rouge">Origin</code> 头信息字段。服务器的回应，也都会有一个 <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> 头信息字段。</p> <p>下面是“预检”请求之后，浏览器的正常 CORS 请求。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">PUT</span> <span class="nn">/cors</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Origin</span><span class="p">:</span> <span class="s">http://api.bob.com</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">api.alice.com</span>
<span class="na">X-Custom-Header</span><span class="p">:</span> <span class="s">value</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-US</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0...</span>
</code></pre></div></div> <p>上面头信息的 <code class="language-plaintext highlighter-rouge">Origin</code> 字段是浏览器自动添加的。</p> <p>下面是服务器正常的回应。</p> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
</span></code></pre></div></div> <p>上面头信息中，<code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> 字段是每次回应都必定包含的。</p> <h3 id="5-与-jsonp-的比较">5. 与 JSONP 的比较</h3> <p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持 <code class="language-plaintext highlighter-rouge">GET</code> 请求，CORS 支持所有类型的 HTTP 请求。<strong>JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据</strong>。</p> <h2 id="八storage-接口">八、Storage 接口</h2> <h3 id="81-概述">8.1 概述</h3> <p>Storage 接口用于脚本在浏览器保存数据。两个对象部署了这个接口：<code class="language-plaintext highlighter-rouge">window.sessionStorage</code> 和 <code class="language-plaintext highlighter-rouge">window.localStorage</code>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">sessionStorage</code> 保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空；</li> <li><code class="language-plaintext highlighter-rouge">localStorage</code> 保存的数据长期存在，下次访问该网站的时候，网页可以直接读取以前保存的数据。</li> </ul> <p>除了保存期限的长短不同，这两个对象的其他方面都一致。保存的数据都以“键值对”的形式存在。所有的数据都是以<strong>文本格式</strong>保存。这个接口能够使用的存储空间一般为 5M ~ 10M 左右。</p> <h3 id="82-属性和方法">8.2 属性和方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Storage.length</code> 是 Storage 接口唯一的一个属性，返回保存的数据项个数。</li> <li><code class="language-plaintext highlighter-rouge">Storage.setItem(key, value)</code> 用于存入数据。两个参数都是字符串。如果不是字符串，会自动转成字符串。</li> <li><code class="language-plaintext highlighter-rouge">Storage.getItem(key)</code> 用于读取数据。</li> <li><code class="language-plaintext highlighter-rouge">Storage.removeItem(key)</code> 用于清除某个键名对应的键值。</li> <li><code class="language-plaintext highlighter-rouge">Storage.clear()</code> 用于清除所有保存的数据。</li> <li><code class="language-plaintext highlighter-rouge">Storage.key(index)</code> 返回 <code class="language-plaintext highlighter-rouge">index</code> 位置对应的键名。</li> </ul> <h3 id="83-storage-事件">8.3 storage 事件</h3> <p>Storage 接口储存的数据发生变化时，会触发 <code class="language-plaintext highlighter-rouge">storage</code> 事件，可以指定这个事件的监听函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">storage</span><span class="dl">'</span><span class="p">,</span> <span class="nx">onStorageChange</span><span class="p">);</span>
</code></pre></div></div> <p>监听函数接受一个 <code class="language-plaintext highlighter-rouge">event</code> 实例对象作为参数。这个实例对象继承了 StorageEvent 接口，有几个特有的属性，都是只读属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">StorageEvent.key</code>：字符串，表示发生变动的键名。如果 <code class="language-plaintext highlighter-rouge">storage</code> 事件是由 <code class="language-plaintext highlighter-rouge">clear()</code> 引起，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">StorageEvent.oldValue</code>：字符串，表示旧的键值。</li> <li><code class="language-plaintext highlighter-rouge">StorageEvent.newValue</code>：字符串，表示新的键值。如果 <code class="language-plaintext highlighter-rouge">storage</code> 事件是由 <code class="language-plaintext highlighter-rouge">clear()</code> 或删除该键值对引发的，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">StorageEvent.storageArea</code>：对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。</li> <li><code class="language-plaintext highlighter-rouge">StorageEvent.url</code>：字符串，表示原始触发 <code class="language-plaintext highlighter-rouge">storage</code> 事件的那个网页的网址。</li> </ul> <p>注意，该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在<strong>同域名</strong>的<strong>其他窗口</strong>触发。也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。</p> <h2 id="九history-对象">九、History 对象</h2> <h3 id="91-概述">9.1 概述</h3> <p><code class="language-plaintext highlighter-rouge">window.history</code> 属性指向 History 对象，它表示当前窗口的浏览历史。History 对象保存了当前窗口访问过的所有页面网址。</p> <h3 id="92-属性">9.2 属性</h3> <p>History 对象主要有两个属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">History.length</code>：当前窗口访问过的网址数量（包括当前网页）。</li> <li><code class="language-plaintext highlighter-rouge">History.state</code>：History 堆栈最上层的状态值。</li> </ul> <h3 id="93-方法">9.3 方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。</li> <li><code class="language-plaintext highlighter-rouge">History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。</li> <li><code class="language-plaintext highlighter-rouge">History.go(delta)</code>：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如 <code class="language-plaintext highlighter-rouge">go(1)</code> 相当于 <code class="language-plaintext highlighter-rouge">forward()</code>，<code class="language-plaintext highlighter-rouge">go(-1)</code> 相当于 <code class="language-plaintext highlighter-rouge">back()</code>。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为 <code class="language-plaintext highlighter-rouge">0</code>，相当于刷新当前页面。</li> <li> <p><code class="language-plaintext highlighter-rouge">History.pushState(state, title, url)</code> 用于在历史中添加一条记录。</p> <p>该方法接受三个参数，依次为：</p> <ul> <li><code class="language-plaintext highlighter-rouge">state</code>：一个与添加的记录相关联的状态对象，主要用于 <code class="language-plaintext highlighter-rouge">popstate</code> 事件。该事件触发时，该对象会传入回调函数。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">title</code>：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。</li> <li><code class="language-plaintext highlighter-rouge">url</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</li> </ul> <p>假定当前网址是 <code class="language-plaintext highlighter-rouge">example.com/1.html</code>，使用 <code class="language-plaintext highlighter-rouge">pushState()</code> 在浏览记录（History 对象）中添加一个新记录。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">history</span><span class="p">.</span><span class="nf">pushState</span><span class="p">({</span> <span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span> <span class="p">},</span> <span class="dl">'</span><span class="s1">page 2</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2.html</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div> </div> <p>添加新记录后，浏览器地址栏立刻显示 <code class="language-plaintext highlighter-rouge">example.com/2.html</code>，但并不会跳转到 <code class="language-plaintext highlighter-rouge">2.html</code>，甚至也不会检查 <code class="language-plaintext highlighter-rouge">2.html</code> 是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问 <code class="language-plaintext highlighter-rouge">google.com</code>)，然后点击了倒退按钮，页面的 URL 将显示 <code class="language-plaintext highlighter-rouge">2.html</code>；你再点击一次倒退按钮，URL 将显示 <code class="language-plaintext highlighter-rouge">1.html</code>。</p> <p><code class="language-plaintext highlighter-rouge">pushState()</code> 不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。</p> <p>使用该方法之后，就可以用 <code class="language-plaintext highlighter-rouge">History.state</code> 属性读出状态对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">history</span><span class="p">.</span><span class="nf">pushState</span><span class="p">({</span> <span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span> <span class="p">},</span> <span class="dl">'</span><span class="s1">page 2</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2.html</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">history</span><span class="p">.</span><span class="nx">state</span> <span class="c1">// {foo: "bar"}</span>
</code></pre></div> </div> <p>如果 <code class="language-plaintext highlighter-rouge">pushState</code> 的 URL 参数设置了一个新的锚点值（即 <code class="language-plaintext highlighter-rouge">hash</code>），并不会触发 <code class="language-plaintext highlighter-rouge">hashchange</code> 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p> <p>如果 <code class="language-plaintext highlighter-rouge">pushState()</code> 设置了一个跨域网址，则会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 报错</span>
<span class="c1">// 当前网址为 http://example.com</span>
<span class="nx">history</span><span class="p">.</span><span class="nf">pushState</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="dl">''</span><span class="p">,</span> <span class="dl">'</span><span class="s1">https://twitter.com/hello</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">pushState</code> 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p> </li> <li><code class="language-plaintext highlighter-rouge">History.replaceState(state, title, url)</code> 用来修改 History 对象的当前记录，使用方法与 <code class="language-plaintext highlighter-rouge">pushState()</code> 一样。</li> </ul> <h3 id="94-popstate-事件">9.4 popstate 事件</h3> <p>每当同一个文档的浏览历史（即 <code class="language-plaintext highlighter-rouge">history</code> 对象）出现变化时，就会触发 <code class="language-plaintext highlighter-rouge">popstate</code> 事件。</p> <p>注意，仅仅调用 <code class="language-plaintext highlighter-rouge">pushState()</code> 或 <code class="language-plaintext highlighter-rouge">replaceState()</code>，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 <code class="language-plaintext highlighter-rouge">History.back()</code>、<code class="language-plaintext highlighter-rouge">History.forward()</code>、<code class="language-plaintext highlighter-rouge">History.go()</code> 时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p> <p>使用的时候，可以为 <code class="language-plaintext highlighter-rouge">popstate</code> 事件指定回调函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onpopstate</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">location: </span><span class="dl">'</span> <span class="o">+</span> <span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">state: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">state</span><span class="p">));</span>
<span class="p">};</span>

<span class="c1">// 或者</span>
<span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">popstate</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">location: </span><span class="dl">'</span> <span class="o">+</span> <span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">state: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">state</span><span class="p">));</span>
<span class="p">});</span>
</code></pre></div></div> <p>回调函数的参数是一个 <code class="language-plaintext highlighter-rouge">event</code> 事件对象，它的 <code class="language-plaintext highlighter-rouge">state</code> 属性指向 <code class="language-plaintext highlighter-rouge">pushState</code> 和 <code class="language-plaintext highlighter-rouge">replaceState</code> 方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数），这个 <code class="language-plaintext highlighter-rouge">state</code> 对象也可以直接通过 <code class="language-plaintext highlighter-rouge">history.state</code> 读取。</p> <p>页面第一次加载的时候，浏览器不会触发 <code class="language-plaintext highlighter-rouge">popstate</code> 事件。</p> <h2 id="十location-对象url-对象urlsearchparams-对象">十、Location 对象，URL 对象，URLSearchParams 对象</h2> <h3 id="1-location-对象">1. Location 对象</h3> <p><code class="language-plaintext highlighter-rouge">Location</code> 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 <code class="language-plaintext highlighter-rouge">window.location</code> 和 <code class="language-plaintext highlighter-rouge">document.location</code> 属性，可以拿到这个对象。</p> <h4 id="11-属性">1.1 属性</h4> <p>Location 对象提供以下属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Location.href：</code> 整个 URL。</li> <li><code class="language-plaintext highlighter-rouge">Location.protocol</code>：当前 URL 的协议，包括冒号（<code class="language-plaintext highlighter-rouge">:</code>）。</li> <li><code class="language-plaintext highlighter-rouge">Location.hostname</code>：主机名，不包括端口。</li> <li><code class="language-plaintext highlighter-rouge">Location.host</code>：主机。如果端口不是协议默认的 <code class="language-plaintext highlighter-rouge">80</code> 和 <code class="language-plaintext highlighter-rouge">433</code>，则还会包括冒号（<code class="language-plaintext highlighter-rouge">:</code>）和端口。</li> <li><code class="language-plaintext highlighter-rouge">Location.port</code>：端口号。</li> <li><code class="language-plaintext highlighter-rouge">Location.origin</code>：URL 的协议、主机名和端口。</li> <li><code class="language-plaintext highlighter-rouge">Location.pathname</code>：URL 的路径部分，从根路径 <code class="language-plaintext highlighter-rouge">/</code> 开始。</li> <li><code class="language-plaintext highlighter-rouge">Location.search</code>：查询字符串部分，从问号 <code class="language-plaintext highlighter-rouge">?</code> 开始。</li> <li><code class="language-plaintext highlighter-rouge">Location.hash</code>：片段字符串部分，从 <code class="language-plaintext highlighter-rouge">#</code> 开始。</li> <li><code class="language-plaintext highlighter-rouge">Location.username</code>：域名前面的用户名。</li> <li><code class="language-plaintext highlighter-rouge">Location.password</code>：域名前面的密码。</li> </ul> <p>这些属性里面，只有 <code class="language-plaintext highlighter-rouge">origin</code> 属性是只读的，其他属性都可写。</p> <p>如果对 <code class="language-plaintext highlighter-rouge">Location.href</code> 写入新的 URL 地址，浏览器会立刻跳转到这个新地址。这个特性常常用于让网页自动滚动到新的锚点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 跳转到新网址</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://www.example.com</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <h4 id="12-方法">1.2 方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Location.assign(url)</code> 方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。</li> <li> <p><code class="language-plaintext highlighter-rouge">Location.replace(url)</code> 方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。它与 <code class="language-plaintext highlighter-rouge">assign</code> 方法的差异在于，<code class="language-plaintext highlighter-rouge">replace</code> 会在浏览器的浏览历史 <code class="language-plaintext highlighter-rouge">History</code> 里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 跳转到新的网址</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://www.example.com</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">Location.reload(force)</code> 方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。它接受一个布尔值作为参数。如果参数为 <code class="language-plaintext highlighter-rouge">true</code>，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即 <code class="language-plaintext highlighter-rouge">scrollTop === 0</code>）。如果参数是 <code class="language-plaintext highlighter-rouge">false</code> 或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。</li> <li><code class="language-plaintext highlighter-rouge">Location.toString()</code> 方法返回整个 URL 字符串，相当于读取 <code class="language-plaintext highlighter-rouge">Location.href</code> 属性。</li> </ul> <h3 id="2-url-的编码和解码">2. URL 的编码和解码</h3> <p>网页的 URL 只能包含合法的字符。合法字符分成两类。</p> <ul> <li><strong>元字符</strong>：斜杠（<code class="language-plaintext highlighter-rouge">/</code>），冒号（<code class="language-plaintext highlighter-rouge">:</code>），at（<code class="language-plaintext highlighter-rouge">@</code>），问号（<code class="language-plaintext highlighter-rouge">?</code>），等号（<code class="language-plaintext highlighter-rouge">=</code>），<code class="language-plaintext highlighter-rouge">&amp;</code>，井号（<code class="language-plaintext highlighter-rouge">#</code>），分号（<code class="language-plaintext highlighter-rouge">;</code>），逗号（<code class="language-plaintext highlighter-rouge">,</code>），加号（<code class="language-plaintext highlighter-rouge">+</code>），美元符号（<code class="language-plaintext highlighter-rouge">$</code>）</li> <li><strong>语义字符</strong>：<code class="language-plaintext highlighter-rouge">a-z</code>，<code class="language-plaintext highlighter-rouge">A-Z</code>，<code class="language-plaintext highlighter-rouge">0-9</code>，连词号（<code class="language-plaintext highlighter-rouge">-</code>），下划线（<code class="language-plaintext highlighter-rouge">_</code>），点（<code class="language-plaintext highlighter-rouge">.</code>），感叹号（<code class="language-plaintext highlighter-rouge">!</code>），波浪线（<code class="language-plaintext highlighter-rouge">~</code>），星号（<code class="language-plaintext highlighter-rouge">*</code>），单引号（<code class="language-plaintext highlighter-rouge">'</code>），圆括号（<code class="language-plaintext highlighter-rouge">()</code>）</li> </ul> <p>除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（<code class="language-plaintext highlighter-rouge">%</code>）加上两个大写的十六进制字母。</p> <p>比如，UTF-8 的操作系统上，<code class="language-plaintext highlighter-rouge">http://www.example.com/q=春节</code> 这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成 <code class="language-plaintext highlighter-rouge">http://www.example.com/q=%E6%98%A5%E8%8A%82</code>。其中，“春”转成了 <code class="language-plaintext highlighter-rouge">%E6%98%A5</code>，“节”转成了 <code class="language-plaintext highlighter-rouge">%E8%8A%82</code>。这是因为“春”和“节”的 UTF-8 编码分别是 <code class="language-plaintext highlighter-rouge">E6 98 A5</code> 和 <code class="language-plaintext highlighter-rouge">E8 8A 82</code>，将每个字节前面加上百分号，就构成了 URL 编码。</p> <p>JavaScript 提供四个 URL 的编码/解码方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">encodeURI(URI)</code> 方法用于转码整个 URL。它会将<strong>元字符和语义字符之外</strong>的字符，都进行转义。</li> <li> <p><code class="language-plaintext highlighter-rouge">encodeURIComponent(str)</code> 方法用于转码 URL 的组成部分，会转码除了<strong>语义字符之外</strong>的所有字符，即元字符也会被转码。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">encodeURIComponent</span><span class="p">(</span><span class="dl">'</span><span class="s1">春节</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// "%E6%98%A5%E8%8A%82"</span>
<span class="nf">encodeURIComponent</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://www.example.com/q=春节</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// "http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82"</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">decodeURI(encodedURI)</code> 方法用于整个 URL 的解码。它是 <code class="language-plaintext highlighter-rouge">encodeURI()</code> 方法的逆运算。</li> <li><code class="language-plaintext highlighter-rouge">decodeURIComponent(encodedURI)</code> 方法用于URL 片段的解码。它是 <code class="language-plaintext highlighter-rouge">encodeURIComponent()</code> 方法的逆运算</li> </ul> <h3 id="3-url-接口">3. URL 接口</h3> <h4 id="31-构造函数">3.1 构造函数</h4> <p><code class="language-plaintext highlighter-rouge">URL(url, base)</code> 构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。</p> <p>除了字符串，<code class="language-plaintext highlighter-rouge">URL()</code> 的参数也可以是另一个 URL 实例。这时，<code class="language-plaintext highlighter-rouge">URL()</code> 会自动读取该实例的 <code class="language-plaintext highlighter-rouge">href</code> 属性，作为实际参数。</p> <h4 id="32-实例属性">3.2 实例属性</h4> <p>URL 实例的属性与 Location 对象的属性基本一致，返回当前 URL 的信息。</p> <ul> <li><code class="language-plaintext highlighter-rouge">URL.href</code>：返回整个 URL</li> <li><code class="language-plaintext highlighter-rouge">URL.protocol</code>：返回协议，以冒号 <code class="language-plaintext highlighter-rouge">:</code> 结尾</li> <li><code class="language-plaintext highlighter-rouge">URL.hostname</code>：返回域名</li> <li><code class="language-plaintext highlighter-rouge">URL.host</code>：返回域名与端口，包含 <code class="language-plaintext highlighter-rouge">:</code> 号，默认的 <code class="language-plaintext highlighter-rouge">80</code> 和 <code class="language-plaintext highlighter-rouge">443</code> 端口会省略</li> <li><code class="language-plaintext highlighter-rouge">URL.port</code>：返回端口</li> <li><code class="language-plaintext highlighter-rouge">URL.origin</code>：返回协议、域名和端口</li> <li><code class="language-plaintext highlighter-rouge">URL.pathname</code>：返回路径，以斜杠 <code class="language-plaintext highlighter-rouge">/</code> 开头</li> <li><code class="language-plaintext highlighter-rouge">URL.search</code>：返回查询字符串，以问号 <code class="language-plaintext highlighter-rouge">?</code> 开头</li> <li><code class="language-plaintext highlighter-rouge">URL.searchParams</code>：返回一个 URLSearchParams 实例，该属性是 Location 对象没有的</li> <li><code class="language-plaintext highlighter-rouge">URL.hash</code>：返回片段识别符，以井号 <code class="language-plaintext highlighter-rouge">#</code> 开头</li> <li><code class="language-plaintext highlighter-rouge">URL.username</code>：返回域名前面的用户名</li> <li><code class="language-plaintext highlighter-rouge">URL.password</code>：返回域名前面的密码</li> </ul> <p>这些属性里面，只有 <code class="language-plaintext highlighter-rouge">origin</code> 属性是只读的，其他属性都可写，并且会立即生效。</p> <h4 id="33-静态方法">3.3 静态方法</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">URL.createObjectURL(object)</code> 方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了 <code class="language-plaintext highlighter-rouge">File</code> 对象或 <code class="language-plaintext highlighter-rouge">Blob</code> 对象的 URL。</p> <p>注意，每次使用 <code class="language-plaintext highlighter-rouge">URL.createObjectURL()</code> 方法，都会在内存里面生成一个 URL 实例。如果不再需要该方法生成的 URL 字符串，为了节省内存，可以使用 <code class="language-plaintext highlighter-rouge">URL.revokeObjectURL()</code> 方法释放这个实例。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>blob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">URL.revokeObjectURL(objectURL)</code> 方法用来释放 <code class="language-plaintext highlighter-rouge">URL.createObjectURL()</code> 方法生成的 URL 实例。它的参数就是 <code class="language-plaintext highlighter-rouge">URL.createObjectURL()</code> 方法返回的 URL 字符串。</p> </li> </ul> <h3 id="4-urlsearchparams-对象">4. URLSearchParams 对象</h3> <p><code class="language-plaintext highlighter-rouge">URLSearchParams</code> 对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号 <code class="language-plaintext highlighter-rouge">?</code> 有没有都行，也可以是对应查询字符串的数组或对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 方法一：传入字符串</span>
<span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLSearchParams</span><span class="p">(</span><span class="dl">'</span><span class="s1">?foo=1&amp;bar=2</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLSearchParams</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">search</span><span class="p">);</span>

<span class="c1">// 方法二：传入数组</span>
<span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLSearchParams</span><span class="p">([[</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]);</span>

<span class="c1">// 方法三：传入对象</span>
<span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLSearchParams</span><span class="p">({</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">,</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span> <span class="p">:</span> <span class="mi">2</span><span class="p">});</span>
</code></pre></div></div> <p>浏览器向服务器发送表单数据时，可以直接使用 <code class="language-plaintext highlighter-rouge">URLSearchParams</code> 实例作为表单数据。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLSearchParams</span><span class="p">({</span><span class="na">foo</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="mi">2</span><span class="p">});</span>
<span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://example.com/api</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">body</span><span class="p">:</span> <span class="nx">params</span>
<span class="p">}).</span><span class="nf">then</span><span class="p">(...)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">URLSearchParams</code> 可以与 <code class="language-plaintext highlighter-rouge">URL()</code> 接口结合使用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URL</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">searchParams</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">somedefault</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">URLSearchParams</code> 实例有遍历器接口，可以用 <code class="language-plaintext highlighter-rouge">for...of</code> 循环遍历。<code class="language-plaintext highlighter-rouge">URLSearchParams</code> 没有实例属性，只有实例方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">URLSearchParams.toString()</code> 方法返回实例的字符串形式。</li> <li><code class="language-plaintext highlighter-rouge">URLSearchParams.append(name, value)</code> 方法用来追加一个查询参数。它接受两个参数，第一个为键名，第二个为键值，没有返回值。</li> <li><code class="language-plaintext highlighter-rouge">URLSearchParams.delete(name)</code> 方法用来删除指定的查询参数。它接受键名作为参数。</li> <li><code class="language-plaintext highlighter-rouge">URLSearchParams.has(name)</code> 方法返回一个布尔值，表示查询字符串是否包含指定的键名。</li> <li><code class="language-plaintext highlighter-rouge">URLSearchParams.set(name, value)</code> 方法用来设置查询字符串的键值。</li> <li><code class="language-plaintext highlighter-rouge">URLSearchParams.get(name)</code> 方法用来读取查询字符串里面的指定键。它接受键名作为参数。</li> <li> <p><code class="language-plaintext highlighter-rouge">URLSearchParams.getAll(name)</code> 方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLSearchParams</span><span class="p">(</span><span class="dl">'</span><span class="s1">?foo=1&amp;foo=2</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">params</span><span class="p">.</span><span class="nf">getAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// ["1", "2"]</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">URLSearchParams.sort()</code> 方法对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。</li> <li><code class="language-plaintext highlighter-rouge">URLSearchParams.keys()</code>，<code class="language-plaintext highlighter-rouge">URLSearchParams.values()</code>，<code class="language-plaintext highlighter-rouge">URLSearchParams.entries()</code> 这三个方法都返回一个遍历器对象，供 <code class="language-plaintext highlighter-rouge">for...of</code> 循环遍历。它们的区别在于，<code class="language-plaintext highlighter-rouge">keys</code> 方法返回的是键名的遍历器，<code class="language-plaintext highlighter-rouge">values</code> 方法返回的是键值的遍历器，<code class="language-plaintext highlighter-rouge">entries</code> 返回的是键值对的遍历器。</li> </ul> <h2 id="十一arraybuffer-对象blob-对象">十一、ArrayBuffer 对象，Blob 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十二file-对象filelist-对象filereader-对象">十二、File 对象，FileList 对象，FileReader 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十三表单formdata-对象">十三、表单，FormData 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十四indexeddb-api">十四、IndexedDB API</h2> <h3 id="1-概述-2">1. 概述</h3> <p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p> <p>IndexedDB 具有以下特点。</p> <ul> <li><strong>键值对储存</strong>。IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以“键值对”的形式保存，每个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li> <li><strong>异步</strong>。IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 <code class="language-plaintext highlighter-rouge">LocalStorage</code> 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li> <li><strong>支持事务</strong>。IndexedDB 支持<strong>事务</strong>（transaction），这意味着一系列操作步骤中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li> <li><strong>同源限制</strong>。IndexedDB 受到同源限制，每个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li> <li><strong>储存空间大</strong>。IndexedDB 的储存空间比 <code class="language-plaintext highlighter-rouge">LocalStorage</code> 大得多，一般来说不少于 250MB，甚至没有上限。</li> <li><strong>支持二进制储存</strong>。IndexedDB 不仅可以储存字符串，还可以储存二进制数据（<code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 对象和 <code class="language-plaintext highlighter-rouge">Blob</code> 对象）。</li> </ul> <h3 id="2-基本概念">2. 基本概念</h3> <p>IndexedDB 是一个比较复杂的 API。它把不同的实体，抽象成一个个对象接口。</p> <ul> <li>数据库：<code class="language-plaintext highlighter-rouge">IDBDatabase</code> 对象。数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。</li> <li>对象仓库：<code class="language-plaintext highlighter-rouge">IDBObjectStore</code> 对象。每个数据库包含若干个对象仓库（object store）。</li> <li>索引：<code class="language-plaintext highlighter-rouge">IDBIndex</code> 对象。指对象仓库保存的数据记录。每条记录只有主键和数据体两部分。</li> <li>事务：<code class="language-plaintext highlighter-rouge">IDBTransaction</code> 对象。数据记录的读写和删改，都要通过事务完成。</li> <li>操作请求：<code class="language-plaintext highlighter-rouge">IDBRequest</code> 对象。</li> <li>指针：<code class="language-plaintext highlighter-rouge">IDBCursor</code> 对象。</li> <li>主键集合：<code class="language-plaintext highlighter-rouge">IDBKeyRange</code> 对象。</li> </ul> <h3 id="3-操作流程">3. 操作流程</h3> <h4 id="31-打开数据库">3.1 打开数据库</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h4 id="32-新建数据库">3.2 新建数据库</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h4 id="33-新增数据">3.3 新增数据</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h4 id="34-读取数据">3.4 读取数据</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h4 id="35-遍历数据">3.5 遍历数据</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h4 id="36-更新数据">3.6 更新数据</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h4 id="37-删除数据">3.7 删除数据</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h4 id="38-使用索引">3.8 使用索引</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h3 id="4-indexeddb-对象">4. indexedDB 对象</h3> <h4 id="41-indexeddbopen">4.1 indexedDB.open()</h4> <h4 id="42-indexeddbdeletedatabase">4.2 indexedDB.deleteDatabase()</h4> <h4 id="43-indexeddbcmp">4.3 indexedDB.cmp()</h4> <h3 id="5-idbrequest-对象">5. IDBRequest 对象</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h3 id="6-idbdatabase-对象">6. IDBDatabase 对象</h3> <h4 id="61-属性">6.1 属性</h4> <h4 id="62-方法">6.2 方法</h4> <h3 id="7-idbobjectstore-对象">7. IDBObjectStore 对象</h3> <h4 id="71-属性">7.1 属性</h4> <h4 id="72-方法">7.2 方法</h4> <h3 id="8-idbtransaction-对象">8. IDBTransaction 对象</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h3 id="9-idbindex-对象">9. IDBIndex 对象</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h3 id="10-idbcursor-对象">10. IDBCursor 对象</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h3 id="11-idbkeyrange-对象">11. IDBKeyRange 对象</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十五web-worker">十五、Web Worker</h2> <h3 id="151-概述">15.1 概述</h3> <p>JavaScript 语言采用单线程模型，Web Worker 的引入，为 JavaScript 创造了多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p> <p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p> <p>Web Worker 有以下几个使用注意点。</p> <ul> <li>同源限制：分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</li> <li>DOM 限制：Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 <code class="language-plaintext highlighter-rouge">document</code>、<code class="language-plaintext highlighter-rouge">window</code>、<code class="language-plaintext highlighter-rouge">parent</code> 这些对象。但是，Worker 线程可以使用 <code class="language-plaintext highlighter-rouge">navigator</code> 对象和 <code class="language-plaintext highlighter-rouge">location</code> 对象。</li> <li>全局对象限制：Worker 的全局对象 <code class="language-plaintext highlighter-rouge">WorkerGlobalScope</code>，不同于网页的全局对象 Window，很多接口拿不到。比如，理论上 Worker 线程不能使用 <code class="language-plaintext highlighter-rouge">console.log</code>，因为标准里面没有提到 Worker 的全局对象存在 <code class="language-plaintext highlighter-rouge">console</code> 接口，只定义了 Navigator 接口和 Location 接口。不过，浏览器实际上支持 Worker 线程使用 <code class="language-plaintext highlighter-rouge">console.log</code>，保险的做法还是不使用这个方法。</li> <li>通信联系：Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</li> <li>脚本限制：Worker 线程不能执行 <code class="language-plaintext highlighter-rouge">alert()</code> 和 <code class="language-plaintext highlighter-rouge">confirm()</code>，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</li> <li>文件限制：<strong>Worker 线程无法读取本地文件</strong>，即不能打开本机的文件系统（<code class="language-plaintext highlighter-rouge">file://</code>），<strong>它所加载的脚本，必须来自网络</strong>。</li> </ul> <h3 id="152-基本用法">15.2 基本用法</h3> <h4 id="1主线程">（1）主线程</h4> <p>在主线程创建使用 Worker 的步骤如下。</p> <ol> <li>主线程采用 <code class="language-plaintext highlighter-rouge">new</code> 命令，调用 <code class="language-plaintext highlighter-rouge">Worker()</code> 构造函数，新建一个 Worker 线程。<code class="language-plaintext highlighter-rouge">Worker()</code> 构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功，Worker 会失败。</li> <li>主线程调用 <code class="language-plaintext highlighter-rouge">worker.postMessage()</code> 向 Worker 发消息。<code class="language-plaintext highlighter-rouge">worker.postMessage()</code> 的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</li> <li>主线程通过 <code class="language-plaintext highlighter-rouge">worker.onmessage</code> 指定监听函数，接收子线程发回来的消息。</li> <li>Worker 完成任务以后，主线程就可以把它关掉。</li> </ol> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Worker</span><span class="p">(</span><span class="dl">'</span><span class="s1">work.js</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">worker</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">worker</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">({</span><span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">echo</span><span class="dl">'</span><span class="p">,</span> <span class="na">args</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Work</span><span class="dl">'</span><span class="p">]});</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// do something...</span>
<span class="p">}</span>
<span class="nx">worker</span><span class="p">.</span><span class="nf">terminate</span><span class="p">();</span>
</code></pre></div></div> <h4 id="2worker-线程">（2）Worker 线程</h4> <p>Worker 线程内部需要有一个监听函数，监听 <code class="language-plaintext highlighter-rouge">message</code> 事件。可以使用 <code class="language-plaintext highlighter-rouge">self.addEventListener()</code> 或者 <code class="language-plaintext highlighter-rouge">self.onmessage</code> 指定监听函数。其中，<code class="language-plaintext highlighter-rouge">self</code> 代表子线程自身，即子线程的全局对象。监听函数的参数是一个事件对象，它的 <code class="language-plaintext highlighter-rouge">data</code> 属性包含主线程发来的数据。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 写法一</span>
<span class="k">this</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">You said: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="c1">// 写法二</span>
<span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">postMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">You said: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <h4 id="3worker-加载脚本">（3）Worker 加载脚本</h4> <p>可以通过 <code class="language-plaintext highlighter-rouge">importScripts()</code> 在 Worker 内部加载其他脚本。该方法可以同时加载多个脚本。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">importScripts</span><span class="p">(</span><span class="dl">'</span><span class="s1">script1.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">script2.js</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <h4 id="4错误处理">（4）错误处理</h4> <p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的 <code class="language-plaintext highlighter-rouge">error</code> 事件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">worker</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
    <span class="dl">'</span><span class="s1">ERROR: Line </span><span class="dl">'</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">lineno</span><span class="p">,</span> <span class="dl">'</span><span class="s1"> in </span><span class="dl">'</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">filename</span><span class="p">,</span> <span class="dl">'</span><span class="s1">: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">message</span>
  <span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 或者</span>
<span class="nx">worker</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="5关闭-worker">（5）关闭 Worker</h4> <p>使用完毕，为了节省系统资源，必须关闭 Worker。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 主线程</span>
<span class="nx">worker</span><span class="p">.</span><span class="nf">terminate</span><span class="p">();</span>
<span class="c1">// Worker 线程</span>
<span class="nb">self</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
</code></pre></div></div> <h3 id="153-数据通信">15.3 数据通信</h3> <p>主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。这种通信是拷贝关系，即是<strong>传值</strong>而不是传址，Worker 对通信内容的修改，不会影响到主线程。浏览器内部的运行机制是，先将通信内容<strong>串行化</strong>，然后把串行化后的字符串发给 Worker，后者再将它还原。</p> <p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。</p> <p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做 <strong>Transferable Objects</strong>。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便，不会产生性能负担。</p> <p>如果要直接转移数据的控制权，就要使用下面的写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Transferable Objects 格式</span>
<span class="nx">worker</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span><span class="nx">arrayBuffer</span><span class="p">,</span> <span class="p">[</span><span class="nx">arrayBuffer</span><span class="p">]);</span>

<span class="c1">// 例子</span>
<span class="kd">var</span> <span class="nx">ab</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">worker</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span><span class="nx">ab</span><span class="p">,</span> <span class="p">[</span><span class="nx">ab</span><span class="p">]);</span>
</code></pre></div></div> <h3 id="154-同页面的-web-worker">15.4 同页面的 Web Worker</h3> <p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script </span><span class="na">id=</span><span class="s">"worker"</span> <span class="na">type=</span><span class="s">"app/worker"</span><span class="nt">&gt;</span>
      <span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">postMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">some message</span><span class="dl">'</span><span class="p">);</span>
      <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
    <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div> <p>上面是一段嵌入网页的脚本，注意必须指定 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性是一个浏览器不认识的值，上例是 <code class="language-plaintext highlighter-rouge">app/worker</code>。</p> <p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">blob</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Blob</span><span class="p">([</span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#worker</span><span class="dl">'</span><span class="p">).</span><span class="nx">textContent</span><span class="p">]);</span>
<span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">createObjectURL</span><span class="p">(</span><span class="nx">blob</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Worker</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// e.data === 'some message'</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p> <h3 id="155-实例worker-线程完成轮询">15.5 实例：Worker 线程完成轮询</h3> <p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">createWorker</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">blob</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Blob</span><span class="p">([</span><span class="dl">'</span><span class="s1">(</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">f</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">)()</span><span class="dl">'</span><span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">createObjectURL</span><span class="p">(</span><span class="nx">blob</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Worker</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">worker</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">pollingWorker</span> <span class="o">=</span> <span class="nf">createWorker</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">cache</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nf">compare</span><span class="p">(</span><span class="k">new</span><span class="p">,</span> <span class="nx">old</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
  <span class="nf">setInterval</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">/my-api-endpoint</span><span class="dl">'</span><span class="p">).</span><span class="nf">then</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">();</span>
      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nf">compare</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">cache</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">cache</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">});</span>

<span class="nx">pollingWorker</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// render data</span>
<span class="p">}</span>

<span class="nx">pollingWorker</span><span class="p">.</span><span class="nf">postMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">init</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p> <h3 id="156-api">15.6 API</h3> <h4 id="1主线程-1">（1）主线程</h4> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">Worker()</code> 构造函数，用来供主线程生成 Worker 线程。<code class="language-plaintext highlighter-rouge">Worker()</code> 构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 主线程</span>
<span class="kd">var</span> <span class="nx">myWorker</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Worker</span><span class="p">(</span><span class="dl">'</span><span class="s1">worker.js</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">name</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">myWorker</span><span class="dl">'</span> <span class="p">});</span>
<span class="c1">// Worker 线程</span>
<span class="nb">self</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// myWorker</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Worker()</code> 构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Worker.onerror</code>：指定 <code class="language-plaintext highlighter-rouge">error</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">Worker.onmessage</code>：指定 <code class="language-plaintext highlighter-rouge">message</code> 事件的监听函数，发送过来的数据在 <code class="language-plaintext highlighter-rouge">Event.data</code> 属性中。</li> <li><code class="language-plaintext highlighter-rouge">Worker.onmessageerror</code>：指定 <code class="language-plaintext highlighter-rouge">messageerror</code> 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">Worker.postMessage()</code>：向 Worker 线程发送消息。</li> <li><code class="language-plaintext highlighter-rouge">Worker.terminate()</code>：立即终止 Worker 线程。</li> </ul> <h4 id="2worker-线程-1">（2）Worker 线程</h4> <p>Web Worker 有自己的全局对象，不是主线程的 <code class="language-plaintext highlighter-rouge">window</code>，而是一个专门为 Worker 定制的全局对象。因此定义在 <code class="language-plaintext highlighter-rouge">window</code> 上面的对象和方法不是全部都可以使用。</p> <p>Worker 线程有一些自己的全局属性和方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">self.name</code>： Worker 的名字。该属性只读，由构造函数指定。</li> <li><code class="language-plaintext highlighter-rouge">self.onmessage</code>：指定 <code class="language-plaintext highlighter-rouge">message</code> 事件的监听函数。</li> <li><code class="language-plaintext highlighter-rouge">self.onmessageerror</code>：指定 <code class="language-plaintext highlighter-rouge">messageerror</code> 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">self.close()</code>：关闭 Worker 线程。</li> <li><code class="language-plaintext highlighter-rouge">self.postMessage()</code>：向产生这个 Worker 的线程发送消息。</li> <li><code class="language-plaintext highlighter-rouge">self.importScripts()</code>：加载 JS 脚本。</li> </ul> <h2 id="十六参考">十六、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/bom/">JavaScript 教程 - 浏览器模型</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 浏览器模型》一章中部分知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/events/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-17T00:00:00+00:00</published><updated>2024-10-17T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/events</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/events/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/events/">《JavaScript 教程 - 事件》</a>一章中部分知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一eventtarget-接口">一、EventTarget 接口</h2> <p>DOM 节点的事件操作（监听和触发），都定义在 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code class="language-plaintext highlighter-rouge">XMLHttpRequest</code>、<code class="language-plaintext highlighter-rouge">AudioNode</code>、<code class="language-plaintext highlighter-rouge">AudioContext</code>）也部署了这个接口。</p> <p>该接口主要提供三个实例方法。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">addEventListener(type, listener[, useCapture])</code>：用于在当前节点或对象上（即部署了 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口的对象），定义一个特定事件的监听函数。</p> <p>第三个参数除了布尔值 <code class="language-plaintext highlighter-rouge">useCapture</code>，还可以是一个监听器配置对象，定制事件监听行为。该对象有以下属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">capture</code>：布尔值，如果设为 <code class="language-plaintext highlighter-rouge">true</code>，表示监听函数在捕获阶段触发，默认为 <code class="language-plaintext highlighter-rouge">false</code>，在冒泡阶段触发。</li> <li><code class="language-plaintext highlighter-rouge">once</code>：布尔值，如果设为 <code class="language-plaintext highlighter-rouge">true</code>，表示监听函数执行一次就会自动移除，后面将不再监听该事件。该属性默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">passive</code>：布尔值，设为 <code class="language-plaintext highlighter-rouge">true</code> 时，表示禁止监听函数调用 <code class="language-plaintext highlighter-rouge">preventDefault()</code>。如果调用了，浏览器将忽略这个要求，并在控制台输出一条警告。该属性默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">signal</code>：该属性的值为一个 <code class="language-plaintext highlighter-rouge">AbortSignal</code> 对象，为监听器设置了一个信号通道，用来在需要时发出信号，移除监听函数。</li> </ul> <p><code class="language-plaintext highlighter-rouge">addEventListener()</code> 可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用 <code class="language-plaintext highlighter-rouge">removeEventListener()</code> 手动去除）。</p> </li> <li><code class="language-plaintext highlighter-rouge">removeEventListener(type, listener[, useCapture])</code>：用于移除事件的监听函数，与 <code class="language-plaintext highlighter-rouge">addEventListener()</code> 完全一致。它的第一个参数“事件类型”，大小写敏感。</li> <li><code class="language-plaintext highlighter-rouge">dispatchEvent(event)</code>：用于在当前节点上触发指定事件，从而触发监听函数的执行。</li> </ul> <h2 id="二事件模型">二、事件模型</h2> <p>JavaScript 有三种方法，可以为事件绑定监听函数。</p> <ul> <li>HTML 的 <code class="language-plaintext highlighter-rouge">on-</code> 属性。使用这个方法指定的监听代码，只会在<strong>冒泡阶段</strong>触发。</li> <li>元素节点的事件属性。使用这个方法指定的监听函数，也是只会在<strong>冒泡阶段</strong>触发。</li> <li> <p><code class="language-plaintext highlighter-rouge">EventTarget.addEventListener()</code>，推荐使用这种方法。它有如下优点：</p> <ul> <li>同一个事件可以添加多个监听函数。</li> <li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li> <li>除了 DOM 节点，其他对象（比如 <code class="language-plaintext highlighter-rouge">window</code>、<code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> 等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li> </ul> </li> </ul> <p>上面三种方式，函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 指向触发事件的元素节点。</p> <p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p> <ul> <li>第一阶段：从 <code class="language-plaintext highlighter-rouge">window</code> 对象传导到目标节点（上层传到底层），称为“<strong>捕获阶段</strong>”（capture phase）。</li> <li>第二阶段：在目标节点上触发，称为“<strong>目标阶段</strong>”（target phase）。</li> <li>第三阶段：从目标节点传导回 <code class="language-plaintext highlighter-rouge">window</code> 对象（从底层传回上层），称为“<strong>冒泡阶段</strong>”（bubbling phase）。</li> </ul> <p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的<strong>代理</strong>（delegation）。</p> <h2 id="三event-对象">三、Event 对象</h2> <h3 id="31-概述">3.1 概述</h3> <p><code class="language-plaintext highlighter-rouge">Event</code> 构造函数可以用来生成实例对象。他接受两参数，第一个参数 <code class="language-plaintext highlighter-rouge">type</code> 是字符串，表示事件的名称；第二个参数 <code class="language-plaintext highlighter-rouge">options</code> 是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">bubbles</code>：布尔值，可选，默认为 <code class="language-plaintext highlighter-rouge">false</code>（即生成的事件只在“捕获阶段”触发监听函数），表示事件对象是否冒泡。</li> <li><code class="language-plaintext highlighter-rouge">cancelable</code>：布尔值，可选，默认为 <code class="language-plaintext highlighter-rouge">false</code>，表示事件是否可以被取消，即能否用 <code class="language-plaintext highlighter-rouge">Event.preventDefault()</code> 取消这个事件。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">ev</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Event</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">look</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="dl">'</span><span class="s1">bubbles</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="dl">'</span><span class="s1">cancelable</span><span class="dl">'</span><span class="p">:</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">ev</span><span class="p">);</span>
</code></pre></div></div> <h3 id="32-实例属性">3.2 实例属性</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Event.type</code> 属性返回一个字符串，表示事件类型。</li> <li><code class="language-plaintext highlighter-rouge">Event.bubbles</code> 属性返回一个布尔值，表示当前事件是否会冒泡。该属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">Event.eventPhase</code> 属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。<code class="language-plaintext highlighter-rouge">Event.eventPhase</code> 的返回值有四种可能。</p> <ul> <li><code class="language-plaintext highlighter-rouge">0</code>，事件目前没有发生。</li> <li><code class="language-plaintext highlighter-rouge">1</code>，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li> <li><code class="language-plaintext highlighter-rouge">2</code>，事件到达目标节点，即 Event.target 属性指向的那个节点。</li> <li><code class="language-plaintext highlighter-rouge">3</code>，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">Event.cancelable</code> 属性返回一个布尔值，表示事件是否可以取消。</li> <li><code class="language-plaintext highlighter-rouge">Event.cancelBubble</code> 属性是一个布尔值，如果设为 <code class="language-plaintext highlighter-rouge">true</code>，相当于执行 <code class="language-plaintext highlighter-rouge">Event.stopPropagation()</code>，可以阻止事件的传播。</li> <li><code class="language-plaintext highlighter-rouge">Event.defaultPrevented</code> 属性返回一个布尔值，表示该事件是否调用过 <code class="language-plaintext highlighter-rouge">Event.preventDefault()</code> 方法。该属性只读。</li> <li><code class="language-plaintext highlighter-rouge">Event.target</code> 属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</li> <li> <p><code class="language-plaintext highlighter-rouge">Event.currentTarget</code> 属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;p id="para"&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;</span>
<span class="kd">function</span> <span class="nf">hide</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 不管点击 Hello 或 World，总是返回 true</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">e</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">);</span>
  <span class="c1">// 点击 Hello，返回 true</span>
  <span class="c1">// 点击 World，返回 false</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
<span class="p">}</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">).</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">hide</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code> 是 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 的子节点，点击 <code class="language-plaintext highlighter-rouge">&lt;em&gt;</code> 或者点击 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>，都会导致监听函数执行。这时，<code class="language-plaintext highlighter-rouge">e.target</code> 总是指向原始点击位置的那个节点，而 <code class="language-plaintext highlighter-rouge">e.currentTarget</code> 指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以 <code class="language-plaintext highlighter-rouge">e.currentTarget</code> 总是等同于监听函数内部的 <code class="language-plaintext highlighter-rouge">this</code>。</p> </li> <li><code class="language-plaintext highlighter-rouge">Event.timeStamp</code> 属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</li> <li><code class="language-plaintext highlighter-rouge">Event.isTrusted</code> 属性返回一个布尔值，表示该事件是否由真实的用户行为产生。</li> <li><code class="language-plaintext highlighter-rouge">Event.detail</code> 属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于 <code class="language-plaintext highlighter-rouge">click</code> 和 <code class="language-plaintext highlighter-rouge">dblclick</code> 事件，<code class="language-plaintext highlighter-rouge">Event.detail</code> 是鼠标按下的次数（<code class="language-plaintext highlighter-rouge">1</code> 表示单击，<code class="language-plaintext highlighter-rouge">2</code> 表示双击，<code class="language-plaintext highlighter-rouge">3</code> 表示三击）；对于鼠标滚轮事件，<code class="language-plaintext highlighter-rouge">Event.detail</code> 是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是 <code class="language-plaintext highlighter-rouge">3</code> 的倍数。</li> </ul> <h3 id="33-实例方法">3.3 实例方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Event.preventDefault()</code> 用于取消浏览器对当前事件的默认行为。该方法生效的前提是，事件对象的 <code class="language-plaintext highlighter-rouge">cancelable</code> 属性为 <code class="language-plaintext highlighter-rouge">true</code>，如果为 <code class="language-plaintext highlighter-rouge">false</code>，调用该方法没有任何效果。注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用 <code class="language-plaintext highlighter-rouge">stopPropagation()</code> 或 <code class="language-plaintext highlighter-rouge">stopImmediatePropagation()</code>。</li> <li><code class="language-plaintext highlighter-rouge">Event.stopPropagation()</code> 用于阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</li> <li><code class="language-plaintext highlighter-rouge">Event.stopImmediatePropagation()</code> 阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比 <code class="language-plaintext highlighter-rouge">Event.stopPropagation()</code> 更彻底。如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了 <code class="language-plaintext highlighter-rouge">Event.stopImmediatePropagation()</code>，其他的监听函数就不会再执行了。</li> <li><code class="language-plaintext highlighter-rouge">Event.composedPath()</code> 返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div&gt;</span>
<span class="c1">//   &lt;p&gt;Hello&lt;/p&gt;</span>
<span class="c1">// &lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">composedPath</span><span class="p">());</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
<span class="c1">// [p, div, body, html, document, Window]</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">click</code> 事件的最底层节点是 <code class="language-plaintext highlighter-rouge">p</code>，向上依次是 <code class="language-plaintext highlighter-rouge">div</code>、<code class="language-plaintext highlighter-rouge">body</code>、<code class="language-plaintext highlighter-rouge">html</code>、<code class="language-plaintext highlighter-rouge">document</code>、<code class="language-plaintext highlighter-rouge">Window</code>。</p> <h2 id="四鼠标事件">四、鼠标事件</h2> <h3 id="41-鼠标事件的种类">4.1 鼠标事件的种类</h3> <p>鼠标事件主要有下面这些，所有事件都继承了 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 接口。</p> <h4 id="1点击事件">（1）点击事件</h4> <p>鼠标点击相关的有四个事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">mousedown</code>：按下鼠标键时触发。</li> <li><code class="language-plaintext highlighter-rouge">mouseup</code>：释放按下的鼠标键时触发。</li> <li><code class="language-plaintext highlighter-rouge">click</code>：按下鼠标（通常是按下主按钮）时触发。</li> <li><code class="language-plaintext highlighter-rouge">dblclick</code>：在同一个元素上双击鼠标时触发。</li> </ul> <p><code class="language-plaintext highlighter-rouge">click</code> 事件的触发顺序是：<code class="language-plaintext highlighter-rouge">mousedown</code> -&gt; <code class="language-plaintext highlighter-rouge">mouseup</code> -&gt; <code class="language-plaintext highlighter-rouge">click</code>。 <code class="language-plaintext highlighter-rouge">dblclick</code> 事件的触发顺序是：<code class="language-plaintext highlighter-rouge">mousedown</code> -&gt; <code class="language-plaintext highlighter-rouge">mouseup</code> -&gt; <code class="language-plaintext highlighter-rouge">click</code> -&gt; <code class="language-plaintext highlighter-rouge">dblclick</code>。</p> <h4 id="2移动事件">（2）移动事件</h4> <p>鼠标移动相关的有五个事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">mousemove</code>：当鼠标在一个<strong>节点内部移动</strong>时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li> <li><code class="language-plaintext highlighter-rouge">mouseenter</code>：鼠标<strong>进入</strong>一个节点时触发，进入子节点<strong>不会</strong>触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">mouseleave</code>：鼠标<strong>离开</strong>一个节点时触发，离开父节点<strong>不会</strong>触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">mouseover</code>：鼠标<strong>进入</strong>一个节点时触发，进入子节点会<strong>再次</strong>触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">mouseout</code>：鼠标<strong>离开</strong>一个节点时触发，离开父节点也会<strong>再次</strong>触发这个事件。</li> </ul> <h4 id="3其他事件">（3）其他事件</h4> <ul> <li><code class="language-plaintext highlighter-rouge">contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文”菜单键时触发。</li> <li><code class="language-plaintext highlighter-rouge">wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是 <code class="language-plaintext highlighter-rouge">WheelEvent</code> 接口。</li> </ul> <h3 id="42-mouseevent-接口">4.2 MouseEvent 接口</h3> <p><code class="language-plaintext highlighter-rouge">MouseEvent</code> 接口继承了 <code class="language-plaintext highlighter-rouge">Event</code> 接口，所以拥有 <code class="language-plaintext highlighter-rouge">Event</code> 的所有属性和方法，并且还提供鼠标独有的属性和方法。浏览器原生提供 <code class="language-plaintext highlighter-rouge">MouseEvent()</code> 构造函数，用于新建 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MouseEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">MouseEvent()</code> 构造函数接受两个参数。第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。除了 <code class="language-plaintext highlighter-rouge">Event</code> 接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p> <ul> <li><code class="language-plaintext highlighter-rouge">screenX</code>：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为 <code class="language-plaintext highlighter-rouge">0</code>，设置该属性不会移动鼠标。</li> <li><code class="language-plaintext highlighter-rouge">screenY</code>：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与 <code class="language-plaintext highlighter-rouge">screenX</code> 相同。</li> <li><code class="language-plaintext highlighter-rouge">clientX</code>：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为 <code class="language-plaintext highlighter-rouge">0</code>，设置该属性不会移动鼠标。</li> <li><code class="language-plaintext highlighter-rouge">clientY</code>：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与 <code class="language-plaintext highlighter-rouge">clientX</code> 相同。</li> <li><code class="language-plaintext highlighter-rouge">shiftKey</code>：布尔值，是否同时按下了 <code class="language-plaintext highlighter-rouge">Shift</code> 键，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>：布尔值，是否同时按下了 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">altKey</code>：布尔值，是否同时按下 <code class="language-plaintext highlighter-rouge">Alt</code> 键，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">metaKey</code>：布尔值，是否同时按下 <code class="language-plaintext highlighter-rouge">Meta</code> 键，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">button</code>：数值，表示按下了哪个鼠标按键，默认值为 <code class="language-plaintext highlighter-rouge">0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code class="language-plaintext highlighter-rouge">1</code> 表示按下辅助键（通常是鼠标的中间键），<code class="language-plaintext highlighter-rouge">2</code> 表示按下次要键（通常是鼠标的右键）。</li> <li><code class="language-plaintext highlighter-rouge">buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为 <code class="language-plaintext highlighter-rouge">0</code>（没有按下任何键）。<code class="language-plaintext highlighter-rouge">1</code>（二进制 <code class="language-plaintext highlighter-rouge">001</code>）表示按下主键（通常是左键），<code class="language-plaintext highlighter-rouge">2</code>（二进制 <code class="language-plaintext highlighter-rouge">010</code>）表示按下次要键（通常是右键），<code class="language-plaintext highlighter-rouge">4</code>（二进制 <code class="language-plaintext highlighter-rouge">100</code>）表示按下辅助键（通常是中间键）。因此，如果返回 <code class="language-plaintext highlighter-rouge">3</code>（二进制 <code class="language-plaintext highlighter-rouge">011</code>）就表示同时按下了左键和右键。</li> <li><code class="language-plaintext highlighter-rouge">relatedTarget</code>：节点对象，表示事件的相关节点，默认为 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">mouseenter</code> 和 <code class="language-plaintext highlighter-rouge">mouseover</code> 事件时，表示鼠标刚刚离开的那个元素节点；<code class="language-plaintext highlighter-rouge">mouseleave</code> 和 <code class="language-plaintext highlighter-rouge">mouseout</code> 事件时，表示鼠标正在进入的那个元素节点。</li> </ul> <h3 id="43-mouseevent-接口的实例属性">4.3 MouseEvent 接口的实例属性</h3> <h4 id="1mouseeventshiftkeymouseeventctrlkeymouseeventaltkeymouseeventmetakey">（1）MouseEvent.shiftKey，MouseEvent.ctrlKey，MouseEvent.altKey，MouseEvent.metaKey</h4> <p><code class="language-plaintext highlighter-rouge">MouseEvent.shiftKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.ctrlKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.altKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.metaKey</code> 这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">shiftKey</code> 属性：<code class="language-plaintext highlighter-rouge">Shift</code> 键</li> <li><code class="language-plaintext highlighter-rouge">ctrlKey</code> 属性：<code class="language-plaintext highlighter-rouge">Ctrl</code> 键</li> <li><code class="language-plaintext highlighter-rouge">altKey</code> 属性：<code class="language-plaintext highlighter-rouge">Alt</code> 键</li> <li><code class="language-plaintext highlighter-rouge">metaKey</code> 属性：<code class="language-plaintext highlighter-rouge">Meta</code> 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 <code class="language-plaintext highlighter-rouge">Windows</code> 键）</li> </ul> <h4 id="2mouseeventbuttonmouseeventbuttons">（2）MouseEvent.button，MouseEvent.buttons</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">MouseEvent.button</code> 属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。</p> <ul> <li><code class="language-plaintext highlighter-rouge">0</code>：按下主键（通常是左键），或者该事件没有初始化这个属性（比如 <code class="language-plaintext highlighter-rouge">mousemove</code> 事件）。</li> <li><code class="language-plaintext highlighter-rouge">1</code>：按下辅助键（通常是中键或者滚轮键）。</li> <li><code class="language-plaintext highlighter-rouge">2</code>：按下次键（通常是右键）。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">MouseEvent.buttons</code> 属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。</p> <ul> <li><code class="language-plaintext highlighter-rouge">1</code>：二进制为 <code class="language-plaintext highlighter-rouge">001</code>（十进制的 <code class="language-plaintext highlighter-rouge">1</code>），表示按下左键。</li> <li><code class="language-plaintext highlighter-rouge">2</code>：二进制为 <code class="language-plaintext highlighter-rouge">010</code>（十进制的 <code class="language-plaintext highlighter-rouge">2</code>），表示按下右键。</li> <li><code class="language-plaintext highlighter-rouge">4</code>：二进制为 <code class="language-plaintext highlighter-rouge">100</code>（十进制的 <code class="language-plaintext highlighter-rouge">4</code>），表示按下中键或滚轮键。</li> </ul> </li> </ul> <p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回 <code class="language-plaintext highlighter-rouge">3</code>（二进制为 <code class="language-plaintext highlighter-rouge">011</code>）。</p> <h4 id="3mouseeventscreenxmouseeventscreeny">（3）MouseEvent.screenX，MouseEvent.screenY</h4> <ul> <li><code class="language-plaintext highlighter-rouge">MouseEvent.screenX</code> 属性返回鼠标位置相对于<strong>屏幕左上角</strong>的水平坐标（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">MouseEvent.screenY</code> 属性返回垂直坐标。</li> </ul> <p>这两个都是只读属性。</p> <h4 id="4mouseeventclientxmouseeventclienty">（4）MouseEvent.clientX，MouseEvent.clientY</h4> <ul> <li><code class="language-plaintext highlighter-rouge">MouseEvent.clientX</code> 属性返回鼠标位置相对于<strong>浏览器窗口左上角</strong>的水平坐标（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">MouseEvent.clientY</code> 属性返回垂直坐标。</li> </ul> <p>这两个都是只读属性。</p> <h4 id="5mouseeventpagexmouseeventpagey">（5）MouseEvent.pageX，MouseEvent.pageY</h4> <ul> <li><code class="language-plaintext highlighter-rouge">MouseEvent.pageX</code> 属性返回鼠标位置与文档左侧边缘的距离（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">MouseEvent.pageY</code> 属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。</li> </ul> <p>这两个都是只读属性。</p> <h4 id="6mouseeventoffsetxmouseeventoffsety">（6）MouseEvent.offsetX，MouseEvent.offsetY</h4> <ul> <li><code class="language-plaintext highlighter-rouge">MouseEvent.offsetX</code> 属性返回鼠标位置与目标节点左侧的 <code class="language-plaintext highlighter-rouge">padding</code> 边缘的水平距离（单位像素）。</li> <li><code class="language-plaintext highlighter-rouge">MouseEvent.offsetY</code> 属性返回与目标节点上方的 <code class="language-plaintext highlighter-rouge">padding</code> 边缘的垂直距离。</li> </ul> <p>这两个都是只读属性。</p> <h4 id="7mouseeventmovementxmouseeventmovementy">（7）MouseEvent.movementX，MouseEvent.movementY</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">MouseEvent.movementX</code> 属性返回当前位置与上一个 <code class="language-plaintext highlighter-rouge">mousemove</code> 事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">currentEvent</span><span class="p">.</span><span class="nx">movementX</span> <span class="o">=</span> <span class="nx">currentEvent</span><span class="p">.</span><span class="nx">screenX</span> <span class="o">-</span> <span class="nx">previousEvent</span><span class="p">.</span><span class="nx">screenX</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">MouseEvent.movementY</code> 属性返回当前位置与上一个 <code class="language-plaintext highlighter-rouge">mousemove</code> 事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">currentEvent</span><span class="p">.</span><span class="nx">movementY</span> <span class="o">=</span> <span class="nx">currentEvent</span><span class="p">.</span><span class="nx">screenY</span> <span class="o">-</span> <span class="nx">previousEvent</span><span class="p">.</span><span class="nx">screenY</span><span class="err">。</span>
</code></pre></div> </div> </li> </ul> <h4 id="8mouseeventrelatedtarget">（8）MouseEvent.relatedTarget</h4> <p><code class="language-plaintext highlighter-rouge">MouseEvent.relatedTarget</code> 属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。该属性只读。</p> <h3 id="44-mouseevent-接口的实例方法">4.4 MouseEvent 接口的实例方法</h3> <p><code class="language-plaintext highlighter-rouge">MouseEvent.getModifierState(key)</code> 返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示功能键的字符串。</p> <h3 id="45-wheelevent-接口">4.5 WheelEvent 接口</h3> <h4 id="1概述">（1）概述</h4> <p><code class="language-plaintext highlighter-rouge">WheelEvent</code> 接口继承了 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 实例，代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有 <code class="language-plaintext highlighter-rouge">wheel</code> 事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">WheelEvent()</code> 构造函数，用来生成 <code class="language-plaintext highlighter-rouge">WheelEvent</code> 实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">wheelEvent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WheelEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">WheelEvent()</code> 构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是 <code class="language-plaintext highlighter-rouge">wheel</code>。第二个参数是事件的配置对象。该对象的属性除了 <code class="language-plaintext highlighter-rouge">Event</code>、<code class="language-plaintext highlighter-rouge">UIEvent</code> 的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p> <ul> <li><code class="language-plaintext highlighter-rouge">deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 <code class="language-plaintext highlighter-rouge">0.0</code>。</li> <li><code class="language-plaintext highlighter-rouge">deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 <code class="language-plaintext highlighter-rouge">0.0</code>。</li> <li><code class="language-plaintext highlighter-rouge">deltaZ</code>：数值，表示滚轮的 <code class="language-plaintext highlighter-rouge">Z</code> 轴滚动量，默认值是 <code class="language-plaintext highlighter-rouge">0.0</code>。</li> <li><code class="language-plaintext highlighter-rouge">deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code class="language-plaintext highlighter-rouge">0</code> 表示滚动单位为像素，<code class="language-plaintext highlighter-rouge">1</code> 表示单位为行，<code class="language-plaintext highlighter-rouge">2</code> 表示单位为页，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> </ul> <h4 id="2实例属性">（2）实例属性</h4> <p><code class="language-plaintext highlighter-rouge">WheelEvent</code> 事件实例除了具有 <code class="language-plaintext highlighter-rouge">Event</code> 和 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li> <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li> <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaZ</code>：数值，表示滚轮的 <code class="language-plaintext highlighter-rouge">Z</code> 轴滚动量。</li> <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code class="language-plaintext highlighter-rouge">0</code> 是像素，<code class="language-plaintext highlighter-rouge">1</code> 是行，<code class="language-plaintext highlighter-rouge">2</code> 是页。</li> </ul> <p>上面的属性都是只读属性。</p> <h2 id="五键盘事件">五、键盘事件</h2> <h3 id="51-键盘事件的种类">5.1 键盘事件的种类</h3> <p>键盘事件由用户击打键盘触发，主要有 <code class="language-plaintext highlighter-rouge">keydown</code>、<code class="language-plaintext highlighter-rouge">keypress</code>、<code class="language-plaintext highlighter-rouge">keyup</code> 三个事件，它们都继承了 <code class="language-plaintext highlighter-rouge">KeyboardEvent</code> 接口。</p> <ul> <li><code class="language-plaintext highlighter-rouge">keydown</code>：按下键盘时触发。</li> <li><code class="language-plaintext highlighter-rouge">keypress</code>：按下有值的键时触发，即按下 <code class="language-plaintext highlighter-rouge">Shift</code>、<code class="language-plaintext highlighter-rouge">Ctrl</code>、<code class="language-plaintext highlighter-rouge">Alt</code>、<code class="language-plaintext highlighter-rouge">Meta</code> 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发 <code class="language-plaintext highlighter-rouge">keydown</code> 事件，再触发这个事件。</li> <li><code class="language-plaintext highlighter-rouge">keyup</code>：松开键盘时触发该事件。</li> </ul> <p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p> <ol> <li><code class="language-plaintext highlighter-rouge">keydown</code></li> <li><code class="language-plaintext highlighter-rouge">keypress</code></li> <li><code class="language-plaintext highlighter-rouge">keydown</code></li> <li><code class="language-plaintext highlighter-rouge">keypress</code></li> <li>…（重复以上过程）</li> <li><code class="language-plaintext highlighter-rouge">keyup</code></li> </ol> <h3 id="52-keyboardevent-接口概述">5.2 KeyboardEvent 接口概述</h3> <p><code class="language-plaintext highlighter-rouge">KeyboardEvent</code> 接口用来描述用户与键盘的互动。这个接口继承了 <code class="language-plaintext highlighter-rouge">Event</code> 接口，并且定义了自己的实例属性和实例方法。</p> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">KeyboardEvent</code> 构造函数，用来新建键盘事件的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">KeyboardEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">KeyboardEvent</code> 构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了 <code class="language-plaintext highlighter-rouge">Event</code> 接口提供的属性，还可以配置以下字段，它们都是可选。</p> <ul> <li><code class="language-plaintext highlighter-rouge">key</code>：字符串，当前按下的键，默认为空字符串。</li> <li><code class="language-plaintext highlighter-rouge">code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li> <li><code class="language-plaintext highlighter-rouge">repeat</code>：布尔值，是否重复按键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">location</code>：整数，当前按下的键的位置，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>：布尔值，是否按下 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">shiftKey</code>：布尔值，是否按下 <code class="language-plaintext highlighter-rouge">Shift</code> 键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">altKey</code>：布尔值，是否按下 <code class="language-plaintext highlighter-rouge">Alt</code> 键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">metaKey</code>：布尔值，是否按下 <code class="language-plaintext highlighter-rouge">Meta</code> 键，默认为 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <h3 id="53-keyboardevent-的实例属性">5.3 KeyboardEvent 的实例属性</h3> <ul> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.key</code> 属性返回一个字符串，表示按下的键名。该属性只读。</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.code</code> 属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.repeat</code> 返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发 <code class="language-plaintext highlighter-rouge">keydown</code> 和 <code class="language-plaintext highlighter-rouge">keypress</code> 事件，直到用户松开手为止。</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.location</code> 属性返回一个整数，表示按下的键处在键盘的哪个区域。它可能取以下值。</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.shiftKey</code> 表示是否按下 <code class="language-plaintext highlighter-rouge">Shift</code> 键</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.ctrlKey</code> 表示是否按下 <code class="language-plaintext highlighter-rouge">Ctrl</code> 键</li> <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.altKey</code> 表示是否按下 <code class="language-plaintext highlighter-rouge">Alt</code> 键</li> <li> <p><code class="language-plaintext highlighter-rouge">KeyboardEvent.metaKey</code> 表示是否按下 <code class="language-plaintext highlighter-rouge">meta</code> 键（Mac 系统是一个四瓣的小花，Windows 系统是 <code class="language-plaintext highlighter-rouge">windows</code> 键）</p> <ul> <li><code class="language-plaintext highlighter-rouge">0</code>：处在键盘的主区域，或者无法判断处于哪个区域。</li> <li><code class="language-plaintext highlighter-rouge">1</code>：处在键盘的左侧，只适用那些有两个位置的键（比如 <code class="language-plaintext highlighter-rouge">Ctrl</code> 和 <code class="language-plaintext highlighter-rouge">Shift</code> 键）。</li> <li><code class="language-plaintext highlighter-rouge">2</code>：处在键盘的右侧，只适用那些有两个位置的键（比如 <code class="language-plaintext highlighter-rouge">Ctrl</code> 和 <code class="language-plaintext highlighter-rouge">Shift</code> 键）。</li> <li><code class="language-plaintext highlighter-rouge">3</code>：处在数字小键盘。</li> </ul> </li> </ul> <h3 id="53-keyboardevent-的实例方法">5.3 KeyboardEvent 的实例方法</h3> <p><code class="language-plaintext highlighter-rouge">KeyboardEvent.getModifierState(key)</code> 返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Shift</code>：<code class="language-plaintext highlighter-rouge">Shift</code> 键</li> <li><code class="language-plaintext highlighter-rouge">Control</code>：<code class="language-plaintext highlighter-rouge">Ctrl</code> 键</li> <li><code class="language-plaintext highlighter-rouge">Alt</code>：<code class="language-plaintext highlighter-rouge">Alt</code> 键</li> <li><code class="language-plaintext highlighter-rouge">Meta</code>：<code class="language-plaintext highlighter-rouge">Meta</code> 键</li> <li><code class="language-plaintext highlighter-rouge">CapsLock</code>：大写锁定键</li> <li><code class="language-plaintext highlighter-rouge">NumLock</code>：数字键盘开关键</li> </ul> <h2 id="六进度事件">六、进度事件</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="七表单事件">七、表单事件</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="八触摸事件">八、触摸事件</h2> <h3 id="1-触摸操作概述">1. 触摸操作概述</h3> <p>浏览器的触摸 API 由三个部分组成。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Touch</code>：一个触摸点。<code class="language-plaintext highlighter-rouge">Touch</code> 接口的实例对象表示触摸点，包括位置、大小、形状、压力、目标元素等属性。</li> <li><code class="language-plaintext highlighter-rouge">TouchList</code>：多个触摸点的集合。有时，触摸动作由多个触摸点组成，多个触摸点的集合由 <code class="language-plaintext highlighter-rouge">TouchList</code> 接口的实例对象表示。</li> <li><code class="language-plaintext highlighter-rouge">TouchEvent</code>：触摸引发的事件实例。<code class="language-plaintext highlighter-rouge">TouchEvent</code> 接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</li> </ul> <p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用 <code class="language-plaintext highlighter-rouge">event.preventDefault()</code> 阻止发出鼠标事件。</p> <h3 id="2-touch-接口">2. Touch 接口</h3> <h4 id="21-touch-接口概述">2.1 Touch 接口概述</h4> <p>Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。Touch 构造函数用来生成 Touch 实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">touch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Touch</span><span class="p">(</span><span class="nx">touchOptions</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">touchOptions</code> 配置对象有以下属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li> <li><code class="language-plaintext highlighter-rouge">target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li> <li><code class="language-plaintext highlighter-rouge">screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 <code class="language-plaintext highlighter-rouge">X</code> 轴半径，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 <code class="language-plaintext highlighter-rouge">Y</code> 轴半径，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">90</code> 度之间，默认值为 <code class="language-plaintext highlighter-rouge">0</code>。</li> <li><code class="language-plaintext highlighter-rouge">force</code>：可选，类型为数值，范围在 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">1</code> 之间，表示触摸压力。<code class="language-plaintext highlighter-rouge">0</code> 代表没有压力，<code class="language-plaintext highlighter-rouge">1</code> 代表硬件所能识别的最大压力，默认为 <code class="language-plaintext highlighter-rouge">0</code>。</li> </ul> <h4 id="22-touch-接口的实例属性">2.2 Touch 接口的实例属性</h4> <h5 id="1touchidentifier">（1）Touch.identifier</h5> <p><code class="language-plaintext highlighter-rouge">Touch.identifier</code> 属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p> <h5 id="2touchscreenxtouchscreenytouchclientxtouchclientypagexpagey">（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY</h5> <ul> <li><code class="language-plaintext highlighter-rouge">Touch.screenX</code> 属性和 <code class="language-plaintext highlighter-rouge">Touch.screenY</code> 属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</li> <li><code class="language-plaintext highlighter-rouge">Touch.clientX</code> 属性和 <code class="language-plaintext highlighter-rouge">Touch.clientY</code> 属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</li> <li><code class="language-plaintext highlighter-rouge">Touch.pageX</code> 属性和 <code class="language-plaintext highlighter-rouge">Touch.pageY</code> 属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</li> </ul> <h5 id="3touchradiusxtouchradiusytouchrotationangle">（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle</h5> <ul> <li><code class="language-plaintext highlighter-rouge">Touch.radiusX</code> 属性和 <code class="language-plaintext highlighter-rouge">Touch.radiusY</code> 属性，分别返回触摸点周围受到影响的椭圆范围的 <code class="language-plaintext highlighter-rouge">X</code> 轴半径和 <code class="language-plaintext highlighter-rouge">Y</code> 轴半径，单位为像素。乘以 <code class="language-plaintext highlighter-rouge">2</code> 就可以得到触摸范围的宽度和高度。</li> <li><code class="language-plaintext highlighter-rouge">Touch.rotationAngle</code> 属性表示触摸区域的椭圆的旋转角度，单位为度数，在 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">90</code> 度之间。</li> </ul> <p>上面这三个属性共同定义了用户与屏幕接触的区域，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p> <h5 id="4touchforce">（4）Touch.force</h5> <p><code class="language-plaintext highlighter-rouge">Touch.force</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">1</code> 之间的数值，表示触摸压力。<code class="language-plaintext highlighter-rouge">0</code> 代表没有压力，<code class="language-plaintext highlighter-rouge">1</code> 代表硬件所能识别的最大压力。</p> <h5 id="5touchtarget">（5）Touch.target</h5> <p><code class="language-plaintext highlighter-rouge">Touch.target</code> 属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</p> <h3 id="3-touchlist-接口">3. TouchList 接口</h3> <p><code class="language-plaintext highlighter-rouge">TouchList</code> 接口表示一组触摸点的集合。它的实例是一个类似数组的对象，成员是 <code class="language-plaintext highlighter-rouge">Touch</code> 的实例对象，表示所有触摸点。用户用三根手指触摸，产生的 <code class="language-plaintext highlighter-rouge">TouchList</code> 实例就会包含三个成员，每根手指的触摸点对应一个 <code class="language-plaintext highlighter-rouge">Touch</code> 实例对象。</p> <p>它的实例主要通过触摸事件的 <code class="language-plaintext highlighter-rouge">TouchEvent.touches</code>、<code class="language-plaintext highlighter-rouge">TouchEvent.changedTouches</code>、<code class="language-plaintext highlighter-rouge">TouchEvent.targetTouches</code> 这几个属性获取。</p> <p>它的实例属性和实例方法只有两个。</p> <ul> <li><code class="language-plaintext highlighter-rouge">TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li> <li><code class="language-plaintext highlighter-rouge">TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li> </ul> <h3 id="4-touchevent-接口">4. TouchEvent 接口</h3> <p><code class="language-plaintext highlighter-rouge">TouchEvent</code> 接口继承了 <code class="language-plaintext highlighter-rouge">Event</code> 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。</p> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">TouchEvent()</code> 构造函数，用来生成触摸事件的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">TouchEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">TouchEvent()</code> 构造函数的第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了 <code class="language-plaintext highlighter-rouge">Event</code> 接口的配置属性，该接口还有一些自己的配置属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">touches</code>：<code class="language-plaintext highlighter-rouge">TouchList</code> 实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组 <code class="language-plaintext highlighter-rouge">[]</code>。</li> <li><code class="language-plaintext highlighter-rouge">targetTouches</code>：<code class="language-plaintext highlighter-rouge">TouchList</code> 实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组 <code class="language-plaintext highlighter-rouge">[]</code>。</li> <li><code class="language-plaintext highlighter-rouge">changedTouches</code>：<code class="language-plaintext highlighter-rouge">TouchList</code> 实例，代表本次触摸事件的相关触摸点，默认值是一个空数组 <code class="language-plaintext highlighter-rouge">[]</code>。</li> <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为 <code class="language-plaintext highlighter-rouge">false</code>。</li> </ul> <p><code class="language-plaintext highlighter-rouge">TouchEvent</code> 接口的实例具有 <code class="language-plaintext highlighter-rouge">Event</code> 实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。</p> <h4 id="1toucheventtouches">（1）TouchEvent.touches</h4> <p><code class="language-plaintext highlighter-rouge">TouchEvent.touches</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">TouchList</code> 实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点。</p> <h4 id="2toucheventtargettouches">（2）TouchEvent.targetTouches</h4> <p><code class="language-plaintext highlighter-rouge">TouchEvent.targetTouches</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">TouchList</code> 实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。</p> <h4 id="3toucheventchangedtouches">（3）TouchEvent.changedTouches</h4> <p><code class="language-plaintext highlighter-rouge">TouchEvent.changedTouches</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">TouchList</code> 实例，成员是一组 <code class="language-plaintext highlighter-rouge">Touch</code> 实例对象，表示本次触摸事件的相关触摸点。</p> <p>对于不同的时间，该属性的含义有所不同。</p> <ul> <li><code class="language-plaintext highlighter-rouge">touchstart</code> 事件：被激活的触摸点</li> <li><code class="language-plaintext highlighter-rouge">touchmove</code> 事件：发生变化的触摸点</li> <li><code class="language-plaintext highlighter-rouge">touchend</code> 事件：消失的触摸点（即不再被触碰的点）</li> </ul> <h4 id="4toucheventaltkeytoucheventctrlkeytoucheventshiftkeytoucheventmetakey">（4）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey</h4> <ul> <li><code class="language-plaintext highlighter-rouge">TouchEvent.altKey</code>：布尔值，表示触摸时是否按下了 Alt 键。</li> <li><code class="language-plaintext highlighter-rouge">TouchEvent.ctrlKey</code>：布尔值，表示触摸时是否按下了 Ctrl 键。</li> <li><code class="language-plaintext highlighter-rouge">TouchEvent.shiftKey</code>：布尔值：表示触摸时是否按下了 Shift 键。</li> <li><code class="language-plaintext highlighter-rouge">TouchEvent.metaKey</code>：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</li> </ul> <h3 id="5-触摸事件的种类">5. 触摸事件的种类</h3> <p>触摸引发的事件，有以下几种。可以通过 <code class="language-plaintext highlighter-rouge">TouchEvent.type</code> 属性，查看到底发生的是哪一种事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">touchstart</code>：用户开始触摸时触发，它的 <code class="language-plaintext highlighter-rouge">target</code> 属性返回发生触摸的元素节点。</li> <li><code class="language-plaintext highlighter-rouge">touchmove</code>：用户移动触摸点时触发，它的 <code class="language-plaintext highlighter-rouge">target</code> 属性与 <code class="language-plaintext highlighter-rouge">touchstart</code> 事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li> <li><code class="language-plaintext highlighter-rouge">touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的 <code class="language-plaintext highlighter-rouge">target</code> 属性与 <code class="language-plaintext highlighter-rouge">touchstart</code> 事件一致的，就是开始触摸时所在的元素节点。它的 <code class="language-plaintext highlighter-rouge">changedTouches</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">TouchList</code> 实例，包含所有不再触摸的触摸点（即 <code class="language-plaintext highlighter-rouge">Touch</code> 实例对象）。</li> <li><code class="language-plaintext highlighter-rouge">touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li> </ul> <h2 id="九拖拉事件">九、拖拉事件</h2> <h3 id="1-拖拉事件的种类">1. 拖拉事件的种类</h3> <p>拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p> <p>拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都可以直接拖拉。为了让元素节点可拖拉，可以将该节点的 <code class="language-plaintext highlighter-rouge">draggable</code> 属性设为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">draggable=</span><span class="s">"true"</span><span class="nt">&gt;</span>
  此区域可拖拉
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div> <p>注意，一旦某个元素节点的 <code class="language-plaintext highlighter-rouge">draggable</code> 属性设为 <code class="language-plaintext highlighter-rouge">true</code>，就无法再用鼠标选中该节点内部的文字或子节点了。</p> <p>当元素节点或选中的文本被拖拉时，会持续触发拖拉事件。</p> <ul> <li><code class="language-plaintext highlighter-rouge">drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li> <li><code class="language-plaintext highlighter-rouge">dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的 <code class="language-plaintext highlighter-rouge">target</code> 属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li> <li><code class="language-plaintext highlighter-rouge">dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的 <code class="language-plaintext highlighter-rouge">target</code> 属性是被拖拉的节点。它与 <code class="language-plaintext highlighter-rouge">dragstart</code> 事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code class="language-plaintext highlighter-rouge">dragend</code> 事件总是会触发。</li> <li><code class="language-plaintext highlighter-rouge">dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的 <code class="language-plaintext highlighter-rouge">target</code> 属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（<code class="language-plaintext highlighter-rouge">drop</code>）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li> <li><code class="language-plaintext highlighter-rouge">dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的 <code class="language-plaintext highlighter-rouge">target</code> 属性是当前节点。<code class="language-plaintext highlighter-rouge">dragenter</code> 事件在进入该节点时触发，只要没有离开这个节点，<code class="language-plaintext highlighter-rouge">dragover</code> 事件会持续触发。</li> <li><code class="language-plaintext highlighter-rouge">dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的 <code class="language-plaintext highlighter-rouge">target</code> 属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li> <li><code class="language-plaintext highlighter-rouge">drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。如果当前节点不允许 <code class="language-plaintext highlighter-rouge">drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li> </ul> <p>关于拖拉事件，有以下几个注意点。</p> <ul> <li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li> <li>将文件从操作系统拖拉进浏览器，不会触发 <code class="language-plaintext highlighter-rouge">dragstart</code> 和 <code class="language-plaintext highlighter-rouge">dragend</code> 事件。</li> <li><code class="language-plaintext highlighter-rouge">dragenter</code> 和 <code class="language-plaintext highlighter-rouge">dragover</code> 事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">ondragover</span><span class="o">=</span><span class="dl">"</span><span class="s2">return false</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">div</span> <span class="nx">ondragover</span><span class="o">=</span><span class="dl">"</span><span class="s2">event.preventDefault()</span><span class="dl">"</span><span class="o">&gt;</span>
</code></pre></div></div> <p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在 <code class="language-plaintext highlighter-rouge">div</code> 节点上放下被拖拉的节点。</p> <h3 id="2-dragevent-接口">2. DragEvent 接口</h3> <p>拖拉事件继承了 <code class="language-plaintext highlighter-rouge">DragEvent</code> 接口，这个接口又继承了 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 接口和 <code class="language-plaintext highlighter-rouge">Event</code> 接口。<code class="language-plaintext highlighter-rouge">DragEvent()</code> 构造函数用来生成拖拉事件的实例对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">DragEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">DragEvent()</code> 构造函数的第一个参数是字符串，表示事件的类型，该参数必须；第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。配置对象除了接受 <code class="language-plaintext highlighter-rouge">MouseEvent</code> 接口和 <code class="language-plaintext highlighter-rouge">Event</code> 接口的配置属性，还可以设置 <code class="language-plaintext highlighter-rouge">dataTransfer</code> 属性要么是 <code class="language-plaintext highlighter-rouge">null</code>，要么是一个 <code class="language-plaintext highlighter-rouge">DataTransfer</code> 接口的实例。</p> <h3 id="3-datatransfer-接口概述">3. DataTransfer 接口概述</h3> <p>所有拖拉事件的实例都有 <code class="language-plaintext highlighter-rouge">DragEvent.dataTransfer</code> 属性，用来读写需要传递的数据。这个属性的值是一个 <code class="language-plaintext highlighter-rouge">DataTransfer</code> 接口的实例。<code class="language-plaintext highlighter-rouge">DataTransfer()</code> 构造函数用来生成 <code class="language-plaintext highlighter-rouge">DataTransfer</code> 实例对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">dataTrans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataTransfer</span><span class="p">();</span>
</code></pre></div></div> <p>拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如 <code class="language-plaintext highlighter-rouge">text/plain</code>、<code class="language-plaintext highlighter-rouge">image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p> <p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过 <code class="language-plaintext highlighter-rouge">dragenter</code> 和 <code class="language-plaintext highlighter-rouge">dragover</code> 事件的监听函数，检查数据类型，以确定是否允许放下（<code class="language-plaintext highlighter-rouge">drop</code>）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为 <code class="language-plaintext highlighter-rouge">text/uri-list</code>。</p> <p>发生 <code class="language-plaintext highlighter-rouge">drop</code> 事件时，监听函数取出拖拉的数据，对其进行处理。</p> <h3 id="4-datatransfer-的实例属性">4. DataTransfer 的实例属性</h3> <h4 id="41-datatransferdropeffect">4.1 DataTransfer.dropEffect</h4> <p><code class="language-plaintext highlighter-rouge">DataTransfer.dropEffect</code> 属性用来设置放下（<code class="language-plaintext highlighter-rouge">drop</code>）被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">copy</code>：复制被拖拉的节点</li> <li><code class="language-plaintext highlighter-rouge">move</code>：移动被拖拉的节点</li> <li><code class="language-plaintext highlighter-rouge">link</code>：创建指向被拖拉的节点的链接</li> <li><code class="language-plaintext highlighter-rouge">none</code>：无法放下被拖拉的节点</li> </ul> <p><code class="language-plaintext highlighter-rouge">dropEffect</code> 属性一般在 <code class="language-plaintext highlighter-rouge">dragenter</code> 和 <code class="language-plaintext highlighter-rouge">dragover</code> 事件的监听函数中设置，对于 <code class="language-plaintext highlighter-rouge">dragstart</code>、<code class="language-plaintext highlighter-rouge">drag</code>、<code class="language-plaintext highlighter-rouge">dragleave</code> 这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。</p> <h4 id="42-datatransfereffectallowed">4.2 DataTransfer.effectAllowed</h4> <p><code class="language-plaintext highlighter-rouge">DataTransfer.effectAllowed</code> 属性设置本次拖拉中允许的效果。它可能取下面的值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">copy</code>：复制被拖拉的节点</li> <li><code class="language-plaintext highlighter-rouge">move</code>：移动被拖拉的节点</li> <li><code class="language-plaintext highlighter-rouge">link</code>：创建指向被拖拉节点的链接</li> <li><code class="language-plaintext highlighter-rouge">none</code>：无法放下被拖拉的节点</li> <li><code class="language-plaintext highlighter-rouge">copyLink</code>：允许 <code class="language-plaintext highlighter-rouge">copy</code> 或 <code class="language-plaintext highlighter-rouge">link</code></li> <li><code class="language-plaintext highlighter-rouge">copyMove</code>：允许 <code class="language-plaintext highlighter-rouge">copy</code> 或 <code class="language-plaintext highlighter-rouge">move</code></li> <li><code class="language-plaintext highlighter-rouge">linkMove</code>：允许 <code class="language-plaintext highlighter-rouge">link</code> 或 <code class="language-plaintext highlighter-rouge">move</code></li> <li><code class="language-plaintext highlighter-rouge">all</code>：允许所有效果</li> <li><code class="language-plaintext highlighter-rouge">uninitialized</code>：默认值，等同于 <code class="language-plaintext highlighter-rouge">all</code></li> </ul> <p>如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。</p> <p>这个属性与 <code class="language-plaintext highlighter-rouge">dropEffect</code> 属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。</p> <p><code class="language-plaintext highlighter-rouge">dragstart</code> 事件的监听函数，可以用来设置这个属性。其他事件的监听函数里面设置这个属性是无效的。</p> <p>只要 <code class="language-plaintext highlighter-rouge">dropEffect</code> 属性和 <code class="language-plaintext highlighter-rouge">effectAllowed</code> 属性之中，有一个为 <code class="language-plaintext highlighter-rouge">none</code>，就无法在目标节点上完成 <code class="language-plaintext highlighter-rouge">drop</code> 操作。</p> <h4 id="43-datatransferfiles">4.3 DataTransfer.files</h4> <p><code class="language-plaintext highlighter-rouge">DataTransfer.files</code> 属性是一个 <code class="language-plaintext highlighter-rouge">FileList</code> 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 <code class="language-plaintext highlighter-rouge">FileList</code> 对象。</p> <h4 id="44-datatransfertypes">4.4 DataTransfer.types</h4> <p><code class="language-plaintext highlighter-rouge">DataTransfer.types</code> 属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是 <code class="language-plaintext highlighter-rouge">text/plain</code>。</p> <h4 id="45-datatransferitems">4.5 DataTransfer.items</h4> <p><code class="language-plaintext highlighter-rouge">DataTransfer.items</code> 属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。</p> <p><code class="language-plaintext highlighter-rouge">DataTransferItemList</code> 实例具有以下的属性和方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">length</code>：返回成员的数量</li> <li><code class="language-plaintext highlighter-rouge">add(data, type)</code>：增加一个指定内容和类型（比如 <code class="language-plaintext highlighter-rouge">text/html</code> 和 <code class="language-plaintext highlighter-rouge">text/plain</code>）的字符串作为成员</li> <li><code class="language-plaintext highlighter-rouge">add(file)</code>：<code class="language-plaintext highlighter-rouge">add</code> 方法的另一种用法，增加一个文件作为成员</li> <li><code class="language-plaintext highlighter-rouge">remove(index)</code>：移除指定位置的成员</li> <li><code class="language-plaintext highlighter-rouge">clear()</code>：移除所有的成员</li> </ul> <p>DataTransferItem 实例具有以下的属性和方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">kind</code>：返回成员的种类（<code class="language-plaintext highlighter-rouge">string</code> 还是 <code class="language-plaintext highlighter-rouge">file</code>）。</li> <li><code class="language-plaintext highlighter-rouge">type</code>：返回成员的类型（通常是 MIME 值）。</li> <li><code class="language-plaintext highlighter-rouge">getAsFile()</code>：如果被拖拉是文件，返回该文件，否则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">getAsString(callback)</code>：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</li> </ul> <h3 id="5-datatransfer-的实例方法">5. DataTransfer 的实例方法</h3> <h4 id="51-datatransfersetdata">5.1 DataTransfer.setData()</h4> <p><code class="language-plaintext highlighter-rouge">DataTransfer.setData()</code> 用来设置拖拉事件所带有的数据。该方法没有返回值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nf">setData</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
</code></pre></div></div> <p>该方法接受两个参数，都是字符串。第一个参数表示数据类型（比如 <code class="language-plaintext highlighter-rouge">text/plain</code>），第二个参数是具体数据。如果指定类型的数据在 <code class="language-plaintext highlighter-rouge">dataTransfer</code> 属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。</p> <p>如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到 <code class="language-plaintext highlighter-rouge">dataTransfer</code> 属性，不用手动指定。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">draggable=</span><span class="s">"true"</span><span class="nt">&gt;</span>
  aaa
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div> <p>上面代码中，拖拉这个 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> 元素会自动带上文本数据 <code class="language-plaintext highlighter-rouge">aaa</code>。</p> <p>使用 <code class="language-plaintext highlighter-rouge">setData()</code> 可以替换到原有数据。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span>
  <span class="na">draggable=</span><span class="s">"true"</span>
  <span class="na">ondragstart=</span><span class="s">"event.dataTransfer.setData('text/plain', 'bbb')"</span>
<span class="nt">&gt;</span>
  aaa
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div> <p>上面代码中，拖拉数据实际上是 <code class="language-plaintext highlighter-rouge">bbb</code>，而不是 <code class="language-plaintext highlighter-rouge">aaa</code>。</p> <h4 id="52-datatransfergetdata">5.2 DataTransfer.getData()</h4> <p><code class="language-plaintext highlighter-rouge">DataTransfer.getData(format)</code> 接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用 <code class="language-plaintext highlighter-rouge">setData</code> 方法添加的数据）。通常只有 <code class="language-plaintext highlighter-rouge">drop</code> 事件触发后，才能取出数据。</p> <p><code class="language-plaintext highlighter-rouge">getData()</code> 返回的是一个字符串，如果其中包含多项数据，必须手动解析。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">onDrop</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nf">getData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
  <span class="nx">event</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doDrop</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">lines</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nf">getData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">).</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">link</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">link</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">line</span><span class="p">;</span>
    <span class="nx">link</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">line</span><span class="p">;</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">link</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">event</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">getData()</code> 返回的是一组链接，必须自行解析。</p> <p>类型值指定为 URL，可以取出第一个有效链接。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">link</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nf">getData</span><span class="p">(</span><span class="dl">'</span><span class="s1">URL</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>下面的例子是从多种类型的数据里面取出数据。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doDrop</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">types</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">types</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">supportedTypes</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">];</span>
  <span class="nx">types</span> <span class="o">=</span> <span class="nx">supportedTypes</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="nx">types</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">});</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nf">getData</span><span class="p">(</span><span class="nx">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="nx">event</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="53-datatransfercleardata">5.3 DataTransfer.clearData()</h4> <p><code class="language-plaintext highlighter-rouge">DataTransfer.clearData(format)</code> 接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。</p> <ul> <li>该方法不会移除拖拉的文件，因此调用该方法后，<code class="language-plaintext highlighter-rouge">DataTransfer.types</code> 属性可能依然会返回 Files 类型（前提是存在文件拖拉）。</li> <li>该方法只能在 <code class="language-plaintext highlighter-rouge">dragstart</code> 事件的监听函数之中使用，因为这是拖拉操作的数据唯一可写的时机。</li> </ul> <h4 id="54-datatransfersetdragimage">5.4 DataTransfer.setDragImage()</h4> <p>拖动过程中（<code class="language-plaintext highlighter-rouge">dragstart</code> 事件触发后），浏览器会显示一张图片跟随鼠标一起移动，表示被拖动的节点。这张图片是自动创造的，通常显示为被拖动节点的外观，不需要自己动手设置。</p> <p><code class="language-plaintext highlighter-rouge">DataTransfer.setDragImage(imgElement, xOffset, yOffset)</code> 可以自定义这张图片。它接受三个参数。第一个是 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 节点或者 <code class="language-plaintext highlighter-rouge">&lt;canvas&gt;</code> 节点，如果省略或为 <code class="language-plaintext highlighter-rouge">null</code>，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和纵坐标。</p> <h2 id="十其他常见事件">十、其他常见事件</h2> <h3 id="1-资源事件">1. 资源事件</h3> <p>beforeunload 事件 unload 事件 load 事件，error 事件</p> <h3 id="2-session-历史事件">2. session 历史事件</h3> <p>pageshow 事件，pagehide 事件 popstate 事件 hashchange 事件</p> <h3 id="3-网页状态事件">3. 网页状态事件</h3> <p>DOMContentLoaded 事件 readystatechange 事件</p> <h3 id="4-窗口事件">4. 窗口事件</h3> <p>scroll 事件 resize 事件 fullscreenchange 事件，fullscreenerror 事件</p> <h3 id="5-剪贴板事件">5. 剪贴板事件</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h3 id="6-焦点事件">6. 焦点事件</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h3 id="7-customevent-接口">7. CustomEvent 接口</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十一globaleventhandlers-接口">十一、GlobalEventHandlers 接口</h2> <ul> <li>GlobalEventHandlers.onabort</li> <li>GlobalEventHandlers.onerror</li> <li>GlobalEventHandlers.onload</li> <li>GlobalEventHandlers.onloadstart</li> <li>GlobalEventHandlers.onfocus</li> <li>GlobalEventHandlers.onblur</li> <li>GlobalEventHandlers.onscroll</li> <li>GlobalEventHandlers.oncontextmenu</li> <li>GlobalEventHandlers.onshow</li> </ul> <h3 id="其他的事件属性">其他的事件属性</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十二参考">十二、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/events/">JavaScript 教程 - 事件</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 事件》一章中部分知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/async/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-12T00:00:00+00:00</published><updated>2024-10-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/async</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/async/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/async/">《JavaScript 教程 - 异步操作》</a>一章中部分知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一概述">一、概述</h2> <h3 id="11-单线程模型">1.1 单线程模型</h3> <p>JavaScript 采用单线程设计，原因是不想让浏览器变得太复杂。多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这无疑增加了复杂性。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征。</p> <p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p> <h3 id="12-同步任务和异步任务">1.2 同步任务和异步任务</h3> <p>程序里面所有的任务，可以分成两类：<strong>同步任务</strong>（synchronous）和<strong>异步任务</strong>（asynchronous）。</p> <ul> <li>同步任务是那些没有被引擎挂起、在<strong>主线程</strong>上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</li> <li>异步任务是那些被引擎放在一边，不进入主线程、而进入<strong>任务队列</strong>的任务。只有引擎认为某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入主线程执行。</li> </ul> <h3 id="13-任务队列和事件循环">1.3 任务队列和事件循环</h3> <p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供<strong>任务队列</strong>（task queue），里面是各种需要当前程序处理的异步任务。</p> <p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p> <p>JavaScript 引擎会不停地检查，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做<strong>事件循环</strong>（Event Loop）。</p> <h3 id="14-异步操作的模式">1.4 异步操作的模式</h3> <h4 id="1回调函数">（1）回调函数</h4> <p><strong>回调函数</strong>是异步操作最基本的方法。</p> <ul> <li>回调函数的优点是简单、容易理解和实现。</li> <li>缺点是不利于代码的阅读和维护，各个部分之间高度<strong>耦合</strong>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</li> </ul> <h4 id="2事件监听">（2）事件监听</h4> <p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p> <ul> <li>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<strong>去耦合</strong>”（decoupling），有利于实现模块化。</li> <li>缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</li> </ul> <h4 id="3发布订阅">（3）发布/订阅</h4> <p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“<strong>发布</strong>”（publish）一个信号，其他任务可以向信号中心“<strong>订阅</strong>”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<strong>发布/订阅模式</strong>”（publish-subscribe pattern），又称“<strong>观察者模式</strong>”（observer pattern）。</p> <p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p> <h3 id="15-异步操作的流程控制">1.5 异步操作的流程控制</h3> <h4 id="1串行执行">（1）串行执行</h4> <p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫<strong>串行执行</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">];</span>
<span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kd">function</span> <span class="nf">async</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">参数为 </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">arg</span> <span class="o">+</span><span class="dl">'</span><span class="s1"> , 1 秒后返回结果</span><span class="dl">'</span><span class="p">);</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">callback</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">final</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">完成: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">series</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">async</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">results</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
      <span class="k">return</span> <span class="nf">series</span><span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">());</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">final</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">series</span><span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">());</span>
</code></pre></div></div> <p>上面代码中，函数 <code class="language-plaintext highlighter-rouge">series()</code> 就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行 <code class="language-plaintext highlighter-rouge">final()</code> 函数。<code class="language-plaintext highlighter-rouge">items</code> 数组保存每个异步任务的参数，<code class="language-plaintext highlighter-rouge">results</code> 数组保存每个异步任务的运行结果。</p> <h4 id="2并行执行">（2）并行执行</h4> <p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行 <code class="language-plaintext highlighter-rouge">final()</code> 函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">];</span>
<span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kd">function</span> <span class="nf">async</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">参数为 </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">arg</span> <span class="o">+</span><span class="dl">'</span><span class="s1"> , 1 秒后返回结果</span><span class="dl">'</span><span class="p">);</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">callback</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">final</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">完成: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">items</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">async</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">){</span>
    <span class="nx">results</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">final</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">});</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">forEach()</code> 方法会同时发起六个异步任务，等到它们全部完成以后，才会执行 <code class="language-plaintext highlighter-rouge">final()</code> 函数。</p> <p>并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p> <h4 id="3并行与串行的结合">（3）并行与串行的结合</h4> <p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行 <code class="language-plaintext highlighter-rouge">n</code> 个异步任务，这样就避免了过分占用系统资源。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">];</span>
<span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">var</span> <span class="nx">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">limit</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">async</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">参数为 </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">arg</span> <span class="o">+</span><span class="dl">'</span><span class="s1"> , 1秒后返回结果</span><span class="dl">'</span><span class="p">);</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">callback</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">final</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">完成: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">launcher</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">running</span> <span class="o">&lt;</span> <span class="nx">limit</span> <span class="o">&amp;&amp;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
    <span class="k">async</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">results</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
      <span class="nx">running</span><span class="o">--</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">launcher</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">running</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">final</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
    <span class="nx">running</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">launcher</span><span class="p">();</span>
</code></pre></div></div> <p>上面代码中，最多只能同时运行两个异步任务。变量 <code class="language-plaintext highlighter-rouge">running</code> 记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于 <code class="language-plaintext highlighter-rouge">0</code>，就表示所有任务都执行完了，这时就执行 <code class="language-plaintext highlighter-rouge">final()</code> 函数。</p> <h2 id="二定时器">二、定时器</h2> <h3 id="21-settimeout">2.1 setTimeout()</h3> <p><code class="language-plaintext highlighter-rouge">setTimeout(func, delay, arg1, arg2, ...)</code> 函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，可以用来取消这个定时器。</p> <h3 id="22-setinterval">2.2 setInterval()</h3> <p><code class="language-plaintext highlighter-rouge">setInterval(func, delay, arg1, arg2, ...)</code> 函数的用法与 <code class="language-plaintext highlighter-rouge">setTimeout()</code> 完全一致，区别仅仅在于 <code class="language-plaintext highlighter-rouge">setInterval()</code> 指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p> <p><code class="language-plaintext highlighter-rouge">setInterval()</code> 指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会<strong>小于</strong>指定的时间。</p> <p>为了确保两次执行之间有固定的间隔，可以不用 <code class="language-plaintext highlighter-rouge">setInterval()</code>，而是每次执行结束后，使用 <code class="language-plaintext highlighter-rouge">setTimeout()</code> 指定下一次执行的具体时间。</p> <h3 id="23-cleartimeoutclearinterval">2.3 clearTimeout()，clearInterval()</h3> <p><code class="language-plaintext highlighter-rouge">clearTimeout(timeoutID)</code> 和 <code class="language-plaintext highlighter-rouge">clearInterval(intervalID)</code> 用来取消对应的定时器。</p> <h3 id="24-实例debounce-函数">2.4 实例：debounce 函数</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">delay</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 声明计时器</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
    <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="nx">timer</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，只要在 2500ms 之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是 2500ms。</p> <h3 id="25-运行机制">2.5 运行机制</h3> <p><code class="language-plaintext highlighter-rouge">setTimeout()</code> 和 <code class="language-plaintext highlighter-rouge">setInterval()</code> 的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。<code class="language-plaintext highlighter-rouge">setTimeout()</code> 和 <code class="language-plaintext highlighter-rouge">setInterval()</code> 指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完是不确定的，所以没有办法保证 <code class="language-plaintext highlighter-rouge">setTimeout()</code> 和 <code class="language-plaintext highlighter-rouge">setInterval()</code> 指定的任务，一定会按照预定时间执行。</p> <h3 id="26-settimeoutfunc-0">2.6 setTimeout(func, 0)</h3> <h4 id="1含义">（1）含义</h4> <p><code class="language-plaintext highlighter-rouge">setTimeout(func, 0)</code> 会在下一轮事件循环一开始就执行。<strong><code class="language-plaintext highlighter-rouge">setTimeout(func, 0)</code> 这种写法的目的是尽可能早地执行 <code class="language-plaintext highlighter-rouge">func</code></strong>，但是并不能保证立刻就执行 <code class="language-plaintext highlighter-rouge">func</code>。</p> <h4 id="2应用">（2）应用</h4> <ul> <li> <p><strong>调整事件的发生顺序</strong>。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到 <code class="language-plaintext highlighter-rouge">setTimeout(func, 0)</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type="button" id="myButton" value="click"&gt;</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myButton</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">input</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nf">B</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span><span class="dl">'</span><span class="s1"> input</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">};</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">C</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1"> body</span><span class="dl">'</span>
<span class="p">};</span>
</code></pre></div> </div> <p>上面代码在点击按钮后，先触发回调函数 <code class="language-plaintext highlighter-rouge">A</code>，然后触发函数 <code class="language-plaintext highlighter-rouge">C</code>。函数 <code class="language-plaintext highlighter-rouge">A</code> 中，<code class="language-plaintext highlighter-rouge">setTimeout(func, 0)</code> 将函数 <code class="language-plaintext highlighter-rouge">B</code> 推迟到下一轮事件循环执行，这样就起到了先触发父元素的回调函数 <code class="language-plaintext highlighter-rouge">C</code> 的目的了。</p> </li> <li> <p>用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，<code class="language-plaintext highlighter-rouge">keypress</code> 事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type="text" id="input-box"&gt;</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">input-box</span><span class="dl">'</span><span class="p">).</span><span class="nx">onkeypress</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以 <code class="language-plaintext highlighter-rouge">this.value</code> 取不到最新输入的那个字符。只有用 <code class="language-plaintext highlighter-rouge">setTimeout(func, 0)</code> 改写，上面的代码才能发挥作用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">input-box</span><span class="dl">'</span><span class="p">).</span><span class="nx">onkeypress</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">();</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">setTimeout(func, 0)</code> 实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到 <code class="language-plaintext highlighter-rouge">setTimeout(func, 0)</code> 里面执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// 写法一</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mh">0xA00000</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0xFFFFFF</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">i</span><span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 写法二</span>
<span class="kd">var</span> <span class="nx">timer</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mh">0x100000</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">timer</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">i</span><span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">i</span><span class="o">++</span> <span class="o">==</span> <span class="mh">0xFFFFFF</span><span class="p">)</span> <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">timer</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是 <code class="language-plaintext highlighter-rouge">setTimeout(func, 0)</code> 的好处。</p> <p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成 <code class="language-plaintext highlighter-rouge">setTimeout(highlightNext, 50)</code> 的样子，性能压力就会减轻。</p> </li> </ul> <h2 id="三promise-对象">三、Promise 对象</h2> <p>参考 <a href="https://es6.ruanyifeng.com/#docs/promise">ES6 标准入门 - Promise 对象</a>。</p> <h2 id="四参考">四、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/async/">JavaScript 教程 - 异步操作</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 异步操作》一章中部分知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/dom/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-12T00:00:00+00:00</published><updated>2024-10-12T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/dom</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/dom/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/dom/">《JavaScript 教程 - DOM》</a>一章中部分知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一概述">一、概述</h2> <p>DOM 是 JavaScript 操作网页的接口，全称为“<strong>文档对象模型</strong>”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。DOM 的最小组成单位叫做<strong>节点</strong>（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p> <p>节点的类型有七种。浏览器提供一个原生的节点对象 <code class="language-plaintext highlighter-rouge">Node</code>，这七种节点都继承了 <code class="language-plaintext highlighter-rouge">Node</code>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Document</code>：整个文档树的顶层节点</li> <li><code class="language-plaintext highlighter-rouge">DocumentType</code>：<code class="language-plaintext highlighter-rouge">doctype</code> 标签（比如 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>）</li> <li><code class="language-plaintext highlighter-rouge">DocumentFragment</code>：文档的片段</li> <li><code class="language-plaintext highlighter-rouge">Element</code>：网页的各种 HTML 标签（比如 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 等）</li> <li><code class="language-plaintext highlighter-rouge">Attr</code>：网页元素的属性（比如 <code class="language-plaintext highlighter-rouge">class="right"</code>）</li> <li><code class="language-plaintext highlighter-rouge">Text</code>：标签之间或标签包含的文本</li> <li><code class="language-plaintext highlighter-rouge">Comment</code>：注释</li> </ul> <p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 <strong>DOM 树</strong>。它有一个顶层节点，下一层都是顶层节点的子节点。</p> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">document</code> 节点，代表整个文档。文档的第一层有两个节点：</p> <ul> <li>第一个是文档类型节点（<code class="language-plaintext highlighter-rouge">&lt;!doctype html&gt;</code>）；</li> <li>第二个是 HTML 网页的顶层容器标签 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code>，它构成了树结构的<strong>根节点</strong>（root node），其他 HTML 标签节点都是它的下级节点。</li> </ul> <p>除了根节点，其他节点有三种层级关系。</p> <ul> <li>父节点关系（parentNode）：直接的那个上级节点</li> <li>子节点关系（childNodes）：直接的下级节点</li> <li>同级节点关系（sibling）：拥有同一个父节点的节点</li> </ul> <p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括 <code class="language-plaintext highlighter-rouge">firstChild</code>（第一个子节点）和 <code class="language-plaintext highlighter-rouge">lastChild</code>（最后一个子节点）等属性，同级节点接口包括 <code class="language-plaintext highlighter-rouge">previousSibling</code>（紧邻在前的那个同级节点）和 <code class="language-plaintext highlighter-rouge">nextSibling</code>（紧邻在后的那个同级节点）属性。</p> <h2 id="二node-接口">二、Node 接口</h2> <p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。</p> <h3 id="1-属性">1. 属性</h3> <h4 id="11-nodeprototypenodetype">1.1 Node.prototype.nodeType</h4> <p><code class="language-plaintext highlighter-rouge">nodeType</code> 属性返回一个整数值，表示节点的<strong>类型</strong>。不同节点的 <code class="language-plaintext highlighter-rouge">nodeType</code> 属性值和对应的常量如下。</p> <ul> <li>文档节点（document）：<code class="language-plaintext highlighter-rouge">9</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code></li> <li>文档类型节点（DocumentType）：<code class="language-plaintext highlighter-rouge">10</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_TYPE_NODE</code></li> <li>文档片断节点（DocumentFragment）：<code class="language-plaintext highlighter-rouge">11</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_FRAGMENT_NODE</code></li> <li>元素节点（element）：<code class="language-plaintext highlighter-rouge">1</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.ELEMENT_NODE</code></li> <li>属性节点（attr）：<code class="language-plaintext highlighter-rouge">2</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.ATTRIBUTE_NODE</code></li> <li>文本节点（text）：<code class="language-plaintext highlighter-rouge">3</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.TEXT_NODE</code></li> <li>注释节点（Comment）：<code class="language-plaintext highlighter-rouge">8</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.COMMENT_NODE</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">nodeType</span> <span class="c1">// 9</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">DOCUMENT_NODE</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="12-nodeprototypenodename">1.2 Node.prototype.nodeName</h4> <p><code class="language-plaintext highlighter-rouge">nodeName</code> 属性返回节点的<strong>名称</strong>。不同节点的 <code class="language-plaintext highlighter-rouge">nodeName</code> 属性值如下。</p> <ul> <li>文档节点（document）：<code class="language-plaintext highlighter-rouge">#document</code></li> <li>文档类型节点（DocumentType）：文档的类型</li> <li>文档片断节点（DocumentFragment）：<code class="language-plaintext highlighter-rouge">#document-fragment</code></li> <li>元素节点（element）：大写的标签名</li> <li>属性节点（attr）：属性的名称</li> <li>文本节点（text）：<code class="language-plaintext highlighter-rouge">#text</code></li> <li>注释节点（Comment）：<code class="language-plaintext highlighter-rouge">#comment</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">nodeName</span> <span class="c1">// "DIV"</span>
</code></pre></div></div> <h4 id="13-nodeprototypenodevalue">1.3 Node.prototype.nodeValue</h4> <p><code class="language-plaintext highlighter-rouge">nodeValue</code> 属性返回一个字符串，表示当前节点本身的<strong>文本值</strong>，该属性<strong>可读写</strong>。</p> <p>只有<strong>属性节点</strong>（attr）、<strong>文本节点</strong>（text）和<strong>注释节点</strong>（comment）有文本值，因此这三类节点的 <code class="language-plaintext highlighter-rouge">nodeValue</code> 可以返回结果，其他类型的节点一律返回 <code class="language-plaintext highlighter-rouge">null</code>。也只有这三类节点可以设置 <code class="language-plaintext highlighter-rouge">nodeValue</code> 属性的值，其他类型的节点设置无效。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="c1">// null</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="c1">// "hello world"</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">div</code> 是元素节点，<code class="language-plaintext highlighter-rouge">nodeValue</code> 属性返回 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">div.firstChild</code> 是文本节点，所以可以返回文本值。</p> <h4 id="14-nodeprototypetextcontent">1.4 Node.prototype.textContent</h4> <p><code class="language-plaintext highlighter-rouge">textContent</code> 属性返回<strong>当前节点和它的所有后代节点</strong>的<strong>文本内容</strong>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">textContent</code> 属性自动忽略当前节点内部的 HTML 标签，返回所有<strong>文本内容</strong>。</li> <li>该属性<strong>可读写</strong>，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它会自动对 HTML 标签转义。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;div id="divA"&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">divA</span><span class="dl">'</span><span class="p">).</span><span class="nx">textContent</span>
<span class="c1">// This is some text</span>
</code></pre></div></div> <h4 id="15-nodeprototypebaseuri">1.5 Node.prototype.baseURI</h4> <p><code class="language-plaintext highlighter-rouge">baseURI</code> 属性返回一个字符串，表示当前网页的<strong>绝对路径</strong>。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为<strong>只读</strong>。该属性的值一般由当前网址的 URL（即 <code class="language-plaintext highlighter-rouge">window.location</code> 属性）决定，但是可以使用 HTML 的 <code class="language-plaintext highlighter-rouge">&lt;base&gt;</code> 标签，改变该属性的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 当前网页的网址为</span>
<span class="c1">// http://www.example.com/index.html</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">baseURI</span>
<span class="c1">// "http://www.example.com/index.html"</span>
<span class="o">&lt;</span><span class="nx">base</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">http://www.example.com/page.html</span><span class="dl">"</span><span class="o">&gt;</span>
</code></pre></div></div> <h4 id="16-nodeprototypeownerdocument">1.6 Node.prototype.ownerDocument</h4> <p><code class="language-plaintext highlighter-rouge">Node.ownerDocument</code> 属性返回当前节点所在的顶层文档对象，即 <code class="language-plaintext highlighter-rouge">document</code> 对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ownerDocument</span><span class="p">;</span>
<span class="nx">d</span> <span class="o">===</span> <span class="nb">document</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="17-nodeprototypeprevioussiblingnodeprototypenextsibling">1.7 Node.prototype.previousSibling，Node.prototype.nextSibling</h4> <ul> <li><code class="language-plaintext highlighter-rouge">previousSibling</code> 属性返回当前节点<strong>前面的</strong>、<strong>距离最近的一个同级节点</strong>。</li> <li><code class="language-plaintext highlighter-rouge">nextSibling</code> 属性返回紧跟在当前节点<strong>后面的第一个同级节点</strong>。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d2</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d2</span><span class="p">.</span><span class="nx">previousSibling</span> <span class="o">===</span> <span class="nx">d1</span> <span class="c1">// true</span>

<span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d2</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d1</span><span class="p">.</span><span class="nx">nextSibling</span> <span class="o">===</span> <span class="nx">d2</span> <span class="c1">// true</span>
</code></pre></div></div> <p>注意，这两个属性还包括文本节点和注释节点。因此如果当前节点前面/后面有空格，他们都会返回一个文本节点，内容为空格。</p> <h4 id="18-nodeprototypeparentnode">1.8 Node.prototype.parentNode</h4> <ul> <li><code class="language-plaintext highlighter-rouge">parentNode</code> 属性返回当前节点的<strong>父节点</strong>。对于一个节点来说，它的父节点只可能是三种类型：<strong>文档节点</strong>（document）、<strong>文档片段节点</strong>（documentfragment）和<strong>元素节点</strong>（element）。文档节点（document）和文档片段节点（documentfragment）的父节点都是 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">parentElement</code> 属性返回当前节点的<strong>父元素节点</strong>。此属性只包含元素节点。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="19-nodeprototypefirstchildnodeprototypelastchild">1.9 Node.prototype.firstChild，Node.prototype.lastChild</h4> <ul> <li><code class="language-plaintext highlighter-rouge">firstChild</code> 属性返回当前节点的第一个子节点。<code class="language-plaintext highlighter-rouge">firstChild</code> 返回的除了元素节点，还可能是文本节点或注释节点。</li> <li><code class="language-plaintext highlighter-rouge">lastChild</code> 属性返回当前节点的最后一个子节点。用法与 <code class="language-plaintext highlighter-rouge">firstChild</code> 属性相同。</li> </ul> <h4 id="110-nodeprototypechildnodes">1.10 Node.prototype.childNodes</h4> <p><code class="language-plaintext highlighter-rouge">childNodes</code> 属性返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">NodeList</code> 集合），成员包括当前节点的所有子节点。<code class="language-plaintext highlighter-rouge">childNodes</code> 属性的返回值包括<strong>元素节点</strong>、<strong>文本节点</strong>和<strong>注释节点</strong>。如果当前节点不包括任何子节点，则返回一个空的 <code class="language-plaintext highlighter-rouge">NodeList</code> 集合。</p> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 对象是一个<strong>动态集合</strong>，子节点发生的变化会立刻反映在返回结果之中。</p> <h4 id="111-nodeprototypeisconnected">1.11 Node.prototype.isConnected</h4> <p><code class="language-plaintext highlighter-rouge">isConnected</code> 布尔值，表示当前节点是否在文档之中。</p> <h3 id="2-方法">2. 方法</h3> <h4 id="21-nodeprototypeappendchild">2.1 Node.prototype.appendChild()</h4> <p><code class="language-plaintext highlighter-rouge">appendChild(aChild)</code> 接受一个节点对象作为参数，将其作为<strong>最后一个</strong>子节点，插入当前节点。该方法的返回值是插入文档的子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</code></pre></div></div> <p>如果参数节点是 DOM 已经存在的节点，<code class="language-plaintext highlighter-rouge">appendChild()</code> 会将其从原来的位置，<strong>移动</strong>到新位置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">div</span><span class="p">);</span>
</code></pre></div></div> <h4 id="22-nodeprototypehaschildnodes">2.2 Node.prototype.hasChildNodes()</h4> <p><code class="language-plaintext highlighter-rouge">hasChildNodes()</code> 返回布尔值，表示当前节点是否有子节点。子节点包括所有类型的节点，哪怕节点只包含一个空格，<code class="language-plaintext highlighter-rouge">hasChildNodes()</code> 方法也会返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <h4 id="23-nodeprototypeclonenode">2.3 Node.prototype.cloneNode()</h4> <p><code class="language-plaintext highlighter-rouge">cloneNode(deep)</code> 用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">cloneUL</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">).</span><span class="nf">cloneNode</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>克隆一个节点，会拷贝该节点的所有属性，但是会丧失 <code class="language-plaintext highlighter-rouge">addEventListener()</code> 方法和 <code class="language-plaintext highlighter-rouge">on-属性</code>（即 <code class="language-plaintext highlighter-rouge">node.onclick = fn</code>），添加在这个节点上的事件回调函数。</li> <li>该方法返回的节点不在文档中，即没有任何父节点，必须使用诸如 <code class="language-plaintext highlighter-rouge">Node.appendChild()</code> 这样的方法添加到文档之中。</li> <li>克隆一个节点之后，DOM 有可能出现两个有相同 <code class="language-plaintext highlighter-rouge">id</code> 属性的网页元素，这时应该修改其中一个元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性。如果原节点有 <code class="language-plaintext highlighter-rouge">name</code> 属性，可能也需要修改。</li> </ul> <h4 id="24-nodeprototypeinsertbefore">2.4 Node.prototype.insertBefore()</h4> <p><code class="language-plaintext highlighter-rouge">insertBefore(newNode, referenceNode)</code> 用于将某个节点插入父节点内部的指定位置。</p> <ul> <li>第一个参数是所要插入的节点 <code class="language-plaintext highlighter-rouge">newNode</code>。</li> <li>第二个参数是父节点 <code class="language-plaintext highlighter-rouge">parentNode</code> 内部的一个子节点 <code class="language-plaintext highlighter-rouge">referenceNode</code>。如果第二个参数为 <code class="language-plaintext highlighter-rouge">null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">insertBefore</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，新建一个 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 节点，插在 <code class="language-plaintext highlighter-rouge">document.body.firstChild</code> 的前面，也就是成为 <code class="language-plaintext highlighter-rouge">document.body</code> 的第一个子节点。</p> <p>由于不存在 <code class="language-plaintext highlighter-rouge">insertAfter</code> 方法，如果新节点要插在父节点的某个子节点后面，可以用 <code class="language-plaintext highlighter-rouge">insertBefore()</code> 结合 <code class="language-plaintext highlighter-rouge">nextSibling</code> 属性模拟。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parent</span><span class="p">.</span><span class="nf">insertBefore</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">parent</code> 是父节点，<code class="language-plaintext highlighter-rouge">s1</code> 是一个全新的节点，<code class="language-plaintext highlighter-rouge">s2</code> 是可以将 <code class="language-plaintext highlighter-rouge">s1</code> 节点，插在 <code class="language-plaintext highlighter-rouge">s2</code> 节点的后面。如果 <code class="language-plaintext highlighter-rouge">s2</code> 是当前节点的最后一个子节点，则 <code class="language-plaintext highlighter-rouge">s2.nextSibling</code> 返 回 <code class="language-plaintext highlighter-rouge">null</code>，这时 <code class="language-plaintext highlighter-rouge">s1</code> 节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在 <code class="language-plaintext highlighter-rouge">s2</code> 的后面。</p> <h4 id="25-nodeprototyperemovechild">2.5 Node.prototype.removeChild()</h4> <p><code class="language-plaintext highlighter-rouge">removeChild(child)</code> 接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">divA</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">divA</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">divA</span><span class="p">);</span>
</code></pre></div></div> <h4 id="26-nodeprototypereplacechild">2.6 Node.prototype.replaceChild()</h4> <p><code class="language-plaintext highlighter-rouge">replaceChild(newChild, oldChild)</code> 用于将一个新的节点，替换当前节点的某个子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">replacedNode</span> <span class="o">=</span> <span class="nx">parentNode</span><span class="p">.</span><span class="nf">replaceChild</span><span class="p">(</span><span class="nx">newChild</span><span class="p">,</span> <span class="nx">oldChild</span><span class="p">);</span>
</code></pre></div></div> <h4 id="27-nodeprototypecontains">2.7 Node.prototype.contains()</h4> <p><code class="language-plaintext highlighter-rouge">contains(otherNode)</code> 返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p> <ul> <li>参数节点为<strong>当前节点</strong>。</li> <li>参数节点为当前节点的<strong>子节点</strong>。</li> <li>参数节点为当前节点的<strong>后代节点</strong>。</li> </ul> <h4 id="28-nodeprototypecomparedocumentposition">2.8 Node.prototype.compareDocumentPosition()</h4> <p><code class="language-plaintext highlighter-rouge">compareDocumentPosition(otherNode)</code> 与 <code class="language-plaintext highlighter-rouge">contains()</code> 完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的<strong>关系</strong>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">000000</code>：十进制的 0，表示两个节点<strong>相同</strong></li> <li><code class="language-plaintext highlighter-rouge">000001</code>：十进制的 1，表示两个节点不在同一个文档（即有一个节点不在当前文档）</li> <li><code class="language-plaintext highlighter-rouge">000010</code>：十进制的 2，表示参数节点在当前节点的<strong>前面</strong></li> <li><code class="language-plaintext highlighter-rouge">000100</code>：十进制的 4，表示参数节点在当前节点的<strong>后面</strong></li> <li><code class="language-plaintext highlighter-rouge">001000</code>：十进制的 8，表示参数节点<strong>包含</strong>当前节点</li> <li><code class="language-plaintext highlighter-rouge">010000</code>：十进制的 16，表示当前节点<strong>包含</strong>参数节点</li> <li><code class="language-plaintext highlighter-rouge">100000</code>：十进制的 32，表示浏览器内部使用</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="mydiv"&gt;</span>
<span class="c1">//   &lt;form&gt;&lt;input id="test" /&gt;&lt;/form&gt;</span>
<span class="c1">// &lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">mydiv</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="c1">// 20</span>
<span class="nx">input</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">div</span><span class="p">)</span> <span class="c1">// 10</span>
</code></pre></div></div> <p>上面代码中，节点 <code class="language-plaintext highlighter-rouge">div</code> 包含节点 <code class="language-plaintext highlighter-rouge">input</code>（二进制 <code class="language-plaintext highlighter-rouge">010000</code>），而且节点 <code class="language-plaintext highlighter-rouge">input</code> 在节点 <code class="language-plaintext highlighter-rouge">div</code> 的后面（二进制 <code class="language-plaintext highlighter-rouge">000100</code>），所以第一个 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 方法返回 <code class="language-plaintext highlighter-rouge">20</code>（二进制 <code class="language-plaintext highlighter-rouge">010100</code>，即 <code class="language-plaintext highlighter-rouge">010000</code> + <code class="language-plaintext highlighter-rouge">000100</code>），第二个 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 方法返回 <code class="language-plaintext highlighter-rouge">10</code>（二进制 <code class="language-plaintext highlighter-rouge">001010</code>）。</p> <p>由于 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 返回值的含义，定义在每个比特位上，所以如果要检查某种特定的含义，就需要使用比特位运算符。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">head</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">文档结构正确</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;body&gt; 不能在 &lt;head&gt; 前面</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 的返回值与 <code class="language-plaintext highlighter-rouge">4</code>（又称掩码）进行与运算（<code class="language-plaintext highlighter-rouge">&amp;</code>），得到一个布尔值，表示 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 是否在 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 前面。</p> <h4 id="29-nodeprototypeisequalnodenodeprototypeissamenode">2.9 Node.prototype.isEqualNode()，Node.prototype.isSameNode()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">isEqualNode(otherNode)</code> 返回一个布尔值，用于检查两个节点是否<strong>相等</strong>。所谓相等的节点，指的是两个节点的<strong>类型</strong>相同、<strong>属性</strong>相同、<strong>子节点</strong>相同。</li> <li><code class="language-plaintext highlighter-rouge">isSameNode(otherNode)</code> 返回一个布尔值，表示两个节点是否为<strong>同一个</strong>节点。</li> </ul> <h4 id="210-nodeprototypenormalize">2.10 Node.prototype.normalize()</h4> <p><code class="language-plaintext highlighter-rouge">normalize()</code> 用于清理当前节点内部的所有<strong>文本节点</strong>（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。该方法是 <code class="language-plaintext highlighter-rouge">Text.splitText()</code> 的逆方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">Part 1 </span><span class="dl">'</span><span class="p">));</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">Part 2 </span><span class="dl">'</span><span class="p">));</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nf">normalize</span><span class="p">();</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>上面代码使用 <code class="language-plaintext highlighter-rouge">normalize()</code> 之前，<code class="language-plaintext highlighter-rouge">wrapper</code> 节点有两个毗邻的文本子节点。使 <code class="language-plaintext highlighter-rouge">normalize()</code> 之后，两个文本子节点被合并成一个。</p> <h4 id="211-nodeprototypegetrootnode">2.11 Node.prototype.getRootNode()</h4> <p><code class="language-plaintext highlighter-rouge">getRootNode(options)</code> 返回当前节点所在文档的根节点 <code class="language-plaintext highlighter-rouge">document</code>，与 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性的作用相同。</p> <h2 id="三nodelist-接口htmlcollection-接口">三、NodeList 接口，HTMLCollection 接口</h2> <p>DOM 提供两种节点集合，用于容纳多个节点：<code class="language-plaintext highlighter-rouge">NodeList</code> 和 <code class="language-plaintext highlighter-rouge">HTMLCollection</code>。<code class="language-plaintext highlighter-rouge">NodeList</code> 可以包含各种类型的节点，<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 只能包含 HTML 元素节点。</p> <h3 id="1-nodelist-接口">1. NodeList 接口</h3> <h4 id="11-概述">1.1 概述</h4> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Node.childNodes</code></li> <li><code class="language-plaintext highlighter-rouge">document.querySelectorAll()</code> 等节点搜索方法</li> </ul> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 是对象不是数组，但可以使用 <code class="language-plaintext highlighter-rouge">length</code> 属性和 <code class="language-plaintext highlighter-rouge">forEach()</code> 。</p> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例。目前，只有 <code class="language-plaintext highlighter-rouge">Node.childNodes</code> 返回的是动态集合，其他的都是静态集合。</p> <h4 id="12-nodelistprototypelength">1.2 NodeList.prototype.length</h4> <p><code class="language-plaintext highlighter-rouge">length</code> 属性返回 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例包含的节点数量。</p> <h4 id="13-nodelistprototypeforeach">1.3 NodeList.prototype.forEach()</h4> <p><code class="language-plaintext highlighter-rouge">forEach()</code> 方法用于遍历 <code class="language-plaintext highlighter-rouge">NodeList</code> 的所有成员。</p> <h4 id="14-nodelistprototypeitem">1.4 NodeList.prototype.item()</h4> <p><code class="language-plaintext highlighter-rouge">item(index)</code> 接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（<code class="language-plaintext highlighter-rouge">[]</code>），而不使用 <code class="language-plaintext highlighter-rouge">item()</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div> <h4 id="15-nodelistprototypekeysnodelistprototypevaluesnodelistprototypeentries">1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h4> <p>这三个方法都返回一个 ES6 的<strong>遍历器对象</strong>，可以通过 <code class="language-plaintext highlighter-rouge">for...of</code> 循环遍历获取每个成员的信息。<code class="language-plaintext highlighter-rouge">keys()</code> 返回键名的遍历器，<code class="language-plaintext highlighter-rouge">values()</code> 返回键值的遍历器，<code class="language-plaintext highlighter-rouge">entries()</code> 返回的遍历器同时包含键名和键值的信息。</p> <h3 id="2-htmlcollection-接口">2. HTMLCollection 接口</h3> <h4 id="21-概述">2.1 概述</h4> <p><code class="language-plaintext highlighter-rouge">HTMLCollection</code> 是一个只包含<strong>元素节点</strong>（element）对象的集合，不包含其他类型的节点。它的返回值是一个类似数组的对象，<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 只能使用 <code class="language-plaintext highlighter-rouge">for</code> 循环遍历。</p> <p>返回 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例的，主要是一些 <code class="language-plaintext highlighter-rouge">Document</code> 对象的集合属性，比如 <code class="language-plaintext highlighter-rouge">document.links</code>、<code class="language-plaintext highlighter-rouge">document.forms</code>、<code class="language-plaintext highlighter-rouge">document.images</code> 等。</p> <p>如果元素节点有 <code class="language-plaintext highlighter-rouge">id</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 属性，那么 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例上面，可以使用 <code class="language-plaintext highlighter-rouge">id</code> 属性或 <code class="language-plaintext highlighter-rouge">name</code> 属性引用该节点元素。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span>
<span class="kd">var</span> <span class="nx">pic</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">.</span><span class="nx">pic</span> <span class="o">===</span> <span class="nx">pic</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">document.images</code> 是一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，可以通过 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性值，从 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例上取到这个元素。</p> <h4 id="22-htmlcollectionprototypelength">2.2 HTMLCollection.prototype.length</h4> <p><code class="language-plaintext highlighter-rouge">length</code> 属性返回 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例包含的成员数量。</p> <h4 id="23-htmlcollectionprototypeitem">2.3 HTMLCollection.prototype.item()</h4> <p><code class="language-plaintext highlighter-rouge">item(index)</code> 接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（<code class="language-plaintext highlighter-rouge">[]</code>），而不使用 <code class="language-plaintext highlighter-rouge">item()</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">img0</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div> <h4 id="24-htmlcollectionprototypenameditem">2.4 HTMLCollection.prototype.namedItem()</h4> <p><code class="language-plaintext highlighter-rouge">namedItem(key)</code> 的参数是一个字符串，表示 <code class="language-plaintext highlighter-rouge">id</code> 属性或 <code class="language-plaintext highlighter-rouge">name</code> 属性的值，返回当前集合中对应的元素节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span>
<span class="kd">var</span> <span class="nx">pic</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">.</span><span class="nf">namedItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">)</span> <span class="o">===</span> <span class="nx">pic</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Collection.namedItem('value')</code> 等同于 <code class="language-plaintext highlighter-rouge">Collection['value']</code>。</p> <h2 id="四parentnode-接口childnode-接口">四、ParentNode 接口，ChildNode 接口</h2> <p>节点对象除了继承 <code class="language-plaintext highlighter-rouge">Node</code> 接口以外，还拥有其他接口。<code class="language-plaintext highlighter-rouge">ParentNode</code> 接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code class="language-plaintext highlighter-rouge">ChildNode</code> 接口表示当前节点是一个子节点，提供一些相关方法。</p> <h3 id="1-parentnode-接口">1. ParentNode 接口</h3> <p>如果当前节点是父节点，就会混入（mixin）<code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。只有<strong>文档节点</strong>（document）、<strong>文档片段节点</strong>（documentFragment）和<strong>元素节点</strong>（element）拥有 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。</p> <h4 id="11-parentnodechildren">1.1 ParentNode.children</h4> <p><code class="language-plaintext highlighter-rouge">children</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是当前节点的<strong>所有元素子节点</strong>。该属性只读。</p> <h4 id="12-parentnodefirstelementchildparentnodelastelementchild">1.2 ParentNode.firstElementChild，ParentNode.lastElementChild</h4> <ul> <li><code class="language-plaintext highlighter-rouge">firstElementChild</code> 属性返回当前节点的<strong>第一个元素子节点</strong>。</li> <li><code class="language-plaintext highlighter-rouge">lastElementChild</code> 属性返回当前节点的<strong>最后一个元素子节点</strong>。</li> </ul> <h4 id="13-parentnodechildelementcount">1.3 ParentNode.childElementCount</h4> <p><code class="language-plaintext highlighter-rouge">childElementCount</code> 属性返回一个整数，表示当前节点的所有元素子节点的数目。</p> <h4 id="14-parentnodeappendparentnodeprepend">1.4 ParentNode.append()，ParentNode.prepend()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">append(node1, node2, ...)</code> 为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。该方法可以添加<strong>元素节点</strong>（参数为元素节点）和<strong>文本节点</strong>（参数为字符串）。</li> <li><code class="language-plaintext highlighter-rouge">prepend(node1, node2, ...)</code> 为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与 <code class="language-plaintext highlighter-rouge">append()</code> 完全一致，也是没有返回值。</li> </ul> <p>注意，<code class="language-plaintext highlighter-rouge">append()</code> 与 <code class="language-plaintext highlighter-rouge">Node.prototype.appendChild()</code> 有三点不同。</p> <ul> <li><code class="language-plaintext highlighter-rouge">append()</code> 允许字符串作为参数，<code class="language-plaintext highlighter-rouge">appendChild()</code> 只允许子节点作为参数。</li> <li><code class="language-plaintext highlighter-rouge">append()</code> 没有返回值，而 <code class="language-plaintext highlighter-rouge">appendChild()</code> 返回添加的子节点。</li> <li><code class="language-plaintext highlighter-rouge">append()</code> 可以添加多个子节点和字符串（即允许多个参数），<code class="language-plaintext highlighter-rouge">appendChild()</code> 只能添加一个节点（即只允许一个参数）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
<span class="c1">// 添加元素子节点</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="c1">// 添加文本子节点</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 添加多个元素子节点</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">);</span>
<span class="c1">// 添加元素子节点和文本子节点</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span> <span class="nx">p</span><span class="p">);</span>
</code></pre></div></div> <h3 id="2-childnode-接口">2. ChildNode 接口</h3> <p>如果一个节点有父节点，那么该节点就拥有了 <code class="language-plaintext highlighter-rouge">ChildNode</code> 接口。</p> <h4 id="21-childnoderemove">2.1 ChildNode.remove()</h4> <p><code class="language-plaintext highlighter-rouge">remove()</code> 用于从父节点移除当前节点。</p> <h4 id="22-childnodebeforechildnodeafter">2.2 ChildNode.before()，ChildNode.after()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">before(node1, node2, ...)</code> 方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。该方法可以插入<strong>元素节点</strong>和<strong>文本节点</strong>。</li> <li><code class="language-plaintext highlighter-rouge">after(node1, node2, ...</code> 方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与 <code class="language-plaintext highlighter-rouge">before()</code> 完全相同。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 插入元素节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="c1">// 插入文本节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 插入多个元素节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">p1</span><span class="p">);</span>
<span class="c1">// 插入元素节点和文本节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <h4 id="23-childnodereplacewith">2.3 ChildNode.replaceWith()</h4> <p><code class="language-plaintext highlighter-rouge">replaceWith(node1, node2, ...)</code> 方法使用参数节点，替换当前节点。参数可以是<strong>元素节点</strong>、<strong>文本节点</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">span</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">span</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">replaceWith</span><span class="p">(</span><span class="nx">span</span><span class="p">);</span>
</code></pre></div></div> <h2 id="五document-节点">五、Document 节点</h2> <h3 id="1-概述">1. 概述</h3> <p><code class="language-plaintext highlighter-rouge">document</code> 节点对象代表整个文档，每张网页都有自己的 <code class="language-plaintext highlighter-rouge">document</code> 对象。<code class="language-plaintext highlighter-rouge">window.document</code> 属性就指向这个对象。当浏览器开始载入 HTML 文档，该对象就存在。<code class="language-plaintext highlighter-rouge">document</code> 对象有不同的办法可以获取。</p> <ul> <li>正常的网页，直接使用 <code class="language-plaintext highlighter-rouge">document</code> 或 <code class="language-plaintext highlighter-rouge">window.document</code>。</li> <li><code class="language-plaintext highlighter-rouge">iframe</code> 框架里面的网页，使用 iframe 节点的 <code class="language-plaintext highlighter-rouge">contentDocument</code> 属性。</li> <li>Ajax 操作返回的文档，使用 <code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> 对象的 <code class="language-plaintext highlighter-rouge">responseXML</code> 属性。</li> <li>内部节点的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document</code> 对象继承了 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口和 <code class="language-plaintext highlighter-rouge">Node</code> 接口，并且混入（mixin）了 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。这意味着，这些接口的方法都可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象上调用。除此之外，<code class="language-plaintext highlighter-rouge">document</code> 对象还有很多自己的属性和方法。</p> <h3 id="2-属性">2. 属性</h3> <h4 id="21-快捷方式属性">2.1 快捷方式属性</h4> <p>以下属性是指向文档内部的某个节点的快捷方式。</p> <ul> <li><code class="language-plaintext highlighter-rouge">document.defaultView</code>：返回 <code class="language-plaintext highlighter-rouge">document</code> 对象所属的 <code class="language-plaintext highlighter-rouge">window</code> 对象。如果当前文档不属于 <code class="language-plaintext highlighter-rouge">window</code> 对象，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">document.doctype</code>：<code class="language-plaintext highlighter-rouge">document</code> 对象一般有两个子节点。第一个子节点是 <code class="language-plaintext highlighter-rouge">document.doctype</code>，指向 <code class="language-plaintext highlighter-rouge">&lt;DOCTYPE&gt;</code> 节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>。</li> <li><code class="language-plaintext highlighter-rouge">document.documentElement</code>：返回当前文档的<strong>根元素节点</strong>（root）。它通常是 <code class="language-plaintext highlighter-rouge">document</code> 节点的第二个子节点，紧跟在 <code class="language-plaintext highlighter-rouge">document.doctype</code> 节点后面。HTML 网页的该属性，一般是 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 节点。</li> <li><code class="language-plaintext highlighter-rouge">document.head</code>：指向 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 节点，该属性<strong>可读写</strong>。</li> <li><code class="language-plaintext highlighter-rouge">document.body</code>：指向 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 节点，该属性<strong>可读写</strong>。</li> <li><code class="language-plaintext highlighter-rouge">document.scrollingElement</code>：返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。标准模式下，这个属性返回的文档的根元素 <code class="language-plaintext highlighter-rouge">document.documentElement</code>（即 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code>）。兼容（quirk）模式下，返回的是 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素，如果该元素不存在，返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">document.activeElement</code>：返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;textarea&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;select&gt;</code> 等表单元素，如果当前没有焦点元素，返回 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素或 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">document.fullscreenElement</code>：返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> </ul> <h4 id="22-节点集合属性">2.2 节点集合属性</h4> <p>以下属性（除 <code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性外）返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，表示文档内部特定元素的集合。这些集合都是<strong>动态的</strong>，原节点有任何变化，立刻会反映在集合中。</p> <ul> <li><code class="language-plaintext highlighter-rouge">document.links</code>：返回当前文档所有设定了 href 属性的 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 及 <code class="language-plaintext highlighter-rouge">&lt;area&gt;</code> 节点。</li> <li><code class="language-plaintext highlighter-rouge">document.forms</code>：返回所有 <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> 表单节点。</li> <li><code class="language-plaintext highlighter-rouge">document.images</code>：返回页面所有 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 图片节点。</li> <li><code class="language-plaintext highlighter-rouge">document.embeds</code>，<code class="language-plaintext highlighter-rouge">document.plugins</code>：所有 <code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 节点。</li> <li><code class="language-plaintext highlighter-rouge">document.scripts</code>：返回所有 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 节点。</li> <li><code class="language-plaintext highlighter-rouge">document.styleSheets</code>：返回网页内嵌或引入的 CSS 样式表集合。</li> </ul> <p>除了 <code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性，以上的其他集合属性返回的都是 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例。<code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性返回的是 <code class="language-plaintext highlighter-rouge">StyleSheetList</code> 实例。</p> <h4 id="23-文档静态信息属性">2.3 文档静态信息属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.documentURI</code>，<code class="language-plaintext highlighter-rouge">document.URL</code>：返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code class="language-plaintext highlighter-rouge">documentURI</code> 继承自 <code class="language-plaintext highlighter-rouge">Document</code> 接口，可用于所有文档；<code class="language-plaintext highlighter-rouge">URL</code> 继承自 <code class="language-plaintext highlighter-rouge">HTMLDocument</code> 接口，只能用于 HTML 文档。</li> <li><code class="language-plaintext highlighter-rouge">document.domain</code>：返回当前文档的<strong>域名</strong>，不包含协议和端口。</li> <li><code class="language-plaintext highlighter-rouge">document.location</code>：<code class="language-plaintext highlighter-rouge">Location</code> 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 <code class="language-plaintext highlighter-rouge">window.location</code> 和 <code class="language-plaintext highlighter-rouge">document.location</code> 属性，可以拿到这个对象。</li> <li><code class="language-plaintext highlighter-rouge">document.lastModified</code>：返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</li> <li><code class="language-plaintext highlighter-rouge">document.title</code>：返回当前文档的标题。默认情况下，返回 <code class="language-plaintext highlighter-rouge">&lt;title&gt;</code> 节点的值。该属性<strong>可读写</strong>。</li> <li><code class="language-plaintext highlighter-rouge">document.characterSet</code>：返回当前文档的编码，比如 UTF-8 等等。</li> <li><code class="language-plaintext highlighter-rouge">document.referrer</code>：返回一个字符串，表示当前文档的访问者来自哪里。<code class="language-plaintext highlighter-rouge">document.referrer</code> 的值，总是与 HTTP 头信息的 <code class="language-plaintext highlighter-rouge">Referer</code> 字段保持一致。</li> <li><code class="language-plaintext highlighter-rouge">document.dir</code>：返回一个字符串，表示文字方向。它有两个可能的值：<code class="language-plaintext highlighter-rouge">rtl</code> 表示文字从右到左，阿拉伯文是这种方式；<code class="language-plaintext highlighter-rouge">ltr</code> 表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</li> <li><code class="language-plaintext highlighter-rouge">document.compatMode</code>：返回浏览器处理文档的模式，可能的值为 <code class="language-plaintext highlighter-rouge">BackCompat</code>（向后兼容模式）和 <code class="language-plaintext highlighter-rouge">CSS1Compat</code>（严格模式）。一般来说，如果网页代码的第一行设置了明确的 <code class="language-plaintext highlighter-rouge">DOCTYPE</code>（比如 <code class="language-plaintext highlighter-rouge">&lt;!doctype html&gt;</code>），<code class="language-plaintext highlighter-rouge">document.compatMode</code> 的值都为 <code class="language-plaintext highlighter-rouge">CSS1Compat</code>。</li> </ul> <h4 id="24-文档状态属性">2.4 文档状态属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.hidden</code>：布尔值，表示当前页面<strong>是否可见</strong>。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得 <code class="language-plaintext highlighter-rouge">document.hidden</code> 返回 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.visibilityState</code>：返回文档的<strong>可见状态</strong>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li> <li><code class="language-plaintext highlighter-rouge">hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li> <li><code class="language-plaintext highlighter-rouge">prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li> <li><code class="language-plaintext highlighter-rouge">unloaded</code>：页面从内存里面卸载了。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">document.readyState</code>：返回当前文档的<strong>状态</strong>，共有三种可能的值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">loading</code>：加载 HTML 代码阶段（尚未完成解析）。</li> <li><code class="language-plaintext highlighter-rouge">interactive</code>：加载外部资源阶段。</li> <li><code class="language-plaintext highlighter-rouge">complete</code>：加载完成。</li> </ul> </li> </ul> <p><code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变化的过程如下。</p> <ol> <li>浏览器开始解析 HTML 文档，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性等于 <code class="language-plaintext highlighter-rouge">loading</code>。</li> <li>浏览器遇到 HTML 文档中的 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，并且没有 <code class="language-plaintext highlighter-rouge">async</code> 或 <code class="language-plaintext highlighter-rouge">defer</code> 属性，就暂停解析，开始执行脚本，这时 <code class="language-plaintext highlighter-rouge">document.readyState</code> 属性还是 <code class="language-plaintext highlighter-rouge">loading</code>。</li> <li>HTML 文档解析完成，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变成 <code class="language-plaintext highlighter-rouge">interactive</code>。</li> <li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变成 <code class="language-plaintext highlighter-rouge">complete</code>。</li> </ol> <h4 id="25-documentcookie">2.5 document.cookie</h4> <p><code class="language-plaintext highlighter-rouge">document.cookie</code> 属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。</p> <h4 id="26-documentdesignmode">2.6 document.designMode</h4> <p><code class="language-plaintext highlighter-rouge">document.designMode</code> 属性控制当前文档是否可编辑。该属性只有两个值 <code class="language-plaintext highlighter-rouge">on</code> 和 <code class="language-plaintext highlighter-rouge">off</code>，默认值为 <code class="language-plaintext highlighter-rouge">off</code>。</p> <h4 id="27-documentcurrentscript">2.7 document.currentScript</h4> <p><code class="language-plaintext highlighter-rouge">document.currentScript</code> 属性只用在 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素的 DOM 节点。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">id=</span><span class="s">"foo"</span><span class="nt">&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">currentScript</span> <span class="o">===</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">);</span> <span class="c1">// true</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">document.currentScript</code> 就是 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素节点。</p> <h4 id="28-documentimplementation">2.8 document.implementation</h4> <p><code class="language-plaintext highlighter-rouge">document.implementation</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">DOMImplementation</code> 对象。该对象有三个方法，主要用于创建独立于当前文档的新的 <code class="language-plaintext highlighter-rouge">Document</code> 对象。</p> <ul> <li><code class="language-plaintext highlighter-rouge">DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li> <li><code class="language-plaintext highlighter-rouge">DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li> <li><code class="language-plaintext highlighter-rouge">DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li> </ul> <p>下面是创建 HTML 文档的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">implementation</span><span class="p">.</span><span class="nf">createHTMLDocument</span><span class="p">(</span><span class="dl">'</span><span class="s1">Title</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">replaceChild</span><span class="p">(</span>
  <span class="nx">doc</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span>
<span class="p">);</span>
</code></pre></div></div> <p>上面代码中，第一步生成一个新的 HTML 文档 <code class="language-plaintext highlighter-rouge">doc</code>，然后用它的根元素 <code class="language-plaintext highlighter-rouge">doc.documentElement</code> 替换掉 <code class="language-plaintext highlighter-rouge">document.documentElement</code>。这会使得当前文档的内容全部消失，变成 <code class="language-plaintext highlighter-rouge">hello world</code>。</p> <h3 id="3-方法">3. 方法</h3> <h4 id="31-documentopendocumentclose">3.1 document.open()，document.close()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.open()</code> 清除当前文档所有内容，使得文档处于<strong>可写状态</strong>，供 <code class="language-plaintext highlighter-rouge">document.write</code> 方法写入内容。</li> <li><code class="language-plaintext highlighter-rouge">document.close()</code> 用来关闭 <code class="language-plaintext highlighter-rouge">document.open()</code> 打开的文档。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">open</span><span class="p">();</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
</code></pre></div></div> <h4 id="32-documentwritedocumentwriteln">3.2 document.write()，document.writeln()</h4> <p><code class="language-plaintext highlighter-rouge">document.write(markup)</code> 方法用于向当前文档写入内容。<code class="language-plaintext highlighter-rouge">document.write</code> 是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对 <code class="language-plaintext highlighter-rouge">innerHTML</code> 属性赋值）。所以，除了某些特殊情况，应该尽量<strong>避免使用</strong> <code class="language-plaintext highlighter-rouge">document.write()</code> 这个方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">document.write()</code> 会当作 HTML 代码解析，不会转义。</li> <li>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行 <code class="language-plaintext highlighter-rouge">document.close()</code>），<code class="language-plaintext highlighter-rouge">document.write()</code> 写入的内容就会追加在已有内容的后面。</li> <li>如果页面已经解析完成（<code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件发生之后）再调用 <code class="language-plaintext highlighter-rouge">write()</code> ，它会先调用 <code class="language-plaintext highlighter-rouge">open()</code> ，擦除当前文档所有内容，然后再写入。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document.writeln(line)</code> 与 <code class="language-plaintext highlighter-rouge">write()</code> 完全一致，除了会在输出内容的尾部添加换行符。注意，<code class="language-plaintext highlighter-rouge">document.writeln()</code> 添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入 <code class="language-plaintext highlighter-rouge">&lt;br&gt;</code>。</p> <h4 id="33-documentqueryselectordocumentqueryselectorall">3.3 document.querySelector()，document.querySelectorAll()</h4> <p><code class="language-plaintext highlighter-rouge">document.querySelector(selectors)</code> 接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回<strong>第一个</strong>匹配的节点。 <code class="language-plaintext highlighter-rouge">document.querySelectorAll(selectors)</code> 与 <code class="language-plaintext highlighter-rouge">querySelector()</code> 用法类似，区别是返回一个 <code class="language-plaintext highlighter-rouge">NodeList</code> 对象，包含所有匹配给定选择器的节点。</p> <p>这两个方法不支持 CSS 伪元素的选择器（比如 <code class="language-plaintext highlighter-rouge">:first-line</code> 和 <code class="language-plaintext highlighter-rouge">:first-letter</code>）和伪类的选择器（比如 <code class="language-plaintext highlighter-rouge">:link</code> 和 <code class="language-plaintext highlighter-rouge">:visited</code>），即无法选中伪元素和伪类。</p> <p>这两个方法都可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</p> <h4 id="34-documentgetelementbyiddocumentgetelementsbytagnamedocumentgetelementsbyclassnamedocumentgetelementsbyname">3.4 document.getElementById()，document.getElementsByTagName()，document.getElementsByClassName()，document.getElementsByName()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.getElementById(id)</code> 返回匹配指定 <code class="language-plaintext highlighter-rouge">id</code> 属性的元素节点。该方法的参数大小写敏感且只能在 <code class="language-plaintext highlighter-rouge">document</code> 对象上使用。</li> <li><code class="language-plaintext highlighter-rouge">document.getElementsByTagName(name)</code> 搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），可以<strong>实时</strong>反映 HTML 文档的变化。该方法可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</li> <li><code class="language-plaintext highlighter-rouge">document.getElementsByClassName(names)</code> 返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），包括了所有 <code class="language-plaintext highlighter-rouge">class</code> 名字符合指定条件的元素，元素的变化<strong>实时</strong>反映在返回结果中。该方法可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</li> <li><code class="language-plaintext highlighter-rouge">document.getElementsByName(name)</code> 用于选择拥有 <code class="language-plaintext highlighter-rouge">name</code> 属性的 HTML 元素（比如 <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;radio&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;frame&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;object&gt;</code> 等），返回一个类似数组的的对象（<code class="language-plaintext highlighter-rouge">NodeList</code> 实例），因为 <code class="language-plaintext highlighter-rouge">name</code> 属性相同的元素可能不止一个。</li> </ul> <h4 id="35-documentelementfrompointdocumentelementsfrompoint">3.5 document.elementFromPoint()，document.elementsFromPoint()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.elementFromPoint()</code> 返回位于页面指定位置<strong>最上层</strong>的元素节点。该方法的两个参数，依次是相对于当前视口<strong>左上角</strong>的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。</li> <li><code class="language-plaintext highlighter-rouge">document.elementsFromPoint()</code> 返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">elementFromPoint</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码选中在 <code class="language-plaintext highlighter-rouge">(50, 50)</code> 这个坐标位置的最上层的那个 HTML 元素。</p> <h4 id="36-documentcreateelementdocumentcreatetextnodedocumentcreateattributedocumentcreatecommentdocumentcreatedocumentfragmentdocumentcreateevent">3.6 document.createElement()，document.createTextNode()，document.createAttribute()，document.createComment()，document.createDocumentFragment()，document.createEvent()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">document.createDocumentFragment()</code> 生成一个空的文档片段对象（<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 实例）。<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</li> <li><code class="language-plaintext highlighter-rouge">document.createElement(tagName, options)</code> 用来生成元素节点，并返回该节点。参数为元素的标签名（不包含 <code class="language-plaintext highlighter-rouge">&lt;</code> 和 <code class="language-plaintext highlighter-rouge">&gt;</code>，否则会报错）。</li> <li><code class="language-plaintext highlighter-rouge">document.createAttribute(name)</code> 生成一个新的属性节点（Attr 实例），并返回它。参数是属性的名称。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.createTextNode(data)</code> 用来生成<strong>文本节点</strong>（Text 实例），并返回该节点。它的参数是文本节点的内容。</p> <ul> <li>该方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</li> <li> <p>该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;span&gt;Foo &amp; bar&lt;/span&gt;</span><span class="dl">'</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">)</span>
<span class="c1">// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt;</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">createTextNode()</code> 对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p> </li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">document.createComment(data)</code> 生成一个新的注释节点，并返回该节点。参数是一个字符。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.createEvent(type)</code> 生成一个事件对象（<code class="language-plaintext highlighter-rouge">Event</code> 实例），该对象可以被 <code class="language-plaintext highlighter-rouge">element.dispatchEvent()</code> 方法使用，触发指定事件。</p> <p><code class="language-plaintext highlighter-rouge">document.createEvent()</code> 的参数是事件类型，比如 <code class="language-plaintext highlighter-rouge">UIEvents</code>、<code class="language-plaintext highlighter-rouge">MouseEvents</code>、<code class="language-plaintext highlighter-rouge">MutationEvents</code>、<code class="language-plaintext highlighter-rouge">HTMLEvents</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">Event</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">event</span><span class="p">.</span><span class="nf">initEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">build</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">build</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span> <span class="c1">// "build"</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码新建了一个名为 <code class="language-plaintext highlighter-rouge">build</code> 的事件实例，然后触发该事件。</p> </li> </ul> <h4 id="37-documentaddeventlistenerdocumentremoveeventlistenerdocumentdispatchevent">3.7 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h4> <p>这三个方法用于处理 <code class="language-plaintext highlighter-rouge">document</code> 节点的事件。它们都继承自 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口，详细介绍参见《EventTarget 接口》一章。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 添加事件监听函数</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="c1">// 移除事件监听函数</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="c1">// 触发事件</span>
<span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
</code></pre></div></div> <h4 id="38-documenthasfocus">3.8 document.hasFocus()</h4> <p><code class="language-plaintext highlighter-rouge">document.hasFocus()</code> 返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p> <p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p> <h4 id="39-documentadoptnodedocumentimportnode">3.9 document.adoptNode()，document.importNode()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">document.adoptNode()</code> 将某个节点及其子节点，从原来所在的文档或 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 里面移除，归属当前 <code class="language-plaintext highlighter-rouge">document</code> 对象，返回插入后的新节点。插入的节点对象的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性，会变成当前的 <code class="language-plaintext highlighter-rouge">document</code> 对象，而 <code class="language-plaintext highlighter-rouge">parentNode</code> 属性是 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">adoptNode</span><span class="p">(</span><span class="nx">externalNode</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
</code></pre></div> </div> <p>注意，<code class="language-plaintext highlighter-rouge">document.adoptNode()</code> 只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用 <code class="language-plaintext highlighter-rouge">appendChild()</code> 方法或 <code class="language-plaintext highlighter-rouge">insertBefore()</code> 方法，将新节点插入当前文档树。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">document.importNode()</code> 从原来所在的文档或 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 里面，<strong>拷贝</strong>某个节点及其子节点，让它们归属当前 <code class="language-plaintext highlighter-rouge">document</code> 对象。拷贝的节点对象的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性，会变成当前的 <code class="language-plaintext highlighter-rouge">document</code> 对象，而 <code class="language-plaintext highlighter-rouge">parentNode</code> 属性是 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">importNode</span><span class="p">(</span><span class="nx">externalNode</span><span class="p">,</span> <span class="nx">deep</span><span class="p">);</span>
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">document.importNode()</code> 的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（<code class="language-plaintext highlighter-rouge">false</code>）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">document.importNode()</code> 只是拷贝外部节点，这时该节点的父节点是 <code class="language-plaintext highlighter-rouge">null</code>。下一步还必须将这个节点插入当前文档树。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">iframe</span><span class="dl">'</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">oldNode</span> <span class="o">=</span> <span class="nx">iframe</span><span class="p">.</span><span class="nx">contentWindow</span><span class="p">.</span><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myNode</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">importNode</span><span class="p">(</span><span class="nx">oldNode</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">container</span><span class="dl">"</span><span class="p">).</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码从 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口拷贝一个指定节点 <code class="language-plaintext highlighter-rouge">myNode</code> 插入当前文档。</p> </li> </ul> <h4 id="310-documentcreatenodeiteratordocumentcreatetreewalker">3.10 document.createNodeIterator()，document.createTreeWalker()</h4> <p><code class="language-plaintext highlighter-rouge">document.createNodeIterator(root, whatToShow, filter)</code> 返回一个子节点遍历器。<code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型。几种主要的节点类型写法如下。</p> <ul> <li>所有节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_ALL</code></li> <li>元素节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_ELEMENT</code></li> <li>文本节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_TEXT</code></li> <li>评论节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_COMMENT</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nodeIterator</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createNodeIterator</span><span class="p">(</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
  <span class="nx">NodeFilter</span><span class="p">.</span><span class="nx">SHOW_ELEMENT</span>
<span class="p">);</span>
</code></pre></div></div> <p>上面代码返回 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素子节点的遍历器。</p> <p><code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 返回一个“遍历器”对象（<code class="language-plaintext highlighter-rouge">NodeFilter</code> 实例）。该实例的 <code class="language-plaintext highlighter-rouge">nextNode()</code> 和 <code class="language-plaintext highlighter-rouge">previousNode()</code> 可以用来遍历所有子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nodeIterator</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createNodeIterator</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">pars</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">var</span> <span class="nx">currentNode</span><span class="p">;</span>
<span class="k">while </span><span class="p">(</span><span class="nx">currentNode</span> <span class="o">=</span> <span class="nx">nodeIterator</span><span class="p">.</span><span class="nf">nextNode</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">pars</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">currentNode</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，使用遍历器的 <code class="language-plaintext highlighter-rouge">nextNode()</code> 方法，将根节点的所有子节点，依次读入一个数组。<code class="language-plaintext highlighter-rouge">nextNode()</code> 方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">previousNode()</code> 方法则是先将指针移向上一个节点，然后返回该节点。</p> <p>注意，遍历器返回的第一个节点，总是<strong>根节点</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">document.createTreeWalker(root, whatToShow, filter)</code> 返回一个 DOM 的子树遍历器。它与 <code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 基本类似，区别在于它返回的是 <code class="language-plaintext highlighter-rouge">TreeWalker</code> 实例且第一个节点不是根节点。</p> <h4 id="311-documentexeccommanddocumentquerycommandsupporteddocumentquerycommandenabled">3.11 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()</h4> <h5 id="1documentexeccommand">（1）document.execCommand()</h5> <p>如果 <code class="language-plaintext highlighter-rouge">document.designMode</code> 属性设为 <code class="language-plaintext highlighter-rouge">on</code>，那么整个文档用户可编辑；如果元素的 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性设为 <code class="language-plaintext highlighter-rouge">true</code>，那么该元素可编辑。这两种情况下，可以使用 <code class="language-plaintext highlighter-rouge">document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)</code>，改变内容的样式，比如 <code class="language-plaintext highlighter-rouge">document.execCommand('bold')</code> 会使得字体加粗。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">execCommand</span><span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="nx">showDefaultUI</span><span class="p">,</span> <span class="nx">input</span><span class="p">)</span>
</code></pre></div></div> <p>该方法接受三个参数。</p> <ul> <li><code class="language-plaintext highlighter-rouge">command</code>：字符串，表示所要实施的样式。</li> <li><code class="language-plaintext highlighter-rouge">showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li><code class="language-plaintext highlighter-rouge">input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为 <code class="language-plaintext highlighter-rouge">true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的返回值是一个布尔值。如果为 <code class="language-plaintext highlighter-rouge">false</code>，表示这个方法无法生效。</p> <p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p> <h5 id="2documentquerycommandsupported">（2）document.queryCommandSupported()</h5> <p><code class="language-plaintext highlighter-rouge">document.queryCommandSupported(command)</code> 返回一个布尔值，表示浏览器是否支持 <code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的某个命令。</p> <h5 id="3documentquerycommandenabled">（3）document.queryCommandEnabled()</h5> <p><code class="language-plaintext highlighter-rouge">document.queryCommandEnabled(command)</code> 返回一个布尔值，表示当前是否可用 <code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的某个命令。比如，<code class="language-plaintext highlighter-rouge">bold</code>（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;input type="button" value="Copy" onclick="doCopy()"&gt;</span>

<span class="kd">function</span> <span class="nf">doCopy</span><span class="p">(){</span>
  <span class="c1">// 浏览器是否支持 copy 命令（选中内容复制到剪贴板）</span>
  <span class="k">if </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">queryCommandSupported</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
    <span class="nf">copyText</span><span class="p">(</span><span class="dl">'</span><span class="s1">你好</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">浏览器不支持</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">copyText</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">textarea</span><span class="dl">'</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
  <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">text</span><span class="p">;</span>
  <span class="nx">input</span><span class="p">.</span><span class="nf">focus</span><span class="p">();</span>
  <span class="nx">input</span><span class="p">.</span><span class="nf">select</span><span class="p">();</span>

  <span class="c1">// 当前是否有选中文字</span>
  <span class="k">if </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">queryCommandEnabled</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">success</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">execCommand</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">input</span><span class="p">.</span><span class="nf">remove</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Copy Ok</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">queryCommandEnabled is false</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，先判断浏览器是否支持 <code class="language-plaintext highlighter-rouge">copy</code> 命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。</p> <h4 id="312-documentgetselection">3.12 document.getSelection()</h4> <p>这个方法指向 <code class="language-plaintext highlighter-rouge">window.getSelection()</code>，参见 <code class="language-plaintext highlighter-rouge">window</code> 对象一节的介绍。</p> <h2 id="六element-节点">六、Element 节点</h2> <h3 id="1-简介">1. 简介</h3> <p><code class="language-plaintext highlighter-rouge">Element</code> 节点对象对应网页的 HTML 元素。每个 HTML 元素，在 DOM 树上都会转化成一个 <code class="language-plaintext highlighter-rouge">Element</code> 节点对象。不同的 HTML 元素对应不同的的元素节点，浏览器使用不同的构造函数，生成不同的元素节点，比如 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 元素的构造函数是<code class="language-plaintext highlighter-rouge">HTMLAnchorElement()</code>，<code class="language-plaintext highlighter-rouge">&lt;button&gt;</code> 是 <code class="language-plaintext highlighter-rouge">HTMLButtonElement()</code>。因此，元素节点不是一种对象，而是许多种对象，这些对象除了继承 <code class="language-plaintext highlighter-rouge">Element</code> 对象的属性和方法，还有各自独有的属性和方法。</p> <h3 id="2-实例属性">2. 实例属性</h3> <h4 id="21-元素特性的相关属性">2.1 元素特性的相关属性</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.id</code>：返回指定元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性，该属性可读写。</li> <li><code class="language-plaintext highlighter-rouge">Element.tagName</code>：返回指定元素的大写标签名，与 <code class="language-plaintext highlighter-rouge">nodeName</code> 属性的值相等。</li> <li><code class="language-plaintext highlighter-rouge">Element.dir</code>：用于读写当前元素的文字方向，可能是从左到右（”<code class="language-plaintext highlighter-rouge">ltr</code>“），也可能是从右到左（”<code class="language-plaintext highlighter-rouge">rtl</code>“）。</li> <li><code class="language-plaintext highlighter-rouge">Element.accessKey</code>：用于读写分配给当前元素的快捷键。</li> <li><code class="language-plaintext highlighter-rouge">Element.draggable</code>：返回一个布尔值，表示当前元素是否可拖动。该属性<strong>可读写</strong>。</li> <li><code class="language-plaintext highlighter-rouge">Element.lang</code>：返回当前元素的语言设置。该属性<strong>可读写</strong>。</li> <li> <p><code class="language-plaintext highlighter-rouge">Element.tabIndex</code>：返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性<strong>可读写</strong>。</p> <ul> <li>如果是正整数，则按照顺序，从小到大遍历。</li> <li>如果是负值（通常是 <code class="language-plaintext highlighter-rouge">-1</code>），则 Tab 键不会遍历到该元素。</li> <li>如果两个元素的 <code class="language-plaintext highlighter-rouge">tabIndex</code> 属性的正整数值相同，则按照出现的顺序遍历。</li> <li>遍历完所有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 为正整数的元素以后，再遍历所有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 等于 <code class="language-plaintext highlighter-rouge">0</code>、或者属性值是非法值、或者没有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 属性的元素，顺序为它们在网页中出现的顺序。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">Element.title</code>：用来读写当前元素的 HTML 属性 <code class="language-plaintext highlighter-rouge">title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</li> </ul> <h4 id="22-元素状态的相关属性">2.2 元素状态的相关属性</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.hidden</code>：返回一个布尔值，表示当前 HTML 元素的 <code class="language-plaintext highlighter-rouge">hidden</code> 属性的值。该属性<strong>可读写</strong>，用来控制当前元素<strong>是否可见</strong>。</p> <ul> <li>该属性与 CSS 设置互相独立。CSS 对当前元素可见性的设置，<code class="language-plaintext highlighter-rouge">Element.hidden</code> 并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</li> <li>CSS 设置的优先级高于 <code class="language-plaintext highlighter-rouge">Element.hidden</code>。如果 CSS 指定了该元素不可见（<code class="language-plaintext highlighter-rouge">display: none</code>）或可见（<code class="language-plaintext highlighter-rouge">visibility: visible</code>），那么 <code class="language-plaintext highlighter-rouge">Element.hidden</code> 并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.contentEditable</code>：返回一个字符串，表示是否设置了 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性，HTML 元素可以设置 <code class="language-plaintext highlighter-rouge">contentEditable</code> 属性，使得元素的内容可以编辑。有三种可能的值。该属性可写。</p> <ul> <li><code class="language-plaintext highlighter-rouge">"true"</code>：元素内容可编辑；</li> <li><code class="language-plaintext highlighter-rouge">"false"</code>：元素内容不可编辑；</li> <li><code class="language-plaintext highlighter-rouge">"inherit"</code>：元素是否可编辑，继承了父元素的设置。</li> </ul> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">contenteditable</span><span class="nt">&gt;</span>123<span class="nt">&lt;/div&gt;</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.isContentEditable</code>：返回一个布尔值，同样表示是否设置了 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性。该属性只读。</p> </li> </ul> <h4 id="23-elementattributes">2.3 Element.attributes</h4> <p><code class="language-plaintext highlighter-rouge">Element.attributes</code> 属性返回一个类似数组的对象，成员是当前元素节点的所有<strong>属性节点</strong>。</p> <h4 id="24-elementclassnameelementclasslist">2.4 Element.className，Element.classList</h4> <ul> <li><code class="language-plaintext highlighter-rouge">className</code> 属性用来读写当前元素节点的 <code class="language-plaintext highlighter-rouge">class</code> 属性。它的值是一个字符串，每个 <code class="language-plaintext highlighter-rouge">class</code> 之间用空格分割。</li> <li><code class="language-plaintext highlighter-rouge">classList</code> 属性返回一个类似数组的<strong>对象</strong>，当前元素节点的每个 <code class="language-plaintext highlighter-rouge">class</code> 就是这个对象的一个成员。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码 &lt;div class="one two three" id="myDiv"&gt;&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">className</span>
<span class="c1">// "one two three"</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span>
<span class="c1">// {</span>
<span class="c1">//   0: "one"</span>
<span class="c1">//   1: "two"</span>
<span class="c1">//   2: "three"</span>
<span class="c1">//   length: 3</span>
<span class="c1">// }</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">classList</code> 对象有下列方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">add()</code>：增加一个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li><code class="language-plaintext highlighter-rouge">remove()</code>：移除一个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li><code class="language-plaintext highlighter-rouge">contains()</code>：检查当前元素是否包含某个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li><code class="language-plaintext highlighter-rouge">toggle()</code>：将某个 <code class="language-plaintext highlighter-rouge">class</code> 移入或移出当前元素，该方法可以接受一个布尔值，作为第二个参数。如果为 <code class="language-plaintext highlighter-rouge">true</code>，则添加该属性；如果为 <code class="language-plaintext highlighter-rouge">false</code>，则去除该属性。。</li> <li><code class="language-plaintext highlighter-rouge">item()</code>：返回指定索引位置的 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li><code class="language-plaintext highlighter-rouge">toString()</code>：将 <code class="language-plaintext highlighter-rouge">class</code> 的列表转为字符串。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">toggle</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 如果 myCssClass 不存在就加入，否则移除</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 返回 true 或者 false</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 返回第一个 Class</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">toString</span><span class="p">();</span>
</code></pre></div></div> <h4 id="25-elementdataset">2.5 Element.dataset</h4> <p>网页元素可以自定义 <code class="language-plaintext highlighter-rouge">data-</code> 属性，用来添加数据。<code class="language-plaintext highlighter-rouge">Element.dataset</code> 属性返回一个对象，可以从这个对象读写 <code class="language-plaintext highlighter-rouge">data-</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &lt;article</span>
<span class="c1">//   id="foo"</span>
<span class="c1">//   data-columns="3"</span>
<span class="c1">//   data-index-number="12314"</span>
<span class="c1">//   data-parent="cars"&gt;</span>
<span class="c1">//   ...</span>
<span class="c1">// &lt;/article&gt;</span>
<span class="kd">var</span> <span class="nx">article</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">columns</span> <span class="c1">// "3"</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">indexNumber</span> <span class="c1">// "12314"</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">parent</span> <span class="c1">// "cars"</span>
</code></pre></div></div> <p>HTML 代码中，<code class="language-plaintext highlighter-rouge">data-</code> 属性的属性名，只能包含英文字母、数字、连词线（<code class="language-plaintext highlighter-rouge">-</code>）、点（<code class="language-plaintext highlighter-rouge">.</code>）、冒号（<code class="language-plaintext highlighter-rouge">:</code>）和下划线（<code class="language-plaintext highlighter-rouge">_</code>）。它们转成 JavaScript 对应的 <code class="language-plaintext highlighter-rouge">dataset</code> 属性名，规则如下。</p> <ul> <li>开头的 <code class="language-plaintext highlighter-rouge">data-</code> 会省略。</li> <li>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</li> <li>其他字符不变。</li> </ul> <p>因此，<code class="language-plaintext highlighter-rouge">data-abc-def</code> 对应 <code class="language-plaintext highlighter-rouge">dataset.abcDef</code>，<code class="language-plaintext highlighter-rouge">data-abc-1</code> 对应 <code class="language-plaintext highlighter-rouge">dataset["abc-1"]</code>。</p> <p>除了使用 <code class="language-plaintext highlighter-rouge">dataset</code> 读写 <code class="language-plaintext highlighter-rouge">data-</code> 属性，也可以使用 <code class="language-plaintext highlighter-rouge">Element.getAttribute()</code> 和 <code class="language-plaintext highlighter-rouge">Element.setAttribute()</code>，通过完整的属性名读写这些属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mydiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">mydiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">mydiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">mydiv</span><span class="p">.</span><span class="nf">getAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">data-foo</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "bar"</span>
</code></pre></div></div> <h4 id="26-elementinnerhtmelementouterhtml">2.6 Element.innerHTM，Element.outerHTML</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.innerHTML</code> 属性返回一个字符串，表示该元素<strong>包含的</strong>所有 HTML 代码。该属性<strong>可读写</strong>，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括 <code class="language-plaintext highlighter-rouge">&lt;HTML&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素。</p> <ul> <li>如果将 <code class="language-plaintext highlighter-rouge">innerHTML</code> 属性设为空，等于删除所有它包含的所有节点。</li> <li>读取属性值的时候，如果文本节点包含 <code class="language-plaintext highlighter-rouge">&amp;</code>、小于号（<code class="language-plaintext highlighter-rouge">&lt;</code>）和大于号（<code class="language-plaintext highlighter-rouge">&gt;</code>），<code class="language-plaintext highlighter-rouge">innerHTML</code> 属性会将它们转为实体形式 <code class="language-plaintext highlighter-rouge">&amp;amp;</code>、<code class="language-plaintext highlighter-rouge">&amp;lt;</code>、<code class="language-plaintext highlighter-rouge">&amp;gt;</code>。</li> <li>如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签，虽然可以生成 <code class="language-plaintext highlighter-rouge">script</code> 节点，但是插入的代码不会执行。</li> <li>如果想得到原文，或者为了安全考虑，如果插入的是文本，最好用 <code class="language-plaintext highlighter-rouge">Element.textContent</code> 属性代替 <code class="language-plaintext highlighter-rouge">innerHTML</code>。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML代码如下 &lt;p id="para"&gt; 5 &gt; 3 &lt;/p&gt;</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span>
<span class="c1">// 5 &amp;gt; 3</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.outerHTML</code> 属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括<strong>该元素</strong>本身和<strong>所有子元素</strong>，该属性<strong>可读写</strong>。如果一个节点没有父节点，设置 <code class="language-plaintext highlighter-rouge">outerHTML</code> 属性会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d</span><span class="p">.</span><span class="nx">outerHTML</span>
<span class="c1">// '&lt;div id="d"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;'</span>
</code></pre></div> </div> </li> </ul> <h4 id="27-elementclientwidthelementclientheightelementclientleftelementclienttop">2.7 Element.clientWidth，Element.clientHeight，Element.clientLeft，Element.clientTop</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.clientWidth</code> 属性返回元素节点的 <strong>CSS 宽度</strong>（单位像素），只对<strong>块级元素</strong>有效，包括元素本身的宽度和 <code class="language-plaintext highlighter-rouge">padding</code>（不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code>），如果有垂直滚动条，还要减去垂直滚动条的宽度。</li> <li> <p><code class="language-plaintext highlighter-rouge">Element.clientHeight</code> 属性返回元素节点的 <strong>CSS 高度</strong>（单位像素），只对<strong>块级元素</strong>生效，包括元素本身的高度和 <code class="language-plaintext highlighter-rouge">padding</code>（不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code>），对于行内元素返回 <code class="language-plaintext highlighter-rouge">0</code>。如果块级元素没有设置 CSS 高度，则返回实际高度。</p> <ul> <li><code class="language-plaintext highlighter-rouge">document.documentElement</code> 的 <code class="language-plaintext highlighter-rouge">clientHeight</code> 属性，返回当前<strong>视口</strong>的高度（即浏览器窗口的高度），等同于 <code class="language-plaintext highlighter-rouge">window.innerHeight</code> 属性减去水平滚动条的高度（如果有的话）。</li> <li><code class="language-plaintext highlighter-rouge">document.body</code> 的高度返回<strong>网页</strong>的<strong>实际高度</strong>。</li> </ul> <p>一般来说，<code class="language-plaintext highlighter-rouge">document.body.clientHeight</code> 大于 <code class="language-plaintext highlighter-rouge">document.documentElement.clientHeight</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">clientHeight</span> <span class="c1">// 视口高度</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">clientHeight</span> <span class="c1">// 网页总高度</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">Element.clientLeft</code> 属性等于元素节点<strong>左边框</strong>（left border）的<strong>宽度</strong>（单位像素），不包括左侧的 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">margin</code>。如果没有设置左边框，或者是行内元素（<code class="language-plaintext highlighter-rouge">display: inline</code>），该属性返回 <code class="language-plaintext highlighter-rouge">0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</li> <li><code class="language-plaintext highlighter-rouge">Element.clientTop</code> 属性等于网页元素<strong>顶部边框</strong>的<strong>宽度</strong>（单位像素），其他特点都与 <code class="language-plaintext highlighter-rouge">clientLeft</code> 相同。</li> </ul> <h4 id="28-elementscrollwidthelementscrollheightelementscrollleftelementscrolltop">2.8 Element.scrollWidth，Element.scrollHeight，Element.scrollLeft，Element.scrollTop</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.scrollWidth</code> 和 <code class="language-plaintext highlighter-rouge">Element.scrollHeight</code> 属性返回一个整数值（小数会四舍五入），表示当前元素的总宽度和总高度（单位像素）。</p> <p>整张网页的总高度可以从 <code class="language-plaintext highlighter-rouge">document.documentElement</code> 或 <code class="language-plaintext highlighter-rouge">document.body</code> 上读取。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 返回网页的总高度</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollHeight</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">scrollHeight</span>
</code></pre></div> </div> </li> </ul> <p>这两个属性都包括溢出容器部分、当前不可见的部分、<code class="language-plaintext highlighter-rouge">padding</code> 和伪元素（<code class="language-plaintext highlighter-rouge">::before</code> 或 <code class="language-plaintext highlighter-rouge">::after</code>）的高度，但是不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code> 以及水平滚动条的高度（如果有水平滚动条的话）。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Element.scrollLeft</code> 属性表示当前元素的水平滚动条向右侧滚动的像素数量。</li> <li><code class="language-plaintext highlighter-rouge">Element.scrollTop</code> 属性表示当前元素的垂直滚动条向下滚动的像素数量。</li> </ul> <p>如果要查看整张网页的水平的和垂直的滚动距离，要从 <code class="language-plaintext highlighter-rouge">document.documentElement</code> 元素上读取。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollLeft</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollTop</span>
</code></pre></div></div> <h4 id="29-elementoffsetwidthelementoffsetheightelementoffsetleftelementoffsettopelementoffsetparent">2.9 Element.offsetWidth，Element.offsetHeight，Element.offsetLeft，Element.offsetTop，Element.offsetParent</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.offsetWidth</code> 属性表示元素的 CSS <strong>水平宽度</strong>（单位像素），包括元素本身的宽度、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>，以及垂直滚动条的宽度（如果存在滚动条）。</li> <li><code class="language-plaintext highlighter-rouge">Element.offsetHeight</code> 属性表示元素的 CSS <strong>垂直高度</strong>（单位像素），包括元素本身的高度、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>，以及水平滚动条的高度（如果存在滚动条）。</li> </ul> <p>这两个属性都是<strong>只读</strong>属性，只比 <code class="language-plaintext highlighter-rouge">Element.clientHeight</code> 和 <code class="language-plaintext highlighter-rouge">Element.clientWidth</code> 多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如 <code class="language-plaintext highlighter-rouge">display: none;</code>），则返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.offsetParent</code> 属性返回最靠近当前元素的、并且 CSS 的 <code class="language-plaintext highlighter-rouge">position</code> 属性不等于 <code class="language-plaintext highlighter-rouge">static</code> 的上层元素。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">"position: absolute;"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p&gt;</span>
    <span class="nt">&lt;span&gt;</span>Hello<span class="nt">&lt;/span&gt;</span>
  <span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">span</code> 元素的 <code class="language-plaintext highlighter-rouge">offsetParent</code> 属性是 <code class="language-plaintext highlighter-rouge">div</code> 元素。</p> </li> <li><code class="language-plaintext highlighter-rouge">Element.offsetLeft</code> 返回当前元素左上角相对于 <code class="language-plaintext highlighter-rouge">Element.offsetParent</code> 节点的水平位移。</li> <li><code class="language-plaintext highlighter-rouge">Element.offsetTop</code> 返回垂直位移，单位为像素。</li> </ul> <p>通常，<code class="language-plaintext highlighter-rouge">Element.offsetLeft</code> 和 <code class="language-plaintext highlighter-rouge">Element.offsetTop</code> 是指相对于父节点的位移。</p> <h4 id="210-elementstyle">2.10 Element.style</h4> <p><code class="language-plaintext highlighter-rouge">style</code> 属性用来读写该元素的行内样式信息。</p> <h4 id="211-elementchildrenelementchildelementcountelementfirstelementchildelementlastelementchild">2.11 Element.children，Element.childElementCount，Element.firstElementChild，Element.lastElementChild</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.children</code> 属性返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），包括当前<strong>元素节点</strong>的所有子元素。</li> <li><code class="language-plaintext highlighter-rouge">Element.childElementCount</code> 属性返回当前元素节点包含的子元素节点的个数，与 <code class="language-plaintext highlighter-rouge">Element.children.length</code> 的值相同。</li> <li><code class="language-plaintext highlighter-rouge">Element.firstElementChild</code> 属性返回当前元素的第一个元素子节点。</li> <li><code class="language-plaintext highlighter-rouge">Element.lastElementChild</code> 属性返回当前元素的最后一个元素子节点。</li> </ul> <h4 id="212-elementnextelementsiblingelementpreviouselementsibling">2.12 Element.nextElementSibling，Element.previousElementSibling</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.previousElementSibling</code> 属性返回当前元素节点的前一个同级元素节点。</li> <li><code class="language-plaintext highlighter-rouge">Element.nextElementSibling</code> 属性返回当前元素节点的后一个同级元素节点。</li> </ul> <h3 id="3-实例方法">3. 实例方法</h3> <h4 id="31-属性相关方法">3.1 属性相关方法</h4> <p>元素节点提供六个方法，用来操作属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getAttribute()</code>：读取某个属性的值。</li> <li><code class="language-plaintext highlighter-rouge">getAttributeNames()</code>：返回当前元素的所有属性名。</li> <li><code class="language-plaintext highlighter-rouge">setAttribute()</code>：写入属性值。</li> <li><code class="language-plaintext highlighter-rouge">hasAttribute()</code>：某个属性是否存在。</li> <li><code class="language-plaintext highlighter-rouge">hasAttributes()</code>：当前元素是否有属性。</li> <li><code class="language-plaintext highlighter-rouge">removeAttribute()</code>：删除属性。</li> </ul> <h4 id="31-elementqueryselectorelementqueryselectorall">3.1 Element.querySelector()，Element.querySelectorAll()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.querySelector(selectors)</code> 接受 CSS 选择器作为参数（多个选择器之间用逗号分隔），返回父元素的<strong>第一个</strong>匹配的子元素。该方法可以接受复杂的 CSS 选择器。</p> <p>浏览器执行 <code class="language-plaintext highlighter-rouge">querySelector()</code> 时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码</span>
<span class="c1">// &lt;div&gt;</span>
<span class="c1">// &lt;blockquote id="outer"&gt;</span>
<span class="c1">//   &lt;p&gt;Hello&lt;/p&gt;</span>
<span class="c1">//   &lt;div id="inner"&gt;</span>
<span class="c1">//     &lt;p&gt;World&lt;/p&gt;</span>
<span class="c1">//   &lt;/div&gt;</span>
<span class="c1">// &lt;/blockquote&gt;</span>
<span class="c1">// &lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">outer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">outer</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">outer</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// &lt;p&gt;Hello&lt;/p&gt;</span>
</code></pre></div> </div> <p>上面代码实际上返回的是第一个 <code class="language-plaintext highlighter-rouge">p</code> 元素，而不是第二个。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.querySelectorAll(selectors)</code> 接受 CSS 选择器作为参数多个选择器之间用逗号分隔），返回一个 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例，包含所有匹配的子元素。该方法的执行机制与 <code class="language-plaintext highlighter-rouge">querySelector</code> 方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。</p> </li> </ul> <h4 id="32-elementgetelementsbyclassnameelementgetelementsbytagname">3.2 Element.getElementsByClassName()，Element.getElementsByTagName()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.getElementsByClassName(names)</code> 返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是<strong>当前节点</strong>的所有具有指定 <code class="language-plaintext highlighter-rouge">class</code> 的子元素节点。</li> <li><code class="language-plaintext highlighter-rouge">Element.getElementsByTagName(tagName)</code> 返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是<strong>当前节点</strong>的所有匹配指定标签名的子元素节点。</li> </ul> <p>这两个方法与 <code class="language-plaintext highlighter-rouge">document.getElementsByClassName()</code> 的用法类似，只是搜索范围不是整个文档，而是<strong>当前</strong>元素节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nf">getElementsByClassName</span><span class="p">(</span><span class="dl">'</span><span class="s1">red test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">table</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">td</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <h4 id="33-elementclosest">3.3 Element.closest()</h4> <p><code class="language-plaintext highlighter-rouge">Element.closest(selectors)</code> 方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个<strong>祖先节点</strong>（包括当前节点本身）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;article&gt;</span>
<span class="c1">//   &lt;div id="div-01"&gt;Here is div-01</span>
<span class="c1">//     &lt;div id="div-02"&gt;Here is div-02</span>
<span class="c1">//       &lt;div id="div-03"&gt;Here is div-03&lt;/div&gt;</span>
<span class="c1">//     &lt;/div&gt;</span>
<span class="c1">//   &lt;/div&gt;</span>
<span class="c1">// &lt;/article&gt;</span>
<span class="kd">var</span> <span class="nx">div03</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">div-03</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// div-03 最近的祖先节点</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">#div-02</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// div-02</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">div div</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// div-03</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">article &gt; div</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//div-01</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">:not(div)</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// article</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">closest()</code> 将当前节点也考虑在内，所以第二个 <code class="language-plaintext highlighter-rouge">closest()</code> 方法返回 <code class="language-plaintext highlighter-rouge">div-03</code>。</p> <h4 id="34-elementmatches">3.4 Element.matches()</h4> <p><code class="language-plaintext highlighter-rouge">Element.matches(selectors)</code> 返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p> <h4 id="35-事件相关方法">3.5 事件相关方法</h4> <p>以下三个方法与 <code class="language-plaintext highlighter-rouge">Element</code> 节点的事件相关。这些方法都继承自 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口，详见相关章节。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Element.addEventListener()</code>：添加事件的回调函数</li> <li><code class="language-plaintext highlighter-rouge">Element.removeEventListener()</code>：移除事件监听函数</li> <li><code class="language-plaintext highlighter-rouge">Element.dispatchEvent()</code>：触发事件</li> </ul> <h4 id="36-elementscrollintoview">3.6 Element.scrollIntoView()</h4> <p><code class="language-plaintext highlighter-rouge">Element.scrollIntoView(alignToTop | options)</code> 滚动当前元素，进入浏览器的可见区域，类似于设置 <code class="language-plaintext highlighter-rouge">window.location.hash</code> 的效果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nf">scrollIntoView</span><span class="p">();</span> <span class="c1">// 等同于 el.scrollIntoView(true)</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">scrollIntoView</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p>该方法可以接受一个布尔值作为参数。如果为 <code class="language-plaintext highlighter-rouge">true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为 <code class="language-plaintext highlighter-rouge">false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <h4 id="37-elementgetboundingclientrectelementgetclientrects">3.7 Element.getBoundingClientRect()，Element.getClientRects()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 返回一个 <code class="language-plaintext highlighter-rouge">rect</code> 对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。该对象具有以下属性（全部为只读）。</p> <ul> <li><code class="language-plaintext highlighter-rouge">x</code>：元素左上角相对于视口的横坐标</li> <li><code class="language-plaintext highlighter-rouge">y</code>：元素左上角相对于视口的纵坐标</li> <li><code class="language-plaintext highlighter-rouge">left</code>：元素左上角相对于视口的横坐标，与 <code class="language-plaintext highlighter-rouge">x</code> 属性相等</li> <li><code class="language-plaintext highlighter-rouge">right</code>：元素右边界相对于视口的横坐标（等于 <code class="language-plaintext highlighter-rouge">x + width</code>）</li> <li><code class="language-plaintext highlighter-rouge">top</code>：元素顶部相对于视口的纵坐标，与 <code class="language-plaintext highlighter-rouge">y</code> 属性相等</li> <li><code class="language-plaintext highlighter-rouge">bottom</code>：元素底部相对于视口的纵坐标（等于 <code class="language-plaintext highlighter-rouge">y + height</code>）</li> <li><code class="language-plaintext highlighter-rouge">width</code>：元素宽度</li> <li><code class="language-plaintext highlighter-rouge">height</code>：元素高度</li> </ul> <p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将 <code class="language-plaintext highlighter-rouge">left</code> 属性加上 <code class="language-plaintext highlighter-rouge">window.scrollX</code>，<code class="language-plaintext highlighter-rouge">top</code> 属性加上 <code class="language-plaintext highlighter-rouge">window.scrollY</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 的所有属性，都把边框（<code class="language-plaintext highlighter-rouge">border</code> 属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，<code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code> 包括了元素本身 + <code class="language-plaintext highlighter-rouge">padding</code> + <code class="language-plaintext highlighter-rouge">border</code>。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.getClientRects()</code> 返回一个类似数组的<strong>对象</strong>，里面是当前元素在页面上形成的所有<strong>矩形</strong>（所以方法名中的 Rect 用的是复数）。每个矩形都有 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">bottom</code>、<code class="language-plaintext highlighter-rouge">left</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code> 六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p> <p>对于盒状元素（比如 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和 <code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 的主要区别，后者对于行内元素总是返回一个矩形。</p> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">inline</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">().</span><span class="nx">length</span> <span class="c1">// 3</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">left</span> <span class="c1">// 8</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">right</span> <span class="c1">// 113.908203125</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">bottom</span> <span class="c1">// 31.200000762939453</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">height</span> <span class="c1">// 23.200000762939453</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">width</span> <span class="c1">// 105.908203125</span>
</code></pre></div></div> <p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p> <h4 id="38-elementinsertadjacentelementelementinsertadjacenthtmlelementinsertadjacenttext">3.8 Element.insertAdjacentElement()，Element.insertAdjacentHTML()，Element.insertAdjacentText()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.insertAdjacentElement(position, element)</code> 在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点。</li> <li><code class="language-plaintext highlighter-rouge">Element.insertAdjacentHTML(position, text)</code> 用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</li> <li><code class="language-plaintext highlighter-rouge">Element.insertAdjacentText(where, data)</code> 在相对于当前节点的指定位置，插入一个文本节点。</li> </ul> <p>这三个方法都可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点/待解析的 HTML 字符串/将要插入的文本内容。第一个参数只可以取如下的值。</p> <ul> <li><code class="language-plaintext highlighter-rouge">beforebegin</code>：当前元素之前</li> <li><code class="language-plaintext highlighter-rouge">afterbegin</code>：当前元素内部的第一个子节点前面</li> <li><code class="language-plaintext highlighter-rouge">beforeend</code>：当前元素内部的最后一个子节点后面</li> <li><code class="language-plaintext highlighter-rouge">afterend</code>：当前元素之后</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码：&lt;div id="one"&gt;one&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">one</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d1</span><span class="p">.</span><span class="nf">insertAdjacentHTML</span><span class="p">(</span><span class="dl">'</span><span class="s1">afterend</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&lt;div id="two"&gt;two&lt;/div&gt;</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 执行后的 HTML 代码：</span>
<span class="c1">// &lt;div id="one"&gt;one&lt;/div&gt;&lt;div id="two"&gt;two&lt;/div&gt;</span>
</code></pre></div></div> <h4 id="39-elementremove">3.9 Element.remove()</h4> <p><code class="language-plaintext highlighter-rouge">Element.remove()</code> 继承自 <code class="language-plaintext highlighter-rouge">ChildNode</code> 接口，用于将当前元素节点从它的父节点移除。</p> <h4 id="310-elementfocuselementblur">3.10 Element.focus()，Element.blur()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.focus()</code> 用于将当前页面的焦点，转移到指定元素上。<code class="language-plaintext highlighter-rouge">document.activeElement</code> 属性可以得到当前获得焦点的元素。</li> <li><code class="language-plaintext highlighter-rouge">Element.blur()</code> 用于将焦点从指定元素移除。</li> </ul> <p><code class="language-plaintext highlighter-rouge">Element.focus()</code> 可以接受一个对象作为参数。参数对象的 <code class="language-plaintext highlighter-rouge">preventScroll</code> 属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getFocus</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">btn</span><span class="dl">'</span><span class="p">).</span><span class="nf">focus</span><span class="p">({</span> <span class="na">preventScroll</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码会让 <code class="language-plaintext highlighter-rouge">btn</code> 元素获得焦点，并滚动到可见区域。</p> <h4 id="311-elementclick">3.11 Element.click()</h4> <p><code class="language-plaintext highlighter-rouge">Element.click()</code> 用于在当前元素上模拟一次鼠标点击，相当于触发了 <code class="language-plaintext highlighter-rouge">click</code> 事件。</p> <h2 id="七属性的操作">七、属性的操作</h2> <h3 id="1-elementattributes-属性">1. Element.attributes 属性</h3> <p><code class="language-plaintext highlighter-rouge">attributes</code> 属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的<strong>实时</strong>变化都会反映在这个节点对象上。</p> <h3 id="2-元素的标准属性">2. 元素的标准属性</h3> <p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。这些属性都是可写的。</p> <p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如 <code class="language-plaintext highlighter-rouge">onClick</code>。</p> <h3 id="3-属性操作的标准方法">3. 属性操作的标准方法</h3> <h4 id="31-概述">3.1 概述</h4> <p>元素节点提供六个方法，用来操作属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">getAttributeNames()</code></li> <li><code class="language-plaintext highlighter-rouge">setAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">hasAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">hasAttributes()</code></li> <li><code class="language-plaintext highlighter-rouge">removeAttribute()</code></li> </ul> <h4 id="32-elementgetattribute">3.2 Element.getAttribute()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">Element.getAttribute(property)</code> 方法返回当前元素节点的指定属性。</li> <li><code class="language-plaintext highlighter-rouge">Element.getAttributeNames()</code> 返回一个数组，成员是当前元素的所有属性的名字。</li> <li><code class="language-plaintext highlighter-rouge">Element.setAttribute(property, value)</code> 方法用于为当前元素节点新增属性。</li> <li><code class="language-plaintext highlighter-rouge">Element.hasAttribute(property)</code> 方法返回一个布尔值，表示当前元素节点是否包含指定属性。</li> <li><code class="language-plaintext highlighter-rouge">Element.hasAttributes()</code> 方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回 <code class="language-plaintext highlighter-rouge">false</code>，否则返回 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li><code class="language-plaintext highlighter-rouge">Element.removeAttribute(property)</code> 方法移除指定属性。该方法没有返回值。</li> </ul> <h3 id="4-dataset-属性">4. dataset 属性</h3> <p>参考 <a href="#25-elementdataset">Element.dataset</a>。</p> <h2 id="八text-节点和-documentfragment-节点">八、Text 节点和 DocumentFragment 节点</h2> <h3 id="1-text-节点的概念">1. Text 节点的概念</h3> <p>文本节点（<code class="language-plaintext highlighter-rouge">Text</code>）代表元素节点（<code class="language-plaintext highlighter-rouge">Element</code>）和属性节点（<code class="language-plaintext highlighter-rouge">Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p> <p>通常我们使用父节点的 <code class="language-plaintext highlighter-rouge">firstChild</code>、<code class="language-plaintext highlighter-rouge">nextSibling</code> 等属性获取文本节点，或者使用 <code class="language-plaintext highlighter-rouge">Document</code> 节点的 <code class="language-plaintext highlighter-rouge">createTextNode()</code> 创造一个文本节点。</p> <p>浏览器原生提供一个 <code class="language-plaintext highlighter-rouge">Text</code> 构造函数。它返回一个文本节点实例，参数是该文本节点的文本内容。</p> <p>文本节点除了继承 <code class="language-plaintext highlighter-rouge">Node</code> 接口，还继承了 <code class="language-plaintext highlighter-rouge">CharacterData</code> 接口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">text1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Text</span><span class="p">();</span> <span class="c1">// 空字符串</span>
<span class="kd">var</span> <span class="nx">text2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Text</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is a text node</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 非空字符串</span>
</code></pre></div></div> <p>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code class="language-plaintext highlighter-rouge">&lt;p&gt; &lt;/p&gt;</code>包含一个空格，它的子节点就是一个文本节点。</p> <h3 id="2-text-节点的属性">2. Text 节点的属性</h3> <ul> <li><code class="language-plaintext highlighter-rouge">data</code> 属性等同于 <code class="language-plaintext highlighter-rouge">nodeValue</code> 属性，用来设置或读取文本节点的内容。</li> <li><code class="language-plaintext highlighter-rouge">length</code> 属性返回当前文本节点的文本长度。</li> <li><code class="language-plaintext highlighter-rouge">previousElementSibling</code> 属性返回当前文本节点前面最近的同级元素节点。</li> <li><code class="language-plaintext highlighter-rouge">nextElementSibling</code> 属性返回紧跟在当前文本节点后面的那个同级元素节点。</li> <li> <p><code class="language-plaintext highlighter-rouge">wholeText</code> 属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，<code class="language-plaintext highlighter-rouge">wholeText</code> 属性的返回值，与 <code class="language-plaintext highlighter-rouge">data</code> 属性和 <code class="language-plaintext highlighter-rouge">textContent</code> 属性相同。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &lt;p id="para"&gt;A &lt;em&gt;B&lt;/em&gt; C&lt;/p&gt;</span>
<span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">wholeText</span> <span class="c1">// "A "</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">data</span> <span class="c1">// "A "</span>
</code></pre></div> </div> <p>但是，一旦移除 <code class="language-plaintext highlighter-rouge">&lt;em&gt;</code> 节点，<code class="language-plaintext highlighter-rouge">wholeText</code> 属性与 <code class="language-plaintext highlighter-rouge">data</code> 属性就会有差异，因为这时其实 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 节点下面包含了两个毗邻的文本节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">para</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">wholeText</span> <span class="c1">// "A C"</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">data</span> <span class="c1">// "A "</span>
</code></pre></div> </div> </li> </ul> <h3 id="3-text-节点的方法">3. Text 节点的方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">appendData(str)</code>：在 <code class="language-plaintext highlighter-rouge">Text</code> 节点尾部追加字符串。</li> <li><code class="language-plaintext highlighter-rouge">deleteData(startIndex, str)</code>：删除 <code class="language-plaintext highlighter-rouge">Text</code> 节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li> <li><code class="language-plaintext highlighter-rouge">insertData(index, str)</code>：在 <code class="language-plaintext highlighter-rouge">Text</code> 节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</li> <li><code class="language-plaintext highlighter-rouge">replaceData(startIndex, replacedStr, str)</code>：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li> <li> <p><code class="language-plaintext highlighter-rouge">subStringData(startIndex, length)</code>：用于获取子字符串，第一个参数为子字符串在 <code class="language-plaintext highlighter-rouge">Text</code> 节点中的开始位置，第二个参数为子字符串长度。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">remove()</code> 方法用于移除当前 <code class="language-plaintext highlighter-rouge">Text</code> 节点。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">splitText(offset)</code> 方法将 <code class="language-plaintext highlighter-rouge">Text</code> 节点一分为二，变成两个毗邻的 <code class="language-plaintext highlighter-rouge">Text</code> 节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。分割后，该方法返回分割位置后方的字符串，而原 <code class="language-plaintext highlighter-rouge">Text</code> 节点变成只包含分割位置前方的字符串。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// html 代码为 &lt;p id="p"&gt;foobar&lt;/p&gt;</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">textnode</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">newText</span> <span class="o">=</span> <span class="nx">textnode</span><span class="p">.</span><span class="nf">splitText</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">newText</span> <span class="c1">// "bar"</span>
<span class="nx">textnode</span> <span class="c1">// "foo"</span>
</code></pre></div> </div> <p>父元素节点的 <code class="language-plaintext highlighter-rouge">normalize()</code> 方法可以将毗邻的两个 <code class="language-plaintext highlighter-rouge">Text</code> 节点合并。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">p</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="c1">// 将毗邻的两个 Text 节点合并</span>
<span class="nx">p</span><span class="p">.</span><span class="nf">normalize</span><span class="p">();</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1</span>
</code></pre></div> </div> </li> </ul> <h3 id="4-documentfragment-节点">4. DocumentFragment 节点</h3> <p><code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，<code class="language-plaintext highlighter-rouge">parentNode</code> 返回 <code class="language-plaintext highlighter-rouge">null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点，要比直接操作 DOM 树快得多。</p> <p>它一般用于构建一个 DOM 结构，然后插入当前文档。<code class="language-plaintext highlighter-rouge">document.createDocumentFragment()</code>，以及浏览器原生的 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 构造函数，可以创建一个空的 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点。然后再使用其他 DOM 方法，向其添加子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">docFrag</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createDocumentFragment</span><span class="p">();</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">docFrag</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DocumentFragment</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">li</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">li</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">li</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello World</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">docFrag</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">li</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">).</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">docFrag</span><span class="p">);</span>
</code></pre></div></div> <p>注意，<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点<strong>本身不能被插入当前文档</strong>。当它作为 <code class="language-plaintext highlighter-rouge">appendChild()</code>、<code class="language-plaintext highlighter-rouge">insertBefore()</code>、<code class="language-plaintext highlighter-rouge">replaceChild()</code> 等方法的参数时，是它的所有<strong>子节点</strong>插入当前文档，而不是它自身。一旦 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点被添加进当前文档，它自身就变成了空节点（<code class="language-plaintext highlighter-rouge">textContent</code> 属性为空字符串），可以被再次使用。如果想要保存 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点的内容，可以使用 <code class="language-plaintext highlighter-rouge">cloneNode</code> 方法。</p> <p><code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点对象没有自己的属性和方法，全部继承自 <code class="language-plaintext highlighter-rouge">Node</code> 节点和 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。也就是说，<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点比 <code class="language-plaintext highlighter-rouge">Node</code> 节点多出以下四个属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">children</code>：返回一个动态的 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 集合对象，包括当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的所有子元素节点。</li> <li><code class="language-plaintext highlighter-rouge">firstElementChild</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的第一个子元素节点。</li> <li><code class="language-plaintext highlighter-rouge">lastElementChild</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的最后一个子元素节点。</li> <li><code class="language-plaintext highlighter-rouge">childElementCount</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的所有子元素数量。</li> </ul> <h2 id="九">九、</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h2 id="十mutation-observer-api">十、Mutation Observer API</h2> <h3 id="1-概述-1">1. 概述</h3> <p><strong>Mutation Observer API 用来监视 DOM 变动</strong>。概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是<strong>异步触发</strong>，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</p> <p>Mutation Observer 有以下特点。</p> <ul> <li>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</li> <li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li> <li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li> </ul> <h3 id="2-mutationobserver-构造函数">2. MutationObserver 构造函数</h3> <p>MutationObserver 构造函数会创建一个观察器实例，它接受一个回调函数，回调函数会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">mutations</span><span class="p">,</span> <span class="nx">observer</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mutations</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">mutation</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">mutation</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <h3 id="3-mutationobserver-的实例方法">3. MutationObserver 的实例方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">disconnect()</code> 用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。</li> <li><code class="language-plaintext highlighter-rouge">takeRecords()</code> 用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</li> <li> <p><code class="language-plaintext highlighter-rouge">observe(target[, options])</code> 用来启动监听，它接受两个参数。</p> <ul> <li>第一个参数：所要观察的 DOM 节点</li> <li>第二个参数：一个配置对象，指定所要观察的特定变动</li> </ul> <p>观察器所能观察的 DOM 变动类型（即 <code class="language-plaintext highlighter-rouge">options</code> 配置对象），有以下几种。</p> <ul> <li><code class="language-plaintext highlighter-rouge">childList</code>：子节点的变动（指新增，删除或者更改）。</li> <li><code class="language-plaintext highlighter-rouge">attributes</code>：属性的变动。</li> <li><code class="language-plaintext highlighter-rouge">characterData</code>：节点内容或节点文本的变动。</li> </ul> <p>想要观察哪一种变动类型，就在 <code class="language-plaintext highlighter-rouge">option</code> 对象中指定它的值为 <code class="language-plaintext highlighter-rouge">true</code>。至少必须同时指定这三种观察的一种，若均未指定将报错。</p> <p>除了变动类型，<code class="language-plaintext highlighter-rouge">options</code> 对象还可以设定以下属性：</p> <ul> <li><code class="language-plaintext highlighter-rouge">subtree</code>：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li> <li><code class="language-plaintext highlighter-rouge">attributeOldValue</code>：布尔值，表示观察 <code class="language-plaintext highlighter-rouge">attributes</code> 变动时，是否需要记录变动前的属性值。</li> <li><code class="language-plaintext highlighter-rouge">characterDataOldValue</code>：布尔值，表示观察 <code class="language-plaintext highlighter-rouge">characterData</code> 变动时，是否需要记录变动前的值。</li> <li><code class="language-plaintext highlighter-rouge">attributeFilter</code>：数组，表示需要观察的特定属性（比如[‘class’,’src’]）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 开始监听文档根节点（即 &lt;html&gt; 标签）的变动</span>
<span class="nx">mutationObserver</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">attributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">characterData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">attributeOldValue</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">characterDataOldValue</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div> </div> </li> </ul> <h3 id="4-mutationrecord-对象">4. MutationRecord 对象</h3> <p>DOM 每次发生变化，就会生成一条变动记录（<code class="language-plaintext highlighter-rouge">MutationRecord</code> 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个 <code class="language-plaintext highlighter-rouge">MutationRecord</code> 实例所组成的数组。</p> <p><code class="language-plaintext highlighter-rouge">MutationRecord</code> 对象包含了 DOM 的相关信息，有如下属性：</p> <ul> <li><code class="language-plaintext highlighter-rouge">type</code>：观察的变动类型（<code class="language-plaintext highlighter-rouge">childList</code>、<code class="language-plaintext highlighter-rouge">attributes</code> 或者 <code class="language-plaintext highlighter-rouge">characterData</code>）。</li> <li><code class="language-plaintext highlighter-rouge">target</code>：发生变动的 DOM 节点。</li> <li><code class="language-plaintext highlighter-rouge">previousSibling</code>：前一个同级节点，如果没有则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">nextSibling</code>：下一个同级节点，如果没有则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">attributeName</code>：发生变动的属性。如果设置了 <code class="language-plaintext highlighter-rouge">attributeFilter</code>，则只返回预先指定的属性。</li> <li><code class="language-plaintext highlighter-rouge">oldValue</code>：变动前的值。这个属性只对 <code class="language-plaintext highlighter-rouge">attribute</code> 和 <code class="language-plaintext highlighter-rouge">characterData</code> 变动有效，如果发生 <code class="language-plaintext highlighter-rouge">childList</code> 变动，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li><code class="language-plaintext highlighter-rouge">addedNodes</code>：新增的 DOM 节点。</li> <li><code class="language-plaintext highlighter-rouge">removedNodes</code>：删除的 DOM 节点。</li> </ul> <h3 id="5-应用示例">5. 应用示例</h3> <h4 id="51-子元素的变动">5.1 子元素的变动</h4> <p>下面的例子说明如何读取变动记录。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">records</span><span class="p">){</span>
  <span class="nx">records</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">record</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mutation type: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mutation target: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
<span class="nx">mo</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">childList</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">subtree</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="52-属性的变动">5.2 属性的变动</h4> <p>下面的例子说明如何追踪属性的变动。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">records</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">record</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Previous attribute value: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">oldValue</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
<span class="nx">mo</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">#my_element</span><span class="dl">'</span><span class="p">),</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">attributes</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">attributeOldValue</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="53-取代-domcontentloaded-事件">5.3 取代 DOMContentLoaded 事件</h4> <p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
<span class="nx">observer</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <p>上面代码中，监听 <code class="language-plaintext highlighter-rouge">document.documentElement</code>（即网页的 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> HTML 节点）的子节点的变动，<code class="language-plaintext highlighter-rouge">subtree</code> 属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。</p> <p>下面的代码，使用 MutationObserver 对象封装一个监听 DOM 生成的函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">win</span><span class="p">){</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">listeners</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">win</span><span class="p">.</span><span class="nb">document</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">MutationObserver</span> <span class="o">=</span> <span class="nx">win</span><span class="p">.</span><span class="nx">MutationObserver</span> <span class="o">||</span> <span class="nx">win</span><span class="p">.</span><span class="nx">WebKitMutationObserver</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">observer</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">fn</span><span class="p">){</span>
    <span class="c1">// 储存选择器和回调函数</span>
    <span class="nx">listeners</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span>
      <span class="na">selector</span><span class="p">:</span> <span class="nx">selector</span><span class="p">,</span>
      <span class="na">fn</span><span class="p">:</span> <span class="nx">fn</span>
    <span class="p">});</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">observer</span><span class="p">){</span>
      <span class="c1">// 监听document变化</span>
      <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nx">check</span><span class="p">);</span>
      <span class="nx">observer</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="c1">// 检查该节点是否已经在DOM中</span>
    <span class="nf">check</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nf">check</span><span class="p">(){</span>
  <span class="c1">// 检查是否匹配已储存的节点</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">listeners</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">listener</span> <span class="o">=</span> <span class="nx">listeners</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="c1">// 检查指定节点是否有匹配</span>
      <span class="kd">var</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="nx">listener</span><span class="p">.</span><span class="nx">selector</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
        <span class="c1">// 确保回调函数只会对该元素调用一次</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">element</span><span class="p">.</span><span class="nx">ready</span><span class="p">){</span>
          <span class="nx">element</span><span class="p">.</span><span class="nx">ready</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="c1">// 对该节点调用回调函数</span>
          <span class="nx">listener</span><span class="p">.</span><span class="nx">fn</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 对外暴露ready</span>
  <span class="nx">win</span><span class="p">.</span><span class="nx">ready</span> <span class="o">=</span> <span class="nx">ready</span><span class="p">;</span>

<span class="p">})(</span><span class="k">this</span><span class="p">);</span>

<span class="c1">// 使用方法</span>
<span class="nf">ready</span><span class="p">(</span><span class="dl">'</span><span class="s1">.foo</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">){</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div></div> <h2 id="十一参考">十一、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/dom/">JavaScript 教程 - DOM</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="JavaScript"/><category term="DOM"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - DOM》一章中部分知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/oop/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-11T00:00:00+00:00</published><updated>2024-10-11T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/oop</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/oop/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/oop/">《JavaScript 教程 - 面向对象编程》</a>一章中部分知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一实例对象与-new-命令">一、实例对象与 new 命令</h2> <h3 id="11-对象是什么">1.1 对象是什么</h3> <ul> <li>对象是单个实物的<strong>抽象</strong>。</li> <li>对象是一个<strong>容器</strong>，封装了属性（property）和方法（method）。</li> </ul> <h3 id="12-构造函数">1.2 构造函数</h3> <p>JavaScript 语言的对象体系，不是基于“类”的，而是基于<strong>构造函数</strong>（constructor）和<strong>原型链</strong>（prototype）。</p> <p>构造函数（constructor）是用来生成实例对象的函数，作为对象的模板。构造函数有两个特点。</p> <ul> <li>生成对象的时候，必须使用 <code class="language-plaintext highlighter-rouge">new</code> 命令。</li> <li>函数体内部使用了 <code class="language-plaintext highlighter-rouge">this</code> 关键字，代表了所要生成的对象实例。</li> </ul> <h3 id="13-new-命令">1.3 new 命令</h3> <h4 id="1基本用法">（1）基本用法</h4> <p><code class="language-plaintext highlighter-rouge">new</code> 命令用于执行构造函数，返回实例对象。</p> <p>如果不使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，直接调用构造函数，此时构造函数就变成了<strong>普通函数</strong>，并不会生成实例对象。此时 <code class="language-plaintext highlighter-rouge">this</code> 代表全局对象，将造成一些意想不到的结果。对此有两个解决办法。</p> <ul> <li> <p>构造函数内部使用严格模式（<code class="language-plaintext highlighter-rouge">use strict</code>）。一旦忘了使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，直接调用构造函数就会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">){</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">Fubar</span><span class="p">()</span>
<span class="c1">// TypeError: Cannot set property '_foo' of undefined</span>
</code></pre></div> </div> </li> <li> <p>构造函数内部判断是否使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，如果发现没有使用，则直接返回一个实例对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Fubar</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">Fubar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="nx">_foo</span> <span class="c1">// 1</span>
<span class="p">(</span><span class="k">new</span> <span class="nc">Fubar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)).</span><span class="nx">_foo</span> <span class="c1">// 1</span>
</code></pre></div> </div> </li> </ul> <h4 id="2new-命令的原理">（2）new 命令的原理</h4> <p>使用 <code class="language-plaintext highlighter-rouge">new</code> 命令时，它后面的函数依次执行下面的步骤。</p> <ol> <li>创建一个<strong>空对象</strong>，作为将要返回的对象实例。</li> <li>将这个空对象的<strong>原型</strong>，指向构造函数的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性。</li> <li>将这个空对象赋值给函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 关键字。</li> <li>开始执行构造函数内部的代码。</li> </ol> <p>也就是说，构造函数内部，<code class="language-plaintext highlighter-rouge">this</code> 指的是一个新生成的空对象，所有针对 <code class="language-plaintext highlighter-rouge">this</code> 的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即 <code class="language-plaintext highlighter-rouge">this</code> 对象），将其“构造”为需要的样子。</p> <ul> <li>如果构造函数内部有 <code class="language-plaintext highlighter-rouge">return</code> 语句，而且 <code class="language-plaintext highlighter-rouge">return</code> 后面跟着一个<strong>对象</strong>，<code class="language-plaintext highlighter-rouge">new</code> 命令会返回 <code class="language-plaintext highlighter-rouge">return</code> 语句指定的<strong>对象</strong>；否则，就会不管 <code class="language-plaintext highlighter-rouge">return</code> 语句，返回 <code class="language-plaintext highlighter-rouge">this</code> 对象。</li> <li>如果 <code class="language-plaintext highlighter-rouge">return</code> 语句返回的是一个跟 <code class="language-plaintext highlighter-rouge">this</code> 无关的<strong>新对象</strong>，<code class="language-plaintext highlighter-rouge">new</code> 命令会返回这个<strong>新对象</strong>，而不是 <code class="language-plaintext highlighter-rouge">this</code> 对象。</li> <li> <p>如果对普通函数（内部没有 <code class="language-plaintext highlighter-rouge">this</code> 关键字的函数）使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，则会返回一个<strong>空对象</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getMessage</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">this is a message</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">getMessage</span><span class="p">();</span>
<span class="nx">msg</span> <span class="c1">// {}</span>
<span class="k">typeof</span> <span class="nx">msg</span> <span class="c1">// "object"</span>
</code></pre></div> </div> <p>这是因为 <code class="language-plaintext highlighter-rouge">new</code> 命令总是返回一个对象，要么是实例对象，要么是 <code class="language-plaintext highlighter-rouge">return</code> 语句指定的对象。上面的代码，<code class="language-plaintext highlighter-rouge">return</code> 语句返回的是字符串，所以 <code class="language-plaintext highlighter-rouge">new</code> 命令就忽略了该语句。</p> </li> </ul> <p><code class="language-plaintext highlighter-rouge">new</code> 命令简化的内部流程，可以用下面的代码表示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">_new</span><span class="p">(</span><span class="cm">/* 构造函数 */</span> <span class="kd">constructor</span><span class="p">,</span> <span class="cm">/* 构造函数参数 */</span> <span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 将 arguments 对象转为数组</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="c1">// 取出构造函数</span>
  <span class="kd">var</span> <span class="kd">constructor</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
  <span class="c1">// 创建一个空对象，继承构造函数的 prototype 属性</span>
  <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="c1">// 执行构造函数</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="kd">constructor</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="c1">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span>
  <span class="k">return </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">result</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">?</span> <span class="nx">result</span> <span class="p">:</span> <span class="nx">context</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 实例</span>
<span class="kd">var</span> <span class="nx">actor</span> <span class="o">=</span> <span class="nf">_new</span><span class="p">(</span><span class="nx">Person</span><span class="p">,</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
</code></pre></div></div> <h4 id="3newtarget">（3）new.target</h4> <p>函数内部可以使用 <code class="language-plaintext highlighter-rouge">new.target</code> 属性。如果当前函数是 <code class="language-plaintext highlighter-rouge">new</code> 命令调用，<code class="language-plaintext highlighter-rouge">new.target</code> 指向当前函数，否则为 <code class="language-plaintext highlighter-rouge">undefined</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">()</span> <span class="c1">// false</span>
<span class="k">new</span> <span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>
</code></pre></div></div> <p><strong>使用这个属性，可以判断函数调用的时候，是否使用 <code class="language-plaintext highlighter-rouge">new</code> 命令</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">请使用 new 命令调用！</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">()</span> <span class="c1">// Uncaught Error: 请使用 new 命令调用！</span>
</code></pre></div></div> <h3 id="14-objectcreate-创建实例对象">1.4 Object.create() 创建实例对象</h3> <p>如果希望以某个现有的对象作为模板，生成新的实例对象，可以使用 <code class="language-plaintext highlighter-rouge">Object.create(proto, propertiesObject)</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">38</span><span class="p">,</span>
  <span class="na">greeting</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hi! I</span><span class="se">\'</span><span class="s1">m </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">person1</span><span class="p">);</span>
<span class="nx">person2</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// 张三</span>
<span class="nx">person2</span><span class="p">.</span><span class="nf">greeting</span><span class="p">()</span> <span class="c1">// Hi! I'm 张三.</span>
</code></pre></div></div> <h2 id="二this-关键字">二、this 关键字</h2> <h3 id="21-涵义">2.1 涵义</h3> <p><code class="language-plaintext highlighter-rouge">this</code> 是属性或方法“当前”所在的对象。由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即 <code class="language-plaintext highlighter-rouge">this</code> 的指向是<strong>可变的</strong>。</p> <h3 id="22-实质">2.2 实质</h3> <p>JavaScript 语言之所以有 <code class="language-plaintext highlighter-rouge">this</code> 的设计，跟内存里面的数据结构有关系。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span>  <span class="mi">5</span> <span class="p">};</span>
</code></pre></div></div> <p>上面的代码将一个对象赋值给变量 <code class="language-plaintext highlighter-rouge">obj</code>。JavaScript 引擎会先在内存里面，生成一个对象 <code class="language-plaintext highlighter-rouge">{ foo: 5 }</code>，然后把这个对象的内存地址赋值给变量 <code class="language-plaintext highlighter-rouge">obj</code>。也就是说，变量 <code class="language-plaintext highlighter-rouge">obj</code> 是一个地址（reference）。后面如果要读取 <code class="language-plaintext highlighter-rouge">obj.foo</code>，引擎先从 <code class="language-plaintext highlighter-rouge">obj</code> 拿到内存地址，然后再从该地址读出原始的对象，返回它的 <code class="language-plaintext highlighter-rouge">foo</code> 属性。</p> <p>原始的对象以字典结构保存，每个属性名都对应一个属性描述对象。举例来说，上面例子的 <code class="language-plaintext highlighter-rouge">foo</code> 属性，实际上是以下面的形式保存的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[[</span><span class="nx">value</span><span class="p">]]:</span> <span class="mi">5</span>
    <span class="p">[[</span><span class="nx">writable</span><span class="p">]]:</span> <span class="kc">true</span>
    <span class="p">[[</span><span class="nx">enumerable</span><span class="p">]]:</span> <span class="kc">true</span>
    <span class="p">[[</span><span class="nx">configurable</span><span class="p">]]:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 <code class="language-plaintext highlighter-rouge">foo</code> 属性的 <code class="language-plaintext highlighter-rouge">value</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[[</span><span class="nx">value</span><span class="p">]]:</span> <span class="nx">函数的地址</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">f</span><span class="p">:</span> <span class="nx">f</span> <span class="p">};</span>
<span class="c1">// 单独执行</span>
<span class="nf">f</span><span class="p">()</span>
<span class="c1">// obj 环境执行</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span>
</code></pre></div></div> <p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得<strong>当前的运行环境</strong>（context）。所以，<code class="language-plaintext highlighter-rouge">this</code> 就出现了，它的设计目的就是<strong>在函数体内部，指代函数当前的运行环境</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，函数体里面的 <code class="language-plaintext highlighter-rouge">this.x</code> 就是指当前运行环境的 <code class="language-plaintext highlighter-rouge">x</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 单独执行</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 1</span>
<span class="c1">// obj 环境执行</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面代码中，函数 <code class="language-plaintext highlighter-rouge">f</code> 在全局环境执行，<code class="language-plaintext highlighter-rouge">this.x</code> 指向全局环境的 <code class="language-plaintext highlighter-rouge">x</code>；在 <code class="language-plaintext highlighter-rouge">obj</code> 环境执行，<code class="language-plaintext highlighter-rouge">this.x</code> 指向 <code class="language-plaintext highlighter-rouge">obj.x</code>。</p> <h3 id="23-使用场合">2.3 使用场合</h3> <ul> <li>全局环境：全局环境使用 <code class="language-plaintext highlighter-rouge">this</code>，指向顶层对象 <code class="language-plaintext highlighter-rouge">window</code>。</li> <li>构造函数：构造函数中使用 <code class="language-plaintext highlighter-rouge">this</code>，指向实例对象。</li> <li> <p>对象的方法：此时 <code class="language-plaintext highlighter-rouge">this</code> 指向方法运行时所在的对象。该方法赋值给另一个对象，就会改变 <code class="language-plaintext highlighter-rouge">this</code> 的指向。</p> <ul> <li> <p>如果 <code class="language-plaintext highlighter-rouge">this</code> 所在的方法不在对象的第一层，这时 <code class="language-plaintext highlighter-rouge">this</code> 只是指向当前层的对象，而不会继承更上面的层。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">m</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nf">m</span><span class="p">()</span> <span class="c1">// undefined</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">this</code> 指向 <code class="language-plaintext highlighter-rouge">a.b</code>。</p> </li> <li> <p>如果将嵌套对象内部的方法赋值给一个变量，<code class="language-plaintext highlighter-rouge">this</code> 依然会指向全局对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">b</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">m</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">hello</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span>
<span class="nf">hello</span><span class="p">()</span> <span class="c1">// undefined</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <h3 id="24-使用注意点">2.4 使用注意点</h3> <h4 id="1避免多层-this">（1）避免多层 this</h4> <p>由于 <code class="language-plaintext highlighter-rouge">this</code> 的指向是不确定的，所以切勿在函数中包含多层的 <code class="language-plaintext highlighter-rouge">this</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f1</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f1</span><span class="p">()</span>
<span class="c1">// Object</span>
<span class="c1">// Window</span>
</code></pre></div></div> <p>上面代码包含两层 <code class="language-plaintext highlighter-rouge">this</code>，结果运行后，第一层指向对象 <code class="language-plaintext highlighter-rouge">o</code>，第二层指向全局对象。</p> <ul> <li> <p>一个解决方法是在第二层改用一个指向外层 <code class="language-plaintext highlighter-rouge">this</code> 的变量。使用一个变量固定 <code class="language-plaintext highlighter-rouge">this</code> 的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f1</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">that</span><span class="p">);</span>
    <span class="p">}();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f1</span><span class="p">()</span>
<span class="c1">// Object</span>
<span class="c1">// Object</span>
</code></pre></div> </div> </li> <li> <p>JavaScript 提供了<strong>严格模式</strong>，也可以硬性避免这种问题。严格模式下，如果函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 指向顶层对象，就会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">count</span><span class="p">:</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span><span class="p">;</span>
<span class="nf">f</span><span class="p">()</span>
<span class="c1">// TypeError: Cannot read property 'count' of undefined</span>
</code></pre></div> </div> </li> </ul> <h4 id="2避免数组处理方法中的-this">（2）避免数组处理方法中的 this</h4> <p>数组的 <code class="language-plaintext highlighter-rouge">map()</code> 和 <code class="language-plaintext highlighter-rouge">forEach()</code> 方法，允许提供一个函数作为参数。这个函数内部不应该使用 <code class="language-plaintext highlighter-rouge">this</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">v</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">p</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">a1</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a2</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">f</span><span class="p">:</span> <span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">v</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">item</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span>
<span class="c1">// undefined a1</span>
<span class="c1">// undefined a2</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">forEach()</code> 方法的回调函数中的 <code class="language-plaintext highlighter-rouge">this</code>，其实是指向 <code class="language-plaintext highlighter-rouge">window</code> 对象，因此取不到 <code class="language-plaintext highlighter-rouge">o.v</code> 的值。原因跟上一段的多层 <code class="language-plaintext highlighter-rouge">this</code> 是一样的，就是内层的 <code class="language-plaintext highlighter-rouge">this</code> 不指向外部，而指向顶层对象。</p> <h4 id="3避免回调函数中的-this">（3）避免回调函数中的 this</h4> <p>回调函数中的 <code class="language-plaintext highlighter-rouge">this</code> 往往会改变指向，最好避免使用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// jQuery 的写法</span>
<span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">#button</span><span class="dl">'</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，点击按钮以后，控制台会显示 <code class="language-plaintext highlighter-rouge">false</code>。原因是此时 <code class="language-plaintext highlighter-rouge">this</code> 不再指向 <code class="language-plaintext highlighter-rouge">o</code> 对象，而是指向按钮的 DOM 对象，因为 <code class="language-plaintext highlighter-rouge">f</code> 方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p> <h3 id="15-绑定-this-的方法">1.5 绑定 this 的方法</h3> <h4 id="1functionprototypecall">（1）Function.prototype.call()</h4> <p>函数实例的 <code class="language-plaintext highlighter-rouge">call(thisArg, arg1, arg2, ...)</code> 可以指定函数内部 <code class="language-plaintext highlighter-rouge">this</code> 的指向。第一个参数是 <code class="language-plaintext highlighter-rouge">this</code> 所要指向的那个对象，后面的参数是函数调用时所需的参数。</p> <p><code class="language-plaintext highlighter-rouge">call()</code> 的一个应用是<strong>调用对象的原生方法</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// 覆盖掉继承的 hasOwnProperty 方法</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">hasOwnProperty()</code> 是 <code class="language-plaintext highlighter-rouge">obj</code> 对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code class="language-plaintext highlighter-rouge">call()</code> 可以解决这个问题，它将 <code class="language-plaintext highlighter-rouge">hasOwnProperty()</code> 的原始定义放到 <code class="language-plaintext highlighter-rouge">obj</code> 对象上执行，这样无论 <code class="language-plaintext highlighter-rouge">obj</code> 上有没有同名方法，都不会影响结果。</p> <h4 id="2functionprototypeapply">（2）Function.prototype.apply()</h4> <p><code class="language-plaintext highlighter-rouge">apply(thisArg, [arg1, arg2, ...])</code> 的作用与 <code class="language-plaintext highlighter-rouge">call()</code> 类似，也是改变 <code class="language-plaintext highlighter-rouge">this</code> 指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。</p> <p><code class="language-plaintext highlighter-rouge">apply()</code> 的一个常见的应用，是利用数组对象的 <code class="language-plaintext highlighter-rouge">slice()</code> 将一个类似数组的对象（比如 <code class="language-plaintext highlighter-rouge">arguments</code> 对象）转为真正的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">length</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// [1]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// []</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">length</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">// [1, undefined]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="na">length</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// [undefined]</span>
</code></pre></div></div> <h4 id="3functionprototypebind">（3）Function.prototype.bind()</h4> <p><code class="language-plaintext highlighter-rouge">bind(thisArg, arg1, arg2, ...)</code> 用于将函数体内的 <code class="language-plaintext highlighter-rouge">this</code> 绑定到某个对象，然后返回一个<strong>新函数</strong>。<code class="language-plaintext highlighter-rouge">bind()</code> 有一些使用注意点。</p> <ul> <li>每次返回一个新函数</li> <li>结合回调函数使用</li> <li>结合 <code class="language-plaintext highlighter-rouge">call()</code> 使用：利用 <code class="language-plaintext highlighter-rouge">bind()</code>，可以改写一些 JavaScript 原生方法的使用形式，以数组的 <code class="language-plaintext highlighter-rouge">slice()</code> 为例。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span>
<span class="c1">// 等同于</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span>
</code></pre></div></div> <h2 id="三对象的继承">三、对象的继承</h2> <h3 id="31-objectgetprototypeof">3.1 Object.getPrototypeOf()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getPrototypeOf(obj)</code> 返回参数对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <p>下面是几种特殊对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 空对象的原型是 Object.prototype</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">({})</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>

<span class="c1">// Object.prototype 的原型是 null</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span> <span class="c1">// true</span>

<span class="c1">// 函数的原型是 Function.prototype</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="32-objectsetprototypeof">3.2 Object.setPrototypeOf()</h3> <p><code class="language-plaintext highlighter-rouge">Object.setPrototypeOf(obj, prototype)</code> 为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">setPrototypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">===</span> <span class="nx">b</span> <span class="c1">// true</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// 1</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">new</code> 命令可以使用 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf()</code> 模拟。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">setPrototypeOf</span><span class="p">({},</span> <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nx">F</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">new</code> 命令新建实例对象，其实可以分成两步。</p> <ul> <li>第一步，将一个空对象的原型设为构造函数的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性（上例是 <code class="language-plaintext highlighter-rouge">F.prototype</code>）；</li> <li>第二步，将构造函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 绑定这个空对象，然后执行构造函数，使得定义在 <code class="language-plaintext highlighter-rouge">this</code> 上面的方法和属性（上例是 <code class="language-plaintext highlighter-rouge">this.foo</code>），都转移到这个空对象上。</li> </ul> <h3 id="33-objectcreate">3.3 Object.create()</h3> <p><code class="language-plaintext highlighter-rouge">Object.create(proto, propertiesObject)</code> 接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 原型对象</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">print</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 实例对象</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span> <span class="o">===</span> <span class="nx">A</span> <span class="c1">// true</span>
<span class="nx">B</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// hello</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 可以用下面的代码代替。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码表明，<code class="language-plaintext highlighter-rouge">Object.create()</code> 的实质是新建一个空的构造函数 <code class="language-plaintext highlighter-rouge">F</code>，然后让 <code class="language-plaintext highlighter-rouge">F.prototype</code> 属性指向参数对象 <code class="language-plaintext highlighter-rouge">obj</code>，最后返回一个 <code class="language-plaintext highlighter-rouge">F</code> 的实例，从而实现让该实例继承 <code class="language-plaintext highlighter-rouge">obj</code> 的属性。</p> <p>下面三种方式生成的新对象是等价的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({});</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">obj3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
</code></pre></div></div> <p>如果想要生成一个不继承任何属性（比如没有 <code class="language-plaintext highlighter-rouge">toString()</code> 和 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法）的对象，可以将 <code class="language-plaintext highlighter-rouge">Object.create()</code> 的参数设为 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// TypeError: Object [object Object] has no method 'valueOf'</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">obj1</span><span class="p">);</span>
<span class="nx">obj1</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 2</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 可以接受第二个参数。该参数是一个<strong>属性描述对象</strong>，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({},</span> <span class="p">{</span>
  <span class="na">p1</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">p2</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({});</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p2</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 生成的对象，继承了它的原型对象的构造函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">A</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="nx">b</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">A</span> <span class="c1">// true</span>
<span class="nx">b</span> <span class="k">instanceof</span> <span class="nx">A</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="34-objectprototypeisprototypeof">3.4 Object.prototype.isPrototypeOf()</h3> <p>实例对象的 <code class="language-plaintext highlighter-rouge">isPrototypeOf(object)</code>，用来判断该对象是否为参数对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">o1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">o3</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">o2</span><span class="p">);</span>
<span class="nx">o2</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nx">o3</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">o1</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nx">o3</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">o1</code> 和 <code class="language-plaintext highlighter-rouge">o2</code> 都是 <code class="language-plaintext highlighter-rouge">o3</code> 的原型。这表明只要实例对象处在参数对象的<strong>原型链</strong>上，<code class="language-plaintext highlighter-rouge">isPrototypeOf()</code> 都返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="sr">/xyz/</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">))</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 处于原型链的最顶端，所以对各种实例都返回 <code class="language-plaintext highlighter-rouge">true</code>，只有直接继承自 <code class="language-plaintext highlighter-rouge">null</code> 的对象除外。</p> <h3 id="35-objectprototypeproto">3.5 Object.prototype.<strong>proto</strong></h3> <p>实例对象的 <code class="language-plaintext highlighter-rouge">__proto__</code> 属性，返回该对象的<strong>原型</strong>。该属性<strong>可读写</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// true</span>
</code></pre></div></div> <p>根据语言标准，<code class="language-plaintext highlighter-rouge">__proto__</code> 属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 和 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p> <p>原型链可以用 <code class="language-plaintext highlighter-rouge">__proto__</code> 很直观地表示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">李四</span><span class="dl">'</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">print</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>

<span class="nx">A</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// 张三</span>
<span class="nx">B</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// 李四</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">A</code> 对象和 <code class="language-plaintext highlighter-rouge">B</code> 对象的原型都是 <code class="language-plaintext highlighter-rouge">proto</code> 对象，它们都共享 <code class="language-plaintext highlighter-rouge">proto</code> 对象的 <code class="language-plaintext highlighter-rouge">print</code> 方法。也就是说，<code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 的 <code class="language-plaintext highlighter-rouge">print</code> 方法，都是在调用 <code class="language-plaintext highlighter-rouge">proto</code> 对象的 <code class="language-plaintext highlighter-rouge">print</code> 方法。</p> <h3 id="36-获取原型对象方法的比较">3.6 获取原型对象方法的比较</h3> <p>获取实例对象 obj 的原型对象，有三种方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">obj.__proto__</code></li> <li><code class="language-plaintext highlighter-rouge">obj.constructor.prototype</code></li> <li><code class="language-plaintext highlighter-rouge">Object.getPrototypeOf(obj)</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面三种方法之中，前两种都不是很可靠。<code class="language-plaintext highlighter-rouge">__proto__</code> 属性只有浏览器才需要部署，其他环境可以不部署。而 <code class="language-plaintext highlighter-rouge">obj.constructor.prototype</code> 在手动改变原型对象时，可能会失效。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">P</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">P</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">C</span><span class="p">();</span>

<span class="nx">c</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，构造函数 <code class="language-plaintext highlighter-rouge">C</code> 的原型对象被改成了 <code class="language-plaintext highlighter-rouge">p</code>，但是实例对象的 <code class="language-plaintext highlighter-rouge">c.constructor.prototype</code> 却没有指向 <code class="language-plaintext highlighter-rouge">p</code>。所以，在改变原型对象时，一般要同时设置 <code class="language-plaintext highlighter-rouge">constructor</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">C</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">C</span><span class="p">();</span>
<span class="nx">c</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// true</span>
</code></pre></div></div> <p>因此，推荐使用第三种 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法，获取原型对象。</p> <h3 id="37-objectgetownpropertynames">3.7 Object.getOwnPropertyNames()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyNames(obj)</code> 返回一个数组，成员是参数对象<strong>自身的</strong>所有属性（包括<strong>可枚举的属性</strong>、<strong>不可枚举的</strong>属性）的键名，不包含继承的属性键名。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nb">Date</span><span class="p">)</span>
<span class="c1">// ["parse", "arguments", "UTC", "caller", "name", "prototype", "now", "length"]</span>
</code></pre></div></div> <h3 id="38-objectprototypehasownproperty">3.8 Object.prototype.hasOwnProperty()</h3> <p>对象实例的 <code class="language-plaintext highlighter-rouge">hasOwnProperty(prop)</code> 返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Date</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">length</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h3 id="39-in-运算符和-forin-循环">3.9 in 运算符和 for…in 循环</h3> <ul> <li><code class="language-plaintext highlighter-rouge">in</code> 运算符返回布尔值，表示一个对象是否具有某个属性。包括对象<strong>自身的</strong>和<strong>继承的</strong>属性。<code class="language-plaintext highlighter-rouge">in</code> 运算符常用于检查一个属性是否存在。</li> <li><code class="language-plaintext highlighter-rouge">for...in</code> 循环用于获取对象<strong>自身的</strong>和<strong>继承的</strong>所有可遍历属性。</li> </ul> <p>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">inheritedPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">props</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">props</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="310-对象的拷贝">3.10 对象的拷贝</h3> <p>如果要拷贝一个对象，需要做到下面两件事情。</p> <ul> <li>确保拷贝后的对象，与原对象具有同样的<strong>原型</strong>。</li> <li>确保拷贝后的对象，与原对象具有同样的<strong>实例属性</strong>。</li> </ul> <p>下面就是根据上面两点，实现的对象拷贝函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">copyObject</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">copy</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">orig</span><span class="p">));</span>
  <span class="nf">copyOwnPropertiesFrom</span><span class="p">(</span><span class="nx">copy</span><span class="p">,</span> <span class="nx">orig</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">copy</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">copyOwnPropertiesFrom</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span>
    <span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">propKey</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">desc</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">);</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">desc</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="k">return</span> <span class="nx">target</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>另一种更简单的写法，是利用 ES2017 才引入标准的 <code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptors(obj)</code> 方法，此方法返回给定对象自身的所有属性描述符。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">copyObject</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">orig</span><span class="p">),</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="四object-对象的相关方法">四、Object 对象的相关方法</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="五严格模式">五、严格模式</h2> <h3 id="51-设计目的">5.1 设计目的</h3> <p>ES5 引入了严格模式，主要目的有以下几个。</p> <ul> <li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li> <li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li> <li>提高编译器效率，提升运行速度。</li> <li>为未来新版本的 JavaScript 语法做好铺垫。</li> </ul> <h3 id="52-启用方法">5.2 启用方法</h3> <p>进入严格模式的标志，是一行字符串 <code class="language-plaintext highlighter-rouge">use strict</code>。老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p> <ul> <li>整个脚本文件：<code class="language-plaintext highlighter-rouge">use strict</code> 放在脚本文件的第一行，整个脚本都将以严格模式运行。</li> <li>单个函数：<code class="language-plaintext highlighter-rouge">use strict</code> 放在函数体的第一行，则整个函数以严格模式运行。</li> </ul> <h3 id="53-显式报错">5.3 显式报错</h3> <h4 id="1只读属性不可写">（1）只读属性不可写</h4> <p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 对只读属性赋值会报错</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="c1">// TypeError: Cannot assign to read only property 'a' of object #&lt;Object&gt;</span>

<span class="c1">// 删除不可配置的属性会报错</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>
<span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">p</span>
<span class="c1">// TypeError: Cannot delete property 'p' of #&lt;Object&gt;</span>
</code></pre></div></div> <h4 id="2只设置了取值器的属性不可写">（2）只设置了取值器的属性不可写</h4> <p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nf">v</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">v</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span>
</code></pre></div></div> <h4 id="3禁止扩展的对象不可扩展">（3）禁止扩展的对象不可扩展</h4> <p>严格模式下，对禁止扩展的对象添加新属性会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// Uncaught TypeError: Cannot add property v, object is not extensible</span>
</code></pre></div></div> <h4 id="4evalarguments-不可用作标识名">（4）eval、arguments 不可用作标识名</h4> <p>严格模式下，使用 <code class="language-plaintext highlighter-rouge">eval</code> 或者 <code class="language-plaintext highlighter-rouge">arguments</code> 作为标识名会报错。下面的语句都会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nb">eval</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">arguments</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="kd">set</span> <span class="nf">p</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">};</span>
<span class="k">try</span> <span class="p">{</span> <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nf">x</span><span class="p">(</span><span class="nb">eval</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nf">arguments</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">eval</span><span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Function</span><span class="p">(</span><span class="dl">'</span><span class="s1">arguments</span><span class="dl">'</span><span class="p">,</span> <span class="dl">"</span><span class="s2">'use strict'; return 17;</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// SyntaxError: Unexpected eval or arguments in strict mode</span>
</code></pre></div></div> <h4 id="5函数不能有重名的参数">（5）函数不能有重名的参数</h4> <p>正常模式下，如果函数有多个重名的参数，可以用 <code class="language-plaintext highlighter-rouge">arguments[i]</code> 读取。严格模式下，这属于语法错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre></div></div> <h4 id="6禁止八进制的前缀-0-表示法">（6）禁止八进制的前缀 0 表示法</h4> <p>正常模式下，整数的第一位如果是 <code class="language-plaintext highlighter-rouge">0</code>，表示这是八进制数，比如 <code class="language-plaintext highlighter-rouge">0100</code> 等于十进制的 <code class="language-plaintext highlighter-rouge">64</code>。严格模式禁止这种表示法，整数第一位为 <code class="language-plaintext highlighter-rouge">0</code>，将报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0100</span><span class="p">;</span>
<span class="c1">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span>
</code></pre></div></div> <h3 id="54-增强的安全措施">5.4 增强的安全措施</h3> <h4 id="1全局变量显式声明">（1）全局变量显式声明</h4> <p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 报错，v 未声明</span>
<span class="k">for </span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 报错，i 未声明</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 报错，未声明就创建一个全局变量</span>
</code></pre></div></div> <h4 id="2禁止-this-关键字指向全局对象">（2）禁止 this 关键字指向全局对象</h4> <p>正常模式下，函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正常模式</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>

<span class="c1">// 严格模式</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>
</code></pre></div></div> <p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 <code class="language-plaintext highlighter-rouge">new</code>，这时 <code class="language-plaintext highlighter-rouge">this</code> 不再指向全局对象，而是报错。</p> <h4 id="3禁止使用-fncalleefncaller">（3）禁止使用 fn.callee、fn.caller</h4> <p>函数内部不得使用 <code class="language-plaintext highlighter-rouge">fn.caller</code>、<code class="language-plaintext highlighter-rouge">fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">f1</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>    <span class="c1">// 报错</span>
  <span class="nx">f1</span><span class="p">.</span><span class="nx">arguments</span><span class="p">;</span> <span class="c1">// 报错</span>
<span class="p">}</span>

<span class="nf">f1</span><span class="p">();</span>
</code></pre></div></div> <h4 id="4禁止使用-argumentscalleeargumentscaller">（4）禁止使用 arguments.callee、arguments.caller</h4> <p><code class="language-plaintext highlighter-rouge">arguments.callee</code> 和 <code class="language-plaintext highlighter-rouge">arguments.caller</code> 是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用 <code class="language-plaintext highlighter-rouge">arguments.callee</code>、<code class="language-plaintext highlighter-rouge">arguments.caller</code> 将会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">;</span>
<span class="p">};</span>

<span class="nf">f</span><span class="p">();</span> <span class="c1">// 报错</span>
</code></pre></div></div> <h4 id="5禁止删除变量">（5）禁止删除变量</h4> <p>严格模式下无法删除变量，如果使用 <code class="language-plaintext highlighter-rouge">delete</code> 命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的 <code class="language-plaintext highlighter-rouge">configurable: true</code>，才能被 <code class="language-plaintext highlighter-rouge">delete</code> 命令删除。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// 语法错误</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// 删除成功</span>
</code></pre></div></div> <h3 id="55-静态绑定">5.5 静态绑定</h3> <h4 id="1禁止使用-with-语句">（1）禁止使用 with 语句</h4> <p>严格模式下，使用 <code class="language-plaintext highlighter-rouge">with</code> 语句将报错。因为 <code class="language-plaintext highlighter-rouge">with</code> 语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nf">with </span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Uncaught SyntaxError: Strict mode code may not include a with statement</span>
</code></pre></div></div> <h4 id="2创设-eval-作用域">（2）创设 eval 作用域</h4> <p>正常模式下，JavaScript 语言有两种变量作用域（scope）：<strong>全局作用域</strong>和<strong>函数作用域</strong>。严格模式创设了第三种作用域：<strong>eval 作用域</strong>。</p> <p>正常模式下，<code class="language-plaintext highlighter-rouge">eval</code> 语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code class="language-plaintext highlighter-rouge">eval</code> 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code class="language-plaintext highlighter-rouge">eval</code> 所生成的变量只能用于 <code class="language-plaintext highlighter-rouge">eval</code> 内部。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="dl">'</span><span class="s1">var x = 5; x</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// 5</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="p">})()</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">eval</code> 语句内部是一个独立作用域，所以内部的变量 <code class="language-plaintext highlighter-rouge">x</code> 不会泄露到外部。</p> <h4 id="3arguments-不再追踪参数的变化">（3）arguments 不再追踪参数的变化</h4> <p>变量 <code class="language-plaintext highlighter-rouge">arguments</code> 代表函数的参数。严格模式下，函数内部改变参数与 <code class="language-plaintext highlighter-rouge">arguments</code> 的联系被切断了，两者不再存在联动关系。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 正常模式为[2, 2]</span>

<span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 严格模式为[2, 1]</span>
</code></pre></div></div> <h3 id="56-保留字">5.6 保留字</h3> <p>严格模式新增了一些保留字（<code class="language-plaintext highlighter-rouge">implements</code>、<code class="language-plaintext highlighter-rouge">interface</code>、<code class="language-plaintext highlighter-rouge">let</code>、<code class="language-plaintext highlighter-rouge">package</code>、<code class="language-plaintext highlighter-rouge">private</code>、<code class="language-plaintext highlighter-rouge">protected</code>、<code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">static</code>、<code class="language-plaintext highlighter-rouge">yield</code> 等）。使用这些词作为变量名将会报错。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/oop/">JavaScript 教程 - 面向对象编程</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 面向对象编程》一章中部分知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry><entry><title type="html">《JavaScript 教程》摘录</title><link href="https://feng-zhang0712.github.io//blog/2024/features/" rel="alternate" type="text/html" title="《JavaScript 教程》摘录"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://feng-zhang0712.github.io//blog/2024/features</id><content type="html" xml:base="https://feng-zhang0712.github.io//blog/2024/features/"><![CDATA[<blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/features/">《JavaScript 教程 - 语法专题》</a>一章中部分知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一数据类型的转换">一、数据类型的转换</h2> <h3 id="11-强制转换">1.1 强制转换</h3> <p>强制转换主要指使用 <code class="language-plaintext highlighter-rouge">Boolean()</code>、<code class="language-plaintext highlighter-rouge">Number()</code> 和 <code class="language-plaintext highlighter-rouge">String()</code> 三个函数，手动转换成布尔值、数字或者字符串。</p> <h4 id="1boolean">（1）Boolean()</h4> <p><code class="language-plaintext highlighter-rouge">Boolean()</code> 将任意类型的值转为布尔值。除了以下五个值的转换结果为 <code class="language-plaintext highlighter-rouge">false</code>，其他的值全部为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <ul> <li><code class="language-plaintext highlighter-rouge">undefined</code></li> <li><code class="language-plaintext highlighter-rouge">null</code></li> <li><code class="language-plaintext highlighter-rouge">NaN</code></li> <li><code class="language-plaintext highlighter-rouge">0</code>（包含 <code class="language-plaintext highlighter-rouge">-0</code> 和 <code class="language-plaintext highlighter-rouge">+0</code>）</li> <li><code class="language-plaintext highlighter-rouge">''</code>（空字符串）</li> </ul> <p>所有对象的布尔值都是 <code class="language-plaintext highlighter-rouge">true</code>，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于 <code class="language-plaintext highlighter-rouge">obj1</code> &amp;&amp; <code class="language-plaintext highlighter-rouge">obj2</code> 这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Boolean</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nc">Boolean</span><span class="p">(</span><span class="k">new</span> <span class="nc">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="2number">（2）Number()</h4> <p><code class="language-plaintext highlighter-rouge">Number()</code> 将任意类型的值转化成数值。</p> <h5 id="a-原始类型值">a. 原始类型值</h5> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数值：转换后还是原来的值</span>
<span class="nc">Number</span><span class="p">(</span><span class="mi">324</span><span class="p">)</span> <span class="c1">// 324</span>

<span class="c1">// 字符串：如果可以被解析为数值，则转换为相应的数值</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">324</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 324</span>

<span class="c1">// 字符串：如果不可以被解析为数值，返回 NaN</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">324abc</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// NaN</span>

<span class="c1">// 空字符串转为0</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">''</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="c1">// 布尔值：true 转成 1，false 转成 0</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="c1">// undefined：转成 NaN</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// NaN</span>

<span class="c1">// null：转成 0</span>
<span class="nc">Number</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 0</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Number()</code> 将字符串转为数值，要比 <code class="language-plaintext highlighter-rouge">parseInt()</code> 严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为 <code class="language-plaintext highlighter-rouge">NaN</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 42</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">42 cats</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// NaN</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">parseInt()</code> 和 <code class="language-plaintext highlighter-rouge">Number()</code> 都会自动过滤一个字符串前导和后缀的空格。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="se">\t\</span><span class="s1">v</span><span class="se">\r</span><span class="s1">12.34</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 12</span>
<span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="se">\t\</span><span class="s1">v</span><span class="se">\r</span><span class="s1">12.34</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 12.34</span>
</code></pre></div></div> <h5 id="b-对象">b. 对象</h5> <p><code class="language-plaintext highlighter-rouge">Number()</code> 的参数是对象时，将返回 <code class="language-plaintext highlighter-rouge">NaN</code>，除非是包含单个数值的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// NaN</span>
<span class="nc">Number</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// NaN</span>
<span class="nc">Number</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// 5</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Number()</code> 的参数是对象时的转换规则是这样。</p> <ol> <li>调用对象自身的 <code class="language-plaintext highlighter-rouge">valueOf()</code>。如果返回原始类型的值，则直接对该值使用 <code class="language-plaintext highlighter-rouge">Number()</code>，不再进行后续步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 返回的还是对象，则改为调用对象自身的 <code class="language-plaintext highlighter-rouge">toString()</code>。如果 <code class="language-plaintext highlighter-rouge">toString()</code> 返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">Number()</code>，不再进行后续步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">toString()</code> 返回的是对象，就报错。</li> </ol> <p>默认情况下，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 返回对象本身，所以一般总是会调用 <code class="language-plaintext highlighter-rouge">toString()</code>，而 <code class="language-plaintext highlighter-rouge">toString()</code> 返回对象的类型字符串（比如 <code class="language-plaintext highlighter-rouge">[object Object]</code>）。当然，对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code> 都是可以自定义的。</p> <h4 id="3string">（3）String()</h4> <p><code class="language-plaintext highlighter-rouge">String()</code> 可以将任意类型的值转化成字符串。</p> <h5 id="a-原始类型值-1">a. 原始类型值</h5> <ul> <li><strong>数值</strong>：转为相应的字符串。</li> <li><strong>字符串</strong>：转换后还是原来的值。</li> <li><strong>布尔值</strong>：<code class="language-plaintext highlighter-rouge">true</code> 转为字符串 <code class="language-plaintext highlighter-rouge">"true"</code>，<code class="language-plaintext highlighter-rouge">false</code> 转为字符串 <code class="language-plaintext highlighter-rouge">"false"</code>。</li> <li><strong>undefined</strong>：转为字符串 <code class="language-plaintext highlighter-rouge">"undefined"</code>。</li> <li><strong>null</strong>：转为字符串 <code class="language-plaintext highlighter-rouge">"null"</code>。</li> </ul> <h5 id="b-对象-1">b. 对象</h5> <p><code class="language-plaintext highlighter-rouge">String()</code> 的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// "[object Object]"</span>
<span class="nc">String</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// "1,2,3"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">String()</code> 的参数是对象时的转换规则跟 <code class="language-plaintext highlighter-rouge">Number()</code> 类似，只是互换了 <code class="language-plaintext highlighter-rouge">valueOf()</code> 和 <code class="language-plaintext highlighter-rouge">toString()</code> 的执行顺序。</p> <ul> <li>先调用对象自身的 <code class="language-plaintext highlighter-rouge">toString()</code>。如果返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">String()</code>，不再进行以下步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">toString()</code> 返回的是对象，再调用原对象的 <code class="language-plaintext highlighter-rouge">valueOf()</code>。如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 返回原始类型的值，则对该值使用 <code class="language-plaintext highlighter-rouge">String()</code>，不再进行以下步骤。</li> <li>如果 <code class="language-plaintext highlighter-rouge">valueOf()</code> 返回的是对象，就报错。</li> </ul> <h3 id="12-自动转换">1.2 自动转换</h3> <p>自动转换发生在三种情况：不同类型的数据互相运算、对非布尔值类型的数据求布尔值以及对非数值类型的值使用一元运算符（即 <code class="language-plaintext highlighter-rouge">+</code> 和 <code class="language-plaintext highlighter-rouge">-</code>）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">123</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span> <span class="c1">// "123abc"</span>
<span class="k">if </span><span class="p">(</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>  <span class="c1">// "hello"</span>
<span class="o">+</span> <span class="p">{</span><span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">}</span> <span class="c1">// NaN</span>
<span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1">// NaN</span>
</code></pre></div></div> <h4 id="1自动转换为布尔值">（1）自动转换为布尔值</h4> <p>预期为布尔值的地方（比如 <code class="language-plaintext highlighter-rouge">if</code> 语句的条件部分），系统内部会自动调用 <code class="language-plaintext highlighter-rouge">Boolean()</code> 将非布尔值的参数自动转换为布尔值。</p> <h4 id="2自动转换为字符串">（2）自动转换为字符串</h4> <p>预期为字符串的地方，就会将非字符串的值自动转为字符串。主要发生在字符串的加法运算时，当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p> <h4 id="3自动转换为数值">（3）自动转换为数值</h4> <p>预期为数值的地方，系统内部会自动调用 <code class="language-plaintext highlighter-rouge">Number()</code> 将参数值自动转换为数值。除了加法运算符（<code class="language-plaintext highlighter-rouge">+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p> <h2 id="二错误处理机制">二、错误处理机制</h2> <h3 id="21-error-实例对象">2.1 Error 实例对象</h3> <p>JavaScript 抛出的错误都是 <code class="language-plaintext highlighter-rouge">Error</code> 构造函数的实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">err</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">出错了</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">err</span><span class="p">.</span><span class="nx">message</span> <span class="c1">// "出错了"</span>
</code></pre></div></div> <p>JavaScript 语言标准只提到，<code class="language-plaintext highlighter-rouge">Error</code> 实例对象必须有 <code class="language-plaintext highlighter-rouge">message</code> 属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对 <code class="language-plaintext highlighter-rouge">Error</code> 实例还提供 <code class="language-plaintext highlighter-rouge">name</code> 和 <code class="language-plaintext highlighter-rouge">stack</code> 属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p> <ul> <li><code class="language-plaintext highlighter-rouge">message</code>：错误提示信息</li> <li><code class="language-plaintext highlighter-rouge">name</code>：错误名称（非标准属性）</li> <li><code class="language-plaintext highlighter-rouge">stack</code>：错误的堆栈（非标准属性）</li> </ul> <h3 id="22-原生错误类型">2.2 原生错误类型</h3> <p>JavaScript 在 <code class="language-plaintext highlighter-rouge">Error</code> 对象的基础上，定义了其他 6 种派生对象。</p> <h4 id="1syntaxerror-对象">（1）SyntaxError 对象</h4> <p><code class="language-plaintext highlighter-rouge">SyntaxError</code> 对象是解析代码时发生的语法错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 变量名错误</span>
<span class="kd">var</span> <span class="mi">1</span><span class="nx">a</span><span class="p">;</span>
<span class="c1">// Uncaught SyntaxError: Invalid or unexpected token</span>

<span class="c1">// 缺少括号</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Uncaught SyntaxError: Unexpected string</span>
</code></pre></div></div> <h4 id="2referenceerror-对象">（2）ReferenceError 对象</h4> <p><code class="language-plaintext highlighter-rouge">ReferenceError</code> 对象是引用一个不存在的变量时发生的错误。</p> <h4 id="3rangeerror-对象">（3）RangeError 对象</h4> <p><code class="language-plaintext highlighter-rouge">RangeError</code> 对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是 <code class="language-plaintext highlighter-rouge">Number</code> 对象的方法参数超出范围，以及函数堆栈超过最大值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组长度不得为负数</span>
<span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Uncaught RangeError: Invalid array length</span>
</code></pre></div></div> <h4 id="4typeerror-对象">（4）TypeError 对象</h4> <p><code class="language-plaintext highlighter-rouge">TypeError</code> 对象是变量或参数不是预期类型时发生的错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="mi">123</span>
<span class="c1">// Uncaught TypeError: 123 is not a constructor</span>
</code></pre></div></div> <h4 id="25-urierror-对象">2.5 URIError 对象</h4> <p><code class="language-plaintext highlighter-rouge">URIError</code> 对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及 <code class="language-plaintext highlighter-rouge">encodeURI()</code>、<code class="language-plaintext highlighter-rouge">decodeURI()</code>、<code class="language-plaintext highlighter-rouge">encodeURIComponent()</code>、<code class="language-plaintext highlighter-rouge">decodeURIComponent()</code>、<code class="language-plaintext highlighter-rouge">escape()</code> 和 <code class="language-plaintext highlighter-rouge">unescape()</code> 这六个函数。</p> <h4 id="26-evalerror-对象">2.6 EvalError 对象</h4> <p><code class="language-plaintext highlighter-rouge">eval</code> 函数没有被正确执行时，会抛出 <code class="language-plaintext highlighter-rouge">EvalError</code> 错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p> <h3 id="23-自定义错误">2.3 自定义错误</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">UserError</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">默认信息</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">UserError</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">UserError</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">();</span>
<span class="nx">UserError</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">UserError</span><span class="p">;</span>

<span class="k">new</span> <span class="nc">UserError</span><span class="p">(</span><span class="dl">'</span><span class="s1">这是自定义的错误！</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码自定义一个错误对象 <code class="language-plaintext highlighter-rouge">UserError</code>，让它<strong>继承</strong> <code class="language-plaintext highlighter-rouge">Error</code> 对象。然后，就可以生成这种自定义类型的错误了。</p> <h3 id="24-throw-语句">2.4 throw 语句</h3> <p><code class="language-plaintext highlighter-rouge">throw</code> 语句用于手动中断程序执行，抛出一个错误。可以是系统错误，也可以是自定义错误。实际上，<code class="language-plaintext highlighter-rouge">throw</code> 可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p> <h3 id="25-trycatch-和-trycatchfinally-结构">2.5 try…catch 和 try…catch…finally 结构</h3> <p><code class="language-plaintext highlighter-rouge">catch</code> 代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。下面的例子反映了 <code class="language-plaintext highlighter-rouge">try...catch...finally</code> 三者之间的执行顺序。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">throw</span> <span class="dl">'</span><span class="s1">bug</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 这句原本会延迟到 finally 代码块结束再执行</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 不会运行</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 这句会覆盖掉前面那句 return</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 不会运行</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 不会运行</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nf">f</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="c1">// 1</span>
<span class="c1">// 3</span>
<span class="nx">result</span>
<span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">catch</code> 代码块结束执行之前，会先执行 <code class="language-plaintext highlighter-rouge">finally</code> 代码块。</p> <h2 id="三编程风格">三、编程风格</h2> <ul> <li>缩进：不管是空格和 Tab 键，坚持使用一种方式。</li> <li> <p>区块：总是使用<strong>大括号</strong>表示区块。区块起首的大括号跟在关键字的后面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">block</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>圆括号：圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。建议可以用空格，区分这两种不同的括号。</p> <ul> <li>表示函数调用和定义时，函数名与左括号之间没有空格。</li> <li>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</li> </ul> </li> <li> <p>行尾的分号：不使用分号的情况</p> <ul> <li><code class="language-plaintext highlighter-rouge">for</code> 和 <code class="language-plaintext highlighter-rouge">while</code> 循环</li> <li>分支语句：<code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">switch</code> 和 <code class="language-plaintext highlighter-rouge">try</code></li> <li>函数的声明语句</li> </ul> <p>除了上边三种情况，所有语句都应该使用分号（即使如果没有使用分号，大多数情况下，JavaScript 会自动添加）。</p> </li> <li>全局变量：避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如 <code class="language-plaintext highlighter-rouge">UPPER_CASE</code>。</li> <li>变量声明：变量最好放在代码块的头部。所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</li> <li><code class="language-plaintext highlighter-rouge">with</code> 语句：<code class="language-plaintext highlighter-rouge">with</code> 可以减少代码的书写，但是会造成混淆。因此，不要使用 <code class="language-plaintext highlighter-rouge">with</code> 语句。</li> <li>相等和严格相等：相等运算符会自动转换变量类型，造成很多意想不到的情况。建议不要使用相等运算符（<code class="language-plaintext highlighter-rouge">==</code>），只使用严格相等运算符（<code class="language-plaintext highlighter-rouge">===</code>）。</li> <li>语句的合并：建议不要将不同目的的语句，合并成一行。</li> <li>自增和自减运算符：建议自增（<code class="language-plaintext highlighter-rouge">++</code>）和自减（<code class="language-plaintext highlighter-rouge">--</code>）运算符尽量使用 <code class="language-plaintext highlighter-rouge">+=</code> 和 <code class="language-plaintext highlighter-rouge">-=</code> 代替。</li> <li> <p><code class="language-plaintext highlighter-rouge">switch...case</code> 结构：<code class="language-plaintext highlighter-rouge">switch...case</code> 结构要求，在每个 <code class="language-plaintext highlighter-rouge">case</code> 的最后一行必须是 <code class="language-plaintext highlighter-rouge">break</code> 语句，否则会接着运行下一个 <code class="language-plaintext highlighter-rouge">case</code>。这样不仅容易忘记，还会造成代码的冗长。而且，<code class="language-plaintext highlighter-rouge">switch...case</code> 不使用大括号，不利于代码形式的统一。此外，这种结构类似于 <code class="language-plaintext highlighter-rouge">goto</code> 语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch </span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid action.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面的代码建议改写成对象结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">doAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">actions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">hack</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">slash</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">run</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">actions</span><span class="p">[</span><span class="nx">action</span><span class="p">]</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid action.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">actions</span><span class="p">[</span><span class="nx">action</span><span class="p">]();</span>
<span class="p">}</span>
</code></pre></div> </div> <p>因此，建议 <code class="language-plaintext highlighter-rouge">switch...case</code> 结构可以用对象结构代替。</p> </li> </ul> <h2 id="四console-对象与控制台">四、console 对象与控制台</h2> <h3 id="41-console-对象">4.1 console 对象</h3> <p><code class="language-plaintext highlighter-rouge">console</code> 对象可以输出各种信息到控制台。<code class="language-plaintext highlighter-rouge">console</code> 的常见用途有两个。</p> <ul> <li>调试程序，显示网页代码运行时的错误信息。</li> <li>提供了一个命令行接口，用来与网页代码互动。</li> </ul> <h3 id="42-console-对象的静态方法">4.2 console 对象的静态方法</h3> <h4 id="1consolelogconsoleinfoconsoledebug">（1）console.log()，console.info()，console.debug()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">console.log()</code> 用于在控制台输出信息。它可以接受一个或多个参数，不同类型的数据必须使用对应的占位符。</p> <ul> <li><code class="language-plaintext highlighter-rouge">%s</code> 字符串</li> <li><code class="language-plaintext highlighter-rouge">%d</code> 整数</li> <li><code class="language-plaintext highlighter-rouge">%i</code> 整数</li> <li><code class="language-plaintext highlighter-rouge">%f</code> 浮点数</li> <li><code class="language-plaintext highlighter-rouge">%o</code> 对象的链接</li> <li><code class="language-plaintext highlighter-rouge">%c</code> CSS 格式字符串</li> </ul> <p>使用 <code class="language-plaintext highlighter-rouge">%c</code> 占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">%cThis text is styled!</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">color: red; background: yellow; font-size: 24px;</span><span class="dl">'</span>
<span class="p">)</span>
</code></pre></div> </div> <p>上面代码运行后，输出的内容将显示为黄底红字。</p> </li> <li><code class="language-plaintext highlighter-rouge">console.info()</code> 是 <code class="language-plaintext highlighter-rouge">console.log</code> 的别名，用法完全一样。只不过 <code class="language-plaintext highlighter-rouge">console.info</code> 方法会在输出信息的前面，加上一个蓝色图标。</li> <li><code class="language-plaintext highlighter-rouge">console.debug()</code> 与 <code class="language-plaintext highlighter-rouge">console.log</code> 类似，会在控制台输出调试信息。默认情况下，<code class="language-plaintext highlighter-rouge">console.debug</code> 输出的信息不会显示，只有在打开显示级别在 <code class="language-plaintext highlighter-rouge">verbose</code> 的情况下，才会显示。</li> </ul> <p><code class="language-plaintext highlighter-rouge">console</code> 对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义 <code class="language-plaintext highlighter-rouge">console.log</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">log</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">info</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">warn</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">]</span> <span class="o">=</span> <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nf">bind</span><span class="p">(</span>
    <span class="nx">console</span><span class="p">,</span>
    <span class="k">new</span> <span class="nc">Date</span><span class="p">().</span><span class="nf">toISOString</span><span class="p">()</span>
  <span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">出错了！</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// 2014-05-18T09:00.000Z 出错了！</span>
</code></pre></div></div> <h4 id="2consolewarnconsoleerror">（2）console.warn()，console.error()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">console.warn()</code> 输出信息时，在最前面加一个黄色三角，表示警告。</li> <li><code class="language-plaintext highlighter-rouge">console.error()</code> 输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。</li> </ul> <h4 id="3consoletable">（3）console.table()</h4> <p>对于某些复合类型的数据，<code class="language-plaintext highlighter-rouge">console.table()</code> 可以将其转为表格显示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">languages</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">JavaScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.js</span><span class="dl">"</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TypeScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.ts</span><span class="dl">"</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">CoffeeScript</span><span class="dl">"</span><span class="p">,</span> <span class="na">fileExtension</span><span class="p">:</span> <span class="dl">"</span><span class="s2">.coffee</span><span class="dl">"</span> <span class="p">}</span>
<span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">table</span><span class="p">(</span><span class="nx">languages</span><span class="p">);</span>
</code></pre></div></div> <table> <thead> <tr> <th>-(index)-</th> <th>-name-</th> <th>-fileExtension-</th> </tr> </thead> <tbody> <tr> <td>0 -</td> <td>“JavaScript”</td> <td>“.js”</td> </tr> <tr> <td>1 -</td> <td>“TypeScript”</td> <td>“.ts”</td> </tr> <tr> <td>2 -</td> <td>“CoffeeScript”</td> <td>“.coffee”</td> </tr> </tbody> </table> <h4 id="4consolecount">（4）console.count()</h4> <p><code class="language-plaintext highlighter-rouge">console.count()</code> 用于计数，输出它被调用了多少次。该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p> <h4 id="5consoledirconsoledirxml">（5）console.dir()，console.dirxml()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">console.dir()</code> 用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">({</span><span class="na">f1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="na">f2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">})</span>
<span class="c1">// Object {f1: "foo", f2: "bar"}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">dir</span><span class="p">({</span><span class="na">f1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="na">f2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">})</span>
<span class="c1">// Object</span>
<span class="c1">//   f1: "foo"</span>
<span class="c1">//   f2: "bar"</span>
<span class="c1">//   __proto__: Object</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">console.dirxml()</code> 主要用于以目录树的形式，显示 DOM 节点。如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code class="language-plaintext highlighter-rouge">console.dirxml</code> 等同于 <code class="language-plaintext highlighter-rouge">console.dir</code>。</p> </li> </ul> <h4 id="6consoleassert">（6）console.assert()</h4> <p><code class="language-plaintext highlighter-rouge">console.assert()</code> 主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p> <p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为 <code class="language-plaintext highlighter-rouge">false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">assert</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="dl">'</span><span class="s1">判断条件不成立</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Assertion failed: 判断条件不成立</span>
</code></pre></div></div> <h4 id="7consoletimeconsoletimeend">（7）console.time()，console.timeEnd()</h4> <p>这两个方法用于计时，可以算出一个操作所花费的准确时间。<code class="language-plaintext highlighter-rouge">time</code> 方法表示计时开始，<code class="language-plaintext highlighter-rouge">timeEnd</code> 方法表示计时结束。它们的参数是计时器的名称。调用 <code class="language-plaintext highlighter-rouge">timeEnd</code> 方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">time</span><span class="p">(</span><span class="dl">'</span><span class="s1">Array initialize</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">array</span><span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">timeEnd</span><span class="p">(</span><span class="dl">'</span><span class="s1">Array initialize</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// Array initialize: 1914.481ms</span>
</code></pre></div></div> <h4 id="8consolegroupconsolegroupendconsolegroupcollapsed">（8）console.group()，console.groupEnd()，console.groupCollapsed()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">console.group</code> 和 <code class="language-plaintext highlighter-rouge">console.groupEnd</code> 这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</li> <li><code class="language-plaintext highlighter-rouge">console.groupCollapsed</code> 方法与 <code class="language-plaintext highlighter-rouge">console.group</code> 方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</li> </ul> <h4 id="9consoletraceconsoleclear">（9）console.trace()，console.clear()</h4> <ul> <li><code class="language-plaintext highlighter-rouge">console.trace</code> 方法显示当前执行的代码在堆栈中的调用路径。</li> <li><code class="language-plaintext highlighter-rouge">console.clear</code> 方法用于清除当前控制台的所有输出，将光标回置到第一行。</li> </ul> <h3 id="43-控制台命令行-api">4.3 控制台命令行 API</h3> <p>浏览器控制台中，除了使用 <code class="language-plaintext highlighter-rouge">console</code> 对象，还可以使用一些控制台自带的命令行方法。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">$_</code>：返回上一个表达式的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="c1">// 4</span>
<span class="nx">$_</span>
<span class="c1">// 4</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">$0</code> - <code class="language-plaintext highlighter-rouge">$4</code>：控制台保存了最近 5 个在 Elements 面板选中的 DOM 元素，<code class="language-plaintext highlighter-rouge">$0</code> 代表倒数第一个（最近一个），<code class="language-plaintext highlighter-rouge">$1</code> 代表倒数第二个，以此类推直到 <code class="language-plaintext highlighter-rouge">$4</code>。</li> <li><code class="language-plaintext highlighter-rouge">$(selector)</code>：返回第一个匹配的元素，等同于 <code class="language-plaintext highlighter-rouge">document.querySelector()</code>。注意，如果页面脚本对 <code class="language-plaintext highlighter-rouge">$</code> 有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行 <code class="language-plaintext highlighter-rouge">$(selector)</code> 就会采用 jQuery 的实现，返回一个数组。</li> <li><code class="language-plaintext highlighter-rouge">$$(selector)</code>：返回选中的 DOM 对象，等同于 <code class="language-plaintext highlighter-rouge">document.querySelectorAll</code>。</li> <li> <p><code class="language-plaintext highlighter-rouge">$x(path)</code>：返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">$x</span><span class="p">(</span><span class="dl">"</span><span class="s2">//p[a]</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">inspect(object)</code>：打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在 Elements 面板中显示，比如 <code class="language-plaintext highlighter-rouge">inspect(document)</code> 会在 Elements 面板显示 <code class="language-plaintext highlighter-rouge">document</code> 元素。JavaScript 对象在控制台面板 Profiles 面板中显示，比如 <code class="language-plaintext highlighter-rouge">inspect(window)</code>。</li> <li><code class="language-plaintext highlighter-rouge">getEventListeners(object)</code>：返回一个对象，该对象的成员为 <code class="language-plaintext highlighter-rouge">object</code> 登记了回调函数的各种事件（比如 <code class="language-plaintext highlighter-rouge">click</code> 或 <code class="language-plaintext highlighter-rouge">keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</li> <li><code class="language-plaintext highlighter-rouge">keys(object)</code>：返回一个数组，包含 <code class="language-plaintext highlighter-rouge">object</code> 的所有键名。</li> <li> <p><code class="language-plaintext highlighter-rouge">values(object)</code>：返回一个数组，包含 <code class="language-plaintext highlighter-rouge">object</code> 的所有键值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="dl">'</span><span class="s1">p1</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">p2</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">};</span>
<span class="nf">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
<span class="c1">// ["p1", "p2"]</span>
<span class="nf">values</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
<span class="c1">// ["a", "b"]</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">monitorEvents(object[, events])</code> 监听特定对象上发生的特定事件。事件发生时，会返回一个 <code class="language-plaintext highlighter-rouge">Event</code> 对象，包含该事件的相关信息。</li> <li> <p><code class="language-plaintext highlighter-rouge">unmonitorEvents(object[, events])</code> 用于停止监听。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="dl">"</span><span class="s2">resize</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">monitorEvents</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">resize</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">scroll</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div> </div> <p>上面代码分别表示单个事件和多个事件的监听方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nx">$0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">mouse</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">unmonitorEvents</span><span class="p">(</span><span class="nx">$0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码表示如何停止监听。</p> <p><code class="language-plaintext highlighter-rouge">monitorEvents</code> 允许监听同一大类的事件。所有事件可以分成四个大类。</p> <ul> <li>mouse：<code class="language-plaintext highlighter-rouge">mousedown</code>, <code class="language-plaintext highlighter-rouge">mouseup</code>, <code class="language-plaintext highlighter-rouge">click</code>, <code class="language-plaintext highlighter-rouge">dblclick</code>, <code class="language-plaintext highlighter-rouge">mousemove</code>, <code class="language-plaintext highlighter-rouge">mouseover</code>, <code class="language-plaintext highlighter-rouge">mouseout</code>, <code class="language-plaintext highlighter-rouge">mousewheel</code></li> <li>key：<code class="language-plaintext highlighter-rouge">keydown</code>, <code class="language-plaintext highlighter-rouge">keyup</code>, <code class="language-plaintext highlighter-rouge">keypress</code>, <code class="language-plaintext highlighter-rouge">textInput</code></li> <li>touch：<code class="language-plaintext highlighter-rouge">touchstart</code>, <code class="language-plaintext highlighter-rouge">touchmove</code>, <code class="language-plaintext highlighter-rouge">touchend</code>, <code class="language-plaintext highlighter-rouge">touchcancel</code></li> <li>control：<code class="language-plaintext highlighter-rouge">resize</code>, <code class="language-plaintext highlighter-rouge">scroll</code>, <code class="language-plaintext highlighter-rouge">zoom</code>, <code class="language-plaintext highlighter-rouge">focus</code>, <code class="language-plaintext highlighter-rouge">blur</code>, <code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">change</code>, <code class="language-plaintext highlighter-rouge">submit</code>, <code class="language-plaintext highlighter-rouge">reset</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monitorEvents</span><span class="p">(</span><span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#msg</span><span class="dl">"</span><span class="p">),</span> <span class="dl">"</span><span class="s2">key</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码表示监听所有 <code class="language-plaintext highlighter-rouge">key</code> 大类的事件。</p> </li> <li> <p>其他方法：命令行 API 还提供以下方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">clear()</code>：清除控制台的历史。</li> <li><code class="language-plaintext highlighter-rouge">copy(object)</code>：复制特定 DOM 元素到剪贴板。</li> <li><code class="language-plaintext highlighter-rouge">dir(object)</code>：显示特定对象的所有属性，是 <code class="language-plaintext highlighter-rouge">console.dir</code> 方法的别名。</li> <li><code class="language-plaintext highlighter-rouge">dirxml(object)</code>：显示特定对象的 XML 形式，是 <code class="language-plaintext highlighter-rouge">console.dirxml</code> 方法的别名。</li> </ul> </li> </ul> <h3 id="44-debugger-语句">4.4 debugger 语句</h3> <p><code class="language-plaintext highlighter-rouge">debugger</code> 语句主要用于除错，作用是设置断点。</p> <h2 id="五参考">五、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/features/">JavaScript 教程 - 语法专题</a></li> </ul>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[本文是对《JavaScript 教程 - 语法专题》一章中部分知识点的摘录，请访问原文，获取更多详细信息。]]></summary></entry></feed>