<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 《JavaScript 教程》摘录 | Zhang Feng </title> <meta name="author" content="Zhang Feng"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://feng-zhang0712.github.io//blog/2024/oop/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Zhang</span> Feng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">《JavaScript 教程》摘录</h1> <p class="post-meta"> Created in October 11, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/javascript"> <i class="fa-solid fa-hashtag fa-sm"></i> javascript</a>   <a href="/blog/tag/oop"> <i class="fa-solid fa-hashtag fa-sm"></i> oop</a>   ·   <a href="/blog/category/blog"> <i class="fa-solid fa-tag fa-sm"></i> blog</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/oop/" rel="external nofollow noopener" target="_blank">《JavaScript 教程 - 面向对象编程》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一实例对象与-new-命令">一、实例对象与 new 命令</h2> <h3 id="1-对象是什么">1. 对象是什么</h3> <ul> <li>对象是单个实物的<strong>抽象</strong>。</li> <li>对象是一个<strong>容器</strong>，封装了属性（property）和方法（method）。</li> </ul> <h3 id="2-构造函数">2. 构造函数</h3> <p>JavaScript 语言的对象体系，不是基于“类”的，而是基于<strong>构造函数</strong>（constructor）和<strong>原型链</strong>（prototype）。</p> <p>构造函数（constructor）是用来生成实例对象的函数，作为对象的模板。构造函数的特点有两个。</p> <ul> <li>函数体内部使用了 <code class="language-plaintext highlighter-rouge">this</code> 关键字，代表了所要生成的对象实例。</li> <li>生成对象的时候，必须使用 <code class="language-plaintext highlighter-rouge">new</code> 命令。</li> </ul> <h3 id="3-new-命令">3. new 命令</h3> <h4 id="31-基本用法">3.1 基本用法</h4> <p><code class="language-plaintext highlighter-rouge">new</code> 命令用于执行构造函数，返回实例对象。</p> <p>如果忘记使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，直接调用构造函数，此时构造函数就变成了<strong>普通函数</strong>，并不会生成实例对象。此时 <code class="language-plaintext highlighter-rouge">this</code> 代表全局对象，将造成一些意想不到的结果。</p> <ul> <li> <p>一个解决办法是，构造函数内部使用严格模式，即第一行加上 <code class="language-plaintext highlighter-rouge">use strict</code>。这样的话，一旦忘了使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，直接调用构造函数就会报错。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">){</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">Fubar</span><span class="p">()</span>
<span class="c1">// TypeError: Cannot set property '_foo' of undefined</span>
</code></pre></div> </div> </li> <li> <p>另一个解决办法，构造函数内部判断是否使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，如果发现没有使用，则直接返回一个实例对象。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Fubar</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">Fubar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="nx">_foo</span> <span class="c1">// 1</span>
<span class="p">(</span><span class="k">new</span> <span class="nc">Fubar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)).</span><span class="nx">_foo</span> <span class="c1">// 1</span>
</code></pre></div> </div> </li> </ul> <h4 id="32-new-命令的原理">3.2 new 命令的原理</h4> <p>使用 new 命令时，它后面的函数依次执行下面的步骤。</p> <ol> <li>创建一个<strong>空对象</strong>，作为将要返回的对象实例。</li> <li>将这个空对象的<strong>原型</strong>，指向构造函数的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性。</li> <li>将这个空对象赋值给函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 关键字。</li> <li>开始执行构造函数内部的代码。</li> </ol> <p>也就是说，构造函数内部，<code class="language-plaintext highlighter-rouge">this</code> 指的是一个新生成的空对象，所有针对 <code class="language-plaintext highlighter-rouge">this</code> 的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即 <code class="language-plaintext highlighter-rouge">this</code> 对象），将其“构造”为需要的样子。</p> <ul> <li>如果构造函数内部有 <code class="language-plaintext highlighter-rouge">return</code> 语句，而且 <code class="language-plaintext highlighter-rouge">return</code> 后面跟着一个<strong>对象</strong>，<code class="language-plaintext highlighter-rouge">new</code> 命令会返回 <code class="language-plaintext highlighter-rouge">return</code> 语句指定的<strong>对象</strong>；否则，就会不管 <code class="language-plaintext highlighter-rouge">return</code> 语句，返回 <code class="language-plaintext highlighter-rouge">this</code> 对象。</li> <li>如果 <code class="language-plaintext highlighter-rouge">return</code> 语句返回的是一个跟 <code class="language-plaintext highlighter-rouge">this</code> 无关的<strong>新对象</strong>，<code class="language-plaintext highlighter-rouge">new</code> 命令会返回这个<strong>新对象</strong>，而不是 <code class="language-plaintext highlighter-rouge">this</code> 对象。</li> <li> <p>如果对普通函数（内部没有 <code class="language-plaintext highlighter-rouge">this</code> 关键字的函数）使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，则会返回一个<strong>空对象</strong>。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getMessage</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">this is a message</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">getMessage</span><span class="p">();</span>

<span class="nx">msg</span> <span class="c1">// {}</span>
<span class="k">typeof</span> <span class="nx">msg</span> <span class="c1">// "object"</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">getMessage()</code> 是一个普通函数，返回一个字符串。对它使用 <code class="language-plaintext highlighter-rouge">new</code> 命令，会得到一个<strong>空对象</strong>。这是因为 <code class="language-plaintext highlighter-rouge">new</code> 命令总是返回一个对象，要么是实例对象，要么是 <code class="language-plaintext highlighter-rouge">return</code> 语句指定的对象。本例中，<code class="language-plaintext highlighter-rouge">return</code> 语句返回的是字符串，所以 <code class="language-plaintext highlighter-rouge">new</code> 命令就忽略了该语句。</p> </li> </ul> <p><code class="language-plaintext highlighter-rouge">new</code> 命令简化的内部流程，可以用下面的代码表示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">_new</span><span class="p">(</span><span class="cm">/* 构造函数 */</span> <span class="kd">constructor</span><span class="p">,</span> <span class="cm">/* 构造函数参数 */</span> <span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 将 arguments 对象转为数组</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="c1">// 取出构造函数</span>
  <span class="kd">var</span> <span class="kd">constructor</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
  <span class="c1">// 创建一个空对象，继承构造函数的 prototype 属性</span>
  <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="c1">// 执行构造函数</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="kd">constructor</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="c1">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span>
  <span class="k">return </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">result</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">?</span> <span class="nx">result</span> <span class="p">:</span> <span class="nx">context</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 实例</span>
<span class="kd">var</span> <span class="nx">actor</span> <span class="o">=</span> <span class="nf">_new</span><span class="p">(</span><span class="nx">Person</span><span class="p">,</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
</code></pre></div></div> <h4 id="33-newtarget">3.3 new.target</h4> <p>函数内部可以使用 <code class="language-plaintext highlighter-rouge">new.target</code> 属性。如果当前函数是 <code class="language-plaintext highlighter-rouge">new</code> 命令调用，<code class="language-plaintext highlighter-rouge">new.target</code> 指向当前函数，否则为 <code class="language-plaintext highlighter-rouge">undefined</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">()</span> <span class="c1">// false</span>
<span class="k">new</span> <span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>
</code></pre></div></div> <p><strong>使用这个属性，可以判断函数调用的时候，是否使用 <code class="language-plaintext highlighter-rouge">new</code> 命令</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">请使用 new 命令调用！</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">()</span> <span class="c1">// Uncaught Error: 请使用 new 命令调用！</span>
</code></pre></div></div> <h3 id="4-objectcreate-创建实例对象">4. Object.create() 创建实例对象</h3> <p>如果希望以某个现有的对象作为模板，生成新的实例对象，可以使用 <code class="language-plaintext highlighter-rouge">Object.create()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">38</span><span class="p">,</span>
  <span class="na">greeting</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hi! I</span><span class="se">\'</span><span class="s1">m </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">person1</span><span class="p">);</span>

<span class="nx">person2</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// 张三</span>
<span class="nx">person2</span><span class="p">.</span><span class="nf">greeting</span><span class="p">()</span> <span class="c1">// Hi! I'm 张三.</span>
</code></pre></div></div> <h2 id="二this-关键字">二、this 关键字</h2> <h3 id="1-涵义">1. 涵义</h3> <p><code class="language-plaintext highlighter-rouge">this</code> 是属性或方法“当前”所在的对象。由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即 <code class="language-plaintext highlighter-rouge">this</code> 的指向是<strong>可变的</strong>。</p> <h3 id="2-实质">2. 实质</h3> <p>JavaScript 语言之所以有 <code class="language-plaintext highlighter-rouge">this</code> 的设计，跟内存里面的数据结构有关系。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span>  <span class="mi">5</span> <span class="p">};</span>
</code></pre></div></div> <p>上面的代码将一个对象赋值给变量 <code class="language-plaintext highlighter-rouge">obj</code>。JavaScript 引擎会先在内存里面，生成一个对象 <code class="language-plaintext highlighter-rouge">{ foo: 5 }</code>，然后把这个对象的内存地址赋值给变量 <code class="language-plaintext highlighter-rouge">obj</code>。也就是说，变量 <code class="language-plaintext highlighter-rouge">obj</code> 是一个地址（reference）。后面如果要读取 <code class="language-plaintext highlighter-rouge">obj.foo</code>，引擎先从 <code class="language-plaintext highlighter-rouge">obj</code> 拿到内存地址，然后再从该地址读出原始的对象，返回它的 <code class="language-plaintext highlighter-rouge">foo</code> 属性。</p> <p>原始的对象以字典结构保存，每个属性名都对应一个属性描述对象。举例来说，上面例子的 <code class="language-plaintext highlighter-rouge">foo</code> 属性，实际上是以下面的形式保存的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[[</span><span class="nx">value</span><span class="p">]]:</span> <span class="mi">5</span>
    <span class="p">[[</span><span class="nx">writable</span><span class="p">]]:</span> <span class="kc">true</span>
    <span class="p">[[</span><span class="nx">enumerable</span><span class="p">]]:</span> <span class="kc">true</span>
    <span class="p">[[</span><span class="nx">configurable</span><span class="p">]]:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 <code class="language-plaintext highlighter-rouge">foo</code> 属性的 <code class="language-plaintext highlighter-rouge">value</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[[</span><span class="nx">value</span><span class="p">]]:</span> <span class="nx">函数的地址</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">f</span><span class="p">:</span> <span class="nx">f</span> <span class="p">};</span>

<span class="c1">// 单独执行</span>
<span class="nf">f</span><span class="p">()</span>

<span class="c1">// obj 环境执行</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span>
</code></pre></div></div> <p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得<strong>当前的运行环境</strong>（context）。所以，<code class="language-plaintext highlighter-rouge">this</code> 就出现了，它的设计目的就是<strong>在函数体内部，指代函数当前的运行环境</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，函数体里面的 <code class="language-plaintext highlighter-rouge">this.x</code> 就是指当前运行环境的 <code class="language-plaintext highlighter-rouge">x</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 单独执行</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 1</span>

<span class="c1">// obj 环境执行</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span> <span class="c1">// 2</span>
</code></pre></div></div> <p>上面代码中，函数 <code class="language-plaintext highlighter-rouge">f</code> 在全局环境执行，<code class="language-plaintext highlighter-rouge">this.x</code> 指向全局环境的 <code class="language-plaintext highlighter-rouge">x</code>；在 <code class="language-plaintext highlighter-rouge">obj</code> 环境执行，<code class="language-plaintext highlighter-rouge">this.x</code> 指向 <code class="language-plaintext highlighter-rouge">obj.x</code>。</p> <h3 id="3-使用场合">3. 使用场合</h3> <ul> <li>全局环境：全局环境使用 <code class="language-plaintext highlighter-rouge">this</code>，指向顶层对象 <code class="language-plaintext highlighter-rouge">window</code>。</li> <li>构造函数：构造函数中使用 <code class="language-plaintext highlighter-rouge">this</code>，指向实例对象。</li> <li> <p>对象的方法：此时 <code class="language-plaintext highlighter-rouge">this</code> 指向方法运行时所在的对象。该方法赋值给另一个对象，就会改变 <code class="language-plaintext highlighter-rouge">this</code> 的指向。</p> <ul> <li> <p>如果 <code class="language-plaintext highlighter-rouge">this</code> 所在的方法不在对象的第一层，这时 <code class="language-plaintext highlighter-rouge">this</code> 只是指向当前层的对象，而不会继承更上面的层。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">m</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nf">m</span><span class="p">()</span> <span class="c1">// undefined</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">this</code> 指向 <code class="language-plaintext highlighter-rouge">a.b</code>。</p> </li> <li> <p>如果这时将嵌套对象内部的方法赋值给一个变量，<code class="language-plaintext highlighter-rouge">this</code> 依然会指向全局对象。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">b</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">m</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">hello</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span>
<span class="nf">hello</span><span class="p">()</span> <span class="c1">// undefined</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <h3 id="4-使用注意点">4. 使用注意点</h3> <h4 id="41-避免多层-this">4.1 避免多层 this</h4> <p>由于 <code class="language-plaintext highlighter-rouge">this</code> 的指向是不确定的，所以切勿在函数中包含多层的 <code class="language-plaintext highlighter-rouge">this</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f1</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f1</span><span class="p">()</span>
<span class="c1">// Object</span>
<span class="c1">// Window</span>
</code></pre></div></div> <p>上面代码包含两层 <code class="language-plaintext highlighter-rouge">this</code>，结果运行后，第一层指向对象 <code class="language-plaintext highlighter-rouge">o</code>，第二层指向全局对象。</p> <ul> <li> <p>一个解决方法是在第二层改用一个指向外层 <code class="language-plaintext highlighter-rouge">this</code> 的变量。使用一个变量固定 <code class="language-plaintext highlighter-rouge">this</code> 的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">f1</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">that</span><span class="p">);</span>
    <span class="p">}();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f1</span><span class="p">()</span>
<span class="c1">// Object</span>
<span class="c1">// Object</span>
</code></pre></div> </div> </li> <li> <p>JavaScript 提供了<strong>严格模式</strong>，也可以硬性避免这种问题。严格模式下，如果函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 指向顶层对象，就会报错。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">count</span><span class="p">:</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span><span class="p">;</span>
<span class="nf">f</span><span class="p">()</span>
<span class="c1">// TypeError: Cannot read property 'count' of undefined</span>
</code></pre></div> </div> </li> </ul> <h4 id="42-避免数组处理方法中的-this">4.2 避免数组处理方法中的 this</h4> <p>数组的 <code class="language-plaintext highlighter-rouge">map()</code> 和 <code class="language-plaintext highlighter-rouge">forEach()</code> 方法，允许提供一个函数作为参数。这个函数内部不应该使用 <code class="language-plaintext highlighter-rouge">this</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">v</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">p</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">a1</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a2</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">f</span><span class="p">:</span> <span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">v</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">item</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nf">f</span><span class="p">()</span>
<span class="c1">// undefined a1</span>
<span class="c1">// undefined a2</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">forEach()</code> 方法的回调函数中的 <code class="language-plaintext highlighter-rouge">this</code>，其实是指向 <code class="language-plaintext highlighter-rouge">window</code> 对象，因此取不到 <code class="language-plaintext highlighter-rouge">o.v</code> 的值。原因跟上一段的多层 <code class="language-plaintext highlighter-rouge">this</code> 是一样的，就是内层的 <code class="language-plaintext highlighter-rouge">this</code> 不指向外部，而指向顶层对象。</p> <h4 id="43-避免回调函数中的-this">4.3 避免回调函数中的 this</h4> <p>回调函数中的 <code class="language-plaintext highlighter-rouge">this</code> 往往会改变指向，最好避免使用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// jQuery 的写法</span>
<span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">#button</span><span class="dl">'</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，点击按钮以后，控制台会显示 <code class="language-plaintext highlighter-rouge">false</code>。原因是此时 <code class="language-plaintext highlighter-rouge">this</code> 不再指向 <code class="language-plaintext highlighter-rouge">o</code> 对象，而是指向按钮的 DOM 对象，因为 <code class="language-plaintext highlighter-rouge">f</code> 方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p> <h3 id="5-绑定-this-的方法">5. 绑定 this 的方法</h3> <h4 id="51-functionprototypecall">5.1 Function.prototype.call()</h4> <p>函数实例的 <code class="language-plaintext highlighter-rouge">call()</code> 方法可以指定函数内部 <code class="language-plaintext highlighter-rouge">this</code> 的指向。第一个参数是 <code class="language-plaintext highlighter-rouge">this</code> 所要指向的那个对象，后面的参数是函数调用时所需的参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">func</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">thisValue</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">call()</code> 方法的一个应用是<strong>调用对象的原生方法</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// 覆盖掉继承的 hasOwnProperty 方法</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">hasOwnProperty()</code> 是 <code class="language-plaintext highlighter-rouge">obj</code> 对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code class="language-plaintext highlighter-rouge">call()</code> 方法可以解决这个问题，它将 <code class="language-plaintext highlighter-rouge">hasOwnProperty()</code> 方法的原始定义放到 <code class="language-plaintext highlighter-rouge">obj</code> 对象上执行，这样无论 <code class="language-plaintext highlighter-rouge">obj</code> 上有没有同名方法，都不会影响结果。</p> <h4 id="52-functionprototypeapply">5.2 Function.prototype.apply()</h4> <p><code class="language-plaintext highlighter-rouge">apply()</code> 方法的作用与 <code class="language-plaintext highlighter-rouge">call()</code> 方法类似，也是改变 <code class="language-plaintext highlighter-rouge">this</code> 指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">func</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">thisValue</span><span class="p">,</span> <span class="p">[</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...])</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">apply()</code> 方法的一个常见的应用，就是利用数组对象的 <code class="language-plaintext highlighter-rouge">slice()</code> 方法，可以将一个类似数组的对象（比如 <code class="language-plaintext highlighter-rouge">arguments</code> 对象）转为真正的数组。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">length</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// [1]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// []</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">length</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">// [1, undefined]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">apply</span><span class="p">({</span><span class="na">length</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// [undefined]</span>
</code></pre></div></div> <h4 id="53-functionprototypebind">5.3 Function.prototype.bind()</h4> <p><code class="language-plaintext highlighter-rouge">bind()</code> 方法用于将函数体内的 <code class="language-plaintext highlighter-rouge">this</code> 绑定到某个对象，然后返回一个<strong>新函数</strong>。<code class="language-plaintext highlighter-rouge">bind()</code> 方法有一些使用注意点。</p> <ul> <li>每次返回一个新函数</li> <li>结合回调函数使用</li> <li>结合 <code class="language-plaintext highlighter-rouge">call()</code> 方法使用：利用 <code class="language-plaintext highlighter-rouge">bind()</code> 方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的 <code class="language-plaintext highlighter-rouge">slice()</code> 方法为例。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span>
<span class="c1">// 等同于</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span>
</code></pre></div></div> <h2 id="三对象的继承">三、对象的继承</h2> <h3 id="1-objectgetprototypeof">1. Object.getPrototypeOf()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法返回参数对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <p>下面是几种特殊对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 空对象的原型是 Object.prototype</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">({})</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>

<span class="c1">// Object.prototype 的原型是 null</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span> <span class="c1">// true</span>

<span class="c1">// 函数的原型是 Function.prototype</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="2-objectsetprototypeof">2. Object.setPrototypeOf()</h3> <p><code class="language-plaintext highlighter-rouge">Object.setPrototypeOf()</code> 方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">setPrototypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">===</span> <span class="nx">b</span> <span class="c1">// true</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// 1</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">new</code> 命令可以使用 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf()</code> 方法模拟。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">setPrototypeOf</span><span class="p">({},</span> <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nx">F</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">new</code> 命令新建实例对象，其实可以分成两步。</p> <ul> <li>第一步，将一个空对象的原型设为构造函数的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性（上例是 <code class="language-plaintext highlighter-rouge">F.prototype</code>）；</li> <li>第二步，将构造函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 绑定这个空对象，然后执行构造函数，使得定义在 <code class="language-plaintext highlighter-rouge">this</code> 上面的方法和属性（上例是 <code class="language-plaintext highlighter-rouge">this.foo</code>），都转移到这个空对象上。</li> </ul> <h3 id="3-objectcreate">3. Object.create()</h3> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 原型对象</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">print</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 实例对象</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span> <span class="o">===</span> <span class="nx">A</span> <span class="c1">// true</span>
<span class="nx">B</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// hello</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法可以用下面的代码代替。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">F</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码表明，<code class="language-plaintext highlighter-rouge">Object.create()</code> 方法的实质是新建一个空的构造函数 <code class="language-plaintext highlighter-rouge">F</code>，然后让 <code class="language-plaintext highlighter-rouge">F.prototype</code> 属性指向参数对象 <code class="language-plaintext highlighter-rouge">obj</code>，最后返回一个 <code class="language-plaintext highlighter-rouge">F</code> 的实例，从而实现让该实例继承 <code class="language-plaintext highlighter-rouge">obj</code> 的属性。</p> <p>下面三种方式生成的新对象是等价的。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({});</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">obj3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>
</code></pre></div></div> <p>如果想要生成一个不继承任何属性（比如没有 <code class="language-plaintext highlighter-rouge">toString()</code> 和 <code class="language-plaintext highlighter-rouge">valueOf()</code> 方法）的对象，可以将 <code class="language-plaintext highlighter-rouge">Object.create()</code> 的参数设为 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="nx">obj</span><span class="p">.</span><span class="nf">valueOf</span><span class="p">()</span> <span class="c1">// TypeError: Object [object Object] has no method 'valueOf'</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">obj1</span><span class="p">);</span>

<span class="nx">obj1</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// 2</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法可以接受第二个参数。该参数是一个<strong>属性描述对象</strong>，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({},</span> <span class="p">{</span>
  <span class="na">p1</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">p2</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">({});</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">p2</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Object.create()</code> 方法生成的对象，继承了它的原型对象的构造函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">A</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>

<span class="nx">b</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">A</span> <span class="c1">// true</span>
<span class="nx">b</span> <span class="k">instanceof</span> <span class="nx">A</span> <span class="c1">// true</span>
</code></pre></div></div> <h3 id="4-objectprototypeisprototypeof">4. Object.prototype.isPrototypeOf()</h3> <p>实例对象的 <code class="language-plaintext highlighter-rouge">isPrototypeOf()</code> 方法，用来判断该对象是否为参数对象的原型。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">o1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">o3</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">o2</span><span class="p">);</span>

<span class="nx">o2</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nx">o3</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">o1</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nx">o3</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">o1</code> 和 <code class="language-plaintext highlighter-rouge">o2</code> 都是 <code class="language-plaintext highlighter-rouge">o3</code> 的原型。这表明只要实例对象处在参数对象的<strong>原型链</strong>上，<code class="language-plaintext highlighter-rouge">isPrototypeOf()</code> 方法都返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">({})</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">([])</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="sr">/xyz/</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nf">isPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">))</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 处于原型链的最顶端，所以对各种实例都返回 <code class="language-plaintext highlighter-rouge">true</code>，只有直接继承自 <code class="language-plaintext highlighter-rouge">null</code> 的对象除外。</p> <h3 id="5-objectprototypeproto">5. Object.prototype.<strong>proto</strong> </h3> <p>实例对象的 <code class="language-plaintext highlighter-rouge">__proto__</code> 属性，返回该对象的<strong>原型</strong>。该属性<strong>可读写</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// true</span>
</code></pre></div></div> <p>根据语言标准，<code class="language-plaintext highlighter-rouge">__proto__</code> 属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 和 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p> <p>原型链可以用 <code class="language-plaintext highlighter-rouge">__proto__</code> 很直观地表示。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">李四</span><span class="dl">'</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">print</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>

<span class="nx">A</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// 张三</span>
<span class="nx">B</span><span class="p">.</span><span class="nf">print</span><span class="p">()</span> <span class="c1">// 李四</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">print</span> <span class="o">===</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">print</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">A</code> 对象和 <code class="language-plaintext highlighter-rouge">B</code> 对象的原型都是 <code class="language-plaintext highlighter-rouge">proto</code> 对象，它们都共享 <code class="language-plaintext highlighter-rouge">proto</code> 对象的 <code class="language-plaintext highlighter-rouge">print</code> 方法。也就是说，<code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 的 <code class="language-plaintext highlighter-rouge">print</code> 方法，都是在调用 <code class="language-plaintext highlighter-rouge">proto</code> 对象的 <code class="language-plaintext highlighter-rouge">print</code> 方法。</p> <h3 id="6-获取原型对象方法的比较">6. 获取原型对象方法的比较</h3> <p>获取实例对象 obj 的原型对象，有三种方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">obj.__proto__</code></li> <li><code class="language-plaintext highlighter-rouge">obj.constructor.prototype</code></li> <li><code class="language-plaintext highlighter-rouge">Object.getPrototypeOf(obj)</code></li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="p">();</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面三种方法之中，前两种都不是很可靠。<code class="language-plaintext highlighter-rouge">__proto__</code> 属性只有浏览器才需要部署，其他环境可以不部署。而 <code class="language-plaintext highlighter-rouge">obj.constructor.prototype</code> 在手动改变原型对象时，可能会失效。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">P</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">P</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{};</span>
<span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">C</span><span class="p">();</span>

<span class="nx">c</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// false</span>
</code></pre></div></div> <p>上面代码中，构造函数 <code class="language-plaintext highlighter-rouge">C</code> 的原型对象被改成了 <code class="language-plaintext highlighter-rouge">p</code>，但是实例对象的 <code class="language-plaintext highlighter-rouge">c.constructor.prototype</code> 却没有指向 <code class="language-plaintext highlighter-rouge">p</code>。所以，在改变原型对象时，一般要同时设置 <code class="language-plaintext highlighter-rouge">constructor</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">C</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">C</span><span class="p">();</span>
<span class="nx">c</span><span class="p">.</span><span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">p</span> <span class="c1">// true</span>
</code></pre></div></div> <p>因此，推荐使用第三种 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法，获取原型对象。</p> <h3 id="7-objectgetownpropertynames">7. Object.getOwnPropertyNames()</h3> <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyNames()</code> 方法返回一个数组，成员是参数对象<strong>自身的</strong>所有属性（包括<strong>可枚举的属性</strong>、<strong>不可枚举的</strong>属性）的键名，不包含继承的属性键名。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nb">Date</span><span class="p">)</span>
<span class="c1">// ["parse", "arguments", "UTC", "caller", "name", "prototype", "now", "length"]</span>
</code></pre></div></div> <h3 id="8-objectprototypehasownproperty">8. Object.prototype.hasOwnProperty()</h3> <p>对象实例的 <code class="language-plaintext highlighter-rouge">hasOwnProperty()</code> 方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Date</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">length</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Date</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div> <h3 id="9-in-运算符和-forin-循环">9. in 运算符和 for…in 循环</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">in</code> 运算符返回一个布尔值，表示一个对象是否具有某个属性。包括对象<strong>自身的</strong>和<strong>继承的</strong>属性。<code class="language-plaintext highlighter-rouge">in</code> 运算符常用于检查一个属性是否存在。</li> <li> <code class="language-plaintext highlighter-rouge">for...in</code> 循环用于获取对象<strong>自身的</strong>和<strong>继承的</strong>所有可遍历属性。</li> </ul> <p>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">inheritedPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">props</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">props</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="10-对象的拷贝">10. 对象的拷贝</h3> <p>如果要拷贝一个对象，需要做到下面两件事情。</p> <ul> <li>确保拷贝后的对象，与原对象具有同样的<strong>原型</strong>。</li> <li>确保拷贝后的对象，与原对象具有同样的<strong>实例属性</strong>。</li> </ul> <p>下面就是根据上面两点，实现的对象拷贝函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">copyObject</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">copy</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">orig</span><span class="p">));</span>
  <span class="nf">copyOwnPropertiesFrom</span><span class="p">(</span><span class="nx">copy</span><span class="p">,</span> <span class="nx">orig</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">copy</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">copyOwnPropertiesFrom</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span>
    <span class="p">.</span><span class="nf">getOwnPropertyNames</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">propKey</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">desc</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">);</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">desc</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="k">return</span> <span class="nx">target</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>另一种更简单的写法，是利用 ES2017 才引入标准的 <code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptors()</code> 方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">copyObject</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">orig</span><span class="p">),</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nf">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">orig</span><span class="p">)</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="四object-对象的相关方法">四、Object 对象的相关方法</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="五严格模式">五、严格模式</h2> <h3 id="1-设计目的">1. 设计目的</h3> <p>ES5 引入了严格模式，主要目的有以下几个。</p> <ul> <li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li> <li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li> <li>提高编译器效率，提升运行速度。</li> <li>为未来新版本的 JavaScript 语法做好铺垫。</li> </ul> <h3 id="2-启用方法">2. 启用方法</h3> <p>进入严格模式的标志，是一行字符串 <code class="language-plaintext highlighter-rouge">use strict</code>。老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p> <ul> <li>整个脚本文件：<code class="language-plaintext highlighter-rouge">use strict</code> 放在脚本文件的第一行，整个脚本都将以严格模式运行。</li> <li>单个函数：<code class="language-plaintext highlighter-rouge">use strict</code> 放在函数体的第一行，则整个函数以严格模式运行。</li> </ul> <h3 id="3-显式报错">3. 显式报错</h3> <h4 id="31-只读属性不可写">3.1 只读属性不可写</h4> <p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 对只读属性赋值会报错</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span>
  <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="c1">// TypeError: Cannot assign to read only property 'a' of object #&lt;Object&gt;</span>

<span class="c1">// 删除不可配置的属性会报错</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">defineProperty</span><span class="p">({},</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>
<span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">p</span>
<span class="c1">// TypeError: Cannot delete property 'p' of #&lt;Object&gt;</span>
</code></pre></div></div> <h4 id="32-只设置了取值器的属性不可写">3.2 只设置了取值器的属性不可写</h4> <p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nf">v</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">v</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span>
</code></pre></div></div> <h4 id="33-禁止扩展的对象不可扩展">3.3 禁止扩展的对象不可扩展</h4> <p>严格模式下，对禁止扩展的对象添加新属性会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// Uncaught TypeError: Cannot add property v, object is not extensible</span>
</code></pre></div></div> <h4 id="34-evalarguments-不可用作标识名">3.4 eval、arguments 不可用作标识名</h4> <p>严格模式下，使用 <code class="language-plaintext highlighter-rouge">eval</code> 或者 <code class="language-plaintext highlighter-rouge">arguments</code> 作为标识名会报错。下面的语句都会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nb">eval</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">arguments</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="kd">set</span> <span class="nf">p</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">};</span>
<span class="k">try</span> <span class="p">{</span> <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nf">x</span><span class="p">(</span><span class="nb">eval</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nf">arguments</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span> <span class="nf">eval</span><span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Function</span><span class="p">(</span><span class="dl">'</span><span class="s1">arguments</span><span class="dl">'</span><span class="p">,</span> <span class="dl">"</span><span class="s2">'use strict'; return 17;</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// SyntaxError: Unexpected eval or arguments in strict mode</span>
</code></pre></div></div> <h4 id="35-函数不能有重名的参数">3.5 函数不能有重名的参数</h4> <p>正常模式下，如果函数有多个重名的参数，可以用 <code class="language-plaintext highlighter-rouge">arguments[i]</code> 读取。严格模式下，这属于语法错误。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre></div></div> <h4 id="36-禁止八进制的前缀-0-表示法">3.6 禁止八进制的前缀 0 表示法</h4> <p>正常模式下，整数的第一位如果是 <code class="language-plaintext highlighter-rouge">0</code>，表示这是八进制数，比如 <code class="language-plaintext highlighter-rouge">0100</code> 等于十进制的 <code class="language-plaintext highlighter-rouge">64</code>。严格模式禁止这种表示法，整数第一位为 <code class="language-plaintext highlighter-rouge">0</code>，将报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0100</span><span class="p">;</span>
<span class="c1">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span>
</code></pre></div></div> <h3 id="4-增强的安全措施">4. 增强的安全措施</h3> <h4 id="41-全局变量显式声明">4.1 全局变量显式声明</h4> <p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 报错，v 未声明</span>

<span class="k">for </span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 报错，i 未声明</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 报错，未声明就创建一个全局变量</span>
</code></pre></div></div> <h4 id="42-禁止-this-关键字指向全局对象">4.2 禁止 this 关键字指向全局对象</h4> <p>正常模式下，函数内部的 <code class="language-plaintext highlighter-rouge">this</code> 可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正常模式</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>

<span class="c1">// 严格模式</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// true</span>
</code></pre></div></div> <p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 <code class="language-plaintext highlighter-rouge">new</code>，这时 <code class="language-plaintext highlighter-rouge">this</code> 不再指向全局对象，而是报错。</p> <h4 id="43-禁止使用-fncalleefncaller">4.3 禁止使用 fn.callee、fn.caller</h4> <p>函数内部不得使用 <code class="language-plaintext highlighter-rouge">fn.caller</code>、<code class="language-plaintext highlighter-rouge">fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">f1</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>    <span class="c1">// 报错</span>
  <span class="nx">f1</span><span class="p">.</span><span class="nx">arguments</span><span class="p">;</span> <span class="c1">// 报错</span>
<span class="p">}</span>

<span class="nf">f1</span><span class="p">();</span>
</code></pre></div></div> <h4 id="44-禁止使用-argumentscalleeargumentscaller">4.4 禁止使用 arguments.callee、arguments.caller</h4> <p><code class="language-plaintext highlighter-rouge">arguments.callee</code> 和 <code class="language-plaintext highlighter-rouge">arguments.caller</code> 是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用 <code class="language-plaintext highlighter-rouge">arguments.callee</code>、<code class="language-plaintext highlighter-rouge">arguments.caller</code> 将会报错。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">;</span>
<span class="p">};</span>

<span class="nf">f</span><span class="p">();</span> <span class="c1">// 报错</span>
</code></pre></div></div> <h4 id="45-禁止删除变量">4.5 禁止删除变量</h4> <p>严格模式下无法删除变量，如果使用 <code class="language-plaintext highlighter-rouge">delete</code> 命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的 <code class="language-plaintext highlighter-rouge">configurable: true</code>，才能被 <code class="language-plaintext highlighter-rouge">delete</code> 命令删除。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// 语法错误</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// 删除成功</span>
</code></pre></div></div> <h3 id="5-静态绑定">5. 静态绑定</h3> <h4 id="51-禁止使用-with-语句">5.1 禁止使用 with 语句</h4> <p>严格模式下，使用 <code class="language-plaintext highlighter-rouge">with</code> 语句将报错。因为 <code class="language-plaintext highlighter-rouge">with</code> 语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nf">with </span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Uncaught SyntaxError: Strict mode code may not include a with statement</span>
</code></pre></div></div> <h4 id="52-创设-eval-作用域">5.2 创设 eval 作用域</h4> <p>正常模式下，JavaScript 语言有两种变量作用域（scope）：<strong>全局作用域</strong>和<strong>函数作用域</strong>。严格模式创设了第三种作用域：<strong>eval 作用域</strong>。</p> <p>正常模式下，<code class="language-plaintext highlighter-rouge">eval</code> 语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code class="language-plaintext highlighter-rouge">eval</code> 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code class="language-plaintext highlighter-rouge">eval</code> 所生成的变量只能用于 <code class="language-plaintext highlighter-rouge">eval</code> 内部。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="dl">'</span><span class="s1">var x = 5; x</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// 5</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="p">})()</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">eval</code> 语句内部是一个独立作用域，所以内部的变量 <code class="language-plaintext highlighter-rouge">x</code> 不会泄露到外部。</p> <h4 id="53-arguments-不再追踪参数的变化">5.3 arguments 不再追踪参数的变化</h4> <p>变量 <code class="language-plaintext highlighter-rouge">arguments</code> 代表函数的参数。严格模式下，函数内部改变参数与 <code class="language-plaintext highlighter-rouge">arguments</code> 的联系被切断了，两者不再存在联动关系。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 正常模式为[2, 2]</span>

<span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 严格模式为[2, 1]</span>
</code></pre></div></div> <h3 id="6-保留字">6. 保留字</h3> <p>严格模式新增了一些保留字（<code class="language-plaintext highlighter-rouge">implements</code>、<code class="language-plaintext highlighter-rouge">interface</code>、<code class="language-plaintext highlighter-rouge">let</code>、<code class="language-plaintext highlighter-rouge">package</code>、<code class="language-plaintext highlighter-rouge">private</code>、<code class="language-plaintext highlighter-rouge">protected</code>、<code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">static</code>、<code class="language-plaintext highlighter-rouge">yield</code> 等）。使用这些词作为变量名将会报错。</p> <h2 id="六参考">六、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/oop/" rel="external nofollow noopener" target="_blank">JavaScript 教程 - 面向对象编程</a> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/bom/">《JavaScript 教程 - 浏览器模型》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/events/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/dom/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/async/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/stdlib/">《JavaScript 教程》摘录</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Zhang Feng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-repositories",title:"repositories",description:"Edit the `_data/repositories.yml` and change the `github_users` and `github_repos` lists to include your own GitHub profile and repositories.",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"This is a description of the page. You can modify it in &#39;_pages/cv.md&#39;. You can also change or remove the top pdf download button.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"nav-people",title:"people",description:"members of the lab or group",section:"Navigation",handler:()=>{window.location.href="/people/"}},{id:"dropdown-blog",title:"blog",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-javascript-\u6559\u7a0b-\u6d4f\u89c8\u5668\u6a21\u578b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b - \u6d4f\u89c8\u5668\u6a21\u578b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/bom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/dom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/oop/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stdlib/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/features/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/operators/"}},{id:"post-webpack-\u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",title:"webpack \u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/publish-subscribe-model/"}},{id:"post-webpack-\u9879\u76ee\u4f18\u5316",title:"webpack \u9879\u76ee\u4f18\u5316",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/optimization/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/configuration/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/concepts/"}},{id:"post-webpack-\u6784\u5efa\u6d41\u7a0b",title:"webpack \u6784\u5efa\u6d41\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/build-flow/"}},{id:"post-webpack-\u4e2d\u7684-plugin",title:"webpack \u4e2d\u7684 Plugin",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/plugin/"}},{id:"post-webpack-\u4e2d\u7684-loader",title:"webpack \u4e2d\u7684 Loader",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/loader/"}},{id:"post-http-\u7f13\u5b58",title:"HTTP \u7f13\u5b58",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/07-caching/"}},{id:"post-http-\u8fde\u63a5\u7ba1\u7406",title:"HTTP \u8fde\u63a5\u7ba1\u7406",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/04-connection-management/"}},{id:"post-es6-\u7f16\u7a0b\u98ce\u683c",title:"ES6 - \u7f16\u7a0b\u98ce\u683c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/style/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u5e94\u7528\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u5e94\u7528\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/application-layer/"}},{id:"post-\u54cd\u5e94\u5f0f-web-\u8bbe\u8ba1",title:"\u54cd\u5e94\u5f0f Web \u8bbe\u8ba1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/responsive-web-design/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u8fd0\u8f93\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u8fd0\u8f93\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/transport-layer/"}},{id:"post-react-\u4e2d\u7684\u4e8b\u4ef6",title:"React \u4e2d\u7684\u4e8b\u4ef6",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events-in-react/"}},{id:"post-css-\u9884\u5904\u7406\u5668",title:"CSS \u9884\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-preprocessor/"}},{id:"post-css-modules-\u7528\u6cd5\u6559\u7a0b",title:"CSS Modules \u7528\u6cd5\u6559\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-modules/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7f51\u7edc\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7f51\u7edc\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/network-layer/"}},{id:"post-\u8de8\u57df\u8d44\u6e90\u5171\u4eab-cors",title:"\u8de8\u57df\u8d44\u6e90\u5171\u4eab\uff08CORS\uff09",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cors/"}},{id:"post-\u9632\u6296\u548c\u8282\u6d41",title:"\u9632\u6296\u548c\u8282\u6d41",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/debounce-and-throttle/"}},{id:"post-es6-symbol",title:"ES6 - Symbol",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/symbol/"}},{id:"post-es6-\u5b57\u7b26\u4e32\u7684\u6269\u5c55",title:"ES6 - \u5b57\u7b26\u4e32\u7684\u6269\u5c55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/string/"}},{id:"post-es6-set",title:"ES6 - Set",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/set/"}},{id:"post-es6-reflect",title:"ES6 - Reflect",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/reflect/"}},{id:"post-es6-proxy",title:"ES6 - Proxy",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/proxy/"}},{id:"post-es6-promise-\u5bf9\u8c61",title:"ES6 - Promise \u5bf9\u8c61",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/promise/"}},{id:"post-es6-object",title:"ES6 - Object",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/object/"}},{id:"post-es6-\u6a21\u5757",title:"ES6 - \u6a21\u5757",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/module/"}},{id:"post-es6-map",title:"ES6 - Map",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/map/"}},{id:"post-es6-let-\u548c-const-\u547d\u4ee4",title:"ES6 - let \u548c const \u547d\u4ee4",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/let-const/"}},{id:"post-es6-iterator",title:"ES6 - Iterator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/iterator/"}},{id:"post-es6-generator-\u51fd\u6570",title:"ES6 - Generator \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/generator/"}},{id:"post-es6-function",title:"ES6 - Function",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/function/"}},{id:"post-es6-decorator",title:"ES6 - Decorator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/decorator/"}},{id:"post-es6-class",title:"ES6 - Class",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/class/"}},{id:"post-es6-async-\u51fd\u6570",title:"ES6 - async \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-es6-array",title:"ES6 - Array",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/array/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6570\u636e\u94fe\u8def\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6570\u636e\u94fe\u8def\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/data-link-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7269\u7406\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7269\u7406\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/physical-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6982\u8ff0",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6982\u8ff0",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/instruction/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%7A%66%65%6E%67%30%37%31%32@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=qc6CJjYAAAAJ","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>