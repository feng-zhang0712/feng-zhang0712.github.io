<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> ES6 - Generator 函数 | Zhang Feng </title> <meta name="author" content="Zhang Feng"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://feng-zhang0712.github.io//blog/2024/generator/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Zhang</span> Feng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">ES6 - Generator 函数</h1> <p class="post-meta"> Created in September 12, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/es6"> <i class="fa-solid fa-hashtag fa-sm"></i> ES6</a>   <a href="/blog/tag/generator"> <i class="fa-solid fa-hashtag fa-sm"></i> Generator</a>   ·   <a href="/blog/category/blog"> <i class="fa-solid fa-tag fa-sm"></i> blog</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>本文是对<a href="https://es6.ruanyifeng.com/#docs/generator" rel="external nofollow noopener" target="_blank">《ECMAScript 6 入门 - Generator 函数的语法》</a> 和<a href="https://es6.ruanyifeng.com/#docs/generator-async" rel="external nofollow noopener" target="_blank">《ECMAScript 6 入门 - Generator 函数的异步应用》</a> 两章中知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一简介">一、简介</h2> <h3 id="1-基本概念">1. 基本概念</h3> <p>Generator 函数是 ES6 提供的一种异步编程解决方案。</p> <ul> <li> <strong>状态机</strong>：语法上，可以认为 Generator 函数是一个状态机，封装了多个内部状态。</li> <li> <strong>遍历器对象生成函数</strong>：Generator 函数还是一个遍历器对象生成函数。它的返回值是一个遍历器对象，可以依次遍历 Generator 函数内部的每个状态。</li> </ul> <p>相比于普通函数，Generator 函数有两个特征。</p> <ul> <li>function 关键字后有个星号（<code class="language-plaintext highlighter-rouge">*</code>）。</li> <li>函数体内部使用 <code class="language-plaintext highlighter-rouge">yield</code> 表达式，产生不同的内部状态。</li> </ul> <p>Generator 函数的调用方法与普通函数一样，调用 Generator 函数后，该函数并不执行，而是返回一个指向内部状态的遍历器对象（Iterator Object）。调用遍历器对象的 <code class="language-plaintext highlighter-rouge">next</code> 方法，指针移向下一个状态，直到遇到下一个 <code class="language-plaintext highlighter-rouge">yield</code> 表达式（或 <code class="language-plaintext highlighter-rouge">return</code> 语句）为止。换言之，Generator 函数是分段执行的，<strong><code class="language-plaintext highlighter-rouge">yield</code> 表达式是暂停执行的标记，而 <code class="language-plaintext highlighter-rouge">next</code> 方法是恢复执行的标记</strong>。</p> <p>每次调用 <code class="language-plaintext highlighter-rouge">next</code> 方法都会返回一个对象，对象的 <code class="language-plaintext highlighter-rouge">value</code> 属性指向当前 <code class="language-plaintext highlighter-rouge">yield</code> 表达式后面的值，<code class="language-plaintext highlighter-rouge">done</code> 属性是一个布尔值，表示是否遍历完成。</p> <h3 id="2-yield-表达式">2. yield 表达式</h3> <p>遍历器对象的 <code class="language-plaintext highlighter-rouge">next</code> 方法的运行逻辑如下。</p> <ol> <li>遇到 <code class="language-plaintext highlighter-rouge">yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code class="language-plaintext highlighter-rouge">yield</code> 后面的那个表达式的值，作为返回的对象的 <code class="language-plaintext highlighter-rouge">value</code> 属性值。</li> <li>下一次调用 <code class="language-plaintext highlighter-rouge">next</code> 方法时，再继续往下执行，直到遇到下一个 <code class="language-plaintext highlighter-rouge">yield</code> 表达式。</li> <li>如果没有再遇到新的 <code class="language-plaintext highlighter-rouge">yield</code> 表达式，就一直运行到函数结束，直到 <code class="language-plaintext highlighter-rouge">return</code> 语句为止，并将 <code class="language-plaintext highlighter-rouge">return</code> 语句后面的表达式的值，作为返回的对象的 <code class="language-plaintext highlighter-rouge">value</code> 属性值。</li> <li>如果该函数没有 <code class="language-plaintext highlighter-rouge">return</code> 语句，则返回的对象的 <code class="language-plaintext highlighter-rouge">value</code> 属性值为 <code class="language-plaintext highlighter-rouge">undefined</code>。</li> </ol> <p>注意，<code class="language-plaintext highlighter-rouge">yield</code> 表达式只能用在 Generator 函数里面，用在其他地方会报错。</p> <h3 id="3-与-iterator-接口的关系">3. 与 Iterator 接口的关系</h3> <p>对象的 <code class="language-plaintext highlighter-rouge">Symbol.iterator</code> 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的 <code class="language-plaintext highlighter-rouge">Symbol.iterator</code> 属性，从而使得该对象具有 Iterator 接口。</p> <p>Generator 函数执行后返回的遍历器对象，也具有 <code class="language-plaintext highlighter-rouge">Symbol.iterator</code> 属性，执行后返回自身。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">gen</span><span class="p">(){</span>
  <span class="c1">// some code</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="o">===</span> <span class="nx">g</span> <span class="c1">// true</span>
</code></pre></div></div> <h2 id="二next-方法的参数">二、next 方法的参数</h2> <p><strong><code class="language-plaintext highlighter-rouge">next</code> 方法可以带一个参数，该参数会被当作上一个 <code class="language-plaintext highlighter-rouge">yield</code> 表达式的返回值</strong>。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 <code class="language-plaintext highlighter-rouge">next</code> 方法的参数，就可以在 Generator 函数开始运行之后，继续向函数体内部注入值，从而调整函数行为。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">yield </span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="k">yield </span><span class="p">(</span><span class="nx">y</span> <span class="o">/</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">return </span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// Object{value:6, done:false}</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// Object{value:NaN, done:false}</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// Object{value:NaN, done:true}</span>
</code></pre></div></div> <p>上面代码中，第二次运行 <code class="language-plaintext highlighter-rouge">next</code> 方法的时候不带参数，导致 <code class="language-plaintext highlighter-rouge">y</code> 的值等于 <code class="language-plaintext highlighter-rouge">2 * undefined</code>（即 <code class="language-plaintext highlighter-rouge">NaN</code>），除以 <code class="language-plaintext highlighter-rouge">3</code> 以后还是 <code class="language-plaintext highlighter-rouge">NaN</code>，因此返回对象的 <code class="language-plaintext highlighter-rouge">value</code> 属性也等于 <code class="language-plaintext highlighter-rouge">NaN</code>。第三次运行 <code class="language-plaintext highlighter-rouge">next</code> 方法的时候不带参数，所以 <code class="language-plaintext highlighter-rouge">z</code> 等于 <code class="language-plaintext highlighter-rouge">undefined</code>，返回对象的 <code class="language-plaintext highlighter-rouge">value</code> 属性等于 <code class="language-plaintext highlighter-rouge">5 + NaN + undefined</code>，即 <code class="language-plaintext highlighter-rouge">NaN</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value:6, done:false }</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="c1">// { value:8, done:false }</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span> <span class="c1">// { value:42, done:true }</span>
</code></pre></div></div> <ul> <li>第一次调用 <code class="language-plaintext highlighter-rouge">b</code> 的 <code class="language-plaintext highlighter-rouge">next</code> 方法时，返回 <code class="language-plaintext highlighter-rouge">x+1</code> 的值 <code class="language-plaintext highlighter-rouge">6</code>。</li> <li>第二次调用 <code class="language-plaintext highlighter-rouge">next</code> 方法，将上一次 <code class="language-plaintext highlighter-rouge">yield</code> 表达式的值设为 <code class="language-plaintext highlighter-rouge">12</code>，因此 <code class="language-plaintext highlighter-rouge">y</code> 等于 <code class="language-plaintext highlighter-rouge">24</code>，返回 <code class="language-plaintext highlighter-rouge">y / 3</code> 的值 <code class="language-plaintext highlighter-rouge">8</code>。</li> <li>第三次调用 <code class="language-plaintext highlighter-rouge">next</code> 方法，将上一次 <code class="language-plaintext highlighter-rouge">yield</code> 表达式的值设为 <code class="language-plaintext highlighter-rouge">13</code>，因此 <code class="language-plaintext highlighter-rouge">z</code> 等于 <code class="language-plaintext highlighter-rouge">13</code>，这时 <code class="language-plaintext highlighter-rouge">x</code> 等于 <code class="language-plaintext highlighter-rouge">5</code>，<code class="language-plaintext highlighter-rouge">y</code> 等于 <code class="language-plaintext highlighter-rouge">24</code>，所以 <code class="language-plaintext highlighter-rouge">return</code> 语句的值等于 <code class="language-plaintext highlighter-rouge">42</code>。</li> </ul> <p>注意，由于 <code class="language-plaintext highlighter-rouge">next</code> 方法的参数表示上一个 <code class="language-plaintext highlighter-rouge">yield</code> 表达式的返回值，所以在第一次使用 <code class="language-plaintext highlighter-rouge">next</code> 方法时，传递参数是无效的。</p> <h2 id="三forof-循环">三、for…of 循环</h2> <p><strong><code class="language-plaintext highlighter-rouge">for...of</code> 循环、扩展运算符（<code class="language-plaintext highlighter-rouge">...</code>）、解构赋值和 <code class="language-plaintext highlighter-rouge">Array.from</code> 方法内部调用的，都是遍历器接口</strong>。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">numbers </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span>
  <span class="k">yield</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="mi">3</span>
  <span class="k">yield</span> <span class="mi">4</span>
<span class="p">}</span>

<span class="c1">// 扩展运算符</span>
<span class="p">[...</span><span class="nf">numbers</span><span class="p">()]</span> <span class="c1">// [1, 2]</span>

<span class="c1">// 解构赋值</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nf">numbers</span><span class="p">();</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 2</span>

<span class="c1">// Array.from 方法</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nf">numbers</span><span class="p">())</span> <span class="c1">// [1, 2]</span>

<span class="c1">// for...of 循环</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nf">numbers</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
</code></pre></div></div> <p>一旦 <code class="language-plaintext highlighter-rouge">next</code> 方法的返回对象的 <code class="language-plaintext highlighter-rouge">done</code> 属性为 <code class="language-plaintext highlighter-rouge">true</code>，<code class="language-plaintext highlighter-rouge">for...of</code> 循环就会中止，<strong>且不包含该返回对象</strong>，所以上面代码的 <code class="language-plaintext highlighter-rouge">return</code> 语句返回的 <code class="language-plaintext highlighter-rouge">3</code>，不包括在 <code class="language-plaintext highlighter-rouge">for...of</code> 循环之中（也包括其他三种操作）。</p> <p>原生的 JavaScript 对象没有遍历接口，无法使用 <code class="language-plaintext highlighter-rouge">for...of</code> 循环，可以通过 Generator 函数为它加上这个接口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">objectEntries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Reflect</span><span class="p">.</span><span class="nf">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Jane</span><span class="dl">'</span> <span class="p">};</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nf">objectEntries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// name: Jane</span>
</code></pre></div></div> <p>加上遍历器接口的另一种写法是，将 Generator 函数加到对象的 <code class="language-plaintext highlighter-rouge">Symbol.iterator</code> 属性上面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">objectEntries</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">keys</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Jane</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="nx">objectEntries</span><span class="p">;</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// name: Jane</span>
</code></pre></div></div> <h2 id="四generatorprototypethrow">四、Generator.prototype.throw()</h2> <ul> <li> <p>Generator 函数返回的遍历器对象有个 <code class="language-plaintext highlighter-rouge">throw</code> 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。<code class="language-plaintext highlighter-rouge">throw</code> 方法可以接受一个参数，该参数会被 <code class="language-plaintext highlighter-rouge">catch</code> 语句接收。（注意，遍历器对象的 <code class="language-plaintext highlighter-rouge">throw</code> 方法和全局的 <code class="language-plaintext highlighter-rouge">throw</code> 命令是两个不同的操作，两者并无关系。）</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nf">g</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">出错了！</span><span class="dl">'</span><span class="p">));</span>
<span class="c1">// Error: 出错了！(…)</span>
</code></pre></div> </div> </li> <li> <p>如果 Generator 函数内部没有部署 <code class="language-plaintext highlighter-rouge">try...catch</code> 代码块，那么 <code class="language-plaintext highlighter-rouge">throw</code> 方法抛出的错误，将被外部 <code class="language-plaintext highlighter-rouge">try...catch</code> 代码块捕获。如果 Generator 函数内部和外部，都没有部署 <code class="language-plaintext highlighter-rouge">try...catch</code> 代码块，那么程序将报错并中断执行。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">while </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">内部捕获</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nf">g</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">外部捕获</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 外部捕获 a</span>
</code></pre></div> </div> </li> <li> <code class="language-plaintext highlighter-rouge">throw</code> 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 <code class="language-plaintext highlighter-rouge">next</code> 方法。这种行为其实很好理解，因为第一次执行 <code class="language-plaintext highlighter-rouge">next</code> 方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时 <code class="language-plaintext highlighter-rouge">throw</code> 方法抛错只可能抛出在函数外部。</li> <li> <p><code class="language-plaintext highlighter-rouge">throw</code> 方法被内部捕获以后，会附带执行到下一条 <code class="language-plaintext highlighter-rouge">yield</code> 表达式，这种情况下等同于执行一次 <code class="language-plaintext highlighter-rouge">next</code> 方法。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="nf">gen</span><span class="p">(){</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value:1, done:false }</span>
<span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">()</span> <span class="c1">// { value:2, done:false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value:3, done:false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value:undefined, done:true }</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">g.throw</code> 方法被内部捕获以后，等同于执行了一次 <code class="language-plaintext highlighter-rouge">next</code> 方法，所以返回 <code class="language-plaintext highlighter-rouge">{ value:2, done:false }</code>。另外，也可以看到，只要 Generator 函数内部部署了 <code class="language-plaintext highlighter-rouge">try...catch</code> 代码块，那么遍历器的 <code class="language-plaintext highlighter-rouge">throw</code> 方法抛出的错误，不影响下一次遍历。</p> </li> <li> <strong>Generator 函数体外抛出的错误，可以在函数体内捕获；Generator 函数体内抛出的错误，也可以被函数体外的 <code class="language-plaintext highlighter-rouge">catch</code> 捕获</strong>。一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 <code class="language-plaintext highlighter-rouge">next</code> 方法，将返回 <code class="language-plaintext highlighter-rouge">{ value: undefined, done: true }</code> 对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</li> </ul> <h2 id="五generatorprototypereturn">五、Generator.prototype.return()</h2> <ul> <li> <p>Generator 函数返回的遍历器对象有个 <code class="language-plaintext highlighter-rouge">return()</code> 方法，可以返回给定的值，并且终结遍历 Generator 函数。如果 <code class="language-plaintext highlighter-rouge">return()</code> 方法调用时，不提供参数，则返回值的 <code class="language-plaintext highlighter-rouge">value</code> 属性为 <code class="language-plaintext highlighter-rouge">undefined</code>。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>        <span class="c1">// { value: 1, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// { value: "foo", done: true }</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>        <span class="c1">// { value: undefined, done: true }</span>
</code></pre></div> </div> </li> <li> <p>如果 Generator 函数内部有 <code class="language-plaintext highlighter-rouge">try...finally</code> 代码块，且正在执行 <code class="language-plaintext highlighter-rouge">try</code> 代码块，那么 <code class="language-plaintext highlighter-rouge">return()</code> 方法会导致立刻进入 <code class="language-plaintext highlighter-rouge">finally</code> 代码块，执行完以后，整个函数才会结束。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">numbers </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">numbers</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value: 1, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value: 2, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="c1">// { value: 4, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value: 5, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value: 7, done: true }</span>
</code></pre></div> </div> <p>上面代码中，调用 <code class="language-plaintext highlighter-rouge">return()</code> 方法后，就开始执行 <code class="language-plaintext highlighter-rouge">finally</code> 代码块，不执行 <code class="language-plaintext highlighter-rouge">try</code> 里面剩下的代码了，然后等到 <code class="language-plaintext highlighter-rouge">finally</code> 代码块执行完，再返回 <code class="language-plaintext highlighter-rouge">return()</code> 方法指定的返回值。</p> </li> </ul> <h2 id="六nextthrowreturn-的共同点">六、next()、throw()、return() 的共同点</h2> <p><code class="language-plaintext highlighter-rouge">next()</code>、<code class="language-plaintext highlighter-rouge">throw()</code>、<code class="language-plaintext highlighter-rouge">return()</code> 这三个方法本质上是同一件事，它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换 <code class="language-plaintext highlighter-rouge">yield</code> 表达式。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">next()</code> 是将 <code class="language-plaintext highlighter-rouge">yield</code> 表达式替换成一个值。</li> <li> <code class="language-plaintext highlighter-rouge">throw()</code> 是将 <code class="language-plaintext highlighter-rouge">yield</code> 表达式替换成一个 <code class="language-plaintext highlighter-rouge">throw</code> 语句。</li> <li> <code class="language-plaintext highlighter-rouge">return()</code> 是将 <code class="language-plaintext highlighter-rouge">yield</code> 表达式替换成一个 <code class="language-plaintext highlighter-rouge">return</code> 语句。</li> </ul> <h2 id="七yield-表达式">七、yield* 表达式</h2> <p>ES6 提供了 <code class="language-plaintext highlighter-rouge">yield*</code> 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nf">foo</span><span class="p">();</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span><span class="o">*</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span><span class="o">*</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nf">foo</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">v</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nf">bar</span><span class="p">()){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// "x"</span>
<span class="c1">// "a"</span>
<span class="c1">// "b"</span>
<span class="c1">// "y"</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">yield*</code> 后面的 Generator 函数，如果没有 <code class="language-plaintext highlighter-rouge">return</code> 语句，等同于在 Generator 函数内部部署一个 <code class="language-plaintext highlighter-rouge">for...of</code> 循环。反之，如果被代理的 Generator 函数有 <code class="language-plaintext highlighter-rouge">return</code> 语句，那么就可以向代理它的 Generator 函数返回数据。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">return</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">yield</span><span class="o">*</span> <span class="nf">foo</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">v: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
  <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">it</span> <span class="o">=</span> <span class="nf">bar</span><span class="p">();</span>
<span class="nx">it</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
<span class="c1">// {value: 1, done: false}</span>
<span class="nx">it</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
<span class="c1">// {value: 2, done: false}</span>
<span class="nx">it</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
<span class="c1">// {value: 3, done: false}</span>
<span class="nx">it</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span>
<span class="c1">// "v: foo"</span>
<span class="c1">// {value: 4, done: false}</span>
<span class="nx">it</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
<span class="c1">// {value: undefined, done: true}</span>
</code></pre></div> </div> </li> <li> <p>如果 <code class="language-plaintext highlighter-rouge">yield*</code> 后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。实际上，任何数据结构只要有 Iterator 接口，就可以被 <code class="language-plaintext highlighter-rouge">yield*</code> 遍历。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span><span class="o">*</span> <span class="p">[</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">c</span><span class="dl">"</span><span class="p">];</span>
<span class="p">}</span>
<span class="nf">gen</span><span class="p">().</span><span class="nf">next</span><span class="p">()</span> <span class="c1">// { value:"a", done:false }</span>

<span class="kd">let</span> <span class="nx">read</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="p">})();</span>

<span class="nx">read</span><span class="p">.</span><span class="nf">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// "hello"</span>
<span class="nx">read</span><span class="p">.</span><span class="nf">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// "h"</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">yield</code> 表达式返回整个字符串，<code class="language-plaintext highlighter-rouge">yield*</code> 语句返回单个字符。因为字符串具有 Iterator 接口，所以被 <code class="language-plaintext highlighter-rouge">yield*</code> 遍历。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">yield*</code> 命令可以很方便地取出嵌套数组的所有成员。由于扩展运算符 <code class="language-plaintext highlighter-rouge">...</code> 默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nf">isArray</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span><span class="o">*</span> <span class="nf">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">tree</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">tree</span> <span class="o">=</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="p">[</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">],</span> <span class="p">[</span><span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">e</span><span class="dl">'</span><span class="p">]</span> <span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nf">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// a</span>
<span class="c1">// b</span>
<span class="c1">// c</span>
<span class="c1">// d</span>
<span class="c1">// e</span>

<span class="p">[...</span><span class="nf">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">)]</span> <span class="c1">// ["a", "b", "c", "d", "e"]</span>
</code></pre></div> </div> </li> </ul> <h2 id="八作为对象属性的-generator-函数">八、作为对象属性的 Generator 函数</h2> <p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="o">*</span> <span class="nf">generator</span><span class="p">()</span> <span class="p">{</span>
    <span class="err">···</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">generator</span><span class="p">:</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ···</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="九generator-函数的-this">九、Generator 函数的 this</h2> <p>Generator 函数不能用作构造函数，也不能跟 new 命令一起用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nf">g</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// undefined</span>
</code></pre></div></div> <h2 id="十含义">十、含义</h2> <h3 id="101-generator-与状态机">10.1 Generator 与状态机</h3> <p>Generator 是实现状态机的最佳结构。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES5 实现</span>
<span class="kd">var</span> <span class="nx">ticking</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">clock</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">ticking</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Tick!</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Tock!</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">ticking</span> <span class="o">=</span> <span class="o">!</span><span class="nx">ticking</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Generator 实现</span>
<span class="kd">var</span> <span class="nx">clock</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">while </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Tick!</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">yield</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Tock!</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">yield</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量 ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p> <h3 id="102-generator-与协程">10.2 Generator 与协程</h3> <h4 id="1协程与子例程的差异">（1）协程与子例程的差异</h4> <p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p> <p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p> <h4 id="2协程与普通线程的差异">（2）协程与普通线程的差异</h4> <p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p> <p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p> <p>Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p> <p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表达式交换控制权。</p> <h3 id="103-generator-与上下文">10.3 Generator 与上下文</h3> <p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p> <p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p> <p>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">gen</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
  <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span>
  <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span>
<span class="p">);</span>
</code></pre></div></div> <p>上面代码中，第一次执行 <code class="language-plaintext highlighter-rouge">g.next()</code> 时，Generator 函数 <code class="language-plaintext highlighter-rouge">gen</code> 的上下文会加入堆栈，即开始运行 <code class="language-plaintext highlighter-rouge">gen</code> 内部的代码。等遇到 <code class="language-plaintext highlighter-rouge">yield 1</code> 时，<code class="language-plaintext highlighter-rouge">gen</code> 上下文退出堆栈，内部状态冻结。第二次执行 <code class="language-plaintext highlighter-rouge">g.next()</code> 时，<code class="language-plaintext highlighter-rouge">gen</code> 上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p> <h2 id="十一应用">十一、应用</h2> <p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。</p> <h3 id="1-异步操作的同步化表达">1. 异步操作的同步化表达</h3> <h3 id="2-控制流管理">2. 控制流管理</h3> <h3 id="3-部署-iterator-接口">3. 部署 Iterator 接口</h3> <p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">iterEntries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="mi">7</span> <span class="p">};</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nf">iterEntries</span><span class="p">(</span><span class="nx">myObj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// foo 3</span>
<span class="c1">// bar 7</span>
</code></pre></div></div> <h3 id="4-作为数据结构">4. 作为数据结构</h3> <p><strong>Generator 使得数据或者操作，具备了类似数组的接口</strong>。Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">doStuff</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">hello.txt</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">world.txt</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">and-such.txt</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for </span><span class="p">(</span><span class="nx">task</span> <span class="k">of</span> <span class="nf">doStuff</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// task 是一个函数，可以像回调函数那样使用它</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。然后，就可以使用 <code class="language-plaintext highlighter-rouge">for...of</code> 循环进行处理。</p> <h2 id="十二generator-函数的异步应用">十二、Generator 函数的异步应用</h2> <h3 id="1-传统方法">1. 传统方法</h3> <p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p> <ul> <li>回调函数</li> <li>事件监听</li> <li>发布/订阅</li> <li>Promise 对象</li> </ul> <p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p> <h3 id="2-基本概念">2. 基本概念</h3> <p>JavaScript 语言对异步编程的实现，是使用回调函数。回调函数的英语名字 <code class="language-plaintext highlighter-rouge">callback</code>，直译过来就是”重新调用”。回调函数的问题是，容易出现多个回调函数嵌套。即所谓的”回调函数地狱”（callback hell）。</p> <p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆 <code class="language-plaintext highlighter-rouge">then</code>，原来的语义变得很不清楚。</p> <h3 id="3-generator-函数">3. Generator 函数</h3> <h4 id="31-协程">3.1 协程</h4> <p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做<strong>协程</strong>（coroutine），意思是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下。</p> <ol> <li>第一步，协程 <code class="language-plaintext highlighter-rouge">A</code> 开始执行。</li> <li>第二步，协程 <code class="language-plaintext highlighter-rouge">A</code> 执行到一半，进入暂停，执行权转移到协程 <code class="language-plaintext highlighter-rouge">B</code>。</li> <li>第三步，（一段时间后）协程 <code class="language-plaintext highlighter-rouge">B</code> 交还执行权。</li> <li>第四步，协程 <code class="language-plaintext highlighter-rouge">A</code> 恢复执行。</li> </ol> <p>上面流程的协程 <code class="language-plaintext highlighter-rouge">A</code>，就是异步任务，因为它分成两段（或多段）执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nf">asyncJob</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...其他代码</span>
  <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">fileA</span><span class="p">);</span>
  <span class="c1">// ...其他代码</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码的函数 <code class="language-plaintext highlighter-rouge">asyncJob</code> 是一个协程，它的奥妙就在其中的 <code class="language-plaintext highlighter-rouge">yield</code> 命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code class="language-plaintext highlighter-rouge">yield</code> 命令是异步两个阶段的分界线。</p> <p>协程遇到 <code class="language-plaintext highlighter-rouge">yield</code> 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作。</p> <h4 id="32-协程的-generator-函数实现">3.2 协程的 Generator 函数实现</h4> <p><strong>Generator 函数是协程在 ES6 的实现，最大特点是可以交出函数的执行权（即暂停执行）</strong>。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 <code class="language-plaintext highlighter-rouge">yield</code> 语句注明。</p> <p>Generator 函数的 <code class="language-plaintext highlighter-rouge">next</code> 方法的作用是分阶段执行 Generator 函数。每次调用 <code class="language-plaintext highlighter-rouge">next</code> 方法，会返回一个对象，表示当前阶段的信息（<code class="language-plaintext highlighter-rouge">value</code> 属性和 <code class="language-plaintext highlighter-rouge">done</code> 属性）。<code class="language-plaintext highlighter-rouge">value</code> 属性是 <code class="language-plaintext highlighter-rouge">yield</code> 语句后面表达式的值，表示当前阶段的值；<code class="language-plaintext highlighter-rouge">done</code> 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p> <h4 id="33-generator-函数的数据交换和错误处理">3.3 Generator 函数的数据交换和错误处理</h4> <p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p> <ul> <li>对于函数体内外的数据交换，<code class="language-plaintext highlighter-rouge">next</code> 返回值的 <code class="language-plaintext highlighter-rouge">value</code> 属性，是 Generator 函数向外输出数据；<code class="language-plaintext highlighter-rouge">next</code> 方法还可以接受参数，向 Generator 函数体内输入数据。</li> <li>对于错误处理机制，可以通过 Generator 函数返回的遍历器对象的 <a href="#%E5%9B%9Bgeneratorprototypethrow">throw</a> 方法。</li> </ul> <h4 id="34-异步任务的封装">3.4 异步任务的封装</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fetch</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">node-fetch</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">function</span><span class="o">*</span> <span class="nf">gen</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">https://api.github.com/users/github</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">bio</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，Generator 函数封装了一个异步操作。就像前面说过的，这段代码非常像同步操作，除了加上了 <code class="language-plaintext highlighter-rouge">yield</code> 命令。执行这段代码的方法如下。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">gen</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span>

<span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nf">json</span><span class="p">();</span>
<span class="p">}).</span><span class="nf">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p> <h3 id="4-thunk-函数">4. Thunk 函数</h3> <p>Thunk 函数是<strong>自动执行 Generator 函数</strong>的一种方法。</p> <h4 id="41-参数的求值策略">4.1 参数的求值策略</h4> <p>在编程语言的早期，一个争论的焦点是<strong>求值策略</strong>，即函数的参数到底应该何时求值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div> <ul> <li> <p>一种意见是<strong>传值调用</strong>（call by value），即在进入函数体之前，就计算 <code class="language-plaintext highlighter-rouge">x + 5</code> 的值（等于 <code class="language-plaintext highlighter-rouge">6</code>），再将这个值传入函数 <code class="language-plaintext highlighter-rouge">f</code>。C 语言就采用这种策略。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// 传值调用时，等同于</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</code></pre></div> </div> </li> <li> <p>另一种意见是<strong>传名调用</strong>（call by name），即直接将表达式 <code class="language-plaintext highlighter-rouge">x + 5</code> 传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// 传名调用时，等同于</span>
<span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
</code></pre></div> </div> </li> </ul> <p>两种方式各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p> <h4 id="42-thunk-函数的含义">4.2 Thunk 函数的含义</h4> <p>编译器的<strong>传名调用</strong>实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 <strong>Thunk 函数</strong>。Thunk 函数是<strong>传名调用</strong>的一种实现策略，用来替换某个表达式。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>

<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">thunk</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">thunk</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">thunk</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="43-javascript-语言的-thunk-函数">4.3 JavaScript 语言的 Thunk 函数</h4> <p>JavaScript 语言是<strong>传值调用</strong>，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是<strong>多参数函数</strong>，将其替换成一个<strong>只接受回调函数作为参数的单参数函数</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正常版本的 readFile（多参数版本）</span>
<span class="nx">fs</span><span class="p">.</span><span class="nf">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>

<span class="c1">// Thunk 版本的 readFile（单参数版本）</span>
<span class="kd">var</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">function </span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fs</span><span class="p">.</span><span class="nf">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nc">Thunk</span><span class="p">(</span><span class="nx">fileName</span><span class="p">);</span>
<span class="nf">readFileThunk</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">fs</code> 模块的 <code class="language-plaintext highlighter-rouge">readFile</code> 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p> <p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES5 版本</span>
<span class="kd">var</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">function </span><span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
      <span class="nx">args</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="c1">// ES6 版本</span>
<span class="kd">const</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">function </span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">function </span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="c1">// 使用上面的转换器，生成 fs.readFile 的 Thunk 函数。</span>
<span class="kd">var</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nc">Thunk</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
<span class="nf">readFileThunk</span><span class="p">(</span><span class="nx">fileA</span><span class="p">)(</span><span class="nx">callback</span><span class="p">);</span>
</code></pre></div></div> <h4 id="44-thunkify-模块">4.4 Thunkify 模块</h4> <p>生产环境的转换器，建议使用 <a href="https://github.com/tj/node-thunkify" rel="external nofollow noopener" target="_blank">Thunkify</a> 模块。下面是 Thunkify 的源码。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">thunkify</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="nf">assert</span><span class="p">(</span><span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">fn</span><span class="p">,</span> <span class="dl">'</span><span class="s1">function required</span><span class="dl">'</span><span class="p">);</span>

  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">called</span><span class="p">;</span>

      <span class="nx">args</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">done</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
      <span class="p">});</span>

      <span class="k">try</span> <span class="p">{</span>
        <span class="nx">fn</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">done</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>Thunkify 的源码与上一节那个简单的转换器非常像。它的源码主要多了一个检查机制，变量 <code class="language-plaintext highlighter-rouge">called</code> 确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">callback</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="nf">callback</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
  <span class="nf">callback</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">ft</span> <span class="o">=</span> <span class="nf">thunkify</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">print</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">);</span>
<span class="nf">ft</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="nx">print</span><span class="p">);</span>
<span class="c1">// 3</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">thunkify</code> 只允许回调函数执行一次，所以只输出一行结果。</p> <h4 id="45-generator-函数的流程管理">4.5 Generator 函数的流程管理</h4> <p>Thunk 函数可以用于 Generator 函数的自动流程管理（也就是说，Generator 函数现在可以自动执行了）。以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">thunkify</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">thunkify</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nf">thunkify</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFileThunk</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">r1</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
  <span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFileThunk</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">r2</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">yield</code> 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">gen</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span>
<span class="nx">r1</span><span class="p">.</span><span class="nf">value</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="nx">r2</span><span class="p">.</span><span class="nf">value</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
    <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入 <code class="language-plaintext highlighter-rouge">next</code> 方法的 <code class="language-plaintext highlighter-rouge">value</code> 属性。这使得我们可以用递归来自动完成这个过程。</p> <h4 id="46-thunk-函数的自动流程管理">4.6 Thunk 函数的自动流程管理</h4> <p><strong>Thunk 函数可以自动执行 Generator 函数</strong>。下面就是一个基于 Thunk 函数的 Generator 执行器。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">run</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nf">fn</span><span class="p">();</span>
  <span class="kd">function</span> <span class="nf">next</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">.</span><span class="nf">value</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nf">next</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="nf">run</span><span class="p">(</span><span class="nx">g</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码的 <code class="language-plaintext highlighter-rouge">run</code> 函数，就是一个 Generator 函数的自动执行器。内部的 <code class="language-plaintext highlighter-rouge">next</code> 函数就是 Thunk 的回调函数。<code class="language-plaintext highlighter-rouge">next</code> 函数先将指针移到 Generator 函数的下一步（<code class="language-plaintext highlighter-rouge">gen.next</code> 方法），然后判断 Generator 函数是否结束（<code class="language-plaintext highlighter-rouge">result.done</code> 属性），如果没结束，就将 <code class="language-plaintext highlighter-rouge">next</code> 函数再传入 Thunk 函数（<code class="language-plaintext highlighter-rouge">result.value</code> 属性），否则就直接退出。</p> <p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入 <code class="language-plaintext highlighter-rouge">run</code> 函数即可。当然，前提是每个异步操作，都要是 Thunk 函数，也就是说，跟在 <code class="language-plaintext highlighter-rouge">yield</code> 命令后面的必须是 Thunk 函数。</p> <p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为<strong>自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权</strong>。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p> <h3 id="5-co-模块">5. co 模块</h3> <h4 id="51-基本用法">5.1 基本用法</h4> <p><a href="https://github.com/tj/co" rel="external nofollow noopener" target="_blank">co 模块</a>用于 Generator 函数的自动执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div> <p>co 模块可以让你不用编写 Generator 函数的执行器。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">co</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">co</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">).</span><span class="nf">then</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Generator 函数执行完成</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <p>上面代码中，Generator 函数只要传入 <code class="language-plaintext highlighter-rouge">co</code> 函数，就会自动执行。<code class="language-plaintext highlighter-rouge">co</code> 函数返回一个 Promise 对象，因此可以用 <code class="language-plaintext highlighter-rouge">then</code> 方法添加回调函数。</p> <h4 id="52-co-模块的原理">5.2 co 模块的原理</h4> <p>Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。两种方法可以做到这一点。</p> <ol> <li> <strong>回调函数</strong>：将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</li> <li> <strong>Promise 对象</strong>：将异步操作包装成 Promise 对象，用 <code class="language-plaintext highlighter-rouge">then</code> 方法交回执行权。</li> </ol> <p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的 <code class="language-plaintext highlighter-rouge">yield</code> 命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。</p> <h4 id="53-基于-promise-对象的自动执行">5.3 基于 Promise 对象的自动执行</h4> <p>首先，把 <code class="language-plaintext highlighter-rouge">fs</code> 模块的 <code class="language-plaintext highlighter-rouge">readFile</code> 方法包装成一个 Promise 对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">fileName</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nf">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="nf">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
      <span class="nf">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nf">toString</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div> <p>然后，手动执行上面的 Generator 函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">().</span><span class="nx">value</span><span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">).</span><span class="nx">value</span><span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <p>手动执行其实就是用 <code class="language-plaintext highlighter-rouge">then</code> 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nf">gen</span><span class="p">();</span>
  <span class="kd">function</span> <span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
      <span class="nf">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="nf">next</span><span class="p">();</span>
<span class="p">}</span>
<span class="nf">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，只要 Generator 函数还没执行到最后一步，<code class="language-plaintext highlighter-rouge">next</code> 函数就调用自身，以此实现自动执行。</p> <h4 id="54-co-模块的源码">5.4 co 模块的源码</h4> <p>co 就是上面那个自动执行器的扩展。</p> <ol> <li> <p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nf">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
   <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{});</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>在返回的 Promise 对象里面，co 先检查参数 <code class="language-plaintext highlighter-rouge">gen</code> 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 <code class="language-plaintext highlighter-rouge">resolved</code>。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nf">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
   <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">gen</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span>
     <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">gen</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span> <span class="nf">resolve</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span>
   <span class="p">});</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>接着，co 将 Generator 函数的内部指针对象的 <code class="language-plaintext highlighter-rouge">next</code> 方法，包装成 <code class="language-plaintext highlighter-rouge">onFulfilled</code> 函数。这主要是为了能够捕捉抛出的错误。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nf">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

   <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">gen</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span>
     <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">gen</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span> <span class="nf">resolve</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span>

     <span class="nf">onFulfilled</span><span class="p">();</span>
     <span class="kd">function</span> <span class="nf">onFulfilled</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
       <span class="kd">var</span> <span class="nx">ret</span><span class="p">;</span>
       <span class="k">try</span> <span class="p">{</span>
         <span class="nx">ret</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
       <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">return</span> <span class="nf">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
       <span class="p">}</span>
       <span class="nf">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
     <span class="p">}</span>
   <span class="p">});</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>最后，就是关键的 <code class="language-plaintext highlighter-rouge">next</code> 函数，它会反复调用自身。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nf">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if </span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nf">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
   <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">toPromise</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
   <span class="k">if </span><span class="p">(</span><span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="nf">isPromise</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
   <span class="k">return</span> <span class="nf">onRejected</span><span class="p">(</span>
     <span class="k">new</span> <span class="nc">TypeError</span><span class="p">(</span>
       <span class="dl">'</span><span class="s1">You may only yield a function, promise, generator, array, or object, </span><span class="dl">'</span>
       <span class="o">+</span> <span class="dl">'</span><span class="s1">but the following object was passed: "</span><span class="dl">'</span>
       <span class="o">+</span> <span class="nc">String</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
       <span class="o">+</span> <span class="dl">'</span><span class="s1">"</span><span class="dl">'</span>
     <span class="p">)</span>
   <span class="p">);</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">next</code> 函数的内部代码，一共只有四行命令。</p> <ul> <li>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</li> <li>第二行，确保每一步的返回值，是 Promise 对象。</li> <li>第三行，使用 <code class="language-plaintext highlighter-rouge">then</code> 方法，为返回值加上回调函数，然后通过 <code class="language-plaintext highlighter-rouge">onFulfilled</code> 函数再次调用 <code class="language-plaintext highlighter-rouge">next</code> 函数。</li> <li>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 <code class="language-plaintext highlighter-rouge">rejected</code>，从而终止执行。</li> </ul> </li> </ol> <h4 id="55-处理并发的异步操作">5.5 处理并发的异步操作</h4> <p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。这时，要把并发的操作都放在数组或对象里面，跟在 <code class="language-plaintext highlighter-rouge">yield</code> 语句后面。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组的写法</span>
<span class="nf">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">[</span>
    <span class="nb">Promise</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="nb">Promise</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">];</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">onerror</span><span class="p">);</span>

<span class="c1">// 对象的写法</span>
<span class="nf">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="mi">2</span><span class="p">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
  <span class="p">};</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">onerror</span><span class="p">);</span>
</code></pre></div></div> <p>下面是另一个例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">values</span> <span class="o">=</span> <span class="p">[</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">,</span> <span class="nx">n3</span><span class="p">];</span>
  <span class="k">yield</span> <span class="nx">values</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">somethingAsync</span><span class="p">);</span>
<span class="p">});</span>

<span class="kd">function</span><span class="o">*</span> <span class="nf">somethingAsync</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// do something async</span>
  <span class="k">return</span> <span class="nx">y</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的代码允许并发三个 <code class="language-plaintext highlighter-rouge">somethingAsync</code> 异步操作，等到它们全部完成，才会进行下一步。</p> <p>此外，<a href="https://es6.ruanyifeng.com/#docs/generator-async#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%A4%84%E7%90%86-Stream" rel="external nofollow noopener" target="_blank">这里</a>还有一个在 Node 中处理 Stream 的例子可以参考。</p> <h2 id="十三参考">十三、参考</h2> <ul> <li>阮一峰，<a href="https://es6.ruanyifeng.com/#docs/generator" rel="external nofollow noopener" target="_blank">Generator 函数的语法</a> </li> <li>阮一峰，<a href="https://es6.ruanyifeng.com/#docs/generator-async" rel="external nofollow noopener" target="_blank">Generator 函数的异步应用</a> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/number/">ES6 - 数值的扩展</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/88-merge-sorted-array/">88. 合并两个有序数组</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/bom/">《JavaScript 教程 - 浏览器模型》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/events/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/dom/">《JavaScript 教程》摘录</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Zhang Feng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-repositories",title:"repositories",description:"Edit the `_data/repositories.yml` and change the `github_users` and `github_repos` lists to include your own GitHub profile and repositories.",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"This is a description of the page. You can modify it in &#39;_pages/cv.md&#39;. You can also change or remove the top pdf download button.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"nav-people",title:"people",description:"members of the lab or group",section:"Navigation",handler:()=>{window.location.href="/people/"}},{id:"dropdown-blog",title:"blog",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-es6-\u6570\u503c\u7684\u6269\u5c55",title:"ES6 - \u6570\u503c\u7684\u6269\u5c55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/number/"}},{id:"post-88-\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4",title:"88. \u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/88-merge-sorted-array/"}},{id:"post-javascript-\u6559\u7a0b-\u6d4f\u89c8\u5668\u6a21\u578b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b - \u6d4f\u89c8\u5668\u6a21\u578b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/bom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/dom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/oop/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stdlib/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/features/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/operators/"}},{id:"post-webpack-\u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",title:"webpack \u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/publish-subscribe-model/"}},{id:"post-webpack-\u9879\u76ee\u4f18\u5316",title:"webpack \u9879\u76ee\u4f18\u5316",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/optimization/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/configuration/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/concepts/"}},{id:"post-webpack-\u6784\u5efa\u6d41\u7a0b",title:"webpack \u6784\u5efa\u6d41\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/build-flow/"}},{id:"post-webpack-\u4e2d\u7684-plugin",title:"webpack \u4e2d\u7684 Plugin",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/plugin/"}},{id:"post-webpack-\u4e2d\u7684-loader",title:"webpack \u4e2d\u7684 Loader",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/loader/"}},{id:"post-http-\u7f13\u5b58",title:"HTTP \u7f13\u5b58",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/07-caching/"}},{id:"post-http-\u8fde\u63a5\u7ba1\u7406",title:"HTTP \u8fde\u63a5\u7ba1\u7406",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/04-connection-management/"}},{id:"post-es6-\u7f16\u7a0b\u98ce\u683c",title:"ES6 - \u7f16\u7a0b\u98ce\u683c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/style/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u5e94\u7528\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u5e94\u7528\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/application-layer/"}},{id:"post-\u54cd\u5e94\u5f0f-web-\u8bbe\u8ba1",title:"\u54cd\u5e94\u5f0f Web \u8bbe\u8ba1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/responsive-web-design/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u8fd0\u8f93\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u8fd0\u8f93\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/transport-layer/"}},{id:"post-react-\u4e2d\u7684\u4e8b\u4ef6",title:"React \u4e2d\u7684\u4e8b\u4ef6",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events-in-react/"}},{id:"post-css-\u9884\u5904\u7406\u5668",title:"CSS \u9884\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-preprocessor/"}},{id:"post-css-modules-\u7528\u6cd5\u6559\u7a0b",title:"CSS Modules \u7528\u6cd5\u6559\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-modules/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7f51\u7edc\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7f51\u7edc\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/network-layer/"}},{id:"post-\u8de8\u57df\u8d44\u6e90\u5171\u4eab-cors",title:"\u8de8\u57df\u8d44\u6e90\u5171\u4eab\uff08CORS\uff09",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cors/"}},{id:"post-\u9632\u6296\u548c\u8282\u6d41",title:"\u9632\u6296\u548c\u8282\u6d41",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/debounce-and-throttle/"}},{id:"post-es6-symbol",title:"ES6 - Symbol",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/symbol/"}},{id:"post-es6-\u5b57\u7b26\u4e32\u7684\u6269\u5c55",title:"ES6 - \u5b57\u7b26\u4e32\u7684\u6269\u5c55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/string/"}},{id:"post-es6-set",title:"ES6 - Set",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/set/"}},{id:"post-es6-set-\u548c-map-\u6570\u636e\u7ed3\u6784",title:"ES6 - Set \u548c Map \u6570\u636e\u7ed3\u6784",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/set-map/"}},{id:"post-es6-reflect",title:"ES6 - Reflect",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/reflect/"}},{id:"post-es6-proxy",title:"ES6 - Proxy",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/proxy/"}},{id:"post-es6-promise-\u5bf9\u8c61",title:"ES6 - Promise \u5bf9\u8c61",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/promise/"}},{id:"post-es6-object",title:"ES6 - Object",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/object/"}},{id:"post-es6-\u6a21\u5757",title:"ES6 - \u6a21\u5757",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/module/"}},{id:"post-es6-map",title:"ES6 - Map",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/map/"}},{id:"post-es6-let-\u548c-const-\u547d\u4ee4",title:"ES6 - let \u548c const \u547d\u4ee4",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/let-const/"}},{id:"post-es6-iterator",title:"ES6 - Iterator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/iterator/"}},{id:"post-es6-generator-\u51fd\u6570",title:"ES6 - Generator \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/generator/"}},{id:"post-es6-function",title:"ES6 - Function",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/function/"}},{id:"post-es6-\u88c5\u9970\u5668",title:"ES6 - \u88c5\u9970\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/decorator/"}},{id:"post-es6-class",title:"ES6 - Class",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/class/"}},{id:"post-es6-async-\u51fd\u6570",title:"ES6 - async \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-es6-array",title:"ES6 - Array",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/array/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6570\u636e\u94fe\u8def\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6570\u636e\u94fe\u8def\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/data-link-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7269\u7406\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7269\u7406\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/physical-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6982\u8ff0",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6982\u8ff0",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/instruction/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%7A%66%65%6E%67%30%37%31%32@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=qc6CJjYAAAAJ","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>