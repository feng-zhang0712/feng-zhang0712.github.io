<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 《JavaScript 教程 - 浏览器模型》摘录 | Zhang Feng </title> <meta name="author" content="Zhang Feng"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://feng-zhang0712.github.io//blog/2024/bom/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Zhang</span> Feng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">《JavaScript 教程 - 浏览器模型》摘录</h1> <p class="post-meta"> Created in October 18, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/javascript"> <i class="fa-solid fa-hashtag fa-sm"></i> javascript</a>   <a href="/blog/tag/bom"> <i class="fa-solid fa-hashtag fa-sm"></i> bom</a>   ·   <a href="/blog/category/blog"> <i class="fa-solid fa-tag fa-sm"></i> blog</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/bom/" rel="external nofollow noopener" target="_blank">《JavaScript 教程 - 浏览器模型》</a>一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。</p> </blockquote> <h2 id="一浏览器模型概述">一、浏览器模型概述</h2> <h3 id="1-代码嵌入网页的方法">1. 代码嵌入网页的方法</h3> <p>网页中嵌入 JavaScript 代码，主要有四种方法。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素直接嵌入代码。</p> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">type</code> 属性用来指定脚本类型。<code class="language-plaintext highlighter-rouge">type</code> 属性可以设为两种值。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">text/javascript</code>：这是<strong>默认值</strong>，也是历史上一贯设定的值。如果你省略 <code class="language-plaintext highlighter-rouge">type</code> 属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li> <li> <code class="language-plaintext highlighter-rouge">application/javascript</code>：对于较新的浏览器，建议设为这个值。</li> </ul> <p>如果 <code class="language-plaintext highlighter-rouge">type</code> 属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的 <code class="language-plaintext highlighter-rouge">type</code> 属性即可。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签通过 src 属性加载外部脚本。为了防止攻击者篡改外部脚本，script 标签允许设置一个 <code class="language-plaintext highlighter-rouge">integrity</code> 属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p> <div class="language-html highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://www.example.com/script.js"</span>
  <span class="na">integrity=</span><span class="s">"sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs="</span><span class="nt">&gt;</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div> </div> </li> <li> <p>事件属性：网页元素的事件属性（比如 <code class="language-plaintext highlighter-rouge">onclick</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">button</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">myBtn</span><span class="dl">"</span> <span class="nx">onclick</span><span class="o">=</span><span class="dl">"</span><span class="s2">console.log(this.id)</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">点击</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span></code></pre></div> </div> </li> <li> <p>URL 协议：URL 支持 <code class="language-plaintext highlighter-rouge">javascript:</code> 协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">javascript:console.log('Hello')</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">点击</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">javascript:</code> 协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以 <code class="language-plaintext highlighter-rouge">javascript:</code> 网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上 <code class="language-plaintext highlighter-rouge">void</code>，或者在脚本最后加上 <code class="language-plaintext highlighter-rouge">void 0</code>。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">javascript: void new Date().toLocaleTimeString();</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">点击</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">javascript: new Date().toLocaleTimeString();void 0;</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">点击</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div> </div> <p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p> </li> </ul> <h3 id="2-script-元素">2. script 元素</h3> <h4 id="21-工作原理">2.1 工作原理</h4> <p>正常的网页加载流程是这样的。</p> <ol> <li>对于 HTML 网页，浏览器边下载边解析。</li> <li>解析过程中，浏览器发现 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li> <li>如果 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li> <li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li> </ol> <p><strong>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染</strong>。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p> <p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“<strong>假死</strong>”状态，这被称为“<strong>阻塞效应</strong>”。</p> <p>为了避免这种情况，较好的做法是将 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签都放在页面底部，而不是头部。这样做有几个好处。</p> <ul> <li>即使遇到脚本失去响应，网页主体的渲染也已经完成，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</li> <li>避免因 DOM 结构生成之前调用 DOM 节点而导致的 JavaScript 报错，因为这时 DOM 已经生成了。</li> </ul> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;script&gt;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">);</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div> <p>上面代码执行时会报错，因为此时 document.body 元素还未生成。有几种方式可以解决这个问题。</p> <ul> <li>设定 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件的回调函数。</li> <li>使用 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">onload</code> 属性。</li> <li>将脚本放在页面底部。</li> </ul> <p>如果有多个 <code class="language-plaintext highlighter-rouge">script</code> 标签，比如下面这样。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"a.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"b.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div> <p>浏览器会同时<strong>并行</strong>下载 <code class="language-plaintext highlighter-rouge">a.js</code> 和 <code class="language-plaintext highlighter-rouge">b.js</code>，但是，执行时会保证先执行 <code class="language-plaintext highlighter-rouge">a.js</code>，然后再执行 <code class="language-plaintext highlighter-rouge">b.js</code>，即使后者先下载完成，也是如此。也就是说，<strong>脚本的执行顺序由它们在页面中的出现顺序决定</strong>，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p> <p><strong>解析和执行 CSS，也会产生阻塞</strong>。</p> <p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载 6～20 个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p> <h4 id="22-defer-属性">2.2 defer 属性</h4> <p><code class="language-plaintext highlighter-rouge">defer</code> 属性可以延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</p> <p><code class="language-plaintext highlighter-rouge">defer</code> 属性的运行流程如下。</p> <ol> <li>浏览器开始解析 HTML 网页。</li> <li>解析过程中，发现带有 <code class="language-plaintext highlighter-rouge">defer</code> 属性的 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素。</li> <li>浏览器继续往下解析 HTML 网页，同时并行下载 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素加载的外部脚本。</li> <li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li> </ol> <p>有了 <code class="language-plaintext highlighter-rouge">defer</code> 属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件触发前执行（即刚刚读取完 <code class="language-plaintext highlighter-rouge">&lt;/html&gt;</code> 标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p> <ul> <li>对于内置而不是加载外部脚本的 <code class="language-plaintext highlighter-rouge">script</code> 标签，以及动态生成的 <code class="language-plaintext highlighter-rouge">script</code> 标签，<code class="language-plaintext highlighter-rouge">defer</code> 属性不起作用。</li> <li>使用 <code class="language-plaintext highlighter-rouge">defer</code> 加载的外部脚本不应该使用 <code class="language-plaintext highlighter-rouge">document.write</code> 方法。</li> </ul> <h4 id="23-async-属性">2.3 async 属性</h4> <p><code class="language-plaintext highlighter-rouge">async</code> 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p> <ol> <li>浏览器开始解析 HTML 网页。</li> <li>解析过程中，发现带有 <code class="language-plaintext highlighter-rouge">async</code> 属性的 <code class="language-plaintext highlighter-rouge">script</code> 标签。</li> <li>浏览器继续往下解析 HTML 网页，同时并行下载 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签中的外部脚本。</li> <li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li> <li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li> </ol> <p><code class="language-plaintext highlighter-rouge">async</code> 属性可以保证脚本下载的同时，浏览器继续渲染。</p> <ul> <li>一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。</li> <li>使用 <code class="language-plaintext highlighter-rouge">async</code> 属性的脚本文件里面的代码，不应该使用 <code class="language-plaintext highlighter-rouge">document.write</code> 方法。</li> </ul> <p>一般来说，如果脚本之间没有依赖关系，就使用 <code class="language-plaintext highlighter-rouge">async</code> 属性，如果脚本之间有依赖关系，就使用 <code class="language-plaintext highlighter-rouge">defer</code> 属性。如果同时使用 <code class="language-plaintext highlighter-rouge">async</code> 和 <code class="language-plaintext highlighter-rouge">defer</code> 属性，后者不起作用，浏览器行为由 <code class="language-plaintext highlighter-rouge">async</code> 属性决定。</p> <h4 id="24-脚本的动态加载">2.4 脚本的动态加载</h4> <p><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素还可以动态生成，这种方法的好处是，动态生成的 <code class="language-plaintext highlighter-rouge">script</code> 标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。可以通过设置 <code class="language-plaintext highlighter-rouge">async</code> 属性为 <code class="language-plaintext highlighter-rouge">false</code> 解决这个问题。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">a.js</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b.js</span><span class="dl">'</span><span class="p">].</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">script</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
  <span class="nx">script</span><span class="p">.</span><span class="k">async</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="25-加载使用的协议">2.5 加载使用的协议</h4> <p>如果不指定协议，浏览器默认采用 HTTP 协议下载。如果要采用 HTTPS 协议下载，必需写明。但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">//example.js</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div> <h3 id="3-浏览器的组成">3. 浏览器的组成</h3> <p>浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。</p> <h4 id="31-渲染引擎">3.1 渲染引擎</h4> <p>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。</p> <p>渲染引擎处理网页，通常分成四个阶段。</p> <ol> <li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li> <li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li> <li>布局：计算出渲染树的布局（layout）。</li> <li>绘制：将渲染树绘制到屏幕。</li> </ol> <p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p> <h4 id="32-重流和重绘">3.2 重流和重绘</h4> <p>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p> <p>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（<code class="language-plaintext highlighter-rouge">a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p> <p>重流和重绘并不一定一起发生，<strong>重流必然导致重绘，重绘不一定需要重流</strong>。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p> <p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p> <p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘 <code class="language-plaintext highlighter-rouge">table</code> 布局和 <code class="language-plaintext highlighter-rouge">flex</code> 布局，开销都会比较大。</p> <p>下面是一些优化技巧。</p> <ul> <li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li> <li>缓存 DOM 信息。</li> <li>不要一项一项地改变样式，而是使用 CSS <code class="language-plaintext highlighter-rouge">class</code> 一次性改变样式。</li> <li>使用 <code class="language-plaintext highlighter-rouge">documentFragment</code> 操作 DOM</li> <li>动画使用 <code class="language-plaintext highlighter-rouge">absolute</code> 定位或 <code class="language-plaintext highlighter-rouge">fixed</code> 定位，这样可以减少对其他元素的影响。</li> <li>只在必要时才显示隐藏元素。</li> <li>使用 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li> <li>使用虚拟 DOM（virtual DOM）库。</li> </ul> <h4 id="33-javascript-引擎">3.3 JavaScript 引擎</h4> <p>JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。</p> <p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p> <p>为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p> <p>早期，浏览器内部对 JavaScript 的处理过程如下：</p> <ol> <li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li> <li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li> <li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li> <li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li> </ol> <p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p> <p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。</p> <h2 id="二window-对象">二、window 对象</h2> <h3 id="1-概述">1. 概述</h3> <p>浏览器里面，<code class="language-plaintext highlighter-rouge">window</code> 对象指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p> <h3 id="2-window-对象的属性">2. window 对象的属性</h3> <h4 id="21-通用属性">2.1 通用属性</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">window.name</code> 属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的 <code class="language-plaintext highlighter-rouge">target</code> 属性使用。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.closed</code> 属性返回一个布尔值，表示窗口是否关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">popup</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">();</span>
<span class="k">if </span><span class="p">((</span><span class="nx">popup</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">popup</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 窗口仍然打开着</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">window.opener</code> 属性表示打开当前窗口的<strong>父窗口</strong>。</p> <p>如果两个窗口之间不需要通信，建议将子窗口的 <code class="language-plaintext highlighter-rouge">opener</code> 属性显式设为 <code class="language-plaintext highlighter-rouge">null</code>，这样可以减少一些安全隐患。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">newWin</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">example.html</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">newWindow</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">height=400,width=400</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">newWin</span><span class="p">.</span><span class="nx">opener</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div> </div> <p>通过 <code class="language-plaintext highlighter-rouge">opener</code> 属性，可以获得父窗口的全局属性和方法，但只限于两个窗口<strong>同源</strong>的情况，且其中一个窗口由另一个打开。<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 元素添加 <code class="language-plaintext highlighter-rouge">rel="noopener"</code> 属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p> <div class="language-html highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"https://an.evil.site"</span> <span class="na">target=</span><span class="s">"_blank"</span> <span class="na">rel=</span><span class="s">"noopener"</span><span class="nt">&gt;</span>
恶意网站
<span class="nt">&lt;/a&gt;</span>
</code></pre></div> </div> </li> <li> <code class="language-plaintext highlighter-rouge">window.self</code> 和 <code class="language-plaintext highlighter-rouge">window.window</code> 属性都指向窗口（<code class="language-plaintext highlighter-rouge">window</code>）本身。这两个属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.frames</code> 属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括 <code class="language-plaintext highlighter-rouge">frame</code> 元素和 <code class="language-plaintext highlighter-rouge">iframe</code> 元素。</p> <p><code class="language-plaintext highlighter-rouge">window.frames[0]</code> 表示页面中第一个框架窗口。</p> <p>如果 <code class="language-plaintext highlighter-rouge">iframe</code> 元素设置了 <code class="language-plaintext highlighter-rouge">id</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 属性，那么就可以用属性值，引用这个 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口。比如 <code class="language-plaintext highlighter-rouge">&lt;iframe name="myIFrame"&gt;</code> 可以用 <code class="language-plaintext highlighter-rouge">frames['myIFrame']</code> 或者 <code class="language-plaintext highlighter-rouge">frames.myIFrame</code> 来引用。</p> <p><code class="language-plaintext highlighter-rouge">frames</code> 属性实际上是 <code class="language-plaintext highlighter-rouge">window</code> 对象的别名。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nx">frames</span> <span class="o">===</span> <span class="nb">window</span> <span class="c1">// true</span>
</code></pre></div> </div> <p>因此，<code class="language-plaintext highlighter-rouge">frames[0]</code> 也可以用 <code class="language-plaintext highlighter-rouge">window[0]</code> 表示。但是，从语义上看，<code class="language-plaintext highlighter-rouge">frames</code> 更清晰，而且考虑到 <code class="language-plaintext highlighter-rouge">window</code> 还是全局对象，因此推荐表示多窗口时，总是使用 <code class="language-plaintext highlighter-rouge">frames[0]</code> 的写法。</p> </li> <li> <code class="language-plaintext highlighter-rouge">window.length</code> 属性返回当前网页包含的框架总数。如果当前网页不包含 <code class="language-plaintext highlighter-rouge">frame</code> 和 <code class="language-plaintext highlighter-rouge">iframe</code> 元素，那么 <code class="language-plaintext highlighter-rouge">window.length</code> 就返回 0。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.frameElement</code> 属性主要用于当前窗口嵌在另一个网页的情况（嵌入 <code class="language-plaintext highlighter-rouge">&lt;object&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 或 <code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 元素），返回当前窗口所在的那个元素节点。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;iframe src="about.html"&gt;&lt;/iframe&gt;</span>

<span class="c1">// 下面的脚本在 about.html 里面</span>
<span class="kd">var</span> <span class="nx">frameEl</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">frameElement</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">frameEl</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">frameEl</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">other.html</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">frameEl</code> 变量就是 <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素。</p> </li> <li> <code class="language-plaintext highlighter-rouge">window.top</code> 属性指向<strong>最顶层窗口</strong>，主要用于在框架窗口（<code class="language-plaintext highlighter-rouge">frame</code>）里面获取顶层窗口。</li> <li> <code class="language-plaintext highlighter-rouge">window.parent</code> 属性指向<strong>父窗口</strong>。如果当前窗口没有父窗口，<code class="language-plaintext highlighter-rouge">window.parent</code> 指向自身。</li> <li> <code class="language-plaintext highlighter-rouge">window.status</code> 属性用于读写浏览器状态栏的文本。很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</li> <li> <code class="language-plaintext highlighter-rouge">window.devicePixelRatio</code> 属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。它表示一个 CSS 像素由多少个物理像素组成。</li> </ul> <h4 id="22-位置大小属性">2.2 位置大小属性</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">window.screenX</code> 和 <code class="language-plaintext highlighter-rouge">window.screenY</code> 属性：返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</li> <li> <p><code class="language-plaintext highlighter-rouge">window.innerHeight</code> 和 <code class="language-plaintext highlighter-rouge">window.innerWidth</code> 属性：返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。</p> <p>用户放大网页的时候（比如将网页从 100% 的大小放大为 200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是 960px），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。注意，这两个属性值包括滚动条的高度和宽度。</p> </li> <li> <code class="language-plaintext highlighter-rouge">window.outerHeight</code> 和 <code class="language-plaintext highlighter-rouge">window.outerWidth</code> 属性：返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。</li> <li> <code class="language-plaintext highlighter-rouge">window.scrollX</code> 和 <code class="language-plaintext highlighter-rouge">window.scrollY</code> 属性返回页面的水平/垂直滚动距离，单位都为像素。这两个属性只读。</li> <li> <code class="language-plaintext highlighter-rouge">window.pageXOffset</code> 和 <code class="language-plaintext highlighter-rouge">window.pageYOffset</code> 属性是 <code class="language-plaintext highlighter-rouge">window.scrollX</code> 和 <code class="language-plaintext highlighter-rouge">window.scrollY</code> 别名。</li> </ul> <h4 id="23-组件属性">2.3 组件属性</h4> <p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">window.locationbar</code>：地址栏对象</li> <li> <code class="language-plaintext highlighter-rouge">window.menubar</code>：菜单栏对象</li> <li> <code class="language-plaintext highlighter-rouge">window.scrollbars</code>：窗口的滚动条对象</li> <li> <code class="language-plaintext highlighter-rouge">window.toolbar</code>：工具栏对象</li> <li> <code class="language-plaintext highlighter-rouge">window.statusbar</code>：状态栏对象</li> <li> <code class="language-plaintext highlighter-rouge">window.personalbar</code>：用户安装的个人工具栏对象</li> </ul> <p>这些对象的 <code class="language-plaintext highlighter-rouge">visible</code> 属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p> <h4 id="24-全局对象属性">2.4 全局对象属性</h4> <p>全局对象属性指向一些浏览器原生的全局对象。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">window.document</code>：指向 <code class="language-plaintext highlighter-rouge">document</code> 对象。注意，这个属性有同源限制。只有来自<strong>同源</strong>的脚本才能读取这个属性。</li> <li> <code class="language-plaintext highlighter-rouge">window.location</code>：指向 <code class="language-plaintext highlighter-rouge">Location</code> 对象，用于获取当前窗口的 URL 信息。它等同于 <code class="language-plaintext highlighter-rouge">document.location</code> 属性。</li> <li> <code class="language-plaintext highlighter-rouge">window.navigator</code>：指向 <code class="language-plaintext highlighter-rouge">Navigator</code> 对象，用于获取<strong>环境信息</strong>。</li> <li> <code class="language-plaintext highlighter-rouge">window.history</code>：指向 <code class="language-plaintext highlighter-rouge">History</code> 对象，表示浏览器的浏览历史。</li> <li> <code class="language-plaintext highlighter-rouge">window.localStorage</code>：指向本地储存的 <code class="language-plaintext highlighter-rouge">localStorage</code> 数据。</li> <li> <code class="language-plaintext highlighter-rouge">window.sessionStorage</code>：指向本地储存的 <code class="language-plaintext highlighter-rouge">sessionStorage</code> 数据。</li> <li> <code class="language-plaintext highlighter-rouge">window.console</code>：指向 <code class="language-plaintext highlighter-rouge">console</code> 对象，用于操作控制台。</li> <li> <code class="language-plaintext highlighter-rouge">window.screen</code>：指向 <code class="language-plaintext highlighter-rouge">Screen</code> 对象，表示屏幕信息。</li> </ul> <h4 id="25-windowissecurecontext">2.5 window.isSecureContext</h4> <p><code class="language-plaintext highlighter-rouge">window.isSecureContext</code> 属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是 <code class="language-plaintext highlighter-rouge">true</code>，否则就是 <code class="language-plaintext highlighter-rouge">false</code>。</p> <h3 id="3-window-对象的方法">3. window 对象的方法</h3> <h4 id="31-windowalertwindowpromptwindowconfirm">3.1 window.alert()，window.prompt()，window.confirm()</h4> <p>window.alert()、window.prompt()、window.confirm() 都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">window.alert(message)</code> 方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。无返回值。</li> <li> <code class="language-plaintext highlighter-rouge">window.confirm(message)</code> 方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。返回一个布尔值，表示是否选择了确定（<code class="language-plaintext highlighter-rouge">true</code>）还是取消（<code class="language-plaintext highlighter-rouge">false</code>）。</li> <li> <code class="language-plaintext highlighter-rouge">window.prompt(message, defaultValue)</code> 方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。返回一个包含用户输入文本的字符串，或 <code class="language-plaintext highlighter-rouge">null</code>。</li> </ul> <h4 id="32-windowopen-windowclosewindowstop">3.2 window.open(), window.close()，window.stop()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">window.open(url, target, [windowFeatures])</code> 方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用。</p> <ul> <li>url：字符串，表示新窗口的网址。如果省略，默认网址就是 <code class="language-plaintext highlighter-rouge">about:blank</code>。</li> <li>target：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用 <code class="language-plaintext highlighter-rouge">_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code class="language-plaintext highlighter-rouge">_self</code> 表示当前窗口，<code class="language-plaintext highlighter-rouge">_top</code> 表示顶层窗口，<code class="language-plaintext highlighter-rouge">_parent</code> 表示上一层窗口。</li> <li> <code class="language-plaintext highlighter-rouge">windowFeatures</code>：字符串，内容为逗号分隔的键值对，表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。关于此参数支持的配置项，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open#windowfeatures" rel="external nofollow noopener" target="_blank">windowfeatures 属性</a>。</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">window.close()</code> 方法用于关闭当前窗口，一般只用来关闭 <code class="language-plaintext highlighter-rouge">window.open</code> 方法新建的窗口。该方法只对顶层窗口有效，<code class="language-plaintext highlighter-rouge">iframe</code> 框架之中的窗口使用该方法无效。</li> <li> <code class="language-plaintext highlighter-rouge">window.stop()</code> 方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</li> </ul> <h4 id="33-windowmovetowindowmoveby">3.3 window.moveTo()，window.moveBy()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">window.moveTo(x, y)</code> 方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</li> <li> <code class="language-plaintext highlighter-rouge">window.moveBy(deltaX, deltaY)</code> 方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</li> </ul> <p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用 <code class="language-plaintext highlighter-rouge">window.open()</code> 方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。</p> <h4 id="34-windowresizetowindowresizeby">3.4 window.resizeTo()，window.resizeBy()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">window.resizeTo(aWidth, aHeight)</code> 方法用于缩放窗口到指定大小。它接受两个参数，第一个是缩放后的窗口宽度（<code class="language-plaintext highlighter-rouge">aWidth</code> 属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code class="language-plaintext highlighter-rouge">aHeight</code> 属性）。</li> <li> <code class="language-plaintext highlighter-rouge">window.resizeBy(xDelta, yDelta)</code> 方法用于缩放窗口。它与 <code class="language-plaintext highlighter-rouge">window.resizeTo()</code> 的区别是，它按照相对的量缩放，<code class="language-plaintext highlighter-rouge">window.resizeTo()</code> 需要给出缩放后的绝对大小。它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</li> </ul> <h4 id="35-windowscrolltowindowscrollwindowscrollby">3.5 window.scrollTo()，window.scroll()，window.scrollBy()</h4> <ul> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scrollTo(x-coord, y-coord)</code></td> <td> <code class="language-plaintext highlighter-rouge">window.scrollTo(options)</code> 方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。它也可以接受一个配置对象作为参数，配置对象 <code class="language-plaintext highlighter-rouge">options</code> 有三个属性。</td> </tr> </tbody> </table> <ul> <li> <code class="language-plaintext highlighter-rouge">top</code>：滚动后页面左上角的垂直坐标，即 <code class="language-plaintext highlighter-rouge">y</code> 坐标。</li> <li> <code class="language-plaintext highlighter-rouge">left</code>：滚动后页面左上角的水平坐标，即 <code class="language-plaintext highlighter-rouge">x</code> 坐标。</li> <li> <code class="language-plaintext highlighter-rouge">behavior</code>：字符串，表示滚动的方式，有三个可能值（<code class="language-plaintext highlighter-rouge">smooth</code>、<code class="language-plaintext highlighter-rouge">instant</code>、<code class="language-plaintext highlighter-rouge">auto</code>），默认值为 <code class="language-plaintext highlighter-rouge">auto</code>。</li> </ul> </li> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scrollBy(x-coord, y-coord)</code></td> <td> <code class="language-plaintext highlighter-rouge">window.scrollBy(options)</code> 方法用于将网页滚动指定距离（单位像素）。</td> </tr> </tbody> </table> </li> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">window.scroll(x-coord, y-coord)</code></td> <td> <code class="language-plaintext highlighter-rouge">window.scroll(options)</code> 方法是 <code class="language-plaintext highlighter-rouge">window.scrollTo()</code> 方法的别名。</td> </tr> </tbody> </table> </li> </ul> <p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Element.scrollTop</code></li> <li><code class="language-plaintext highlighter-rouge">Element.scrollLeft</code></li> <li><code class="language-plaintext highlighter-rouge">Element.scrollIntoView()</code></li> </ul> <h4 id="36-windowprint">3.6 window.print()</h4> <p><code class="language-plaintext highlighter-rouge">window.print()</code> 方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p> <h4 id="37-windowfocuswindowblur">3.7 window.focus()，window.blur()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">window.focus()</code> 方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</li> <li> <code class="language-plaintext highlighter-rouge">window.blur()</code> 方法将焦点从窗口移除。</li> </ul> <h4 id="38-windowgetselection">3.8 window.getSelection()</h4> <p><code class="language-plaintext highlighter-rouge">window.getSelection()</code> 方法返回一个 <code class="language-plaintext highlighter-rouge">Selection</code> 对象，表示用户现在选中的文本。使用 <code class="language-plaintext highlighter-rouge">Selection</code> 对象的 <code class="language-plaintext highlighter-rouge">toString()</code> 方法可以得到选中的文本。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">selObj</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">getSelection</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">selectedText</span> <span class="o">=</span> <span class="nx">selObj</span><span class="p">.</span><span class="nf">toString</span><span class="p">();</span>
</code></pre></div></div> <h4 id="39-windowgetcomputedstylewindowmatchmedia">3.9 window.getComputedStyle()，window.matchMedia()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">window.getComputedStyle(element, pseudoElt)</code> 方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象。</li> <li> <code class="language-plaintext highlighter-rouge">window.matchMedia(mediaQueryString)</code> 方法用来检查 CSS 的 <code class="language-plaintext highlighter-rouge">mediaQuery</code> 语句。</li> </ul> <h4 id="310-windowrequestanimationframe">3.10 window.requestAnimationFrame()</h4> <p><code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 方法跟 <code class="language-plaintext highlighter-rouge">setTimeout</code> 类似，都是推迟某个函数的执行。不同之处在于，<code class="language-plaintext highlighter-rouge">setTimeout</code> 必须指定推迟的时间，<code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code class="language-plaintext highlighter-rouge">requestAnimationFrame()</code> 会暂停执行。</p> <p>如果某个函数会改变网页的布局，一般就放在 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p> <p>该方法接受一个回调函数作为参数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">callback</code> 是一个回调函数。<code class="language-plaintext highlighter-rouge">callback</code> 执行时，它的参数就是系统传入的一个高精度时间戳（<code class="language-plaintext highlighter-rouge">performance.now()</code> 的返回值），单位是毫秒，表示距离网页加载的时间。</p> <p><code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 的返回值是一个整数，这个整数可以传入 <code class="language-plaintext highlighter-rouge">window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p> <p>下面是一个 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 执行网页动画的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">animate</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">absolute</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">step</span><span class="p">(</span><span class="nx">timestamp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">start</span><span class="p">)</span> <span class="nx">start</span> <span class="o">=</span> <span class="nx">timestamp</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">progress</span> <span class="o">=</span> <span class="nx">timestamp</span> <span class="o">-</span> <span class="nx">start</span><span class="p">;</span>
  <span class="c1">// 元素不断向右移，最大不超过200像素</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">progress</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
  <span class="c1">// 如果距离第一次执行不超过 2000 毫秒，</span>
  <span class="c1">// 就继续执行动画</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">progress</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">step</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">step</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码定义了一个网页动画，持续时间是 2 秒，会让元素向右移动。</p> <h4 id="311-windowrequestidlecallback">3.11 window.requestIdleCallback()</h4> <p><code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 跟 <code class="language-plaintext highlighter-rouge">setTimeout</code> 类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用 <code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 将其推迟执行，以保证网页性能。</p> <p>它跟 <code class="language-plaintext highlighter-rouge">window.requestAnimationFrame()</code> 的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在 16ms 之内完成；<code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 可以保证回调函数在系统资源空闲时执行。</p> <p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nf">requestIdleCallback</span><span class="p">(</span><span class="nx">callback</span><span class="p">[,</span> <span class="nx">options</span><span class="p">])</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">callback</code> 参数是一个回调函数。该回调函数执行时，系统会传入一个 <code class="language-plaintext highlighter-rouge">IdleDeadline</code> 对象作为参数。<code class="language-plaintext highlighter-rouge">IdleDeadline</code> 对象有一个 <code class="language-plaintext highlighter-rouge">didTimeout</code> 属性（布尔值，表示是否为超时调用）和一个 <code class="language-plaintext highlighter-rouge">timeRemaining()</code> 方法（返回该空闲时段剩余的毫秒数）。</p> <p><code class="language-plaintext highlighter-rouge">options</code> 参数是一个配置对象，目前只有 <code class="language-plaintext highlighter-rouge">timeout</code> 一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p> <p><code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code> 方法返回一个整数。该整数可以传入 <code class="language-plaintext highlighter-rouge">window.cancelIdleCallback()</code> 取消回调函数。</p> <p>下面是一个例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">requestIdleCallback</span><span class="p">(</span><span class="nx">myNonEssentialWork</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">myNonEssentialWork</span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while </span><span class="p">(</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">timeRemaining</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">doWorkIfNeeded</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">requestIdleCallback()</code> 用来执行非关键任务 <code class="language-plaintext highlighter-rouge">myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p> <p>下面是指定 <code class="language-plaintext highlighter-rouge">timeout</code> 的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">requestIdleCallback</span><span class="p">(</span><span class="nx">processPendingAnalyticsEvents</span><span class="p">,</span> <span class="p">{</span> <span class="na">timeout</span><span class="p">:</span> <span class="mi">2000</span> <span class="p">});</span>
</code></pre></div></div> <p>上面代码指定，<code class="language-plaintext highlighter-rouge">processPendingAnalyticsEvents</code> 必须在未来 2 秒之内执行。</p> <p>如果由于超时导致回调函数执行，则 <code class="language-plaintext highlighter-rouge">deadline.timeRemaining()</code> 返回 <code class="language-plaintext highlighter-rouge">0</code>，<code class="language-plaintext highlighter-rouge">deadline.didTimeout</code> 返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>如果多次执行 <code class="language-plaintext highlighter-rouge">window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p> <h3 id="4-事件">4. 事件</h3> <h4 id="41-load-事件和-onload-属性">4.1 load 事件和 onload 属性</h4> <p>load 事件发生在文档在浏览器窗口加载完毕时。window.onload 属性可以指定这个事件的回调函数。</p> <h4 id="42-error-事件和-onerror-属性">4.2 error 事件和 onerror 属性</h4> <p>error 事件发生在浏览器脚本发生错误时，window.onerror 属性可以指定该事件的回调函数。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p> <h4 id="43-window-对象的事件监听属性">4.3 window 对象的事件监听属性</h4> <p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code class="language-plaintext highlighter-rouge">window</code> 对象还具有以下的事件监听函数属性。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">window.onafterprint</code>：<code class="language-plaintext highlighter-rouge">afterprint</code>事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onbeforeprint</code>：<code class="language-plaintext highlighter-rouge">beforeprint</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onbeforeunload</code>：<code class="language-plaintext highlighter-rouge">beforeunload</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onhashchange</code>：<code class="language-plaintext highlighter-rouge">hashchange</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onlanguagechange</code>: <code class="language-plaintext highlighter-rouge">languagechange</code> 的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onmessage</code>：<code class="language-plaintext highlighter-rouge">message</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onmessageerror</code>：<code class="language-plaintext highlighter-rouge">MessageError</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onoffline</code>：<code class="language-plaintext highlighter-rouge">offline</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.ononline</code>：<code class="language-plaintext highlighter-rouge">online</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onpagehide</code>：<code class="language-plaintext highlighter-rouge">pagehide</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onpageshow</code>：<code class="language-plaintext highlighter-rouge">pageshow</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onpopstate</code>：<code class="language-plaintext highlighter-rouge">popstate</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onstorage</code>：<code class="language-plaintext highlighter-rouge">storage</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onunhandledrejection</code>：未处理的 <code class="language-plaintext highlighter-rouge">Promise</code> 对象的 <code class="language-plaintext highlighter-rouge">reject</code> 事件的监听函数。</li> <li> <code class="language-plaintext highlighter-rouge">window.onunload</code>：<code class="language-plaintext highlighter-rouge">unload</code> 事件的监听函数。</li> </ul> <h3 id="5-多窗口操作">5. 多窗口操作</h3> <p>由于网页可以使用 <code class="language-plaintext highlighter-rouge">iframe</code> 元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p> <h4 id="51-窗口的引用">5.1 窗口的引用</h4> <p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">top</code>：顶层窗口，即最上层的那个窗口</li> <li> <code class="language-plaintext highlighter-rouge">parent</code>：父窗口</li> <li> <code class="language-plaintext highlighter-rouge">self</code>：当前窗口，即自身</li> </ul> <p>与这些变量对应，浏览器还提供一些特殊的窗口名，供 <code class="language-plaintext highlighter-rouge">window.open()</code> 方法、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 标签、<code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> 标签等引用。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">_top</code>：顶层窗口</li> <li> <code class="language-plaintext highlighter-rouge">_parent</code>：父窗口</li> <li> <code class="language-plaintext highlighter-rouge">_blank</code>：新窗口</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">somepage.html</span><span class="dl">"</span> <span class="nx">target</span><span class="o">=</span><span class="dl">"</span><span class="s2">_top</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">Link</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span></code></pre></div></div> <p>上面代码就表示在顶层窗口打开链接。</p> <h4 id="52-iframe-元素">5.2 iframe 元素</h4> <p>对于 <code class="language-plaintext highlighter-rouge">iframe</code> 嵌入的窗口，<code class="language-plaintext highlighter-rouge">document.getElementById</code> 方法可以拿到该窗口的 DOM 节点，然后使用 <code class="language-plaintext highlighter-rouge">contentWindow</code> 属性获得 <code class="language-plaintext highlighter-rouge">iframe</code> 节点包含的 <code class="language-plaintext highlighter-rouge">window</code> 对象。</p> <p><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素的 <code class="language-plaintext highlighter-rouge">contentDocument</code> 属性，可以拿到子窗口的 <code class="language-plaintext highlighter-rouge">document</code> 对象。</p> <p><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素遵守<strong>同源策略</strong>，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用 <code class="language-plaintext highlighter-rouge">window.postMessage</code> 方法。</p> <p><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 窗口内部，使用 <code class="language-plaintext highlighter-rouge">window.parent</code> 引用父窗口。如果当前页面没有父窗口，则 <code class="language-plaintext highlighter-rouge">window.parent</code> 属性返回自身。因此，可以通过 <code class="language-plaintext highlighter-rouge">window.parent</code> 是否等于 <code class="language-plaintext highlighter-rouge">window.self</code>，判断当前窗口是否为 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">parent</span> <span class="o">!==</span> <span class="nb">window</span><span class="p">.</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 当前窗口是子窗口</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 窗口的 <code class="language-plaintext highlighter-rouge">window</code> 对象，有一个 <code class="language-plaintext highlighter-rouge">frameElement</code> 属性，返回 <code class="language-plaintext highlighter-rouge">4</code> 在父窗口中的 DOM 节点。</p> <h4 id="53-windowframes-属性">5.3 window.frames 属性</h4> <p><code class="language-plaintext highlighter-rouge">window.frames</code> 属性返回一个类似数组的对象，成员是所有子窗口的 <code class="language-plaintext highlighter-rouge">window</code> 对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code class="language-plaintext highlighter-rouge">frames[0]</code> 返回第一个子窗口，<code class="language-plaintext highlighter-rouge">frames[1].frames[2]</code>返 回第二个子窗口内部的第三个子窗口。</p> <p>注意，<code class="language-plaintext highlighter-rouge">window.frames</code> 每个成员的值，是框架内的窗口（即框架的 <code class="language-plaintext highlighter-rouge">window</code> 对象），而不是 <code class="language-plaintext highlighter-rouge">iframe</code> 标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用 <code class="language-plaintext highlighter-rouge">window.frames[0].document</code> 的写法。</p> <p>另外，如果 <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code> 元素设置了 <code class="language-plaintext highlighter-rouge">name</code> 或 <code class="language-plaintext highlighter-rouge">id</code> 属性，那么属性值会自动成为全局变量，并且可以通过 <code class="language-plaintext highlighter-rouge">window.frames</code> 属性引用，返回子窗口的 <code class="language-plaintext highlighter-rouge">window</code> 对象。</p> <h2 id="三navigator-对象screen-对象">三、Navigator 对象，Screen 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="四cookie">四、Cookie</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="五xmlhttprequest-对象">五、XMLHttpRequest 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="六同源限制">六、同源限制</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="七cors-通信">七、CORS 通信</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="八storage-接口">八、Storage 接口</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="九history-对象">九、History 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十location-对象url-对象urlsearchparams-对象">十、Location 对象，URL 对象，URLSearchParams 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十一arraybuffer-对象blob-对象">十一、ArrayBuffer 对象，Blob 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十二file-对象filelist-对象filereader-对象">十二、File 对象，FileList 对象，FileReader 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十三表单formdata-对象">十三、表单，FormData 对象</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十四indexeddb-api">十四、IndexedDB API</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十五web-worker">十五、Web Worker</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> <h2 id="十六参考">十六参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/bom/" rel="external nofollow noopener" target="_blank">JavaScript 教程 - 浏览器模型</a> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/events/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/dom/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/async/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/oop/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/stdlib/">《JavaScript 教程》摘录</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Zhang Feng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-repositories",title:"repositories",description:"Edit the `_data/repositories.yml` and change the `github_users` and `github_repos` lists to include your own GitHub profile and repositories.",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"This is a description of the page. You can modify it in &#39;_pages/cv.md&#39;. You can also change or remove the top pdf download button.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"nav-people",title:"people",description:"members of the lab or group",section:"Navigation",handler:()=>{window.location.href="/people/"}},{id:"dropdown-blog",title:"blog",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-javascript-\u6559\u7a0b-\u6d4f\u89c8\u5668\u6a21\u578b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b - \u6d4f\u89c8\u5668\u6a21\u578b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/bom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/dom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/oop/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stdlib/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/features/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/operators/"}},{id:"post-webpack-\u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",title:"webpack \u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/publish-subscribe-model/"}},{id:"post-webpack-\u9879\u76ee\u4f18\u5316",title:"webpack \u9879\u76ee\u4f18\u5316",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/optimization/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/configuration/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/concepts/"}},{id:"post-webpack-\u6784\u5efa\u6d41\u7a0b",title:"webpack \u6784\u5efa\u6d41\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/build-flow/"}},{id:"post-webpack-\u4e2d\u7684-plugin",title:"webpack \u4e2d\u7684 Plugin",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/plugin/"}},{id:"post-webpack-\u4e2d\u7684-loader",title:"webpack \u4e2d\u7684 Loader",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/loader/"}},{id:"post-http-\u7f13\u5b58",title:"HTTP \u7f13\u5b58",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/07-caching/"}},{id:"post-http-\u8fde\u63a5\u7ba1\u7406",title:"HTTP \u8fde\u63a5\u7ba1\u7406",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/04-connection-management/"}},{id:"post-es6-\u7f16\u7a0b\u98ce\u683c",title:"ES6 - \u7f16\u7a0b\u98ce\u683c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/style/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u5e94\u7528\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u5e94\u7528\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/application-layer/"}},{id:"post-\u54cd\u5e94\u5f0f-web-\u8bbe\u8ba1",title:"\u54cd\u5e94\u5f0f Web \u8bbe\u8ba1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/responsive-web-design/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u8fd0\u8f93\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u8fd0\u8f93\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/transport-layer/"}},{id:"post-react-\u4e2d\u7684\u4e8b\u4ef6",title:"React \u4e2d\u7684\u4e8b\u4ef6",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events-in-react/"}},{id:"post-css-\u9884\u5904\u7406\u5668",title:"CSS \u9884\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-preprocessor/"}},{id:"post-css-modules-\u7528\u6cd5\u6559\u7a0b",title:"CSS Modules \u7528\u6cd5\u6559\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-modules/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7f51\u7edc\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7f51\u7edc\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/network-layer/"}},{id:"post-\u8de8\u57df\u8d44\u6e90\u5171\u4eab-cors",title:"\u8de8\u57df\u8d44\u6e90\u5171\u4eab\uff08CORS\uff09",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cors/"}},{id:"post-\u9632\u6296\u548c\u8282\u6d41",title:"\u9632\u6296\u548c\u8282\u6d41",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/debounce-and-throttle/"}},{id:"post-es6-symbol",title:"ES6 - Symbol",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/symbol/"}},{id:"post-es6-\u5b57\u7b26\u4e32\u7684\u6269\u5c55",title:"ES6 - \u5b57\u7b26\u4e32\u7684\u6269\u5c55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/string/"}},{id:"post-es6-set",title:"ES6 - Set",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/set/"}},{id:"post-es6-reflect",title:"ES6 - Reflect",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/reflect/"}},{id:"post-es6-proxy",title:"ES6 - Proxy",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/proxy/"}},{id:"post-es6-promise-\u5bf9\u8c61",title:"ES6 - Promise \u5bf9\u8c61",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/promise/"}},{id:"post-es6-object",title:"ES6 - Object",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/object/"}},{id:"post-es6-\u6a21\u5757",title:"ES6 - \u6a21\u5757",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/module/"}},{id:"post-es6-map",title:"ES6 - Map",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/map/"}},{id:"post-es6-let-\u548c-const-\u547d\u4ee4",title:"ES6 - let \u548c const \u547d\u4ee4",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/let-const/"}},{id:"post-es6-iterator",title:"ES6 - Iterator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/iterator/"}},{id:"post-es6-generator-\u51fd\u6570",title:"ES6 - Generator \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/generator/"}},{id:"post-es6-function",title:"ES6 - Function",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/function/"}},{id:"post-es6-decorator",title:"ES6 - Decorator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/decorator/"}},{id:"post-es6-class",title:"ES6 - Class",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/class/"}},{id:"post-es6-async-\u51fd\u6570",title:"ES6 - async \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-es6-array",title:"ES6 - Array",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/array/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6570\u636e\u94fe\u8def\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6570\u636e\u94fe\u8def\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/data-link-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7269\u7406\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7269\u7406\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/physical-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6982\u8ff0",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6982\u8ff0",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/instruction/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%7A%66%65%6E%67%30%37%31%32@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=qc6CJjYAAAAJ","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>