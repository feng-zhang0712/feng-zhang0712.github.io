<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 《JavaScript 教程》摘录 | Zhang Feng </title> <meta name="author" content="Zhang Feng"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://feng-zhang0712.github.io//blog/2024/dom/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Zhang</span> Feng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">《JavaScript 教程》摘录</h1> <p class="post-meta"> Created in October 12, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/javascript"> <i class="fa-solid fa-hashtag fa-sm"></i> JavaScript</a>   <a href="/blog/tag/dom"> <i class="fa-solid fa-hashtag fa-sm"></i> DOM</a>   ·   <a href="/blog/category/blog"> <i class="fa-solid fa-tag fa-sm"></i> blog</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>本文是对<a href="https://wangdoc.com/javascript/dom/" rel="external nofollow noopener" target="_blank">《JavaScript 教程 - DOM》</a>一章中部分知识点的摘录，请访问原文，获取更多详细信息。</p> </blockquote> <h2 id="一概述">一、概述</h2> <p>DOM 是 JavaScript 操作网页的接口，全称为“<strong>文档对象模型</strong>”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。DOM 的最小组成单位叫做<strong>节点</strong>（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p> <p>节点的类型有七种。浏览器提供一个原生的节点对象 <code class="language-plaintext highlighter-rouge">Node</code>，这七种节点都继承了 <code class="language-plaintext highlighter-rouge">Node</code>。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Document</code>：整个文档树的顶层节点</li> <li> <code class="language-plaintext highlighter-rouge">DocumentType</code>：<code class="language-plaintext highlighter-rouge">doctype</code> 标签（比如 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>）</li> <li> <code class="language-plaintext highlighter-rouge">DocumentFragment</code>：文档的片段</li> <li> <code class="language-plaintext highlighter-rouge">Element</code>：网页的各种 HTML 标签（比如 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 等）</li> <li> <code class="language-plaintext highlighter-rouge">Attr</code>：网页元素的属性（比如 <code class="language-plaintext highlighter-rouge">class="right"</code>）</li> <li> <code class="language-plaintext highlighter-rouge">Text</code>：标签之间或标签包含的文本</li> <li> <code class="language-plaintext highlighter-rouge">Comment</code>：注释</li> </ul> <p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 <strong>DOM 树</strong>。它有一个顶层节点，下一层都是顶层节点的子节点。</p> <p>浏览器原生提供 <code class="language-plaintext highlighter-rouge">document</code> 节点，代表整个文档。文档的第一层有两个节点：</p> <ul> <li>第一个是文档类型节点（<code class="language-plaintext highlighter-rouge">&lt;!doctype html&gt;</code>）；</li> <li>第二个是 HTML 网页的顶层容器标签 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code>，它构成了树结构的<strong>根节点</strong>（root node），其他 HTML 标签节点都是它的下级节点。</li> </ul> <p>除了根节点，其他节点有三种层级关系。</p> <ul> <li>父节点关系（parentNode）：直接的那个上级节点</li> <li>子节点关系（childNodes）：直接的下级节点</li> <li>同级节点关系（sibling）：拥有同一个父节点的节点</li> </ul> <p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括 <code class="language-plaintext highlighter-rouge">firstChild</code>（第一个子节点）和 <code class="language-plaintext highlighter-rouge">lastChild</code>（最后一个子节点）等属性，同级节点接口包括 <code class="language-plaintext highlighter-rouge">previousSibling</code>（紧邻在前的那个同级节点）和 <code class="language-plaintext highlighter-rouge">nextSibling</code>（紧邻在后的那个同级节点）属性。</p> <h2 id="二node-接口">二、Node 接口</h2> <p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。</p> <h3 id="1-属性">1. 属性</h3> <h4 id="11-nodeprototypenodetype">1.1 Node.prototype.nodeType</h4> <p><code class="language-plaintext highlighter-rouge">nodeType</code> 属性返回一个整数值，表示节点的<strong>类型</strong>。不同节点的 <code class="language-plaintext highlighter-rouge">nodeType</code> 属性值和对应的常量如下。</p> <ul> <li>文档节点（document）：<code class="language-plaintext highlighter-rouge">9</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code> </li> <li>文档类型节点（DocumentType）：<code class="language-plaintext highlighter-rouge">10</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_TYPE_NODE</code> </li> <li>文档片断节点（DocumentFragment）：<code class="language-plaintext highlighter-rouge">11</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_FRAGMENT_NODE</code> </li> <li>元素节点（element）：<code class="language-plaintext highlighter-rouge">1</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.ELEMENT_NODE</code> </li> <li>属性节点（attr）：<code class="language-plaintext highlighter-rouge">2</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.ATTRIBUTE_NODE</code> </li> <li>文本节点（text）：<code class="language-plaintext highlighter-rouge">3</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.TEXT_NODE</code> </li> <li>注释节点（Comment）：<code class="language-plaintext highlighter-rouge">8</code>，对应常量 <code class="language-plaintext highlighter-rouge">Node.COMMENT_NODE</code> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">nodeType</span> <span class="c1">// 9</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">DOCUMENT_NODE</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="12-nodeprototypenodename">1.2 Node.prototype.nodeName</h4> <p><code class="language-plaintext highlighter-rouge">nodeName</code> 属性返回节点的<strong>名称</strong>。不同节点的 <code class="language-plaintext highlighter-rouge">nodeName</code> 属性值如下。</p> <ul> <li>文档节点（document）：<code class="language-plaintext highlighter-rouge">#document</code> </li> <li>文档类型节点（DocumentType）：文档的类型</li> <li>文档片断节点（DocumentFragment）：<code class="language-plaintext highlighter-rouge">#document-fragment</code> </li> <li>元素节点（element）：大写的标签名</li> <li>属性节点（attr）：属性的名称</li> <li>文本节点（text）：<code class="language-plaintext highlighter-rouge">#text</code> </li> <li>注释节点（Comment）：<code class="language-plaintext highlighter-rouge">#comment</code> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">nodeName</span> <span class="c1">// "DIV"</span>
</code></pre></div></div> <h4 id="13-nodeprototypenodevalue">1.3 Node.prototype.nodeValue</h4> <p><code class="language-plaintext highlighter-rouge">nodeValue</code> 属性返回一个字符串，表示当前节点本身的<strong>文本值</strong>，该属性<strong>可读写</strong>。</p> <p>只有<strong>属性节点</strong>（attr）、<strong>文本节点</strong>（text）和<strong>注释节点</strong>（comment）有文本值，因此这三类节点的 <code class="language-plaintext highlighter-rouge">nodeValue</code> 可以返回结果，其他类型的节点一律返回 <code class="language-plaintext highlighter-rouge">null</code>。也只有这三类节点可以设置 <code class="language-plaintext highlighter-rouge">nodeValue</code> 属性的值，其他类型的节点设置无效。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="c1">// null</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="c1">// "hello world"</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">div</code> 是元素节点，<code class="language-plaintext highlighter-rouge">nodeValue</code> 属性返回 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">div.firstChild</code> 是文本节点，所以可以返回文本值。</p> <h4 id="14-nodeprototypetextcontent">1.4 Node.prototype.textContent</h4> <p><code class="language-plaintext highlighter-rouge">textContent</code> 属性返回<strong>当前节点和它的所有后代节点</strong>的<strong>文本内容</strong>。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">textContent</code> 属性自动忽略当前节点内部的 HTML 标签，返回所有<strong>文本内容</strong>。</li> <li>该属性<strong>可读写</strong>，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它会自动对 HTML 标签转义。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;div id="divA"&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">divA</span><span class="dl">'</span><span class="p">).</span><span class="nx">textContent</span>
<span class="c1">// This is some text</span>
</code></pre></div></div> <h4 id="15-nodeprototypebaseuri">1.5 Node.prototype.baseURI</h4> <p><code class="language-plaintext highlighter-rouge">baseURI</code> 属性返回一个字符串，表示当前网页的<strong>绝对路径</strong>。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为<strong>只读</strong>。该属性的值一般由当前网址的 URL（即 <code class="language-plaintext highlighter-rouge">window.location</code> 属性）决定，但是可以使用 HTML 的 <code class="language-plaintext highlighter-rouge">&lt;base&gt;</code> 标签，改变该属性的值。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 当前网页的网址为</span>
<span class="c1">// http://www.example.com/index.html</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">baseURI</span>
<span class="c1">// "http://www.example.com/index.html"</span>
<span class="o">&lt;</span><span class="nx">base</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">http://www.example.com/page.html</span><span class="dl">"</span><span class="o">&gt;</span>
</code></pre></div></div> <h4 id="16-nodeprototypeownerdocument">1.6 Node.prototype.ownerDocument</h4> <p><code class="language-plaintext highlighter-rouge">Node.ownerDocument</code> 属性返回当前节点所在的顶层文档对象，即 <code class="language-plaintext highlighter-rouge">document</code> 对象。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ownerDocument</span><span class="p">;</span>
<span class="nx">d</span> <span class="o">===</span> <span class="nb">document</span> <span class="c1">// true</span>
</code></pre></div></div> <h4 id="17-nodeprototypeprevioussiblingnodeprototypenextsibling">1.7 Node.prototype.previousSibling，Node.prototype.nextSibling</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">previousSibling</code> 属性返回当前节点<strong>前面的</strong>、<strong>距离最近的一个同级节点</strong>。</li> <li> <code class="language-plaintext highlighter-rouge">nextSibling</code> 属性返回紧跟在当前节点<strong>后面的第一个同级节点</strong>。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d2</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d2</span><span class="p">.</span><span class="nx">previousSibling</span> <span class="o">===</span> <span class="nx">d1</span> <span class="c1">// true</span>

<span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d1</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d2</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d1</span><span class="p">.</span><span class="nx">nextSibling</span> <span class="o">===</span> <span class="nx">d2</span> <span class="c1">// true</span>
</code></pre></div></div> <p>注意，这两个属性还包括文本节点和注释节点。因此如果当前节点前面/后面有空格，他们都会返回一个文本节点，内容为空格。</p> <h4 id="18-nodeprototypeparentnode">1.8 Node.prototype.parentNode</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">parentNode</code> 属性返回当前节点的<strong>父节点</strong>。对于一个节点来说，它的父节点只可能是三种类型：<strong>文档节点</strong>（document）、<strong>文档片段节点</strong>（documentfragment）和<strong>元素节点</strong>（element）。文档节点（document）和文档片段节点（documentfragment）的父节点都是 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li> <code class="language-plaintext highlighter-rouge">parentElement</code> 属性返回当前节点的<strong>父元素节点</strong>。此属性只包含元素节点。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="19-nodeprototypefirstchildnodeprototypelastchild">1.9 Node.prototype.firstChild，Node.prototype.lastChild</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">firstChild</code> 属性返回当前节点的第一个子节点。<code class="language-plaintext highlighter-rouge">firstChild</code> 返回的除了元素节点，还可能是文本节点或注释节点。</li> <li> <code class="language-plaintext highlighter-rouge">lastChild</code> 属性返回当前节点的最后一个子节点。用法与 <code class="language-plaintext highlighter-rouge">firstChild</code> 属性相同。</li> </ul> <h4 id="110-nodeprototypechildnodes">1.10 Node.prototype.childNodes</h4> <p><code class="language-plaintext highlighter-rouge">childNodes</code> 属性返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">NodeList</code> 集合），成员包括当前节点的所有子节点。<code class="language-plaintext highlighter-rouge">childNodes</code> 属性的返回值包括<strong>元素节点</strong>、<strong>文本节点</strong>和<strong>注释节点</strong>。如果当前节点不包括任何子节点，则返回一个空的 <code class="language-plaintext highlighter-rouge">NodeList</code> 集合。</p> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 对象是一个<strong>动态集合</strong>，子节点发生的变化会立刻反映在返回结果之中。</p> <h4 id="111-nodeprototypeisconnected">1.11 Node.prototype.isConnected</h4> <p><code class="language-plaintext highlighter-rouge">isConnected</code> 布尔值，表示当前节点是否在文档之中。</p> <h3 id="2-方法">2. 方法</h3> <h4 id="21-nodeprototypeappendchild">2.1 Node.prototype.appendChild()</h4> <p><code class="language-plaintext highlighter-rouge">appendChild(aChild)</code> 接受一个节点对象作为参数，将其作为<strong>最后一个</strong>子节点，插入当前节点。该方法的返回值是插入文档的子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</code></pre></div></div> <p>如果参数节点是 DOM 已经存在的节点，<code class="language-plaintext highlighter-rouge">appendChild()</code> 会将其从原来的位置，<strong>移动</strong>到新位置。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">div</span><span class="p">);</span>
</code></pre></div></div> <h4 id="22-nodeprototypehaschildnodes">2.2 Node.prototype.hasChildNodes()</h4> <p><code class="language-plaintext highlighter-rouge">hasChildNodes()</code> 返回布尔值，表示当前节点是否有子节点。子节点包括所有类型的节点，哪怕节点只包含一个空格，<code class="language-plaintext highlighter-rouge">hasChildNodes()</code> 方法也会返回 <code class="language-plaintext highlighter-rouge">true</code>。</p> <h4 id="23-nodeprototypeclonenode">2.3 Node.prototype.cloneNode()</h4> <p><code class="language-plaintext highlighter-rouge">cloneNode(deep)</code> 用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">cloneUL</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">).</span><span class="nf">cloneNode</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>克隆一个节点，会拷贝该节点的所有属性，但是会丧失 <code class="language-plaintext highlighter-rouge">addEventListener()</code> 方法和 <code class="language-plaintext highlighter-rouge">on-属性</code>（即 <code class="language-plaintext highlighter-rouge">node.onclick = fn</code>），添加在这个节点上的事件回调函数。</li> <li>该方法返回的节点不在文档中，即没有任何父节点，必须使用诸如 <code class="language-plaintext highlighter-rouge">Node.appendChild()</code> 这样的方法添加到文档之中。</li> <li>克隆一个节点之后，DOM 有可能出现两个有相同 <code class="language-plaintext highlighter-rouge">id</code> 属性的网页元素，这时应该修改其中一个元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性。如果原节点有 <code class="language-plaintext highlighter-rouge">name</code> 属性，可能也需要修改。</li> </ul> <h4 id="24-nodeprototypeinsertbefore">2.4 Node.prototype.insertBefore()</h4> <p><code class="language-plaintext highlighter-rouge">insertBefore(newNode, referenceNode)</code> 用于将某个节点插入父节点内部的指定位置。</p> <ul> <li>第一个参数是所要插入的节点 <code class="language-plaintext highlighter-rouge">newNode</code>。</li> <li>第二个参数是父节点 <code class="language-plaintext highlighter-rouge">parentNode</code> 内部的一个子节点 <code class="language-plaintext highlighter-rouge">referenceNode</code>。如果第二个参数为 <code class="language-plaintext highlighter-rouge">null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">insertBefore</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，新建一个 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 节点，插在 <code class="language-plaintext highlighter-rouge">document.body.firstChild</code> 的前面，也就是成为 <code class="language-plaintext highlighter-rouge">document.body</code> 的第一个子节点。</p> <p>由于不存在 <code class="language-plaintext highlighter-rouge">insertAfter</code> 方法，如果新节点要插在父节点的某个子节点后面，可以用 <code class="language-plaintext highlighter-rouge">insertBefore()</code> 结合 <code class="language-plaintext highlighter-rouge">nextSibling</code> 属性模拟。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parent</span><span class="p">.</span><span class="nf">insertBefore</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">parent</code> 是父节点，<code class="language-plaintext highlighter-rouge">s1</code> 是一个全新的节点，<code class="language-plaintext highlighter-rouge">s2</code> 是可以将 <code class="language-plaintext highlighter-rouge">s1</code> 节点，插在 <code class="language-plaintext highlighter-rouge">s2</code> 节点的后面。如果 <code class="language-plaintext highlighter-rouge">s2</code> 是当前节点的最后一个子节点，则 <code class="language-plaintext highlighter-rouge">s2.nextSibling</code> 返 回 <code class="language-plaintext highlighter-rouge">null</code>，这时 <code class="language-plaintext highlighter-rouge">s1</code> 节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在 <code class="language-plaintext highlighter-rouge">s2</code> 的后面。</p> <h4 id="25-nodeprototyperemovechild">2.5 Node.prototype.removeChild()</h4> <p><code class="language-plaintext highlighter-rouge">removeChild(child)</code> 接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">divA</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">divA</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">divA</span><span class="p">);</span>
</code></pre></div></div> <h4 id="26-nodeprototypereplacechild">2.6 Node.prototype.replaceChild()</h4> <p><code class="language-plaintext highlighter-rouge">replaceChild(newChild, oldChild)</code> 用于将一个新的节点，替换当前节点的某个子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">replacedNode</span> <span class="o">=</span> <span class="nx">parentNode</span><span class="p">.</span><span class="nf">replaceChild</span><span class="p">(</span><span class="nx">newChild</span><span class="p">,</span> <span class="nx">oldChild</span><span class="p">);</span>
</code></pre></div></div> <h4 id="27-nodeprototypecontains">2.7 Node.prototype.contains()</h4> <p><code class="language-plaintext highlighter-rouge">contains(otherNode)</code> 返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p> <ul> <li>参数节点为<strong>当前节点</strong>。</li> <li>参数节点为当前节点的<strong>子节点</strong>。</li> <li>参数节点为当前节点的<strong>后代节点</strong>。</li> </ul> <h4 id="28-nodeprototypecomparedocumentposition">2.8 Node.prototype.compareDocumentPosition()</h4> <p><code class="language-plaintext highlighter-rouge">compareDocumentPosition(otherNode)</code> 与 <code class="language-plaintext highlighter-rouge">contains()</code> 完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的<strong>关系</strong>。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">000000</code>：十进制的 0，表示两个节点<strong>相同</strong> </li> <li> <code class="language-plaintext highlighter-rouge">000001</code>：十进制的 1，表示两个节点不在同一个文档（即有一个节点不在当前文档）</li> <li> <code class="language-plaintext highlighter-rouge">000010</code>：十进制的 2，表示参数节点在当前节点的<strong>前面</strong> </li> <li> <code class="language-plaintext highlighter-rouge">000100</code>：十进制的 4，表示参数节点在当前节点的<strong>后面</strong> </li> <li> <code class="language-plaintext highlighter-rouge">001000</code>：十进制的 8，表示参数节点<strong>包含</strong>当前节点</li> <li> <code class="language-plaintext highlighter-rouge">010000</code>：十进制的 16，表示当前节点<strong>包含</strong>参数节点</li> <li> <code class="language-plaintext highlighter-rouge">100000</code>：十进制的 32，表示浏览器内部使用</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="mydiv"&gt;</span>
<span class="c1">//   &lt;form&gt;&lt;input id="test" /&gt;&lt;/form&gt;</span>
<span class="c1">// &lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">mydiv</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="c1">// 20</span>
<span class="nx">input</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">div</span><span class="p">)</span> <span class="c1">// 10</span>
</code></pre></div></div> <p>上面代码中，节点 <code class="language-plaintext highlighter-rouge">div</code> 包含节点 <code class="language-plaintext highlighter-rouge">input</code>（二进制 <code class="language-plaintext highlighter-rouge">010000</code>），而且节点 <code class="language-plaintext highlighter-rouge">input</code> 在节点 <code class="language-plaintext highlighter-rouge">div</code> 的后面（二进制 <code class="language-plaintext highlighter-rouge">000100</code>），所以第一个 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 方法返回 <code class="language-plaintext highlighter-rouge">20</code>（二进制 <code class="language-plaintext highlighter-rouge">010100</code>，即 <code class="language-plaintext highlighter-rouge">010000</code> + <code class="language-plaintext highlighter-rouge">000100</code>），第二个 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 方法返回 <code class="language-plaintext highlighter-rouge">10</code>（二进制 <code class="language-plaintext highlighter-rouge">001010</code>）。</p> <p>由于 <code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 返回值的含义，定义在每个比特位上，所以如果要检查某种特定的含义，就需要使用比特位运算符。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">head</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nf">compareDocumentPosition</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">文档结构正确</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;body&gt; 不能在 &lt;head&gt; 前面</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">compareDocumentPosition()</code> 的返回值与 <code class="language-plaintext highlighter-rouge">4</code>（又称掩码）进行与运算（<code class="language-plaintext highlighter-rouge">&amp;</code>），得到一个布尔值，表示 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 是否在 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 前面。</p> <h4 id="29-nodeprototypeisequalnodenodeprototypeissamenode">2.9 Node.prototype.isEqualNode()，Node.prototype.isSameNode()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">isEqualNode(otherNode)</code> 返回一个布尔值，用于检查两个节点是否<strong>相等</strong>。所谓相等的节点，指的是两个节点的<strong>类型</strong>相同、<strong>属性</strong>相同、<strong>子节点</strong>相同。</li> <li> <code class="language-plaintext highlighter-rouge">isSameNode(otherNode)</code> 返回一个布尔值，表示两个节点是否为<strong>同一个</strong>节点。</li> </ul> <h4 id="210-nodeprototypenormalize">2.10 Node.prototype.normalize()</h4> <p><code class="language-plaintext highlighter-rouge">normalize()</code> 用于清理当前节点内部的所有<strong>文本节点</strong>（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。该方法是 <code class="language-plaintext highlighter-rouge">Text.splitText()</code> 的逆方法。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">Part 1 </span><span class="dl">'</span><span class="p">));</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">Part 2 </span><span class="dl">'</span><span class="p">));</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nf">normalize</span><span class="p">();</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1</span>
</code></pre></div></div> <p>上面代码使用 <code class="language-plaintext highlighter-rouge">normalize()</code> 之前，<code class="language-plaintext highlighter-rouge">wrapper</code> 节点有两个毗邻的文本子节点。使 <code class="language-plaintext highlighter-rouge">normalize()</code> 之后，两个文本子节点被合并成一个。</p> <h4 id="211-nodeprototypegetrootnode">2.11 Node.prototype.getRootNode()</h4> <p><code class="language-plaintext highlighter-rouge">getRootNode(options)</code> 返回当前节点所在文档的根节点 <code class="language-plaintext highlighter-rouge">document</code>，与 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性的作用相同。</p> <h2 id="三nodelist-接口htmlcollection-接口">三、NodeList 接口，HTMLCollection 接口</h2> <p>DOM 提供两种节点集合，用于容纳多个节点：<code class="language-plaintext highlighter-rouge">NodeList</code> 和 <code class="language-plaintext highlighter-rouge">HTMLCollection</code>。<code class="language-plaintext highlighter-rouge">NodeList</code> 可以包含各种类型的节点，<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 只能包含 HTML 元素节点。</p> <h3 id="1-nodelist-接口">1. NodeList 接口</h3> <h4 id="11-概述">1.1 概述</h4> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例。</p> <ul> <li><code class="language-plaintext highlighter-rouge">Node.childNodes</code></li> <li> <code class="language-plaintext highlighter-rouge">document.querySelectorAll()</code> 等节点搜索方法</li> </ul> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 是对象不是数组，但可以使用 <code class="language-plaintext highlighter-rouge">length</code> 属性和 <code class="language-plaintext highlighter-rouge">forEach()</code> 。</p> <p><code class="language-plaintext highlighter-rouge">NodeList</code> 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例。目前，只有 <code class="language-plaintext highlighter-rouge">Node.childNodes</code> 返回的是动态集合，其他的都是静态集合。</p> <h4 id="12-nodelistprototypelength">1.2 NodeList.prototype.length</h4> <p><code class="language-plaintext highlighter-rouge">length</code> 属性返回 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例包含的节点数量。</p> <h4 id="13-nodelistprototypeforeach">1.3 NodeList.prototype.forEach()</h4> <p><code class="language-plaintext highlighter-rouge">forEach()</code> 方法用于遍历 <code class="language-plaintext highlighter-rouge">NodeList</code> 的所有成员。</p> <h4 id="14-nodelistprototypeitem">1.4 NodeList.prototype.item()</h4> <p><code class="language-plaintext highlighter-rouge">item(index)</code> 接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（<code class="language-plaintext highlighter-rouge">[]</code>），而不使用 <code class="language-plaintext highlighter-rouge">item()</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div> <h4 id="15-nodelistprototypekeysnodelistprototypevaluesnodelistprototypeentries">1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h4> <p>这三个方法都返回一个 ES6 的<strong>遍历器对象</strong>，可以通过 <code class="language-plaintext highlighter-rouge">for...of</code> 循环遍历获取每个成员的信息。<code class="language-plaintext highlighter-rouge">keys()</code> 返回键名的遍历器，<code class="language-plaintext highlighter-rouge">values()</code> 返回键值的遍历器，<code class="language-plaintext highlighter-rouge">entries()</code> 返回的遍历器同时包含键名和键值的信息。</p> <h3 id="2-htmlcollection-接口">2. HTMLCollection 接口</h3> <h4 id="21-概述">2.1 概述</h4> <p><code class="language-plaintext highlighter-rouge">HTMLCollection</code> 是一个只包含<strong>元素节点</strong>（element）对象的集合，不包含其他类型的节点。它的返回值是一个类似数组的对象，<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 只能使用 <code class="language-plaintext highlighter-rouge">for</code> 循环遍历。</p> <p>返回 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例的，主要是一些 <code class="language-plaintext highlighter-rouge">Document</code> 对象的集合属性，比如 <code class="language-plaintext highlighter-rouge">document.links</code>、<code class="language-plaintext highlighter-rouge">document.forms</code>、<code class="language-plaintext highlighter-rouge">document.images</code> 等。</p> <p>如果元素节点有 <code class="language-plaintext highlighter-rouge">id</code> 或 <code class="language-plaintext highlighter-rouge">name</code> 属性，那么 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例上面，可以使用 <code class="language-plaintext highlighter-rouge">id</code> 属性或 <code class="language-plaintext highlighter-rouge">name</code> 属性引用该节点元素。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span>
<span class="kd">var</span> <span class="nx">pic</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">.</span><span class="nx">pic</span> <span class="o">===</span> <span class="nx">pic</span> <span class="c1">// true</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">document.images</code> 是一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，可以通过 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性值，从 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例上取到这个元素。</p> <h4 id="22-htmlcollectionprototypelength">2.2 HTMLCollection.prototype.length</h4> <p><code class="language-plaintext highlighter-rouge">length</code> 属性返回 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例包含的成员数量。</p> <h4 id="23-htmlcollectionprototypeitem">2.3 HTMLCollection.prototype.item()</h4> <p><code class="language-plaintext highlighter-rouge">item(index)</code> 接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（<code class="language-plaintext highlighter-rouge">[]</code>），而不使用 <code class="language-plaintext highlighter-rouge">item()</code>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">img0</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div> <h4 id="24-htmlcollectionprototypenameditem">2.4 HTMLCollection.prototype.namedItem()</h4> <p><code class="language-plaintext highlighter-rouge">namedItem(key)</code> 的参数是一个字符串，表示 <code class="language-plaintext highlighter-rouge">id</code> 属性或 <code class="language-plaintext highlighter-rouge">name</code> 属性的值，返回当前集合中对应的元素节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span>
<span class="kd">var</span> <span class="nx">pic</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">.</span><span class="nf">namedItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">pic</span><span class="dl">'</span><span class="p">)</span> <span class="o">===</span> <span class="nx">pic</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Collection.namedItem('value')</code> 等同于 <code class="language-plaintext highlighter-rouge">Collection['value']</code>。</p> <h2 id="四parentnode-接口childnode-接口">四、ParentNode 接口，ChildNode 接口</h2> <p>节点对象除了继承 <code class="language-plaintext highlighter-rouge">Node</code> 接口以外，还拥有其他接口。<code class="language-plaintext highlighter-rouge">ParentNode</code> 接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code class="language-plaintext highlighter-rouge">ChildNode</code> 接口表示当前节点是一个子节点，提供一些相关方法。</p> <h3 id="1-parentnode-接口">1. ParentNode 接口</h3> <p>如果当前节点是父节点，就会混入（mixin）<code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。只有<strong>文档节点</strong>（document）、<strong>文档片段节点</strong>（documentFragment）和<strong>元素节点</strong>（element）拥有 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。</p> <h4 id="11-parentnodechildren">1.1 ParentNode.children</h4> <p><code class="language-plaintext highlighter-rouge">children</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是当前节点的<strong>所有元素子节点</strong>。该属性只读。</p> <h4 id="12-parentnodefirstelementchildparentnodelastelementchild">1.2 ParentNode.firstElementChild，ParentNode.lastElementChild</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">firstElementChild</code> 属性返回当前节点的<strong>第一个元素子节点</strong>。</li> <li> <code class="language-plaintext highlighter-rouge">lastElementChild</code> 属性返回当前节点的<strong>最后一个元素子节点</strong>。</li> </ul> <h4 id="13-parentnodechildelementcount">1.3 ParentNode.childElementCount</h4> <p><code class="language-plaintext highlighter-rouge">childElementCount</code> 属性返回一个整数，表示当前节点的所有元素子节点的数目。</p> <h4 id="14-parentnodeappendparentnodeprepend">1.4 ParentNode.append()，ParentNode.prepend()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">append(node1, node2, ...)</code> 为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。该方法可以添加<strong>元素节点</strong>（参数为元素节点）和<strong>文本节点</strong>（参数为字符串）。</li> <li> <code class="language-plaintext highlighter-rouge">prepend(node1, node2, ...)</code> 为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与 <code class="language-plaintext highlighter-rouge">append()</code> 完全一致，也是没有返回值。</li> </ul> <p>注意，<code class="language-plaintext highlighter-rouge">append()</code> 与 <code class="language-plaintext highlighter-rouge">Node.prototype.appendChild()</code> 有三点不同。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">append()</code> 允许字符串作为参数，<code class="language-plaintext highlighter-rouge">appendChild()</code> 只允许子节点作为参数。</li> <li> <code class="language-plaintext highlighter-rouge">append()</code> 没有返回值，而 <code class="language-plaintext highlighter-rouge">appendChild()</code> 返回添加的子节点。</li> <li> <code class="language-plaintext highlighter-rouge">append()</code> 可以添加多个子节点和字符串（即允许多个参数），<code class="language-plaintext highlighter-rouge">appendChild()</code> 只能添加一个节点（即只允许一个参数）。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
<span class="c1">// 添加元素子节点</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="c1">// 添加文本子节点</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 添加多个元素子节点</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">);</span>
<span class="c1">// 添加元素子节点和文本子节点</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span> <span class="nx">p</span><span class="p">);</span>
</code></pre></div></div> <h3 id="2-childnode-接口">2. ChildNode 接口</h3> <p>如果一个节点有父节点，那么该节点就拥有了 <code class="language-plaintext highlighter-rouge">ChildNode</code> 接口。</p> <h4 id="21-childnoderemove">2.1 ChildNode.remove()</h4> <p><code class="language-plaintext highlighter-rouge">remove()</code> 用于从父节点移除当前节点。</p> <h4 id="22-childnodebeforechildnodeafter">2.2 ChildNode.before()，ChildNode.after()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">before(node1, node2, ...)</code> 方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。该方法可以插入<strong>元素节点</strong>和<strong>文本节点</strong>。</li> <li> <code class="language-plaintext highlighter-rouge">after(node1, node2, ...</code> 方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与 <code class="language-plaintext highlighter-rouge">before()</code> 完全相同。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 插入元素节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="c1">// 插入文本节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 插入多个元素节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">p1</span><span class="p">);</span>
<span class="c1">// 插入元素节点和文本节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">before</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <h4 id="23-childnodereplacewith">2.3 ChildNode.replaceWith()</h4> <p><code class="language-plaintext highlighter-rouge">replaceWith(node1, node2, ...)</code> 方法使用参数节点，替换当前节点。参数可以是<strong>元素节点</strong>、<strong>文本节点</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">span</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">span</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">replaceWith</span><span class="p">(</span><span class="nx">span</span><span class="p">);</span>
</code></pre></div></div> <h2 id="五document-节点">五、Document 节点</h2> <h3 id="1-概述">1. 概述</h3> <p><code class="language-plaintext highlighter-rouge">document</code> 节点对象代表整个文档，每张网页都有自己的 <code class="language-plaintext highlighter-rouge">document</code> 对象。<code class="language-plaintext highlighter-rouge">window.document</code> 属性就指向这个对象。当浏览器开始载入 HTML 文档，该对象就存在。<code class="language-plaintext highlighter-rouge">document</code> 对象有不同的办法可以获取。</p> <ul> <li>正常的网页，直接使用 <code class="language-plaintext highlighter-rouge">document</code> 或 <code class="language-plaintext highlighter-rouge">window.document</code>。</li> <li> <code class="language-plaintext highlighter-rouge">iframe</code> 框架里面的网页，使用 iframe 节点的 <code class="language-plaintext highlighter-rouge">contentDocument</code> 属性。</li> <li>Ajax 操作返回的文档，使用 <code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> 对象的 <code class="language-plaintext highlighter-rouge">responseXML</code> 属性。</li> <li>内部节点的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document</code> 对象继承了 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口和 <code class="language-plaintext highlighter-rouge">Node</code> 接口，并且混入（mixin）了 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。这意味着，这些接口的方法都可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象上调用。除此之外，<code class="language-plaintext highlighter-rouge">document</code> 对象还有很多自己的属性和方法。</p> <h3 id="2-属性">2. 属性</h3> <h4 id="21-快捷方式属性">2.1 快捷方式属性</h4> <p>以下属性是指向文档内部的某个节点的快捷方式。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">document.defaultView</code>：返回 <code class="language-plaintext highlighter-rouge">document</code> 对象所属的 <code class="language-plaintext highlighter-rouge">window</code> 对象。如果当前文档不属于 <code class="language-plaintext highlighter-rouge">window</code> 对象，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li> <code class="language-plaintext highlighter-rouge">document.doctype</code>：<code class="language-plaintext highlighter-rouge">document</code> 对象一般有两个子节点。第一个子节点是 <code class="language-plaintext highlighter-rouge">document.doctype</code>，指向 <code class="language-plaintext highlighter-rouge">&lt;DOCTYPE&gt;</code> 节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成 <code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>。</li> <li> <code class="language-plaintext highlighter-rouge">document.documentElement</code>：返回当前文档的<strong>根元素节点</strong>（root）。它通常是 <code class="language-plaintext highlighter-rouge">document</code> 节点的第二个子节点，紧跟在 <code class="language-plaintext highlighter-rouge">document.doctype</code> 节点后面。HTML 网页的该属性，一般是 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 节点。</li> <li> <code class="language-plaintext highlighter-rouge">document.head</code>：指向 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 节点，该属性<strong>可读写</strong>。</li> <li> <code class="language-plaintext highlighter-rouge">document.body</code>：指向 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 节点，该属性<strong>可读写</strong>。</li> <li> <code class="language-plaintext highlighter-rouge">document.scrollingElement</code>：返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。标准模式下，这个属性返回的文档的根元素 <code class="language-plaintext highlighter-rouge">document.documentElement</code>（即 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code>）。兼容（quirk）模式下，返回的是 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素，如果该元素不存在，返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li> <code class="language-plaintext highlighter-rouge">document.activeElement</code>：返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;textarea&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;select&gt;</code> 等表单元素，如果当前没有焦点元素，返回 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素或 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li> <code class="language-plaintext highlighter-rouge">document.fullscreenElement</code>：返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> </ul> <h4 id="22-节点集合属性">2.2 节点集合属性</h4> <p>以下属性（除 <code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性外）返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，表示文档内部特定元素的集合。这些集合都是<strong>动态的</strong>，原节点有任何变化，立刻会反映在集合中。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">document.links</code>：返回当前文档所有设定了 href 属性的 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 及 <code class="language-plaintext highlighter-rouge">&lt;area&gt;</code> 节点。</li> <li> <code class="language-plaintext highlighter-rouge">document.forms</code>：返回所有 <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> 表单节点。</li> <li> <code class="language-plaintext highlighter-rouge">document.images</code>：返回页面所有 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 图片节点。</li> <li> <code class="language-plaintext highlighter-rouge">document.embeds</code>，<code class="language-plaintext highlighter-rouge">document.plugins</code>：所有 <code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 节点。</li> <li> <code class="language-plaintext highlighter-rouge">document.scripts</code>：返回所有 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 节点。</li> <li> <code class="language-plaintext highlighter-rouge">document.styleSheets</code>：返回网页内嵌或引入的 CSS 样式表集合。</li> </ul> <p>除了 <code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性，以上的其他集合属性返回的都是 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例。<code class="language-plaintext highlighter-rouge">document.styleSheets</code> 属性返回的是 <code class="language-plaintext highlighter-rouge">StyleSheetList</code> 实例。</p> <h4 id="23-文档静态信息属性">2.3 文档静态信息属性</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">document.documentURI</code>，<code class="language-plaintext highlighter-rouge">document.URL</code>：返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code class="language-plaintext highlighter-rouge">documentURI</code> 继承自 <code class="language-plaintext highlighter-rouge">Document</code> 接口，可用于所有文档；<code class="language-plaintext highlighter-rouge">URL</code> 继承自 <code class="language-plaintext highlighter-rouge">HTMLDocument</code> 接口，只能用于 HTML 文档。</li> <li> <code class="language-plaintext highlighter-rouge">document.domain</code>：返回当前文档的<strong>域名</strong>，不包含协议和端口。</li> <li> <code class="language-plaintext highlighter-rouge">document.location</code>：<code class="language-plaintext highlighter-rouge">Location</code> 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 <code class="language-plaintext highlighter-rouge">window.location</code> 和 <code class="language-plaintext highlighter-rouge">document.location</code> 属性，可以拿到这个对象。</li> <li> <code class="language-plaintext highlighter-rouge">document.lastModified</code>：返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</li> <li> <code class="language-plaintext highlighter-rouge">document.title</code>：返回当前文档的标题。默认情况下，返回 <code class="language-plaintext highlighter-rouge">&lt;title&gt;</code> 节点的值。该属性<strong>可读写</strong>。</li> <li> <code class="language-plaintext highlighter-rouge">document.characterSet</code>：返回当前文档的编码，比如 UTF-8 等等。</li> <li> <code class="language-plaintext highlighter-rouge">document.referrer</code>：返回一个字符串，表示当前文档的访问者来自哪里。<code class="language-plaintext highlighter-rouge">document.referrer</code> 的值，总是与 HTTP 头信息的 <code class="language-plaintext highlighter-rouge">Referer</code> 字段保持一致。</li> <li> <code class="language-plaintext highlighter-rouge">document.dir</code>：返回一个字符串，表示文字方向。它有两个可能的值：<code class="language-plaintext highlighter-rouge">rtl</code> 表示文字从右到左，阿拉伯文是这种方式；<code class="language-plaintext highlighter-rouge">ltr</code> 表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</li> <li> <code class="language-plaintext highlighter-rouge">document.compatMode</code>：返回浏览器处理文档的模式，可能的值为 <code class="language-plaintext highlighter-rouge">BackCompat</code>（向后兼容模式）和 <code class="language-plaintext highlighter-rouge">CSS1Compat</code>（严格模式）。一般来说，如果网页代码的第一行设置了明确的 <code class="language-plaintext highlighter-rouge">DOCTYPE</code>（比如 <code class="language-plaintext highlighter-rouge">&lt;!doctype html&gt;</code>），<code class="language-plaintext highlighter-rouge">document.compatMode</code> 的值都为 <code class="language-plaintext highlighter-rouge">CSS1Compat</code>。</li> </ul> <h4 id="24-文档状态属性">2.4 文档状态属性</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">document.hidden</code>：布尔值，表示当前页面<strong>是否可见</strong>。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得 <code class="language-plaintext highlighter-rouge">document.hidden</code> 返回 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.visibilityState</code>：返回文档的<strong>可见状态</strong>。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li> <li> <code class="language-plaintext highlighter-rouge">hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li> <li> <code class="language-plaintext highlighter-rouge">prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li> <li> <code class="language-plaintext highlighter-rouge">unloaded</code>：页面从内存里面卸载了。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">document.readyState</code>：返回当前文档的<strong>状态</strong>，共有三种可能的值。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">loading</code>：加载 HTML 代码阶段（尚未完成解析）。</li> <li> <code class="language-plaintext highlighter-rouge">interactive</code>：加载外部资源阶段。</li> <li> <code class="language-plaintext highlighter-rouge">complete</code>：加载完成。</li> </ul> </li> </ul> <p><code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变化的过程如下。</p> <ol> <li>浏览器开始解析 HTML 文档，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性等于 <code class="language-plaintext highlighter-rouge">loading</code>。</li> <li>浏览器遇到 HTML 文档中的 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素，并且没有 <code class="language-plaintext highlighter-rouge">async</code> 或 <code class="language-plaintext highlighter-rouge">defer</code> 属性，就暂停解析，开始执行脚本，这时 <code class="language-plaintext highlighter-rouge">document.readyState</code> 属性还是 <code class="language-plaintext highlighter-rouge">loading</code>。</li> <li>HTML 文档解析完成，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变成 <code class="language-plaintext highlighter-rouge">interactive</code>。</li> <li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code class="language-plaintext highlighter-rouge">document.readyState</code> 属性变成 <code class="language-plaintext highlighter-rouge">complete</code>。</li> </ol> <h4 id="25-documentcookie">2.5 document.cookie</h4> <p><code class="language-plaintext highlighter-rouge">document.cookie</code> 属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。</p> <h4 id="26-documentdesignmode">2.6 document.designMode</h4> <p><code class="language-plaintext highlighter-rouge">document.designMode</code> 属性控制当前文档是否可编辑。该属性只有两个值 <code class="language-plaintext highlighter-rouge">on</code> 和 <code class="language-plaintext highlighter-rouge">off</code>，默认值为 <code class="language-plaintext highlighter-rouge">off</code>。</p> <h4 id="27-documentcurrentscript">2.7 document.currentScript</h4> <p><code class="language-plaintext highlighter-rouge">document.currentScript</code> 属性只用在 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素的 DOM 节点。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">id=</span><span class="s">"foo"</span><span class="nt">&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">currentScript</span> <span class="o">===</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">);</span> <span class="c1">// true</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">document.currentScript</code> 就是 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 元素节点。</p> <h4 id="28-documentimplementation">2.8 document.implementation</h4> <p><code class="language-plaintext highlighter-rouge">document.implementation</code> 属性返回一个 <code class="language-plaintext highlighter-rouge">DOMImplementation</code> 对象。该对象有三个方法，主要用于创建独立于当前文档的新的 <code class="language-plaintext highlighter-rouge">Document</code> 对象。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li> <li> <code class="language-plaintext highlighter-rouge">DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li> <li> <code class="language-plaintext highlighter-rouge">DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li> </ul> <p>下面是创建 HTML 文档的例子。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">implementation</span><span class="p">.</span><span class="nf">createHTMLDocument</span><span class="p">(</span><span class="dl">'</span><span class="s1">Title</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">replaceChild</span><span class="p">(</span>
  <span class="nx">doc</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span>
<span class="p">);</span>
</code></pre></div></div> <p>上面代码中，第一步生成一个新的 HTML 文档 <code class="language-plaintext highlighter-rouge">doc</code>，然后用它的根元素 <code class="language-plaintext highlighter-rouge">doc.documentElement</code> 替换掉 <code class="language-plaintext highlighter-rouge">document.documentElement</code>。这会使得当前文档的内容全部消失，变成 <code class="language-plaintext highlighter-rouge">hello world</code>。</p> <h3 id="3-方法">3. 方法</h3> <h4 id="31-documentopendocumentclose">3.1 document.open()，document.close()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">document.open()</code> 清除当前文档所有内容，使得文档处于<strong>可写状态</strong>，供 <code class="language-plaintext highlighter-rouge">document.write</code> 方法写入内容。</li> <li> <code class="language-plaintext highlighter-rouge">document.close()</code> 用来关闭 <code class="language-plaintext highlighter-rouge">document.open()</code> 打开的文档。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">open</span><span class="p">();</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
</code></pre></div></div> <h4 id="32-documentwritedocumentwriteln">3.2 document.write()，document.writeln()</h4> <p><code class="language-plaintext highlighter-rouge">document.write(markup)</code> 方法用于向当前文档写入内容。<code class="language-plaintext highlighter-rouge">document.write</code> 是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对 <code class="language-plaintext highlighter-rouge">innerHTML</code> 属性赋值）。所以，除了某些特殊情况，应该尽量<strong>避免使用</strong> <code class="language-plaintext highlighter-rouge">document.write()</code> 这个方法。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">document.write()</code> 会当作 HTML 代码解析，不会转义。</li> <li>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行 <code class="language-plaintext highlighter-rouge">document.close()</code>），<code class="language-plaintext highlighter-rouge">document.write()</code> 写入的内容就会追加在已有内容的后面。</li> <li>如果页面已经解析完成（<code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件发生之后）再调用 <code class="language-plaintext highlighter-rouge">write()</code> ，它会先调用 <code class="language-plaintext highlighter-rouge">open()</code> ，擦除当前文档所有内容，然后再写入。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document.writeln(line)</code> 与 <code class="language-plaintext highlighter-rouge">write()</code> 完全一致，除了会在输出内容的尾部添加换行符。注意，<code class="language-plaintext highlighter-rouge">document.writeln()</code> 添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入 <code class="language-plaintext highlighter-rouge">&lt;br&gt;</code>。</p> <h4 id="33-documentqueryselectordocumentqueryselectorall">3.3 document.querySelector()，document.querySelectorAll()</h4> <p><code class="language-plaintext highlighter-rouge">document.querySelector(selectors)</code> 接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回<strong>第一个</strong>匹配的节点。 <code class="language-plaintext highlighter-rouge">document.querySelectorAll(selectors)</code> 与 <code class="language-plaintext highlighter-rouge">querySelector()</code> 用法类似，区别是返回一个 <code class="language-plaintext highlighter-rouge">NodeList</code> 对象，包含所有匹配给定选择器的节点。</p> <p>这两个方法不支持 CSS 伪元素的选择器（比如 <code class="language-plaintext highlighter-rouge">:first-line</code> 和 <code class="language-plaintext highlighter-rouge">:first-letter</code>）和伪类的选择器（比如 <code class="language-plaintext highlighter-rouge">:link</code> 和 <code class="language-plaintext highlighter-rouge">:visited</code>），即无法选中伪元素和伪类。</p> <p>这两个方法都可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</p> <h4 id="34-documentgetelementbyiddocumentgetelementsbytagnamedocumentgetelementsbyclassnamedocumentgetelementsbyname">3.4 document.getElementById()，document.getElementsByTagName()，document.getElementsByClassName()，document.getElementsByName()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">document.getElementById(id)</code> 返回匹配指定 <code class="language-plaintext highlighter-rouge">id</code> 属性的元素节点。该方法的参数大小写敏感且只能在 <code class="language-plaintext highlighter-rouge">document</code> 对象上使用。</li> <li> <code class="language-plaintext highlighter-rouge">document.getElementsByTagName(name)</code> 搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），可以<strong>实时</strong>反映 HTML 文档的变化。该方法可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</li> <li> <code class="language-plaintext highlighter-rouge">document.getElementsByClassName(names)</code> 返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），包括了所有 <code class="language-plaintext highlighter-rouge">class</code> 名字符合指定条件的元素，元素的变化<strong>实时</strong>反映在返回结果中。该方法可以在 <code class="language-plaintext highlighter-rouge">document</code> 对象以及元素节点上调用。</li> <li> <code class="language-plaintext highlighter-rouge">document.getElementsByName(name)</code> 用于选择拥有 <code class="language-plaintext highlighter-rouge">name</code> 属性的 HTML 元素（比如 <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;radio&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;frame&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;object&gt;</code> 等），返回一个类似数组的的对象（<code class="language-plaintext highlighter-rouge">NodeList</code> 实例），因为 <code class="language-plaintext highlighter-rouge">name</code> 属性相同的元素可能不止一个。</li> </ul> <h4 id="35-documentelementfrompointdocumentelementsfrompoint">3.5 document.elementFromPoint()，document.elementsFromPoint()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">document.elementFromPoint()</code> 返回位于页面指定位置<strong>最上层</strong>的元素节点。该方法的两个参数，依次是相对于当前视口<strong>左上角</strong>的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。</li> <li> <code class="language-plaintext highlighter-rouge">document.elementsFromPoint()</code> 返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">elementFromPoint</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
</code></pre></div></div> <p>上面代码选中在 <code class="language-plaintext highlighter-rouge">(50, 50)</code> 这个坐标位置的最上层的那个 HTML 元素。</p> <h4 id="36-documentcreateelementdocumentcreatetextnodedocumentcreateattributedocumentcreatecommentdocumentcreatedocumentfragmentdocumentcreateevent">3.6 document.createElement()，document.createTextNode()，document.createAttribute()，document.createComment()，document.createDocumentFragment()，document.createEvent()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">document.createDocumentFragment()</code> 生成一个空的文档片段对象（<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 实例）。<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</li> <li> <code class="language-plaintext highlighter-rouge">document.createElement(tagName, options)</code> 用来生成元素节点，并返回该节点。参数为元素的标签名（不包含 <code class="language-plaintext highlighter-rouge">&lt;</code> 和 <code class="language-plaintext highlighter-rouge">&gt;</code>，否则会报错）。</li> <li> <code class="language-plaintext highlighter-rouge">document.createAttribute(name)</code> 生成一个新的属性节点（Attr 实例），并返回它。参数是属性的名称。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.createTextNode(data)</code> 用来生成<strong>文本节点</strong>（Text 实例），并返回该节点。它的参数是文本节点的内容。</p> <ul> <li>该方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</li> <li> <p>该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">createTextNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;span&gt;Foo &amp; bar&lt;/span&gt;</span><span class="dl">'</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">)</span>
<span class="c1">// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt;</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">createTextNode()</code> 对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p> </li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">document.createComment(data)</code> 生成一个新的注释节点，并返回该节点。参数是一个字符。</li> <li> <p><code class="language-plaintext highlighter-rouge">document.createEvent(type)</code> 生成一个事件对象（<code class="language-plaintext highlighter-rouge">Event</code> 实例），该对象可以被 <code class="language-plaintext highlighter-rouge">element.dispatchEvent()</code> 方法使用，触发指定事件。</p> <p><code class="language-plaintext highlighter-rouge">document.createEvent()</code> 的参数是事件类型，比如 <code class="language-plaintext highlighter-rouge">UIEvents</code>、<code class="language-plaintext highlighter-rouge">MouseEvents</code>、<code class="language-plaintext highlighter-rouge">MutationEvents</code>、<code class="language-plaintext highlighter-rouge">HTMLEvents</code>。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">Event</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">event</span><span class="p">.</span><span class="nf">initEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">build</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">build</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span> <span class="c1">// "build"</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码新建了一个名为 <code class="language-plaintext highlighter-rouge">build</code> 的事件实例，然后触发该事件。</p> </li> </ul> <h4 id="37-documentaddeventlistenerdocumentremoveeventlistenerdocumentdispatchevent">3.7 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h4> <p>这三个方法用于处理 <code class="language-plaintext highlighter-rouge">document</code> 节点的事件。它们都继承自 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口，详细介绍参见《EventTarget 接口》一章。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 添加事件监听函数</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="c1">// 移除事件监听函数</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="c1">// 触发事件</span>
<span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
</code></pre></div></div> <h4 id="38-documenthasfocus">3.8 document.hasFocus()</h4> <p><code class="language-plaintext highlighter-rouge">document.hasFocus()</code> 返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p> <p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p> <h4 id="39-documentadoptnodedocumentimportnode">3.9 document.adoptNode()，document.importNode()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">document.adoptNode()</code> 将某个节点及其子节点，从原来所在的文档或 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 里面移除，归属当前 <code class="language-plaintext highlighter-rouge">document</code> 对象，返回插入后的新节点。插入的节点对象的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性，会变成当前的 <code class="language-plaintext highlighter-rouge">document</code> 对象，而 <code class="language-plaintext highlighter-rouge">parentNode</code> 属性是 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">adoptNode</span><span class="p">(</span><span class="nx">externalNode</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
</code></pre></div> </div> <p>注意，<code class="language-plaintext highlighter-rouge">document.adoptNode()</code> 只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用 <code class="language-plaintext highlighter-rouge">appendChild()</code> 方法或 <code class="language-plaintext highlighter-rouge">insertBefore()</code> 方法，将新节点插入当前文档树。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">document.importNode()</code> 从原来所在的文档或 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 里面，<strong>拷贝</strong>某个节点及其子节点，让它们归属当前 <code class="language-plaintext highlighter-rouge">document</code> 对象。拷贝的节点对象的 <code class="language-plaintext highlighter-rouge">ownerDocument</code> 属性，会变成当前的 <code class="language-plaintext highlighter-rouge">document</code> 对象，而 <code class="language-plaintext highlighter-rouge">parentNode</code> 属性是 <code class="language-plaintext highlighter-rouge">null</code>。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">importNode</span><span class="p">(</span><span class="nx">externalNode</span><span class="p">,</span> <span class="nx">deep</span><span class="p">);</span>
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">document.importNode()</code> 的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（<code class="language-plaintext highlighter-rouge">false</code>）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">document.importNode()</code> 只是拷贝外部节点，这时该节点的父节点是 <code class="language-plaintext highlighter-rouge">null</code>。下一步还必须将这个节点插入当前文档树。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">iframe</span><span class="dl">'</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">oldNode</span> <span class="o">=</span> <span class="nx">iframe</span><span class="p">.</span><span class="nx">contentWindow</span><span class="p">.</span><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myNode</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">importNode</span><span class="p">(</span><span class="nx">oldNode</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">container</span><span class="dl">"</span><span class="p">).</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
</code></pre></div> </div> <p>上面代码从 <code class="language-plaintext highlighter-rouge">iframe</code> 窗口拷贝一个指定节点 <code class="language-plaintext highlighter-rouge">myNode</code> 插入当前文档。</p> </li> </ul> <h4 id="310-documentcreatenodeiteratordocumentcreatetreewalker">3.10 document.createNodeIterator()，document.createTreeWalker()</h4> <p><code class="language-plaintext highlighter-rouge">document.createNodeIterator(root, whatToShow, filter)</code> 返回一个子节点遍历器。<code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型。几种主要的节点类型写法如下。</p> <ul> <li>所有节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_ALL</code> </li> <li>元素节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_ELEMENT</code> </li> <li>文本节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_TEXT</code> </li> <li>评论节点：<code class="language-plaintext highlighter-rouge">NodeFilter.SHOW_COMMENT</code> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nodeIterator</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createNodeIterator</span><span class="p">(</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
  <span class="nx">NodeFilter</span><span class="p">.</span><span class="nx">SHOW_ELEMENT</span>
<span class="p">);</span>
</code></pre></div></div> <p>上面代码返回 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素子节点的遍历器。</p> <p><code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 返回一个“遍历器”对象（<code class="language-plaintext highlighter-rouge">NodeFilter</code> 实例）。该实例的 <code class="language-plaintext highlighter-rouge">nextNode()</code> 和 <code class="language-plaintext highlighter-rouge">previousNode()</code> 可以用来遍历所有子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nodeIterator</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createNodeIterator</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">pars</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">var</span> <span class="nx">currentNode</span><span class="p">;</span>
<span class="k">while </span><span class="p">(</span><span class="nx">currentNode</span> <span class="o">=</span> <span class="nx">nodeIterator</span><span class="p">.</span><span class="nf">nextNode</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">pars</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">currentNode</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，使用遍历器的 <code class="language-plaintext highlighter-rouge">nextNode()</code> 方法，将根节点的所有子节点，依次读入一个数组。<code class="language-plaintext highlighter-rouge">nextNode()</code> 方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回 <code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">previousNode()</code> 方法则是先将指针移向上一个节点，然后返回该节点。</p> <p>注意，遍历器返回的第一个节点，总是<strong>根节点</strong>。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span> <span class="c1">// true</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">document.createTreeWalker(root, whatToShow, filter)</code> 返回一个 DOM 的子树遍历器。它与 <code class="language-plaintext highlighter-rouge">document.createNodeIterator()</code> 基本类似，区别在于它返回的是 <code class="language-plaintext highlighter-rouge">TreeWalker</code> 实例且第一个节点不是根节点。</p> <h4 id="311-documentexeccommanddocumentquerycommandsupporteddocumentquerycommandenabled">3.11 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()</h4> <h5 id="1documentexeccommand">（1）document.execCommand()</h5> <p>如果 <code class="language-plaintext highlighter-rouge">document.designMode</code> 属性设为 <code class="language-plaintext highlighter-rouge">on</code>，那么整个文档用户可编辑；如果元素的 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性设为 <code class="language-plaintext highlighter-rouge">true</code>，那么该元素可编辑。这两种情况下，可以使用 <code class="language-plaintext highlighter-rouge">document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)</code>，改变内容的样式，比如 <code class="language-plaintext highlighter-rouge">document.execCommand('bold')</code> 会使得字体加粗。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">execCommand</span><span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="nx">showDefaultUI</span><span class="p">,</span> <span class="nx">input</span><span class="p">)</span>
</code></pre></div></div> <p>该方法接受三个参数。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">command</code>：字符串，表示所要实施的样式。</li> <li> <code class="language-plaintext highlighter-rouge">showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为 <code class="language-plaintext highlighter-rouge">false</code>。</li> <li> <code class="language-plaintext highlighter-rouge">input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为 <code class="language-plaintext highlighter-rouge">true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li> </ul> <p><code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的返回值是一个布尔值。如果为 <code class="language-plaintext highlighter-rouge">false</code>，表示这个方法无法生效。</p> <p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p> <h5 id="2documentquerycommandsupported">（2）document.queryCommandSupported()</h5> <p><code class="language-plaintext highlighter-rouge">document.queryCommandSupported(command)</code> 返回一个布尔值，表示浏览器是否支持 <code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的某个命令。</p> <h5 id="3documentquerycommandenabled">（3）document.queryCommandEnabled()</h5> <p><code class="language-plaintext highlighter-rouge">document.queryCommandEnabled(command)</code> 返回一个布尔值，表示当前是否可用 <code class="language-plaintext highlighter-rouge">document.execCommand()</code> 的某个命令。比如，<code class="language-plaintext highlighter-rouge">bold</code>（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;input type="button" value="Copy" onclick="doCopy()"&gt;</span>

<span class="kd">function</span> <span class="nf">doCopy</span><span class="p">(){</span>
  <span class="c1">// 浏览器是否支持 copy 命令（选中内容复制到剪贴板）</span>
  <span class="k">if </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">queryCommandSupported</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
    <span class="nf">copyText</span><span class="p">(</span><span class="dl">'</span><span class="s1">你好</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">浏览器不支持</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">copyText</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">textarea</span><span class="dl">'</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
  <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">text</span><span class="p">;</span>
  <span class="nx">input</span><span class="p">.</span><span class="nf">focus</span><span class="p">();</span>
  <span class="nx">input</span><span class="p">.</span><span class="nf">select</span><span class="p">();</span>

  <span class="c1">// 当前是否有选中文字</span>
  <span class="k">if </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">queryCommandEnabled</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">success</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">execCommand</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">input</span><span class="p">.</span><span class="nf">remove</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Copy Ok</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">queryCommandEnabled is false</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码中，先判断浏览器是否支持 <code class="language-plaintext highlighter-rouge">copy</code> 命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。</p> <h4 id="312-documentgetselection">3.12 document.getSelection()</h4> <p>这个方法指向 <code class="language-plaintext highlighter-rouge">window.getSelection()</code>，参见 <code class="language-plaintext highlighter-rouge">window</code> 对象一节的介绍。</p> <h2 id="六element-节点">六、Element 节点</h2> <h3 id="1-简介">1. 简介</h3> <p><code class="language-plaintext highlighter-rouge">Element</code> 节点对象对应网页的 HTML 元素。每个 HTML 元素，在 DOM 树上都会转化成一个 <code class="language-plaintext highlighter-rouge">Element</code> 节点对象。不同的 HTML 元素对应不同的的元素节点，浏览器使用不同的构造函数，生成不同的元素节点，比如 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 元素的构造函数是<code class="language-plaintext highlighter-rouge">HTMLAnchorElement()</code>，<code class="language-plaintext highlighter-rouge">&lt;button&gt;</code> 是 <code class="language-plaintext highlighter-rouge">HTMLButtonElement()</code>。因此，元素节点不是一种对象，而是许多种对象，这些对象除了继承 <code class="language-plaintext highlighter-rouge">Element</code> 对象的属性和方法，还有各自独有的属性和方法。</p> <h3 id="2-实例属性">2. 实例属性</h3> <h4 id="21-元素特性的相关属性">2.1 元素特性的相关属性</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.id</code>：返回指定元素的 <code class="language-plaintext highlighter-rouge">id</code> 属性，该属性可读写。</li> <li> <code class="language-plaintext highlighter-rouge">Element.tagName</code>：返回指定元素的大写标签名，与 <code class="language-plaintext highlighter-rouge">nodeName</code> 属性的值相等。</li> <li> <code class="language-plaintext highlighter-rouge">Element.dir</code>：用于读写当前元素的文字方向，可能是从左到右（”<code class="language-plaintext highlighter-rouge">ltr</code>“），也可能是从右到左（”<code class="language-plaintext highlighter-rouge">rtl</code>“）。</li> <li> <code class="language-plaintext highlighter-rouge">Element.accessKey</code>：用于读写分配给当前元素的快捷键。</li> <li> <code class="language-plaintext highlighter-rouge">Element.draggable</code>：返回一个布尔值，表示当前元素是否可拖动。该属性<strong>可读写</strong>。</li> <li> <code class="language-plaintext highlighter-rouge">Element.lang</code>：返回当前元素的语言设置。该属性<strong>可读写</strong>。</li> <li> <p><code class="language-plaintext highlighter-rouge">Element.tabIndex</code>：返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性<strong>可读写</strong>。</p> <ul> <li>如果是正整数，则按照顺序，从小到大遍历。</li> <li>如果是负值（通常是 <code class="language-plaintext highlighter-rouge">-1</code>），则 Tab 键不会遍历到该元素。</li> <li>如果两个元素的 <code class="language-plaintext highlighter-rouge">tabIndex</code> 属性的正整数值相同，则按照出现的顺序遍历。</li> <li>遍历完所有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 为正整数的元素以后，再遍历所有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 等于 <code class="language-plaintext highlighter-rouge">0</code>、或者属性值是非法值、或者没有 <code class="language-plaintext highlighter-rouge">tabIndex</code> 属性的元素，顺序为它们在网页中出现的顺序。</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">Element.title</code>：用来读写当前元素的 HTML 属性 <code class="language-plaintext highlighter-rouge">title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</li> </ul> <h4 id="22-元素状态的相关属性">2.2 元素状态的相关属性</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.hidden</code>：返回一个布尔值，表示当前 HTML 元素的 <code class="language-plaintext highlighter-rouge">hidden</code> 属性的值。该属性<strong>可读写</strong>，用来控制当前元素<strong>是否可见</strong>。</p> <ul> <li>该属性与 CSS 设置互相独立。CSS 对当前元素可见性的设置，<code class="language-plaintext highlighter-rouge">Element.hidden</code> 并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</li> <li>CSS 设置的优先级高于 <code class="language-plaintext highlighter-rouge">Element.hidden</code>。如果 CSS 指定了该元素不可见（<code class="language-plaintext highlighter-rouge">display: none</code>）或可见（<code class="language-plaintext highlighter-rouge">visibility: visible</code>），那么 <code class="language-plaintext highlighter-rouge">Element.hidden</code> 并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.contentEditable</code>：返回一个字符串，表示是否设置了 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性，HTML 元素可以设置 <code class="language-plaintext highlighter-rouge">contentEditable</code> 属性，使得元素的内容可以编辑。有三种可能的值。该属性可写。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">"true"</code>：元素内容可编辑；</li> <li> <code class="language-plaintext highlighter-rouge">"false"</code>：元素内容不可编辑；</li> <li> <code class="language-plaintext highlighter-rouge">"inherit"</code>：元素是否可编辑，继承了父元素的设置。</li> </ul> <div class="language-html highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">contenteditable</span><span class="nt">&gt;</span>123<span class="nt">&lt;/div&gt;</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.isContentEditable</code>：返回一个布尔值，同样表示是否设置了 <code class="language-plaintext highlighter-rouge">contenteditable</code> 属性。该属性只读。</p> </li> </ul> <h4 id="23-elementattributes">2.3 Element.attributes</h4> <p><code class="language-plaintext highlighter-rouge">Element.attributes</code> 属性返回一个类似数组的对象，成员是当前元素节点的所有<strong>属性节点</strong>。</p> <h4 id="24-elementclassnameelementclasslist">2.4 Element.className，Element.classList</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">className</code> 属性用来读写当前元素节点的 <code class="language-plaintext highlighter-rouge">class</code> 属性。它的值是一个字符串，每个 <code class="language-plaintext highlighter-rouge">class</code> 之间用空格分割。</li> <li> <code class="language-plaintext highlighter-rouge">classList</code> 属性返回一个类似数组的<strong>对象</strong>，当前元素节点的每个 <code class="language-plaintext highlighter-rouge">class</code> 就是这个对象的一个成员。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码 &lt;div class="one two three" id="myDiv"&gt;&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">className</span>
<span class="c1">// "one two three"</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span>
<span class="c1">// {</span>
<span class="c1">//   0: "one"</span>
<span class="c1">//   1: "two"</span>
<span class="c1">//   2: "three"</span>
<span class="c1">//   length: 3</span>
<span class="c1">// }</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">classList</code> 对象有下列方法。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">add()</code>：增加一个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li> <code class="language-plaintext highlighter-rouge">remove()</code>：移除一个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li> <code class="language-plaintext highlighter-rouge">contains()</code>：检查当前元素是否包含某个 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li> <code class="language-plaintext highlighter-rouge">toggle()</code>：将某个 <code class="language-plaintext highlighter-rouge">class</code> 移入或移出当前元素，该方法可以接受一个布尔值，作为第二个参数。如果为 <code class="language-plaintext highlighter-rouge">true</code>，则添加该属性；如果为 <code class="language-plaintext highlighter-rouge">false</code>，则去除该属性。。</li> <li> <code class="language-plaintext highlighter-rouge">item()</code>：返回指定索引位置的 <code class="language-plaintext highlighter-rouge">class</code>。</li> <li> <code class="language-plaintext highlighter-rouge">toString()</code>：将 <code class="language-plaintext highlighter-rouge">class</code> 的列表转为字符串。</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">toggle</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 如果 myCssClass 不存在就加入，否则移除</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCssClass</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 返回 true 或者 false</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 返回第一个 Class</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">toString</span><span class="p">();</span>
</code></pre></div></div> <h4 id="25-elementdataset">2.5 Element.dataset</h4> <p>网页元素可以自定义 <code class="language-plaintext highlighter-rouge">data-</code> 属性，用来添加数据。<code class="language-plaintext highlighter-rouge">Element.dataset</code> 属性返回一个对象，可以从这个对象读写 <code class="language-plaintext highlighter-rouge">data-</code> 属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &lt;article</span>
<span class="c1">//   id="foo"</span>
<span class="c1">//   data-columns="3"</span>
<span class="c1">//   data-index-number="12314"</span>
<span class="c1">//   data-parent="cars"&gt;</span>
<span class="c1">//   ...</span>
<span class="c1">// &lt;/article&gt;</span>
<span class="kd">var</span> <span class="nx">article</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">columns</span> <span class="c1">// "3"</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">indexNumber</span> <span class="c1">// "12314"</span>
<span class="nx">article</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">parent</span> <span class="c1">// "cars"</span>
</code></pre></div></div> <p>HTML 代码中，<code class="language-plaintext highlighter-rouge">data-</code> 属性的属性名，只能包含英文字母、数字、连词线（<code class="language-plaintext highlighter-rouge">-</code>）、点（<code class="language-plaintext highlighter-rouge">.</code>）、冒号（<code class="language-plaintext highlighter-rouge">:</code>）和下划线（<code class="language-plaintext highlighter-rouge">_</code>）。它们转成 JavaScript 对应的 <code class="language-plaintext highlighter-rouge">dataset</code> 属性名，规则如下。</p> <ul> <li>开头的 <code class="language-plaintext highlighter-rouge">data-</code> 会省略。</li> <li>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</li> <li>其他字符不变。</li> </ul> <p>因此，<code class="language-plaintext highlighter-rouge">data-abc-def</code> 对应 <code class="language-plaintext highlighter-rouge">dataset.abcDef</code>，<code class="language-plaintext highlighter-rouge">data-abc-1</code> 对应 <code class="language-plaintext highlighter-rouge">dataset["abc-1"]</code>。</p> <p>除了使用 <code class="language-plaintext highlighter-rouge">dataset</code> 读写 <code class="language-plaintext highlighter-rouge">data-</code> 属性，也可以使用 <code class="language-plaintext highlighter-rouge">Element.getAttribute()</code> 和 <code class="language-plaintext highlighter-rouge">Element.setAttribute()</code>，通过完整的属性名读写这些属性。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mydiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">mydiv</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">mydiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">mydiv</span><span class="p">.</span><span class="nf">getAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">data-foo</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "bar"</span>
</code></pre></div></div> <h4 id="26-elementinnerhtmelementouterhtml">2.6 Element.innerHTM，Element.outerHTML</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.innerHTML</code> 属性返回一个字符串，表示该元素<strong>包含的</strong>所有 HTML 代码。该属性<strong>可读写</strong>，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括 <code class="language-plaintext highlighter-rouge">&lt;HTML&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 元素。</p> <ul> <li>如果将 <code class="language-plaintext highlighter-rouge">innerHTML</code> 属性设为空，等于删除所有它包含的所有节点。</li> <li>读取属性值的时候，如果文本节点包含 <code class="language-plaintext highlighter-rouge">&amp;</code>、小于号（<code class="language-plaintext highlighter-rouge">&lt;</code>）和大于号（<code class="language-plaintext highlighter-rouge">&gt;</code>），<code class="language-plaintext highlighter-rouge">innerHTML</code> 属性会将它们转为实体形式 <code class="language-plaintext highlighter-rouge">&amp;amp;</code>、<code class="language-plaintext highlighter-rouge">&amp;lt;</code>、<code class="language-plaintext highlighter-rouge">&amp;gt;</code>。</li> <li>如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签，虽然可以生成 <code class="language-plaintext highlighter-rouge">script</code> 节点，但是插入的代码不会执行。</li> <li>如果想得到原文，或者为了安全考虑，如果插入的是文本，最好用 <code class="language-plaintext highlighter-rouge">Element.textContent</code> 属性代替 <code class="language-plaintext highlighter-rouge">innerHTML</code>。</li> </ul> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// HTML代码如下 &lt;p id="para"&gt; 5 &gt; 3 &lt;/p&gt;</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span>
<span class="c1">// 5 &amp;gt; 3</span>
</code></pre></div> </div> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.outerHTML</code> 属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括<strong>该元素</strong>本身和<strong>所有子元素</strong>，该属性<strong>可读写</strong>。如果一个节点没有父节点，设置 <code class="language-plaintext highlighter-rouge">outerHTML</code> 属性会报错。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d</span><span class="p">.</span><span class="nx">outerHTML</span>
<span class="c1">// '&lt;div id="d"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;'</span>
</code></pre></div> </div> </li> </ul> <h4 id="27-elementclientwidthelementclientheightelementclientleftelementclienttop">2.7 Element.clientWidth，Element.clientHeight，Element.clientLeft，Element.clientTop</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.clientWidth</code> 属性返回元素节点的 <strong>CSS 宽度</strong>（单位像素），只对<strong>块级元素</strong>有效，包括元素本身的宽度和 <code class="language-plaintext highlighter-rouge">padding</code>（不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code>），如果有垂直滚动条，还要减去垂直滚动条的宽度。</li> <li> <p><code class="language-plaintext highlighter-rouge">Element.clientHeight</code> 属性返回元素节点的 <strong>CSS 高度</strong>（单位像素），只对<strong>块级元素</strong>生效，包括元素本身的高度和 <code class="language-plaintext highlighter-rouge">padding</code>（不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code>），对于行内元素返回 <code class="language-plaintext highlighter-rouge">0</code>。如果块级元素没有设置 CSS 高度，则返回实际高度。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">document.documentElement</code> 的 <code class="language-plaintext highlighter-rouge">clientHeight</code> 属性，返回当前<strong>视口</strong>的高度（即浏览器窗口的高度），等同于 <code class="language-plaintext highlighter-rouge">window.innerHeight</code> 属性减去水平滚动条的高度（如果有的话）。</li> <li> <code class="language-plaintext highlighter-rouge">document.body</code> 的高度返回<strong>网页</strong>的<strong>实际高度</strong>。</li> </ul> <p>一般来说，<code class="language-plaintext highlighter-rouge">document.body.clientHeight</code> 大于 <code class="language-plaintext highlighter-rouge">document.documentElement.clientHeight</code>。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">clientHeight</span> <span class="c1">// 视口高度</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">clientHeight</span> <span class="c1">// 网页总高度</span>
</code></pre></div> </div> </li> <li> <code class="language-plaintext highlighter-rouge">Element.clientLeft</code> 属性等于元素节点<strong>左边框</strong>（left border）的<strong>宽度</strong>（单位像素），不包括左侧的 <code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">margin</code>。如果没有设置左边框，或者是行内元素（<code class="language-plaintext highlighter-rouge">display: inline</code>），该属性返回 <code class="language-plaintext highlighter-rouge">0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</li> <li> <code class="language-plaintext highlighter-rouge">Element.clientTop</code> 属性等于网页元素<strong>顶部边框</strong>的<strong>宽度</strong>（单位像素），其他特点都与 <code class="language-plaintext highlighter-rouge">clientLeft</code> 相同。</li> </ul> <h4 id="28-elementscrollwidthelementscrollheightelementscrollleftelementscrolltop">2.8 Element.scrollWidth，Element.scrollHeight，Element.scrollLeft，Element.scrollTop</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.scrollWidth</code> 和 <code class="language-plaintext highlighter-rouge">Element.scrollHeight</code> 属性返回一个整数值（小数会四舍五入），表示当前元素的总宽度和总高度（单位像素）。</p> <p>整张网页的总高度可以从 <code class="language-plaintext highlighter-rouge">document.documentElement</code> 或 <code class="language-plaintext highlighter-rouge">document.body</code> 上读取。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// 返回网页的总高度</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollHeight</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">scrollHeight</span>
</code></pre></div> </div> </li> </ul> <p>这两个属性都包括溢出容器部分、当前不可见的部分、<code class="language-plaintext highlighter-rouge">padding</code> 和伪元素（<code class="language-plaintext highlighter-rouge">::before</code> 或 <code class="language-plaintext highlighter-rouge">::after</code>）的高度，但是不包括 <code class="language-plaintext highlighter-rouge">border</code>、<code class="language-plaintext highlighter-rouge">margin</code> 以及水平滚动条的高度（如果有水平滚动条的话）。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.scrollLeft</code> 属性表示当前元素的水平滚动条向右侧滚动的像素数量。</li> <li> <code class="language-plaintext highlighter-rouge">Element.scrollTop</code> 属性表示当前元素的垂直滚动条向下滚动的像素数量。</li> </ul> <p>如果要查看整张网页的水平的和垂直的滚动距离，要从 <code class="language-plaintext highlighter-rouge">document.documentElement</code> 元素上读取。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollLeft</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollTop</span>
</code></pre></div></div> <h4 id="29-elementoffsetwidthelementoffsetheightelementoffsetleftelementoffsettopelementoffsetparent">2.9 Element.offsetWidth，Element.offsetHeight，Element.offsetLeft，Element.offsetTop，Element.offsetParent</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.offsetWidth</code> 属性表示元素的 CSS <strong>水平宽度</strong>（单位像素），包括元素本身的宽度、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>，以及垂直滚动条的宽度（如果存在滚动条）。</li> <li> <code class="language-plaintext highlighter-rouge">Element.offsetHeight</code> 属性表示元素的 CSS <strong>垂直高度</strong>（单位像素），包括元素本身的高度、<code class="language-plaintext highlighter-rouge">padding</code> 和 <code class="language-plaintext highlighter-rouge">border</code>，以及水平滚动条的高度（如果存在滚动条）。</li> </ul> <p>这两个属性都是<strong>只读</strong>属性，只比 <code class="language-plaintext highlighter-rouge">Element.clientHeight</code> 和 <code class="language-plaintext highlighter-rouge">Element.clientWidth</code> 多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如 <code class="language-plaintext highlighter-rouge">display: none;</code>），则返回 <code class="language-plaintext highlighter-rouge">0</code>。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.offsetParent</code> 属性返回最靠近当前元素的、并且 CSS 的 <code class="language-plaintext highlighter-rouge">position</code> 属性不等于 <code class="language-plaintext highlighter-rouge">static</code> 的上层元素。</p> <div class="language-html highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">"position: absolute;"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p&gt;</span>
    <span class="nt">&lt;span&gt;</span>Hello<span class="nt">&lt;/span&gt;</span>
  <span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div> </div> <p>上面代码中，<code class="language-plaintext highlighter-rouge">span</code> 元素的 <code class="language-plaintext highlighter-rouge">offsetParent</code> 属性是 <code class="language-plaintext highlighter-rouge">div</code> 元素。</p> </li> <li> <code class="language-plaintext highlighter-rouge">Element.offsetLeft</code> 返回当前元素左上角相对于 <code class="language-plaintext highlighter-rouge">Element.offsetParent</code> 节点的水平位移。</li> <li> <code class="language-plaintext highlighter-rouge">Element.offsetTop</code> 返回垂直位移，单位为像素。</li> </ul> <p>通常，<code class="language-plaintext highlighter-rouge">Element.offsetLeft</code> 和 <code class="language-plaintext highlighter-rouge">Element.offsetTop</code> 是指相对于父节点的位移。</p> <h4 id="210-elementstyle">2.10 Element.style</h4> <p><code class="language-plaintext highlighter-rouge">style</code> 属性用来读写该元素的行内样式信息。</p> <h4 id="211-elementchildrenelementchildelementcountelementfirstelementchildelementlastelementchild">2.11 Element.children，Element.childElementCount，Element.firstElementChild，Element.lastElementChild</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.children</code> 属性返回一个类似数组的对象（<code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例），包括当前<strong>元素节点</strong>的所有子元素。</li> <li> <code class="language-plaintext highlighter-rouge">Element.childElementCount</code> 属性返回当前元素节点包含的子元素节点的个数，与 <code class="language-plaintext highlighter-rouge">Element.children.length</code> 的值相同。</li> <li> <code class="language-plaintext highlighter-rouge">Element.firstElementChild</code> 属性返回当前元素的第一个元素子节点。</li> <li> <code class="language-plaintext highlighter-rouge">Element.lastElementChild</code> 属性返回当前元素的最后一个元素子节点。</li> </ul> <h4 id="212-elementnextelementsiblingelementpreviouselementsibling">2.12 Element.nextElementSibling，Element.previousElementSibling</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.previousElementSibling</code> 属性返回当前元素节点的前一个同级元素节点。</li> <li> <code class="language-plaintext highlighter-rouge">Element.nextElementSibling</code> 属性返回当前元素节点的后一个同级元素节点。</li> </ul> <h3 id="3-实例方法">3. 实例方法</h3> <h4 id="31-属性相关方法">3.1 属性相关方法</h4> <p>元素节点提供六个方法，用来操作属性。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">getAttribute()</code>：读取某个属性的值。</li> <li> <code class="language-plaintext highlighter-rouge">getAttributeNames()</code>：返回当前元素的所有属性名。</li> <li> <code class="language-plaintext highlighter-rouge">setAttribute()</code>：写入属性值。</li> <li> <code class="language-plaintext highlighter-rouge">hasAttribute()</code>：某个属性是否存在。</li> <li> <code class="language-plaintext highlighter-rouge">hasAttributes()</code>：当前元素是否有属性。</li> <li> <code class="language-plaintext highlighter-rouge">removeAttribute()</code>：删除属性。</li> </ul> <h4 id="31-elementqueryselectorelementqueryselectorall">3.1 Element.querySelector()，Element.querySelectorAll()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.querySelector(selectors)</code> 接受 CSS 选择器作为参数（多个选择器之间用逗号分隔），返回父元素的<strong>第一个</strong>匹配的子元素。该方法可以接受复杂的 CSS 选择器。</p> <p>浏览器执行 <code class="language-plaintext highlighter-rouge">querySelector()</code> 时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码</span>
<span class="c1">// &lt;div&gt;</span>
<span class="c1">// &lt;blockquote id="outer"&gt;</span>
<span class="c1">//   &lt;p&gt;Hello&lt;/p&gt;</span>
<span class="c1">//   &lt;div id="inner"&gt;</span>
<span class="c1">//     &lt;p&gt;World&lt;/p&gt;</span>
<span class="c1">//   &lt;/div&gt;</span>
<span class="c1">// &lt;/blockquote&gt;</span>
<span class="c1">// &lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">outer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">outer</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">outer</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div p</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// &lt;p&gt;Hello&lt;/p&gt;</span>
</code></pre></div> </div> <p>上面代码实际上返回的是第一个 <code class="language-plaintext highlighter-rouge">p</code> 元素，而不是第二个。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.querySelectorAll(selectors)</code> 接受 CSS 选择器作为参数多个选择器之间用逗号分隔），返回一个 <code class="language-plaintext highlighter-rouge">NodeList</code> 实例，包含所有匹配的子元素。该方法的执行机制与 <code class="language-plaintext highlighter-rouge">querySelector</code> 方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。</p> </li> </ul> <h4 id="32-elementgetelementsbyclassnameelementgetelementsbytagname">3.2 Element.getElementsByClassName()，Element.getElementsByTagName()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.getElementsByClassName(names)</code> 返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是<strong>当前节点</strong>的所有具有指定 <code class="language-plaintext highlighter-rouge">class</code> 的子元素节点。</li> <li> <code class="language-plaintext highlighter-rouge">Element.getElementsByTagName(tagName)</code> 返回一个 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 实例，成员是<strong>当前节点</strong>的所有匹配指定标签名的子元素节点。</li> </ul> <p>这两个方法与 <code class="language-plaintext highlighter-rouge">document.getElementsByClassName()</code> 的用法类似，只是搜索范围不是整个文档，而是<strong>当前</strong>元素节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nf">getElementsByClassName</span><span class="p">(</span><span class="dl">'</span><span class="s1">red test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">table</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">td</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <h4 id="33-elementclosest">3.3 Element.closest()</h4> <p><code class="language-plaintext highlighter-rouge">Element.closest(selectors)</code> 方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个<strong>祖先节点</strong>（包括当前节点本身）。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;article&gt;</span>
<span class="c1">//   &lt;div id="div-01"&gt;Here is div-01</span>
<span class="c1">//     &lt;div id="div-02"&gt;Here is div-02</span>
<span class="c1">//       &lt;div id="div-03"&gt;Here is div-03&lt;/div&gt;</span>
<span class="c1">//     &lt;/div&gt;</span>
<span class="c1">//   &lt;/div&gt;</span>
<span class="c1">// &lt;/article&gt;</span>
<span class="kd">var</span> <span class="nx">div03</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">div-03</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// div-03 最近的祖先节点</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">#div-02</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// div-02</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">div div</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// div-03</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">article &gt; div</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//div-01</span>
<span class="nx">div03</span><span class="p">.</span><span class="nf">closest</span><span class="p">(</span><span class="dl">"</span><span class="s2">:not(div)</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// article</span>
</code></pre></div></div> <p>上面代码中，由于 <code class="language-plaintext highlighter-rouge">closest()</code> 将当前节点也考虑在内，所以第二个 <code class="language-plaintext highlighter-rouge">closest()</code> 方法返回 <code class="language-plaintext highlighter-rouge">div-03</code>。</p> <h4 id="34-elementmatches">3.4 Element.matches()</h4> <p><code class="language-plaintext highlighter-rouge">Element.matches(selectors)</code> 返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p> <h4 id="35-事件相关方法">3.5 事件相关方法</h4> <p>以下三个方法与 <code class="language-plaintext highlighter-rouge">Element</code> 节点的事件相关。这些方法都继承自 <code class="language-plaintext highlighter-rouge">EventTarget</code> 接口，详见相关章节。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.addEventListener()</code>：添加事件的回调函数</li> <li> <code class="language-plaintext highlighter-rouge">Element.removeEventListener()</code>：移除事件监听函数</li> <li> <code class="language-plaintext highlighter-rouge">Element.dispatchEvent()</code>：触发事件</li> </ul> <h4 id="36-elementscrollintoview">3.6 Element.scrollIntoView()</h4> <p><code class="language-plaintext highlighter-rouge">Element.scrollIntoView(alignToTop | options)</code> 滚动当前元素，进入浏览器的可见区域，类似于设置 <code class="language-plaintext highlighter-rouge">window.location.hash</code> 的效果。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nf">scrollIntoView</span><span class="p">();</span> <span class="c1">// 等同于 el.scrollIntoView(true)</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">scrollIntoView</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p>该方法可以接受一个布尔值作为参数。如果为 <code class="language-plaintext highlighter-rouge">true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为 <code class="language-plaintext highlighter-rouge">false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为 <code class="language-plaintext highlighter-rouge">true</code>。</p> <h4 id="37-elementgetboundingclientrectelementgetclientrects">3.7 Element.getBoundingClientRect()，Element.getClientRects()</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 返回一个 <code class="language-plaintext highlighter-rouge">rect</code> 对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。该对象具有以下属性（全部为只读）。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">x</code>：元素左上角相对于视口的横坐标</li> <li> <code class="language-plaintext highlighter-rouge">y</code>：元素左上角相对于视口的纵坐标</li> <li> <code class="language-plaintext highlighter-rouge">left</code>：元素左上角相对于视口的横坐标，与 <code class="language-plaintext highlighter-rouge">x</code> 属性相等</li> <li> <code class="language-plaintext highlighter-rouge">right</code>：元素右边界相对于视口的横坐标（等于 <code class="language-plaintext highlighter-rouge">x + width</code>）</li> <li> <code class="language-plaintext highlighter-rouge">top</code>：元素顶部相对于视口的纵坐标，与 <code class="language-plaintext highlighter-rouge">y</code> 属性相等</li> <li> <code class="language-plaintext highlighter-rouge">bottom</code>：元素底部相对于视口的纵坐标（等于 <code class="language-plaintext highlighter-rouge">y + height</code>）</li> <li> <code class="language-plaintext highlighter-rouge">width</code>：元素宽度</li> <li> <code class="language-plaintext highlighter-rouge">height</code>：元素高度</li> </ul> <p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将 <code class="language-plaintext highlighter-rouge">left</code> 属性加上 <code class="language-plaintext highlighter-rouge">window.scrollX</code>，<code class="language-plaintext highlighter-rouge">top</code> 属性加上 <code class="language-plaintext highlighter-rouge">window.scrollY</code>。</p> <p>注意，<code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 的所有属性，都把边框（<code class="language-plaintext highlighter-rouge">border</code> 属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，<code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code> 包括了元素本身 + <code class="language-plaintext highlighter-rouge">padding</code> + <code class="language-plaintext highlighter-rouge">border</code>。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Element.getClientRects()</code> 返回一个类似数组的<strong>对象</strong>，里面是当前元素在页面上形成的所有<strong>矩形</strong>（所以方法名中的 Rect 用的是复数）。每个矩形都有 <code class="language-plaintext highlighter-rouge">top</code>、<code class="language-plaintext highlighter-rouge">bottom</code>、<code class="language-plaintext highlighter-rouge">left</code>、<code class="language-plaintext highlighter-rouge">right</code>、<code class="language-plaintext highlighter-rouge">width</code> 和 <code class="language-plaintext highlighter-rouge">height</code> 六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p> <p>对于盒状元素（比如 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;em&gt;</code>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和 <code class="language-plaintext highlighter-rouge">Element.getBoundingClientRect()</code> 的主要区别，后者对于行内元素总是返回一个矩形。</p> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">inline</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">().</span><span class="nx">length</span> <span class="c1">// 3</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">left</span> <span class="c1">// 8</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">right</span> <span class="c1">// 113.908203125</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">bottom</span> <span class="c1">// 31.200000762939453</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">height</span> <span class="c1">// 23.200000762939453</span>
<span class="nx">el</span><span class="p">.</span><span class="nf">getClientRects</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="nx">width</span> <span class="c1">// 105.908203125</span>
</code></pre></div></div> <p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p> <h4 id="38-elementinsertadjacentelementelementinsertadjacenthtmlelementinsertadjacenttext">3.8 Element.insertAdjacentElement()，Element.insertAdjacentHTML()，Element.insertAdjacentText()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.insertAdjacentElement(position, element)</code> 在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点。</li> <li> <code class="language-plaintext highlighter-rouge">Element.insertAdjacentHTML(position, text)</code> 用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</li> <li> <code class="language-plaintext highlighter-rouge">Element.insertAdjacentText(where, data)</code> 在相对于当前节点的指定位置，插入一个文本节点。</li> </ul> <p>这三个方法都可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点/待解析的 HTML 字符串/将要插入的文本内容。第一个参数只可以取如下的值。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">beforebegin</code>：当前元素之前</li> <li> <code class="language-plaintext highlighter-rouge">afterbegin</code>：当前元素内部的第一个子节点前面</li> <li> <code class="language-plaintext highlighter-rouge">beforeend</code>：当前元素内部的最后一个子节点后面</li> <li> <code class="language-plaintext highlighter-rouge">afterend</code>：当前元素之后</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码：&lt;div id="one"&gt;one&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">one</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">d1</span><span class="p">.</span><span class="nf">insertAdjacentHTML</span><span class="p">(</span><span class="dl">'</span><span class="s1">afterend</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&lt;div id="two"&gt;two&lt;/div&gt;</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 执行后的 HTML 代码：</span>
<span class="c1">// &lt;div id="one"&gt;one&lt;/div&gt;&lt;div id="two"&gt;two&lt;/div&gt;</span>
</code></pre></div></div> <h4 id="39-elementremove">3.9 Element.remove()</h4> <p><code class="language-plaintext highlighter-rouge">Element.remove()</code> 继承自 <code class="language-plaintext highlighter-rouge">ChildNode</code> 接口，用于将当前元素节点从它的父节点移除。</p> <h4 id="310-elementfocuselementblur">3.10 Element.focus()，Element.blur()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.focus()</code> 用于将当前页面的焦点，转移到指定元素上。<code class="language-plaintext highlighter-rouge">document.activeElement</code> 属性可以得到当前获得焦点的元素。</li> <li> <code class="language-plaintext highlighter-rouge">Element.blur()</code> 用于将焦点从指定元素移除。</li> </ul> <p><code class="language-plaintext highlighter-rouge">Element.focus()</code> 可以接受一个对象作为参数。参数对象的 <code class="language-plaintext highlighter-rouge">preventScroll</code> 属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getFocus</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">btn</span><span class="dl">'</span><span class="p">).</span><span class="nf">focus</span><span class="p">({</span> <span class="na">preventScroll</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面代码会让 <code class="language-plaintext highlighter-rouge">btn</code> 元素获得焦点，并滚动到可见区域。</p> <h4 id="311-elementclick">3.11 Element.click()</h4> <p><code class="language-plaintext highlighter-rouge">Element.click()</code> 用于在当前元素上模拟一次鼠标点击，相当于触发了 <code class="language-plaintext highlighter-rouge">click</code> 事件。</p> <h2 id="七属性的操作">七、属性的操作</h2> <h3 id="1-elementattributes-属性">1. Element.attributes 属性</h3> <p><code class="language-plaintext highlighter-rouge">attributes</code> 属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的<strong>实时</strong>变化都会反映在这个节点对象上。</p> <h3 id="2-元素的标准属性">2. 元素的标准属性</h3> <p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。这些属性都是可写的。</p> <p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如 <code class="language-plaintext highlighter-rouge">onClick</code>。</p> <h3 id="3-属性操作的标准方法">3. 属性操作的标准方法</h3> <h4 id="31-概述">3.1 概述</h4> <p>元素节点提供六个方法，用来操作属性。</p> <ul> <li><code class="language-plaintext highlighter-rouge">getAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">getAttributeNames()</code></li> <li><code class="language-plaintext highlighter-rouge">setAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">hasAttribute()</code></li> <li><code class="language-plaintext highlighter-rouge">hasAttributes()</code></li> <li><code class="language-plaintext highlighter-rouge">removeAttribute()</code></li> </ul> <h4 id="32-elementgetattribute">3.2 Element.getAttribute()</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">Element.getAttribute(property)</code> 方法返回当前元素节点的指定属性。</li> <li> <code class="language-plaintext highlighter-rouge">Element.getAttributeNames()</code> 返回一个数组，成员是当前元素的所有属性的名字。</li> <li> <code class="language-plaintext highlighter-rouge">Element.setAttribute(property, value)</code> 方法用于为当前元素节点新增属性。</li> <li> <code class="language-plaintext highlighter-rouge">Element.hasAttribute(property)</code> 方法返回一个布尔值，表示当前元素节点是否包含指定属性。</li> <li> <code class="language-plaintext highlighter-rouge">Element.hasAttributes()</code> 方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回 <code class="language-plaintext highlighter-rouge">false</code>，否则返回 <code class="language-plaintext highlighter-rouge">true</code>。</li> <li> <code class="language-plaintext highlighter-rouge">Element.removeAttribute(property)</code> 方法移除指定属性。该方法没有返回值。</li> </ul> <h3 id="4-dataset-属性">4. dataset 属性</h3> <p>参考 <a href="#25-elementdataset">Element.dataset</a>。</p> <h2 id="八text-节点和-documentfragment-节点">八、Text 节点和 DocumentFragment 节点</h2> <h3 id="1-text-节点的概念">1. Text 节点的概念</h3> <p>文本节点（<code class="language-plaintext highlighter-rouge">Text</code>）代表元素节点（<code class="language-plaintext highlighter-rouge">Element</code>）和属性节点（<code class="language-plaintext highlighter-rouge">Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p> <p>通常我们使用父节点的 <code class="language-plaintext highlighter-rouge">firstChild</code>、<code class="language-plaintext highlighter-rouge">nextSibling</code> 等属性获取文本节点，或者使用 <code class="language-plaintext highlighter-rouge">Document</code> 节点的 <code class="language-plaintext highlighter-rouge">createTextNode()</code> 创造一个文本节点。</p> <p>浏览器原生提供一个 <code class="language-plaintext highlighter-rouge">Text</code> 构造函数。它返回一个文本节点实例，参数是该文本节点的文本内容。</p> <p>文本节点除了继承 <code class="language-plaintext highlighter-rouge">Node</code> 接口，还继承了 <code class="language-plaintext highlighter-rouge">CharacterData</code> 接口。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">text1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Text</span><span class="p">();</span> <span class="c1">// 空字符串</span>
<span class="kd">var</span> <span class="nx">text2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Text</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is a text node</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 非空字符串</span>
</code></pre></div></div> <p>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code class="language-plaintext highlighter-rouge">&lt;p&gt; &lt;/p&gt;</code>包含一个空格，它的子节点就是一个文本节点。</p> <h3 id="2-text-节点的属性">2. Text 节点的属性</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">data</code> 属性等同于 <code class="language-plaintext highlighter-rouge">nodeValue</code> 属性，用来设置或读取文本节点的内容。</li> <li> <code class="language-plaintext highlighter-rouge">length</code> 属性返回当前文本节点的文本长度。</li> <li> <code class="language-plaintext highlighter-rouge">previousElementSibling</code> 属性返回当前文本节点前面最近的同级元素节点。</li> <li> <code class="language-plaintext highlighter-rouge">nextElementSibling</code> 属性返回紧跟在当前文本节点后面的那个同级元素节点。</li> <li> <p><code class="language-plaintext highlighter-rouge">wholeText</code> 属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，<code class="language-plaintext highlighter-rouge">wholeText</code> 属性的返回值，与 <code class="language-plaintext highlighter-rouge">data</code> 属性和 <code class="language-plaintext highlighter-rouge">textContent</code> 属性相同。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// &lt;p id="para"&gt;A &lt;em&gt;B&lt;/em&gt; C&lt;/p&gt;</span>
<span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">wholeText</span> <span class="c1">// "A "</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">data</span> <span class="c1">// "A "</span>
</code></pre></div> </div> <p>但是，一旦移除 <code class="language-plaintext highlighter-rouge">&lt;em&gt;</code> 节点，<code class="language-plaintext highlighter-rouge">wholeText</code> 属性与 <code class="language-plaintext highlighter-rouge">data</code> 属性就会有差异，因为这时其实 <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 节点下面包含了两个毗邻的文本节点。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">para</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">wholeText</span> <span class="c1">// "A C"</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">data</span> <span class="c1">// "A "</span>
</code></pre></div> </div> </li> </ul> <h3 id="3-text-节点的方法">3. Text 节点的方法</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">appendData(str)</code>：在 <code class="language-plaintext highlighter-rouge">Text</code> 节点尾部追加字符串。</li> <li> <code class="language-plaintext highlighter-rouge">deleteData(startIndex, str)</code>：删除 <code class="language-plaintext highlighter-rouge">Text</code> 节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li> <li> <code class="language-plaintext highlighter-rouge">insertData(index, str)</code>：在 <code class="language-plaintext highlighter-rouge">Text</code> 节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</li> <li> <code class="language-plaintext highlighter-rouge">replaceData(startIndex, replacedStr, str)</code>：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li> <li> <p><code class="language-plaintext highlighter-rouge">subStringData(startIndex, length)</code>：用于获取子字符串，第一个参数为子字符串在 <code class="language-plaintext highlighter-rouge">Text</code> 节点中的开始位置，第二个参数为子字符串长度。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">remove()</code> 方法用于移除当前 <code class="language-plaintext highlighter-rouge">Text</code> 节点。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">splitText(offset)</code> 方法将 <code class="language-plaintext highlighter-rouge">Text</code> 节点一分为二，变成两个毗邻的 <code class="language-plaintext highlighter-rouge">Text</code> 节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。分割后，该方法返回分割位置后方的字符串，而原 <code class="language-plaintext highlighter-rouge">Text</code> 节点变成只包含分割位置前方的字符串。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// html 代码为 &lt;p id="p"&gt;foobar&lt;/p&gt;</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">textnode</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">newText</span> <span class="o">=</span> <span class="nx">textnode</span><span class="p">.</span><span class="nf">splitText</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">newText</span> <span class="c1">// "bar"</span>
<span class="nx">textnode</span> <span class="c1">// "foo"</span>
</code></pre></div> </div> <p>父元素节点的 <code class="language-plaintext highlighter-rouge">normalize()</code> 方法可以将毗邻的两个 <code class="language-plaintext highlighter-rouge">Text</code> 节点合并。</p> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nx">p</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="c1">// 将毗邻的两个 Text 节点合并</span>
<span class="nx">p</span><span class="p">.</span><span class="nf">normalize</span><span class="p">();</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1</span>
</code></pre></div> </div> </li> </ul> <h3 id="4-documentfragment-节点">4. DocumentFragment 节点</h3> <p><code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，<code class="language-plaintext highlighter-rouge">parentNode</code> 返回 <code class="language-plaintext highlighter-rouge">null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点，要比直接操作 DOM 树快得多。</p> <p>它一般用于构建一个 DOM 结构，然后插入当前文档。<code class="language-plaintext highlighter-rouge">document.createDocumentFragment()</code>，以及浏览器原生的 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 构造函数，可以创建一个空的 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点。然后再使用其他 DOM 方法，向其添加子节点。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">docFrag</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createDocumentFragment</span><span class="p">();</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">docFrag</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DocumentFragment</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">li</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">li</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">li</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello World</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">docFrag</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">li</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">).</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">docFrag</span><span class="p">);</span>
</code></pre></div></div> <p>注意，<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点<strong>本身不能被插入当前文档</strong>。当它作为 <code class="language-plaintext highlighter-rouge">appendChild()</code>、<code class="language-plaintext highlighter-rouge">insertBefore()</code>、<code class="language-plaintext highlighter-rouge">replaceChild()</code> 等方法的参数时，是它的所有<strong>子节点</strong>插入当前文档，而不是它自身。一旦 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点被添加进当前文档，它自身就变成了空节点（<code class="language-plaintext highlighter-rouge">textContent</code> 属性为空字符串），可以被再次使用。如果想要保存 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点的内容，可以使用 <code class="language-plaintext highlighter-rouge">cloneNode</code> 方法。</p> <p><code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点对象没有自己的属性和方法，全部继承自 <code class="language-plaintext highlighter-rouge">Node</code> 节点和 <code class="language-plaintext highlighter-rouge">ParentNode</code> 接口。也就是说，<code class="language-plaintext highlighter-rouge">DocumentFragment</code> 节点比 <code class="language-plaintext highlighter-rouge">Node</code> 节点多出以下四个属性。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">children</code>：返回一个动态的 <code class="language-plaintext highlighter-rouge">HTMLCollection</code> 集合对象，包括当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的所有子元素节点。</li> <li> <code class="language-plaintext highlighter-rouge">firstElementChild</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的第一个子元素节点。</li> <li> <code class="language-plaintext highlighter-rouge">lastElementChild</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的最后一个子元素节点。</li> <li> <code class="language-plaintext highlighter-rouge">childElementCount</code>：返回当前 <code class="language-plaintext highlighter-rouge">DocumentFragment</code> 对象的所有子元素数量。</li> </ul> <h2 id="九">九、</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h2 id="十mutation-observer-api">十、Mutation Observer API</h2> <h3 id="1-概述-1">1. 概述</h3> <p><strong>Mutation Observer API 用来监视 DOM 变动</strong>。概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是<strong>异步触发</strong>，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</p> <p>Mutation Observer 有以下特点。</p> <ul> <li>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</li> <li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li> <li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li> </ul> <h3 id="2-mutationobserver-构造函数">2. MutationObserver 构造函数</h3> <p>MutationObserver 构造函数会创建一个观察器实例，它接受一个回调函数，回调函数会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">mutations</span><span class="p">,</span> <span class="nx">observer</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mutations</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">mutation</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">mutation</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <h3 id="3-mutationobserver-的实例方法">3. MutationObserver 的实例方法</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">disconnect()</code> 用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。</li> <li> <code class="language-plaintext highlighter-rouge">takeRecords()</code> 用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</li> <li> <p><code class="language-plaintext highlighter-rouge">observe(target[, options])</code> 用来启动监听，它接受两个参数。</p> <ul> <li>第一个参数：所要观察的 DOM 节点</li> <li>第二个参数：一个配置对象，指定所要观察的特定变动</li> </ul> <p>观察器所能观察的 DOM 变动类型（即 <code class="language-plaintext highlighter-rouge">options</code> 配置对象），有以下几种。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">childList</code>：子节点的变动（指新增，删除或者更改）。</li> <li> <code class="language-plaintext highlighter-rouge">attributes</code>：属性的变动。</li> <li> <code class="language-plaintext highlighter-rouge">characterData</code>：节点内容或节点文本的变动。</li> </ul> <p>想要观察哪一种变动类型，就在 <code class="language-plaintext highlighter-rouge">option</code> 对象中指定它的值为 <code class="language-plaintext highlighter-rouge">true</code>。至少必须同时指定这三种观察的一种，若均未指定将报错。</p> <p>除了变动类型，<code class="language-plaintext highlighter-rouge">options</code> 对象还可以设定以下属性：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">subtree</code>：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li> <li> <code class="language-plaintext highlighter-rouge">attributeOldValue</code>：布尔值，表示观察 <code class="language-plaintext highlighter-rouge">attributes</code> 变动时，是否需要记录变动前的属性值。</li> <li> <code class="language-plaintext highlighter-rouge">characterDataOldValue</code>：布尔值，表示观察 <code class="language-plaintext highlighter-rouge">characterData</code> 变动时，是否需要记录变动前的值。</li> <li> <code class="language-plaintext highlighter-rouge">attributeFilter</code>：数组，表示需要观察的特定属性（比如[‘class’,’src’]）。</li> </ul> <div class="language-javascript highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// 开始监听文档根节点（即 &lt;html&gt; 标签）的变动</span>
<span class="nx">mutationObserver</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">attributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">characterData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">attributeOldValue</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">characterDataOldValue</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div> </div> </li> </ul> <h3 id="4-mutationrecord-对象">4. MutationRecord 对象</h3> <p>DOM 每次发生变化，就会生成一条变动记录（<code class="language-plaintext highlighter-rouge">MutationRecord</code> 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个 <code class="language-plaintext highlighter-rouge">MutationRecord</code> 实例所组成的数组。</p> <p><code class="language-plaintext highlighter-rouge">MutationRecord</code> 对象包含了 DOM 的相关信息，有如下属性：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">type</code>：观察的变动类型（<code class="language-plaintext highlighter-rouge">childList</code>、<code class="language-plaintext highlighter-rouge">attributes</code> 或者 <code class="language-plaintext highlighter-rouge">characterData</code>）。</li> <li> <code class="language-plaintext highlighter-rouge">target</code>：发生变动的 DOM 节点。</li> <li> <code class="language-plaintext highlighter-rouge">previousSibling</code>：前一个同级节点，如果没有则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li> <code class="language-plaintext highlighter-rouge">nextSibling</code>：下一个同级节点，如果没有则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li> <code class="language-plaintext highlighter-rouge">attributeName</code>：发生变动的属性。如果设置了 <code class="language-plaintext highlighter-rouge">attributeFilter</code>，则只返回预先指定的属性。</li> <li> <code class="language-plaintext highlighter-rouge">oldValue</code>：变动前的值。这个属性只对 <code class="language-plaintext highlighter-rouge">attribute</code> 和 <code class="language-plaintext highlighter-rouge">characterData</code> 变动有效，如果发生 <code class="language-plaintext highlighter-rouge">childList</code> 变动，则返回 <code class="language-plaintext highlighter-rouge">null</code>。</li> <li> <code class="language-plaintext highlighter-rouge">addedNodes</code>：新增的 DOM 节点。</li> <li> <code class="language-plaintext highlighter-rouge">removedNodes</code>：删除的 DOM 节点。</li> </ul> <h3 id="5-应用示例">5. 应用示例</h3> <h4 id="51-子元素的变动">5.1 子元素的变动</h4> <p>下面的例子说明如何读取变动记录。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">records</span><span class="p">){</span>
  <span class="nx">records</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">record</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mutation type: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Mutation target: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
<span class="nx">mo</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">childList</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">subtree</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="52-属性的变动">5.2 属性的变动</h4> <p>下面的例子说明如何追踪属性的变动。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">records</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">record</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Previous attribute value: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">record</span><span class="p">.</span><span class="nx">oldValue</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
<span class="nx">mo</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">#my_element</span><span class="dl">'</span><span class="p">),</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">attributes</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">attributeOldValue</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="53-取代-domcontentloaded-事件">5.3 取代 DOMContentLoaded 事件</h4> <p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用 <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> 事件。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
<span class="nx">observer</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
</code></pre></div></div> <p>上面代码中，监听 <code class="language-plaintext highlighter-rouge">document.documentElement</code>（即网页的 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> HTML 节点）的子节点的变动，<code class="language-plaintext highlighter-rouge">subtree</code> 属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。</p> <p>下面的代码，使用 MutationObserver 对象封装一个监听 DOM 生成的函数。</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">win</span><span class="p">){</span>
  <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">listeners</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">win</span><span class="p">.</span><span class="nb">document</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">MutationObserver</span> <span class="o">=</span> <span class="nx">win</span><span class="p">.</span><span class="nx">MutationObserver</span> <span class="o">||</span> <span class="nx">win</span><span class="p">.</span><span class="nx">WebKitMutationObserver</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">observer</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">fn</span><span class="p">){</span>
    <span class="c1">// 储存选择器和回调函数</span>
    <span class="nx">listeners</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span>
      <span class="na">selector</span><span class="p">:</span> <span class="nx">selector</span><span class="p">,</span>
      <span class="na">fn</span><span class="p">:</span> <span class="nx">fn</span>
    <span class="p">});</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">observer</span><span class="p">){</span>
      <span class="c1">// 监听document变化</span>
      <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutationObserver</span><span class="p">(</span><span class="nx">check</span><span class="p">);</span>
      <span class="nx">observer</span><span class="p">.</span><span class="nf">observe</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="c1">// 检查该节点是否已经在DOM中</span>
    <span class="nf">check</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nf">check</span><span class="p">(){</span>
  <span class="c1">// 检查是否匹配已储存的节点</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">listeners</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">listener</span> <span class="o">=</span> <span class="nx">listeners</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="c1">// 检查指定节点是否有匹配</span>
      <span class="kd">var</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="nx">listener</span><span class="p">.</span><span class="nx">selector</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
        <span class="c1">// 确保回调函数只会对该元素调用一次</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">element</span><span class="p">.</span><span class="nx">ready</span><span class="p">){</span>
          <span class="nx">element</span><span class="p">.</span><span class="nx">ready</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="c1">// 对该节点调用回调函数</span>
          <span class="nx">listener</span><span class="p">.</span><span class="nx">fn</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 对外暴露ready</span>
  <span class="nx">win</span><span class="p">.</span><span class="nx">ready</span> <span class="o">=</span> <span class="nx">ready</span><span class="p">;</span>

<span class="p">})(</span><span class="k">this</span><span class="p">);</span>

<span class="c1">// 使用方法</span>
<span class="nf">ready</span><span class="p">(</span><span class="dl">'</span><span class="s1">.foo</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">){</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div></div> <h2 id="十一参考">十一、参考</h2> <ul> <li>阮一峰，<a href="https://wangdoc.com/javascript/dom/" rel="external nofollow noopener" target="_blank">JavaScript 教程 - DOM</a> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/geolocation/">《Web API 教程 - Geolocation API》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/number/">ES6 - 数值的扩展</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/canvas/">《Web API 教程 - Canvas API》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/88-merge-sorted-array/">88. 合并两个有序数组</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/bom/">《JavaScript 教程 - 浏览器模型》摘录</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Zhang Feng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-repositories",title:"repositories",description:"Edit the `_data/repositories.yml` and change the `github_users` and `github_repos` lists to include your own GitHub profile and repositories.",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"This is a description of the page. You can modify it in &#39;_pages/cv.md&#39;. You can also change or remove the top pdf download button.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"nav-people",title:"people",description:"members of the lab or group",section:"Navigation",handler:()=>{window.location.href="/people/"}},{id:"dropdown-blog",title:"blog",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-web-api-\u6559\u7a0b-geolocation-api-\u6458\u5f55",title:"\u300aWeb API \u6559\u7a0b - Geolocation API\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/geolocation/"}},{id:"post-es6-\u6570\u503c\u7684\u6269\u5c55",title:"ES6 - \u6570\u503c\u7684\u6269\u5c55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/number/"}},{id:"post-web-api-\u6559\u7a0b-canvas-api-\u6458\u5f55",title:"\u300aWeb API \u6559\u7a0b - Canvas API\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/canvas/"}},{id:"post-88-\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4",title:"88. \u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/88-merge-sorted-array/"}},{id:"post-javascript-\u6559\u7a0b-\u6d4f\u89c8\u5668\u6a21\u578b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b - \u6d4f\u89c8\u5668\u6a21\u578b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/bom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/dom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/oop/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stdlib/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/features/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/operators/"}},{id:"post-webpack-\u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",title:"webpack \u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/publish-subscribe-model/"}},{id:"post-webpack-\u9879\u76ee\u4f18\u5316",title:"webpack \u9879\u76ee\u4f18\u5316",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/optimization/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/configuration/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/concepts/"}},{id:"post-webpack-\u6784\u5efa\u6d41\u7a0b",title:"webpack \u6784\u5efa\u6d41\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/build-flow/"}},{id:"post-webpack-\u4e2d\u7684-plugin",title:"webpack \u4e2d\u7684 Plugin",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/plugin/"}},{id:"post-webpack-\u4e2d\u7684-loader",title:"webpack \u4e2d\u7684 Loader",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/loader/"}},{id:"post-http-\u7f13\u5b58",title:"HTTP \u7f13\u5b58",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/07-caching/"}},{id:"post-http-\u8fde\u63a5\u7ba1\u7406",title:"HTTP \u8fde\u63a5\u7ba1\u7406",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/04-connection-management/"}},{id:"post-es6-\u7f16\u7a0b\u98ce\u683c",title:"ES6 - \u7f16\u7a0b\u98ce\u683c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/style/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u5e94\u7528\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u5e94\u7528\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/application-layer/"}},{id:"post-\u54cd\u5e94\u5f0f-web-\u8bbe\u8ba1",title:"\u54cd\u5e94\u5f0f Web \u8bbe\u8ba1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/responsive-web-design/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u8fd0\u8f93\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u8fd0\u8f93\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/transport-layer/"}},{id:"post-react-\u4e2d\u7684\u4e8b\u4ef6",title:"React \u4e2d\u7684\u4e8b\u4ef6",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events-in-react/"}},{id:"post-css-\u9884\u5904\u7406\u5668",title:"CSS \u9884\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-preprocessor/"}},{id:"post-css-modules-\u7528\u6cd5\u6559\u7a0b",title:"CSS Modules \u7528\u6cd5\u6559\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-modules/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7f51\u7edc\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7f51\u7edc\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/network-layer/"}},{id:"post-\u8de8\u57df\u8d44\u6e90\u5171\u4eab-cors",title:"\u8de8\u57df\u8d44\u6e90\u5171\u4eab\uff08CORS\uff09",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cors/"}},{id:"post-\u9632\u6296\u548c\u8282\u6d41",title:"\u9632\u6296\u548c\u8282\u6d41",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/debounce-and-throttle/"}},{id:"post-es6-symbol",title:"ES6 - Symbol",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/symbol/"}},{id:"post-es6-\u5b57\u7b26\u4e32\u7684\u6269\u5c55",title:"ES6 - \u5b57\u7b26\u4e32\u7684\u6269\u5c55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/string/"}},{id:"post-es6-set-\u548c-map-\u6570\u636e\u7ed3\u6784",title:"ES6 - Set \u548c Map \u6570\u636e\u7ed3\u6784",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/set-map/"}},{id:"post-es6-reflect",title:"ES6 - Reflect",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/reflect/"}},{id:"post-es6-proxy",title:"ES6 - Proxy",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/proxy/"}},{id:"post-es6-promise-\u5bf9\u8c61",title:"ES6 - Promise \u5bf9\u8c61",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/promise/"}},{id:"post-es6-object",title:"ES6 - Object",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/object/"}},{id:"post-es6-\u6a21\u5757",title:"ES6 - \u6a21\u5757",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/module/"}},{id:"post-es6-let-\u548c-const-\u547d\u4ee4",title:"ES6 - let \u548c const \u547d\u4ee4",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/let-const/"}},{id:"post-es6-iterator",title:"ES6 - Iterator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/iterator/"}},{id:"post-es6-generator-\u51fd\u6570",title:"ES6 - Generator \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/generator/"}},{id:"post-es6-function",title:"ES6 - Function",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/function/"}},{id:"post-es6-\u88c5\u9970\u5668",title:"ES6 - \u88c5\u9970\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/decorator/"}},{id:"post-es6-class",title:"ES6 - Class",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/class/"}},{id:"post-es6-async-\u51fd\u6570",title:"ES6 - async \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-es6-array",title:"ES6 - Array",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/array/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6570\u636e\u94fe\u8def\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6570\u636e\u94fe\u8def\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/data-link-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7269\u7406\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7269\u7406\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/physical-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6982\u8ff0",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6982\u8ff0",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/instruction/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%7A%66%65%6E%67%30%37%31%32@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=qc6CJjYAAAAJ","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>