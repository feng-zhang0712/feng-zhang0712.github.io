<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 计算机网络 - 网络层 | Zhang Feng </title> <meta name="author" content="Zhang Feng"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://feng-zhang0712.github.io//blog/2024/network-layer/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Zhang</span> Feng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">计算机网络 - 网络层</h1> <p class="post-meta"> Created in September 13, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/computer"> <i class="fa-solid fa-hashtag fa-sm"></i> computer</a>   <a href="/blog/tag/networks"> <i class="fa-solid fa-hashtag fa-sm"></i> networks</a>   <a href="/blog/tag/network-layer"> <i class="fa-solid fa-hashtag fa-sm"></i> network layer</a>   <a href="/blog/tag/osi"> <i class="fa-solid fa-hashtag fa-sm"></i> OSI</a>   ·   <a href="/blog/category/blog"> <i class="fa-solid fa-tag fa-sm"></i> blog</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>本章的核心内容——网际协议 IP 是本书的一个重点内容。本章还要讨论网际控制报文协议 ICMP，几种常用的路由选择协议，IPv6 的主要特点，IP 多播的概念。本章最重要的内容是：</p> <ul> <li>虚拟互连网络的概念。</li> <li>IP 地址与物理地址的关系。</li> <li>传统的分类的 IP 地址（包括子网掩码）和无分类域间路由选择 CIDR。</li> <li>路由选择协议的工作原理。</li> </ul> <h2 id="一网络层提供的两种服务">一、网络层提供的两种服务</h2> <p>计算机网络发展的早期，人们曾认为，计算机网络应模仿打电话所使用的面向连接的通信方式。当两台计算机进行通信时，应当先建立连接（但在分组交换中是建立一条<strong>虚电路</strong> VC（Virtual Circuit）），以预留双方通信所需的一切网络资源。然后双方就沿着已建立的虚电路发送分组。图 4-1（a）是网络提供虚电路服务的示意图。主机 $H_1$ 和 $H_2$ 之间交换的分组都必须在事先建立的虚电路上传送。</p> <p>但互联网的先驱者却提出一种崭新的网络设计思路。他们认为，电信网提供的端到端可靠传输的服务对电话业务无疑是很合适的，因为电信网的终端（电话机）非常简单，没有智能，也没有差错处理能力。因此电信网必须负责把用户电话机产生的话音信号可靠地传送到对方的电话机，使还原后的话音质量符合技术规范的要求。但计算机网络的端系统是有智能的计算机。计算机有很强的差错处理能力（这点和传统的电话机有本质上的差别）。因此，互联网在设计上就采用了和电信网完全不同的思路。</p> <p>互联网采用的设计思路是这样的：<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong>。这里的“数据报”（datagram）指我们经常使用的“分组”。</p> <p>网络在发送分组时不需要先建立连接。每个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。<strong>网络层不提供服务质量的承诺</strong>。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器比较简单，且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。</p> <p>图 4-1（b）给出了网络提供数据报服务的示意图。主机 $H_1$ 向 $H_2$ 发送的分组各自独立地选择路由，并且在传送的过程中还可能丢失。</p> <p><img src="/assets/images/computer-network/two-types-of-services-provided-by-the-network-layer.png" alt="网络层提供的两种服务"> <em>图 4-1 网络层提供的两种服务</em></p> <p>| 对比的方面 | 虚电路服务 | 数据报服务 | | — | — | — | | 思路 | 可靠通信应当由网络来保证 | 可靠通信应当由用户主机来保证 | | 连接的建立 | 必须有 | 不需要 | | 终点地址 | 仅在连接建立阶段使用，每个分组使用短的虚电路号 | 每个分组都有终点的完整地址 | | 分组的转发 | 属于同一条虚电路的分组均按照同一路由进行转发 | 每个分组独立选择路由进行转发 | | 当结点出故障时 | 所有通过出故障的结点的虚电路均不能工作 | 出故障的结点可能会丢失分组，一些路由可能会发生变化 | | 分组的顺序 | 总是按发送顺序到达终点 | 到达终点的时间不一定按发送顺序 | | 端到端的差错处理和流量控制 | 可以由网络负责，也可以由用户主机负责 | 由用户主机负责 | <em>表 4-1 虚电路服务与数据报服务的对比</em></p> <h2 id="二网际协议-ip">二、网际协议 IP</h2> <p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一[STEV94][COME06][FORO10]，也是最重要的互联网标准协议之一（注意，这里所讲的 IP 是 IP 的第 4 个版本（IPv4）。但在讲述 IP 协议的各种原理时，往往不在 IP 后面加上版本号。在后面的 <a href="#%E5%85%ADipv6">第六节</a> 会介绍较新的版本 IPv6）。</p> <p>与 IP 协议配套使用的还有三个协议：</p> <ul> <li> <strong>地址解析协议 ARP</strong>（Address Resolution Protocol）</li> <li> <strong>网际控制报文协议 ICMP</strong>（Internet Control Message Protocol）</li> <li> <strong>网际组管理协议 IGMP</strong>（Internet Group Management Protocol）</li> </ul> <p>图 4-2 画出了这三个协议和网际协议 IP 的关系。在这一层中，ARP 画在最下面，因为 IP 经常要使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层常常被称为<strong>网际层</strong>（internet layer），或 <strong>IP 层</strong>。</p> <p><img src="/assets/images/computer-network/internet-protocol-ip-and-its-supporting-protocols.png" alt="网际协议 IP 及其配套协议"> <em>图 4-2 网际协议 IP及其配套协议</em></p> <h3 id="21-虚拟互连网络">2.1 虚拟互连网络</h3> <p>将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p> <ul> <li>物理层使用的中间设备叫做<strong>转发器</strong>（repeater）。</li> <li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>（bridge）。</li> <li>网络层使用的中间设备叫做<strong>路由器</strong>（router）。</li> <li>在网络层以上使用的中间设备叫做<strong>网关</strong>（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li> </ul> <p>当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称之为网络互连。网关由于比较复杂，目前使用得较少。因此现在我们讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。注意，由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关（本书有时也这样用）。</p> <p>图 4-3（a）表示有许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的<strong>网际协议 IP</strong>（Internet Protocol），因此可以把互连以后的计算机网络看成如图 4-3（b）所示的一个<strong>虚拟互连网络</strong>（internet）。所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。这种使用 IP协 议的虚拟互连网络可简称为 IP 网。使用 IP 网的好处是：当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节（如具体的编址方案、路由选择协议，等等）。如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网（Internet）。</p> <p><img src="/assets/images/computer-network/the-concept-of-ip-network.png" alt="IP 网的概念"> <em>图 4-3 IP 网的概念</em></p> <p>在图 4-4 所示的互联网中的源主机 $H_1$ 要把一个 IP 数据报发送给目的主机 $H_2$。根据之前讲过的分组交换的存储转发概念，主机 $H_1$ 先要查找自己的路由表，看目的主机是否就在本网络上。如是，则不需要经过任何路由器而是<strong>直接交付</strong>，任务就完成了。如不是，则必须把 IP 数据报发送给某个路由器（图中的 $R_1$）。$R_1$ 在查找了自己的路由表后，知道应当把数据报转发给 $R_2$ 进行<strong>间接交付</strong>。这样一直转发下去，最后由路由器 $R_5$ 知道自己是和 $H_2$ 连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报直接交付目的主机 $H_2$。图中画出了源主机、目的主机以及各路由器的协议栈。我们注意到，主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向（用黑色粗线表示）。我们还可注意到，在 $R_4$ 和 $R_5$ 之间使用了卫星链路，而 $R_5$ 所连接的是个无线局域网。在 $R_1$ 到 $R_4$ 之间的三个网络则可以是任意类型的网络。总之，这里强调的是：<strong>互联网可以由多种异构网络互连组成</strong>。</p> <p>如果我们只从网络层考虑问题，那么IP 数据报就可以想象是在网络层中传送，其传送路径是：</p> \[H_1 → R_1 → R_2 → R_3 → R_4 → R_5 → H_2\] <p><img src="/assets/images/computer-network/transmission-of-packets-over-the-internet.png" alt="分组在互联网中的传送"> <em>图 4-4 分组在互联网中的传送</em></p> <h3 id="22-分类的-ip-地址">2.2 分类的 IP 地址</h3> <p>在 TCP/IP 体系中，IP 地址是一个最基本的概念。有关 IP 最重要的文档就是互联网的正式标准 RFC 791。</p> <h4 id="1ip-地址及其表示方法">（1）IP 地址及其表示方法</h4> <p>整个的互联网就是一个<strong>单一的、抽象的网络</strong>。IP 地址就是给互联网上的每台主机（或路由器）的每个接口分配一个在全世界范围内是唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上很方便地进行寻址。IP 地址现在由<strong>互联网名字和数字分配机构 ICANN</strong>（Internet Corporation for Assigned Names and Numbers）进行分配。</p> <p>IP 地址的编址方法共经过了三个历史阶段。</p> <ol> <li> <strong>分类的 IP 地址</strong>：这是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li> <li> <strong>子网的划分</strong>：这是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</li> <li> <strong>构成超网</strong>：这是比较新的无分类编址方法。1993 年提出后很快就得到推广应用。</li> </ol> <p>所谓“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每类地址都由两个固定长度的字段组成。</p> <ol> <li> <strong>网络号</strong>（net-id）：第一个字段。它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。</li> <li> <strong>主机号</strong>（host-id）：第二个字段。它标志该主机（或路由器）。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li> </ol> <p>由此可见，一个 IP 地址<strong>在整个互联网范围内是唯一的</strong>。这种两级的 IP 地址可以记为：</p> \[IP 地址 ::= {&lt;网络号&gt;, &lt;主机号&gt;}\] <p>上式中的符号“::=”表示“<strong>定义为</strong>”。图 4-5 给出了各种 IP 地址的网络号字段和主机号字段，这里 A 类、B 类和 C 类地址都是单播地址（一对一通信），是最常用的。</p> <p><img src="/assets/images/computer-network/the-network-number-field-and-host-number-field-in-the-ip-address.png" alt="IP 地址中的网络号字段和主机号字段"> <em>图 4-5 IP 地址中的网络号字段和主机号字段</em></p> <p>从图 4-5 可以看出：</p> <ul> <li>A 类、B 类和 C 类地址的网络号字段（在图中这个字段是灰色的）分别为 1 个、2 个和 3 个字节长，而在网络号字段的最前面有 1~3 位的<strong>类别位</strong>，其数值分别规定为 0、10 和 110。</li> <li>A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。</li> <li>D 类地址（前 4 位是 1110）用于多播（一对多通信）。</li> <li>E 类地址（前 4 位是 1111）保留为以后用。</li> </ul> <p>这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、B 类和 C 类地址的区分已成为历史[RFC1812]，但由于很多文献和资料都还使用传统的分类的 IP 地址，而且从概念的演进上更清晰，因此我们在这里还要从分类的 IP 地址讲起。</p> <p>从 IP 地址的结构来看，IP 地址并不仅仅指明一台主机，而是还指明了主机连接到的网络。</p> <p>把 IP 地址划分为 A 类、B 类、C 类三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把 IP 地址划分为 A 类、B 类和 C 类是为了更好地满足不同用户的要求。当某个单位申请到一个 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。</p> <p>对主机或路由器来说，IP 地址都是 32 位的二进制代码。为了提高可读性，我们常把 32 位的 IP 地址中的每 8 位插入一个空格（但在机器中并没有这样的空格）。为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做<strong>点分十进制记法</strong>（dotted decimal notation）。图 4-6 是一个 B 类 IP 地址的表示方法。显然，128.11.3.31 比 10000000 00001011 00000011 00011111 书写起来要方便得多。</p> <p><img src="/assets/images/computer-network/the-use-of-dotted-decimal-notation-improves-readability.png" alt="采用点分十进制记法能够提高可读性"> <em>图 4-6 采用点分十进制记法能够提高可读性</em></p> <h4 id="2常用的三种类别的-ip-地址">（2）常用的三种类别的 IP 地址</h4> <p>A 类地址的网络号字段占 1 个字节，只有 7 位可供使用（该字段的第一位已固定为 0），但可指派的网络号是 126 个（即 $2^{-7} - 2$）。减 2 的原因是：第一，IP 地址中的全 0 表示“这个（this）”。网络号字段为全 0 的 IP 地址是个保留地址，意思是“<strong>本网络</strong>”；第二，网络号为 127（即 01111111）保留作为本地软件<strong>环回测试</strong>（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。</p> <p>A 类地址的主机号占 3 个字节，因此每个 A 类网络中的最大主机数是 $2^{24} - 2$，即 16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>单个网络地址</strong>（例如，一主机的 IP 地址为5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示“所有的（all）”，因此全 1 的主机号字段表示该网络上的所有主机。</p> <p>IP 地址空间共有 $2^{32}$（即 4294967296）个地址。整个 A 类地址空间共有 21 个地址，占整个 IP 地址空间的 50%。</p> <p>B 类地址的网络号字段有 2 个字节，但前面两位（10）已经固定了，只剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此这里不存在网络总数减 2 的问题。但实际上 B 类网络地址128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0 [COME06]。因此 B 类地址可指派的网络数为 $2^{14} - 1$，即 16383。B 类地址的每个网络上的最大主机数是 $2^{16} - 2$，即 65534。这里需要减 2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 $2^{30}$ 个地址，占整个 IP 地址空间的 25%。</p> <p>C 类地址有 3 个字节的网络号字段，最前面的 3 位是（110），还有 21 位可以进行分配。C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络地址是 192.0.1.0 [COME06]，因此 C 类地址可指派的网络总数是 $2^{21} - 1$，即 2097151。每个 C 类地址的最大主机数是 $2^8 - 2$，即 254。整个 C 类地址空间共约有 $2^{29}$ 个地址，占整个 IP 地址的 12.5%。</p> <p>这样，我们就可得出表 4-2 所示的 IP 地址的指派范围。</p> <p>| 网络类别 | 最大可指派的网络数 | 第一个可指派的网络号 | 最后一个可指派的网络号 | 每个网络中的最大主机数 | | — | — | — | — | — | | A | $126(2^7 - 2)$ | 1 | 126 | 16777214 | | B | $16383(2^{14} - 1)$ | 128.1 | 191.255 | 65534 | | C | $2097151(2^{21} - 1)$ | 192.0.1 | 223.255.255 | 254 | <em>表 4-2 IP 地址的指派范围</em></p> <p>表 4-3 给出了一般不使用的特殊 IP 地址，这些地址只能在特定的情况下使用。</p> <p>| 网络号 | 主机号 | 源地址使用 | 目的地址使用 | 代表的意思 | | — | — | — | — | — | | 0 | 0 | 可以 | 不可 | 在本网络上的本主机（见6。6节 DHCP 协议） | | 0 | host-id | 可以 | 不可 | 在本网络上的某台主机 host-id | | 全 1 | 全 1 | 不可 | 可以 | 只在本网络上进行广播（各路由器均不转发） | | net-id | 全 1 | 不可 | 可以 | 对 net-id 上的所有主机进行广播 | | 127 | 非全 0 或全 1 的任何数 | 可以 | 可以 | 用于本地软件环回测试 | <em>表 4-3 一般不使用的特殊 IP 地址</em></p> <p>IP 地址具有以下一些重要特点。</p> <ol> <li>每个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种<strong>分等级的地址结构</strong>。分两个等级的好处是： <ul> <li>第一，IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong>（第一级），而剩下的主机号（第二级）则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理；</li> <li>第二，路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong>（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而<strong>减小了路由表所占的存储空间以及查找路由表的时间</strong>。</li> </ul> </li> <li>实际上 IP 地址是标志一台主机（或路由器）和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>（multihomed host）。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。这好比一个建筑正好处在北京路和上海路的交叉口上，那么这个建筑就可以拥有两个门牌号码。例如，北京路 4 号和上海路 37 号。</li> <li>按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，<strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li> <li>在 IP 地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是<strong>平等</strong>的。所谓平等，是指互联网同等对待每个 IP 地址。图 4-7 画出了三个局域网（$LAN_1$，$LAN_2$ 和 $LAN_3$）通过三个路由器（$R_1$，$R_2$ 和 $R_3$）互连起来所构成的一个互联网（此互联网用虚线圆角方框表示）。其中局域网 $LAN_2$， 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有一个 IP 地址。</li> </ol> <p>我们应当注意到：</p> <ul> <li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。图中所示的网络号就是 IP 地址中的网络号字段的值，这也是文献中常见的一种表示方法。另一种表示方法是用主机号为全 0 的网络 IP 地址。</li> <li>用网桥（它只在链路层工作）互连的网段仍然是一个局域网，只能有一个网络号。</li> <li>路由器总是具有两个或两个以上的 IP 地址。即路由器的每个接口都有一个不同网络号的 IP 地址。</li> <li>当两个路由器直接相连时（例如通过一条租用线路），在连线两端的接口处，可以分配也可以不分配 IP 地址。如分配了 IP 地址，则这段连线就构成了一种只包含一段线路的特殊“网络”（如图中的 $N_1$，$N_2$ 和 $N_3$）。之所以叫做“网络”是因为它有 IP 地址。但为了节省 IP 地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配 IP 地址。通常把这样的特殊网络叫做<strong>无编号网络</strong>（unnumbered network）或<strong>无名网络</strong>（anonymous network）[COME06]。</li> </ul> <p><img src="/assets/images/computer-network/an-ip-address-on-the-internet.png" alt="互联网中的 IP 地址"> <em>图 4-7 互联网中的 IP 地址</em></p> <h3 id="23-ip-地址与硬件地址">2.3 IP 地址与硬件地址</h3> <p>图 4-8 说明了 IP 地址与硬件地址的区别。从层次的角度看，<strong>物理地址是数据链路层和物理层使用的地址</strong>，而 <strong>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</strong>。</p> <p><img src="/assets/images/computer-network/differences-between-ip-addresses-and-hardware-addresses.png" alt="IP 地址与硬件地址的区别"> <em>图 4-8 IP 地址与硬件地址的区别</em></p> <p>在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在MAC 帧的首部中。</p> <p>连接在通信链路上的设备（主机或路由器）在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。</p> <p>总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。</p> <p>图 4-9（a）画的是三个局域网用两个路由器 $R_1$ 和 $R_2$ 互连起来。现在主机 $H_1$ 要和主机 $H_2$ 通信。这两台主机的 IP 地址分别是 $IP_1$ 和 $IP_2$，而它们的硬件地址分别为 $HA_1$ 和 $HA2_1$（HA 表示 Hardware Address）。通信的路径是：$H_1$ → 经过 $R_1$ 转发 → 再经过 $R_2$ 转发 → $H_2$。路由器 $R_1$ 因同时连接到两个局域网上，因此它有两个硬件地址，即 $HA_3$ 和 $HA_4$。同理，路由器 $R_2$ 也有两个硬件地址 $HA_5$ 和 $HA_6$。</p> <p><img src="/assets/images/computer-network/ip-addresses-and-hardware-addresses-at-different-levels.png" alt="从不同层次上看 IP 地址和硬件地址"> <em>图 4-9 从不同层次上看 IP 地址和硬件地址</em></p> <p>图4-9（b）特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。</p> <p><img src="/assets/images/computer-network/source-and-destination-addresses-of-different-levels-and-ranges.png" alt="图 4-9（b）中不同层次、不同区间的源地址和目的地址"> <em>表 4-4 图 4-9（b）中不同层次、不同区间的源地址和目的地址</em></p> <p>这里要强调指出以下几点：</p> <ul> <li> <strong>在 IP 层抽象的互联网上只能看到 IP 数据报</strong>。虽然 IP 数据报要经过路由器 $R_1$ 和 $R_2$ 的两次转发，但在它的首部中的源地址和目的地址始终分别是 $IP_1$ 和 $IP_2$。图中的数据报上写的“从 $IP_1$ 到 $IP_2$”就表示前者是源地址而后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li> <li>虽然在 IP 数据报首部有源站 IP 地址，但<strong>路由器只根据目的站的 IP 地址的网络号进行路由选择</strong>。</li> <li> <strong>在局域网的链路层，只能看见 MAC 帧</strong>。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图 4-9（b）。开始在 $H_1$ 到 $R_1$ 间传送时，MAC 帧首部中写的是从硬件地址 $HA_1$，发送到硬件地址 $HA_3$，路由器 $R_1$ 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新添加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 $HA_4$ 和 $HA_5$。路由器 $R_2$ 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变成为 $HA_6$ 和 $HA_2$。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。</li> <li>尽管互连在一起的网络的硬件地址体系各不相同，但<strong>IP 层抽象的互联网却屏蔽了下层这些很复杂的细节</strong>。<strong>只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信</strong>。上述的这种“屏蔽”概念是一个很有用，很普遍的基本概念。例如，计算机中广泛使用的图形用户界面使得用户只需简单地点击几下鼠标就能让计算机完成很多任务。实际上计算机要完成这些任务必须执行很多条指令。但这些复杂的过程全都被设计良好的图形用户界面屏蔽掉了，使用户看不见这些复杂过程。</li> </ul> <p>以上这些概念是计算机网络的精髓所在，对这些重要概念务必仔细思考和掌握。到目前为止，还有两个重要问题没有解决：</p> <ol> <li>主机或路由器怎样知道应当在 MAC 帧的首部填入什么样的硬件地址？</li> <li>路由器中的路由表是怎样得出的？</li> </ol> <p>第一个问题就是下一节所要讲的内容，而第二个问题将在后面的 <a href="#%E4%BA%94%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">第五节</a> 节详细讨论。</p> <h3 id="24-地址解析协议-arp">2.4 地址解析协议 ARP</h3> <p>在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址。地址解析协议 ARP 就是用来解决这样的问题的。图 4-10 说明了 ARP 协议的作用。</p> <p><img src="/assets/images/computer-network/function-of-arp-protocol.png" alt="ARP 协议的作用"> <em>图 4-10 ARP 协议的作用</em></p> <p>由于是 IP 协议使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。ARP 协议的用途是为了从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。注意，还有一个旧的协议叫做逆地址解析协议 RARP，它的作用是使只知道自己硬件地址的主机能够通过 RARP 协议找出其 IP 地址。现在的 DHCP 协议已经包含了 RARP 协议的功能。因此本书不再介绍 RARP 协议。</p> <p>我们知道，网络层使用的是 IP 地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但 IP 地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系（例如，IP 地址有 32 位，而局域网的硬件地址是 48 位）。此外，在一个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变。<strong>地址解析协议 ARP</strong> 解决这个问题的方法是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。</p> <p>每台主机都设有一个 <strong>ARP 高速缓存</strong>（ARP cache），里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p> <p>当主机 A 要向<strong>本局域网</strong>上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。也有可能查不到主机 B 的 IP 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 ARP，然后按以下步骤找出主机 B 的硬件地址。</p> <ol> <li>ARP 进程在本局域网上广播发送一个 ARP 请求分组（具体格式可参阅[COME06]的第 23 章）。图 4-11（a）是主机 A 广播发送 ARP 请求分组的示意图。ARP 请求分组的主要内容是：“我的 IP 地址是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18。我想知道 IP 地址为 209.0.0.6 的主机的硬件地址。”</li> <li>在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组。</li> <li>主机 B 的 IP 地址与 ARP 请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机 A 发送 ARP 响应分组（其格式见[COME06]），同时在这个 ARP 响应分组中写入自己的硬件地址。由于其余的所有主机的 IP 地址都与 ARP 请求分组中要查询的 IP 地址不一致，因此都不理睬这个 ARP 请求分组，见图 4-11（b）。ARP 响应分组的主要内容是：“我的 IP 地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A。”请注意：虽然 ARP 请求分组是广播发送的，但 ARP 响应分组是普通的单播，即从一个源地址发送到一个目的地址。</li> <li>主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的IP 地址到硬件地址的映射。</li> </ol> <p><img src="/assets/images/computer-network/the-working-principle-of-the-address-resolution-protocol.png" alt="地址解析协议 ARP 的工作原理"> <em>图 4-11 地址解析协议 ARP 的工作原理</em></p> <p>在上述第（3）步中，当主机 B 收到 A 的 ARP 请求分组时，同时会把主机 A 的地址映射写入主机 B 自己的 ARP 高速缓存中。以后主机 B 向 A 发送数据报时就很方便了。</p> <p>ARP 把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。</p> <p>ARP 对保存在高速缓存中的每个映射地址项目都设置生存时间（例如，10 ～ 20 分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目的生存时间是很重要的。设想有一种情况。主机 A 和 B 通信。A 的 ARP 高速缓存里保存有 B 的硬件地址。但 B 的网络适配器突然坏了，B 立即更换了一块，因此 B 的硬件地址就改变了。假定 A 还要和 B 继续通信。A 在其 ARP 高速缓存中查找到 B 原先的硬件地址，并使用该硬件地址向 B 发送数据帧。但 B 原先的硬件地址已经失效了，因此 A 无法找到主机 B。但是过了一段不长的生存时间，A 的 ARP 高速缓存中已经删除了 B 原先的硬件地址，于是 A 重新广播发送 ARP 请求分组，又找到了 B。</p> <p>注意，ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如，在前面的图 4-9 中，主机 H 就无法解析出另一个局域网上主机 $H_2$ 的硬件地址（实际上主机 $H_1$ 也不需要知道远程主机 $H_2$ 的硬件地址）。主机 $H_1$ 发送给 $H_2$ 的 IP 数据报首先需要通过与主机 $H_1$ 连接在同一个局域网上的路由器 $R_1$ 来转发。因此主机 $H_1$ 这时需要把路由器 $R_1$ 的 IP 地址 $IP_3$，解析为硬件地址 $HA_3$，以便能够把 IP 数据报传送到路由器 $R_1$。以后 $R_1$ 从转发表找出了下一跳路由器 $R_2$，同时使用 ARP 解析出 $R_2$ 的硬件地址 $HA_5$。于是 IP 数据报按照硬件地址 $HA_5$，转发到路由器 $R_2$。路由器 $R_2$ 在转发这个 IP 数据报时用类似方法解析出目的主机 $H_2$ 的硬件地址 $HA_2$，使 IP 数据报最终交付主机 $H_2$。</p> <p>从 IP 地址到硬件地址的解析是自动进行的，<strong>主机的用户对这种地址解析过程是不知道的</strong>。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地把这个 IP 地址解析为链路层所需要的硬件地址。</p> <p>下面我们归纳出使用ARP的四种典型情况（图4-12）。</p> <p><img src="/assets/images/computer-network/four-typical-scenarios-for-using-arp.png" alt="使用 ARP 的四种典型情况"> <em>图4 -12 使用 ARP 的四种典型情况</em></p> <ol> <li>发送方是主机（如 $H_1$），要把 IP 数据报发送到同一个网络上的另一台主机（如 $H_2$）。这时 $H_1$ 发送 ARP 请求分组（在网上广播），找到目的主机 $H_2$ 的硬件地址。</li> <li>发送方是主机（如 $H_1$），要把 IP 数据报发送到另一个网络上的一台主机（如 $H_3$ 或 $H_4$）。这时 $H_1$ 发送 ARP 请求分组（在网上广播），找到网上的一个路由器 $R_1$ 的硬件地址。剩下的工作由路由器 $R_1$ 来完成。$R_1$ 要做的事情是下面的（3）或（4）。</li> <li>发送方是路由器（如 $R_1$），要把 IP 数据报转发到与 $R_1$ 连接在同一个网络（网 2）上的主机（如 $H_3$）。这时 $R_1$ 发送 ARP 请求分组（在网 2 上广播），找到目的主机 $H_3$ 的硬件地址。</li> <li>发送方是路由器（如 $R_1$），要把 IP 数据报转发到网 3 上的一台主机（如 $H_4$）。$H_4$ 与 $R_1$ 不是连接在同一个网络上。这时 $R_1$ 发送 ARP 请求分组（在网 2 上广播），找到连接在网 2 上的一个路由器 R2 的硬件地址。剩下的工作由这个路由器 $R_2$ 来完成。</li> </ol> <p>在许多情况下需要多次使用 ARP。但这只是以上几种情况的反复使用而已。</p> <p>既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的 IP 地址，而不直接使用硬件地址进行通信？由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但 IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p> <h3 id="25-ip-数据报的格式">2.5 IP 数据报的格式</h3> <p>IP 数据报的格式能够说明 IP 协议都具有什么功能。在 TCP/IP 的标准中，各种数据格式常常以 32 位（即 4 字节）为单位来描述。图 4-13 是 IP 数据报的完整格式。</p> <p><img src="/assets/images/computer-network/format-of-the-ip-datagram.png" alt="IP 数据报的格式"> <em>图 4-13 IP 数据报的格式</em></p> <p>从图 4-13 可看出，一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。</p> <h4 id="1ip-数据报首部的固定部分中的各字段">（1）IP 数据报首部的固定部分中的各字段</h4> <ul> <li> <strong>版本</strong>：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4（即 IPv4）。</li> <li> <strong>首部长度</strong>：占 4 位，可表示的最大十进制数值是 15。请注意，首部长度字段所表示数的单位是 32 位字（1 个 32 位字长是 4 字节）。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 5（即二进制表示的首部长度是 0101）。而当首部长度为最大值 1111 时（即十进制数的 15），就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节（即首部长度为 0101），这时不使用任何选项。</li> <li> <strong>区分服务</strong>：占 8 位，用来获得更好的服务。只有在使用区分服务时，这个字段才起作用。一般情况下不使用这个字段[RFC2474，3168，3260]。</li> <li> <p><strong>总长度</strong>：总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 $2^{16} - 1$ = 65535 字节。 然而实际上传送这样长的数据报在现实中是极少遇到的。</p> <p>我们知道，在 IP 层下面的每种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为<strong>最大传送单元 MTU</strong>（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的 MTU 值。例如，最常用的以太网就规定其 MTU 值是 1500 字节。若所传送的数据报长度超过数据链路层的 MTU 值，就必须把过长的数据报进行分片处理。</p> <p>虽然使用尽可能长的 IP 数据报会使传输效率得到提高（因为每个 IP 数据报中首部长度占数据报总长度的比例就会小些），但数据报短些也有好处。每个 IP 数据报越短，路由器转发的速度就越快。为此，IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p> <p>在进行分片时（见后面的“片偏移”字段），数据报首部中的“总长度”字段是指分片后的每个分片的首部长度与该分片的数据长度的总和。</p> </li> <li> <p><strong>标识</strong>（identification）：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p> </li> <li> <strong>标志</strong>（flag）：占 3 位，但目前只有两位有意义。 <ul> <li>标志字段中的最低位记为 MF（More Fragment）。MF = 1 即表示后面“还有分片”的数据报。MF = 0 表示这已是若干数据报片中的最后一个。</li> <li>标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF = 0 时才允许分片。</li> </ul> </li> <li> <p><strong>片偏移</strong>：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位。这就是说，每个分片的长度一定是 8 字节（64 位）的整数倍。下面举一个例子。 【例 4-1】 一数据报的总长度为 3820 字节，其数据部分为 3800 字节长（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。于是分为 3 个数据报片，其数据部分的长度分别为 1400，1400 和 1000 字节。原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。图 4-14 给出分片后得出的结果（注意片偏移的数值）。</p> <p><img src="/assets/images/computer-network/example-for-fragment-datagram.png" alt="数据报的分片举例"> <em>图 4-14 数据报的分片举例</em></p> <p>表 4-5 是本例中数据报首部与分片有关的字段中的数值，其中标识字段的值是任意给定的（12345）。具有相同标识的数据报片在目的站就可无误地重装成原来的数据报。</p> <p>| | 总长度 | 标识 | MF | DF | 片偏移 | | :—: | :—: | :—: | :—: | :—: | :—: | | 原始数据报 | 3820 | 12345 | 0 | 0 | 0 | | 数据报片 1 | 1420 | 12345 | 1 | 0 | 0 | | 数据报片 2 | 1420 | 12345 | 1 | 0 | 175 | | 数据报片 3 | 1020 | 12345 | 0 | 0 | 350 | <em>表 4-5 IP 数据报首部中与分片有关的字段中的数值</em></p> <p>现在假定数据报片 2 经过某个网络时还需要再进行分片，即划分为数据报片 2-1（携带数据 800 字节）和数据报片 2-2（携带数据 600 字节）。那么这两个数据报片的总长度、标识、MF、DF 和片偏移分别为：820，12345，1，0， 175；620，12345，1，0，275。</p> </li> <li> <p><strong>生存时间</strong>：占 8 位，生存时间字段常用的英文缩写是 TTL（Time To Live），表明这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子（例如从路由器 $R_1$ 转发到 $R_2$，再转发到 $R_3$，然后又转发到 $R_1$），因而白白消耗网络资源。最初的设计是以秒作为 TTL 值的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于 1 秒，后来就把 TTL 字段的功能改为“<strong>跳数限制</strong>”（但名称不变）。路由器在每次转发数据报之前就把 TTL 值减 1。若 TTL 值减小到零，就丢弃这个数据报，不再转发。因此，现在 TTL 的单位不再是秒，而是<strong>跳数</strong>。TTL 的意义是指明数据报在互联网中至多可经过多少个路由器。显然，数据报能在互联网中经过的路由器的最大数值是 255。若把 TTL 的初始值设置为 1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前 TTL 值就减小到零，因而就会被这个路由器丢弃。</p> </li> <li> <p><strong>协议</strong>：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。</p> <p>常用的一些协议和相应的协议字段值如下：</p> <table> <thead> <tr> <th>协议名</th> <th>ICMP</th> <th>IGMP</th> <th>IP</th> <th>TCP</th> <th>EGP</th> <th>IGP</th> <th>UDP</th> <th>IPv6</th> <th>ESP</th> <th>OSPF</th> </tr> </thead> <tbody> <tr> <td>协议字段值</td> <td>1</td> <td>2</td> <td>4</td> <td>6</td> <td>8</td> <td>9</td> <td>17</td> <td>41</td> <td>50</td> <td>89</td> </tr> </tbody> </table> </li> <li> <p><strong>首部检验和</strong>：占 16 位。这个字段<strong>只检验数据报的首部</strong>，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的 CRC 检验码而采用下面的简单计算方法：在发送方，先把 IP 数据报首部划分为许多 16 位字的序列，并把检验和字段置零。用反码算术运算把所有 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有 16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为 0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。图 4-15 说明了 IP 数据报首部检验和的计算过程。</p> <p><img src="/assets/images/computer-network/the-calculation-process-of-ip-datagram-header-check-sum.png" alt="IP 数据报首部检验和的计算过程"> <em>图 4-15 IP 数据报首部检验和的计算过程</em></p> </li> <li> <strong>源地址</strong>：占 32 位。</li> <li> <strong>目的地址</strong>：占 32 位。</li> </ul> <h4 id="2ip-数据报首部的可变部分">（2）IP 数据报首部的可变部分</h4> <p>IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。</p> <p>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 IPv6 就把 IP 数据报的首部长度做成固定的。</p> <h3 id="26-ip-层转发分组的流程">2.6 IP 层转发分组的流程</h3> <p>图 4-16（a）是一个路由表的简单例子。有四个 A 类网络通过三个路由器连接在一起。每个网络上都可能有成千上万台主机（图中没有画出这些主机）。可以想象，若路由表指出到每台主机应怎样转发，则所得出的路由表就会过于庞大（如果每个网络有 1 万台主机，四个网络就有 4 万台主机，因而每个路由表就有 4 万个项目，即 4 万行。每一行对应于一台主机）。但若路由表指出到某个网络应如何转发，则每个路由器中的路由表就只包含 4 个项目（即只有 4 行，每一行对应于一个网络）。以路由器 $R_2$ 的路由表为例。由于 $R_2$ 同时连接在网络 2 和网络 3 上，因此只要目的主机在网络 2 或网络 3上，都可通过接口 0 或 1 由路由器 $R_2$ 直接交付（当然还要利用地址解析协议 ARP 才能找到这些主机相应的硬件地址）。若目的主机在网络 1 中，则下一跳路由器应为 $R_1$，其 IP 地址为 20.0.0.7。路由器 $R_2$ 和 $R_1$ 由于同时连接在网络 2 上，因此从路由器 $R_2$ 分组转发到路由器 $R_1$ 是很容易的。同理，若目的主机在网络 4 中，则路由器 $R_2$ 应把分组转发给 IP 地址为30.0.0.1 的路由器 $R_3$。我们应当注意到，图中的每个路由器都有两个不同的 IP 地址。</p> <p>可以把整个的网络拓扑简化为图 4-16（b）所示的那样。在简化图中，网络变成了一条链路，但每个路由器旁边都注明其 IP 地址。使用这样的简化图，可以使我们不必关心某个网络内部的具体拓扑以及连接在该网络上有多少台主机，因为这些对于研究分组转发问题并没有什么关系。这样的简化图强调了在互联网上转发分组时，是从一个路由器转发到下一个路由器。</p> <p>总之，在路由表中，对每一条路由最主要的是以下两个信息：</p> \[（目的网络地址，下一跳地址）\] <p><img src="/assets/images/computer-network/an-example-of-routing-table.png" alt="路由表举例"> <em>图 4-16 路由表举例</em></p> <p>于是，我们就根据目的网络地址来确定下一跳路由器，这样做可得出以下的结果。</p> <ul> <li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li> <li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li> </ul> <p>虽然互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做<strong>特定主机路由</strong>。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某台主机的特殊路由就十分有用。</p> <p>路由器还可采用<strong>默认路由</strong>（default route）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。实际上，默认路由在主机发送 IP 数据报时往往更能显示出它的好处。我们之前讲过，主机在发送每个 IP 数据报时都要查找自己的路由表。如果一台主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。例如，在图 4-17 的互联网中，连接在网络上的任何一台主机中的路由表只需要三个项目即可。第一个项目就是到本网络主机的路由，其目的网络就是本网络 $N_1$，因而不需要路由器转发，而是直接交付。第二个项目是到网络 $N_2$ 的路由，对应的下一跳路由器是 $R_2$。第三个项目就是<strong>默认路由</strong>。只要目的网络是其他网络（不是 $N_1$ 或 $N_2$），就一律选择默认路由，把数据报先间接交付路由器 $R_1$，让再 $R_1$ 转发给互联网中的下一个路由器，一直转发到目的网络上的路由器，最后进行直接交付。在实际上的路由器中，像图 4-17 路由表中所示的“直接”和“其他”的几个字符并没有出现在路由表中，而是被记为 0.0.0.0。</p> <p><img src="/assets/images/computer-network/router-r1-acts-as-the-default-router-for-network-n1.png" alt="路由器 $R_1$ 充当网络 $N_1$ 的默认路由器"> <em>图 4-17 路由器 $R_1$ 充当网络 $N_1$ 的默认路由器</em></p> <p>这里我们应当强调指出，在 IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。在 IP 数据报的首部写上的 IP 地址是源 IP 地址和目的 IP 地址，而没有中间经过的路由器的 IP 地址。既然 IP 数据报中没有下一跳路由器的 IP 地址，那么待转发的数据报又怎样能够找到下一跳路由器呢？</p> <p>当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（必须使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用 ARP 得到硬件地址、把硬件地址写入 MAC 帧的首部等过程，将不断地重复进行，造成了一定的开销。</p> <p>那么，能不能在路由表中不使用 IP 地址而直接使用硬件地址呢？不行。我们一定要弄清楚，使用抽象的 IP 地址，本来就是为了隐蔽各种底层网络的复杂性而便于分析和研究问题，这样就不可避免地要付出代价，例如在选择路由时多了一些开销。但反过来，如果在路由表中直接使用硬件地址，那就会带来更多的麻烦。</p> <p>根据以上所述，可归纳出<strong>分组转发算法</strong>如下：</p> <ol> <li>从数据报的首部提取目的主机的 IP 地址 D，得出目的网络地址为 N。</li> <li>若 N 就是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行（3）。</li> <li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。</li> <li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）。</li> <li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）。</li> <li>报告转发分组出错。</li> </ol> <p>这里我们要再强调一下，路由表并没有给分组指明到某个网络的完整路径（即先经过哪一个路由器，然后再经过哪一个路由器，等等）。路由表指出，到某个网络应当先到某个路由器（即下一跳路由器），在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</p> <h2 id="三-划分子网和构造超网">三、 划分子网和构造超网</h2> <h3 id="31-划分子网">3.1 划分子网</h3> <h4 id="1从两级-ip-地址到三级-ip-地址">（1）从两级 IP 地址到三级 IP 地址</h4> <p>在今天看来，在 ARPANET 的早期，IP 地址的设计不够合理。</p> <ol> <li> <strong>IP 地址空间的利用率有时很低</strong>。每个 A 类地址网络可连接的主机数超过 1000 万，而每个 B 类地址网络可连接的主机数也超过 6 万。有的单位申请到了一个 B 类地址网络，但所连接的主机数并不多，可是又不愿意申请一个足够使用的 C 类地址，理由是考虑到今后可能的发展。IP 地址的浪费，还会使 IP 地址空间的资源过早地被用完。</li> <li>给每个物理网络分配一个网络号会<strong>使路由表变得太大</strong>因而使网络性能变坏。每个路由器都应当能够从路由表查出应怎样到达其他网络的下一跳路由器。因此，互联网中的网络数越多，路由器的路由表的项目数也就越多。这样，即使我们拥有足够多的 IP 地址资源可以给每个物理网络分配一个网络号，也会导致路由器的路由表中的项目数过多。这不仅增加了路由器的成本（需要更多的存储空间），而且使查找路由时耗费更多的时间，同时也使路由器之间定期交换的路由信息急剧增加，因而使路由器和整个互联网的性能都下降了。</li> <li> <strong>两级 IP 地址不够灵活</strong>。有时情况紧急，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必事先到互联网管理机构去申请新的网络号。原来的两级 IP 地址无法做到这一点。</li> </ol> <p>为解决上述问题，在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级 IP 地址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做<strong>划分子网</strong>（subnetting）[RFC 950]，或<strong>子网寻址</strong>或<strong>子网路由选择</strong>。划分子网已成为互联网的正式标准协议。</p> <p>划分子网的基本思路如下：</p> <ol> <li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个<strong>子网</strong>（subnet）。划分子网纯属一个单位内部的事情。本单位以外的网络<strong>看不见</strong>这个网络是由多少个子网组成，因为这个单位对<strong>外仍然表现为一个网络</strong>。</li> <li> <p>划分子网的方法是从网络的主机号借用若干位作为子网号（subnet-id），当然主机号也就相应减少了同样的位数。于是两级 IP 地址在<strong>本单位内部</strong>就变为<strong>三级</strong> IP 地址：网络号、子网号和主机号。也可以用以下记法来表示： \(IP 地址 ::== {&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}\)</p> </li> <li>凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。</li> </ol> <p>下面用例子说明划分子网的概念。图 4-18 表示某单位拥有一个 B 类 IP 地址，网络地址是 145.13.0.0（网络号是 145.13）。凡目的地址为 145.13.x.x 的数据报都被送到这个网络上的路由器 $R_1$。</p> <p><img src="/assets/images/computer-network/a-b-network.png" alt="一个 B 类网络 145.13.0.0"> <em>图 4-18 一个 B 类网络 145.13.0.0</em></p> <p>现把图 4-18 的网络划分为三个子网（图 4-19）。这里假定子网号占用 8 位，因此在增加了子网号后，主机号就只有 8 位。所划分的三个子网分别是：145.13.3.0，145.13.7.0 和 145.13.21.0 。在划分子网后，整个网络对外部仍表现为一个网络，其网络地址仍为 145.13.0.0。但网络 145.13.0.0 上的路由器 $R_1$ 在收到外来的数据报后，再根据数据报的目的地址把它转发到相应的子网。</p> <p><img src="/assets/images/computer-network/a-subnet-of-b-network.png" alt="把图 4-18 的网络 145.13.0.0 划分为三个子网，但对外仍是一个网络"> <em>图 4-19 把图 4-18 的网络 145.13.0.0 划分为三个子网，但对外仍是一个网络</em></p> <p>总之，当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。</p> <h4 id="2子网掩码">（2）子网掩码</h4> <p>假定有一个数据报（其目的地址是 145.13.3.10）已经到达了路由器 $R_1$。那么这个路由器如何把它转发到子网 145.13.3.0 呢？</p> <p>我们知道，从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。因此必须另外想办法，这就是使用<strong>子网掩码</strong>（subnet mask）（见图4-20）。</p> <p><img src="/assets/images/computer-network/each-field-and-subnet-mask-of-the-ip-address.png" alt="IP 地址的各字段和子网掩码"> <em>图 4-20 IP 地址的各字段和子网掩码（以 145.13.3.30 为例）</em></p> <ul> <li>图 4-20（a）是 IP 地址为 145.13.3.10 的主机本来的两级 IP 地址结构。</li> <li>图 4-20（b）是这个两级 IP 地址的子网掩码。</li> <li>图 4-20（c）是同一地址的三级 IP 地址结构，也就是说，现在从原来 16 位的主机号中拿出 8 位作为子网号，而主机号由 16 位减少到 8 位。请注意，现在子网号为 3 的网络的<strong>网络地址</strong>是 145.13.3.0（既不是原来两级 IP 地址的网络地址 145.13.0.0，也不是简单的子网号 3）。为了使路由器 $R_1$ 能够很方便地从数据报中的目的 IP 地址中提取出所要找的子网的网络地址，路由器 $R_1$ 就要使用三级 IP 地址的子网掩码。</li> <li>图 4-20（d）是三级 IP 地址的子网掩码，它也是 32 位，由一串 24 个 1 和跟随的一串 8 个 0 组成。子网掩码中的 1 对应于 IP 地址中原来二级地址中的 16 位网络号加上新增加的 8 位子网号，而子网掩码中的 0 对应于现在的 8 位主机号。虽然 RFC 文档中没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用<strong>连续的 1</strong>，以免出现可能发生的差错。</li> <li>图 4-20（e）表示 $R_1$ 把三级 IP 地址的子网掩码和收到的数据报的目的 IP 地址 145.13.3.10 逐位相“与”（AND）（计算机进行这种逻辑 AND 运算是很容易的），得出了所要找的<strong>子网的网络地址</strong> 145.13.3.0。</li> </ul> <p>使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“<strong>与</strong>”运算（AND），就能够立即得出网络地址。这样在路由器处理到来的分组时就可采用同样的算法。</p> <p>归纳一下上述的要点。从网络 145.13.0.0 外面看，这就是一个普通的 B 类网络，其子网掩码为 16 个连 1 后面跟上 16 个连 0。但进入到这个网络后（即到了路由器 $R_1$），就看到了还有许多网络（即划分了子网后的许多网络），其网络地址是 145.13.x.0（这里 x 可以表示不同的数值），而这些网络的子网掩码都是 24 个连 1 后面跟上 8 个连 0。总之，在这个 B 类网络的外面和里面，看到的网络是不一样的。</p> <p>这里还要弄清一个问题，这就是：在不划分子网时，既然没有子网，为什么还要使用子网掩码？这就是为了更便于查找路由表。现在互联网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用<strong>默认子网掩码</strong>。默认子网掩码中的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相“与”（AND），就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。显然：</p> <ul> <li>A 类地址的默认子网掩码是255.0.0.0，或 0xFF000000（注：对应二进制为 11111111 00000000 00000000 00000000）。</li> <li>B 类地址的默认子网掩码是255.255.0.0，或 0xFFFF0000（注：对应二进制为 11111111 11111111 00000000 00000000）。</li> <li>C 类地址的默认子网掩码是255.255.255.0，或 0xFFFFFF00（注：对应二进制为 11111111 11111111 11111111 00000000）。</li> </ul> <p>图 4-21 是这三类 IP 地址的网络地址和相应的默认子网掩码。</p> <p><img src="/assets/images/computer-network/default-subnet-mask-of-class-a-b-and-c-ip-addresses.png" alt="A 类、B 类和 C 类 IP 地址的默认子网掩码"> <em>图 4-21 A 类、B 类和 C 类 IP 地址的默认子网掩码</em></p> <p><strong>子网掩码是一个网络或一个子网的重要属性</strong>。在 RFC 950 成为互联网的正式标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。我们以一个 B 类地址为例，说明可以有多少种子网划分的方法。在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的（见表 4-6）。</p> <p>| 子网号的位数 | 子网掩码 | 子网数 | 每个子网的主机数 | | :-: | :-: | :-: | :-: | :-: | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | <em>表 4-6 B 类地址的子网划分选择（使用固定长度子网）</em></p> <p>在表 4-6 中，子网数是根据子网号（subnet-id）计算出来的。若 subnet-id 有 n 位，则共有 $2^n$ 种可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数。</p> <p>表中的“子网号的位数”中没有 0，1，15 和 16这四种情况，因为这没有意义。</p> <p>注意，虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，<strong>现在全 1 和全 0 的子网号也可以使用了</strong>，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种用法。</p> <p>我们可以看出，若使用较少位数的子网号，则每一个子网上可连接的主机数就较多。反之，若使用较多位数的子网号，则子网的数目较多但每个子网上可连接的主机数就较少。因此我们可根据网络的具体情况（一共需要划分多少个子网，每个子网中最多有多少台主机）来选择合适的子网掩码。</p> <p>通过简单的计算，读者不难得到这样的结论：<strong>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数</strong>。例如，本来一个 B 类地址最多可连接 65534 台主机，但表 4-6 中任意一行的最后两项的乘积一定小于 65534。对 A 类和 C 类地址的子网划分也可得出类似的表格。</p> <p>【例 4-2】已知 IP 地址是 141.14.72.24，子网掩码是 255.255.192.0。试求网络地址。</p> <p>【解】子网掩码是 11111111 11111111 11000000 00000000。请注意，掩码的前两个字节都是全 1，因此网络地址的前两个字节可写为 141.14。子网掩码的第四字节是全 0，因此网络地址的第四字节是 0。可见本题仅需对地址中的第三字节进行计算。我们只要把 IP 地址和子网掩码的第三字节用二进制表示，就可以很容易地得出网络地址（图 4-22）。</p> <p><img src="/assets/images/computer-network/network-address-calculation.png" alt="网络地址的计算"> <em>图 4-22 网络地址的计算</em></p> <p>注意，在一个 IP 地址中不允许把十进制和二进制混合使用。图 4-22 中（b）和（d）的写法，仅仅为了说明解题的步骤，而并非表示平时可以这样书写 IP 地址。</p> <p>【例 4-3】在上例中，若子网掩码改为 255.255.224.0。试求网络地址，并讨论所得结果。</p> <p>【解】 用同样方法可得出网络地址是 141.14.64.0，和上例的结果相同（图 4-23）。</p> <p><img src="/assets/images/computer-network/different-subnet-masks-give-the-same-network-address.png" alt="不同的子网掩码得出相同的网络地址"> <em>图 4-23 不同的子网掩码得出相同的网络地址</em></p> <p>这个例子说明，同样的 IP 地址和不同的子网掩码可以得出相同的网络地址。但是，不同的掩码的效果是不同的。在例 4-2 中，子网号是 2 位，主机号是 14 位。在例 4-3 中，子网号是 3 位，主机号是 13 位。因此这两个例子中可划分的子网数和每个子网中的最大主机数都是不一样的。</p> <h3 id="32-使用子网时分组的转发">3.2 使用子网时分组的转发</h3> <p>使用子网划分后，路由表必须包含以下三项内容：<strong>目的网络地址</strong>、<strong>子网掩码</strong>和<strong>下一跳地址</strong>。在划分子网的情况下，路由器转发分组的算法如下：</p> <ol> <li>从收到的数据报的首部提取目的 IP 地址 D。</li> <li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 逐位相“<strong>与</strong>”（AND 操作），看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去），转发任务结束。否则就是间接交付，执行（3）。</li> <li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。</li> <li>对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和 D 逐位相“<strong>与</strong>”（AND 操作），其结果为 N。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行（5）。</li> <li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）。</li> <li>报告转发分组出错。</li> </ol> <p>【例 4-4】图 4-24 有三个子网，两个路由器，以及路由器 $R_1$ 中的部分路由表。现在源主机 $H_1$ 向目的主机 $H_2$ 发送分组。试讨论 $R_1$ 收到 $H_1$ 向 $H_2$ 发送的分组后查找路由表的过程。</p> <p><img src="/assets/images/computer-network/host-h1-sends-packets-to-h2.png" alt="主机 $H_1$ 向 $H_2$ 发送分组"> <em>图 4-24 主机 $H_1$ 向 $H_2$ 发送分组</em></p> <p>【解】源主机 $H_1$ 向目的主机 $H_2$ 发送的分组的目的地址是 $H_2$ 的 IP 地址 128.30.33.138。源主机 $H_1$ 首先要进行的操作是要判断：发送的这个分组，是在本子网上进行直接交付还是要通过本子网上的路由器进行间接交付？</p> <p>源主机 $H_1$ 把本子网的“子网掩码 255.255.255.128”与目的主机 $H_2$ 的“IP 地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），得出 128.30.33.128，它不等于 $H_1$ 的网络地址（128.30.33.0）。这说明 $H_2$ 与 $H_1$ 不在同一个子网上。因此 $H_1$ 不能把分组直接交付 $H_2$，而必须交给子网上的默认路由器 $R_1$，由 $R_1$ 来转发。</p> <p>路由器 $R_1$ 在收到一个分组后，就在其路由表中逐行寻找有无匹配的网络地址。</p> <p>先看 $R_1$ 路由表中的第一行。用这一行的“子网掩码 255.255.255.128”和收到的分组的“目的地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），得出 128.30.33.128。然后和这一行给出的目的网络地址 128.30.33.0 进行比较。但比较的结果不一致（即不匹配）。</p> <p>用同样方法继续往下找第二行。用第二行的“子网掩码 255.255.255.128”和该分组的“目的地址 128.30.33.138”逐位相“与”（即逐位进行 AND 操作），结果也是 128.30.33.128。这个结果和第二行的目的网络地址 128.30.33.128 相匹配，说明这个网络（子网 2） 就是收到的分组所要寻找的目的网络。于是不需要再继续查找下去。$R_1$ 把分组从接口 1 直接交付主机 $H_2$（它们都在一个子网上）。</p> <h3 id="33-无分类编址-cidr构造超网">3.3 无分类编址 CIDR（构造超网）</h3> <h4 id="1网络前缀">（1）网络前缀</h4> <p>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：</p> <ol> <li>B 类地址在 1992 年已分配了近一半，眼看很快就将全部分配完毕!</li> <li>互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。</li> <li>整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽了。</li> </ol> <p>当时预计前两个问题将在 1994 年变得非常严重。因此 IETF 很快就研究出采用无分类编址的方法来解决前两个问题。IETF 认为上面的第三个问题属于更加长远的问题，因此专门成立 IPv6 工作组负责研究解决新版本 IP 协议的问题。</p> <p>其实早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用<strong>变长子网掩码</strong> VLSM（Variable Length Subnet Mask）可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出<strong>无分类编址</strong>方法，它的正式名字是无分类域间路由选择 CIDR（Classless Inter-Domain Routing，CIDR 的读音是“sider”）。</p> <p>CIDR 最主要的特点有两个：</p> <ol> <li> <strong>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念</strong>，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是“<strong>网络前缀</strong>”（network-prefix）（或简称为“前缀”），用来指明网络，后面部分则用来指明主机。因此 CIDR 使 IP 地址从三级编址（使用子网掩码）又回到了两级编址，但这已是<strong>无分类的两级编址</strong>。其记法是：</li> </ol> \[IP 地址 ::= {&lt;网络前缀&gt;，&lt;主机号&gt;}\] <p>CIDR 还使用“<strong>斜线记法</strong>”（slash notation），或称为 <strong>CIDR 记法</strong>，即在 IP 地址后面加上斜线“/”，然后写上网络前缀所占的位数。</p> <ol> <li>CIDR 把网络前缀都相同的连续的 IP 地址组成一个“CIDR <strong>地址块</strong>”。我们只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。例如，已知 IP 地址 128.14.35.7/20 是某 CIDR 地址块中的一个地址，现在把它写成二进制表示，其中的前 20 位是网络前缀（用粗体和下划线表示出），而前缀后面的 12 位是主机号：</li> </ol> \[128.14.35.7/20 = \underline{10000000 00001110 0010}0011 00000111\] <p>这个地址所在的地址块中的最小地址和最大地址可以很方便地得出：</p> <table> <thead> <tr> <th>最小地址</th> <th>128.14.32.0</th> <th>$\underline{10000000 00001110 0010}0000 00000000$</th> </tr> </thead> <tbody> <tr> <td>最大地址</td> <td>128.14.47.255</td> <td>$\underline{10000000 00001110 0010}1111 11111111$</td> </tr> </tbody> </table> <p>当然，以上这两个特殊地址的主机是全和全 1 的地址。一般并不使用。通常只使用在这两个特殊地址之间的地址。不难看出，这个地址块共有 $2^{12}$ 个地址。我们可以用地址块中的最小地址和网络前缀的位数指明这个地址块。例如，上面的地址块可记为 128.14.32.0/20。在不需要指出地址块的起始地址时，也可把这样的地址块简称为“/20 地址块”。</p> <p>为了更方便地进行路由选择，CIDR 使用 32 位的<strong>地址掩码</strong>（address mask）。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为子网掩码。例如，/20 地址块的地址掩码是：11111111 11111111 11110000 00000000（20 个连续的 1）。<strong>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数</strong>。</p> <p>注意，“CIDR 不使用子网”是指 CIDR 并没有在 32 位地址中指明若干位作为子网字段。但分配到一个 CIDR 地址块的单位，仍然可以在本单位内根据需要划分出一些子网。这些子网也都只有一个网络前缀和一台主机号字段，但子网的网络前缀比整个单位的网络前缀要长些。例如，某单位分配到地址块/20，就可以再继续划分为 8 个子网（即需要从主机号中借用 3 位来划分子网）。这时每个子网的网络前缀就变成 23 位（原来的 20 位加上从主机号借来的 3 位），比该单位的网络前缀多了 3 位。</p> <p>斜线记法还有一个好处就是它除了表示一个 IP 地址外，还提供了其他一些重要信息。我们举例说明如下。</p> <p>例如，地址 192.199.170.82/27 不仅表示IP 地址是 192.199.170.82，而且还表示这个地址块的网络的前缀有 27 位（剩下的 5 位是主机号），因此这个地址块包含 32 个 IP 地址（232）。通过简单的计算还可得出，这个地址块的最小地址是192.199.170.64，最大地址是 192.199.170.95。具体的计算方法是这样的。找出地址掩码中 1 和 0 的交界处发生在地址中的哪个字节。现在是在第四个字节。因此只要把这一个字节的十进制 82 用二进制表示即可。十进制 82 的二进制是 01010010，取其前 3 位（这 3 位加上前 3 个字节的 24 位等于前缀的 27 位），再把后面 5 位都写成 0，即 $010\underline{00000}$，等于十进制的 64。这就找出了地址块的最小地址 192.199.170.64。再把地址的第四字节的最后 5 位都置 1，即 $010\underline{11111}$，等于十进制的 95，这就找出了地址块中的最大地址 192.199.170.95。</p> <p>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong>（route aggregation），它使得路由表中的一个项目可以表示原来传统分类地址的很多个（例如上千个）路由。路由聚合也称为<strong>构成超网</strong>（supernetting）。路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p> <p>CIDR 记法有多种形式，例如，地址块 10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。另一种简化表示方法是在网络前缀的后面加一个星号 <code class="language-plaintext highlighter-rouge">*</code>，如：</p> \[00001010 00*\] <p>意思是：在星号 <code class="language-plaintext highlighter-rouge">*</code> 之前是网络前缀，而星号 <code class="language-plaintext highlighter-rouge">*</code> 表示 IP 地址中的主机号，可以是任意值。</p> <p>前缀位数不是 8 的整数倍时，需要进行简单的计算才能得到一些地址信息。</p> <p>表 4-7 给出了最常用的 CIDR 地址块。表中的 K 表示 $2^{10}$ 即 1024。网络前缀小于 13 或大于 27 都较少使用。在“包含的地址数”中没有把全 1 和全 0 的主机号除外。</p> <p>| CIDR 前缀长度 | 点分十进制 | 包含的地址数 | 相当于包含分类的网络数 | | :-: | :-: | :-: | :-: | | /13 | 255.248.0.0 | 512 K | 8 个 B 类或 2048 个 C 类 | | /14 | 255.252.0.0 | 256 K | 4 个 B 类或 1024 个 C 类 | | /15 | 255.254.0.0 | 128 K | 2 个 B 类或 512 个 C 类 | | /16 | 255.255.0.0 | 64 K | 1 个 B 类或 256 个 C 类 | | /17 | 255.255.128.0 | 32 K | 128 个 C 类 | | /18 | 255.255.192.0 | 16 K | 64个 C 类 | | /19 | 255.255.224.0 | 8 K | 32 个 C 类 | | /20 | 255.255.240.0 | 4 K | 16 个 C 类 | | /21 | 255.255.248.0 | 2 K | 8 个 C 类 | | /22 | 255.255.252.0 | 1 K | 4 个 C 类 | | /23 | 255.255.254.0 | 512 | 2 个 C 类 | | /24 | 255.255.255.0 | 256 | 1 个 C 类 | | /25 | 255.255.255.128 | 128 | 1/2 个 C 类 | | /26 | 255.255.255.192 | 64 | 1/4 个 C 类 | | /27 | 255.255.255.224 | 32 | 1/8 个 C 类 | <em>表 4-7 常用的 CIDR 地址块</em></p> <p>从表 4-7 可看出，每一个 CIDR 地址块中的地址数一定是 2 的整数次幂。除最后几行外，CIDR 地址块都包含了多个 C 类地址（是一个 C 类地址的 $2^n$ 倍，n 是整数），这就是“<strong>构成超网</strong>”这一名词的来源。</p> <p>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。然而在分类地址的环境中，向一个部门分配 IP 地址，就只能以 <code class="language-plaintext highlighter-rouge">/8</code>，<code class="language-plaintext highlighter-rouge">/16</code> 或 <code class="language-plaintext highlighter-rouge">/24</code> 为单位来分配。这就很不灵活。</p> <p>图 4-25 给出的是 CIDR 地址块分配的例子。假定某 ISP 已拥有地址块 206.0.64.0/18（相当于有 64 个 C 类网络）。现在某大学需要 800 个 IP 地址。ISP 可以给该大学分配一个地址块 206.0.68.0/22，它包括 1024（即 $2^{10}$） 个 IP 地址，相当于 4 个连续的 C 类 <code class="language-plaintext highlighter-rouge">/24</code> 地址块，占该 ISP 拥有的地址空间的 1/16。这个大学然后可自由地对本校的各系分配地址块，而各系还可再划分本系的地址块。CIDR 的地址块分配有时不易看清，这是因为网络前缀和主机号的界限不是恰好出现在整数字节处。只要写出地址的二进制表示（从图中的地址块的二进制表示中可看出，实际上只需要将其中的一个关键字节转换为二进制的表示即可），弄清网络前缀的位数，就不会把地址块的范围弄错。</p> <p><img src="/assets/images/computer-network/example-for-dividing-cidr-address-blocks.png" alt="CIDR 地址块划分举例"> <em>图 4-25 CIDR 地址块划分举例</em></p> <p>从图 4-25 可以清楚地看出<strong>地址聚合</strong>的概念。这个 ISP 共拥有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，就只需用路由聚合后的一个项目 206.0.64.0/18 就能找到该 ISP。同理，这个大学共有 4 个系。在 ISP 内的路由器的路由表中，也需使用 206.0.68.0/22 这个项目。这个项目好比是大学的收发室。凡寄给这个大学任何一个系的邮件，邮递员都不考虑大学各个系的地址，而是把这些邮件集中投递到大学的收发室，然后由大学的收发室再进行下一步的投递。这样就减轻了邮递员的工作量（相当于简化了路由表的查找）。</p> <p>从图 4-25 下面表格中的二进制地址可看出，把四个系的路由聚合为大学的一个路由（即构成超网），是将网络前缀<strong>缩短</strong>。<strong>网络前缀越短，其地址块所包含的地址数就越多</strong>。而在三级结构的 IP 地址中，划分子网是使网络前缀变长。</p> <h4 id="2最长前缀匹配">（2）最长前缀匹配</h4> <p>在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个 部分组成，因此在路由表中的项目也要有相应的改变。这时，每个项目由“网络前缀”和 “下一跳地址”组成。但是在查找路由表时可能会得到不止一个匹配结果。这样就带来一个 问题：我们应当从这些匹配结果中选择哪一条路由呢？ 正确的答案是：应当从匹配结果中选择具有最长网络前缀的路由。这叫做最长前缀匹 配（longest-prefix matching），这是因为网络前缀越长，其地址块就越小，因而路由就越具体 （more specific）。最长前缀匹配又称为最长匹配或最佳匹配。为了说明最长前缀匹配的概 念，我们仍以前面的例子来讨论。 假定大学下属的四系希望 ISP 把转发给四系的数据报直接发到四系而不要经过大学的路 由器，但又不愿意改变自己使用的 IP 地址块。因此，在 ISP 的路由器的路由表中，至少要 有以下两个项目，即206。0。68。0/22（大学）和206。0。71。128/25（四系）。现在假定 ISP 收到一 个数据报，其目的 IP 地址为D=206。0。71。130。把D分别和路由表中这两个项目的掩码逐位 相“与”（AND操作）。将所得的逐位 AND 操作的结果按顺序写在下面。 D 和 11111111 11111111 1111110000000000 逐位相“与”=206。0。68。0/22 匹配 D 和 11111111 11111111 11111111 10000000 逐位相“与”=206。0。71。128/25 匹配 不难看出，现在同一个 IP 地址 D 可以在路由表中找到两个目的网络（大学和四系）和 该地址相匹配。根据最长前缀匹配的原理，应当选择后者，把收到的数据报转发到后一个目 的网络（四系），即选择两个匹配的地址中更具体的一个。 从以上的讨论可以看出，如果IP 地址的分配一开始就采用 CIDR，那么我们可以按网 络所在的地理位置来分配地址块，这样就可大大减少路由表中的路由项目。例如，可以将世 界划分为四大地区，每一地区分配一个 CIDR 地址块： 地址块 194/7 （194。0。0。0至195。255。255。255）分配给欧洲； 地址块 198/7（198。0。0。0至199。255。255。255）分配给北美洲； 地址块 200/7 （200。0。0。0至201。255。255。255）分配给中美洲和南美洲； 地址块 202/7 （202。0。0。0至203。255。255。255）分配给亚洲和太平洋地区。 上面的每一个地址块包含有约3200 万个地址。这种分配地址的方法就使得IP地址与地 理位置相关联。它的好处是可以大大压缩路由表中的项目数。例如，凡是从中国发往北美的</p> <p>IP数据报（不管它是地址块198/7中的哪一个地址）都先送交位于美国的一个路由器，因此 在路由表中使用一个项目就行了。 但是，在使用 CIDR 之前，互联网的地址管理机构没有按地理位置来分配 IP 地址。现 在要把已分配出的IP 地址收回再重新分配是件十分困难的事，因为这牵涉到很多正在工作 的主机必须改变其 IP 地址。尽管这样，CIDR 的使用已经推迟了 IP 地址耗尽的日期。 3。使用二叉线索查找路由表 使用 CIDR 后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。当路 由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。例如， 连接路由器的线路的速率为10Gbit/s，而分组的平均长度为2000 bit，那么路由器就应当平均 每秒钟能够处理 500万个分组（常记为5Mpps）。或者说，路由器处理一个分组的平均时间只 有200 ns （1 ns = 10-秒）。因此，查找每一个路由所需的时间是非常短的。可见在路由表中 必须使用很好的数据结构和使用先进的快速查找算法，这一直是人们积极研究的热门课题。 对无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。例 如，给定一个目的地址 D。对每一个可能的网络前缀长度M，路由器从 D 中提取前 M 个位成 一个网络前缀，然后查找路由表中的网络前缀。所找到的最长匹配就对应于要查找的路由。 这种最简单的算法的明显缺点就是查找的次数太多。最坏的情况是路由表中没有这个 路由。在这种情况下，算法仍要进行32次（具有32位的网络前缀是一个特定主机路由）。 就是要找到一个传统的 B 类地址（即/16），也要查找 16次。对于经常使用的默认路由，这 种算法都要经历31次不必要的查找。 为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构 中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索（binary trie），它是一种 特殊结构的树。IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二 叉线索中的各个路径就代表路由表中存放的各个地址。 图 4-26 用一个例子来说明二叉线索的结构。图中给出了 5 个 IP 地址。为了简化二叉线 索的结构，可以先找出对应于每一个 IP 地址的唯一前缀（unique prefix）。所谓唯一前缀就是 在表中所有的 IP 地址中，该前缀是唯一的。这样就可以用这些唯一前缀来构造二叉线索。 在进行查找时，只要能够和唯一前缀相匹配就行了。 32位的IP地址 01000110 00000000 00000000 00000000 01010110 00000000 00000000 00000000 0 唯一前缀 0100 0101 01100001 00000000 00000000 00000000 10110000 00000010 00000000 00000000 011 10110 10111011 00001010 00000000 00000000 10111 1 图4-26 用5个前缀构成的二叉线索</p> <p>从二叉线索的根节点自顶向下的深度最多有32层，每一层对应于IP地址中的一位。 个 IP 地址存入二叉线索的规则很简单。先检查IP地址左边的第一位，如为0，则第一层的 节点就在根节点的左下方；如为 1，则在右下方。然后再检查地址的第二位，构造出第二层 的节点。依此类推，直到唯一前缀的最后一位。由于唯一前缀一般都小于32 位，因此用唯 一前缀构造的二叉线索的深度往往不到 32 层。图中较粗的折线就是前缀 0101 在这个二叉线 索中的路径。二叉线索中的小圆圈是中间节点，而在路径终点的小方框是叶节点（也叫做外 部节点）。每个叶节点代表一个唯一前缀。节点之间的连线旁边的数字表示这条边在唯一前 缀中对应的比特是0或1。 假定有一个 IP 地址是 10011011 01111010 00000000 00000000，需要查找该地址是否在 此二叉线索中。我们从最左边查起。很容易发现，查到第三个字符（即前缀 10 后面的 0） 时，在二叉线索中就找不到匹配的，说明这个地址不在这个二叉线索中。 以上只是给出了二叉线索这种数据结构的用法，而并没有说明“与唯一前缀匹配”和 “与网络前缀匹配”的关系。显然，要将二叉线索用于路由表中，还必须使二叉线索中的每 一个叶节点包含所对应的网络前缀和子网掩码。当搜索到一个叶节点时，就必须将寻找匹配 的目的地址和该叶节点的子网掩码进行逐位“与”运算，看结果是否与对应的网络前缀相匹 配。若匹配，就按下一跳的接口转发该分组。否则，就丢弃该分组。 总之，二叉线索只是提供了一种可以快速在路由表中找到匹配的叶节点的机制。但这 是否和网络前缀匹配，还要和子网掩码进行一次逻辑与的运算。 为了提高二叉线索的查找速度，广泛使用了各种压缩技术。例如，在图 4-26 中的最后 两个地址，其最前面的4位都是1011。因此，只要一个地址的前4位是1011，就可以跳过 前面4位（即压缩了4个层次）而直接从第5位开始比较。这样就可以减少查找的时间。当 然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由表时都可以提高查找 速度，因此这样做还是值得的。</p> <h2 id="四网际控制报文协议-icmp">四、网际控制报文协议 ICMP</h2> <p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了<strong>网际控制报文协议 ICMP</strong>（Internet Control Message Protocol）[RFC 792]。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议。但ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 报文格式如图 4-27 所示。</p> <p><img src="/assets/images/computer-network/icmp-packet-format.png" alt="ICMP 报文的格式"> <em>图 4-27 ICMP 报文的格式</em></p> <h3 id="41-icmp-报文的种类">4.1 ICMP 报文的种类</h3> <p>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</p> <p>ICMP 报文的前4个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4 个字节的内容与ICMP的类型有关。最后面是数据字段，其长度取决于ICMP的类型。表 4-8 给出了几种常用的ICMP报文类型。</p> <p>| ICMP 报文种类 | 类型的值 | ICMP 报文的类型 | | - | - | - | | 差错报告报文 | 3 | 终点不可达 | | 差错报告报文 | 11 | 时间超过 | | 差错报告报文 | 12 | 参数问题 | | 差错报告报文 | 5 | 改变路由（Redirect） | | 询问报文 | 8 或 0 | 回送（Echo）请求或回答 | | 询问报文 | 13 或 14 | 时间戳（Timestamp）请求或回答 | <em>表 4-8 几种常用的 ICMP报文类型</em></p> <p>ICMP 报文的代码字段是为了进一步区分某种类型中的几种不同情况。检验和字段用来检验整个 ICMP报文。我们应当还记得，IP数据报首部的检验和并不检验 IP 数据报的内容，因此不能保证经过传输的ICMP报文不产生差错。</p> <p>表4-8 给出的 ICMP差错报告报文共有四种，即：</p> <ol> <li>终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li> <li>时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li> <li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li> <li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li> </ol> <p>下面对改变路由报文进行简短的解释。我们知道，在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每个目的网络的最佳路由（通过和其他路由器交换路由信息）。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器R（而不是默认路由器）。</p> <p>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式（图 4-28）。把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段。再加上相应的 ICMP 差错报告报文的前 8 个字节，就构成了 ICMP 差错报告报文。提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号（对于 TCP 和 UDP）以及运输层报文的发送序号（对于 TCP）。这些信息对源点通知高层协议是有用的。整个 ICMP 报文作为 IP 数据报的数据字段发送给源点。</p> <p><img src="/assets/images/computer-network/the-content-of-the-data-field-of-an-icmp-error-report-packet.png" alt="ICMP 差错报告报文的数据字段的内容"> <em>图 4-28 ICMP 差错报告报文的数据字段的内容</em></p> <p>下面是不应发送 ICMP 差错报告报文的几种情况。</p> <ul> <li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li> <li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。</li> <li>对具有多播地址的数据报，都不发送 ICMP 差错报告报文。</li> <li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 差错报告报文。</li> </ul> <p>常用的 ICMP 询问报文有两种，即：</p> <ol> <li> <strong>回送请求和回答</strong>：ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</li> <li> <strong>时间戳请求和回答</strong>：ICMP 时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年 1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。</li> </ol> <h3 id="42-icmp-的应用举例">4.2 ICMP 的应用举例</h3> <p>ICMP 的一个重要应用就是分组网间探测 PING （Packet InterNet Groper），用来测试两台 主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使 用网络层 ICMP 的一个例子。它没有通过运输层的TCP 或UDP。 Windows 操作系统的用户可在接入互联网后转入 MS DOS（点击“开始”，点击“运 行”，再键入“cmd”）。看见屏幕上的提示符后，就键入“ping hostname”（这里的 hostname 是要测试连通性的主机名或它的IP 地址），按回车键后就可看到结果。 图 4-29 给出了从南京的一台 PC 到新浪网的邮件服务器 mail。sina。com。cn 的连通性的测 试结果。PC 一连发出四个 ICMP 回送请求报文。如果邮件服务器 mail。sina。com。cn 正常工作 而且响应这个 ICMP 回送请求报文（有的主机为了防止恶意攻击就不理睬外界发送过来的这 种报文），那么它就发回 ICMP 回送回答报文。由于往返的 ICMP 报文上都有时间戳，因此 很容易得出往返时间。最后显示出的是统计结果：发送到哪个机器（IP 地址），发送的、收 到的和丢失的分组数（但不给出分组丢失的原因），以及往返时间的最小值、最大值和平均</p> <p>值。从得到的结果可以看出，第三个测试分组丢失了。</p> <div class="language-ssh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">C</span>：<span class="err">\</span>Documents and Settings<span class="err">\</span>XXR&gt;piny nail.sina.com.cn

<span class="k">Pinging</span> nail.sina.com.cn [202。108。43。230] with <span class="m">32</span> bytes of data：

<span class="k">Reply</span> from <span class="m">202</span>.108.43.230： bytes=32 time=368ms TTL=242
<span class="k">Reply</span> from <span class="m">202</span>.108.43.230；bytes=32 time=324ns TTL=242 Request timed out。
<span class="k">Reply</span> from <span class="m">202</span>.108.43.230： bytes <span class="m">32</span> time-374ms TTL-242

<span class="k">Ping</span> statistics for <span class="m">202</span>.108.43.230：Packets： Sent = <span class="m">4</span>。 Received = <span class="m">3</span>， Lost <span class="m">1</span> （25% loss）。
<span class="k">Approximate</span> round trip times in milli-seconds：Minimum <span class="m">368</span>ms， Maximum <span class="m">374</span>ns， Average <span class="m">372</span>ns
</code></pre></div></div> <p><em>图 4-29 用 PING 测试主机的连通性</em></p> <p>另一个非常有用的应用是 traceroute（这是 UNIX 操作系统中名字），它用来跟踪一个分 组从源点到终点的路径。在 Windows 操作系统中这个命令是 tracert。下面简单介绍这个程 序的工作原理。 Traceroute 从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的 UDP 用户数据报。第一个数据报 Pı 的生存时间 TTL 设置为 1。当 Pı 到达路径上的第一个 路由器 Rı 时，路由器R， 先收下它，接着把 TTL 的值减 1。由于 TTL 等于零了，Rı 就把 Pı 丢弃了，并向源主机发送一个 ICMP 时间超过差错报告报文。 源主机接着发送第二个数据报P2，并把 TTL 设置为2。P，先到达路由器Rı，Rı 收下后 把 TTL 减 1 再转发给路由器R2R2 收到 P2时 TTL 为1，但减1 后 TTL 变为零了。R，就丢 弃 P2，并向源主机发送一个 ICMP时间超过差错报告报文。这样一直继续下去。当最后一 个数据报刚刚到达目的主机时，数据报的TTL 是 1。主机不转发数据报，也不把 TTL 值减 1。但因 IP 数据报中封装的是无法交付的运输层的 UDP 用户数据报，因此目的主机要向源 主机发送 ICMP 终点不可达差错报告报文（见下一章的5。2。2节）。 这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的 ICMP 报文正 好给出了源主机想知道的路由信息——到达目的主机所经过的路由器的IP地址，以及到达 其中的每一个路由器的往返时间。图 4-30 是从南京的一个 PC 向新浪网的邮件服务器 mail。sina。com。cn 发出的 tracert 命令后所获得的结果。图中每一行有三个时间出现，是因为 对应于每一个 TTL 值，源主机要发送三次同样的 IP 数据报。 我们还应注意到，从原则上讲，IP 数据报经过的路由器越多，所花费的时间也会越 多。但从图 4-30 可看出，有时正好相反。这是因为互联网的拥塞程度随时都在变化，也很 难预料到。因此，完全有这样的可能：经过更多的路由器反而花费更少的时间。</p> <div class="language-ssh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">IC</span>：<span class="err">\</span>Documents and Settings<span class="err">\</span><span class="m">22</span>R&gt;tracert nail.sina.com.cn
<span class="k">Tracing</span> route to nail.sina.com.cn [202.188.43.230]
<span class="k">over</span> maximum of <span class="m">30</span> hops：
<span class="k">1</span> <span class="m">24</span>ms <span class="m">24</span>ms <span class="m">23</span>ms <span class="m">222</span>.95.172.1
<span class="k">2</span> <span class="m">23</span>ms <span class="m">24</span>ms <span class="m">22</span>ms <span class="m">221</span>.231.204.129
<span class="k">3</span> <span class="m">23</span>ms <span class="m">22</span>ms <span class="m">23</span>ms <span class="m">221</span>.231.206.9
<span class="k">4</span> <span class="m">24</span>ms <span class="m">23</span>ms <span class="m">24</span>ms <span class="m">202</span>.97.27.37
<span class="k">5</span> <span class="m">22</span>ms <span class="m">23</span>ms <span class="m">24</span>ns <span class="m">202</span>.97.41.226
<span class="k">6</span> <span class="m">28</span>ns <span class="m">28</span>ms <span class="m">28</span>ms <span class="m">202</span>.97.35.25
<span class="k">7</span> <span class="m">50</span>ns <span class="m">50</span>ms <span class="m">51</span>ms <span class="m">202</span>.97.36.86
<span class="k">8</span> <span class="m">308</span>ms <span class="m">311</span>ms <span class="m">310</span>ms <span class="m">219</span>.158.32.1
<span class="k">9</span> <span class="m">387</span>ns <span class="m">305</span>ms <span class="m">385</span>ns <span class="m">219</span>.158.13.17
<span class="k">10</span> <span class="m">164</span>ms <span class="m">164</span>ms <span class="m">165</span>ms <span class="m">202</span>.96.12.154
<span class="k">11</span> <span class="m">322</span>ms <span class="m">320</span>ms <span class="m">2988</span>ms <span class="m">61</span>.135.148.50
<span class="k">12</span> <span class="m">321</span>ms <span class="m">322</span>ms <span class="m">320</span>ms freenai143-230.sina.com [202.108.43.230]
<span class="k">Trace</span> conplete。
</code></pre></div></div> <p><em>图 4-30 用 tracert 命令获得到目的主机的路由信息</em></p> <h2 id="五互联网的路由选择协议">五、互联网的路由选择协议</h2> <p>本节将讨论几种常用的路由选择协议，也就是要讨论路由表中的路由是怎样得出的。</p> <h3 id="51-有关路由选择协议的几个基本概念">5.1 有关路由选择协议的几个基本概念</h3> <h4 id="1理想的路由算法">（1）理想的路由算法</h4> <p>路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点[BELL86]：</p> <ol> <li> <strong>算法必须是正确的和完整的</strong>。这里，“正确”的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li> <li> <strong>算法在计算上应简单</strong>。路由选择的计算不应使网络通信量增加太多的额外开销。</li> <li> <strong>算法应能适应通信量和网络拓扑的变化</strong>，这就是说，要有<strong>自适应性</strong>。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“<strong>稳健性</strong>”（robustness）。</li> <li> <strong>算法应具有稳定性</strong>。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li> <li> <strong>算法应是公平的</strong>。路由选择算法应对所有用户（除对少数优先级高的用户）都是平等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就明显地不符合公平性的要求。</li> <li> <strong>算法应是最佳的</strong>。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到“最佳”的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，<strong>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已</strong>。</li> </ol> <p>一个实际的路由选择算法，应尽可能接近于理想的算法。在不同的应用条件下，对以上提出的六个方面也可有不同的侧重。</p> <p>倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即<strong>静态路由选择策略</strong>与<strong>动态路由选择策略</strong>。</p> <ul> <li>静态路由选择也叫做<strong>非自适应路由选择</strong>，其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li> <li>动态路由选择也叫做<strong>自适应路由选择</strong>，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。</li> </ul> <h4 id="2分层次的路由选择协议">（2）分层次的路由选择协议</h4> <p>互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。由于以下两个原因，互联网采用分层次的路由选择协议：</p> <ol> <li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li> <li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。</li> </ol> <p>为此，可以把整个互联网划分为许多较小的<strong>自治系统</strong>（autonomous system），一般都记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是一个<strong>单一的和一致的路由选择策略</strong>[RFC 4271]。</p> <p>在目前的互联网中，一个大的 ISP 就是一个自治系统。这样，互联网就把路由选择协议划分为两大类，即：</p> <ol> <li> <strong>内部网关协议</strong> IGP（Interior Gateway Protocol）：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li> <li> <strong>外部网关协议</strong> EGP（External Gateway Protocol）：若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4（BGP-4）。</li> </ol> <p>自治系统之间的路由选择也叫做<strong>域间路由选择</strong>（interdomain routing），而在自治系统内部的路由选择叫做<strong>域内路由选择</strong>（intradomain routing）。</p> <p>图 4-31 是两个自治系统互连在一起的示意图。每个自治系统自己决定在本自治系统内部运行哪个内部路由选择协议（例如，可以是 RIP，也可以是 OSPF）。但每个自治系统都有一个或多个路由器（图中的路由器 $R_1$ 和 $R_2$）除运行本系统的内部路由选择协议外，还要运行自治系统间的路由选择协议（BGP-4）。</p> <p><img src="/assets/images/computer-network/autonomous-system-and-interior-gateway-protocol-and-external-gateway-protocol.png" alt="自治系统和内部网关协议、外部网关协议"> <em>图 4-31 自治系统和内部网关协议、外部网关协议</em></p> <p>总之，使用分层次的路由选择方法，可将互联网的路由选择协议划分为：</p> <ul> <li> <strong>内部网关协议</strong> IGP：具体的协议有多种，如 RIP 和 OSPF 等。</li> <li> <strong>外部网关协议</strong> EGP：目前使用的协议就是 BGP。</li> </ul> <p>对于比较大的自治系统，还可将所有的网络再进行一次划分。例如，可以构筑一个链路速率较高的主干网和许多速率较低的区域网。每个区域网通过路由器连接到主干网。当在一个区域内找不到目的站时，就通过路由器经过主干网到达另一个区域网，或者通过外部路由器到别的自治系统中去查找。</p> <h4 id="52-内部网关协议-rip">5.2 内部网关协议 RIP</h4> <p>1。工作原理 RIP （Routing Information Protocol）是内部网关协议IGP 中最先得到广泛使用的协议[RFC 1058]，它的中文名称叫做路由信息协议，但很少被使用。RIP 是一种分布式的基于距离向 量的路由选择协议，是互联网的标准协议，其最大优点就是简单。 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记 录（因此，这是一组距离，即“距离向量”）。RIP 协议将“距离”定义如下： 从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离 定义为所经过的路由器数加1。“加1”是因为到达目的网络后就进行直接交付，而到直接连 接的网络的距离已经定义为 1。例如在前面讲过的图 4-16 中，路由器R， 到网或网 2 的距</p> <p>离都是1（直接连接），而到网3的距离是2，到网4的距离是3。 RIP 协议的“距离”也称为“跳数”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多 只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型 互联网。 需要注意的是，到直接连接的网络的距离也可定义为0（采用这种定义的理由是：路由 器在和直接连接在该网络上的主机通信时，不需要经过另外的路由器。既然每经过一个路由 器要将距离加 1，那么不再经过路由器的距离就应当为0）。作者编写的其他版本的教材过去 也曾使用过这种定义。但两种不同的定义对实现 RIP 协议并无影响，因为重要的是要找出 最短距离，将所有的距离都加1或都减1，对选择最佳路由其实是一样的。 RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由（即 最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。 本节讨论的 RIP 协议和下一节要讨论的OSPF协议，都是分布式路由选择协议。它们的 共同特点就是每一个路由器都要不断地和其他一些路由器交换路由信息。我们一定要弄清以 下三个要点，即和哪些路由器交换信息？交换什么信息？在什么时候交换信息？ RIP 协议的特点是： （1）仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器， 那么这两个路由器就是相邻的。RIP协议规定，不相邻的路由器不交换信息。 （2） 路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。也就 是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到每个网络应经 过的下一跳路由器”。 （3）按固定的时间间隔交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由 信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路 由信息。 这里要强调一点：路由器在刚刚开始工作时，它的路由表是空的。然后路由器就得出 到直接相连的几个网络的距离（这些距离定义为 1）。接着，每一个路由器也只和数目非常 有限的相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知 道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 看起来 RIP 协议有些奇怪，因为“我的路由表中的信息要依赖于你的，而你的信息又 依赖于我的。”然而事实证明，通过这样的方式——“我告诉别人一些信息，而别人又告诉 我一些信息。我再把我知道的更新后的信息告诉别人，别人也这样把更新后的信息再告诉 我”，最后在自治系统中所有的结点都得到了正确的路由选择信息。在一般情况下，RIP 协 议可以收敛，并且过程也较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选 择信息的过程。 路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳 地址。路由表更新的原则是找出到每个目的网络的最短距离。这种更新算法又称为距离向量 算法。下面就是 RIP 协议使用的距离向量算法。</p> <p>2。距离向量算法 对每一个相邻路由器发送过来的RIP报文，进行以下步骤： （1） 对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一 跳”字段中的地址都改为X，并把所有的“距离”字段的值加1（见后面的解释1）。每一个 项目都有三个关键数据，即：到目的网络N，距离是d，下一跳路由器是X。 （2）对修改后的RIP报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络N，则把该项目添加到路由表中（见解释2）。 否则（即在路由表中有目的网络N，这时就再查看下一跳路由器地址） 若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目（见解释3）。 否则（即这个项目是：到目的网络，但下一跳路由器不是X） 若收到的项目中的距离d小于路由表中的距离，则进行更新（见解释4）， 否则什么也不做。（见解释5） （3） 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路 由器，即把距离置为16（距离为16表示不可达）。 （4） 返回。 上面给出的距离向量算法的基础就是 Bellman-Ford 算法（或Ford-Fulkerson 算法）。这 种算法的要点是这样的： 设 X 是结点 A到B的最短路径上的一个结点。若把路径A→B拆成两段路径A→X 和 X→B，则每一段路径A→X和X→B也都分别是结点A到X和结点X到B的最短路径。 下面是对上述距离向量算法的五点解释。 解释：这样做是为了便于进行本路由表的更新。假设从位于地址X的相邻路由器发来 的 RIP 报文的某一个项目是：“Net2， 3， Y”，意思是“我经过路由器Y到网络 Net2 的距离是 3”，那么本路由器就可推断出：“我经过X到网络Net2的距离应为3+1=4”。于是，本路 由器就把收到的 RIP报文的这一个项目修改为“Net2， 4， X”，作为下一步和路由表中原有项 目进行比较时使用（只有比较后才能知道是否需要更新）。读者可注意到，收到的项目中的 Y对本路由器是没有用的，因为Y不是本路由器的下一跳路由器地址。 解释 2： 表明这是新的目的网络，应当加入到路由表中。例如，本路由表中没有到目的 网络 Net2 的路由，那么在路由表中就要加入新的项目“Net2， 4， X”。 解释 3：为什么要替换呢？因为这是最新的消息，要以最新的消息为准。到目的网络的 距离有可能增大或减小，但也可能没有改变。例如，不管原来路由表中的项目是“Net2， 3， X”还是“Net2，5，X”，都要更新为现在的“Net2， 4， X”。 解释4：例如，若路由表中已有项目“Net2， 5， P”，就要更新为“Net2， 4， X”。因为到网 络 Net2 的距离原来是5，现在减到4，更短了。 解释5： 若距离更大了，显然不应更新。若距离不变，更新后得不到好处，因此也不更新。 【例4-5】已知路由器R6有表4-9（a）所示的路由表。现在收到相邻路由器R4发来的路 由更新信息，如表4-9（b）所示。试更新路由器R6的路由表。</p> <p>表4-9（a） 路由器 Rs 的路由表 目的网络 Net2 距离 3 下一跳路由器 R4 Net3 4 Rs 。。。 表4-9（b） R4发来的路由更新信息 目的网络 Netl 距离 3 Net2 4 Net3 下一跳路由器 R₁ R2 1 直接交付 【解】 如同路由器一样，我们不需要知道该网络的拓扑。 先把表4-9（b）中的距离都加1，并把下一跳路由器都改为R4。得出表4-9（c）。 表4-9（c） 修改后的表4-9（b） 目的网络 距离 下一跳路由器 Netl 4 R4 Net2 5 R4 Net3 2 R4 把这个表的每一行和表4-9（a）进行比较。 第一行在表4-9（a）中没有，因此要把这一行添加到表4-9（a）中。 第二行的 Net2 在表4-9（a）中有，且下一跳路由器也是 R4。因此要更新（距离增大了）。 第三行的 Net3 在表4-9（a）中有，但下一跳路由器不同。于是就要比较距离。新的路由 信息的距离是2，小于原来表中的4，因此要更新。 这样，得出更新后的R的路由表如表4-9（d）所示。 表4-9（d） 路由器R6更新后的路由表 目的网络 距离 下一跳路由器 Net1 4 R4 Net2 5 R4 Net3 2 R4 RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并 不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最 少）。这里还应注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由 于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p> <p>3。 RIP 协议的报文格式 现在较新的 RIP 版本是1998年11 月公布的 RIP2 [RFC2453]（已成为互联网标准），新 版本协议本身并无多大变化，但性能上有些改进。RIP2 可以支持变长子网掩码和无分类域 间路由选择 CIDR。此外，RIP2还提供简单的鉴别过程支持多播。 图 4-32 是 RIP2 的报文格式，它和RIP1 的首部相同，但后面的路由部分不一样。从图 4-32 还可看出，RIP 协议使用运输层的用户数据报 UDP 进行传送（使用 UDP 的端口 520。 端口的意义见 5。2。2节）。 4 字节 命令 版本 必为0 4 字节 地址标识符 路由标记 网络地址 路由信息 子网掩码 下一跳路由器地址 （20字节/路由） 可重复出现 最多 25 个 首部 路由部分 距离（1-16） IP UDP 首部 首部 RIP报文 UDP 用户数据报 IP数据报 图4-32RIP2的报文格式 RIP 报文由首部和路由部分组成。 RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1表示请求路由信 息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为 0”是为了4字节字的对齐。 RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址 族标识符（又称为地址类别）字段用来标志所使用的地址协议。如采用 IP 地址就令这个字 段的值为2（原来考虑RIP也可用于其他非 TCP/IP 协议的情况）。路由标记填入自治系统号 ASN （Autonomous System Number），这是考虑使RIP 有可能收到本自治系统以外的路由选 择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的 距离。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是4+20× 25 = 504 字节。如超过，必须再用一个RIP报文来传送。 RIP2 还具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息（20 字 节）的位置用作鉴别。这时应将地址族标识符置为全1（即0xFFFF），而路由标记写入鉴别 类型，剩下的 16字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放 入24个路由信息。</p> <p>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所 有的路由器。我们可以用图 4-33 的简单例子来说明。设三个网络通过两个路由器互连起 来，并且都已建立了各自的路由表。图中路由器交换的信息只给出了我们感兴趣的一行内 容。路由器 Rı 中的“1， 1， 直接”表示“到网1的距离是1，直接交付”。路由器 R№ 中的“1， 2， Rı”表示“到网1的距离是2，下一跳经过 Rı”。 现在假定路由器 R， 到网 1 的链路出了故障，Rı 无法到达网 1。于是路由器 Rı 把到网 1 的距离改为 16（表示到网 1 不可达），因而在 Rı的路由表中的相应项目变为“1，16，直 接”。但是，很可能要经过30秒钟后，才把更新信息发送给R2。然而R，可能已经先把自 己的路由表发送给了R，其中有“1， 2， Rı”这一项。 | 1，1，直接 1， 2， R₁ 正常情况 网1 网2 网了 R₁ R₂ 网1出故障 网 2 网了 R2 R₁ 1，16，直接 1， 2， R₁ 1， 3， R， 1，4， R₁ 1， 5， R， D ： 1， 16， R， → 1， 16， R₁ 图4-33 RIP协议的缺点：坏消息传播得慢 Rı 收到 R2 的更新报文后，误认为可经过R，到达网1，于是把收到的路由信息“1，2， Rı”修改为：“1， 3， Rı”，表明“我到网1的距离是 3，下一跳经过R”，并把更新后的信息 发送给 R2。 同理，R，接着又更新自己的路由表为“1， 4， Rı”，以为“我到网 1 距离是 4，下一跳经 过 Rı”。 这样的更新一直继续下去，直到 R 和R2 到网 1的距离都增大到16时，R 和R2 才知道 原来网1是不可达的。RIP 协议的这一特点叫做：好消息传播得快，而坏消息传播得慢。网 络出故障的传播时间往往需要较长的时间（例如数分钟）。这是RIP 的一个主要缺点。 但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。 为了使坏消息传播得更快些，可以采取多种措施。例如，让路由器记录收到某特定路 由信息的接口，而不让同一路由信息再通过此接口向反方向传送。 总之，RIP 协议最大的优点就是实现简单，开销较小。但 RIP 协议的缺点也较多。首 先，RIP 限制了网络的规模，它能使用的最大距离为15（16表示不可达）。其次，路由器之 间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最 后，“坏消息传播得慢，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使 用下一节所述的 OSPF 协议。然而目前在规模较小的网络中，使用 RIP 协议的仍占多数。</p> <p>4。5。3 内部网关协议 OSPF 1。 OSPF 协议的基本特点 这个协议的名字是开放最短路径优先 OSPF （Open Shortest Path First）。它是为克服 RIP 的缺点在 1989年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 的第二个版本OSPF2 已成为互联网标准协议 [RFC 2328]。关于OSPF 可参阅专著[MOY98]，[HUIT95]。 请注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径 优先”。实际上，所有的在自治系统内部使用的路由选择协议（包括RIP 协议）都是要寻找 一条最短的路径。 OSPF 最主要的特征就是使用分布式的链路状态协议（link state protocol），而不是像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样： （1）向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法（flooding），这就是 路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息 发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区 域中所有的路由器都得到了这个信息的一个副本。更具体的做法后面还要讨论。我们应注 意，RIP 协议是仅仅向自己相邻的几个路由器发送信息。 （2） 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道 的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的 “度量”（metric）。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都 由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。我们应注 意，对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。 （3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。 从上述的三个方面可以看出，OSPF 和 RIP 的工作原理相差较大。 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链 路状态数据库（link-state database），这个数据库实际上就是全网的拓扑结构图。这个拓扑结 构图在全网范围内是一致的（这称为链路状态数据库的同步）。因此，每一个路由器都知道 全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使 用链路状态数据库中的数据，构造出自己的路由表（例如，使用 Dijkstra 的最短路径路由算 法）。我们注意到，RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由 器，但却不知道全网的拓扑结构（只有到了下一跳路由器，才能知道再下一跳应当怎样 走）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。 OSPF 的更新过程收敛得快是其重要优点。</p> <p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的 范围，叫做区域（area）。图4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。当然，一个区域也不能太大，在一个区域内的路 由器最好不超过200个。 至其他自治系统 自治系统 AS 主干区域 0。0。0。0 R， R6 网6。 R&gt; Rs 网13 7 网23 R2 网43 网83 XX3 5 区域 0。0。0。3 区域0。0。0。1 区域0。0。0。2 图4-34 OSPF划分为两种不同的区域 划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是 整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域 的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以 外的区域进行通信，OSPF 使用层次结构的区域划分。在上层的区域叫做主干区域（backbone area）。主干区域的标识符规定为0。0。0。0。主干区域的作用是用来连通其他在下层的区域。从 其他区域来的信息都由区域边界路由器（area border router）进行概括。在图4-34 中，路由器 R3，R4 和R，都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。 在主干区域内的路由器叫做主干路由器（backbone router），如 R3，R4，Rs，R6 和R7。一个主 干路由器可以同时是区域边界路由器，如R3，R4 和R7。在主干区域内还要有一个路由器专 门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做自治系统边界路由器 （如图中的R。）。 采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复 杂了。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议 能够用于规模很大的自治系统中。这里，我们再一次地看到划分层次在网络设计中的重要 性。 OSPF 不用 UDP 而是直接用 IP 数据报传送（其IP数据报首部的协议字段值为89）。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以 不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据 报，而整个数据报就必须重传。 OSPF 分组使用24字节的固定长度首部（见图4-35），分组的数据部分可以是五种类型 分组中的一种。下面简单介绍 OSPF 首部各字段的意义。 （1） 版本 当前的版本号是2。 （2） 类型 可以是五种类型分组中的一种。 （3）分组长度 包括 OSPF 首部在内的分组长度，以字节为单位。 （4）路由器标识符 标志发送该分组的路由器的接口的 IP 地址。</p> <p>（5） 区域标识符 分组属于的区域的标识符。 （6） 检验和 用来检测分组中的差错。 （7） 鉴别类型 目前只有两种，0（不用）和1（口令）。 （8） 鉴别 鉴别类型为0时就填入0，鉴别类型为1则填入8个字符的口令。 位 0 8 16 31 版本 类型 分组长度 路由器标识符 区域标识符 检验和 鉴别类型 鉴 别 鉴 别 -24字节- OSPF 分组首部 类型1至类型5 的OSPF 分组 IP数据报首部一 OSPF 分组 IP数据报 图4-35 OSPF分组用IP数据报传送 除了以上的几个基本特点外，OSPF 还具有下列的一些特点： （1） OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实 时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此， OSPF 对于不同类型的业务可计算出不同的路由。链路的代价可以是1至65535中的任何一 个无量纲的数，因此十分灵活。商用的网络在使用OSPF时，通常根据链路带宽来计算链路 的代价。这种灵活性是RIP所没有的。 （2） 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路 径。这叫做多路径间的负载平衡（load balancing）。在代价相同的多条路径上分配通信量是 通信量工程中的简单形式。RIP只能找出到某个网络的一条路径。 （3） 所有在 OSPF 路由器之间交换的分组（例如，链路状态更新分组）都具有鉴别的功 能，因而保证了仅在可信赖的路由器之间交换链路状态信息。 （4） OSPF 支持可变长度的子网划分和无分类的编址 CIDR。 （5） 由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一 个 32 位的序号，序号越大状态就越新。OSPF规定，链路状态序号增长的速率不得超过每5 秒钟1次。这样，全部序号空间在600年内不会产生重复号。 2。 OSPF 的五种分组类型 OSPF 共有以下五种分组类型： （1） 类型 1，问候（Hello）分组，用来发现和维持邻站的可达性。 （2） 类型 2，数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库 中的所有链路状态项目的摘要信息。 （3） 类型 3，链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目 的详细信息。 （4）类型 4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。这 种分组是最复杂的，也是OSPF协议最核心的部分。路由器使用这种分组将其链路状态通知 给邻站。链路状态更新分组共有五种不同的链路状态[RFC2328]，这里从略。 （5） 类型 5，链路状态确认（Link State Acknowledgment）分组，对链路更新分组的确认。 OSPF 规定，每两个相邻路由器每隔10秒钟要交换一次问候分组。这样就能确知哪些 邻站是可达的。对相邻路由器来说，“可达”是最基本的要求，因为只有可达邻站的链路状 态信息才存入链路状态数据库（路由表就是根据链路状态数据库计算出来的）。在正常情况 下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由 器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重 新计算路由表。 其他的四种分组都是用来进行链路状态数据库的同步。所谓同步就是指不同路由器的 链路状态数据库的内容是一样的。两个同步的路由器叫做“完全邻接的”（fully adjacent）路 由器。不是完全邻接的路由器表明它们虽然在物理上是相邻的，但其链路状态数据库并没有 达到一致。 当一个路由器刚开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工 作，以及将数据发往相邻路由器所需的“代价”。如果所有的路由器都把自己的本地链路状 态信息对全网进行广播，那么各路由器只要将这些链路状态信息综合起来就可得出链路状态 数据库。但这样做开销太大，因此 OSPF 采用下面的办法。 OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态 摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了 数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对 方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网 同步的链路数据库就建立了。图 4-36 给出了OSPF 的基本操作，说明了两个路由器需要交 换各种类型的分组。 问候 确定可达性 达到数据库的同步 问候 数据库描述 数据库描述 数据库描述 数据库描述 新情况下的同步 链路状态请求 链路状态更新 链路状态确认 图4-36 OSPF 的基本操作 在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路 状态更新分组，用洪泛法向全网更新链路状态。OSPF 使用的是可靠的洪泛法，其要点见图 4-37 所示。设路由器R 用洪泛法发出链路状态更新分组。图中用一些小的箭头表示更新分 组。第一次先发给相邻的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上 游路由器除外。可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要 发送一次确认）。图中的空心箭头表示确认分组。 更新报文 R R R ACK报文 R 图4-37 用可靠的洪泛法发送更新分组 为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规 模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。由于 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于100 ms。 若 N 个路由器连接在一个以太网上，则每个路由器要向其他（N - 1）个路由器发送链路 状态信息，因而共有 N（N-1）个链路状态要在这个以太网上传送。OSPF 协议对这种多点接 入的局域网采用了指定的路由器（designated router）的方法，使广播的信息量大大减少。指定 的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。 4。5。4 外部网关协议 BGP 1989 年，公布了新的外部网关协议——边界网关协议 BGP。为简单起见，后面我们把 目前使用最多的版本 BGP-4 经常简写为 BGP。最近已经陆续发布了一些 BGP-4 的更新文 档，但目前 BGP-4仍然是草案标准[RFC 4271]。 我们首先应当弄清，在不同自治系统 AS 之间的路由选择为什么不能使用前面讨论过的 内部网关协议，如 RIP 或OSPF？ 我们知道，内部网关协议（如RIP 或OSPF）主要是设法使数据报在一个AS中尽可能 有效地从源站传送到目的站。在一个AS 内部也不需要考虑其他方面的策略。然而 BGP 使 用的环境却不同。这主要是因为以下的两个原因： 第一，互联网的规模太大，使得自治系统 AS 之间路由选择非常困难。连接在互联网主 干网上的路由器，必须对任何有效的IP 地址都能在路由表中找到匹配的目的网络。目前在 互联网的主干网路由器中，一个路由表的项目数早已超过了5万个网络前缀。如果使用链路 状态协议，则每一个路由器必须维持一个很大的链路状态数据库。对于这样大的主干网用 Dijkstra算法计算最短路径时花费的时间也太长。另外，由于自治系统 AS 各自运行自己选 定的内部路由选择协议，并使用本AS 指明的路径度量，因此，当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。例如，对某AS 来说，代价 为1000可能表示一条比较长的路由。但对另一AS代价为1000却可能表示不可接受的坏路 由。因此，对于自治系统 AS之间的路由选择，要用“代价”作为度量来寻找最佳路由也是 很不现实的。比较合理的做法是在自治系统之间交换“可达性”信息（即“可到达”或“不 可到达”）。例如，告诉相邻路由器：“到达目的网络N可经过自治系统 ASx”。 第二，自治系统 AS 之间的路由选择必须考虑有关策略。由于相互连接的网络的性能相 差很大，根据最短距离（即最少跳数）找出来的路径，可能并不合适。也有的路径的使用代 价很高或很不安全。还有一种情况，如自治系统 AS要发送数据报给自治系统 ASz，本来最 好是经过自治系统 AS3。但 AS， 不愿意让这些数据报通过本自治系统的网络，因为“这是他 们的事情，和我们没有关系。”但另一方面，自治系统 AS，愿意让某些相邻自治系统的数据 报通过自己的网络，特别是对那些付了服务费的某些自治系统更是如此。因此，自治系统之 间的路由选择协议应当允许使用多种路由选择策略。这些策略包括政治、安全或经济方面的 考虑。例如，我国国内的站点在互相传送数据报时不应经过国外兜圈子，特别是，不要经过 某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置 的，但这些策略并不是自治系统之间的路由选择协议本身。还可举出一些策略的例子，如： “仅在到达下列这些地址时才经过ASx”，“AS和AS， 相比时应优先通过 ASx”，等等。显 然，使用这些策略是为了找出较好的路径而不是最佳路径。 由于上述情况，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的 路由（不能兜圈子），而并非要寻找一条最佳路由。BGP 采用了路径向量（path vector）路由选 择协议，它与距离向量协议（如RIP）和链路状态协议（如OSPF）都有很大的区别。 在配置 BGP 时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 “BGP 发言人”。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是BGP边界路由器，但也可以不是BGP 边界路由器。 一个 BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息，就要先建立TCP 连接 （端口号为 179），然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会 话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使 用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两 个 BGP 发言人，彼此成为对方的邻站（neighbor）或对等站（peer）。 图 4-38 表示 BGP 发言人和自治系统 AS的关系的示意图。在图中画出了三个自治系统 中的 5 个 BGP 发言人。每一个 BGP 发言人除了必须运行 BGP 协议外，还必须运行该自治 系统所使用的内部网关协议，如 OSPF 或 RIP。 BGP BGP ASı 发言人 发言人 AS2 BGP 发言人 BGP 发言人 AS3 BGP 发言人 AS4 AS5 图4-38 BGP发言人和自治系统 AS的关系 边界网关协议 BGP所交换的网络可达性的信息就是要到达某个网络（用网络前缀表 示）所要经过的一系列自治系统。当BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。图 4-39 表示从图 4-38 的 AS 上的一个 BGP 发言人构造出的自治系统连通图，它是树形结构，不存 在回路。 AS， AS， AS AS ASF 图4-39 自治系统AS的连通图举例 在第 1 章的 1。2。2 节我们已经介绍了当前互联网的多级结构特点（图1-4）。这种多级结 构的网络拓扑决定了BGP路由选择协议的特点。 图 4-40 给出了一个 BGP 发言人交换路径向量的例子。自治系统 AS2 的BGP 发言人通 知主干网的 BGP 发言人：“要到达网络 Nı，N2，N3 N4可经过ASz。”主干网在收到这个通 知后，就发出通知：“要到达网络 Nı， N2， N3 和 N4 可沿路径（ASı，ASz）。”同理，主干网还 可发出通知：“要到达网络 Ns， N｡ 和N，可沿路径（ASı， AS3）。” 地区 ISP （ASz） 本地ISP（AS） N，N2 主干网 （AS） 本地ISP（AS） N3， N4 本地ISP（AS） Ns 地区 ISP （AS3） 本地 ISP（AS） No，N7 图4-40 BGP发言人交换路径向量的例子 从上面的讨论可看出，BGP 协议交换路由信息的结点数量级是自治系统个数量级， 这要比这些自治系统中的网络数少很多。要在许多自治系统之间寻找一条较好的路径，就是</p> <p>要寻找正确的 BGP 发言人（或边界路由器），而在每一个自治系统中 BGP 发言人（或边界 路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。 BGP 支持无分类域间路由选择 CIDR，因此 BGP 的路由表也就应当包括目的网络前 缀、下一跳路由器，以及到达该目的网络所要经过的自治系统序列。由于使用了路径向量的 信息，就可以很容易地避免产生兜圈子的路由。如果一个BGP 发言人收到了其他 BGP 发言 人发来的路径通知，它就要检查一下本自治系统是否在此通知的路径中。如果在这条路径 中，就不能采用这条路径（因为会兜圈子）。 在 BGP 刚刚运行时，BGP 的邻站是交换整个的BGP路由表。但以后只需要在发生变 化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。 在 RFC 4271 中规定了BGP-4 的四种报文： （1） OPEN（打开）报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。 （2）UPDATE（更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由。 （3）KEEPALIVE（保活）报文，用来周期性地证实邻站的连通性。 （4）NOTIFICATION（通知）报文，用来发送检测到的差错。 若两个邻站属于两个不同 AS，而其中一个邻站打算和另一个邻站定期地交换路由信 息，这就应当有一个商谈的过程（因为很可能对方路由器的负荷已很重因而不愿意再加重负 担）。因此，一开始向邻站进行商谈时就必须发送 OPEN 报文。如果邻站接受这种邻站关 系，就用 KEEPALIVE 报文响应。这样，两个 BGP 发言人的邻站关系就建立了。 一旦邻站关系建立了，就要继续维持这种关系。双方中的每一方都需要确信对方是存 在的，且一直在保持这种邻站关系。为此，这两个 BGP 发言人彼此要周期性地交换 KEEPALIVE 报文（一般每隔30秒）。KEEPALIVE 报文只有 19 字节长（只用 BGP 报文的 通用首部），因此不会造成网络上太大的开销。 UPDATE 报文是BGP 协议的核心内容。BGP 发言人可以用UPDATE 报文撤销它以前 曾经通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路 由时，每个更新报文只能增加一条。 BGP 可以很容易地解决距离向量路由选择算法中的“坏消息传播得慢”这一问题。当 某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很 容易选择出新的路由。距离向量算法往往不能给出正确的选择，是因为这些算法不能指出哪 些邻站到目的站的路由是独立的。 图 4-41 给出了 BGP报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度 为 19 字节。通用首部分为三个字段。标记（marker）字段为16字节长，用来鉴别收到的 BGP 报文（这是假定将来有人会发明出合理的鉴别方案）。当不使用鉴别时，标记字段要置为全 1。长度字段指出包括通用首部在内的整个 BGP报文以字节为单位的长度，最小值是 19， 最大值是 4096。类型字段的值为1到4，分别对应于上述四种 BGP报文中的一种。 OPEN 报文共有6个字段，即版本（1字节，现在的值是4）、本自治系统号（2 字节， 使用全球唯一的16 位自治系统号，由ICANN 地区登记机构分配）、保持时间（2 字节，以 秒计算的保持为邻站关系的时间）、BGP 标识符（4字节，通常就是该路由器的IP 地址）、 可选参数长度（1字节）和可选参数。</p> <p>字节 16 2 1 H 标 记 长度 类型 BGP报文通用首部 BGP报文主体部分 | TCP 首部 BGP 报文 IP 首部 TCP报文 图4-41 BGP报文具有通用的首部 UPDATE 报文共有5个字段，即不可行路由长度（2字节，指明下一个字段的长度）、 撤销的路由（列出所有要撤销的路由）、路径属性总长度（2 字节，指明下一个字段的长 度）、路径属性（定义在这个报文中增加的路径的属性）和网络层可达性信息 NLRI （Network Layer Reachability Information）。最后这个字段定义发出此报文的网络，包括网络 前缀的位数、IP 地址前缀。 KEEPALIVE 报文只有BGP的19字节长的通用首部。 NOTIFICATION 报文有3 个字段，即差错代码（1 字节）、差错子代码（1 字节）和差 错数据（给出有关差错的诊断信息）。 在讨论完路由选择之后，我们再来介绍路由器的构成。 4。5。5 路由器的构成 1。路由器的结构 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。 从路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路 由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组， 直到该分组到达终点为止。路由器的转发分组正是网络层的主要工作。图 4-42 给出了一种 典型的路由器的构成框图。 路由选择处理机 路由选择协议 路由选择 路由表 输入端口 输出端口 23元 3 分组处理 转发表 分组转发 输入端口 输出端口 1-2-3 交换结构 3 2 -1 图4-42 典型的路由器的结构（图中的数字1~3表示相应层次的构件） 部分。 从图 4-42 可以看出，整个的路由器结构可划分为两大部分：路由选择部分和分组转发 路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任 务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信 息而不断地更新和维护路由表。关于怎样根据路由选择协议构造和更新路由表，我们已在前 面的4。5。2至4。5。4节讨论过了。 分组转发部分是本节所要讨论的问题，它由三部分组成：交换结构、一组输入端口和 一组输出端口（请注意：这里的端口就是硬件接口）。下面分别讨论每一部分的组成。 交换结构（switching fabric）又称为交换组织，它的作用就是根据转发表（forwarding table） 对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构本 身就是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中 的网络”。 请注意“转发”和“路由选择”是有区别的。在互联网中，“转发”就是路由器根据转 发表把收到的 IP数据报从路由器合适的端口转发出去。“转发”仅仅涉及到一个路由器。但 “路由选择”则涉及到很多路由器，路由表则是许多路由器协同工作的结果。这些路由器按 照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态地改变所选择的路由，并 由此构造出整个的路由表。路由表一般仅包含从目的网络到下一跳（用 IP 地址表示）的映 射，而转发表是从路由表得出的。转发表必须包含完成转发功能所必需的信息。这就是说， 在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC 地址信息（如下一 跳的以太网地址）的映射。将转发表和路由表用不同的数据结构实现会带来一些好处，这是 因为在转发分组时，转发表的结构应当查找过程最优化，但路由表则需要对网络拓扑变化 的计算最优化。路由表总是用软件实现的，但转发表则甚至可用特殊的硬件来实现。请读者 注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，而可以笼统地都使 用路由表这一名词。 在图 4-42 中，路由器的输入和输出端口里面都各有三个方框，用方框中的 1， 2 和 3 分 别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按 照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理 模块。若接收到的分组是路由器之间交换路由信息的分组（如 RIP 或OSPF 分组等），则把 这种分组送交路由器的路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照 分组首部中的目的地址查找转发表，根据得出的结果，分组就经过交换结构到达合适的输出 端口。一个路由器的输入端口和输出端口就做在路由器的线路接口卡上。 输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分 散化，往往把复制的转发表放在每一个输入端口中（如图 4-42 中的虚线箭头所示）。路由选 择处理机负责对各转发表的副本进行更新。这些副本常称为“影子副本”（shadow copy）。分 散化交换可以避免在路由器中的某一点上出现瓶颈。 以上介绍的查找转发表和转发分组的概念虽然并不复杂，但在具体的实现中还是会遇 到不少困难。问题就在于路由器必须以很高的速率转发分组。最理想的情况是输入端口的处 理速率能够跟上线路把分组传送到路由器的速率。这种速率称为线速（line speed 或 wire speed）。可以粗略地估算一下。设线路是OC-48 链路，即 2。5 Gbit/s。若分组长度为256 字 节，那么线速就应当达到每秒能够处理 100 万以上的分组。现在常用 Mpps （百万分组每 秒）为单位来说明一个路由器对收到的分组的处理速率有多高。在路由器的设计中，怎样提 高查找转发表的速率是一个十分重要的研究课题。 当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个 后到的分组就必须在队列中排队等待，因而产生了一定的时延。图4-43 给出了在输入端口 的队列中排队的分组的示意图。 输入端口的处理 网络层处理 分组排队 数据链路层| · 物理层处理 处理 查表和转发 从线路接收分组 交换结构 图4-43 输入端口对线路上收到的分组的处理 我们再来观察在输出端口上的情况（图4-44）。输出端口从交换结构接收分组，然后把 它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上它就是一 个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组 就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给 物理层后发送到外部线路。 交换结构 向线路发送分组 输出端口的处理 网络层处理 分组排队 数据链路层 物理层处理· 处理 缓存管理 图4-44 输出端口把交换结构传送过来的分组发送到线路上 从以上的讨论可以看出，分组在路由器的输入端口和输出端口都可能会在队列中排队 等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少 到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。以前我们提到过的分 组丢失就是发生在路由器中的输入或输出队列产生溢出的时候。当然，设备或线路出故障也 可能使分组丢失。 2。交换结构 交换结构是路由器的关键构件[KURO13]。正是这个交换结构把分组从一个输入端口 转移到某个合适的输出端口。实现这样的交换有多种方法，图4-45 给出了三种常用的交 换方法。这三种方法都是将输入端口 I收到的分组转发到输出端口 Oz。下面简单介绍它 们的特点。 存储器 （a）通过存储器 -0-0-0 总线 （b）通过总线 互连网络 （c）通过互连网络 图4-45 三种常用的交换方法 最早使用的路由器就是利用普通的计算机，用计算机的 CPU 作为路由器的路由选择处 理机。路由器的输入和输出端口的功能和传统的操作系统中的I/O设备一样。当路由器的某 个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复 制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适 的输出端口的缓存中。若存储器的带宽（读或写）为每秒M个分组，那么路由器的交换速 率（即分组从输入端口传送到输出端口的速率）一定小于M/2。这是因为存储器对分组的读 和写需要花费的时间是同一个数量级。 许多现代的路由器也通过存储器进行交换，图4-45（a）的示意图表示分组通过存储器进 行交换。与早期的路由器的区别就是，目的地址的查找和分组在存储器中的缓存都是在输入 端口中进行的。Cisco 公司的 Catalyst 8500 系列交换机（有的公司把路由器也称为交换机） 和 Bay Network 公司的 Accelar 1200系列路由器就采用了共享存储器的方法。 图4-45（b）是通过总线进行交换的示意图。采用这种方式时，数据报从输入端口通过共 享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。但是，由于总线是 共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线 忙（因为总线正在传送另一个分组），则被阻塞而不能通过交换结构，并在输入端口排队等 待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的 限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品 都采用这种通过总线的交换方式。例如，Cisco 公司的 Catalyst 1900系列交换机就使用了带 宽达到 1 Gbit/s 的总线（叫做Packet Exchange Bus）。 图4-45（c）画的是通过纵横交换结构（crossbar switch fabric）进行交换。这种交换机构常称 为互连网络（interconnection network），它有 2N 条总线，可以使 N个输入端口和 N 个输出端 口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收 到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口 的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个 输出端口。但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到 达的分组就被阻塞，必须在输入端口排队。采用这种交换方式的路由器例子是 Cisco 公司的 12000系列交换路由器，它使用的互连网络的带宽达60Gbit/s。</p> <h2 id="六ipv6">六、IPv6</h2> <p>IP 是互联网的核心协议。现在使用的IP（即IPv4）是在20世纪70年代末期设计的。 互联网经过几十年的飞速发展，到2011年2月，IPv4的地址已经耗尽，ISP已经不能再申 请到新的IP 地址块了。我国在2014年至2015年也逐步停止了向新用户和应用分配IPv4地 址，同时全面开始商用部署 IPv6。 解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的IP，即 IPv6。到目 前为止，IPv6 还只是草案标准阶段[RFC2460，4862，4443]。有关向IPv6 转换的进展情况见 有关网站[W-NGTRANS]。 4。6。1 IPv6 的基本首部 IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组，而不是IPv4 的数据 报。为方便起见，本书仍采用数据报这一名词（[COME06]和[TANE11]也是这样做的）。 IPv6 所引进的主要变化如下： （1）更大的地址空间。IPv6 把地址从IPv4 的32 位增大到4倍，即增大到128位，使地 址空间增大了 26倍。这样大的地址空间在可预见的将来是不会用完的。 （2） 扩展的地址层次结构。IPv6 由于地址空间很大，因此可以划分为更多的层次。 （3） 灵活的首部格式。IPv6 数据报的首部和IPv4 的并不兼容。IPv6 定义了许多可选的 扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路 由器对扩展首部不进行处理（除逐跳扩展首部外）。 （4） 改进的选项。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选 项。但 IPv6 的首部长度是固定的，其选项放在有效载荷中。我们知道，IPv4 所规定的选项 是固定不变的，其选项放在首部的可变部分。 （5） 允许协议继续扩充。这一点很重要，因为技术总是在不断地发展（如网络硬件的更 新）而新的应用也还会出现。但我们知道，IPv4 的功能是固定不变的。 （6） 支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。 （7）支持资源的预分配。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。 （8） IPv6 首部改为8字节对齐（即首部长度必须是8字节的整数倍）。原来的IPv4 首部 是4字节对齐。 IPv6 数据报由两大部分组成，即基本首部（base header）和后面的有效载荷（payload）。有 效载荷也称为净负荷。有效载荷允许有零个或多个扩展首部（extension header），再后面是数 据部分（图4-46）。但请注意， 所有的扩展首部并不属于IPv6 数据报的首部。 IPv6 数据报 发送在前 基本首部 有 效 载 荷 40字节 不超过65535字节 扩展 首部1 扩展 首部N 数 据部 分 图4-46 具有多个可选扩展首部的IPv6数据报的一般形式 与 IPv4 相比，IPv6对首部中的某些字段进行了如下的更改： • 取消了首部长度字段，因为它的首部长度是固定的（40字节）。 取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。 • 取消了总长度字段，改用有效载荷长度字段。 • 取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。 • 把 TTL 字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致）。 取消了协议字段，改用下一个首部字段。 取消了检验和字段，这样就加快了路由器处理数据报的速度。我们知道，在数据链 路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的 用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确 传送到目的进程为止。因此在网络层的差错检测可以精简掉。 • 取消了选项字段，而用扩展首部来实现选项功能。 由于把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有8个（虽然首 部长度增大了一倍）。 下面解释 IPv6 基本首部中各字段的作用（参见图4-47）。 IPv6的 位0 4 12 16 24 31 版本 通信量类 流标号 有效载荷长度 下一个首部 跳数限制 基本首部 （40B） IPv6的 有效载荷 （至64KB） 源地址 （128位） 目的地址 （128位） 有效载荷（扩展首部/数据） 图4-47 40字节长的IPv6基本首部 （1） 版本（version） 占4位。它指明了协议的版本，对IPv6 该字段是6。 （2） 通信量类（traffic class） 占8位。这是为了区分不同的IPv6 数据报的类别或优先 级。目前正在进行不同的通信量类性能的实验。 （3） 流标号（flow label） 占 20 位。IPv6的一个新的机制是支持资源预分配，并且允 许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流（flow）的抽象概念。所 谓“流”就是互联网络上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音 频或视频传输），而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属 于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别 有用。对于传统的电子邮件或非实时数据，流标号则没有用处，把它置为0即可。关于流标 号可参考[RFC 6437]。 （4）有效载荷长度（payload length） 占 16 位。它指明IPv6数据报除基本首部以外的字 节数（所有扩展首部都算在有效载荷之内）。这个字段的最大值是64KB（65535字节）。 （5） 下一个首部（next header） 占8位。它相当于IPv4 的协议字段或可选字段。 • 当IPv6 数据报没有扩展首部时，下一个首部字段的作用和IPv4 的协议字段一样， 它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议（例如：6 或17分别表示应交付运输层TCP或UDP）。 当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。 占8位。用来防止数据报在网络中无限期地存在。源点在每 （6） 跳数限制（hop limit） 个数据报发出时即设定某个跳数限制（最大为 255 跳）。每个路由器在转发数据报时，要先 把跳数限制字段中的值减1。当跳数限制的值为零时，就要把这个数据报丢弃。 （7） 源地址 （8） 目的地址 占 128 位。是数据报的发送端的 IP 地址。 占 128 位。是数据报的接收端的 IP 地址。 下面我们介绍一下 IPv6 的扩展首部。 大家知道，IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上 的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。然 而实际上很多的选项在途中的路由器上是不需要检查的（因为不需要使用这些选项的信 息）。IPv6 把原来IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端 的源点和终点的主机来处理，而数据报途中经过的路由器都不处理这些扩展首部（只有一个 首部例外，即逐跳选项扩展首部），这样就大大提高了路由器的处理效率。 在 RFC 2460 中定义了以下六种扩展首部：（1）逐跳选项；（2） 路由选择；（3）分片；（4） 鉴别；（5） 封装安全有效载荷；（6） 目的站选项。 每一个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的第一 个字段都是 8 位的“下一个首部”字段。此字段的值指出了在该扩展首部后面的字段是什 么。当使用多个扩展首部时，应按以上的先后顺序出现。高层首部总是放在最后面。 4。6。2 IPv6 的地址 一般来讲，一个IPv6 数据报的目的地址可以是以下三种基本类型地址之一： （1） 单播（unicast） 单播就是传统的点对点通信。 （2） 多播（multicast） 多播是一点对多点的通信，数据报发送到一组计算机中的每一 个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。 （3） 任播（anycast） 这是 IPv6 增加的一种类型。任播的终点是一组计算机，但数据报 只交付其中的一个，通常是距离最近的一个。 IPv6 把实现 IPv6 的主机和路由器均称为结点。由于一个结点可能会使用多条链路与其 他的一些结点相连，因此一个结点可能有多个与链路相连的接口。这样，IPv6 给结点的每 一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当 到达该结点的目的地址。 在 IPv6 中，每个地址占128位，地址空间大于3。4x108。如果整个地球表面（包括陆 地和水面）都覆盖着计算机，那么IPv6 允许每平方米拥有7x103 个IP地址。如果地址分配 速率是每微秒分配100万个地址，则需要 101°年的时间才能将所有可能的地址分配完毕。 可见在想象到的将来，IPv6的地址空间是不可能用完的。 巨大的地址范围还必须使维护互联网的人易于阅读和操纵这些地址。IPv4 所用的点分 十进制记法现在也不够方便了。例如，一个用点分十进制记法的128位的地址为： 104。230。140。100。255。255。255。255。0。0。17。128。150。10。255。255 为了使地址再稍简洁些，IPv6使用冒号十六进制记法（colon hexadecimal notation，简写 为 colon hex），它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如，如果前 面所给的点分十进制数记法的值改为冒号十六进制记法，就变成了： 68E6：8C64：FFFF：FFFF：0：1180：960A： FFFF 在十六进制记法中，允许把数字前面的0省略。上面就把 0000 中的前三个0省略了。 冒号十六进制记法还包含两个技术使它尤其有用。首先，冒号十六进制记法可以允许 零压缩（zero compression），即一连串连续的零可以为一对冒号所取代，例如： 可压缩为： FF05：0：0：0：0：0：0：B3 FF05：：B3 为了保证零压缩有一个不含混的解释，规定在任一地址中只能使用一次零压缩。该技 术对已建议的分配策略特别有用，因为会有许多地址包含较长连续的零串。 其次，冒号十六进制记法可结合使用点分十进制记法的后缀。我们下面会看到这种结 合在 IPv4 向 IPv6的转换阶段特别有用。例如，下面的串是一个合法的冒号十六进制记法： 0：0：0：0：0：0：128。10。2。1 请注意，在这种记法中，虽然为冒号所分隔的每个值是两个字节（16位）的量，但每个点 分十进制部分的值则指明一个字节（8位）的值。再使用零压缩即可得出： ：： 128。10。2。1 下面再给出几个使用零压缩的例子。 1080：0：0：0：8：800：200C：417A 记为 FF01：0：0：0：0：0：0：101 （多播地址） 记为 0：0：0：0：0：0：0：1（环回地址） 1080：：8：800：200C：417A FF01：：101 记为 ：： 1 记为 ： ： 0：0：0：0：0：0：0：0（未指明地址） CIDR 的斜线表示法仍然可用。例如，60 位的前缀 12AB00000000CD3（十六进制表</p> <p>示的15个字符，每个字符代表4位二进制数字）可记为： 12AB 0000：0000：CD30：0000：0000：0000：0000/60 或12AB：：CD30：0：0：0：0/60 或12AB：0：0：CD30：：/60 （不能把16位地址CD30块中的最后的省略） 但不允许记为： 12AB：0：0：CD3/60 或 12AB：：CD30/60 （这是地址12AB：0：0：0：0：0：0：CD30的前60 位二进制） 或 12AB：：CD3/60 （这是地址12AB：0：0：0：0：0：0：0CD3的前60位二进制） IPv6 的地址分类见表4-10所示[RFC 4291]。 表4-10 IPv6 的地址分类 地址类型 未指明地址 环回地址 多播地址 二进制前缀 00。0 （128位），可记为：：128。 00。。。1 （128位），可记为：1/128。 11111111 （8位），可记为FF00：：/8。 本地链路单播地址 全球单播地址 1111111010 （10位），可记为FE80/10。 （除上述四种外，所有其他的二进制前缀） 对表 4-10 所列举的几种地址简单解释如下。 未指明地址 这是 16 字节的全 0 地址，可缩写为两个冒号“：：”。这个地址不能用 作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的 IP 地址。这类地址仅此一个。 环回地址 IPv6 的环回地址是0：0：0：0：0：0：0：1，可缩写为：：1。 它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。 多播地址 功能和 IPv4 的一样。这类地址占IPv6地址总数的1/256。 本地链路单播地址（Link-Local Unicast Address） 有些单位的网络使用TCP/IP 协议， 但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信， 但不能和互联网上的其他主机通信。这类地址占IPv6地址总数的 1/1024。 全球单播地址 IPv6 的这一类单播地址是使用得最多的一类。曾提出过多种方案来进 一步划分这128位的单播地址。根据2006年发布的草案标准 RFC 4291 的建议， IPv6 单播 地址的划分方法非常灵活，可以如图 4-48 所示的任何一种。这就是说，可把整个的 128 比 特都作为一个结点的地址。也可用n比特作为子网前缀，用剩下的（128-n）比特作为接口标 识符（相当于 IPv4 的主机号）。当然也可以划分为三级，用n比特作为全球路由选择前缀， 用 m 比特作为子网前缀，而用剩下的（128-n-m）比特作为接口标识符。 结点地址（128 bit） 子网前缀（nbit） 接口标识符（128-n）bit 全球路由选择前缀（nbit） 子网标识符（mbit） 接口标识符（128-n-m）bit 图4-48 IPv6的单播地址的几种划分方法</p> <p>4。6。3 从IPv4 向 IPv6 过渡 由于现在整个互联网的规模太大，因此，“规定一个日期，从这一天起所有的路由器一 律都改用IPv6”，显然是不可行的。这样，向IPv6 过渡只能采用逐步演进的办法，同时， 还必须使新安装的IPv6系统能够向后兼容。这就是说，IPv6系统必须能够接收和转发 IPv4 分组，并且能够为IPv4分组选择路由。 下面介绍两种向IPv6 过渡的策略，即使用双协议栈和使用隧道技术[RFC 2473，2529， 3056， 4038， 4213]。 1。双协议栈 双协议栈（dual stack）是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有双 协议栈：一个 IPv4 和一个IPv6。因此双协议栈主机（或路由器）既能够和IPv6的系统通 信，又能够和 IPv4 的系统通信。双协议栈的主机（或路由器）记为IPv6/IPv4，表明它同时 具有两种 IP 地址：一个IPv6地址和一个 IPv4 地址。 双协议栈主机在和 IPv6 主机通信时采用IPv6 地址，而和 IPv4 主机通信时则采用IPv4 地址。但双协议栈主机怎样知道目的主机是采用哪一种地址呢？它是使用域名系统 DNS 来 查询的。若 DNS 返回的是IPv4地址，双协议栈的源主机就使用 IPv4 地址。但当 DNS 返回 的是 IPv6 地址，源主机就使用 IPv6 地址。 图 4-49 所示的情况是源主机A 和目的主机 F都使用IPv6，所以A向F发送 IPv6 数据 报，路径是 A→B→C→D→E→F。中间 B 到 E 这段路径是IPv4 网络，路由器 B 不能向 C 转发 IPv6 数据报，因为C只使用IPv4 协议。B 是IPv6/IPv4 路由器，它把IPv6 数据报首部 转换为IPv4 数据报首部后发送给CC再转发到D。当D转发到 IPv4 网络的出口路由器E 时（E 也是 IPv6/IPv4 路由器），再恢复成原来的IPv6 数据报。需要注意的是：IPv6 首部中 的某些字段却无法恢复。例如，原来 IPv6 首部中的流标号 X在最后恢复出的IPv6 数据报中 只能变为空缺。这种信息的损失是使用首部转换方法所不可避免的。 IPv6 A 双协议栈 IPv6/IPv4 B IPv4 网络 双协议栈 IPv6/IPv4 D E IPv6 F 流标号：X 源地址：A 目的地址：F 源地址：A 目的地址：F 源地址：A 目的地址：F 流标号：无 源地址：A 目的地址：F 数据部分 数据部分 数据部分 数据部分 IPv4 数据报 IPv4 数据报 IPv6 数据报 IPv6 数据报 图4-49 使用双协议栈进行从IPv4 到IPv6的过渡 2。隧道技术 向 IPv6 过渡的另一种方法是隧道技术（tunneling）。图 4-50 给出了隧道技术的工作原 理。这种方法的要点就是在IPv6 数据报要进入IPv4 网络时，把IPv6数据报封装成为IPv4 数据报。现在整个的IPv6数据报变成了IPv4 数据报的数据部分。这样的IPv4 数据报从路 由器 B 经过路由器C和D，传送到E，而原来的IPv6数据报就好像在IPv4 网络的隧道中传 输，什么都没有变化。当IPv4数据报离开IPv4 网络中的隧道时，再把数据部分（即原来的 IPv6 数据报）交给主机的IPv6 协议栈。图中的一条粗线表示在IPv4 网络中好像有一个从B 到E的“IPv6隧道”，路由器B是隧道的入口而E是出口。请注意，在隧道中传送的数据 报的源地址是B而目的地址是E。 要使双协议栈的主机知道IPv4 数据报里面封装的数据是一个IPv6 数据报，就必须把 IPv4 首部的协议字段的值设置为4141表示数据报的数据部分是IPv6数据报）。 双协议栈 IPv4 网络 双协议栈 IPv6 IPv6/IPv4 IPv6/IPv4 IPv6 B A IPv6 隧道 。IPv6 隧道 D IPv6 隧道 E F 流标号：X 源地址：A 目的地址：F 源地址：B 源地址：B 目的地址：E 目的地址：E 流标号：X 源地址：A 目的地址：F IPv6 IPv6 数据报 数据报 数据部分 IPv4 数据报 IPv4 数据报 数据部分 IPv4 网络 IPv6 数据报 IPv6 数据报 图4-50 使用隧道技术进行从IPv4 到IPv6的过渡 4。6。4 ICMPv6 和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数 据报。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6，它比 ICMPv4 要复杂得多。地址解析协议 ARP 和网际组管理协议 IGMP 的功能都已被合并到 ICMPv6 中（图4-51）。 ICMP IGMP IPv4 ARP 版本4中的网络层 ICMPv6 IPv6 版本6中的网络层 图4-51 新旧版本中的网络层的比较 ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播 通信。ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类 时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为ICMPv6 报 文，而把另一些报文定义为邻站发现 ND （Neighbor-Discovery）报文或多播听众交付 MLD （Multicast Listener Delivery）报文。其实所有这些报文都应当是ICMPv6 报文，只是功能和作 用不同而已。因此我们把这些报文都列入ICMPv6 的不同类别。使用这种分类方法的原因是 所有这些报文都具有相同的格式，并且所有报文类型都由 ICMPv6 协议处理。其实，像 ND</p> <p>和 MLD 这样的协议都是运行在 ICMPv6 协议之下的。基于这样的考虑，可把ICMPv6 报文 分类如图4-52 所示。请注意，邻站发现报文和组成员关系报文分别是在ND 协议和 MLD 协 议的控制下进行发送和接收的。 ICMPv6 报文 差错报文 信息报文 邻站发现报文 ND triX 组成员关系报文 MLD 协议 图4-52 ICMPv6 报文的分类 关于 ICMPv6 的进一步讨论可参阅[FORO10]，这里从略。</p> <h2 id="七ip-多播">七、IP 多播</h2> <p>4。7。1 IP 多播的基本概念 1988年 Steve Deering 首次在其博士学位论文中提出 IP 多播的概念。1992年3月IETF 在互联网范围首次试验 IETF 会议声音的多播，当时有 20 个网点可同时听到会议的声音。IP 多播是需要在互联网上增加更多的智能才能提供的一种服务。现在 IP 多播（multicast，以 前曾译为组播）已成为互联网的一个热门课题。这是由于有许多的应用需要由一个源点发送 到许多个终点，即一对多的通信。例如，实时信息的交付（如新闻、股市行情等），软件更 新，交互式会议等。随着互联网的用户数目的急剧增加，以及多媒体通信的开展，有更多的 业务需要多播来支持。关于IP多播可参考[W-MCAST]。 与单播相比，在一对多的通信中，多播可大大节约网络资源。图 4-53（a）是视频服务器 用单播方式向 90 台主机传送同样的视频节目。为此，需要发送 90 个单播，即同一个视频分 组要发送 90 个副本。图4-53（b）是视频服务器用多播方式向属于同一个多播组的 90 个成员 传送节目。这时，视频服务器只需把视频分组当作多播数据报来发送，并且只需发送一次。 路由器 Rı 在转发分组时，需要把收到的分组复制成3个副本，分别向 R2、R， 和 R&amp; 各转发1 个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此不需要复制分组， 在局域网上的多播组成员都能收到这个视频分组。 当多播组的主机数很大时（如成千上万个），采用多播方式就可明显地减轻网络中各种 资源的消耗。在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多 播数据报的软件。能够运行多播协议的路由器称为多播路由器（multicast router）。多播路由器 当然也可以转发普通的单播IP数据报。 为了适应交互式音频和视频信息的多播，从1992 年起，在互联网上开始试验虚拟的多 播主干网 MBONE （Multicast Backbone On the InterNEt）。 MBONE 可把分组传播给地点分散 但属于一个组的许多台主机。现在多播主干网已经有了相当大的规模。 在互联网上进行多播就叫做IP 多播。IP多播所传送的分组需要使用多播 IP 地址。 我们知道，在互联网中每一台主机必须有一个全球唯一的IP地址。如果某台主机现在 想接收某个特定多播组的分组，那么怎样才能使这个多播数据报传送到这台主机？</p> <p>视频服务器M 视频服务器 M 发送1次多播 发送90次单播 1个 90 个 R₁ 复制 R₁ 30个 30个 30个 R2 R3 R₁ R2 R3 Rai 个 30个 30个 30个 多播 多播 ♡ 多播 共有90个主机接收视频节目 （a）单播 多播组成员共有90个 （b） 多播 图4-53 单播与多播的比较 显然，这个多播数据报的目的地址一定不能写入这台主机的IP地址。这是因为在同一 时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入这样多的 主机的IP 地址。在多播数据报的目的地址写入的是多播组的标识符，然后设法让加入到这 个多播组的主机的IP地址与多播组的标识符关联起来。 其实多播组的标识符就是IP地址中的D类地址。D类IP地址的前四位是1110，因此 D 类地址范围是224。0。0。0 到239。255。255。255。我们就用每一个D类地址标志一个多播组。 这样，D 类地址共可标志 228个多播组，也就是说，在同一时间可以允许有超过2。6亿的多 播组在互联网上运行。多数据报也是“尽最大努力交付”，不保证一定能够交付多播组内 的所有成员。因此，多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的 地址，并且首部中的协议字段值是2，表明使用网际组管理协议 IGMP。 显然，多播地址只能用于目的地址，而不能用于源地址。此外，对多播数据报不产生 ICMP 差错报文。因此，若在PING命令后面键入多播地址，将永远不会收到响应。 IP 多播可以分为两种。一种是只在本局域网上进行硬件多播，另一种则是在互联网的 范围进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入 到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播 交付多播组的所有成员（如图4-53（b）所示）。下面就先讨论这种硬件多播。 4。7。2 在局域网上进行硬件多播 互联网号码指派管理局IANA 拥有的以太网地址块的高24位为00-00-5E，因此 TCP/IP 协议使用的以太网多播地址块的范围是从 00-00-5E-00-00-00 到 00-00-5E-FF-FF-FF。在第3 章 3。4。3 节已讲过，以太网硬件地址字段中的第1字节的最低位为1时即为多播地址，这种 多播地址数占IANA 分配到的地址数的一半。因此IANA 拥有的以太网多播地址的范围是从 01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF。不难看出，在每一个地址中，只有23 位可用作多 播。这只能和D 类IP地址中的23位有一一对应的关系。D类IP地址可供分配的有 28 位， 可见在这 28 位中的前 5 位不能用来构成以太网硬件地址（图4-54）。例如，IP 多播地址 224。128。64。32（即E0-80-40-20）和另一个IP多播地址 224。0。64。32（即E0-00-40-20）转换成 以太网的硬件多播地址都是 01-00-5E-00-40-20。由于多播 IP 地址与以太网硬件地址的映射 关系不是唯一的，因此收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本 主机要接收的数据报丢弃。 ·这5位不使用 0 8 16 24 31 D 类 1110 IP 地址 0 1 0 0 5 E 00000001 00000000 010111100 表示多播 最低23位来自D类IP地址 48位以太网地址 图4-54 D类IP地址与以太网多播地址的映射关系 下面就讨论进行IP多播所需要的协议。 4。7。3 网际组管理协议IGMP 和多播路由选择协议 1。 IP多需要两种协议 图4-55是在互联网上传送多播数据报的例子。图中标有IP地址的四台主机都参加了一 个多播组，其组地址是226。15。37。123。显然，多播数据报应当传送到路由器Rı，R和R3， 而不应当传送到路由器R4，因为与R4连接的局域网上现在没有这个多播组的成员。但这些 路由器又怎样知道多播组的成员信息呢？这就要利用一个协议，叫做网际组管理协议 IGMP （Internet Group Management Protocol）。 135。27。74。52 参加多播组 226。15。37。123 128。56。24。34 未参加 多播组 参加多播组 226。15。37。123 R₁ IGMP 130。12。14。56 参加多播组 IGMP 226。15。37。123 IGMP R2 多播组 Ra 226。15。37。123 130。12。14。43 IGMP 参加多播组 226。15。37。123 未参加 多播组 Ral 未参加 未参加 多播组 多播组 图 4-55 IGMP 使多播路由器知道多播组成员信息 图 4-55 强调了 IGMP 的本地使用范围。请注意，IGMP 并非在互联网范围内对所有多 播组成员进行管理的协议。IGMP 不知道IP多播组包含的成员数，也不知道这些成员都分 布在哪些网络上，等等。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上 是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。 显然，仅有 IGMP 协议是不能完成多任务的。连接在局域网上的多播路由器还必须 和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成 员。这就需要使用多播路由选择协议。</p> <p>然而多播路由选择协议要比单播路由选择协议复杂得多。我们可以通过一个简单的例 子来说明（图4-56）。 N 多播组① R N， G F B E ˙多播组② 图4-56 用来说明多播路由选择的例子 我们假定图 4-56中有两个多播组。多播组①的成员有主机 A，B和C，而多播组②的 成员有主机 D，E和F。这些主机分布在三个网络上（N1，N2和N3）。 路由器 R 不应当向网络N，转发多播组①的分组，因为网络N，上没有多播组①的成 员。但是每一台主机可以随时加入或离开一个多播组。例如，如果主机 G 现在加入了多播 组①，那么从这时起，路由器 R 就必须也向网络 N； 转发多播组①的分组。这就是说，多播 转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由 选择通常是在网络拓扑发生变化时才需要更新路由。 再看一种情况。主机 E 和 F 都是多播组②的成员。当 E 向 F 发送多播数据报时，路由 器 R 把这个多播数据报转发到网络 N3。但当 F E 发送多播数据报时，路由器R则把多播 数据报转发到网络 Nz。如果路由器 R 收到来自主机A的多播数据报（A不是多播组②的成 员，但也可向多播组发送多播数据报），那么路由器R 就应当把多播数据报转发到 N2 和 N3。由此可见，多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地 址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。 还有一种情况。主机 G 没有参加任何多播组，但 G 却可向任何多播组发送多播数据 报。例如，G 可向多播组①或②发送多播数据报。主机 G 所在的局域网上可以没有任何多 播组的成员。显然，多播数据报所经过的许多网络，也不一定非要有多播组成员。总之，多 播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。 正因为如此，IP多播就成为比较复杂的问题。下面介绍这两种协议的要点。 2。 网际组管理协议 IGMP IGMP 已有了三个版本。1989年公布的RFC1112（IGMPv1）早已成为了互联网的标准 协议。2002年10月公布的建议标准IGMPv3是最新的[RFC 3376]。 和网际控制报文协议 ICMP 相似，IGMP 使用IP数据报传递其报文（即IGMP 报文加 上 IP 首部构成IP数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独 的协议，而是属于整个网际协议IP的一个组成部分。 从概念上讲，IGMP 的工作可分为两个阶段。 第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到IGMP报文后，还要利用 多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。 第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主 机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路</p> <p>由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路 由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给 其他的多播路由器。 IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些 具体措施如下： （1） 在主机和多播路由器之间的所有通信都是使用IP多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加IP多播的主 机不会收到 IGMP 报文。 （2） 多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报 文，而不需要对每一个组发送一个询问报文（虽然也允许对一个特定组发送询问报文）。默 认的询问速率是每125 秒发送一次（通信量并不太大）。 （3）当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个 来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。 （4） 在 IGMP 的询问报文中有一个数值，它指明一个最长响应时间（默认值为 10 秒）。当收到询问时，主机在0到之间随机选择发送响应所需经过的时延。因此，若一台 主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的 响应最先发送。 （5） 同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自 己就可以不再发送响应了。这样就抑制了不必要的通信量。 多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据 报是使用硬件多播。多播路由器只需要知道网络上是否至少还有一台主机是本组成员即可。 实际上，对询问报文每一个组只需有一台主机发送响应。 如果一台主机上有多个进程都加入了某个多播组，那么这台主机对发给这个多播组的 每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。 最后我们还要强调指出，多播数据报的发送者和接收者都不知道（也无法找出）一个 多播组的成员有多少，以及这些成员是哪些主机。互联网中的路由器和主机都不知道哪个应 用进程将要向哪个多播组发送多播数据报，因为任何应用进程都可以在任何时候向任何一个 多播组发送多播数据报，而这个应用进程并不需要加入这个多播组。 IGMP 的报文格式可参阅有关文档[RFC 3376]，这里从略。 3。 多播路由选择协议 虽然在 TCP/IP 中IP多播协议已成为建议标准，但多播路由选择协议（用来在多播路由 器之间传播路由信息）则尚未标准化。 在多播过程中一个多播组中的成员是动态变化的。例如在收听网上某个广播节目时， 随时会有主机加入或离开这个多播组。多播路由选择实际上就是要找出以源主机为根节点的 多播转发树。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据 报，但在多播转发树上的路由器不会收到重复的多播数据报（即多播数据报不应在互联网中 兜圈子）。不难看出，对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的 源点也会有不同的多播转发树。 已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：</p> <p>（1）洪泛与剪除。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相 邻接的。一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈 子，采用了叫做反向路径广播 RPB （Reverse Path Broadcasting）的策略。RPB 的要点是：每 一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进 行这种检查很容易，只要从本路由器寻找到源点的最短路径上（之所以叫做反向路径，因为 在计算最短路径时是把源点当作终点）的第一个路由器是否就是刚才把多播数据报送来的路 由器。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就 丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上（也就是说， 存在几条同样长度的最短路径），那么只能选择一条最短路径，选择的准则就是看这几条最 短路径中的相邻路由器的IP地址最小。图4-57的例子说明了这一概念。 R₂ 源点 转发多播数据报 X 收到后即丢弃 Rs 剪除没有 R4 组成员的树枝 图4-57 反向路径广播RPB 和剪除 为简单起见，在图4-57中的网络用路由器之间的链路来表示。我们假定各路由器之间 的距离都是 1。路由器 Rı 收到源点发来的多播数据报后，向R 和R] 转发。R， 发现 R， 就在 自己到源点的最短路径上，因此向 R， 和R4 转发收到的数据报。R， 发现 R， 不在自己到源点 的最短路径上，因此丢弃 R2 发来的数据报。其他路由器也这样转发。R， 到源点有两条最短 路径：R┐→R4→R2→Rı →源点；R→ R5 → R3 → R｣ → 源点。我们再假定 R4 的IP地址比 Rs 的 IP 地址小，所以我们只使用前一条最短路径。因此R， 只转发 Ra传过来的数据报，而丢弃 Rs 传过来的数据报。最后就得出了用来转发多播数据报的多播转发树（图中用粗线表示）， 以后就按这个多播转发树来转发多播数据报。这样就避免了多播数据报兜圈子，同时每一个 路由器也不会接收重复的多播数据报。 如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播 组的成员，就应把它和下游的树枝一起剪除。例如，在图 4-57中虚线椭圆表示剪除的部 分。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。 （2） 隧道技术（tunneling）。隧道技术适用于多播组的位置在地理上很分散的情况。例如 在图 4-58 中，网1和网2都支持多播。现在网1中的主机向网2中的一些主机进行多播。 但路由器 Rı 和 R2 之间的网络并不支持多播，因而R 和R，不能按多播地址转发数据报。为 此，路由器 Rı 就对多数据报进行再次封装，即再加上普通数据报首部，使之成为向单一 目的站发送的单播（unicast）数据报，然后通过“隧道”（tunnel）从R，发送到 R2。</p> <p>网1和网2中 网1 （支持多播） 网 2 的多播数据报 （支持多播） 首部 数据 不支持多播 的网络 R2 首部 IP数据报的数据 隧道 隧道通行的 单播IP数据报 图4-58 隧道技术在多播中的应用 单播数据报到达路由器R后，再由路由器R剥去其首部，使它又恢复成原来的多播数 据报，继续向多个目的站转发。这一点和英吉利海峡隧道运送汽车的情况相似。英吉利海峡 隧道不允许汽车在隧道中行驶。但是，可以把汽车放置在隧道中行驶的电气火车上来通过隧 道。过了隧道后，汽车又可以继续在公路上行驶。这种使用隧道技术传送数据报又叫做IP 中的 IP （IP-in-IP）。 （3）基于核心的发现技术。这种方法对于多播组的大小在较大范围内变化时都适合。这 种方法是对每一个多播组 G 指定一个核心（core）路由器，给出它的IP 单播地址。核心路由器 按照前面讲过的方法创建出对应于多播组G 的转发树。如果有一个路由器，向这个核心路 由器发送数据报，那么它在途中经过的每一个路由器都要检查其内容。当数据报到达参加了 多播组 G 的路由器 Rą 时，R， 就处理这个数据报。如果 Rı 发出的是一个多播数据报，其目 的地址是 G 的组地址，R，就向多播组G 的成员转发这个多播数据报。如果R 发出的数据 报是一个请求加入多播组 G 的数据报，R，就把这个信息加到它的路由中，并用隧道技术向 Rı转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多 了，扩大了多播转发树的覆盖范围。 目前还没有在整个互联网范围使用的多播路由选择协议。下面是一些建议使用的多播 路由选择协议。 距离向量多播路由选择协议 DVMRP （Distance Vector Multicast Routing Protocol）是在互 联网上使用的第一个多播路由选择协议[RFC 1075]。由于在 UNIX 系统中实现 RIP 的程序叫 做 routed，所以在 routed 的前面加表示多播的字母m，叫做mrouted，它使用 DVMRP 在路 由器之间传播路由信息。 基于核心的转发树 CBT （Core Based Tree） [RFC 2189，2201]。这个协议使用核心路由器 作为转发树的根节点。一个大的自治系统 AS 可划分为几个区域，每一个区域选择一个核心 路由器（也叫做中心路由器 center router，或汇聚点路由器 rendezvous router）。 开放最短通路优先的多播扩展 MOSPF （Multicast extensions to OSPF） [RFC 1585]。这个 协议是单播路由选择协议 OSPF 的扩充，使用于一个机构内。MOSPF 使用多播链路状态路 由选择创建出基于源点的多播转发树。 协议无关多播-稀疏方式 PIM-SM （Protocol Independent Multicast-Sparse Mode） [RFC 4601]。这个协议使用和 CBT 同样的方法构成多播转发树。采用“协议无关”这个名词是強 调：虽然在建立多播转发树时是使用单播数据报来和远程路由器联系的，但这并不要求使用 特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。 协议无关多播-密集方式 PIM-DM （Protocol Independent Multicast-Dense Mode） [RFC 3973]。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。 PIM-DM 不使用核心路由器，而是使用洪泛方式转发数据报。</p> <h2 id="八虚拟专用网vpn-和网络地址转换-nat">八、虚拟专用网VPN 和网络地址转换 NAT</h2> <p>4。8。1 虚拟专用网 VPN 由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机 数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。 实际上，在许多情况下，很多主机主要还是和本机构内的其他主机进行通信（例如，在大型 商场或宾馆中，有很多用于营业和管理的计算机。显然这些计算机并不都需要和互联网相 连）。假定在一个机构内部的计算机通信也是采用TCP/IP 协议，那么从原则上讲，对于这些 仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。这就是说，让这些计算机 使用仅在本机构有效的IP地址（这种地址称为本地地址），而不需要向互联网的管理机构申 请全球唯一的 IP 地址（这种地址称为全球地址）。这样就可以大大节约宝贵的全球IP 地址 资源。 但是，如果任意选择一些 IP 地址作为本机构内部使用的本地地址，那么在某种情况下 可能会引起一些麻烦。例如，有时机构内部的某台主机需要和互联网连接，那么这种仅在内 部使用的本地地址就有可能和互联网中某个IP 地址重合，这样就会出现地址的二义性问 题。 为了解决这一问题，RFC 1918 指明了一些专用地址（private address）。这些地址只能用 于一个机构的内部通信，而不能用于和互联网上的主机通信。换言之，专用地址只能用做本 地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一 律不进行转发。2013 年 4 月，RFC 6890 全面地给出了所有特殊用途的IPv4地址，但三个 专用地址块的指派并无变化，即 （1） 10。0。0。0 10。255。255。255 （或记为10。0。0。0/8，它又称为24位块） （2） 172。16。0。0 172。31。255。255 （或记为172。16。0。0/12，它又称为20位块） （3） 192。168。0。0 192。168。255。255 （或记为192。168。0。0/16，它又称为16位块） 上面的三个地址块分别相当于一个A类网络、16个连续的B类网络和256个连续的C 类网络。A 类地址本来早已用完了，而上面的地址 10。0。0。0 本来是分配给 ARPANET 的。由 于 ARPANET 已经关闭停止运行了，因此这个地址就用作专用地址。 采用这样的专用 IP 地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫 做专用网。显然，全世界可能有很多的专用互连网络具有相同的专用 IP 地址，但这并不会 引起麻烦，因为这些专用地址仅在本机构内部使用。专用 IP 地址也叫做可重用地址 （reusable address）。 有时一个很大的机构的许多部门分布的范围很广（例如，在世界各地），这些部门经常 要互相交换信息。这可以有两种方法。（1）租用电信公司的通信线路为本机构专用。这种方 法虽然简单方便，但线路的租金太高，一般难于承受。（2）利用公用的互联网作为本机构各 专用网之间的通信载体，这样的专用网又称为虚拟专用网 VPN（Virtual Private Network）。 之所以称为“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不 是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的互联</p> <p>网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。加密需要采用的协议 将在7。6。1 节讨论。“虚拟”表示“好像是”，但实际上并不是，因为现在并没有真正使用通 信专线，而 VPN只是在效果上和真正的专用网一样。一个机构要构建自己的VPN 就必须为 它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其 他场所的地址。 图 4-59 以两个场所为例说明如何使用IP隧道技术实现虚拟专用网。 假定某个机构在两个相隔较远的场所建立了专用网 A 和 B，其网络地址分别为专用地 址 10。1。0。0 和 10。2。0。0。现在这两个场所需要通过公用的互联网构成一个 VPN。 显然，每一个场所至少要有一个路由器具有合法的全球IP地址，如图4-59（a）中的路由 器 Rı 和 R2。这两个路由器和互联网的接口地址必须是合法的全球IP 地址。路由器 R」 和 R2 在专用网内部网络的接口地址则是专用网的本地地址。 加密的从X到Y的内部数据报 源地址：125。1。2。3 目的地址：194。4。5。6 外部数据报的数据部分 外部数据报 数据报首部 场所A 125。1。2。3 194。4。5。6 场所 B X 隧道 Y 10。2。0。0 10。1。0。0 10。2。0。3 10。1。0。1 互联网 （a）使用隧道技术 场所 A 虚拟专用网VPN 场所 B X Y 10。2。0。0 10。1。0。0 10。2。0。3 10。1。0。1 （b）构成虚拟专用网 图4-59 用隧道技术实现虚拟专用网 在每一个场所 A或B内部的通信量都不经过互联网。但如果场所A的主机 X 要和另一 个场所 B 的主机Y通信，那么就必须经过路由器R 和R2。主机 X 向主机 Y 发送的 IP 数据 报的源地址是 10。1。0。1，而目的地址是10。2。0。3。这个数据报先作为本机构的内部数据报从X 发送到与互联网连接的路由器Rı。路由器 R， 收到内部数据报后，发现其目的网络必须通过 互联网才能到达，就把整个的内部数据报进行加密（这样就保证了内部数据报的安全），然 后重新加上数据报的首部，封装成为在互联网上发送的外部数据报，其源地址是路由器 Rı 的全球地址 125。1。2。3，而目的地址是路由器R的全球地址 194。4。5。6。路由器，收到数据报 后将其数据部分取出进行解密，恢复出原来的内部数据报（目的地址是10。2。0。3），交付主机 Y。可见，虽然 X 向 Y 发送的数据报是通过了公用的互联网，但在效果上就好像是在本部 门的专用网上传送一样。如果主机Y要向X发送数据报，那么所进行的步骤也是类似的。 请注意，数据报从R 传送到 R， 可能要经过互联网中的很多个网络和路由器。但从逻辑</p> <p>上看，在 Rı到R，之间好像是一条直通的点对点链路，图4-59（a）中的“隧道”就是这个意 思。 如图 4-59（b）所示的、由场所 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为内联 网（intranet 或intranet VPN，即内联网VPN），表示场所A和B都属于同一个机构。 有时一个机构的 VPN 需要有某些外部机构（通常就是合作伙伴）参加进来。这样的 VPN 就称为外联网（extranet 或extranet VPN，即外联网 VPN）。 请注意，内联网和外联网都采用了互联网技术，即都是基于TCP/IP协议的。 还有一种类型的VPN，就是远程接入 VPN （remote access VPN）。我们知道，有的公司 可能并没有分布在不同场所的部门，但却有很多流动员工在外地工作。公司需要和他们保持 联系，有时还可能一起开电话会议或视频会议。远程接入 VPN 可以满足这种需求。在外地 工作的员工通过拨号接入互联网，而驻留在员工个人电脑中的 VPN 软件可以在员工的个人 电脑和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容也是保密的，员工 们感到好像就是使用公司内部的本地网络。 4。8。2网络地址转换 NAT 下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地 IP 地址 （即仅在本专用网内使用的专用地址），但现在又想和互联网上的主机通信（并不需要加 密），那么应当采取什么措施呢？ 最简单的办法就是设法再申请一些全球IP地址。但这在很多情况下是不容易做到的， 因为全球 IPv4 的地址已所剩不多了。目前使用得最多的方法是采用网络地址转换。 网络地址转换 NAT （Network Address Translation）方法是在1994年提出的。这种方法需 要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路 由器，它至少有一个有效的外部全球IP 地址。这样，所有使用本地地址的主机在和外界通 信时，都要在 NAT 路由器上将其本地地址转换成全球IP地址，才能和互联网连接。 图 4-60 给出了NAT 路由器的工作原理。在图中，专用网 192。168。0。0 内所有主机的 IP 地址都是本地 IP地址 192。168。x。x。NAT 路由器至少要有一个全球IP地址，才能和互联网相 连。图 4-60 表示出 NAT 路由器有一个全球 IP 地址 172。38。1。5（当然，NAT 路由器可以有多 个全球 IP 地址）。 全球IP地址 专用网192。168。0。0 172。38。1。5 主机B 源IP 地址 213。18。2。4 主机A 192。168。0。3 192。168。0。3 源 IP 地址 172。38。1。5 互联网 NAT 路由器 目的IP 地址 192。168。0。3 目的IP地址 172。38。1。5 图4-60 NAT路由器的工作原理 NAT 路由器收到从专用网内部的主机 A 发往互联网上主机 B 的 IP数据报：源IP地址 是 192。168。0。3，而目的 IP 地址是213。18。2。4。NAT 路由器把IP数据报的源 IP 地址</p> <p>192。168。0。3，转换为新的IP地址（即NAT 路由器的全球IP地址） 172。38。1。5，然后转发 出去。因此，主机B收到这个IP数据报时，以为A的IP地址是172。38。1。5。当B给A发 送应答时，IP数据报的目的IP地址是NAT路由器的IP地址172。38。1。5。B并不知道A的专 用地址 192。168。0。3。实际上，即使知道了，也不能使用，因为互联网上的路由器都不转发目 的地址是专用网本地IP地址的IP数据报。当NAT路由器收到互联网上的主机B发来的IP 数据报时，还要进行一次IP地址的转换。通过NAT 地址转换表，就可把IP数据报上的旧 的目的 IP 地址172。38。1。5，转换为新的目的IP地址192。168。0。3（主机A真正的本地IP地 址）。表 4-11 给出了NAT 地址转换表的举例。表中的前两行数据对应于图4-60中所举的例 子。第一列“方向”中的“出”表示离开专用网，而“入”表示进入专用网。表中后两行数 据（图4-60中没有画出对应的IP数据报）表示专用网内的另一主机192。168。0。7 向互联网发 送了IP数据报，而NAT路由器还有另外一个全球IP地址172。38。1。6。 表4-11 NAT地址转换表举例 方向 字段 旧的 IP 地址 新的 IP 地址 出 源 IP 地址 入 目的 IP 地址 192。168。0。3 172。38。1。5 172。38。1。5 192。168。0。3 出 入 源 IP 地址 目的 IP 地址 192。168。0。7 172。38。1。6 172。38。1。6 192。168。0。7 由此可见，当 NAT 路由器具有n个全球 IP 地址时，专用网内最多可以同时有n 台主机 接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的 全球IP地址。 显然，通过 NAT 路由器的通信必须由专用网内的主机发起。设想互联网上的主机要发 起通信，当 IP 数据报到达 NAT 路由器时，NAT 路由器就不知道应当把目的IP 地址转换成 专用网内的哪一个本地IP 地址。这就表明，这种专用网内部的主机不能充当服务器用，因 为互联网上的客户无法请求专用网内的服务器提供服务。 为了更加有效地利用 NAT 路由器上的全球IP 地址，现在常用的 NAT 转换表把运输层 的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的 全球 IP 地址，因而可以同时和互联网上的不同主机进行通信[COME06]。 由于运输层的端口号将在下一章 5。1。3 节讨论，因此，建议在学完运输层的有关内容 后，再学习下面的内容。从系统性考虑，把下面的这部分内容放在本章中介绍较为合适。 使用端口号的 NAT 也叫做网络地址与端口号转换 NAPT （Network Address and Port Translation），而不使用端口号的NAT 就叫做传统的NAT （traditional NAT）。但在许多文献中 并没有这样区分，而是不加区分地都使用 NAT 这个更加简洁的缩写词。表 4-12 说明了 NAPT 的地址转换机制。 表4-12 NAPT 地址转换表举例 方向 字段 出 源 IP 地址：TCP 源端口 出 源IP 地址：TCP 源端口 入 目的IP 地址：TCP 目的端口 入 目的 IP 地址：TCP 目的端口 192。168。0。4：30000 172。38。1。5：40001 172。38。1。5：40002 192。168。0。4：30000 旧的IP 地址和端口号 新的IP地址和端口号 192。168。0。3：30000 172。38。1。5：40001 172。38。1。5：40002 192。168。0。3：30000 • 188。</p> <p>从表 4-12 可以看出，在专用网内主机 192。168。0。3 向互联网发送IP数据报，其 TCP 端 口号选择为 30000。NAPT 把源IP地址和TCP端口号都进行转换（如果使用UDP，则对 UDP 的端口号进行转换。原理是一样的）。另一台主机192。168。0。4 也选择了同样的 TCP 端 口号 30000。这纯属巧合（端口号仅在本主机中才有意义）。现在 NAPT 把专用网内不同的 源 IP 地址都转换为同样的全球IP地址。但对源主机所采用的TCP端口号（不管相同或不 同），则转换为不同的新的端口号。因此，当NAPT 路由器收到从互联网发来的应答时，就 可以从 IP 数据报的数据部分找出运输层的端口号，然后根据不同的目的端口号，从NAPT 转换表中找到正确的目的主机。 应当指出，从层次的角度看，NAPT的机制有些特殊。普通路由器在转发IP数据报 时，对于源 IP地址或目的IP地址都是不改变的。但NAT 路由器在转发IP数据报时，一定 要更换其IP地址（转换源IP地址或目的IP地址）。其次，普通路由器在转发分组时，是工 作在网络层。但NAPT 路由器还要查看和转换运输层的端口号，而这本来应当属于运输层 的范畴。也正因为这样，NAPT 曾遭受了一些人的批评，认为NAPT的操作没有严格按照 次的关系。但不管怎样，NAT（包括NAPT）已成为互联网的一个重要构件。有关 NAT 的 详细讨论可参阅建议标准 RFC3022 和IETF 关于 NAT 工作组的网站[W-NAT]。</p> <h2 id="九多协议标记交换-mpls">九、多协议标记交换 MPLS</h2> <p>IETF于1997年成立了MPLS工作组，为的是开发出一种新的协议。这种新的协议就是 多协议标记交换MPLS （MultiProtocol Label Switching）。“多协议”表示在MPLS 的上层可以 采用多种协议。IETF 还综合了许多公司的类似技术，如Cisco 公司的标记交换 TAG （TAG Switching），以及Ipsilon 公司的IP交换（IP Switching）等。2001年1月MPLS终于成为互联 网的建议标准[RFC 3031，3032][W-MPLS]。 MPLS 利用面向连接技术，使每个分组携带一个叫做标记（label）的小整数（这叫做打 上标记）。当分组到达交换机（即标记交换路由器）时，交换机读取分组的标记，并用标记 值来检索分组转发表。这样就比查找路由表来转发分组要快得多。 人们经常把 MPLS与异步传递方式 ATM （Asynchronous Transfer Mode）联系起来，这仅 仅是因为它们都采用了面向连接的工作方式。以前很多人都曾认为网络的发展方向是以 ATM 为核心的宽带综合业务数字 B-ISDN。然而价格低廉得多的高速IP路由器仍然占领了 市场，最终导致 ATM 技术和 B-ISDN 未能够成为网络的发展方向。MPLS 并没有取代IP， 而是作为一种IP增强技术，被广泛地应用在互联网中。 MPLS 具有以下三个方面的特点：（1）支持面向连接的服务质量。（2） 支持流量工程， 平衡网络负载。（3）有效地支持虚拟专用网 VPN。 下面讨论 MPLS 的基本工作原理。</p> <p>4。9。1 MPLS 的工作原理 1。基本工作过程 在传统的IP网络中，分组每到达一个路由器，都必须查找路由表，并按照“最长前缀 匹配”的原则找到下一跳的IP地址（请注意，前缀的长度是不确定的。当网络很大时，查 找含有大量项目的路由表要花费很多的时间。在出现突发性的通信量时，往往还会使缓存溢 出，这就会引起分组丢失、传输时延增大和服务质量下降。 MPLS 的一个重要特点就是在 MPLS 域的入口处，给每一个IP数据报打上固定长度 “标记”，然后对打上标记的IP数据报用硬件进行转发，这就使得IP数据报转发的过程大 大地加快了。采用硬件技术对打上标记的IP数据报进行转发就称为标记交换。“交换”也 表示在转发时不再上升到第三层查找转发表，而是根据标记在第二层（链路层）用硬件进行 转发。MPLS 可使用多种链路层协议，如PPP、以太网、ATM 以及帧中继等。图4-61 是 MPLS 协议的基本原理的示意图。 MPLS 域 打上标记 B 去除标记 LDP LDP ☑ LDP 3 2 打上标记 的分组 \的分组 打上标记 2 打上标记 的分组 MPLS MPLS 入口结点 X 出口结点 ☑ 普通IP分组 打上标记的分组 普通路由器 范 标记交换路由器 LSR 图4-61 MPLS 协议的基本原理 MPLS 域（MPLS domain）是指该域中有许多彼此相邻的路由器，并且所有的路由器都是 支持 MPLS 技术的标记交换路由器 LSR （Label Switching Router）。 LSR 同时具有标记交换和 路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择 功能构造转发表。 图4-61 中给出了MPLS 的基本工作过程如下： （1） MPLS 域中的各 LSR 使用专门的标记分配协议 LDP （Label Distribution Protocol）交换 报文，并找出和特定标记相对应的路径，即标记交换路径 LSP（Label Switched Path）。例如 在图中的路径 A→B→C→D。各LSR 根据这些路径构造出转发表。这个过程和路由器构造 自己的路由表相似[RFC 3031]，限于篇幅，这里不讨论转发表构造的详细步骤。但应注意的 是，MPLS 是面向连接的，因为在标记交换路径LSP上的第一个 LSR 就根据IP数据报的初 始标记确定了整个的标记交换路径，就像一条虚连接一样。</p> <p>（2） 当一个 IP 数据报进入到MPLS 域时，MPLS 入口结点（ingress node）就给它打上标记 （后面我们就会知道，这实际上是插入一个 MPLS 首部），并按照转发表把它转发给下一个 LSR。以后的所有LSR都按照标记进行转发。 给 IP 数据报打标记的过程叫做分类（classification）。严格的第三层（网络层）分类只使用 了 IP 首部中的字段，如源IP地址和目的IP地址等。大多数运营商实现了第四层（运输层） 分类（除了要检查IP首部外，运输层还要检查TCP或UDP 首部中的协议端口号），而有些运 营商则实现了第五层（应用层）分类（更进一步地检查数据报的内部并考虑其有效载荷）。 （3）由于在全网内统一分配全局标记数值是非常困难的，因此一个标记仅仅在两个标记 交换路由器 LSR 之间才有意义。分组每经过一个 LSR，LSR 就要做两件事：一是转发，二 是更换新的标记，即把入标记更换成为出标记。这就叫做标记对换（label swapping）。做这 两件事所需的数据都已清楚地写在转发表中。例如，图 4-61 中的标记交换路由器B 从入接 口0收到一个入标记为3的IP数据报，查找了如下的转发表： 入接口 0 入标记 出接口 出标记 3 1 1 为1。 标记交换路由器B就知道应当把该IP数据报从出接口 1 转发出去，同时把标记对换 当IP数据报进入下一个LSR时，这时的入标记就是刚才得到的出标记。因此，标记交 换路由器C接着在转发该IP数据报时，又把入标记1对换为出标记2。 （4） 当 IP 数据报离开 MPLS 域时，MPLS 出口结点（egress node）就把 MPLS 的标记去 除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。 上述的这种“由入口 LSR 确定进入 MPLS 域以后的转发路径”称为显式路由选择 （explicit routing），它和互联网中通常使用的“每一个路由器逐跳进行路由选择”有着很大的 区别。 下面再讨论 MPLS 中的几个重要概念。 2。 转发等价类 FEC MPLS 有个很重要的概念就是转发等价类 FEC （Forwarding Equivalence Class）。所谓 “转发等价类”就是路由器按照同样方式对待的IP 数据报的集合。这里“按照同样方式对 待”表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级 等。FEC 的例子是： （1） 目的 IP 地址与某一个特定 IP 地址的前缀匹配的IP 数据报（这就相当于普通的 IP 路由器）； （2） 所有源地址与目的地址都相同的 IP 数据报； （3） 具有某种服务质量需求的 IP 数据报。 总之，划分 FEC 的方法不受什么限制，这都由网络管理员来控制，因此非常灵活。入 口结点并不是给每一个IP数据报指派一个不同的标记，而是将属于同样 FEC 的 IP 数据报</p> <p>都指派同样的标记。FEC 和标记是一一对应的关系。 图 4-62 给出一个把 FEC 用于负载平衡的例子。图4-62（a）的主机H 和H2分别向H，和 H4 发送大量数据。路由器A和C是数据传输必须经过的。但传统的路由选择协议只能选择 最短路径A→B→C，这就可能导致这段最短路径过载。 H B H₂ （a） 传统路由选择协议使最短路径A→B→C过载 H， H B H₁ H A H₂ Ha （b） 利用FEC使通信量较为均衡 图4-62 FEC用于负载平衡 图 4-62（b）表示在 MPLS 的情况下，入口结点 A 可设置两种 FEC：“源地址为 H 而目的 地址为 Hţ”和“源地址为 H， 而目的地址为 H4”，把前一种 FEC 的路径设置为 Hı→A→B→ C→H3，而后一种的路径设置为 H2→A→D→E→C→H4。这样可使网络的负载较为平衡。网 络管理员采用自定义的 FEC 就可以更好地管理网络的资源。这种均衡网络负载的做法也称 为流量工程 TE （Traffic Engineering）或通信量工程。 4。9。2 MPLS 首部的位置与格式 MPLS 并不要求下层的网络都使用面向连接的技术。因此一对 MPLS 路由器之间的物理 连接，既可以由一个专用电路组成，如 OC-48 线路，也可以使用像以太网这样的网络。但 是这些网络并不提供打标记的手段，而IPv4 数据报首部也没有多余的位置存放 MPLS 标 记。这就需要使用一种封装技术：在把IP数据报封装成以太网帧之前，先要插入一个 MPLS 首部。从层次的角度看，MPLS 首部就处在第二层和第三层之间（图 4-63）。在把加 上 MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为 884716，而在多播的情况下为884816。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的IP数据报。 网络层 MPLS 首部 插入 数据链路层 图4-63 MPLS 首部的位置 图4-64 给出了 MPLS 首部的格式。可见“给IP数据报打上标记”其实就是在以太网的 帧首部和 IP 数据报的首部之间插入一个4字节的 MPLS 首部。具体的标记就在“标记值” 这个字段中。</p> <p>位 20 3 1 8 标记值 试验 S 生存时间 TTL 以太网帧 帧首部MPLS 首部IP首部 IP 数据 部 分 帧尾部 IP数据报 发送在前 图4-64 MPLS 首部的格式 占 20 位。由于一个 MPLS 标记占 20位，因此从理论上讲，在设置 MPLS 首部共包括以下四个字段： （1） 标记值 MPLS 时可以使用标记的所有 20 位，因而可以同时容纳高达220个流（即1048576个流）。 但是，实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管 理和设置每条交换路径。 （2） 试验 占3位，目前保留用于试验。 （3） 栈 S 占1位，在有“标记栈”时使用。 （4） 生存时间 TTL 占8位，用来防止 MPLS 分组在MPLS 域中兜圈子。 本章的重要概念 • TCP/IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数 据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组 可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。 • IP 网是虚拟的，因为从网络层上看，IP网就是一个统一的、抽象的网络（实际上 是异构的）。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统 一的、抽象的 IP 地址处理主机之间的通信问题。 在互联网上的交付有两种：在本网络上的直接交付（不经过路由器）和到其他网络 的间接交付（经过至少一个路由器，但最后一次一定是直接交付）。 一个 IP 地址在整个互联网范围内是唯一的。分类的IP 地址包括 A 类、B 类和 C 类地址（单播地址），以及D类地址（多播地址）。E类地址未使用。 分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络 号字段最前面的类别位指明IP地址的类别。 • IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络 号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的 网络号来转发分组。 • IP 地址标志一台主机（或路由器）和一条链路的接口。多归属主机同时连接到两 个或更多的网络上。这样的主机同时具有两个或更多的IP 地址，其网络号必须是 不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两 个不同的 IP 地址。 按照互联网的观点，用转发器或网桥连接起来的若干个局域网仍为一个网络。所有 分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广 域网）都是平等的。 物理地址（即硬件地址）是数据链路层和物理层使用的地址，而 IP 地址是网络层</p> <p>和以上各层使用的地址，是一种逻辑地址（用软件实现的），在数据链路层看不见 数据报的IP 地址。 IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所 有IP数据报必须具有的（源地址、目的地址，总长度等重要字段都在固定首部 中）。一些长度可变的可选字段放在固定首部的后面。 IP 首部中的生存时间字段给出了IP数据报在互联网中所能经过的最大路由器数， 可防止IP 数据报在互联网中无限制地兜圈子。 地址解析协议 ARP 把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由 器的 IP 地址和硬件地址的映射问题。ARP 的高速缓存可以大大减少网络上的通信 量。 在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。 无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指 明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”。IP地址的分配都以CIDR 地址块为单位。 CIDR 的 32 位地址掩码（或子网掩码）由一串 1 和一串0组成，而1的个数就是 前缀的长度。只要把 IP 地址和地址掩码逐位进行“逻辑与（AND）”运算，就很 容易得出网络地址。A类地址的默认地址掩码是 255。0。0。0。B类地址的默认地址掩 码是255。255。0。0C类地址的默认地址掩码是255。255。255。0。 路由聚合（把许多前缀相同的地址用一个来代替）有利于减少路由表中的项目，减 少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 “转发”和“路由选择”有区别。“转发”是单个路由器的动作。“路由选择”是许 多路由器共同协作的过程，这些路由器相互交换信息，目的是生成路由表，再从路 由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转 发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使 用路由表这一名词。 自治系统（AS）就是在单一的技术管理下的一组路由器。一个自治系统对其他自 治系统表现出的是一个单一的和一致的路由选择策略。 路由选择协议有两大类：内部网关协议（或自治系统内部的路由选择协议），如 RIP 和 OSPF；外部网关协议（或自治系统之间的路由选择协议），如BGP-4。 RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按固定 的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自 治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器。 OSPF 是分布式的链路状态协议，适用于大型互联网。OSPF 只在链路状态发生变 化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由 器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路 的“度量”。“度量”可表示费用、距离、时延、带宽等，可统称为“代价”。所有 的路由器最终都能建立一个全网的拓扑结构图。 BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协</p> <p>议。BGP 力求寻找一条能够到达目的网络（可达）且比较好的路由（不兜圈子）， 而并非要寻找一条最佳路由。 网际控制报文协议ICMP是IP层的协议。ICMP报文作为IP数据报的数据，加上 首部后组成 IP数据报发送出去。使用ICMP并非为了实现可靠传输。ICMP 允许 主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两 种，即 ICMP差错报告报文和 ICMP 询问报文。 ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通 性。PING 使用了ICMP 回送请求与回送回答报文。 要解决 IP 地址耗尽的问题，最根本的办法就是采用具有更大地址空间的新版本的 IP 协议，即 IPv6。 IPv6 所带来的主要变化是：（1）更大的地址空间（采用128位的地址）； （2） 灵活的 首部格式；（3） 改进的选项；（4） 支持即插即用；（5）支持资源的预分配；（6） IPv6 首部改为8字节对齐。 IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有 的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。 IPv6 的地址使用冒号十六进制记法。 向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的IPv6系统能够向后兼容。 向 IPv6 过渡可以使用双协议栈或使用隧道技术。 • 与单播相比，在一对多的通信中，IP多播可大大节约网络资源。IP多播使用 D 类 IP 地址。IP 多播需要使用网际组管理协议 IGMP 和多播路由选择协议。 虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体。VPN 内 部使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球IP 地 址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送 的数据都必须加密。 使用网络地址转换NAT技术，可以在专用网络内部使用专用IP 地址，而仅在连接 到互联网的路由器使用全球IP地址。这样就大大节约了宝贵的 IP 地址。 MPLS 的特点： （1） 支持面向连接的服务质量；（2） 支持流量工程，平衡网络负 载；（3）有效地支持虚拟专用网 VPN。 MPLS 在入口结点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第 二层（链路层）用硬件进行转发（在标记交换路由器中进行标记对换），因而转发 速率大大加快。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/webpack/">Webpack</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/07-caching/">HTTP 缓存</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/04-connection-management/">HTTP 连接管理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/style/">ES6 - 编程风格</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/application-layer/">计算机网络 - 应用层</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Zhang Feng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-repositories",title:"repositories",description:"Edit the `_data/repositories.yml` and change the `github_users` and `github_repos` lists to include your own GitHub profile and repositories.",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"This is a description of the page. You can modify it in &#39;_pages/cv.md&#39;. You can also change or remove the top pdf download button.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"nav-people",title:"people",description:"members of the lab or group",section:"Navigation",handler:()=>{window.location.href="/people/"}},{id:"dropdown-blog",title:"blog",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-webpack",title:"Webpack",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/webpack/"}},{id:"post-http-\u7f13\u5b58",title:"HTTP \u7f13\u5b58",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/07-caching/"}},{id:"post-http-\u8fde\u63a5\u7ba1\u7406",title:"HTTP \u8fde\u63a5\u7ba1\u7406",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/04-connection-management/"}},{id:"post-es6-\u7f16\u7a0b\u98ce\u683c",title:"ES6 - \u7f16\u7a0b\u98ce\u683c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/style/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u5e94\u7528\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u5e94\u7528\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/application-layer/"}},{id:"post-\u54cd\u5e94\u5f0f-web-\u8bbe\u8ba1",title:"\u54cd\u5e94\u5f0f Web \u8bbe\u8ba1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/responsive-web-design/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u8fd0\u8f93\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u8fd0\u8f93\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/transport-layer/"}},{id:"post-react-\u4e2d\u7684\u4e8b\u4ef6",title:"React \u4e2d\u7684\u4e8b\u4ef6",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events-in-react/"}},{id:"post-css-\u9884\u5904\u7406\u5668",title:"CSS \u9884\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-preprocessor/"}},{id:"post-css-modules-\u7528\u6cd5\u6559\u7a0b",title:"CSS Modules \u7528\u6cd5\u6559\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-modules/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7f51\u7edc\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7f51\u7edc\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/network-layer/"}},{id:"post-\u8de8\u57df\u8d44\u6e90\u5171\u4eab-cors",title:"\u8de8\u57df\u8d44\u6e90\u5171\u4eab\uff08CORS\uff09",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cors/"}},{id:"post-\u9632\u6296\u548c\u8282\u6d41",title:"\u9632\u6296\u548c\u8282\u6d41",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/debounce-and-throttle/"}},{id:"post-es6-symbol",title:"ES6 - Symbol",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/symbol/"}},{id:"post-es6-\u5b57\u7b26\u4e32\u7684\u6269\u5c55",title:"ES6 - \u5b57\u7b26\u4e32\u7684\u6269\u5c55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/string/"}},{id:"post-es6-set",title:"ES6 - Set",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/set/"}},{id:"post-es6-reflect",title:"ES6 - Reflect",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/reflect/"}},{id:"post-es6-proxy",title:"ES6 - Proxy",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/proxy/"}},{id:"post-es6-promise-\u5bf9\u8c61",title:"ES6 - Promise \u5bf9\u8c61",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/promise/"}},{id:"post-es6-object",title:"ES6 - Object",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/object/"}},{id:"post-es6-\u6a21\u5757",title:"ES6 - \u6a21\u5757",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/module/"}},{id:"post-es6-map",title:"ES6 - Map",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/map/"}},{id:"post-es6-let-\u548c-const-\u547d\u4ee4",title:"ES6 - let \u548c const \u547d\u4ee4",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/let-const/"}},{id:"post-es6-iterator",title:"ES6 - Iterator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/iterator/"}},{id:"post-es6-generator-\u51fd\u6570",title:"ES6 - Generator \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/generator/"}},{id:"post-es6-function",title:"ES6 - Function",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/function/"}},{id:"post-es6-decorator",title:"ES6 - Decorator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/decorator/"}},{id:"post-es6-class",title:"ES6 - Class",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/class/"}},{id:"post-es6-async-\u51fd\u6570",title:"ES6 - async \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-es6-array",title:"ES6 - Array",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/array/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6570\u636e\u94fe\u8def\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6570\u636e\u94fe\u8def\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/data-link-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7269\u7406\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7269\u7406\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/physical-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6982\u8ff0",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6982\u8ff0",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/instruction/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%7A%66%65%6E%67%30%37%31%32@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=qc6CJjYAAAAJ","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>