<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 计算机网络 - 应用层 | Zhang Feng </title> <meta name="author" content="Zhang Feng"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://feng-zhang0712.github.io//blog/2024/application-layer/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Zhang</span> Feng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">计算机网络 - 应用层</h1> <p class="post-meta"> Created in September 15, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/computer"> <i class="fa-solid fa-hashtag fa-sm"></i> computer</a>   <a href="/blog/tag/networks"> <i class="fa-solid fa-hashtag fa-sm"></i> networks</a>   <a href="/blog/tag/application-layer"> <i class="fa-solid fa-hashtag fa-sm"></i> application layer</a>   <a href="/blog/tag/osi"> <i class="fa-solid fa-hashtag fa-sm"></i> OSI</a>   ·   <a href="/blog/category/blog"> <i class="fa-solid fa-tag fa-sm"></i> blog</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程间的通信和协同工作来完成。应用进程间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规则。具体来说，应用层协议应当定义：</p> <ul> <li>应用进程交换的报文类型，如请求报文和响应报文。</li> <li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li> <li>字段的语义，即包含在字段中的信息的含义。</li> <li>进程何时、如何发送报文，以及对报文进行响应的规则。</li> </ul> <p>本章最重要的内容是：</p> <ul> <li>域名系统 DNS——从域名解析出 IP 地址。</li> <li>万维网和 HTTP 协议，以及万维网的两种不同的信息搜索引擎。</li> <li>电子邮件的传送过程，SMTP 协议和 POP3 协议、IMAP 协议使用的场合。</li> <li>动态主机配置协议 DHCP 的特点。</li> <li>网络管理的三个组成部分（SNMP 本身、管理信息结构 SMI 和管理信息库 MIB）的作用。</li> <li>系统调用和应用编程接口的基本概念。</li> <li>P2P 文件系统。</li> </ul> <h2 id="一域名系统-dns">一、域名系统 DNS</h2> <h3 id="11-域名系统概述">1.1 域名系统概述</h3> <p><strong>域名系统</strong> DNS（Domain Name System）是互联网使用的命名系统，用来把便于人们使用的机器名字转换 为IP 地址。</p> <p>互联网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行<strong>解析</strong>，仅少量解析需要在互联网上通信，因此 DNS 系统的效率很高。由于 DNS 是分布式系统，即使单个计算机出了故障，也不会妨碍整个 DNS 系统的正常运行。</p> <p>域名到 IP 地址的解析是由分布在互联网上的许多<strong>域名服务器程序</strong>（可简称为域名服务器）共同完成的。域名服务器程序在专设的结点上运行，而人们也常把运行域名服务器程序的机器称为<strong>域名服务器</strong>。</p> <p>域名到 IP 地址的解析过程的要点如下：当某个应用进程需要把主机名解析为 IP 地址时，该应用进程就调用<strong>解析程序</strong>，并成为 DNS 的一个客户，把待解析的域名放在 DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器（使用 UDP 是为了减少开销）。本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。应用进程获得目的主机的 IP 地址后即可进行通信。若本地域名服务器不能回答该请求，则此域名服务器就暂时成为 DNS 中的另一个客户，并向其他域名服务器发出查询请求。</p> <h3 id="12-互联网的域名结构">1.2 互联网的域名结构</h3> <p>互联网采用层次树状结构的命名方法，采用这种命名方法，任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结 构的名字，即域名（domain name）。这里，“域”（domain）是名字空间中一个可被管理的划 分。域还可以划分为子域，而子域还可继续划分为子域的子域，这样就形成了顶级域、二级 域、三级域，等等。从语法上讲，每个域名都由标号（label）序列组成，而各标号之间用点隔开。</p> <div class="row justify-content-center"> <div class="col-4"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/different-domain-names-480.webp 480w,/assets/images/computer-network/different-domain-names-800.webp 800w,/assets/images/computer-network/different-domain-names-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/different-domain-names.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="中央电视台用于收发电子邮件的计算机的域名" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>DNS 规定：</p> <ul> <li>域名中的标号都由英文字母和数字组成。</li> <li>每个标号不超过 63 个字符。</li> <li>不区分大小写字母。</li> <li>标号中除连字符（<code class="language-plaintext highlighter-rouge">-</code>）外不能使用其他的标点符号。</li> <li>级别最低的域名写在最左边，而级别最高的顶级域名则写在最右边。</li> <li>由多个标号组成的完整域名总共不超过 255 个字符</li> </ul> <p>原先的顶级域名共分为三大类：</p> <ol> <li> <strong>国家顶级域名</strong> nTLD：如：<code class="language-plaintext highlighter-rouge">cn</code> 表示中国，<code class="language-plaintext highlighter-rouge">us</code> 表示美国，<code class="language-plaintext highlighter-rouge">uk</code> 表示英国，等等。</li> <li> <strong>通用顶级域名</strong> gTLD：通用顶级域名有 20 个，即（这里只列举出了最初的 7 个）： <ul> <li> <code class="language-plaintext highlighter-rouge">com</code>（公司企业）</li> <li> <code class="language-plaintext highlighter-rouge">net</code>（网络服务机构）</li> <li> <code class="language-plaintext highlighter-rouge">org</code>（非营利性组织）</li> <li> <code class="language-plaintext highlighter-rouge">int</code>（国际组织）</li> <li> <code class="language-plaintext highlighter-rouge">edu</code>（美国专用的教育机构）</li> <li> <code class="language-plaintext highlighter-rouge">gov</code>（美国的政府部门）</li> <li> <code class="language-plaintext highlighter-rouge">mil</code>（美国的军事部门）</li> </ul> </li> <li> <strong>基础结构域名</strong>（infrastructure domain）：这种顶级域名只有一个，即 <code class="language-plaintext highlighter-rouge">arpa</code>，用于反向域名解析，因此又称为<strong>反向域名</strong>。</li> </ol> <p>注意，ICANN 后来正式批准了<strong>新顶级域名</strong>（New gTLD），因此任何公司、机构都有权向 ICANN 申请新的顶级域。</p> <p>用域名树来表示互联网的域名系统是最清楚的。图 6-1 是互联网域名空间的结构，它实际上是一个倒过来的树，在最上面的是根，但没有对应的名字。根下面一级的节点就是最高一级的顶级域名（由于根没有名字，所以在根下面一级的域名就叫做顶级域名）。顶级域名可往下划分子域，即二级域名。再往下划分就是三级域名、四级域名，等等。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-Internet's-domain-name-space-480.webp 480w,/assets/images/computer-network/the-Internet's-domain-name-space-800.webp 800w,/assets/images/computer-network/the-Internet's-domain-name-space-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/the-Internet's-domain-name-space.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="互联网的域名空间" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 图 6-1 互联网的域名空间 </div> <h3 id="13-域名服务器">1.3 域名服务器</h3> <p>一个服务器所负责管辖的（或有权限的）范围叫做<strong>区</strong>（zone）。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每个区设置相应的<strong>权限域名服务器</strong>（authoritative name server），用来保存该区中的所有主机的域名到 IP 地址的映射。由此看出，DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。区是 DNS 服务器实际管辖的范围。区可能等于或小于域，但一定不能大于域。</p> <p>图 6-2 是区的不同划分方法的举例。假定 abc 公司有下属部门 x 和 y，部门 x 下面又分三个分部门 u，v 和 w，而 y 下面还有其下属部门 t。图 6-2（a）表示 abc 公司只设一个区 <code class="language-plaintext highlighter-rouge">abc.com</code>。这时，区 <code class="language-plaintext highlighter-rouge">abc.com</code> 和域 <code class="language-plaintext highlighter-rouge">abc.com</code> 指的是同一件事。但图 6-2（b）表示 abc 公司划分了两个区（大的公司可能要划分多个区）：<code class="language-plaintext highlighter-rouge">abc.com</code> 和 <code class="language-plaintext highlighter-rouge">y.abc.com</code>。这两个区都隶属于域 <code class="language-plaintext highlighter-rouge">abc.com</code>，都各设置了相应的权限域名服务器。不难看出，区是“域”的子集。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/examples-of-DNS-zones-480.webp 480w,/assets/images/computer-network/examples-of-DNS-zones-800.webp 800w,/assets/images/computer-network/examples-of-DNS-zones-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/examples-of-DNS-zones.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="DNS 划分区的举例" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 图 6-2 DNS 划分区的举例 </div> <p>图 6-3 以图 6-2（b）中公司 abc 划分的两个区为例，给出了 DNS 域名服务器树状结构图。在图 6-3 中的每个域名服务器都能够进行部分域名到 IP 地址的解析。当某个 DNS 服务器不能进行域名到 IP 地址的转换时，它就设法找互联网上别的域名服务器进行解析。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/tree-structure-of-DNS-domain-name-server-480.webp 480w,/assets/images/computer-network/tree-structure-of-DNS-domain-name-server-800.webp 800w,/assets/images/computer-network/tree-structure-of-DNS-domain-name-server-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/tree-structure-of-DNS-domain-name-server.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="树状结构的 DNS 域名服务器" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 图 6-3 树状结构的 DNS 域名服务器 </div> <p>从图 6-3 可看出，互联网上的 DNS 域名服务器是按照层次安排的。每个域名服务器都只对域名体系中的一部分进行管辖。根据域名服务器所起的作用，可以把域名服务器划分为以下四种不同的类型：</p> <ul> <li> <strong>根域名服务器</strong>（root name server）：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。根域名服务器是最重要的域名服务器，因为不管是哪个本地域名服务器，若要对互联网上任何一个域名进行解析（即转换为 IP 地址），只要自己无法解析，就首先要求助于根域名服务器。假定所有的根域名服务器都瘫痪了，那么整个互联网中的 DNS 系统就无法工作。据统计，到 2016 年2 月，全世界已经在 588 个<strong>地点</strong>（地点数值还在不断增加）安装了根域名服务器，但这么多的根域名服务器却只使用 13 个不同 IP 地址的域名，即 <code class="language-plaintext highlighter-rouge">a.rootservers.net</code>，<code class="language-plaintext highlighter-rouge">b.rootservers.net</code>，…，<code class="language-plaintext highlighter-rouge">m.rootservers.net</code>。注意，虽然互联网的根域名服务器总共只有 13 个域名，但这不表明根域名服务器是由 13 台<strong>机器</strong>所组成。实际上，在互联网中是由 13 套装置（13 installations）构成这 13 组根域名服务器[W-ROOT]。每套装置在很多地点安装根域名服务器（也可称为镜像根服务器），但都使用同一个域名。为了提供更可靠的服务，在每个地点的根域名服务器往往由多台机器组成。现在世界上大部分 DNS 域名服务器，都能就近找到一个根域名服务器查询 IP 地址（现在这些根域名服务器都已增加了 IPv6 地址）。为了方便，人们常用从 <code class="language-plaintext highlighter-rouge">A</code> 到 <code class="language-plaintext highlighter-rouge">M</code> 的前 13 个英文字母中的一个，来表示某组根域名服务器。注意，在许多情况下，根域名服务器并不直接把待查询的域名直接转换成 IP 地址（根域名服务器也没有存放这种信息），而是告诉本地域名服务器下一步应当找哪个顶级域名服务器进行查询。</li> <li> <strong>顶级域名服务器</strong>（即 TLD 服务器）：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</li> <li> <strong>权限域名服务器</strong>：指负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪个权限域名服务器。例如在图 6-2（b）中，区 <code class="language-plaintext highlighter-rouge">abc.com</code> 和区 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 各设有一个权限域名服务器。</li> <li> <strong>本地域名服务器</strong>（local name server）：本地域名服务器并不属于图 6-3 所示的域名服务器层次结构，但它对域名系统非常重要。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每个互联网服务提供者 ISP，都可以拥有一个<strong>本地域名服务器</strong>，这种域名服务器有时也称为<strong>默认域名服务器</strong>。本地域名服务器离用户较近，一般不超过几个路由器的距离。当所要查询的主机也属于同一个本地 ISP 时，该本地域名服务器立即就能将所查询的主机名转换为它的 IP 地址，而不需要再去询问其他的域名服务器。</li> </ul> <p>为了提高域名服务器的可靠性， DNS域名服务器都把数据复制到几个域名服务器来保存，其中的一个是<strong>主域名服务器</strong>（master name server），其他的是<strong>辅助域名服务器</strong>（secondary name server）。当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。</p> <p>下面简单讨论一下域名的解析过程。这里要注意两点。</p> <ol> <li>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>（recursive query）。即：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</li> <li>本地域名服务器向根域名服务器的查询通常是采用<strong>迭代查询</strong>（iterative query）。迭代查询的特点是这样的：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪个域名服务器进行查询”。然后让本地域名服务器进行后续的查询（而不是替本地域名服务器进行后续的查询）。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地域名服务器下一步应当向哪个权限域名服务器进行查询，本地域名服务器就这样进行迭代查询。最后，知道了所要解析的域名的 IP 地址，然后把这个结果返回给发起查询的主机。当然，本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文的设置是要求使用哪种查询方式。</li> </ol> <p>图 6-5 用例子说明了这两种查询的区别。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/a-DNS-query-example-480.webp 480w,/assets/images/computer-network/a-DNS-query-example-800.webp 800w,/assets/images/computer-network/a-DNS-query-example-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/a-DNS-query-example.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="DNS 查询举例" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 图 6-5 DNS 查询举例 </div> <p>假定域名为 <code class="language-plaintext highlighter-rouge">m.xyz.com</code> 的主机想知道另一台主机（域名为 <code class="language-plaintext highlighter-rouge">y.abc.com</code>）的 IP 地址。例如，主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code> 打算发送邮件给主机 <code class="language-plaintext highlighter-rouge">y.abc.com</code>。这时就必须知道主机 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址。下面是图 6-5（a）的几个查询步骤：</p> <ol> <li>主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code> 先向其本地域名服务器 <code class="language-plaintext highlighter-rouge">dns.xyz.com</code> 进行递归查询。</li> <li>本地域名服务器采用迭代查询。它先向一个根域名服务器查询。</li> <li>根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器 <code class="language-plaintext highlighter-rouge">dns.com</code> 的 IP 地址。</li> <li>本地域名服务器向顶级域名服务器 <code class="language-plaintext highlighter-rouge">dns.com</code> 进行查询。</li> <li>顶级域名服务器 <code class="language-plaintext highlighter-rouge">dns.com</code> 告诉本地域名服务器，下一次应查询的权限域名服务器 <code class="language-plaintext highlighter-rouge">dns.abc.com</code> 的 IP 地址。</li> <li>本地域名服务器向权限域名服务器 <code class="language-plaintext highlighter-rouge">dns.abc.com</code> 进行查询。</li> <li>权限域名服务器 <code class="language-plaintext highlighter-rouge">dns.abc.com</code> 告诉本地域名服务器，所查询的主机的 IP 地址。</li> <li>本地域名服务器最后把查询结果告诉主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code>。</li> </ol> <p>我们注意到，这 8 个步骤总共要使用 8 个 UDP 用户数据报的报文。本地域名服务器经过三次迭代查询后，从权限域名服务器 <code class="language-plaintext highlighter-rouge">dns.abc.com</code> 得到了主机 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址，最后把结果返回给发起查询的主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code>。</p> <p>图 6-5（b）是本地域名服务器采用递归查询的情况。在这种情况下，本地域名服务器只需向根域名服务器查询一次，后面的几次查询都是在其他几个域名服务器之间进行的（步骤 3 至 6）。只是在步骤 7，本地域名服务器从根域名服务器得到了所需的 IP 地址。最后在步骤 8，本地域名服务器把查询结果告诉主机 <code class="language-plaintext highlighter-rouge">m.xyz.com</code>。整个的查询也是使用 8个 UDP 报文。</p> <p>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>（有时也称为高速缓存域名服务器）。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p> <p>例如，在图 6-5（a）的查询过程中，如果在不久前已经有用户查询过域名为 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址，那么本地域名服务器就不必向根域名服务器重新查询 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址，而是直接把高速缓存中存放的上次查询结果（即 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的 IP 地址）告诉用户。假定本地域名服务器的缓存中并没有 <code class="language-plaintext highlighter-rouge">y.abc.com</code> 的IP 地址，而是存放着顶级域名服务器 <code class="language-plaintext highlighter-rouge">dns.com</code> 的 IP 地址，那么本地域名服务器也可以不向根域名服务器进行查询，而是直接向 com 顶级域名服务器发送查询请求报文。这样不仅可以大大减轻根域名服务器的负荷，而且也能够使互联网上的 DNS 查询请求和回答报文的数量大为减少。</p> <h2 id="二文件传送协议">二、文件传送协议</h2> <h3 id="21">2.1</h3> <p>FTP 概述 文件传送协议 FTP （File Transfer Protocol） [RFC 959]是互联网上使用得最广泛的文件传 送协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用 ASCII 码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）。 FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。RFC 959 很早就成为了互联网的正式标准。 在互联网发展的早期阶段，用FTP 传送文件约占整个互联网的通信量的三分之一，而 由电子邮件和域名系统所产生的通信量还小于 FTP 所产生的通信量。只是到了 1995 年， WWW 的通信量才首次超过了FTP。 在下面 6。2。2 和 6。2。3 节分别介绍基于TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP，它们都是文件共享协议中的一大类，即复制整个文件，其特点是：若要存取一个文 件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然 后再将修改后的文件副本传回到原节点。 文件共享协议中的另一大类是联机访问（on-line access）。联机访问意味着允许多个程序 同时对一个文件进行存取。和数据库系统的不同之处是用户不需要调用一个特殊的客户进 程，而是由操作系统提供对远地共享文件进行访问的服务，就如同对本地文件的访问一样。 这就使用户可以用远地文件作为输入和输出来运行任何应用程序，而操作系统中的文件系统 则提供对共享文件的透明存取。透明存取的优点是：将原来用于处理本地文件的应用程序用 来处理远地文件时，不需要对该应用程序作明显的改动。属于文件共享协议的有网络文件系 统NFS （Network File System） [COME06]。网络文件系统NFS最初是在UNIX 操作系统环境 下实现文件和目录共享的。NFS 可使本地计算机共享远地的资源，就像这些资源在本地一 样。由于 NFS 原先是美国 SUN 公司在 TCP/IP 网络上创建的，因此目前 NFS 主要应用在 TCP/IP 网络上。然而现在 NFS 也可在 OS/2， MS-Windows， NetWare 等操作系统上运行。 NFS 还没有成为互联网的正式标准。经过几次修订更新，现在的最新版本（NFSv4）于 2015 年 3 月发布[RFC 7530]，目前还只是建议标准。限于篇幅，本书不讨论 NFS 的详细工 作过程。</p> <h3 id="22-ftp-的基本工作原理">2.2 FTP 的基本工作原理</h3> <p>网络环境中的一项基本应用就是将文件从一台计算机中复制到另一台可能相距很远的 计算机中。初看起来，在两台主机之间传送文件是很简单的事情。其实这往往非常困难。原 因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。经常遇到的问题是： （1） 计算机存储数据的格式不同。 （2） 文件的目录结构和文件命名的规定不同。 （3）对于相同的文件存取功能，操作系统使用的命令不同。 （4） 访问控制方法不同。 文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用TCP 可靠的运输服务。 FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。 FTP 使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程， 负责处理单个请求。 主进程的工作步骤如下： （1） 打开熟知端口（端口号为21），使客户进程能够连接上。 （2） 等待客户进程发出连接请求。 （3） 启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即 终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。 （4） 回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并 发进行的。 FTP 的工作情况如图6-6所示。图中的椭圆圈表示在系统中运行的进程。图中的服务器 端有两个从属进程：控制进程和数据传送进程。为简单起见，服务器端的主进程没有画上。 客户端除了控制进程和数据传送进程外，还有一个用户界面进程用来和用户接口。 在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：“控制连 接”和“数据连接”。控制连接在整个会话期间一直保持打开， FTP 客户所发出的传送请 求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传 输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后</p> <p>就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数 据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。由于 FTP 使用了一个分离的控制连接，因此 FTP 的控制信息是带外（out of band）传送的。 用户界面 TCP控制连接 控制进程 控制进程 互联网 数据传送 进程 数据传送 进程 FTP客户端 TCP 数据连接 FTP服务器端 图 6-6 FTP使用的两个TCP连接</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 21， 同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进 程用自己传送数据的熟知端口 20 与客户进程所提供的端口号建立数据传送连接。由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。 使用两个独立的连接的主要好处是使协议更加简单和更容易实现，同时在传输文件时 还可以利用控制连接对文件的传输进行控制。例如，客户发送“请求终止传输”。 FTP 并非对所有的数据传输都是最佳的。例如，计算机 A 上运行的应用程序要在远地 计算机 B 的一个很大的文件末尾添加一行信息。若使用 FTP，则应先将此文件从计算机 B 传送到计算机 A，添加上这一行信息后，再用FTP 将此文件传送到计算机 B，来回传送 这样大的文件很花时间。实际上这种传送是不必要的，因为计算机 A 并没有使用该文件的 内容。 然而网络文件系统 NFS 则采用另一种思路。NFS 允许应用进程打开一个远地文件，并 能在该文件的某一个特定的位置上开始读写数据。这样，NFS 可使用户只复制一个大文件 中的一个很小的片段，而不需要复制整个大文件。对于上述例子，计算机A中的 NFS 客户 软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 中的 NFS 服 务器，NFS 服务器更新文件后返回应答信息。在网络上传送的只是少量的修改数据。</p> <h3 id="23-简单文件传送协议-tftp">2.3 简单文件传送协议 TFTP</h3> <p>TCP/IP 协议族中还有一个简单文件传送协议 TFTP （Trivial File Transfer Protocol），它是 一个很小且易于实现的文件传送协议。TFTP 的版本是互联网的正式标准[RFC1350]。虽 然 TFTP 也使用客户服务器方式，但它使用UDP 数据报，因此 TFTP 需要有自己的差错改 正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录 的功能，也不能对用户进行身份鉴别。 TFTP 的主要优点有两个。第一，TFTP 可用于 UDP 环境。例如，当需要将程序或文件 同时向许多机器下载时就往往需要使用TFTP。第二，TFTP 代码所占的内存较小。这对较 小的计算机或某些特殊用途的设备是很重要的。这些设备不需要硬盘，只需要固化了 TFTP、UDP 和 IP 的小容量只读存储器即可。当接通电源后，设备执行只读存储器中的代 码，在网络上广播一个 TFTP 请求。网络上的 TFTP 服务器就发送响应，其中包括可执行二 进制程序。设备收到此文件后将其放入内存，然后开始运行程序。这种方式增加了灵活性， 也减少了开销。 TFTP的主要特点是： （1） 每次传送的数据报文中有512字节的数据，但最后一次可不足 512 字节。 （2）数据报文按序编号，从1开始。 （3） 支持 ASCII 码或二进制传送。 （4）可对文件进行读或写。 （5） 使用很简单的首部。 TFTP 的工作很像停止等待协议（见第 5 章 5。4。1 节）。发送完一个文件块后就等待对方 的确认，确认时应指明所确认的块编号。发完数据后在规定时间内收不到确认就要重发数据 PDU。发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这 样就可保证文件的传送不致因某一个数据报的丢失而告失败。 在一开始工作时。TFTP客户进程发送一个读请求报文或写请求报文给 TFTP 服务器进 程，其熟知端口号码为 69。TFTP服务器进程要选择一个新的端口和 TFTP 客户进程进行通 信。若文件长度恰好为512字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只 含首部而无数据的数据报文。若文件长度不是512字节的整数倍，则最后传送数据报文中的 数据字段一定不满512字节，这正好可作为文件结束的标志。</p> <h2 id="三远程终端协议-telnet">三、远程终端协议 TELNET</h2> <p>TELNET 是一个简单的远程终端协议[RFC 854]，它也是互联网的正式标准。用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录到远地的另一台主机上（使用主机 名或 IP 地址）。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接 连在远地主机上。因此，TELNET 又称为终端仿真协议。 TELNET 并不复杂，以前应用得很多。现在由于计算机的功能越来越强，用户已较少 使用TELNET了。 TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机 则运行 TELNET 服务器进程。和FTP的情况相似，服务器中的主进程等待新的请求，并产 生从属进程来处理每一个连接。 TELNET 能够适应许多计算机和操作系统的差异。例如，对于文本中一行的结束，有 的系统使用 ASCII 码的回车（CR），有的系统使用换行（LF），还有的系统使用两个字符，回车 -换行（CR-LF）。又如，在中断一个程序时，许多系统使用 Control-C （^C），但也有系统使用 ESC 按键。为了适应这种差异，TELNET 定义了数据和命令应怎样通过互联网。这些定义 就是所谓的网络虚拟终端 NVT （Network Virtual Terminal）。图 6-7 说明了 NVT 的意义。客户 软件把用户的击键和命令转换成NVT格式，并送交服务器。服务器软件把收到的数据和命 令从 NVT 格式转换成远地系统所需的格式。向用户返回数据时，服务器把远地系统的格式 转换为 NVT 格式，本地客户再从NVT 格式转换到本地系统所需的格式。 TELNET 客户端 TELNET 互联网 服务器端 TCP连接 客户 【服务器 使用客户端的格式 使用NVT 格式 使用服务器端的格式 图 6-7 TELNET 使用网络虚拟终端 NVT 格式</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"></div> <p>NVT 的格式定义很简单。所有的通信都使用8位一个字节。在运转时，NVT 使用7位 ASCII 码传送数据，而当高位置1时用作控制命令。ASCII 码共有95 个可打印字符（如字 母、数字、标点符号）和 33 个控制字符。所有可打印字符在 NVT 中的意义和在 ASCII 码 中一样。但 NVT 只使用了 ASCII 码的控制字符中的几个。此外，NVT 还定义了两字符的 CR-LF 为标准的行结束控制符。当用户键入回车按键时，TELNET 的客户就把它转换为 CR-LF 再进行传输，而TELNET 服务器要把 CR-LF 转换为远地机器的行结束字符。 TELNET 的选项协商（Option Negotiation）使 TELNET 客户和 TELNET 服务器可商定使 用更多的终端功能，协商的双方是平等的。</p> <h2 id="四万维网-www">四、万维网 WWW</h2> <h3 id="41-万维网概述">4.1 万维网概述</h3> <p><strong>万维网是一个大规模的、联机式的信息储藏所</strong>，英文简称为 Web。万维网以客户服务器方式工作。<strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>。</p> <p>万维网使用<strong>统一资源定位符</strong> URL（Uniform Resource Locator）来标志万维网上的各种文档，并使每个文档在整个互联网的范围内具有唯一的标识符 URL。客户程序与服务器程序之间的交互使用<strong>超文本传送协议</strong> HTTP（HyperText Transfer Protocol）。HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。万维网使用<strong>超文本标记语言</strong> HTML（HyperText Markup Language），使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来。</p> <h3 id="42-统一资源定位符-url">4.2 统一资源定位符 URL</h3> <h4 id="1url-的格式">（1）URL 的格式</h4> <p><strong>统一资源定位符</strong> URL 用来表示从互联网上的资源位置和访问这些资源的方法。互联网上的所有资源，都有一个唯一确定的 URL。URL 的一般形式由以下四个部分组成：</p> \[&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;\] <h4 id="2使用-http-的-url">（2）使用 HTTP 的 URL</h4> <p>对于万维网的网点的访问要使用 HTTP 协议。HTTP 的 URL 的一般形式是：</p> \[http://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;\] <p>HTTP 的默认端口号是 80，通常可省略。URL 里面的字母不分大小写。</p> <h3 id="43-超文本传送协议-http">4.3 超文本传送协议 HTTP</h3> <h4 id="1http-的操作过程">（1）HTTP 的操作过程</h4> <p>HTTP 协议定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP 是<strong>面向事务的</strong>（transaction-oriented）应用层协议，它是万维网上能够可靠地交换文件的重要基础。万维网的大致工作过程如图 6-9 所示。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/how-the-World-Wide-Web-works-480.webp 480w,/assets/images/computer-network/how-the-World-Wide-Web-works-800.webp 800w,/assets/images/computer-network/how-the-World-Wide-Web-works-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/how-the-World-Wide-Web-works.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="万维网的工作过程" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 图 6-9 万维网的工作过程 </div> <p>HTTP 使用面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。HTTP 不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP 协议<strong>本身是无连接的</strong>。这就是说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立 HTTP 连接。</p> <p>HTTP 协议是<strong>无状态的</strong>（stateless）。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同（假定现在服务器还没有把该页面更新），因为服务器并不记得曾经访问过的这个客户，也不记得为该客户曾经服务过多少次。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的 HTTP 请求。</p> <p>用户在点击鼠标链接某个万维网文档时，HTTP 协议首先要和服务器建立 TCP 连接。这需要使用三报文握手。当建立 TCP 连接的三报文握手的前两部分完成后（即经过了一个 RTT 时间后），万维网客户就把 HTTP 请求报文，作为建立 TCP 连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到 HTTP 请求报文后，就把所请求的文档作为响应报文返回给客户。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/the-time-required-to-request-a-World-Wide-Web-document-480.webp 480w,/assets/images/computer-network/the-time-required-to-request-a-World-Wide-Web-document-800.webp 800w,/assets/images/computer-network/the-time-required-to-request-a-World-Wide-Web-document-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/the-time-required-to-request-a-World-Wide-Web-document.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="请求一个万维网文档所需的时间" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 图 6-10 请求一个万维网文档所需的时间 </div> <p>从图 6-10 可看出，请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上两倍往返时间 RTT（一个 RTT 用于连接 TCP 连接，另一个RTT 用于请求和接收万维网文档。TCP 建立连接的三报文握手的第三个报文段中的数据，就是客户对万维网文档的请求报文）。</p> <ul> <li>HTTP/1.0 的主要缺点，是每请求一个文档就要有两倍 <code class="language-plaintext highlighter-rouge">RTT</code> 的开销。若一个主页上有很多链接的对象（如图片等）需要依次进行链接，那么每次链接下载都导致 <code class="language-plaintext highlighter-rouge">2 × RTT</code> 的开销。</li> <li>另一种开销就是万维网客户和服务器每次建立新的 TCP 连接都要分配缓存和变量。特别是万维网服务器往往要同时服务于大量客户的请求，所以这种<strong>非持续连接</strong>会使万维网服务器的负担很重。</li> </ul> <p>HTTP/1.1 协议较好地解决了这个问题，它使用<strong>持续连接</strong>（persistent connection）。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。目前一些流行的浏览器的默认设置就使用了 HTTP/1.1。</p> <p>HTTP/1。1 协议的持续连接有两种工作方式，即<strong>非流水线方式</strong>（without pipelining）和<strong>流水线方式</strong>（with pipelining）。</p> <ul> <li>非流水线方式的特点，是客户在收到前一个响应后才能发出下一个请求。因此，在 TCP 连接已建立后，客户每访问一次对象都要用去一个往返时间 <code class="language-plaintext highlighter-rouge">RTT</code>。这比非持续连接要用去两倍 <code class="language-plaintext highlighter-rouge">RTT</code> 的开销，节省了建立 TCP 连接所需的一个 <code class="language-plaintext highlighter-rouge">RTT</code> 时间。但非流水线方式还是有缺点的，因为服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</li> <li>流水线方式的特点，是客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用流水线方式时，客户访问所有的对象只需花费一个 <code class="language-plaintext highlighter-rouge">RTT</code> 时间。流水线工作方式使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li> </ul> <h4 id="2代理服务器">（2）代理服务器</h4> <p><strong>代理服务器</strong>（proxy server）是一种网络实体，它又称为<strong>万维网高速缓存</strong>（Web cache）。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器端工作，也可在中间系统上工作。</p> <p>设图 6-11（a）是校园网不使用代理服务器的情况。这时，校园网中所有的计算机都通过 2Mbit/s 专线链路（\(R_1 - R_2\)）与互联网上的源点服务器建立 TCP 连接。因而校园网各计算机访问互联网的通信量往往会使这条 2 Mbit/s 的链路过载，使得时延大大增加。</p> <p>图 6-11（b）是校园网使用代理服务器的情况。这时，访问互联网的过程是这样的：</p> <ol> <li>校园网的计算机中的浏览器向互联网的服务器请求服务时，就先和校园网的代理服务器建立 TCP 连接，并向代理服务器发出 HTTP 请求报文（见图 6-11（b）中的 ❶）。</li> <li>若代理服务器已经存放了所请求的对象，代理服务器就把这个对象放入 HTTP 响应报文中返回给计算机的浏览器。</li> <li>否则，代理服务器就代表发出请求的用户浏览器，与互联网上的<strong>源点服务器</strong>（origin server）建立 TCP 连接（如图 6-11（b）中的 ❷ 所示），并发送 HTTP 请求报文。</li> <li>源点服务器把所请求的对象放在 HTTP 响应报文中返回给校园网的代理服务器。</li> <li>代理服务器收到这个对象后，先复制在自己的本地存储器中（留待以后用），然后再把这个对象放在 HTTP 响应报文中，通过已建立的 TCP 连接（见图 6-11（b）中的 ❶），返回给请求该对象的浏览器。</li> </ol> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/function-of-proxy-server-480.webp 480w,/assets/images/computer-network/function-of-proxy-server-800.webp 800w,/assets/images/computer-network/function-of-proxy-server-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/function-of-proxy-server.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="代理服务器的作用" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 图 6-11 代理服务器的作用 </div> <p>代理服务器有时是作为服务器（当接受浏览器的 HTTP 请求时），有时是作为客户（当向互联网上的源点服务器发送 HTTP 请求时）。在使用代理服务器的情况下，由于有相当大一部分通信量局限在校园网的内部，因此，2 Mbit/s 专线链路（\(R_1 - R_2\)）上的通信量大大减少，因而减小了访问互联网的时延。</p> <h4 id="3http-的报文结构">（3）HTTP 的报文结构</h4> <p>HTTP 有两类报文：</p> <ul> <li>请求报文——从客户向服务器发送请求报文，见图 6-12（a）。</li> <li>响应报文——从服务器到客户的回答，见图 6-12（b）。</li> </ul> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/HTTP-packet-structure-480.webp 480w,/assets/images/computer-network/HTTP-packet-structure-800.webp 800w,/assets/images/computer-network/HTTP-packet-structure-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/HTTP-packet-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP 的报文结构" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 图 6-12 HTTP 的报文结构 </div> <p>由于 HTTP 是<strong>面向文本的</strong>（text-oriented），因此在报文中的每个字段都是一些 ASCII 码串，因而各个字段的长度都是不确定的。 HTTP 请求报文和响应报文都由三个部分组成，这两种报文格式的区别是开始行不同。</p> <ul> <li> <strong>开始行</strong>，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做<strong>请求行</strong>（Request-Line），而在响应报文中的开始行叫做<strong>状态行</strong>（Status-Line）。在开始行的三个字段之间都以空格分隔开，最后的 “CR” 和 “LF” 分别代表“回车”和“换行”。</li> <li> <strong>首部行</strong>，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每个首部行中都有首部字段名和它的值，每行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</li> <li> <strong>实体主体</strong>，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</li> </ul> <p>请求报文的第一行“请求行”只有三个内容，即方法、请求资源的 URL、HTTP 的版本。所谓“方法”就是对所请求的对象进行的操作，这些方法实际上也就是一些命令。因此，请求报文的类型是由它所采用的方法决定的。表 6-1 给出了请求报文中常用的几种方法。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/some-methods-of-HTTP-request-messages-480.webp 480w,/assets/images/computer-network/some-methods-of-HTTP-request-messages-800.webp 800w,/assets/images/computer-network/some-methods-of-HTTP-request-messages-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/some-methods-of-HTTP-request-messages.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="HTTP请求报文的一些方法" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 表 6-1 HTTP请求报文的一些方法 </div> <p>响应报文的第一行是状态行。状态行包括三项内容，即HTTP 的版本，状态码，以及解释状态码的简单短语。 <strong>状态码</strong>（Status-Code）都是三位数字的，分为 5 大类，这 5 大类的状态码都是以不同的数字开头的。</p> <ul> <li> <strong>1xx</strong> 表示通知信息，如请求收到了或正在进行处理。</li> <li> <strong>2xx</strong> 表示成功，如接受或知道了。</li> <li> <strong>3xx</strong> 表示重定向，如要完成请求还必须采取进一步的行动。</li> <li> <strong>4xx</strong> 表示客户的差错，如请求中有错误的语法或不能完成。</li> <li> <strong>5xx</strong> 表示服务器的差错，如服务器失效无法完成请求。</li> </ul> <h4 id="4在服务器上存放用户的信息">（4）在服务器上存放用户的信息</h4> <p>HTTP 是无状态的，但在实际工作中，却常常希望能够识别用户。要做到这点，可以在 HTTP 中使用 Cookie。</p> <p>Cookie 是这样工作的。当用户 <code class="language-plaintext highlighter-rouge">A</code> 浏览某个使用 Cookie 的网站时，该网站的服务器就为 <code class="language-plaintext highlighter-rouge">A</code> 产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目。接着在给 <code class="language-plaintext highlighter-rouge">A</code> 的 HTTP 响应报文中添加一个叫做 <code class="language-plaintext highlighter-rouge">Set-cookie</code> 的首部行。例如这个首部行是这样的：</p> \[Set-cookie: 31d4d96e407aad42\] <p>当 <code class="language-plaintext highlighter-rouge">A</code> 收到这个响应时，其浏览器就在它管理的特定 Cookie 文件中添加一行，其中包括这个服务器的主机名和 <code class="language-plaintext highlighter-rouge">Set-cookie</code> 后面给出的识别码。当 <code class="language-plaintext highlighter-rouge">A</code> 继续浏览这个网站时，每发送一个 HTTP 请求报文，其浏览器就会从其 Cookie 文件中取出这个网站的识别码，并放到 HTTP 请求报文的 Cookie 首部行中：</p> \[Cookie: 31d4d96e407aad42\] <p>于是，这个网站就能够跟踪用戶 <code class="language-plaintext highlighter-rouge">31d4d96e407aad42</code>（用户 <code class="language-plaintext highlighter-rouge">A</code>）在该网站的活动。</p> <h3 id="44-万维网的文档">4.4 万维网的文档</h3> <h4 id="1超文本标记语言-html">（1）超文本标记语言 HTML</h4> <p>要使任何一台计算机都能显示出任何一个万维网服务器上的页面，就必须解决页面制 作的标准化问题。超文本标记语言 HTML （HyperText Markup Language）就是一种制作万维 网页面的标准语言，它消除了不同计算机之间信息交流的障碍。但请注意，HTML 并不是 应用层的协议，它只是万维网浏览器使用的一种语言。由于 HTML 非常易于掌握且实施简 单，因此它很快就成为万维网的重要基础[RFC 2854]。官方的 HTML 标准由万维网联盟 W3C（即WWW Consortium）负责制定。有关 HTML 的一些参考资料见[W-HTML]。从 HTML 在 1993 年问世后，就不断地对其版本进行更新。现在最新的版本是 HTML 5。0 （2014 年 9 月发布），新的版本增加了在网页中嵌入音频、视频以及交互式文档等功能。现 在一些主流的浏览器都支持HTML 5。0。 HTML 定义了许多用于排版的命令，即“标签”（tag）。例如，<i>表示后面开始用斜体 字排版，而</i>则表示斜体字排版到此结束。HTML 把各种标签嵌入到万维网的页面中，这 样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器（例如， Windows 的记事本 Notepad）创建的ASCII 码文件。但应注意，仅当 HTML 文档是以。html 或。htm 为后缀时，浏览器才对这样的 HTML 文档的各种标签进行解释。如果 HTML 文档 改为以。txt 为其后缀，则 HTML 解释程序就不对标签进行解释，而浏览器只能看见原来的文 本文件。 并非所有的浏览器都支持所有的 HTML 标签。若某一个浏览器不支持某一个 HTML 标 签，则浏览器将忽略此标签，但在一对不能识别的标签之间的文本仍然会被显示出来。 下面是一个简单例子，用来说明 HTML 文档中标签的用法。在每一个语句后面的花括 号中的字是给读者看的注释，在实际的 HTML 文档中并没有这种注释。</p> <title>一个 HTML 的例子</title> <h1>HTML 很容易掌握</h1> <p>这是第一个段落。</p> {HTML 文档开始} {首部开始} {“一个 HTML 的例子”是文档的标题} {首部结束} {主体开始} {“HTML 很容易掌握”是主体的1级题头} {<p>和</p>之间的文字是一个段落} <p>这是第二个段落。</p> <p>{&lt;P&gt;和&lt;/P&gt;之间的文字是一个段落} {主体结束} {HTML 文档结束} 把上面的 HTML 文档存入D盘的文件夹 HTML 中，文件名是HTML-example。html（注 意：实际的文档中没有注释部分）。当浏览器读取了该文档后，就按照 HTML 文档中的各种 标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并显示出来。图 6-13 表示 IE 浏览器在计算机屏幕上显示出的与该文档有关部分的画面。文档的标题（title）“一个 HTML 的例子”显示在浏览器最上面的标题栏中。文件的路径显示在地址栏中。再下面就 是文档的主体部分。主体部分的题头（heading），即文档主体部分的标题“HTML 很容易掌 握”，用较大的字号显示出来，因为在标签中指明了使用的是1级题头&lt;H1&gt;。 目前已开发出了很好的制作万维网页面的软件工具，使我们能够像使用 Word 文字处理 器那样很方便地制作各种页面。即使我们用 Word 文字处理器编辑了一个文件，但只要在 “另存为（Save As）”时选取文件后缀为。htm 或。html，就可以很方便地把 Word 的。doc 格式文 件转换为浏览器可以显示的HTML 格式的文档。 a 个HTML的例子 icrosoft Internet Explorer 文件（z） 编辑（g） 查看收款（a） 工具） 帮助 Q 地址（ ep1。html D：\HTML\HTHL-ex HTML很容易掌握 这是第一个段落、 这是第二个段落。 图6-13 在屏幕上显示的HTML 文档主体部分的例子</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>HTML 允许在万维网页面中插入图像。一个页面本身带有的图像称为内含图像（inline image）。HTML 标准并没有规定该图像的格式。实际上，大多数浏览器都支持 GIF 和 JPEG 文件。很多格式的图像占据的存储空间太大，因而这种图像在互联网传送时就很浪费时间。 例如，一幅位图文件（。bmp）可能要占用 500 ~ 700 KB 的存储空间。但若将此图像改存为经压 缩的 。gif 格式，则可能只有十几个千字节，大大减少了存储空间。 HTML 还规定了链接的设置方法。我们知道每个链接都有一个起点和终点。链接的起 点说明在万维网页面中的什么地方可引出一个链接。在一个页面中，链接的起点可以是一个 字或几个字，或是一幅图，或是一段文字。在浏览器所显示的页面上，链接的起点是很容易 识别的。在以文字作为链接的起点时，这些文字往往用不同的颜色显示（例如，一般的文字 用黑色字时，链接起点往往使用蓝色字），甚至还会加上下划线（一般由浏览器来设置）。当 我们将鼠标移动到一个链接的起点时，表示鼠标位置的箭头就变成了一只手。这时只要点击 鼠标，这个链接就被激活。</p> <p>链接的终点可以是其他网站上的页面。这种链接方式叫做远程链接。这时必须在 HTML 文档中指明链接到的网站的URL。有时链接可以指向本计算机中的某一个文件或本 文件中的某处，这叫做本地链接。这时必须在HTML 文档中指明链接的路径。 实际上，现在这种链接方式已经不局限于用在万维网文档中。在最常用的 Word 文字处 理器的工具栏中，也设有“插入超链接”的按钮。只要点击这个按钮，就可以看到设置超链 接的窗口。用户可以很方便地在自己写的 Word 文档中设置各种链接的起点和终点。 在这一小节的最后，我们还要简单介绍一下和浏览器有关的几种其他语言。 XML （Extensible Markup Language）是可扩展标记语言，它和 HTML 很相似。但 XML 的设计宗旨是传输数据，而不是显示数据（HTML 是为了在浏览器上显示数据）。更具体 些，XML 用于标记电子文件，使其具有结构性的标记语言，可用来标记数据、定义数据类 型，是一种允许用户对自己的标记语言进行定义的源语言。XML 是一种简单、与平台无关 并被广泛采用的标准。XML 相对于 HTML 的优点是它将用户界面与结构化数据分隔开 来。这种数据与显示的分离使得集成来自不同源的数据成为可能。客户信息、订单、研究结 果、账单付款、病历、目录数据及其他信息都可以转换为 XML。XML 不是要替换 HTML，而是对 HTML 的补充。XML 标记由文档的作者定义，并且是无限制的。HTML 标记则是预定义的；HTML 作者只能使用当前 HTML 标准所支持的标记。 另一种语言 XHTML （Extensible HTML）是可扩展超文本标记语言，它与HTML 4。01 几 乎是相同的。但XHTML 是更严格的HTML 版本，也是一个W3C标准（2000年1月制 定），是作为一种 XML 应用被重新定义的HTML，并将逐渐取代HTML。所有新的浏览器 都支持 XHTML。 还有一种语言 CSS （Cascading Style Sheets）是层叠样式表，它是一种样式表语言，用于 为HTML 文档定义布局。CSS 与HTML 的区别就是：HTML 用于结构化内容，而 CSS 则 用于格式化结构化的内容。例如，在浏览器上显示的字体、颜色、边距、高度、宽度、背景 图像等方面，都能够给出精确的规定。现在所有的浏览器都支持 CSS。</p> <h4 id="2动态万维网文档">（2）动态万维网文档</h4> <p>上面所讨论的万维网文档只是万维网文档中最基本的一种，即所谓的静态文档（static document）。静态文档在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程 中，内容不会改变。由于这种文档的内容不会改变，因此用户对静态文档的每次读取所得到 的返回结果都是相同的。 静态文档的最大优点是简单。由于 HTML 是一种排版语言，因此静态文档可以由不懂 程序设计的人员来创建。但静态文档的缺点是不够灵活。当信息变化时就要由文档的作者手 工对文档进行修改。可见，变化频繁的文档不适于做成静态文档。 动态文档（dynamic document）是指文档的内容是在浏览器访问万维网服务器时才由应用 程序动态创建的。当浏览器请求到达时，万维网服务器要运行另一个应用程序，并把控制转 移到此应用程序。接着，该应用程序对浏览器发来的数据进行处理，并输出 HTTP 格式的文 档，万维网服务器把应用程序的输出作为对浏览器的响应。由于对浏览器每次请求的响应都 是临时生成的，因此用户通过动态文档所看到的内容是不断变化的。动态文档的主要优点是 具有报告当前最新信息的能力。例如，动态文档可用来报告股市行情、天气预报或民航售票 情况等内容。但动态文档的创建难度比静态文档的高，因为动态文档的开发不是直接编写文</p> <p>档本身，而是编写用于生成文档的应用程序，这就要求动态文档的开发人员必须会编程，而 所编写的程序还要通过大范围的测试，以保证输入的有效性。 动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方 法不同。而从浏览器的角度看，这两种文档并没有区别。动态文档和静态文档的内容都遵循 HTML 所规定的格式，浏览器仅根据在屏幕上看到的内容无法判定服务器送来的是哪一种 文档，只有文档的开发者才知道。 从以上所述可以看出，要实现动态文档就必须在以下两个方面对万维网服务器的功能 进行扩充： （1）应增加另一个应用程序，用来处理浏览器发来的数据，并创建动态文档。 （2）应增加一个机制，用来使万维网服务器将浏览器发来的数据传送给这个应用程序， 然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。 图 6-14 是扩充了功能的万维网服务器的示意图。这里增加了一个机制，叫做通用网关 接口 CGI （Common Gateway Interface）。CGI 是一种标准，它定义了动态文档应如何创建， 输入数据应如何提供给应用程序，以及输出结果应如何使用。 在万维网服务器中新增加的应用程序叫做 CGI 程序。取这个名字的原因是：万维网服 务器与 CGI 的通信遵循 CGI 标准。“通用”是因为这个标准所定义的规则对其他任何语言都 是通用的。“网关”二字的出现是因为 CGI程序还可能访问其他的服务器资源，如数据库或 图形软件包，因而 CGI程序的作用有点像一个网关。也有人将 CGI 程序简称为网关程序。 “接口”是因为有一些已定义好的变量和调用等可供其他 CGI 程序使用。请读者注意：在 看到 CGI 这个名词时，应弄清是指CGI 标准，还是指CGI程序。 万维网 万维网服务器 客户端 浏览器 互联网 ·程序 服务器 程序 数据库 HTTP CGD ② CGI 程序创建动态文档 ● 请求文档 HTTP请求报文 ● 响应动态 文档 HTTP 响应报文 图6-14 扩充了功能的万维网服务器</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>CGI 程序的正式名字是 CGI 脚本（script）。按照计算机科学的一般概念，“脚本”指的 是一个程序，它被另一个程序（解释程序）而不是计算机的处理机来解释或执行。有一些语 言专门作为脚本语言（script language），如 Perl， REXX（在IBM 主机上使用），JavaScript 以 及 Tcl/Tk等。脚本也可用一些常用的编程语言写出，如C，C++等。使用脚本语言可更容易 和更快地进行编码，这对一些有限功能的小程序是很合适的。但一个脚本运行起来比一般的</p> <p>编译程序要慢，因为它的每一条指令先要被另一个程序来处理（这就要一些附加的指令）， 而不是直接被指令处理器来处理。脚本不一定是一个独立的程序，它可以是一个动态装入的 库，甚至是服务器的一个子程序。 CGI 程序又称为 cgi-bin 脚本，这是因为在许多万维网服务器上，为便于找到 CGI 程 序，就将 CGI 程序放在/cgi-bin 的目录下。</p> <h4 id="3活动万维网文档">（3）活动万维网文档</h4> <p>随着 HTTP 和万维网浏览器的发展，上一节所述的动态文档已明显地不能满足发展的 需要。这是因为，动态文档一旦建立，它所包含的信息内容也就固定下来而无法及时刷新屏 幕。另外，像动画之类的显示效果，动态文档也无法提供。 有两种技术可用于浏览器屏幕显示的连续更新。一种技术称为服务器推送（server push），这种技术是将所有的工作都交给服务器。服务器不断地运行与动态文档相关联的应 用程序，定期更新信息，并发送更新过的文档。 尽管从用户的角度看，这样做可达到连续更新的目的，但这也有很大的缺点。首先， 为了满足很多客户的请求，服务器就要运行很多服务器推送程序。这将造成过多的服务器开 销。其次，服务器推送技术要求服务器为每一个浏览器客户维持一个不释放的 TCP 连接。 随着 TCP 连接的数目增加，每一个连接所能分配到的网络带宽就下降，这就导致网络传输 时延的增大。 另一种提供屏幕连续更新的技术是活动文档（active document）。这种技术是把所有的工 作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段活动文档程序副 本，使该程序副本在浏览器端运行。这时，活动文档程序可与用户直接交互，并可连续地改 变屏幕的显示。只要用户运行活动文档程序，活动文档的内容就可以连续地改变。由于活动 文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。 从传送的角度看，浏览器和服务器都把活动文档看成是静态文档。在服务器上的活动 文档的内容是不变的，这点和动态文档是不同的。浏览器可在本地缓存一份活动文档的副 本。活动文档还可处理成压缩形式，以便于存储和传送。另一点要注意的是，活动文档本身 并不包括其运行所需的全部软件，大部分的支持软件是事先存放在浏览器中的。图 6-15 说 明了活动文档的创建过程。 • 278 • 万维网 客户端 万维网服务器 浏览器 程序 互联网 服务器 程序 ● 请求文档 ● 此程序在 客户端创建 出活动文档 =D 文档 HTTP HTTP请求报文 HTTP响应报文 程序 ② 响应程序 程序| 程序事先被编译 图6-15 活动文档由服务器发送过来的程序在客户端创建</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>成二进制代码， 存放为文件</p> <p>由美国 SUN 公司开发的 Java 语言是一项用于创建和运行活动文档的技术。在 Java 技 术中使用了一个新的名词“小应用程序”（applet）来描述活动文档程序。当用户从万维网服 务器下载一个嵌入了Java 小应用程序的 HTML 文档后，用户可在浏览器的显示屏幕上点击 某个图像，然后就可看到动画的效果；或是在某个下拉式菜单中点击某个项目，即可看到根 据用户键入的数据所得到的计算结果。实际上，Java技术是活动文档技术的一部分。限于 篇幅，有关 Java技术的进一步讨论这里从略。</p> <h3 id="45-万维网的信息检索系统">4.5 万维网的信息检索系统</h3> <h4 id="1全文检索搜索与分类目录搜索">（1）全文检索搜索与分类目录搜索</h4> <p>万维网是一个大规模的、联机式的信息储藏所。那么，应当采用什么方法才能找到所 需的信息呢？如果已经知道存放该信息的网点，那么只要在浏览器的地址（Location）框内键 入该网点的 URL 并按回车键，就可进入该网点。但是，若不知道要找的信息在何网点，那 就要使用万维网的搜索工具。 在万维网中用来进行搜索的工具叫做搜索引擎（search engine）。搜索引擎的种类很多， 但大体上可划分为两大类，即全文检索搜索引擎和分类目录搜索引擎。 全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件（例如 一种叫做“蜘蛛”或“网络机器人”的 Spider 程序）到互联网上的各网站收集信息，找到 一个网站后可以从这个网站再链接到另一个网站，像蜘蛛爬行一样。然后按照一定的规则建 立一个很大的在线索引数据库供用户查询。用户在查询时只要输入关键词，就从已经建立的 索引数据库里进行查询（并不是实时地在互联网上检索到的信息）。因此很可能有些查到的 信息已经是过时的（例如很多年前的）。建立这种索引数据库的网站必须定期对已建立的数 据库进行更新维护（但不少网站的维护很不及时，因此对查找到的信息-定要注意其发布的 时间）。现在全球最大的并且最受欢迎的全文检索搜索引擎就是谷歌 Google （www。google。com）。谷歌提供的主要的搜索服务有：网页搜索、图片搜索、视频搜索、地图 搜索、新闻搜索、购物搜索、博客搜索、论坛搜索、学术搜索、财经搜索等。应全球用户的 需求，谷歌在美国及世界各地创建数据中心。至2013年底，谷歌的数据中心在全球共设有 12 处。大多数数据中心的业主基于信息安全考虑，极少透露其数据中心的信息及內部情 形。 我们将在下一小节简单介绍谷歌搜索技术的特点。现在“谷歌”不仅是网站名，而且 还是动词。例如，“谷歌一下”的意思就是“用谷歌网站进行信息搜索”。在全文检索搜索引 擎中另外两个著名的网站是美国微软的必应（cn。bing。com）和中国的百度（www。baidu。com）。 分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交网站信 息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条 件，则输入到分类目录的数据库中，供网上用户查询。因此，分类目录搜索也叫做分类网站 搜索。分类目录的好处就是用户可根据网站设计好的目录有针对性地逐级查询所需要的信</p> <p>息，查询时不需要使用关键词，只需要按照分类（先找大类，再找下面的小类），因而查询 的准确性较好。但分类目录查询的结果并不是具体的页面，而是被收录网站主页的 URL 地 址，因而所得到的内容就比较有限。相比之下，全文检索可以检索出大量的信息（一次检索 的结果是几百万条，甚至是千万条以上），但缺点是查询结果不够准确，往往是罗列出了海 量的信息（如上千万个页面），使用户无法迅速找到所需的信息。在分类目录搜索引擎中最 著名的就是雅虎（www。yahoo。com）。国内著名的分类搜索引擎有雅虎中国（cn。yahoo。com）、新 浪（sina。com。cn）、搜狐（www。sohu。com）、网易（www。163。com）等。 图 6-16 说明了上述这两种搜索方法的区别。图 6-16（a）是全文搜索谷歌的首页。用户只 需在空白的栏目中键入拟搜索的关键词，搜索引擎就返回搜索结果，用户可根据屏幕上显示 的结果继续点击下去，直到看到满意的结果。图 6-16（b）是分类检索新浪网的首页。我们可 以看到页面上有三行共 63 个类别。用户要检索的内容通常总是在这几十个类别之中，因此 按类别点击查找下去，最后就可以查找到所要检索的内容。 Google ↓ （a）全文检索举例 sina sina。com。cn Siha新浪网 微博 大家正在竣：攜眷高格调喝法 南京 15°C 核心价值观： 网站举报APP下载 O 燒烤网络空间 維护网民权益 新闻 军事 社会 国际 财经 股票 基金 期货 科技 手机探索外汇 体育 NBA 中超 奥运 娱乐 明星 电影 座 汽车 报价 买车 秒车 博客 专栏 文史天气 视频 综艺 航拍 直播 房产 二手房家居 收藏 时间 女性健康 育儿 教育 高考 公益 佛学 圖片 读书 情感 法院 城市 鲜城 旅游 航空 游戏 页游 手游 SHOW 江苏 English 彩票高尔夫 微博 邮箱 更多 √ （b）分类检索举例 图6-16 举例说明两种检索的区别</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>从用户的角度看，使用这两种不同的搜索引擎一般都能够实现自己查询信息的目的。 为了使用户能够更加方便地搜索到有用信息，目前许多网站往往同时具有全文检索搜索和分 类目录搜索的功能。在互联网上搜索信息需要经验的积累。要多实践才能掌握从互联网获取 信息的技巧。 这里再强调一下，不管哪种搜索引擎，就是告诉你只要链接到什么地方就可以检索到 所需的信息。搜索引擎网站本身并没有直接存储这些信息。 值得注意的是，目前出现了垂直搜索引擎（Vertical Search Engine），它针对某一特定领 域、特定人群或某一特定需求提供搜索服务。垂直搜索也是提供关键字来进行搜索的，但被 放到了一个行业知识的上下文中，返回的结果更倾向于信息、消息、条目等。例如，对买房 的人讲，他希望查找的是房子的具体供求信息（如面积、地点、价格等），而不是有关房子 供求的一般性的论文或新闻、政策等。目前热门的垂直搜索行业有：购物、旅游、汽车、求 职、房产、交友等。还有一种元搜索引擎（Meta Search Engine），它把用户提交的检索请求 发送到多个独立的搜索引擎上去搜索，并把检索结果集中统一处理，以统一的格式提供 给用户，因此是搜索引擎之上的搜索引擎。它的主要精力放在提高搜索速度、智能化处 理搜索结果、个性化搜索功能的设置和用户检索界面的友好性上。元搜索引擎的查全率 和查准率都比较高。</p> <h4 id="2google-搜索技术的特点">（2）Google 搜索技术的特点</h4> <p>Google 的搜索引擎性能优良，因为它使用了先进的硬件和软件。以往的大多数的搜索 引擎是使用少量大型服务器。在访问高峰期，搜索的速度就会明显减慢。Google 则利用在 互联网上相互链接的计算机来快速查找每个搜索的答案，并且成功地缩短了查找的相应时 间。Google 的搜索软件可同时进行许多运算，它的核心技术就是 PageRank™，译为网页排 名。 PageRank 对搜索出来的结果按重要性进行排序，这是 Google 的两个创始人 Larry Page 和 Sergey Brin 共同开发出来的[W-GOOGLE]。由于用户在有限的时间内，不可能阅读全部 的搜索结果（因为数量往往非常大），而通常仅仅是查阅一下前几个（或前几十个）项目。 因此用户希望检索结果能够按重要性来排序。但怎样确定某个页面的重要性呢？传统的搜索 引擎往往是检查关键字在网页上出现的频率。PageRank 技术则把整个互联网当作了一个整 体对待，检查整个网络链接的结构，并确定哪些网页重要性最高。更具体些，就是如果有很 多网站上的链接都指向页面 A，那么页面 A 就比较重要。PageRank 对链接的数目进行加权 统计。对来自重要网站的链接，其权重也较大。统计链接数目的问题是一个二维矩阵相乘的 问题，从理论上讲，这种二维矩阵的元素数是网页数目的平方。对于1亿个网页，这个矩阵 就有1亿亿个元素。这样大的矩阵相乘，计算量是非常大的。Larry Page 和 Sergey Brin 两人 利用稀疏矩阵计算的技巧，大大地简化了计算量。他们用迭代的方法解决了这个问题。他们 先假定所有网页的排名是相同的，并且根据此初始值，算出各个网页的第一次迭代排名，再 根据第一次迭代排名算出第二次的排名。他们从理论上证明了不论初始值如何选取，这种算 法都保证了网页排名的估计值能收敛到排名的真实值。这种算法是完全没有任何人工干预 的，厂商不可能用金钱购买网页的排名。Google 还要进行超文本匹配分析，以确定哪些网 页与正在执行的特定搜索相关。在综合考虑整体重要性以及与特定查询的相关性之后， Google 就把最相关、最可靠的搜索结果放在首位。 然而有一些著名网站通过“竞价排名”把虚假广告信息放在检索结果的首位，结果误 导了消费者，使受骗者蒙受很大的损失。因此对网络搜索的结果，我们应认真分析其真伪， 提高辨别能力，不要随意轻信网络检索的广告信息（哪怕是知名度很高的网站）。</p> <h3 id="46-博客和微博">4.6 博客和微博</h3> <p>近年来，万维网的一些新的应用广为流行，这就是博客和微博。下面进行简单的介绍。</p> <h4 id="1博客">（1）博客</h4> <p>我们知道，建立网站就是万维网的一种应用。博客（blog）和网站有很相似的地方。博客 的作者可以源源不断地往万维网上的个人博客里填充内容，供其他网民阅读。网民可以用浏 览器上网阅读博客、发表评论，也可以什么都不做。 博客是万维网日志（weblog）的简称。也有人把 blog 进行音译，译为“部落格”，或“部 落阁”。还有人用“博文”来表示“博客文章”。 本来，网络日志是指个人撰写并在互联网上发布的、属于网络共享的个人日记。但现 在它不仅可以是个人日记，而且可以有无数的形式和大小，也没有任何实际的规则。 现在博客已经极大地扩充了互联网的应用和影响，成为了所有网民都可以参与的一种 新媒体，并使得无数的网民有了发言权，有了与政府、机构、企业，以及很多人交流的机</p> <p>会。在博客出现以前，网民是互联网上内容的消费者，网民在互联网上搜寻并下载感兴趣的 信息。这些信息是其他人生产的，他们把这些信息放在互联网的某个服务器上，供广大网民 使用（也就是供网民消费）。但博客改变了这种情况，网民不仅是互联网上内容的消费者， 而且还是互联网上内容的生产者。 从历史上看，weblog 这个新词是 Jorn Barger 于1997 年创造的。简写的 blog（这是今 天最常用的术语）则是 Peter Merholz 于1999年创造的。不久，有人把blog 既当作名词，也 当作动词，表示编辑博客或写博客。接着，新名词 blogger 也出现了，它表示博客的拥有 者，或博客内容的撰写者和维护者，或博客用户。博客可以看成是继电子邮件、电子公告牌 系统 BBS 和即时传信 IM （Instant Messaging）之后的第四种网络交流方式。 现在从一些著名的门户网站的主页上都能很容易地进入到博客页面，这让用户查看博 客或发表自己的博客都非常方便。前面的图 6-16（b）所示的新浪网站首页， 就可看到在几十 个分类中的第1行第9列的“博客”。 当我们在新浪网站主页点击“博客”时，就可以看到各式各样的博客。也可以利用搜 索工具寻找所需的博客。如果我们已在新浪博客注册了，那么也可随时把自己的博客发表在 此，让别人来阅读。我们还可直接登录新浪博客网站 blog。sina。com。cn。 博客与个人网站还是有不少区别的。这里最主要的区别就是建立个人网站成本较高， 需要租用个人空间、域名等，同时建立网站的个人需要懂得 HTML 语言和网页制作等相关 技术；但博客在这方面是不需要什么投资的，所需的技术仅仅是会上网和会用键盘或书写板 输入汉字即可。因此网民用较短的时间就能够把自己写的博客发表在网上，而不像制作个人 网站那样花费较多的时间。正因为写博客的门槛较低，广大的网民才有可能成为今天互联网 上的信息制造者。 顺便提一下，不要把“博客”和“播客”弄混。播客（Podcast）是苹果手机的一个预装软 件，能够让用户通过手机订阅和自动下载所预订的音乐文件，以便随时欣赏音乐。</p> <h4 id="2微博">（2）微博</h4> <p>在图 6-16（b）新浪网站首页各种分类的第1行的最后，可以找到“微博”。微博就是微型 博客（microblog），又称为微博客，它的意思已经非常清楚。博客或微博里的朋友，常称为 “博友”。微博也被人戏称为“围脖”，把博友戏称为“脖友”。 但微博不同于一般的博客。微博只记录片段、碎语，三言两语，现场记录，发发感 慨，晒晒心情，永远只针对一个问题进行回答。微博只是记录自己琐碎的生活，呈现给人 看，而且必须很真实。微博中不必有太多的逻辑思维，很随便，很自由，有点像电影中的一 个镜头。写微博比写其他东西简单多了，不需要标题，不需要段落，更不需要漂亮的词汇。 2009 年是中国微博蓬勃发展的一年，相继出现了新浪微博、139说客、9911、嘀咕网、 同学网、贫嘴等微博客。例如，新浪微博就是由中国最大的门户网站新浪网推出的微博服 务，是中国目前用户数最多的微博网站（weibo。com），名人用户众多是新浪微博的一大特 色，基本已经覆盖大部分知名文体明星、企业高管、媒体人士。用户可以通过网页、WAP 网、手机短信彩信、手机客户端等多种方式更新自己的微博。每条微博字数最初限制为 140</p> <p>英文字符，但现在已增加了“长微博”的选项， 可输入更多的字符。微博还提供插入图片、 视频、音乐等功能。根据统计，从2010年3月到2012年3月共两年的时间，新浪微博的覆 盖人数从 2510。9 万增长到 3 亿人，而其中 90%的用户认为微博改变了他们与媒体接触的方 式。 现在不少地方政府也开通了微博（即政务微博），这是信息公开的表现。政府可以通过 政务微博，及时公布政情、公务、资讯等，获取与民众更多、更直接、更快的沟通，特别是 在突发事件或者群体性事件发生的时候，微博就能够成为政府新闻发布的一种重要手段。 虽然政务微博具有“传递信息、沟通上下、解决问题”的功能性特点，并受到广大网 民的欢迎，但政务微博的日常管理也非常重要。如果政务微博因缺乏良好的管理而不能够满 足群众的各种需求，那么它就会成为一种无用的摆设。 微博是一种互动及传播性极快的工具，其实时性、现场感及快捷性，往往超过所有媒 体。这是因为微博对用户的技术要求门槛非常低，而且在语言的编排组织上，没有博客那么 高。另外，微博开通的多种API 使大量的用户可通过手机、网络等方式来即时更新自己的 个人信息。微博网站的即时传信功能非常强大，可以通过QQ和MSN直接书写。 我们正处在一个急剧变革的时代，人们需要用贯穿不同社会阶层的信息去了解社会、 改变生活。在互联网上微博的出现正好满足了广大网民的需求。微博发布、转发信息的功能 很强大，这种一个人的“通讯社”将对整个社会产生越来越大的影响。</p> <h3 id="47-社交网站">4.7 社交网站</h3> <p>社交网站 SNS （Social Networking Site）是近年来发展非常迅速的一种网站，其作用是为 一群拥有相同兴趣与活动的人创建在线社区。社交网站的功能非常丰富，如电子邮件、即时 传信（在线聊天）、博客撰写、共享相册、上传视频、网页游戏、创建社团、刊登广告等， 对现实社交结构已经形成了巨大冲击。社交网络服务提供商针对不同的群众，有着不同的定 位，对个人消费者都是免费的。这种网站通过朋友，一传十，十传百地把联系范围不断扩大 下去。前面曾提到过的BBS和微博，可以看作是社交网站的前身。 2004 年社交网站脸书（Facebook，又名面书、脸谱、脸谱网）在美国诞生。脸书最初的用 户定位是大学生，但现在它的用户范围已经扩大了很多。接着社交网站热潮席卷全球，而国内 以人人网、开心网等为代表的社交网站也如雨后春笋般迅速崛起。社交网站极大地丰富了人 们的社交生活，孕育了新的经济增长点，其所蕴含的巨大商业价值和社会力量也正凸显出来。 毫无疑问，目前世界上排名第一且分布最广的社交网站是脸书。脸书最大的特点就是 可以非常方便地寻找朋友或联系老同学、老同事，能够简易地在朋友圈中分享图片、视频和 音频文件（现在也可以发送其他文件，如。docx， xlsx 等），以及通过集成的地图功能分享用 户所在的位置。现在脸书的月度活跃用户已达11。5亿人之多，其中半数以上为移动电话用 户。在 2010年3月，脸书在美国的访问人数已超过谷歌，成为全美访问量最大的网站。脸 书的官网域名为 Facebook。com，并持有。cn 域名 Facebook。cn。排名第二的社交网站是视频分 享网站 YouTube，其月度活跃用户人数为10亿人。2006年 YouTube。com 网站被谷歌收购， 目前谷歌手上持有了 youtube。com/。com。cn/。net/。org 等域名。国内类似的视频分享网站有优酷 （www。youku。com）、土豆（movie。tudou。com）、56网（56。com）等。 另一种能够提供微博服务的社交网络现在也很流行。例如推特 Twitter （twitter。com） 网 站创建于 2006 年，它可以让用户发表不超过140个英文字符的消息。这些消息也被称为</p> <p>“推文”（Tweet）。我国的新浪微博（www。weibo。com）、腾讯微博（t。qq。com）等就是这种性质的 社交网站。职业性社交网站领英LinkedIn 也是很受欢迎的网站。 目前在我国最为流行的社交网站就是微信（weixin。qq。com）。微信最初是专为手机用户使 用的聊天工具，其功能是“收发信息、拍照分享、联系朋友”。但几年来经过多次系统更 新，现在微信不仅可传送文字短信、图片、录音电话、视频短片，还可提供实时音频或视频 聊天，甚至可进行网上购物、转账、打车，等等。原来微信仅限于在手机上使用，但新的微 信版本已能够安装在普通电脑上。现在微信的功能已远远超越了社交领域。我们知道，电子 邮件可以发送给网上任何一个并不认识你的用户，也不管他是否愿意接收你发送的邮件。各 种博客和微博也可供任何上网用户浏览。但微信只能在确定的朋友圈中交换信息。正是由于 朋友之间更加需要交换信息，而微信的功能又不断在扩展，因此微信在我国已成为几乎每个 网民都使用的应用软件。</p> <h2 id="五电子邮件">五、电子邮件</h2> <h3 id="51-电子邮件概述">5.1 电子邮件概述</h3> <p>大家知道，实时通信的电话有两个严重缺点。第一，电话通信的主叫和被叫双方必须 同时在场。第二，有些电话常常不必要地打断被叫者的工作或休息。 电子邮件（e-mail）是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件 发送到收件人使用的邮件服务器，并放在其中的收件人邮箱（mail box）中，收件人可在自己 方便时上网到自己使用的邮件服务器进行读取。这相当于互联网为用户设立了存放邮件的信 箱，因此 e-mail 有时也称为“电子信箱”。电子邮件不仅使用方便，而且还具有传递迅速和 费用低廉的优点。据有的公司报道，使用电子邮件后可提高劳动生产率 30%以上。现在电 子邮件不仅可传送文字信息，而且还可附上声音和图像。由于电子邮件和手机的广泛使用， 现已迫使传统的电报业务退出市场，因为这种传统电报既贵又慢，且很不方便。 1982 年 ARPANET 的电子邮件问世后，很快就成为最受广大网民欢迎的互联网应用。 电子邮件的两个最重要的标准就是：简单邮件传送协议SMTP（Simple Mail Transfer Protocol） [RFC 5321]和互联网文本报文格式[RFC 5322]。 由于互联网的 SMTP 只能传送可打印的7位ASCII 码邮件，因此在 1993 年又提出了通 用互联网邮件扩充 MIME （Multipurpose Internet Mail Extensions）。MIME 在其邮件首部中说 明了邮件的数据类型（如文本、声音、图像、视像等）。在 MIME 邮件中可同时传送多种类 型的数据。这在多媒体通信的环境下是非常有用的。 一个电子邮件系统应具有图 6-17 所示的三个主要组成构件，这就是用户代理、邮件服 务器，以及邮件发送协议（如 SMTP）和邮件读取协议（如POP3）。POP3 是邮局协议（Post Office Protocol）的版本3。凡是有TCP 连接的，都经过了互联网，有的甚至可以跨越数千公 里的距离。这里为简洁起见，没有画出网络。在互联网中，邮件服务器的数量是很大的。正 是这些邮件服务器构成了电子邮件基础结构的核心。在图6-17 中为了说明问题，仅仅画出 了两个邮件服务器。</p> <p>发件人 用户代理 发送方 接收方 发送邮件服务器 邮件服务器 邮件 SMTP SMTP SMTP POP3 读取 邮件 POP3 收件人 用户代理 POP3 客戶 TCP （服务器） 服务器 TCP 客戶 连接 连接 SMTP 发送邮件 SMTP /SMTP™ 客戶 TCP 连接 服务器 用户邮箱 （读取邮件） 发送方 （发送邮件） SMTP POP3 （发送邮件）SMTP 接收方 用户代理 邮件缓存 发送方 邮件服务器 互联网 接收方 邮件服务器 用户代理 图6-17 电子邮件的最主要的组成构件</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>用户代理 UA （User Agent）就是用户与电子邮件系统的接口，在大多数情况下它就是运 行在用户电脑中的一个程序。因此用户代理又称为电子邮件客户端软件。用户代理向用户提 供一个很友好的接口（目前主要是窗口界面）来发送和接收邮件。现在可供大家选择的用户 代理有很多种。例如，微软公司的Outlook Express 和我国张小龙制作的Foxmail，都是很受 欢迎的电子邮件用户代理。 用户代理至少应当具有以下4个功能。 （1）撰写。给用户提供编辑信件的环境。例如，应让用户能创建便于使用的通讯录（有 常用的人名和地址）。回信时不仅能很方便地从来信中提取出对方地址，并自动地将此地址 写入到邮件中合适的位置，而且还能方便地对来信提出的问题进行答复（系统自动将来信复 制一份在用户撰写回信的窗口中，因而用户不需要再输入来信中的问题）。 （2） 显示。能方便地在计算机屏幕上显示出来信（包括来信附上的声音和图像）。 （3）处理。处理包括发送邮件和接收邮件。收件人应能根据情况按不同方式对来信进行 处理。例如，阅读后删除、存盘、打印、转发等，以及自建目录对来信进行分类保存。有时 还可在读取信件之前先查看一下邮件的发件人和长度等，对于不愿收的信件可直接在邮箱中 删除。 （4） 通信。发信人在撰写完邮件后，要利用邮件发送协议发送到用户所使用的邮件服务 收件人在接收邮件时，要使用邮件读取协议从本地邮件服务器接收邮件。 互联网上有许多邮件服务器可供用户选用（有些要收取少量的邮箱费用）。邮件服务器 24 小时不间断地工作，并且具有很大容量的邮件信箱。邮件服务器的功能是发送和接收邮 件，同时还要向发件人报告邮件传送的结果（已交付、被拒绝、丢失等）。邮件服务器按照 客户服务器方式工作。邮件服务器需要使用两种不同的协议。一种协议用于用户代理向邮件 服务器发送邮件或在邮件服务器之间发送邮件，如 SMTP 协议，而另一种协议用于用户代 理从邮件服务器读取邮件，如邮局协议 POP3。 这里应当注意，邮件服务器必须能够同时充当客户和服务器。例如，当邮件服务器 A</p> <p>向另一个邮件服务器B发送邮件时，A 就作为 SMTP 客户，而 B 是 SMTP 服务器。反之， 当 B 向 A 发送邮件时，B 就是 SMTP 客户，而A 就是 SMTP 服务器。 图 6-17 给出了计算机之间发送和接收电子邮件的几个重要步骤。请注意，SMTP 和 POP3（或 IMAP）都是使用TCP连接来传送邮件的，使用TCP 的目的是为了可靠地传送 邮件。 发件人调用计算机中的用户代理撰写和编辑要发送的邮件。 • 发件人点击屏幕上的“发送邮件”按钮，把发送邮件的工作全都交给用户代理来完 成。用户代理把邮件用 SMTP 协议发给发送方邮件服务器，用户代理充当 SMTP 客户，而 发送方邮件服务器充当 SMTP 服务器。用户代理所进行的这些工作，用户是看不到的。有 的用户代理可以让用户在屏幕上看见邮件发送的进度显示。用户所使用的邮件服务器究竟在 什么地方，用户并不知道，也不必要知道。实际上，用户在把写好的信件交付给用户代理 后，就什么都不用管了。 ● SMTP 服务器收到用户代理发来的邮件后，就把邮件临时存放在邮件缓存队列中， 等待发送到接收方的邮件服务器（等待时间的长短取决于邮件服务器的处理能力和队列中待 发送的信件的数量。但这种等待时间一般都远远大于分组在路由器中等待转发的排队时 间）。 ● 发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP 服务器建立TCP连 接，然后就把邮件缓存队列中的邮件依次发送出去。请注意，邮件不会在互联网中的某个中 间邮件服务器落地。如果SMTP客户还有一些邮件要发送到同一个邮件服务器，那么可以 在原来已建立的TCP连接上重复发送。如果SMTP客户无法和SMTP服务器建立TCP连接 （例如，接收方服务器过负荷或出了故障），那么要发送的邮件就会继续保存在发送方的邮 件服务器中，并在稍后一段时间再进行新的尝试。如果SMTP客户超过了规定的时间还不 能把邮件发送出去，那么发送邮件服务器就把这种情况通知用户代理。 ● 运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的 用户邮箱中，等待收件人进行读取。 • 收件人在打算收信时，就运行计算机中的用户代理，使用POP3（或IMAP）协议读 取发送给自己的邮件。请注意，在图6-17中，POP3 服务器和 POP3 客户之间的箭头表示的 是邮件传送的方向。但它们之间的通信是由POP3客户发起的。 请注意这里有两种不同的通信方式。一种是“推”（push）： SMTP 客户把邮件“推”给 SMTP 服务器。另一种是“拉”（pull）：POP3 客户把邮件从 POP3 服务器“拉”过来。细心 的读者可能会想到这样的问题：如果让图 6-17 中的邮件服务器程序就在发送和接收方的 计算机中运行，那么岂不是可以直接把邮件发送到收件人的计算机中？ 答案是“不行”。这是因为并非所有的计算机都能运行邮件服务器程序。有些计算机可能 没有足够的存储空间来运行允许程序在后台运行的操作系统，或是可能没有足够的 CPU 能 力来运行邮件服务器程序。更重要的是，邮件服务器程序必须不间断地运行，每天24 小时 都必须不间断地连接在互联网上，否则就可能使很多外面发来的邮件无法接收。这样看来， 让用户的计算机运行邮件服务器程序显然是很不现实的（一般用户在不使用计算机时就将机 器关闭）。让来信暂时存储在用户的邮件服务器中，而当用户方便时就从邮件服务器的用户 信箱中读取来信，则是一种比较合理的做法。在 Foxmail 中使用一种“特快专递”服务。这 种服务就是从发件人的用户代理直接利用 SMTP 把邮件发送到接收方邮件服务器。这就加</p> <p>快了邮件的交付（省去在发送邮件服务器中的排队等待时间）。但这种“特快专递”和邮 政的 EMS 直接把邮件送到用户家中不同，它并没有把邮件直接发送到收件人的计算机中。 但有些邮件服务器为了防止垃圾邮件和计算机病毒，拒绝接收从一般用户直接发来的邮件。 电子邮件由信封（envelope）和内容（content）两部分组成。电子邮件的传输程序根据邮件信 封上的信息来传送邮件。这与邮局按照信封上的信息投递信件是相似的。 在邮件的信封上，最重要的就是收件人的地址。TCP/IP体系的电子邮件系统规定电子 邮件地址（e-mail address）的格式如下： 用户名 @ 邮件服务器的域名 （6-1） 在上式中，符号“@”读作“at”，表示“在”的意思。例如，在电子邮件地址 “xyz@abc。com”中，“abc。com”就是邮件服务器的域名，而“xyz”就是在这个邮件服务 器中收件人的用户名，也就是收件人邮箱名，是收件人为自己定义的字符串标识符。但应注 意，这个用户名在邮件服务器中必须是唯一的（当用户定义自己的用户名时，邮件服务器要 负责检查该用户名在本服务器中的唯一性）。这样就保证了每一个电子邮件地址在世界范围 内是唯一的。这对保证电子邮件能够在整个互联网范围内的准确交付是十分重要的。电子邮 件的用户一般采用容易记忆的字符串。</p> <h3 id="52-简单邮件传送协议-smtp">5.2 简单邮件传送协议 SMTP</h3> <p>下面介绍 SMTP的一些主要特点。 SMTP 规定了在两个相互通信的 SMTP 进程之间应如何交换信息。由于SMTP 使用客 户服务器方式，因此负责发送邮件的SMTP 进程就是SMTP客户，而负责接收邮件的 SMTP 进程就是SMTP服务器。至于邮件内部的格式，邮件如何存储，以及邮件系统应以多 快的速度来发送邮件，SMTP也都未做出规定。 SMTP 规定了 14条命令和21种应答信息。每条命令用几个字母组成，而每一种应答信 息一般只有一行信息，由一个3位数字的代码开始，后面附上（也可不附上）很简单的文字 说明。下面通过发送和接收方的邮件服务器之间的 SMTP 通信的三个阶段介绍几个最主 要的命令和响应信息。</p> <h4 id="1连接建立">（1）连接建立</h4> <p>发件人的邮件送到发送方邮件服务器的邮件缓存后，SMTP 客户就每隔一定时间（例如 30分钟）对邮件缓存扫描一次。如发现有邮件，就使用SMTP 的熟知端口号码 25 与接收方 邮件服务器的 SMTP 服务器建立 TCP 连接。在连接建立后，接收方 SMTP 服务器要发出 “220 Service ready”（服务就绪）。然后 SMTP 客户向SMTP 服务器发送HELO命令，附上 发送方的主机名。SMTP 服务器若有能力接收邮件，则回答：“250 OK”，表示已准备好接 收。若 SMTP 服务器不可用，则回答“421 Service not available”（服务不可用）。 如在一定时间内（例如三天）发送不了邮件，邮件服务器会把这个情况通知发件人。 SMTP 不使用中间的邮件服务器。不管发送和接收方的邮件服务器相隔有多远，不管 在邮件传送过程中要经过多少个路由器，TCP 连接总是在发送和接收方这两个邮件服务 器之间直接建立。当接收方邮件服务器出故障而不能工作时，发送方邮件服务器只能等待一 段时间后再尝试和该邮件服务器建立 TCP 连接，而不能先找一个中间的邮件服务器建立</p> <p>TCP 连接。</p> <h4 id="2邮件传送">（2）邮件传送</h4> <p>邮件的传送从 MAIL 命令开始。MAIL 命令后面有发件人的地址。如：MAIL FROM： &lt;xiexiren@tsinghua。org。cn&gt;。若 SMTP 服务器已准备好接收邮件，则回答“250 OK”。否 则，返回一个代码，指出原因。如：451（处理时出错），452 （存储空间不够），500 （命令 无法识别）等。 下面跟着一个或多个 RCPT 命令，取决于把同一个邮件发送给一个或多个收件人，其 格式为 RCPT TO：&lt;收件人地址&gt;。RCPT 是 recipient（收件人）的缩写。每发送一个 RCPT 命令，都应当有相应的信息从 SMTP 服务器返回，如：“250 OK”，表示指明的邮箱在接收 方的系统中，或“550 No such user here”（无此用户），即不存在此邮箱。 RCPT 命令的作用就是：先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮 件。这样做是为了避免浪费通信资源，不至于发送了很长的邮件以后才知道地址错误。 再下面就是 DATA 命令，表示要开始传送邮件的内容了。SMTP 服务器返回的信息是： “354 Start mail input； end with <crlf>。<crlf>”。这里<crlf>是“回车换行”的意思。若 不能接收邮件，则返回421（服务器不可用），500（命令无法识别）等。接着 SMTP 客户就 发送邮件的内容。发送完毕后，再发送<crlf>。<crlf>（两个回车换行中间用一个点隔 开）表示邮件内容结束。实际上在服务器端看到的可打印字符只是一个英文的句点。若邮件 收到了，则 SMTP 服务器返回信息“250 OK”，或返回差错代码。 虽然 SMTP 使用TCP连接试图使邮件的传送可靠，但“发送成功”并不等于“收件人 读取了这个邮件”。当一个邮件传送到接收方的邮件服务器后（即接收方的邮件服务器收下 了这个邮件），再往后的情况如何，就有好几种可能性。接收方的邮件服务器也可能接着就 出了故障，使收到的邮件全部丢失（在收件人读取信件之前）。也可能被邮件服务器的软件 当作垃圾邮件删除了。也可能收件人在清理自己的邮箱时，把尚未读取的邮件一起都删除 了。有时收件人由于某种原因，很久没有查阅自己的邮箱，根本不知道自己的邮箱中有一些 来信。因此，一个邮件即使是“发送成功”，收件人也不一定会读取到这个邮件。尽管如 此，基于 SMTP 的电子邮件通常都被认为是可靠的。 3。 连接释放 邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是“221 （服务关闭）”，表示SMTP 同意释放 TCP 连接。邮件传送的全部过程即结束。 这里再强调一下，使用电子邮件的用户看不见以上这些过程，所有这些复杂过程都被 电子邮件的用户代理屏蔽了。 已经广泛使用多年的 SMTP 存在着一些缺点。例如，发送电子邮件不需要经过鉴别。 这就是说，在 FROM 命令后面的地址可以任意填写。这就大大方便了垃圾邮件的作者，给 收信人添加了麻烦（有人估计，在全世界所有的电子邮件中，垃圾邮件至少占到 50%以 上，甚至高达 90%）。又如，SMTP 本来就是为传送 ASCII 码而不是传送二进制数据设计 的。虽然后来有了 MIME 可以传送二进制数据（见后面 6。5。6 节的介绍），但在传送非 ASCII 码的长报文时，在网络上的传输效率是不高的。此外，SMTP 传送的邮件是明文，不 利于保密。</crlf></crlf></crlf></crlf></crlf>收件人地址&gt;</p> <p>为了解决上述问题，2008 年 10 月颁布的 RFC 5321 对 SMTP 进行了扩充，成为扩充的 SMTP （Extended SMTP），记为ESMTP。RFC 5321 在许多命令中增加了扩展的参数。新增加 的功能有：客户端的鉴别，服务器接受二进制报文，服务器接受分块传送的大报文，发送前 先检查报文的大小，使用安全传输 TLS（见下一章 7。6。2 节），以及使用国际化地址等。考 虑到现在的许多 SMTP 邮件服务器可能还没有升级到 ESMTP，因此特规定使用 ESMTP 的 客户端在准备传送报文时，不是发送 HLLO 而是发送 EHLO 报文。如果 EHLO 报文被对方 服务器端拒绝，就表明对方仍然是一个标准的 SMTP 邮件服务器（不使用扩展的参数），因 而就要按照原来使用的SMTP 参数进行邮件的传送。如果 EHLO 报文被接受了，那么客户 端就可以使用 ESMTP扩展的参数传送报文了。</p> <h3 id="53-电子邮件的信息格式">5.3 电子邮件的信息格式</h3> <p>一个电子邮件分为信封和内容两大部分。在 RFC 5322 文档中只规定了邮件内容中的首 部（header）格式，而对邮件的主体（body）部分则让用户自由撰写。用户写好首部后，邮件系统 自动地将信封所需的信息提取出来并写在信封上。所以用户不需要填写电子邮件信封上的信 息。 邮件内容首部包括一些关键字，后面加上冒号。最重要的关键字是：To 和 Subject。 “To：”后面填入一个或多个收件人的电子邮件地址。在电子邮件软件中，用户把经常 通信的对象姓名和电子邮件地址写到地址簿（address book）中。当撰写邮件时，只需打开地址 簿，点击收件人名字，收件人的电子邮件地址就会自动地填入到合适的位置上。 “ Subject： ”是邮件的主题。它反映了邮件的主要内容。主题类似于文件系统的文件 名，便于用户查找邮件。 邮件首部还有一项是抄送“Cc：”。这两个字符来自“Carbon copy”，意思是留下一个 “复写副本”。这是借用旧的名词，表示应给某某人发送一个邮件副本。 有些邮件系统允许用户使用关键字 Bcc （Blind carbon copy）来实现盲复写副本。这是使 发件人能将邮件的副本送给某人，但不希望此事为收件人知道。Bcc 又称为暗送。 首部关键字还有“From”和“Date”，表示发件人的电子邮件地址和发信日期。这两项 一般都由邮件系统自动填入。 另一个关键字是“Reply-To”，即对方回信所用的地址。这个地址可以与发件人发信时 所用的地址不同。例如有时到外地借用他人的邮箱给自己的朋友发送邮件，但仍希望对方将 回信发送到自己的邮箱。这一项可以事先设置好，不需要在每次写信时进行设置。</p> <h3 id="54-邮件读取协议-pop3-和-imap">5.4 邮件读取协议 POP3 和 IMAP</h3> <p>现在常用的邮件读取协议有两个，即邮局协议第 3 个版本 POP3 和网际报文存取协议 IMAP （Internet Message Access Protocol）。现分别讨论如下。 邮局协议 POP 是一个非常简单，但功能有限的邮件读取协议。邮局协议 POP 最初公布 于1984年。经过几次更新，现在使用的是1996年的版本POP3 [RFC 1939]，它已成为互联 网的正式标准。大多数的ISP 都支持 POP3。 POP3 也使用客户服务器的工作方式。在接收邮件的用户计算机中的用户代理必须运行 POP3 客户程序，而在收件人所连接的ISP的邮件服务器中则运行 POP3 服务器程序。当 然，这个 ISP 的邮件服务器还必须运行 SMTP 服务器程序，以便接收发送邮件服务器的</p> <p>SMTP 客户程序发来的邮件。这些请参阅图 6-17。POP3 服务器只有在用户输入鉴别信息 （用户名和口令）后，才允许对邮箱进行读取。 POP3 协议的一个特点就是只要用户从 POP3 服务器读取了邮件，POP3 服务器就把该 邮件删除。这在某些情况下就不够方便。例如，某用户在办公室的台式计算机上接收了一个 邮件，还来不及写回信，就马上携带笔记本电脑出差。当他打开笔记本电脑写回信时， POP3 服务器上却已经删除了原来已经看过的邮件（除非他事先将这些邮件复制到笔记本电 脑中）。为了解决这一问题，POP3 进行了一些功能扩充，其中包括让用户能够事先设置 邮件读取后仍然在POP3 服务器中存放的时间[RFC 2449]。目前 RFC 2449 是互联网建议 标准。 另一个读取邮件的协议是网际报文存取协议 IMAP，它比 POP3 复杂得多。IMAP 和 POP 都按客户服务器方式工作，但它们有很大的差别。现在较新的版本是2003年3月修订 的版本 4，即 IMAP4 [RFC 3501]，它目前也是互联网的建议标准。不过在习惯上，对这个 协议大家很少加上版本号“4”，而经常简单地用IMAP表示IMAP4。但是对 POP3 却不会 忘记写上版本号“3”。 在使用 IMAP 时，在用户的计算机上运行 IMAP 客户程序，然后与接收方的邮件服务 器上的 IMAP 服务器程序建立TCP连接。用户在自己的计算机上就可以操纵邮件服务器的 邮箱，就像在本地操纵一样，因此 IMAP 是一个联机协议。当用户计算机上的IMAP 客户程 序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该 邮件才传到用户的计算机上。用户可以根据需要为自己的邮箱创建便于分类管理的层次式的 邮箱文件夹，并且能够将存放的邮件从某一个文件夹中移动到另一个文件夹中。用户也可按 某种条件对邮件进行查找。在用户未发出删除邮件的命令之前，IMAP 服务器邮箱中的邮件 一直保存着。 IMAP 最大的好处就是用户可以在不同的地方使用不同的计算机（例如，使用办公室的 计算机、或家中的计算机，或在外地使用笔记本电脑）随时上网阅读和处理自己在邮件服务 器中的邮件。IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像 附件（此文件可能很大）的邮件，而用户使用的是无线上网，信道的传输速率很低。为了节 省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很大的附件。 IMAP 的缺点是如果用户没有将邮件复制到自己的计算机上，则邮件一直存放在 IMAP 服务器上。要想查阅自己的邮件，必须先上网。 下面的表 6-2 给出了 IMAP 和 POP3 的主要功能的比较。 表 6-2 IMAP 和POP3的主要功能比较 操作位置 操作内容 IMAP 收件箱 发件箱 阅读、标记、移动、删除邮件等 保存到已发送 创建文件夹 草稿 新建自定义的文件夹 保存草稿 垃圾文件夹 接收并移入垃圾文件夹的邮件 客户端与邮箱更新同步 客户端与邮箱更新同步 客户端与邮箱更新同步 客户端与邮箱更新同步 支持 POP3 仅在客户端内 仅在客户端内 仅在客户端内 仅在客户端内 不支持 广告邮件 接收并移入广告邮件夹的邮件 支持 不支持 最后再强调一下，不要把邮件读取协议 POP3 或IMAP 与邮件传送协议 SMTP 弄混。发</p> <p>件人的用户代理向发送方邮件服务器发送邮件，以及发送方邮件服务器向接收方邮件服务器 发送邮件，都是使用 SMTP 协议。而POP3 或IMAP则是用户代理从接收方邮件服务器上读 取邮件所使用的协议。</p> <h3 id="55-基于万维网的电子邮件">5.5 基于万维网的电子邮件</h3> <p>从前面的图 6-17 可看出，用户要使用电子邮件，必须在自己使用的计算机中安装用户 代理软件 UA。如果外出到某地而又未携带自己的笔记本电脑，那么要使用别人的计算机进 行电子邮件的收发，将是非常不方便的。 现在这个问题解决了。在20 世纪 90 年代中期，Hotmail 推出了基于万维网的电子邮件 （Webmail）。今天，几乎所有的著名网站以及大学或公司，都提供了万维网电子邮件。常用 的万维网电子邮件有谷歌的 Gmail，微软的 Hotmail，雅虎的 Yahoo! Mail。我国的网易 （163 或126）和新浪（sina）等互联网技术公司也都提供万维网邮件服务。 万维网电子邮件的好处就是：不管在什么地方（在任何一个国家的网吧、宾馆或朋友 家中），只要能够找到上网的计算机，在打开任何一种浏览器后，就可以非常方便地收发电 子邮件。使用万维网电子邮件不需要在计算机中再安装用户代理软件。浏览器本身可以向用 户提供非常友好的电子邮件界面（和原来的用户代理提供的界面相似），使用户在浏览器上 就能够很方便地撰写和收发电子邮件。 例如，你使用的是网易163邮箱，那么在任何一个浏览器的地址栏中，键入 163邮 箱的 URL （mail。163。com），按回车键后，就可以使用163 电子邮件了，这和在家中一样 方便。你曾经接收和发送过的邮件，已删除的邮件以及你的通讯录等内容，都照常呈现在屏 幕上。 我们知道，用户在浏览器中浏览各种信息时需要使用HTTP 协议。因此，在浏览器和 互联网上的邮件服务器之间传送邮件时，仍然使用HTTP协议。但是在各邮件服务器之间传 送邮件时，则仍然使用SMTP协议。</p> <h3 id="56-通用互联网邮件扩充mime">5.6 通用互联网邮件扩充MIME</h3> <h4 id="1mime-概述">（1）MIME 概述</h4> <p>前面所述的电子邮件协议 SMTP 有以下缺点： （1） SMTP 不能传送可执行文件或其他的二进制对象。人们曾试图将二进制文件转换为 SMTP 使用的 ASCII 文本，例如流行的 UNIX_UUencode/UUdecode 方案，但这些均未形成 正式标准或事实上的标准。 （2） SMTP 限于传送7位的ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚 至带重音符号的法文或德文）就无法传送。即使在 SMTP 网关将 EBCDIC 码（即扩充的二/ 十进制交换码）转换为ASCII码，也会遇到一些麻烦。 （3） SMTP 服务器会拒绝超过一定长度的邮件。 （4） 某些 SMTP 的实现并没有完全按照SMTP 的互联网标准。常见的问题如下： 回车、换行的删除和增加； 超过 76 个字符时的处理：截断或自动换行； 后面多余空格的删除；</p> <p>• 将制表符 tab 转换为若干个空格。 于是在这种情况下就提出了通用互联网邮件扩充 MIME [RFC 2045~2049]。MIME并 没有改动或取代 SMTP。MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结 构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程 序和协议下传送。图6-18表示MIME 和 SMTP 的关系。 用户 用户 非 ASCII码 MIME 非 ASCII码 MIME | 7位ASCII码 7位ASCII码 7位ASCII码 SMTP SMTP 图6-18 MIME 和 SMTP 的关系</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>MIME 主要包括以下三部分内容： （1） 5 个新的邮件首部字段，它们可包含在原来的邮件首部中。这些字段提供了有关邮 件主体的信息。 （2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。 （3）定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。 为适应于任意数据类型和表示，每个MIME 报文包含告知收件人数据类型和使用编码 的信息。MIME 把增加的信息加入到原来的邮件首部中。 下面是 MIME 增加的5个新的邮件首部的名称及其意义（有的可以是选项）。 （1） MIME-Version： 标志 MIME 的版本。现在的版本号是1。0。若无此行，则为英文文 本。 （2） Content-Description：这是可读字符串，说明此邮件主体是否是图像、音频或视频。 （3） Content-Id：邮件的唯一标识符。 （4） Content-Transfer-Encoding： 在传送时邮件的主体是如何编码的。 （5） Content-Type： 说明邮件主体的数据类型和子类型。 上述的前三项的意思很清楚，因此下面只对后两项进行介绍。</p> <h4 id="2内容传送编码">（2）内容传送编码</h4> <p>下面介绍三种常用的内容传送编码 （Content-Transfer-Encoding）。 最简单的编码就是7位ASCII 码，而每行不能超过1000个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。 另一种编码称为quoted-printable，这种编码方法适用于所传送的数据中只有少量的非 ASCII 码，例如汉字。这种编码方法的要点就是对于所有可打印的ASCII 码，除特殊字符等 号“=”外，都不改变。等号“=”和不可打印的 ASCII 码以及非 ASCII 码的数据的编码方 法是：先将每个字节的二进制代码用两个十六进制数字表示，然后在前面再加上一个等号 “=”。例如，汉字的“系统”的二进制编码是：11001111 10110101 11001101 10110011（共 有 32 位，但这四个字节都不是 ASCII 码），其十六进制数字表示为：CFB5CDB3。用 quoted-printable 编码表示为：=CF=B5=CD=B3，这12个字符都是可打印的ASCII 字符，它 •</p> <p>们的二进制编码需要96位，和原来的32位相比，开销达200%。而等号“=”的二进制代 码为 00111101，即十六进制的 3D，因此等号“=”的quoted-printable 编码为“=3D”。 对于任意的二进制文件，可用 base64 编码。这种编码方法是先把二进制代码划分为一 个个 24 位长的单元，然后把每一个24位单元划分为4个6位组。每一个6位组按以下方法 转换成 ASCII 码。6位的二进制代码共有 64 种不同的值，从0到63。用 A 表示 0，用 B 表 示1，等等。26个大写字母排列完毕后，接下去再排26个小写字母，再后面是10个数字， 最后用“+”表示 62，而用“/”表示63。再用两个连在一起的等号“= ”和一个等号 “=”分别表示最后一组的代码只有 8 位或 16 位。回车和换行都忽略，它们可在任何地方 插入。 下面是一个 base64编码的例子： 24位二进制代码 划分为4个6位组 对应的 base64编码 用 ASCII编码发送 01001001 00110001 01111001 010010 010011 000101 111001 S T F 5 01010011 01010100 01000110 00110101 不难看出，24 位的二进制代码采用 base64编码后变成了32位，开销为25%。</p> <h4 id="3内容类型">（3）内容类型</h4> <p>MIME 标准规定 Content-Type 说明必须含有两个标识符，即内容类型（type）和子类型 （subtype），中间用“/”分开。 MIME 标准原先定义了7个基本内容类型和15种子类型（见RFC 1521，但这个文档已 被列入“陈旧的”）。除了内容类型和子类型，MIME 允许发件人和收件人自己定义专用的内 容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串 X-开始。但是，后来陆续出现了几百个子类型，而且子类型的数目还在不断地增加。现在 可以在网站上查出现有的MIME类型和子类型的名称，以及申请新的子类型的具体步骤[W- MEDIA-TYPE]。表6-3 列出了MIME的内容类型、子类型举例及其说明®。 表6-3 可出现在 MIME Content-Type 说明中的类型及子类型举例 内容类型 子类型举例 text（文本） |plain， html， xml， css image（图像） audio （音频） | gif， jpeg， tiff | basic， mpeg， mp4 video （视频） | mpeg， mp4， quicktime 说明 | 不同格式的文本 | 不同格式的静止图像 可听见的声音 不同格式的影片</p> <p>续表 内容类型 子类型举例 说明 | model （模型） vrml | 3D模型 不同应用程序产生的数据 （ message （报文） | multipart（多部分） | 封装的报文 多种类型的组合 | application（应用） | octet-stream， pdf， javascript， zip |http， rfc822 | mixed， alternative， parallel， digest MIME 的内容类型中的 multipart 是很有用的，因为它使邮件增加了相当大的灵活性。 MIME 标准为 multipart 定义了四种可能的子类型，每个子类型都提供重要功能。 （1） mixed 子类型允许单个报文含有多个相互独立的子报文，每个子报文可有自己的类 型和编码。mixed 子类型报文使用户能够在单个报文中附上文本、图形和声音，或者用额外 数据段发送一个备忘录，类似商业信笺含有的附件。在 mixed 后面还要用到一个关键字，即 Boundary=，此关键字定义了分隔报文各部分所用的字符串（由邮件系统定义），只要在邮 件的内容中不会出现这样的字符串即可。当某一行以两个连字符“–”开始，后面紧跟上述 的字符串，就表示下面开始了另一个子报文。 （2） alternative 子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件和 软件系统的收件人发送备忘录时，这种类型的 multipart 报文很有用。例如，用户可同时用 普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在查看 图形时选择格式化的形式。 （3） parallel 子类型允许单个报文含有可同时显示的各个子部分（例如，图像和声音子部 分必须一起播放）。 （4） digest 子类型允许单个报文含有一组其他报文（如从讨论中收集电子邮件报文）。 下面显示了一个 MIME 邮件，它包含有一个简单解释的文本和含有非文本信息的照 片。邮件中第一部分的注解说明第二部分含有一张照片。 From： xiexiren@tsinghua。org。cn To： xyz@163。com MIME-Version： 1。0 Content-Type： multipart/mixed； boundary=qwertyuiop –qwertyuiop XYZ： 你要的图片在此邮件中，收到后请回信。 –qwertyuiop Content-Type： image/gif Content-Transfer-Encoding： base64 。。。data for the image （图像的数据）。。。 –qwertyuiop– 谢希仁 上面最后一行表示 boundary 的字符串后面还有两个连字符“–”，表示整个multipart 的 结束。</p> <h2 id="六动态主机配置协议-dhcp">六、动态主机配置协议 DHCP</h2> <p>为了把协议软件做成通用的和便于移植的，协议软件的编写者不会把所有的细节都固 定在源代码中。相反，他们把协议软件参数化。这就使得在很多台计算机上有可能使用同一 个经过编译的二进制代码。一台计算机和另一台计算机的许多区别，都可以通过一些不同的 参数来体现。在协议软件运行之前，必须给每一个参数赋值。 在协议软件中给这些参数赋值的动作叫做协议配置。一个协议软件在使用之前必须是 已正确配置的。具体的配置信息有哪些则取决于协议栈。例如，连接到互联网的计算机的协 议软件需要配置的项目包括： （1） IP 地址； （2） 子网掩码； （3） 默认路由器的IP 地址； （4）域名服务器的IP 地址。 为了省去给计算机配置 IP 地址的麻烦，我们能否在计算机的生产过程中，事先给每一 台计算机配置好一个唯一的 IP 地址呢（如同每一个以太网适配器拥有一个唯一的硬件地 址）？这显然是不行的。这是因为 IP 地址不仅包括了主机号，而且还包括了网络号。一个 IP 地址指出了一台计算机连接在哪一个网络上。当计算机还在生产时，无法知道它在出厂 后将被连接到哪一个网络上。因此，需要连接到互联网的计算机，必须对IP地址等项目进 行协议配置。 用人工进行协议配置很不方便，而且容易出错。因此，应当采用自动协议配置的方法。 互联网现在广泛使用的是动态主机配置协议 DHCP （Dynamic Host Configuration Protocol），它提供了一种机制，称为即插即用连网（plug-and-play networking）。这种机制允许 一台计算机加入新的网络和获取 IP 地址而不用手工参与。DHCP 最新的 RFC 文档是 1997 年的 RFC 2131 和 RFC 2132，目前还是互联网草案标准。 DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一 个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。DHCP 给运行服务器 软件而位置固定的计算机指派一个永久地址，而当这计算机重新启动时其地址不改变。 DHCP 使用客户服务器方式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送 发现报文（DHCPDISCOVER）（将目的IP地址置为全1，即255。255。255。255），这时该主机 就成为 DHCP 客户。发送广播报文是因为现在还不知道 DHCP 服务器在什么地方，因此要 发现（DISCOVER）DHCP 服务器的IP地址。这台主机目前还没有自己的IP 地址，因此它 将 IP 数据报的源 IP 地址设为全0。这样，在本地网络上的所有主机都能够收到这个广播报 文，但只有 DHCP 服务器才对此广播报文进行回答。DHCP服务器先在其数据库中查找该 计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 （address pool）中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文 （DHCPOFFER），表示“提供”了IP地址等配置信息。 但是我们并不愿意在每一个网络上都设置一个 DHCP 服务器，因为这样会使 DHCP 服 务器的数量太多。因此现在是使每一个网络至少有一个 DHCP 中继代理（relay agent）（通常 是一台路由器，见图 6-19），它配置了 DHCP 服务器的IP地址信息。当 DHCP 中继代理收 到主机 A 以广播形式发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等</p> <p>待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再把此提供报文发回给 主机 A。需要注意的是，图6-19 只是个示意图。实际上，DHCP 报文只是 UDP 用户数据报 的数据，它还要加上 UDP 首部、IP数据报首部，以及以太网的 MAC 帧的首部和尾部后， 才能在链路上传送。 主机A 广播 DHCPDISCOVER 单播 DHCPDISCOVER 其他网络 DHCP 服务器 DHCP 中继代理 图6-19 DHCP 中继代理以单播方式转发发现报文 DHCP 服务器分配给 DHCP 客户的IP地址是临时的，因此 DHCP 客戶只能在一段有限 的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期（lease period），但并没 有具体规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。例 如，一个校园网的 DHCP 服务器可将租用期设定为1小时。DHCP 服务器在给 DHCP 发送 的提供报文的选项中给出租用期的数值。按照 RFC 2132 的规定，租用期用4字节的二进制 数字表示，单位是秒。因此可供选择的租用期范围从1秒到136年。DHCP客户也可在自己 发送的报文中（例如，发现报文）提出对租用期的要求。 DHCP 的详细工作过程如图6-20 所示。DHCP 客户使用的 UDP 端口是68，而 DHCP 服务器使用的 UDP端口是67。这两个 UDP 端口都是熟知端口。 被动打开 67 服务器 · UDP 67 服务器 客戶 68 DHCPDISCOVER UDP UDP 客戶 68 DHCPOFFER 67 服务器 。 UDP UDP 客戶 68 DHCPREQUEST 67 服务器 UDP UDP 客户 68 DHCPACK 67 服务器 UDP UDP 6 客户 68 UDP 客户 68 UDP DHCPREQUEST 1 DHCPACK 67 服务器 UDP 67 服务器 。 UDP 客户 68 DHCPNACK 67 服务器 UDP UDP 9 客户 68 DHCPRELEASE 67 服务器 UDP UDP 图6-20 DHCP 协议的工作过程</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>下面按照图 6-20 中的注释编号（●至）进行简单的解释。 1 DHCP 服务器被动打开UDP端口67，等待客户端发来的报文。 2 DHCP 客户从 UDP 端口 68 发送 DHCP 发现报文。 • 凡收到 DHCP 发现报文的DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客戶</p> <p>可能收到多个 DHCP 提供报文。 4 DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器 发送 DHCP 请求报文。 • 被选择的 DHCP服务器发送确认报文 DHCPACK。从这时起，DHCP 客戶就可以使 用这个 IP 地址了。这种状态叫做已绑定状态，因为在 DHCP 客户端的 IP 地址和硬 件地址已经完成绑定，并且可以开始使用得到的临时 IP 地址了。 DHCP 客户现在要根据服务器提供的租用期T 设置两个计时器 T和T2，它们的超 时时间分别是 0。5T 和0。875T。当超时时间到了就要请求更新租用期。 • 租用期过了一半（Tı 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租 用期。 DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用 期，重新设置计时器。 8 DHCP 服务器若不同意，则发回否认报文 DHCPNACK。这时 DHCP 客户必须立即 停止使用原来的IP 地址，而必须重新申请IP 地址（回到步骤●）。 若 DHCP 服务器不响应步骤的请求报文 DHCPREQUEST，则在租用期过了 87。5%时（T2 时间到），DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复 步骤●），然后又继续后面的步骤。 9 DHCP 客户可以随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发 送释放报文 DHCPRELEASE 即可。 DHCP 很适合于经常移动位置的计算机。当计算机使用 Windows 操作系统时，点击 “控制面板”的“网络”图标就可以找到某个连接中的“网络”下面的菜单，找到 TCP/IP 协议后点击其“属性”按钮，若选择“自动获得IP 地址”和“自动获得DNS 服务器地 址”，就表示是使用DHCP 协议。</p> <h2 id="七简单网络管理协议-snmp">七、简单网络管理协议 SNMP</h2> <h3 id="71-网络管理的基本概念">7.1 网络管理的基本概念</h3> <p>虽然网络管理还没有精确定义，但它的内容可归纳为： 网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、 测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行 性能、服务质量等。网络管理常简称为网管。 我们可以看到，网络管理并不是指对网络进行行政上的管理。 网络是一个非常复杂的分布式系统。这是因为网络上有很多不同厂家生产的、运行着 多种协议的结点（主要是路由器），而这些结点还在相互通信和交换信息。网络的状态总是 不断地变化着。可见，我们必须使用一种机制来读取这些结点上的状态信息，有时还要把一 些新的状态信息写入到这些结点上。 下面简单介绍网络管理模型中的主要构件（见图6-21）。 管理站又称为管理器，是整个网络管理系统的核心，它通常是个有着良好图形界面的 高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理</p> <p>站发出的。管理站的所在部门也常称为网络运行中心 NOC （Network Operations Center）。管 理站中的关键构件是管理程序（如图6-21 中有字母 M 的椭圆形图标所示）。管理程序在运 行时就成为管理进程。管理站（硬件）或管理程序（软件）都可称为管理者（manager）或管 理器，所以这里的 manager 不是指人而是指机器或软件。网络管理员（administrator）才是指 人。大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的 设备。 被管设备 被管设备 互联网 被管设备 被管设备 被管设备 网管协议 网络 管理站 管理员 M ·管理程序（运行SNMP客户程序） A ·代理程序（运行 SNMP 服务器程序） 图6-21 网络管理的一般模型 在被管网络中有很多的被管设备（包括设备中的软件）。被管设备可以是主机、路由 器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多被管对象 （Managed Object）。被管对象可以是被管设备中的某个硬件（例如，一块网络接口卡），也可 以是某些硬件或软件（例如，路由选择协议）的配置参数的集合。被管设备有时可称为网络 元素或简称为网元。在被管设备中也会有一些不能被管的对象（在下面的 6。7。2 节将会讲到 对象命名树，所谓不能被管的对象就是不在对象命名树上的对象）。 在每一个被管设备中都要运行一个程序以便和管理站中的管理程序进行通信。这些运 行着的程序叫做网络管理代理程序，或简称为代理（agent）（如图6-22 中有字母 A 的几个椭 圆形图标所示）。代理程序在管理程序的命令和控制下，在被管设备上采取本地的行动。 在图 6-22 中还有一个重要构件就是网络管理协议，简称为网管协议。后面还要讨论它 的作用。 简单网络管理协议 SNMP （Simple Network Management Protocol）中的管理程序和代理程 序按客户服务器方式工作。管理程序运行 SNMP 客户程序，而代理程序运行 SNMP 服务器 程序。在被管对象上运行的 SNMP 服务器程序不停地监听来自管理站的 SNMP 客户程序的 请求（或命令）。一旦发现了，就立即返回管理站所需的信息，或执行某个动作（例如，把 某个参数的设置进行更新）。在网管系统中往往是一个（或少数几个）客户程序与很多的服 务器程序进行交互。 关于网络管理有一个基本原理，这就是： 若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有 对象的影响必须尽量小些。 SNMP 正是按照这样的基本原理来设计的。 SNMP 发布于 1988 年。OSI 虽然在这之前就已制定出许多的网络管理标准，但当时 （到现在也很少）却没有符合 OSI 网管标准的产品。SNMP 最重要的指导思想就是要尽可 能简单。SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。在网</p> <p>络正常工作时，SNMP 可实现统计、配置和测试等功能。当网络出故障时，可实现各种差错 检测和恢复功能。经过近二十年的使用，SNMP 不断修订完善，较新的版本是SNMPv3，而 前两个版本分别是SNMPv2 和 SNMPv1。但一般可简称为 SNMP。现在 SNMPv3 已成为互 联网标准（STD 62）。SNMPv3 最大的改进就是安全特性。也就是说，只有被授权的人员才 有资格执行网络管理的功能（如关闭某一条链路）和读取有关网络管理的信息（如读取一个 配置文件的內容）。然而 SNMP 协议已相当庞大，一点也不“简单”，整个标准共有八个 RFC 文档[RFC 3411~3418]。因此这里只能给出一些最基本的概念。 若网络元素使用的不是 SNMP 协议而是另一种网络管理协议，那么 SNMP 协议就无法 控制该网络元素。这时可使用委托代理（proxy agent）。委托代理能提供如协议转换和过滤操 作等功能对被管对象进行管理。 SNMP 的网络管理由三个部分组成，即SNMP 本身、管理信息结构 SMI （Structure of Management Information）和管理信息库 MIB （Management Information Base）。下面简述这三 部分的作用。 SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象 （变量名及其状态（值）。SNMP 负责读取和改变这些数值。 SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和 对象的值进行编码的规则。这样做是为了确保网络管理数据的语法和语义无二义性。但从 SMI 的名称并不能看出它的功能。请注意，SMI 并不定义一个实体应管理的对象数目，也 不定义被管对象名以及对象名及其值之间的关联。 MIB 在被管理的实体中创建了命名对象，并规定了其类型。 为了更好地理解上述的几个组成部分，可以把它们和程序设计进行一下对比。 我们在编程时要使用某种语言，而这种语言就是用来定义编程的规则。例如，一个变 量名必须从字母开始而后面接着是字母数字。在网络管理中，这些规则由SMI来定义。 在程序设计中必须对变量进行说明。例如，int counter，表示变量 counter 是整数类型。 MIB 在网络管理中就做这样的事情。MIB 给每个对象命名，并定义对象的类型。 在编程中的说明语句之后，程序需要写出一些语句用来存储变量的值，并在需要时改 变这些变量的值。SNMP 在网络管理中完成这件任务。SNMP 按照SMI 定义的规则，存 储、改变和解释这些已由MIB 说明的对象的值。 总之，SMI 建立规则，MIB对变量进行说明，而SNMP 完成网管的动作。 下面就一一介绍上述的三个构件。</p> <h3 id="72-管理信息结构-smi">7.2 管理信息结构 SMI</h3> <p>管理信息结构 SMI 是 SNMP 的重要组成部分。根据 6。7。1 节所讲的，SMI 的功能应当 有三个，即规定： （1）被管对象应怎样命名； （2）用来存储被管对象的数据类型有哪些； （3） 在网络上传送的管理数据应如何编码。</p> <h4 id="1被管对象的命名">（1）被管对象的命名</h4> <p>SMI 规定，所有的被管对象都必须处在对象命名树（object naming tree）上。图6-22 给出</p> <p>了对象命名树的一部分。对象命名树的根没有名字，它的下面有三个顶级对象，都是世界上 著名的标准制定单位，即ITU-T （过去叫做CCITT），ISO，以及这两个组织的联合体，它 们的标号分别是 0 到 2。图中的对象名习惯上用英文小写表示。在 ISO 的下面的一个标号为 3 的节点是 ISO 认同的的组织成员 org。在其下面有一个美国国防部 dod （Department of Defense）的子树（标号为 6），再下面就是 internet（标号为 1）。在只讨论 internet 中的对象 时，可只画出 internet 以下的子树，并在internet 节点旁边写上对象标识符 1。3。6。1 即可。 根 itu-t （0） iso （1） iso/itu-t （2） org （3） dod （6） internet （1） 1。3。6。1 （iso。org。dod。internet） mgmt （2） mib-2（1） 1。3。6。1。2。1 （iso。org。dod。internet。mgmt。mib-2） system（1） 八 interface（2） at（3） ip（4） icmp（5） tcp（6） udp（7） 八 八 egp（8） 。。。 八 八八 ipInReceives（3） 1。3。6。1。2。1。4。3 图6-22 SMI规定所有被管对象必须在命名树上</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>在 internet 节点下面的标号为2的节点是mgmt（管理）。再下面只有一个节点，即管理 信息库 mib-2，其对象标识符为1。3。6。1。2。1。在mib-2 下面包含了所有被SNMP 管理的对象 （见下面6。7。3 节的讨论）。</p> <h4 id="2被管对象的数据类型">（2）被管对象的数据类型</h4> <p>SMI 使用基本的抽象语法记法1（即ISO制定的ASN。1）来定义数据类型，但又增加 了一些新的定义。因此 SMI 既是ASN。1 的子集，又是ASN。1 的超集。ASN。1 的记法很严 格，它使得数据的含义不存在任何可能的二义性。例如，使用ASN。1 时不能简单地说 个具有整数值的变量”，而必须说明该变量的准确格式和整数取值的范围。当网络中的计算 机对数据项并不都使用相同的表示时，采用这种精确的记法就尤其重要。 我们知道，任何数据都具有两种重要的属性，即值（value）与类型（type）。这里“值”是 某个值集合中的一个元素，而“类型”则是值集合的名字。如果给定一种类型，则这种类型 的一个值就是该类型的一个具体实例。 SMI 把数据类型分为两大类：简单类型和结构化类型。简单类型是最基本的、直接使 用 ASN。1 定义的类型。表6-4 给出了最主要的几种简单类型。</p> <p>表6-4 几种最主要的简单类型 类型 大小 说明 INTEGER 4字节 在-231 到231-1之间的整数 Interger32 4 字节 和 INTEGER 相同 Unsigned32 4 字节 在0到22 −1之间的无符号数 OCTET STRING 可变 不超过65535字节长的字节串 OBJECT IDENTIFIER 可变 对象标识符 IPAddress 4 字节 由4个整数组成的IP地址 Counter32 4字节 可从0增加到23”的整数；当它到达最大值时就返回到0 TimeTicks 4字节 记录时间的计数值，以1/100秒为单位 BITS 比特串 Opaque 可变 不解释的串 SMI 定义了两种结构化数据类型，即 sequence 和 sequence ofo 数据类型 sequence 类似于 C 语言中的 struct 或 record，它是一些简单数据类型的组合 （不一定要相同的类型）。而数据类型 sequence of 类似于 C 语言中的 array，它是同样类型 的简单数据类型的组合，或同样类型的 sequence 数据类型的组合。</p> <h4 id="3编码方法">（3）编码方法</h4> <p>SMI 使用 ASN。1 制定的基本编码规则BER（Basic Encoding Rule）进行数据的编码。BER 指明了每种数据的类型和值。在发送端用 BER 编码，可把用ASN。1 所表述的报文转换成唯 一的比特序列。在接收端用BER 进行解码，就可得到该比特序列所表示的ASN。1报文。 初看起来，或许用两个字段就能表示类型和值。但由于表示值可能需要多个字节，因 此还需要一个指出“要用多少字节表示值”的长度字段。因此 ASN。1 把所有的数据元素都 表示为 T-L-V 三个字段组成的序列（见图6-23）。T字段（Tag）定义数据的类型，L 字段 （Length）定义 V 字段的长度，而V字段（Value）定义数据的值。 字节 1 可变 可变 数据元素 标记T 长度L 值V 类别 格式 位2 编 号 1 5 图6-23 用TLV 方法进行编码</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>（1） T 字段又叫做标记字段，占1 字节。T 字段比较复杂，因为它要定义的数据类型较 多。T字段又再分为以下三个子字段： 类别（2位）共四种：通用类（00），即 ASN。1 定义的类型；应用类（01），即 SMI 定 义的类型；上下文类（10），即上下文所定义的类型；专用类（11），保留为特定厂商 定义的类型。 格式（1 位）共两种，指出数据类型的种类：简单数据类型（0），结构化数据类型 （1）。 •</p> <p>编号（5位）用来标志不同的数据类型。编号的范围一般为0~30。当编号大于 30 时，T 字段就要扩展为多个字节（这种情况很少用到，可参考 ITU-T X。209，这里 从略）。 表6-5是一些数据类型的T字段的编码。 表6-5 几种数据类型的T字段编码 数据类型 类别 格式 编号 T字段（二进制） T字段（十六进制） INTEGER 00 0 00010 00000010 02 OCTET STRING 00 0 00100 00000100 04 OBJECT IDENTIFIER 00 0 00110 00000110 06 NULL 00 0 00101 00000101 05 Sequence， sequence of 00 1 10000 00110000 30 IPAddress 01 0 00000 01000000 40 Counter 01 0 00001 01000001 41 Gauge 01 0 00010 01000010 42 TimeTicks Opaque 01 0 00011 01000011 43 01 0 00100 01000100 44 （2） L 字段又叫做长度字段（单字节或多字节）。当字段为单字节时，其最高位为 0， 后面的7位定义V字段的长度。当L 字段为多个字节时，其最高位为 1，而后面的 7 位定 义后续字节的字节数（用二进制整数表示）。这时，所有的后续字节并置起来的二进制整数 定义V字段的长度。图6-24给出了L字段的格式。 指出V字段长度=2字节 单字节的L字段00000010 指出后续字节数 = 2 指出V字段长度=262字节 多字节的L字段 0000010 0000000100000110 后续字节数=2 图6-24 L字段的格式</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>（3） V 字段又叫做值字段，用于定义数据元素的值。 根据以上所述，我们给出两个用十六进制表示的编码例子。例如，INTEGER 15，根据 表 6-5，其 T 字段是02，再根据表 6-4，INTEGER 类型要用4字节编码。最后得出 TLV 编 码为 02 04 00 00 00 OF。又如 IPAddress 192。1。2。3，IPAddress 的T字段是40，V字段需要4 字节表示，因此IPAddress 192。1。2。3 的TLV编码是4004C0 01 02 03。 TLV 方法中的V字段还可嵌套其他数据元素的TLV 字段，并可多重嵌套。</p> <h3 id="73-管理信息库-mib">7.3 管理信息库 MIB</h3> <p>所谓“管理信息”就是指在互联网的网管框架中被管对象的集合。被管对象必须维持 可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚拟的信息存储器，所 以才称为管理信息库 MIB。管理程序就使用 MIB 中这些信息的值对网络进行管理（如读取 或重新设置这些值）。只有在 MIB 中的对象才是 SNMP 所能够管理的。例如，路由器应当 •</p> <p>维持各网络接口的状态、入分组和出分组的流量、丢弃的分组和有差错的报文的统计信息， 而调制解调器则应当维持发送和接收的字符数、码元传输速率和接受的呼叫等统计信息。因 此在 MIB 中就必须有上面这样一些信息。 我们再看一下图 6-22，可以找到节点 mib-2 下面的部分是 MIB 子树。表 6-6 给出了节 点 mib-2 所包含的前八个信息类别代表的意思（在后面还有好几个类别）。 表6-6 节点 mib-2 所包含的信息类别举例 类别 标号 所包含的信息 system （1） interfaces （2） 主机或路由器的操作系统 各种网络接口 address translation （3） 地址转换（例如，ARP 映射） ip （4） IP 软件 icmp （5） ICMP 软件 tcp （6） TCP 软件 udp （7） UDP 软件 egp （8） EGP 软件 我们可以用个简单例子进一步说明 MIB 的意义。例如，从图 6-22 可以看出，对象 ip 的标号是4。因此，所有与 IP 有关的对象都从前缀 1。3。6。1。2。1。4 开始。 （1） 在节点 ip 下面有个名为ipInReceives 的 MIB 变量（见图6-22），表示收到的 IP 数据 报数。这个变量的标号是3，变量的名字是： iso。org。dod。internet。mgmt。mib。ip。ipInReceives， 而相应的数值表示是：1。3。6。1。2。1。4。3。 （2）当 SNMP 在报文中使用 MIB 变量时，对于简单类型的变量，后缀0指具有该名字 的变量的实例。因此，当这个变量出现在发送给路由器的报文中时，ipInReceives 的数值表 示（即变量的一个实例）就是：1。3。6。1。2。1。4。3。0。 （3） 请注意，对于分配给一个 MIB 变量的数值或后缀是完全没有办法进行推算的，必 须查找已发布的标准。 上面所说的 MIB对象命名树的大小并没有限制。下面给出若干 MIB 变量的例子（见表 6-7），以便更好地理解 MIB 的意义。这里的“变量”是指特定对象的一个实例。 表 6-7 MIB 变量的例子 MIB 变量 所属类别 意义 sysUpTime system 距上次重启动的时间 ifNumber interfaces 网络接口数 ifMtu interfaces 特定接口的最大传送单元 MTU ipDefaultTTL ip IP 在生存时间字段中使用的值 ipInReceives ip 接收到的数据报数目 ipForwDatagrams ip 转发的数据报数目 ipOutNoRoutes ip 路由选择失败的数目 ipReasmOKs ip 重装的数据报数目 ipFragOKs ip 分片的数据报数目 ipRouting Table ip IP 路由表 icmpInEchos icmp 收到的 ICMP 回送请求数目</p> <p>MIB 变量 所属类别 tcpRtoMin tcp 意义 TCP 允许的最小重传时间 tcpMaxConn tcp tcpInSegs udpInDatagrams tcp udp 允许的最大TCP 连接数目 已收到的TCP报文段数目 已收到的 UDP数据报数目 续表 上面列举的大多数项目的值可用一个整数来表示。但 MIB 也定义了更复杂的结构。例 如，MIB 变量 ipRoutingTable 则定义一个完整的路由表。还有其他一些 MIB 变量定义了路 由表项目的内容，并允许网络管理协议访问路由器中的单个项目，包括前缀、地址掩码以及 下一跳地址等。当然，MIB 变量只给出了每个数据项的逻辑定义，而一个路由器使用的內 部数据结构可能与 MIB 的定义不同。当一个查询到达路由器时，路由器上的代理软件负责 MIB 变量和路由器用于存储信息的数据结构之间的映射。</p> <h3 id="74-snmp-的协议数据单元和报文">7.4 SNMP 的协议数据单元和报文</h3> <p>实际上，SNMP 的操作只有两种基本的管理功能，即： （1）“读”操作，用 Get 报文来检测各被管对象的状况； （2）“写”操作，用Set报文来改变各被管对象的状况。 SNMP 的这些功能通过探询操作来实现，即SNMP 管理进程定时向被管理设备周期性 地发送探询信息。上述时间间隔可通过 SNMP 的管理信息库 MIB 来建立。探询的好处是： 第一，可使系统相对简单；第二，能限制通过网络所产生的管理信息的通信量。但探询管理 协议不够灵活，而且所能管理的设备数目不能太多。探询系统的开销也较大。如探询频繁而 并未得到有用的报告，则通信线路和计算机的CPU周期就被浪费了。 但 SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为 陷阱（trap），表示它能够捕捉“事件”。但这种陷阱信息的参数是受限制的。 当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达 到某些门限值的事件（这就叫做过滤）。这种方法的好处是：第一，仅在严重事件发生时才 发送陷阱；第二，陷阱信息很简单且所需字节数很少。 总之，使用探询（至少是周期性地）以维持对网络资源的实时监视，同时也采用陷阱 机制报告特殊事件，使得 SNMP成为一种有效的网络管理协议。 SNMP 使用无连接的UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保 证可靠交付的。这里还要指出，SNMP 使用UDP 的方法有些特殊。在运行代理程序的服务 器端用熟知端口161 来接收Get 或Set报文和发送响应报文（与熟知端口通信的客户端使用 临时端口），但运行管理程序的客户端则使用熟知端口162来接收来自各代理的 trap 报文。 SNMP 现在共定义了如表 6-8 所示的8种类型的协议数据单元[RFC 3416]，其中 PDU 编号为4的已经废弃了。在 PDU 编号后面是对应的T字段值（十六进制表示）。 表6-8 SNMP定义的协议数据单元类型 PDU 编号（T字段 ） PDU 名称 用途 0 （A0） GetRequest 管理者从代理读取一个或一组变量的值</p> <p>PDU 编号（T字段 ） 1（Al） PDU 名称 GetNextRequest 用途 续表 管理者从代理读取 MIB 树上的下一个变量的值（即使不知道此变量名也行）。 此操作可反复进行，特别是按顺序一一读取列表中的值很方便 2 （A2） Response 代理向管理者或管理者向管理者发送对五种 Request 报文的响应，并提供差错 码、差错状态等信息 3（A3） SetRequest 管理者对代理的一个或多个MIB 变量的值进行设置 5（A5） 6（A6） GetBulkRequest 管理者从代理读取大数据块的值（如大的列表中的值） InformRequest 管理者从另一远程管理者读取该管理者控制的代理中的变量值 7 （A7） 8（A8） SNMPv2Trap 代理向管理者报告代理中发生的异常事件 Report 在管理者之间报告某些类型的差错，目前尚未定义 和大多数 TCP/IP协议不一样，SNMP报文没有固定的字段。相反，它们使用标准 ASN。1 编码。因此，SNMP报文用人工进行编码和理解时都比较困难。为此，在图 6-25 中 给出了 SNMPv1 的报文格式。可以看出，一个 SNMP 报文共由四个部分组成，即版本、首 部、安全参数和SNMP报文的数据部分。版本现在已是版本3。首部包括报文标识（message identification）、最大报文长度、报文标志（message flag）。报文标志占1字节，其中的每一位 定义安全类型或其他信息。安全参数用来产生报文摘要（见下一章的7。4节）。 从图6-25 可看出，在SNMP PDU 前面还有两个有关加密信息的字段。这是当数据部分 需要加密时才使用的两个字段。与网络管理直接相关的是后面的 SNMP PDU 部分。对于表 6-8 给出的前四种PDU的格式都是相同的，即由PDU类型、请求ID、差错状态、差错索引 以及变量绑定这几个字段组成。PDU 的各种类型以及类型的编号和T字段的编码已在表6-8 中给出。下面简单介绍一下其他字段的作用。 IP数据报 UDP数据报 20字节 8字节 SNMP 报文 IP UDP 首部首部 版本 首部 安全 参数 SNMP 报文的数据部分 上下文引擎 ID | 上下文名 PDU 类型 请求ID 差错状态差错索引 名 值名值 有关加密信息的字段 首部 SNMP PDU 图6-25 SNMP 的报文格式</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>变量绑定 （1）请求标识符（request ID） 由管理进程设置的4字节数值。代理进程在发送响应 报文时也要返回此请求标识符。由于管理进程可同时向许多代理发出请求读取变量值的报 文，因此设置了请求标识符可使管理进程能够识别返回的响应是对应于哪一个请求报文。 （2） 差错状态（error status） 在请求报文中，这个字段是零。当代理进程响应时，就填 入 0~18 中的一个数字。例如表示 noError （一切正常），1表示tooBig（代理无法把回答 装入到一个 SNMP 报文之中），2 表示 noSuchName（操作指明了一个不存在的变量），3表 示badValue（无效值或无效语法），等等[RFC3416]。</p> <p>（3） 差错索引（error index） 在请求报文中，这个字段是零。当代理进程响应时，若出 现 noSuchName， badValue或readOnly 的差错，代理进程就设置一个整数，指明有差错的变 量在变量列表中的偏移。 （4） 变量绑定（variable-bindings） 中，变量的值应忽略（类型是NULL）。 指明一个或多个变量的名和对应的值。在请求报文 为了大致了解 ASN。1 给出的定义的形式，下面举出定义 GetRequest-PDU 的例子。两个 连字符“–”后面的是注解。 Get-request-PDU ：：= [0] IMPLICIT SEQUENCE { –[0]表示上下文类，编号为0 –类型是SEQUENCE –变量 request-id的类型是integer32 request-id integer32， error-status INTEGER {0。。18}， error-index variable-bindings VarBindList} –变量 error-status取值为0~18的整数 INTEGER {0。。max-bindings}， –变量 error-index 取值为0~max-bindings 的整数 –变量 variable-binding 的类型是VarBindList 但变量 VarBindList 是什么类型呢？还需要继续定义（这里从略）。上面 ASN。1 定义中 的第二行中的 IMPLICIT 叫做隐式标记，是为了在进行编码时可省去对IMPLICIT 后面的类 型（SEQUENCE）的编码，使最后得出的编码更加简洁。 下面我们假定管理者发送 GetRequest-PDU，为的是从某路由器的代理进程获得“收到 UDP数据报的数目”的信息。从图6-22可以查出，mib-2 下面第7个节点是udp，而udp节 点下面的第一个节点就是 udpInDatagrams。由于这个节点已经是叶节点（即没有连接在它下 面的子节点了），读取这个节点的数值时应在节点标识符后面加上0，即 1。3。1。1。2。1。7。1。0。这 样，可得出 GetRequest-PDU 的ASN。1 编码如图6-26 所示。 T L INTEGER 04 T GetRequest-PDU A0 1D L GetRequest -PDU request-id error-status error-index variable-bindings L VarBind V T LV LV T T 05 AE 56 02 INTEGER 01：00 INTEGER 01 00 SEQUENCE OF OF request-ID T L SEQUENCE OD name value T L V T L OBJECT IDENTIFIER 09 01 03 06 01 02 01 01 01 00 1。 3。 6。 1。 2。 1。 7。 1。0 NULL 00 图6-26 GetRequest-PDU的ASN。1 编码</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>可以把图中各字段的十六进制编码表示如下。 A0 1D 02 04 05 AE 56 02 02 01 00 02 01 00 • 306 • 30 OF 30 0D — GetRequest-PDU，上下文类型，长度1D16=29 – INTEGER 类型，长度 0416，request-id = 05 AE56 02 – INTEGER类型，长度 0116， error status = 0016 – INTEGER 类型，长度 0116， error index = 0016 — SEQUENCE OF 类型，长度 OF16 = 15 — SEQUENCE 类型，长度 0。6 = 13</p> <p>06 09 01 03 06 01 02 01 07 01 00 05 00 –</p> <ul> <li>OBJECT IDENTIFIER类型，长度 0916， udpInDatagrams – NULL 类型，长度 0016</li> </ul> <h2 id="八应用进程跨越网络的通信">八、应用进程跨越网络的通信</h2> <p>在这以前我们已经讨论了互联网使用的几种常用的应用层协议，这些应用协议使广大 用户可以更加方便地利用互联网的资源。 现在的问题是：如果我们还有一些特定的应用需要互联网的支持，但这些应用又不能 直接使用已经标准化的互联网应用协议，那么我们应当做哪些工作？要回答这个问题，实际 上就是要了解下面要介绍的系统调用和应用编程接口。这些问题实际上需要一门专门的课程 来学习，我们在这里只能给出一些初步的概念。</p> <h3 id="81-系统调用和应用编程接口">8.1 系统调用和应用编程接口</h3> <p>大多数操作系统使用系统调用（system call）的机制在应用程序和操作系统之间传递控制 权。对程序员来说，系统调用和一般程序设计中的函数调用非常相似，只是系统调用是将控 制权传递给了操作系统。图6-27说明了多个应用进程使用系统调用的机制。 应用程序 1 应用程序2 。。。 应用程序 n 在用户地址空间中 的应用程序 由应用程序调用的系统函数 系统调用接口 包括 TCP/IP 协议软件的操作系统内核 系统地址空间中 的协议软件 图6-27 多个应用进程使用系统调用的机制</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口。此接 口再把控制权传递给计算机的操作系统。操作系统把这个调用转给某个内部过程，并执行所 请求的操作。内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程。总 之，只要应用进程需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执 行必要的操作后把控制权返回给应用进程。因此，系统调用接口实际上就是应用进程的控制 权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些 程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口 API （Application Programming Interface）。API从程序设计的角度定义了许多标准的系统调用 函数。应用进程只要使用标准的系统调用函数就可得到操作系统的服务。因此从程序设计的 角度看，也可以把API看成是应用程序和操作系统之间的接口。 现在 TCP/IP 协议软件已驻留在操作系统中。由于TCP/IP 协议族被设计成能运行在多 种操作系统的环境中，因此 TCP/IP 标准没有规定应用程序与 TCP/IP 协议软件如何接口的细 节，而是允许系统设计者能够选择有关 API 的具体实现细节。目前，只有几种可供应用程 序使用 TCP/IP 的应用编程接口 API。这里最著名的就是美国加利福尼亚大学伯克利分校为 Berkeley UNIX 操作系统定义了一种 API，它又称为套接字接口（socket interface） （或插口接 口）。微软公司在其操作系统中采用了套接字接口 API，形成了一个稍有不同的 API，并称</p> <p>之为 Windows Socket，简称为 WinSock。AT&amp;T 为其 UNIX系统V 定义了一种API，简写为 TLI （Transport Layer Interface）。 我们知道，若要让计算机做某件事情，就要编写使计算机能理解的程序。在网络环境 下的计算机应用都有一个共同特点，这就是：在不同地点的计算机要通过网络进行通信。从 另一种角度看，计算机之间的通信就是本计算机要读取另一个地点的计算机中的数据，或者 要把数据从本计算机写入到另一个地点的计算机中。这种“读取”和“写入”的过程都要用 到上面所说的系统调用。 在讨论网络编程时常常把套接字作为应用进程和运输层协议之间的接口，图6-28 表示 这一概念。图中假定了运输层使用TCP 协议（若使用UDP协议，情况也是类似的，只是 UDP 是无连接的。通信的两端仍然可用两个套接字来标志）。现在套接字已成为计算机操作 系统内核的一部分。 客户 服务器 由应用程序 控制 应用进程 应用进程 套接字 |套接字 互联网 由操作系统 TCP TCP 控制 图6-28 套接字成为应用进程与运输层协议的接口</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>请注意：在套接字以上的进程是受应用程序控制的，而在套接字以下的运输层协议软 件则是受计算机操作系统的控制。因此，只要应用程序使用TCP/IP 协议进行通信，它就必 须通过套接字与操作系统交互（这就要使用系统调用函数）并请求其服务。我们应当注意 到，应用程序的开发者对套接字以上的应用进程具有完全的控制，但对套接字以下的运输层 却只有很少的控制，例如，可以选择运输层协议（TCP 或UDP）以及一些运输层的参数 （如最大缓存空间和最大报文长度等）。 当应用进程（客户或服务器）需要使用网络进行通信时，必须首先发出 socket 系统调 用，请求操作系统为其创建一个“套接字”。这个调用的实际效果是请求操作系统把网络通 信所需要的一些系统资源（存储器空间、CPU 时间、网络带宽等）分配给该应用进程。操 作系统为这些资源的总和用一个叫做套接字描述符（socket descriptor）的号码（小的整数）来 表示，然后把这个套接字描述符返回给应用进程。此后，应用进程所进行的网络操作（建立 连接、收发数据、调整网络通信参数等）都必须使用这个套接字描述符。所以，几乎所有的 网络系统调用都把这个套接字描述符作为套接字的许多参数中的第一个参数。在处理系统调 用的时候，通过套接字描述符，操作系统就可以识别出应该使用哪些资源来完成应用进程所 请求的服务。通信完毕后，应用进程通过一个关闭套接字的 close 系统调用通知操作系统回 收与该套接字描述符相关的所有资源。由此可见，套接字是应用进程为了获得网络通信服务 而与操作系统进行交互时使用的一种机制。 图 6-29 给出了当应用进程发出 socket 系统调用时，操作系统所创建的套接字描述符 与套接字数据结构的关系。由于在一个机器中可能同时出现多个套接字，因此需要有一个存 放套接字描述符的表，而每一个套接字描述符有一个指针指向存放套接字的地址。在套接字</p> <p>的数据结构中有许多参数要填写。图 6-29 中已填写好的参数是协议族（PF_INET，表示使 用 Internet 的 TCP/IP 协议族）和服务（SOCKSTREAM，表示使用流式服务，也就是使用 TCP 服务）。在刚刚创建一个新的套接字时，有灰色背景的四个项目（本地和远地 IP 地址， 本地和远地端口）都是未填写的，因此它和任何机器中的应用进程暂时都还没有联系。 操作系统 套接字描述符表 （每一个进程一个描述符） 套接字的数据结构 0 1 2。 3。 4。 0： 协议族：PF_INET 1： 服务：SOCK_STREAM 2： 3： 远地 4： ： 图6-29 调用 socket 创建套接字 。。。</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <h3 id="82-几种常用的系统调用">8.2 几种常用的系统调用</h3> <p>下面我们以使用TCP 的服务为例介绍几种常用的系统调用。</p> <h4 id="1连接建立阶段">（1）连接建立阶段</h4> <p>当套接字被创建后，它的端口号和IP 地址都是空的，因此应用进程要调用 bind（绑 定）来指明套接字的本地地址（本地端口号和本地 IP 地址）。在服务器端调用bind 时就是 把熟知端口号和本地IP 地址填写到已创建的套接字中。这就叫做把本地地址绑定到套接 字。在客户端也可以不调用 bind，这时由操作系统内核自动分配一个动态端口号（通信结 束后由系统收回）。 服务器在调用 bind 后，还必须调用 listen （收听）把套接字设置为被动方式，以便 随时接受客户的服务请求。UDP 服务器由于只提供无连接服务，不使用 listen 系统调 用。 服务器紧接着就调用 accept（接受），以便把远地客户进程发来的连接请求提取出 来。系统调用 accept 的一个变量就是要指明是从哪一个套接字发起的连接。 调用 accept 要完成的动作较多。这是因为一个服务器必须能够同时处理多个连接。 这样的服务器常称为并发方式（concurrent）工作的服务器。可以有多种方法实现这种并发方 式。图 6-30 所示的是一种实现方法。 主服务器进程 M（就是通常所说的服务器进程）一调用 accept，就为每一个新的连 接请求创建一个新的套接字，并把这个新创建的套接字的标识符返回给发起连接的客户方。 与此同时，主服务器进程还要创建一个从属服务器进程（如图6-30 中的S）来处理新建立 的连接。这样，从属服务器进程用这个新创建的套接字和客户进程建立连接，而主服务器进 程用原来的套接字重新调用 accept，继续接受下一个连接请求。在已建立的连接上，从属</p> <p>服务器进程就使用这个新创建的套接字传送和接收数据。数据通信结束后，从属服务器进程 就关闭这个新创建的套接字，同时这个从属服务器也被撤销。 主服务器进程 M 从属服务器进程 服务器 应用进程 S3 S2 S₁ 接受连接请求 的套接字 （原来的套接字） 连接 连接 连接 套接字 套接字 套接字 - 操作系统 （新创建的套接字） 图6-30 并发方式工作的服务器 总之，在任一时刻，服务器中总是有一个主服务器进程和零个或多个从属服务器进 程。主服务器进程用原来的套接字接受连接请求，而从属服务器进程用新创建的套接字（在 图 6-30 中注明是“连接套接字”）和相应的客户建立连接并可进行双向传送数据。 以上介绍的是服务器为了接受客户端发起的连接请求而进行的一些系统调用。现在看 一下客户端的情况。当使用 TCP 协议的客户已经调用 socket 创建了套接字后，客户进程 就调用 connect，以便和远地服务器建立连接（这就是主动打开，相当于客户发出的连接 请求）。在 connect 系统调用中，客户必须指明远地端点（即远地服务器的IP地址和端口 号）。</p> <h4 id="2数据传送阶段">（2）数据传送阶段</h4> <p>客户和服务器都在 TCP 连接上使用 send 系统调用传送数据，使用recv 系统调用接 收数据。通常客户使用 send 发送请求，而服务器使用 send 发送回答。服务器使用 recv 接收客户用 send 调用发送的请求。客户在发完请求后用recv 接收回答。 调用 send 需要三个变量：数据要发往的套接字的描述符、要发送的数据的地址以及数 据的长度。通常 send 调用把数据复制到操作系统内核的缓存中。若系统的缓存已满， send 就暂时阻塞，直到缓存有空间存放新的数据。 调用 recv 也需要三个变量：要使用的套接字的描述符、缓存的地址以及缓存空间的长 度。</p> <h4 id="3连接释放阶段">（3）连接释放阶段</h4> <p>一旦客户或服务器结束使用套接字，就把套接字撤销。这时就调用 close 释放连接和 撤销套接字。 图 6-31 画出了上述的一些系统调用的使用顺序。有些系统调用在一个 TCP 连接中可能 会循环使用。</p> <p>客户端 服务器端 socket bind socket listen connect 连接建立请求 accept send recv close recv send close 图6-31 系统调用使用顺序的例子</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"></div> <p>UDP 服务器由于只提供无连接服务，因此不使用listen 和 accept 系统调用。</p> <h2 id="九p2p-应用">九、P2P 应用</h2> <p>我们在第1章1。3。1 节中已经简单地介绍了P2P 应用的概念。现在我们将进一步讨论 P2P 应用的若干工作原理。 P2P 应用就是指具有 P2P 体系结构的网络应用。所谓 P2P 体系结构就是在这样的网络 应用中，没有（或只有极少数的）固定的服务器，而绝大多数的交互都是使用对等方式 （P2P 方式）进行的。 P2P 应用的范围很广，例如，文件分发、实时音频或视频会议、数据库系统、网络服务 支持（如 P2P 打车软件、P2P理财等）。限于篇幅，下面只介绍最常用的P2P文件分发的工 作原理。 P2P 文件分发不需要使用集中式的媒体服务器，而所有的音频/视频文件都是在普通的 互联网用户之间传输的。这其实是相当于有很多（有时达到上百万个）分散在各地的媒体服 务器（由普通用户的计算机充当这种媒体服务器）向其他用户提供所要下载的音频/视频文 件。这种 P2P 文件分发方式解决了集中式媒体服务器可能出现的瓶颈问题。 目前在互联网流量中，P2P 工作方式下的文件分发已占据了最大的份额，比万维网应用 所占的比例大得多。因此单纯从流量的角度看，P2P 文件分发应当是互联网上最重要的应 用。现在 P2P 文件分发不仅传送音频文件 MP3，而且还传送视频文件（10~1000 MB，或 更大）、各种软件和图像文件。</p> <h3 id="91-具有集中目录服务器的-p2p-工作方式">9.1 具有集中目录服务器的 P2P 工作方式</h3> <p>最早使用 P2P 工作方式的是Napster。这个名称来自1999 年美国东北大学的新生 Shawn Fanning 所写的一个叫做 Napster 的软件。利用这个软件就可通过互联网免费下载各种 MP3</p> <p>音乐。Napster 的出现使MP3成为网络音乐事实上的标准。 Napster 能够搜索音乐文件，能够提供检索功能。所有音乐文件的索引信息都集中存放 在 Napster 目录服务器中。这个目录服务器起着索引的作用。使用者只要查找目录服务器， 就可知道应从何处下载所要的MP3文件。在2000年，Napster 成为互联网上最流行的 P2P 应用，并占据互联网上的通信量中相当大的比例。 这里的关键就是运行 Napster 的所有用户，都必须及时向 Napster 的目录服务器报告自 己已经存有哪些音乐文件。Napster 目录服务器就用这些用户信息建立起一个动态数据库， 集中存储了所有用户的音乐文件信息（即对象名和相应的 IP 地址）。当某个用户想下载某个 MP3 文件时，就向目录服务器发出查询（这个过程仍是传统的客户-服务器方式），目录服 务器检索出结果后向用户返回存放这一文件的计算机 IP 地址，于是这个用户就可以从中选 取一个地址下载想要得到的 MP3文件（这个下载过程就是P2P 方式）。可以看出，Napster 的文件传输是分散的（P2P方式），但文件的定位则是集中的（客户服务器方式）。 图 6-32 是Napster 的工作过程的示意图。假定 Napster 目录服务器已经建立了其用户的 动态数据库。图中给出了某个用户要下载音乐文件的主要交互过程。 A Napster 集中式 目录服务器 A有，B，C有。 谁有文件 MP3#？ 请求文件 MP3# MP3# C B 图6-32 Napster 的工作过程</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>● 用戶X向Napster 目录服务器查询（客户—服务器方式）谁有音乐文件 MP3#。 ② Napster 目录服务器回答X：有三个地点有文件MP3#，即A，B和C（给出了这三个 地点的 IP 地址）。于是用户X得知所需的文件 MP3#的三个下载地点。 ● 用戶 X 可以随机地选择三个地点中的任一个，也可以使用 PING 报文寻找最方便下 载的一个。在图 6-32 中，我们假定 X向A发送下载文件 MP3#的请求报文。现在X和A都 使用 P2P 方式通信，互相成为对等方，X是临时的客户，而对等方A是临时的服务器。 ● 对等方A（现在作为服务器）把文件MP3#发送给X。 这种集中式目录服务器的最大缺点就是可靠性差，而且会成为其性能的瓶颈（尤其是 在用户数非常多的情况下）。更为严重的是这种做法侵犯了唱片公司的版权。虽然 Napster 网站并没有直接非法复制任何 MP3 文件（Napster 网站不存储任何 MP3 文件，因而并没有 直接侵犯版权），但法院还是判决 Napster 属于“间接侵害版权”，因此在 2000 年 7 月底</p> <p>Napster 网站就被迫关闭了。</p> <h3 id="92-具有全分布式结构的p2p文件共享程序">9.2 具有全分布式结构的P2P文件共享程序</h3> <p>在第一代 P2P 文件共享网站 Napster 关闭后，开始出现了以 Gnutella 为代表的第二代 P2P 文件共享程序。Gnutella 是一种采用全分布方法定位内容的P2P文件共享应用程序。 Gnutella 与 Napster 最大的区别就是不使用集中式的目录服务器进行查询，而是使用洪泛法 在大量 Gnutella 用户之间进行查询。为了不使查询的通信量过大，Gnutella 设计了一种有限 范围的洪泛查询。这样可以减少倾注到互联网的查询流量，但由于查询的范围受限，因而这 也影响到查询定位的准确性。 为了更加有效地在大量用户之间使用P2P技术下载共享文件，最近几年已经开发出很 多种第三代 P2P 共享文件程序[KURO13]，它们使用分散定位和分散传输技术。如 KaZaA， 电骡 eMule，比特洪流BT（BitTorrent）等。 下面对比特洪流 BT 的主要特点进行简单的介绍。 在 P2P 的文件分发应用中，2001 年由 Brahm Cohen 开发的 BitTorrent （中文意思是“比 特洪流”）是很具代表性的一个。取这个名称的原因就是 BitTorrent 把参与某个文件分发的 所有对等方的集合称为一个洪流（torrent）。为了方便，下面我们使用 BitTorrent 的简称 BT。 BT 把对等方下载文件的数据单元称为文件块（chunk），一个文件块的长度是固定不变的，例 如，典型的数值是 256 KB。当一个新的对等方加入某个洪流时，一开始并没有文件块。 但新的对等方逐渐地能够下载到一些文件块。而与此同时，它也为别的对等方上传一些文件 块。某个对等方获得了整个的文件后，可以立即退出这个洪流（相当于自私的用户），也可 继续留在这个洪流中，为其他的对等方上传文件块（相当于无私的用户）。加入或退出某个 洪流可在任何时间完成（即使在某个文件还没有下载完毕时），也是完全自由的。 BT 的协议相当复杂[W-BT]。下面讨论其基本机制。 每一个洪流都有一个基础设施结点，叫做追踪器（tracker）。当一个对等方加入洪流时， 必须向追踪器登记（或称为注册），并周期性地通知追踪器它仍在洪流中。追踪器因而就跟 踪了洪流中的对等方。一个洪流中可以拥有少到几个多到几百或几千个对等方。 我们用图 6-33 来进一步说明 BT 的工作原理。当一个新的对等方A加入洪流时，追踪 器就随机地从参与的对等方集合中选择若干个（例如，30个），并把这些对等方的IP 地址 告诉 A。于是 A就和这些对等方建立了TCP 连接。我们称所有与A建立了TCP 连接的对 等方为“相邻对等方”（neighboring peers）。在图 6-33 中我们画出了 A 有三个相邻对等方 （B，C 和 D）。这些相邻对等方的数目是动态变化的，有的不久就离开了，但又有新加入 进来的。请注意，实际的网络拓扑可能是非常复杂的（参见图6-34的实际网络图）。我们知 道，TCP 连接只是个逻辑连接，而每一个 TCP 连接可能会穿越很多的网络。因此我们在讨 论问题时，可以利用实际网络上面的一个更加简洁的覆盖网络，这个覆盖网络忽略了实际网 络的许多细节，使问题的讨论更加方便。在覆盖网络中，A的三个相邻对等方就看得很清 楚。然而在实际网络中，则反映不出这几个对等方的相邻关系。 在任何时刻，每一个对等方可能只拥有某文件的一个文件块子集，而不同的对等方所 拥有的文件块子集也不会完全相同。对等方A将通过TCP连接周期性地向其相邻对等方索 取它们拥有的文件块列表。根据收到的文件块列表，A就知道了应当请求哪一个相邻对等方 把哪些自己缺少的文件块发送过来。</p> <p>追踪器 TCP连接 D D BT 覆盖网络 实际网络 图6-33 在覆盖网络中对等方的相邻关系的示意图</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"></div> <p>图 6-34 是对等方之间互相传送数据块的示意图。例如，A 向 B、C和D 索取数据块， 但 B 同时也向C和D传送数据块，D和C还互相传送数据块。由于P2P对等用户的数量非 常多，因此，从不同的对等方获得不同的数据块，然后组装成整个的文件，一般要比仅从一 个地方下载整个的文件要快很多。 对等方A 对等方 对等方 B 图例： 数据块 数据块传送 对等方C 图6-34 对等方之间互相传送文件数据块</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>然而 A 必须做出两个重要决定。第一，哪些文件块是首先需要向其相邻对等方请求 的？第二，在很多向 A 请求文件块的相邻对等方中，A应当向哪些相邻对等方发送所请求 的文件块？ 对于第一个问题，A要使用叫做最稀有的优先（rarest first）的技术。我们知道，凡是A所 缺少的而正好相邻对等方已拥有的文件块，都应当去索取。可能其中的某些文件块，很多相 邻对等方都有（即文件块的副本很多），这就是“不稀有的”文件块，以后可慢慢请求。如 果 A 所缺少的文件块在相邻对等方中的副本很少，那就是“很稀有的”。因此，A 首先应当 请求副本最少的文件块（即最稀有的）。否则，一旦拥有最稀有文件块的对等方退出了洪 流，就会影响A对所缺文件块的收集。 对于第二个问题，BT 采用了一种更加机灵的算法，其基本思想就是：凡当前有以最高 数据率向 A 传送文件块的某相邻对等方，A就优先把所请求的文件块传送给该相邻对等 方。具体来说，A 持续地测量从其相邻对等方接收数据的速率，并确定速率最高的4个相邻 对等方。接着，A就把文件块发送给这4个相邻对等方。每隔10秒钟，A 还要重新计算数 据率，然后可能修改这4个对等方。在 BT 的术语中，这4个对等方叫做已疏通的或无障碍</p> <p>的（unchoked）对等方。更重要的是，每隔30秒，A要随机地找一个另外的相邻对等方 B，并 向其发送文件块。这样，A有可能成为B的前4位上传文件块的提供者。在此情况下，B 也有可能向 A 发送文件块。如果B发送文件的速率足够快，那么B也有可能进入A的前 4 位上传文件块的提供者。这样做的结果是，这些对等方相互之间都能够以令人满意的速率 交换文件块。</p> <h3 id="93-p2p-文件分发的分析">9.3 P2P 文件分发的分析</h3> <p>我们从一个例子开始，来讨论 P2P 文件分发中的几个重要概念[KURO13]。 在图 6-35 中，有N台主机要从互联网上的服务器下载一个大文件，其长度为 F bit。在 图中我们把这个文件也记为F。按照习惯，从互联网传送数据到主机，叫做下载 （download），而反过来传送数据，即从主机向互联网传送，则称为上传（upload）或上载。服务 器的文件是供互联网上的用户享用的，因此服务器的文件只是单方向上传到互联网。我们把 服务器的上传速率记为us，单位是bit/s。再假定主机与互联网连接的链路的上传速率和下载 速率分别为 u； 和d，单位都是bit/s。我们还假定互联网的核心部分不会产生拥塞。瓶颈只 会发生在服务器的接入链路，或者是某些主机的接入链路。 62 d2 d₁ dN UN 文件 F 互联网 Из 5 ds 服务器 图6-35 文件分发的例子</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"></div> <p>我们先在传统的客户服务器方式下，计算给所有主机分发完毕的最短时间 Tes。 从服务器端考虑，N 台主机共需要从服务器得到的数据总量（比特数）是NF。如果服 务器能够不停地以其上传速率us向各主机传送数据，一直到各主机都收到文件 F，就需要 时间 NF/us，单位是秒。由此可见，不可能小于 NF/us 如果 N 台主机都以各自的下载速率不停地下载文件F，那么下载速率最慢的主机（设 其下载速率为 dmin）的下载文件时间（F/dmin），将是N个下载时间中最大的一个。由此可 见，Tas也不可能小于 F/dmin。 如果 NF/us ≥ F/dmin，则瓶颈在服务器端的接入链路。这时 Tes = NF/us。 如果 F/dmin ≥ NF/us，则瓶颈在下载最慢的主机的接入链路。这时Tes = F/dmin。 由此可得出所有主机都下载完文件F的最少时间是</p> <p>NF F Tes = max- us da min （6-2） 从以上分析可以看出，若公式（6-2）括号中的第一项远大于第二项，则 Ts近似与主机数 N成正比。如果主机数增大1000倍，那么文件的分发时间也要增大 1000 倍。 下面讨论在 P2P方式下，文件全部分发完毕的最少时间 Tp2p。然而在P2P方式下，文 件分发所需的时间较难计算，这是因为每一台主机在接收文件的同时，还利用自己的上传能 力向其他主机传送文件。文件传送所需的时间取决于主机向对等方传送文件的具体方式。但 是，我们还是可以导出文件分发所需的最少时间的表达式。 在文件分发开始时，只有服务器有文件F。服务器必须把文件F的每一个比特通过接入 链路传送到互联网（至少要传送一次）。因此文件分发的最少时间不可能小于F/us。和客户- 服务器方式相比，在P2P方式下，服务器不需要一遍一遍地发送文件F，因为互联网上的其 他主机（即对等方）可以代替服务器向其他对等方分发文件 F。 在 P2P 方式下，下载速率最慢的主机（设其下载速率为dmin）下载文件 F 的时间是 F/dmin，这是 N个对等方下载时间中最大的一个。可见文件分发的最少时间不可能小于 F/dmin。这个结论和客户服务器方式是一样的。 整个系统中所有主机（包括服务器）的上传速率之和是ur=us+U1+U2+。。。+uyo因 此，文件分发的最少时间也不可能小于 NF/uTo 这样，我们得出在P2P方式下所有主机都下载完文件F的最少时间的下限是 F F NF Tpzp≥max- us d UT min （6-3） 在公式（6-3）的推导过程中，我们假定每一个对等方只要收到一个比特就立即上传到互 联网的其他对等方。但实际上是把收到的若干个比特组成一个数据块后再上传出去。但是当 文件 F 很大时，我们也可以在公式（6-3）中取等号，作为文件F的最少分发时间 Tpzp的近似 值。 有一种情况最值得我们注意。这就是对等方的数目N非常大，因此在公式（6-3）的括号 中的最后一项的值将远大于前两项的值。这样，Tpzp值的下限就近似为NF/uT 我们再假定一些数据。设所有的对等方的上传速率都是u，并且 Flu ==== 1 小时，所有对 等方的下载速率都不小于服务器的上传速率，因而不会对我们的计算产生影响。我们还设服 务器的上传速率us=10u。当N=30时，用公式（6-3）算出所有主机都下载完文件F的最少时 间的下限是 Tp2p = 0。75 F/u= 0。75小时&lt;1小时（不管多大）。如果采用客户-服务器方 式，则当N=30时，所有主机都下载完文件F的最少时间是Ts=NF/us=3小时。</p> <h3 id="94-在-p2p-对等方中搜索对象">9.4 在 P2P 对等方中搜索对象</h3> <p>在 P2P 文件系统中，对等方用户的数量非常多，并且处于一种无序的状态。任何一个 对等方可以随时加入进来或随时退出。在这种情况下，怎样有效地找到所需的文件，也就是 怎样有效地定位对等方及其资源，乃是P2P系统中的一个十分重要的问题。 限于篇幅，我们在这里只简单介绍一下怎样利用散列函数来定位对等方。 我们知道，Gnutella 是一种采用全分布方法定位内容的P2P文件共享应用程序，它解决</p> <p>了集中式目录服务器所造成的瓶颈问题。然而 Gnutella 是在非结构化的覆盖网络中采用查询 洪泛的方法来进行查找的，因此查找的效率较低。现在比较好的查找方法是设法构建一种分 布式数据库，以进行对等方及其资源的定位。这种分布式数据库在概念上并不复杂，只要能 够支持大量对等方（可能有几百万个）进行索引查找即可。存储在数据库中的信息只有两个 部分： （1）要查找的资源名K（例如，电影或歌曲的名字）。资源名也可称为关键字。 （2）存放该对象的结点的IP地址N。有的IP地址还附带有端口号。 存放在数据库中的信息就是大量成对出现的（资源名 K，结点的 IP 地址 N）。在查找某 资源名 K 时，只要在数据库中查找到匹配的资源名K，数据库就能够返回对应的结点的 IP 地址 N。所以问题的关键就是要设法把每个资源名K 存放在一个非常便于查找的地方。 细心的读者可能会联想到曾在前面 6。1 节讨论的 DNS 域名系统。DNS 是根据主机的域 名来查找其 IP 地址，这和 P2P 的情况有相似之处。但我们知道，主机的域名是结构化的命 名系统，因此域名服务器可以划分为几种不同的级别（如根服务器等）便于查找。但 P2P 系统则不同，其资源名是非结构化的。因此不能套用DNS的那种查找方法。 前面已经讲过，Napster 在一个集中式目录服务器中构建的查找数据库虽然很简单，但 性能上却有瓶颈。在 P2P 系统中，应怎样构建分布式的P2P数据库？让每个对等方都拥有 所有对等方 IP 地址的列表是不可行的。让所有成对出现的（资源名 K， IP 地址 N）随机地分 散到各对等方也是不可行的。因为这将使查找对象的次数过大，无法使用。现在广泛使用的 索引和查找技术叫做分布式散列表 DHT （Distributed Hash Table）。DHT 也可译为分布式哈希 表，它是由大量对等方共同维护的散列表。基于 DHT 的具体算法已有不少，如 Chord， Pastry，CAN （Content Addressable Network），以及Kademilia 等。下面简单介绍广泛使用的 Chord 算法，这是美国麻省理工大学于2001年提出的[STOI01]。 分布式散列表 DHT 利用散列函数，把资源名K及其存放的结点IP地址N都分别映射 为资源名标识符 KID 和结点标识符 NID。如果所有的对等方都使用散列函数 SHA-1（我们 在下一章 7。4。1 节还要介绍 SHA-1 在网络安全方面的应用），那么通过散列得出的标识符 KID 和 NID 都是 160位二进制数字，且其数值范围在[0， 2’60 - 1]之间。虽然从理论上讲，散 列函数 SHA-1 是多对一的函数，但实际上不同输入得到相同的输出的概率是极小的。此 外，通过 SHA-1 映射得到的标识符能够比较均匀而稀疏地分布在 Chord 环上。为便于讨 论，我们假定现在标识符只有5位二进制数字，也就是说，所有经散列函数得出的标识符的 数值范围都在[0， 31]之间。Chord 把结点按标识符数值从小到大沿顺时针排列成一个环形覆 盖网络（见图 6-36（a）），并按照下面的规则进行映射： （1） 结点标识符 NID 按照其标识符值映射到 Chord 环上对应的点，见图 6-36（a）中标有 NID 的小圆点，如 N4， N7， N10， N20， N26 和 N30。 （2） 资源名标识符 KID 则按照其标识符值映射到与其值最接近的下一个 NID，见图 6- 36（a）中标有 KID 的小方块。所谓“最接近的下一个”NID 就是指：从KID值开始，按顺时 针方向沿 Chord 环遇到的下一个 NID。例如，K31 和K2应放在N4，因为在环上从 31 和 2 按顺时针方向遇到的下一个 NID 是 N4。同理，K8，K12，K23 和K29应分别放在N10， N20， N26 和 N30。如果碰巧同时出现 K29和N29（这种概率极小），那么K29 就应当放在 N29。 请注意：在图 6-36中，K31 和K2 都放在N4，这表示要查找存放资源K31 或 K2 的结 点的 IP 地址，就应当到结点N4去查找。请注意，资源 K31 和 K2 并非存放在结点 N4。</p> <p>这就是说，每个资源由 Chord 环上与其标识符值最接近的下一个结点提供服务。我们 再强调一下，Chord 环并非实际的网络。在 Chord环上相邻的结点，在地理上很可能相距非 常远。 N30 K31 K2 N30 K31 K2 图例：ONID K29 31 0 1 30 2 K29 29 3 N4 KID 30 31 0 1 2 K23 ☑ 29 1N4 28 28 N26 27 27 6 26 K23 25 7ON7 25 70N7 8 8 24 24 9 9 23 23 K8 K8 10 10 22 22 11 N10 11 N10 21 21 20 20 N20 19 N20 K12 18 17 16 15 （a） KID 和 NID映射在环上 18 17 16 15 -K12 N13 （b）N13加入，N26退出 图 6-36 基于 DHT 的 Chord 环</p> <div class="row justify-content-center"> <div class="col-8"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/images/computer-network/-480.webp 480w,/assets/images/computer-network/-800.webp 800w,/assets/images/computer-network/-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/images/computer-network/" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> </div> <p>Chord 环上的每一个结点都要维护两个指针变量，一个指向其后继结点，而另一个指向 其前任结点。例如，在图 6-36（a）中，N10 的后继结点是N20（沿顺时针方向 N10 的下一个 结点），其前任结点是N7（沿逆时针方向N10之前的一个结点）。如果一个新的结点 N13 加 入进来，那么 N20 的前任结点就变为N13，因而 K12 就要从N20的位置移到 N13，同时 N10 的后继结点就变为N13（见图6-36（b））。此外，如果结点 N26 退出，那么 K23 就要移 到N30，而N30 的前任结点就变为N20，同时N20的后继结点变为N30。 在这样的 Chord 环上查找资源，从理论上讲，任何一个结点，只要从其后继结点一个 个地遍历查找下去，一定可以找到所查询的资源。可见要定位一个资源，平均需要沿环发送 查找报文 N/2 个，或遍历 O（N）个结点（N为环上的总结点数）。显然，这种顺序查找的方法 效率很低。 = 为了加速查找，在 Chord 环上可以增加一些指针表（finger table），它又称为路由表或查 找器表。若 Chord 环上的标识符有 m 位（现在 m 5），则在结点n上的指针表可设置不超 过 m 个指针，指向其后继的结点。我们先看图 6-37中结点 N4的指针表。指针表中的第2 列是从 N4 可以指向的多个后继结点。本来每一个结点仅仅指向沿顺时针方向的下一个后继 结点，但现在则指向多个后继结点（在本例中就是 N7，N10 和N20）。第1列的第i行是计 算 （N4 + 2’-‘），用来得出后继结点。例如，第4行 i = 4，算出（N4 + 2-1） = N4 + 8 = 12，而 Chord 环上的结点 12 的后继结点是N20。图中还画出了从 N4 到这几个后继结点的 连线（这些连线就是 Chord 环上的弦，Chord 名字由此得出）。还有一点要注意的是，在 N20 的指针表中的第5行，N20+16=36，但按照模 2‘运算，36 mod 2 = 4，恰好结点4的 后继结点是N4。 假定在图 6-37 中的结点 N4 要查找 K29。如果用遍历各结点的方法，则要查找 5 次， 即 N7→N10→N20→N29→N30。但若利用指针表，则 N4 首先在自己的指针表中寻找在不 到 29 且最接近 29 的结点，即N20，然后把定位资源 K29 的请求发送给 N20。在 N20 的指 针表中继续类似的寻找。结果是：最接近29的结点是N30。这就是存放资源 K29 的结点。 这种查找方法类似于二分查找，只用了两次查找，定位一个资源仅需 O（logz）步。</p> <p>N30 K31 K2 图例： ● NID N4 的指针表 K29 31 0 1 2 KID N4 29 N4 + 1 |N7 28 N4 + 2 NZ N26 N4 + 4 N10 K23 ONG N4 + 8 |N20 8 N4+16 N20 24 N20 的指针表 23 K8 N20+1 N26 N20+2 N26 11 JN10 N20+4 N26 12 19 13 N20+8 N30 N20 |N20+16 N4 K12 图6-37 结点 N4 和N20 的指针表 在 P2P 网络中，对等方可能相当频繁地加入或退出系统，这就需要很好地维护这个分 布式数据库（维护各结点的指针和指针表），而这种维护的工作量可能会很大。当对等方数 量非常大时，究竟采用何种查询机制更加合理，则需要根据具体情况来确定。 P2P 技术还在不断地改进，但随着 P2P 文件共享程序日益广泛地使用，也产生了一系列 的问题有待于解决。这些问题已迫使人们要重新思考下一代互联网应如何演进。例如，音频 /视频文件的知识产权就是其中的一个问题。又如，当非法盗版的、或不健康的音频/视频文 件在互联网上利用 P2P 文件共享程序广泛传播时，要对P2P的流量进行有效的管理，在技 术上还是有相当的难度。由于现在 P2P 文件共享程序的大量使用，已经消耗了互联网主干 网上大部分的带宽。因此，怎样制定出合理的收费标准，既能够让广大网民接受，又能使网 络运营商赢利并继续加大投入，也是目前迫切需要解决的问题。</p> <h2 id="十本章的重要概念">十、本章的重要概念</h2> <p>应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于不同主机中的 多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所 遵循的协议。应用层的许多协议都是基于客户服务器方式的。客户是服务请求方， 服务器是服务提供方。 域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。DNS 是一个联机分布式数据库系统，并采用客户服务器方式。 域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序（即域名服务 器）共同完成的。 互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器， 都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制IP 地址中的 点没有关系。 域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服 务器。 文件传送协议 FTP 使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客戶 和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接。实际用于传输 文件的是数据连接。 万维网 WWW 是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网</p> <p>• 上的一个站点链接到另一个站点。 万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回 客户所要的万维网文档。在客户程序主窗口上显示出的万维网文档称为页面。 万维网使用统一资源定位符 URL 来标志万维网上的各种文档，并使每一个文档在整 个互联网的范围内具有唯一的标识符 URL。 万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议 HTTP。HTTP 使用TCP连接进行可靠的传送。但HTTP协议本身是无连接、无状 态的。HTTP/1。1协议使用了持续连接（分为非流水线方式和流水线方式）。 万维网使用超文本标记语言 HTML 来显示各种万维网页面。 万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的 过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时 才由应用程序动态创建的。 活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可 连续地改变屏幕的显示。 • 在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索 搜索引擎和分类目录搜索引擎两大类。 • 电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发送 到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自 己使用的邮件服务器进行读取，相当于“电子信箱”。 一个电子邮件系统有三个主要组成构件，即：用户代理、邮件服务器，以及邮件协 议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和IMAP）。用户代 理和邮件服务器都要运行这些协议。 电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的 视窗界面来发送和接收邮件。 从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送，都要使用 SMTP 协议。但用户代理从邮件服务器读取邮件时，则要使用 POP3（或IMAP） 协议。 基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏览器和邮件服 务器之间的邮件传送使用 HTTP 协议，而在邮件服务器之间邮件的传送仍然使用 SMTP 协议。 简单网络管理协议 SNMP 由三部分组成，即（1） SNMP 本身，负责读取和改变各代 理中的对象名及其状态数值；（2）管理信息结构 SMI，定义命名对象和定义对象类 型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的基本编码规 则 BER；（3） 管理信息库 MIB，在被管理的实体中创建了命名对象，并规定了其类 型。 系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称 为应用编程接口API。API就是应用程序和操作系统之间的接口。 • 套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而 与操作系统进行交互时使用的一种机制。 目前 P2P 工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应 用所占的比例大得多。 • BT 是很流行的一种P2P应用。BT采用“最稀有的优先”的技术，可以尽早把最 稀有的文件收集到。此外，凡有当前以最高数据率向某个对等方传送文件块的相 邻对等方，该对等方就优先把所请求的文件传送给这些相邻对等方。这样做的结 果是，这些对等方相互之间都能够以令人满意的速率交换文件块。 当对方的数量很大时，采用P2P方式下载大文件，要比传统的客户服务器方式 快得多。 • 在P2P 应用中，广泛使用的索引和查找技术是分布式散列表DHT。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/bom/">《JavaScript 教程 - 浏览器模型》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/events/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/dom/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/async/">《JavaScript 教程》摘录</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/oop/">《JavaScript 教程》摘录</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Zhang Feng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-repositories",title:"repositories",description:"Edit the `_data/repositories.yml` and change the `github_users` and `github_repos` lists to include your own GitHub profile and repositories.",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"This is a description of the page. You can modify it in &#39;_pages/cv.md&#39;. You can also change or remove the top pdf download button.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"nav-people",title:"people",description:"members of the lab or group",section:"Navigation",handler:()=>{window.location.href="/people/"}},{id:"dropdown-blog",title:"blog",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-javascript-\u6559\u7a0b-\u6d4f\u89c8\u5668\u6a21\u578b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b - \u6d4f\u89c8\u5668\u6a21\u578b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/bom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/dom/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/oop/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stdlib/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/features/"}},{id:"post-javascript-\u6559\u7a0b-\u6458\u5f55",title:"\u300aJavaScript \u6559\u7a0b\u300b\u6458\u5f55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/operators/"}},{id:"post-webpack-\u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",title:"webpack \u7684\u53d1\u5e03-\u8ba2\u9605\u6a21\u5f0f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/publish-subscribe-model/"}},{id:"post-webpack-\u9879\u76ee\u4f18\u5316",title:"webpack \u9879\u76ee\u4f18\u5316",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/optimization/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/configuration/"}},{id:"post-webpack-\u5e38\u7528\u914d\u7f6e\u9879",title:"webpack \u5e38\u7528\u914d\u7f6e\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/concepts/"}},{id:"post-webpack-\u6784\u5efa\u6d41\u7a0b",title:"webpack \u6784\u5efa\u6d41\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/build-flow/"}},{id:"post-webpack-\u4e2d\u7684-plugin",title:"webpack \u4e2d\u7684 Plugin",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/plugin/"}},{id:"post-webpack-\u4e2d\u7684-loader",title:"webpack \u4e2d\u7684 Loader",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/loader/"}},{id:"post-http-\u7f13\u5b58",title:"HTTP \u7f13\u5b58",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/07-caching/"}},{id:"post-http-\u8fde\u63a5\u7ba1\u7406",title:"HTTP \u8fde\u63a5\u7ba1\u7406",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/04-connection-management/"}},{id:"post-es6-\u7f16\u7a0b\u98ce\u683c",title:"ES6 - \u7f16\u7a0b\u98ce\u683c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/style/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u5e94\u7528\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u5e94\u7528\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/application-layer/"}},{id:"post-\u54cd\u5e94\u5f0f-web-\u8bbe\u8ba1",title:"\u54cd\u5e94\u5f0f Web \u8bbe\u8ba1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/responsive-web-design/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u8fd0\u8f93\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u8fd0\u8f93\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/transport-layer/"}},{id:"post-react-\u4e2d\u7684\u4e8b\u4ef6",title:"React \u4e2d\u7684\u4e8b\u4ef6",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/events-in-react/"}},{id:"post-css-\u9884\u5904\u7406\u5668",title:"CSS \u9884\u5904\u7406\u5668",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-preprocessor/"}},{id:"post-css-modules-\u7528\u6cd5\u6559\u7a0b",title:"CSS Modules \u7528\u6cd5\u6559\u7a0b",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/css-modules/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7f51\u7edc\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7f51\u7edc\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/network-layer/"}},{id:"post-\u8de8\u57df\u8d44\u6e90\u5171\u4eab-cors",title:"\u8de8\u57df\u8d44\u6e90\u5171\u4eab\uff08CORS\uff09",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cors/"}},{id:"post-\u9632\u6296\u548c\u8282\u6d41",title:"\u9632\u6296\u548c\u8282\u6d41",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/debounce-and-throttle/"}},{id:"post-es6-symbol",title:"ES6 - Symbol",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/symbol/"}},{id:"post-es6-\u5b57\u7b26\u4e32\u7684\u6269\u5c55",title:"ES6 - \u5b57\u7b26\u4e32\u7684\u6269\u5c55",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/string/"}},{id:"post-es6-set",title:"ES6 - Set",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/set/"}},{id:"post-es6-reflect",title:"ES6 - Reflect",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/reflect/"}},{id:"post-es6-proxy",title:"ES6 - Proxy",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/proxy/"}},{id:"post-es6-promise-\u5bf9\u8c61",title:"ES6 - Promise \u5bf9\u8c61",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/promise/"}},{id:"post-es6-object",title:"ES6 - Object",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/object/"}},{id:"post-es6-\u6a21\u5757",title:"ES6 - \u6a21\u5757",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/module/"}},{id:"post-es6-map",title:"ES6 - Map",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/map/"}},{id:"post-es6-let-\u548c-const-\u547d\u4ee4",title:"ES6 - let \u548c const \u547d\u4ee4",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/let-const/"}},{id:"post-es6-iterator",title:"ES6 - Iterator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/iterator/"}},{id:"post-es6-generator-\u51fd\u6570",title:"ES6 - Generator \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/generator/"}},{id:"post-es6-function",title:"ES6 - Function",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/function/"}},{id:"post-es6-decorator",title:"ES6 - Decorator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/decorator/"}},{id:"post-es6-class",title:"ES6 - Class",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/class/"}},{id:"post-es6-async-\u51fd\u6570",title:"ES6 - async \u51fd\u6570",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/async/"}},{id:"post-es6-array",title:"ES6 - Array",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/array/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6570\u636e\u94fe\u8def\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6570\u636e\u94fe\u8def\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/data-link-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u7269\u7406\u5c42",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u7269\u7406\u5c42",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/physical-layer/"}},{id:"post-\u8ba1\u7b97\u673a\u7f51\u7edc-\u6982\u8ff0",title:"\u8ba1\u7b97\u673a\u7f51\u7edc - \u6982\u8ff0",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/instruction/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%7A%66%65%6E%67%30%37%31%32@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=qc6CJjYAAAAJ","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>