---
layout: post
title: 《JavaScript 教程》摘录
categories: blog
tags:
  - javascript
  - events
---

> 本文是对[《JavaScript 教程 - 事件》](https://wangdoc.com/javascript/events/)一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。

## 一、EventTarget 接口

DOM 节点的事件操作（监听和触发），都定义在 `EventTarget` 接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。

该接口主要提供三个实例方法。

- `addEventListener(type, listener[, useCapture])`：用于在当前节点或对象上（即部署了 `EventTarget` 接口的对象），定义一个特定事件的监听函数。

  第三个参数除了布尔值 `useCapture`，还可以是一个监听器配置对象，定制事件监听行为。该对象有以下属性。

  - `capture`：布尔值，如果设为 `true`，表示监听函数在捕获阶段触发，默认为 `false`，在冒泡阶段触发。
  - `once`：布尔值，如果设为 `true`，表示监听函数执行一次就会自动移除，后面将不再监听该事件。该属性默认值为 `false`。
  - `passive`：布尔值，设为 `true` 时，表示禁止监听函数调用 `preventDefault()` 方法。如果调用了，浏览器将忽略这个要求，并在控制台输出一条警告。该属性默认值为 `false`。
  - `signal`：该属性的值为一个 `AbortSignal` 对象，为监听器设置了一个信号通道，用来在需要时发出信号，移除监听函数。

  `addEventListener()` 方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用 `removeEventListener()` 方法手动去除）。

- `removeEventListener(type, listener[, useCapture])`：用于移除事件的监听函数，与 `addEventListener()` 方法完全一致。它的第一个参数“事件类型”，大小写敏感。
- `dispatchEvent(event)`：用于在当前节点上触发指定事件，从而触发监听函数的执行。

## 二、事件模型

JavaScript 有三种方法，可以为事件绑定监听函数。

- HTML 的 `on-` 属性。使用这个方法指定的监听代码，只会在**冒泡阶段**触发。
- 元素节点的事件属性。使用这个方法指定的监听函数，也是只会在**冒泡阶段**触发。
- `EventTarget.addEventListener()`，推荐使用这种方法。它有如下优点：

  - 同一个事件可以添加多个监听函数。
  - 能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。
  - 除了 DOM 节点，其他对象（比如 `window`、`XMLHttpRequest` 等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。

上面三种方式，函数内部的 this 指向触发事件的那个元素节点。

一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。

- 第一阶段：从 `window` 对象传导到目标节点（上层传到底层），称为“**捕获阶段**”（capture phase）。
- 第二阶段：在目标节点上触发，称为“**目标阶段**”（target phase）。
- 第三阶段：从目标节点传导回 `window` 对象（从底层传回上层），称为“**冒泡阶段**”（bubbling phase）。

由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的**代理**（delegation）。

## 三、Event 对象

### 1. 概述

`Event` 构造函数可以用来生成实例对象。他接受两参数，第一个参数 `type` 是字符串，表示事件的名称；第二个参数 `options` 是一个对象，表示事件对象的配置。该对象主要有下面两个属性。

- `bubbles`：布尔值，可选，默认为 `false`（即生成的事件只在“捕获阶段”触发监听函数），表示事件对象是否冒泡。
- `cancelable`：布尔值，可选，默认为 `false`，表示事件是否可以被取消，即能否用 `Event.preventDefault()` 取消这个事件。

```javascript
var ev = new Event(
  'look',
  {
    'bubbles': true,
    'cancelable': false
  }
);
document.dispatchEvent(ev);
```

上面代码新建一个 `look` 事件实例，然后使用 `dispatchEvent()` 方法触发该事件。

### 2. 实例属性

- `Event.bubbles` 属性返回一个布尔值，表示当前事件是否会冒泡。该属性只读。
- `Event.eventPhase` 属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。

  `Event.eventPhase` 的返回值有四种可能。

  - `0`，事件目前没有发生。
  - `1`，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。
  - `2`，事件到达目标节点，即 Event.target 属性指向的那个节点。
  - `3`，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。

- `Event.cancelable` 属性返回一个布尔值，表示事件是否可以取消。
- `Event.cancelBubble` 属性是一个布尔值，如果设为 `true`，相当于执行 `Event.stopPropagation()`，可以阻止事件的传播。
- `Event.defaultPrevented` 属性返回一个布尔值，表示该事件是否调用过 `Event.preventDefault()` 方法。该属性只读。
- `Event.target` 属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。
- `Event.currentTarget` 属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。

  ```javascript
  // HTML 代码为
  // <p id="para">Hello <em>World</em></p>
  function hide(e) {
    // 不管点击 Hello 或 World，总是返回 true
    console.log(this === e.currentTarget);

    // 点击 Hello，返回 true
    // 点击 World，返回 false
    console.log(this === e.target);
  }

  document.getElementById('para').addEventListener('click', hide, false);
  ```

  上面代码中，`<em>` 是 `<p>` 的子节点，点击 `<em>` 或者点击 `<p>`，都会导致监听函数执行。这时，`e.target` 总是指向原始点击位置的那个节点，而 `e.currentTarget` 指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以 `e.currentTarget` 总是等同于监听函数内部的 `this`。

- `Event.type` 属性返回一个字符串，表示事件类型。
- `Event.timeStamp` 属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。
- `Event.isTrusted` 属性返回一个布尔值，表示该事件是否由真实的用户行为产生。
- `Event.detail` 属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于 `click` 和 `dblclick` 事件，`Event.detail` 是鼠标按下的次数（`1` 表示单击，`2` 表示双击，`3` 表示三击）；对于鼠标滚轮事件，`Event.detail` 是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是 `3` 的倍数。

### 3. 实例方法

- `Event.preventDefault()` 方法用于取消浏览器对当前事件的默认行为。该方法生效的前提是，事件对象的 `cancelable` 属性为 `true`，如果为 `false`，调用该方法没有任何效果。注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用 `stopPropagation()` 或 `stopImmediatePropagation()` 方法。
- `Event.stopPropagation()` 方法用于阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。
- `Event.stopImmediatePropagation()` 方法方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比 `Event.stopPropagation()` 更彻底。

  如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了 `Event.stopImmediatePropagation()` 方法，其他的监听函数就不会再执行了。

- `Event.composedPath()` 方法返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。

```javascript
// HTML 代码如下
// <div>
//   <p>Hello</p>
// </div>
var div = document.querySelector('div');
var p = document.querySelector('p');

div.addEventListener('click', function (e) {
  console.log(e.composedPath());
}, false);
// [p, div, body, html, document, Window]
```

上面代码中，`click` 事件的最底层节点是 `p`，向上依次是 `div`、`body`、`html`、`document`、`Window`。

## 四、鼠标事件

```javascript
```

```javascript
```

```javascript
```

## 五、键盘事件

```javascript
```

```javascript
```

```javascript
```

## 六、进度事件

```javascript
```

```javascript
```

```javascript
```

## 七、表单事件

```javascript
```

```javascript
```

```javascript
```

## 八、触摸事件

```javascript
```

```javascript
```

```javascript
```

## 九、拖拉事件

```javascript
```

```javascript
```

```javascript
```

## 十、其他常见事件

```javascript
```

```javascript
```

```javascript
```

## 十一、GlobalEventHandlers 接口

```javascript
```

```javascript
```

```javascript
```

## 十二、参考

- 阮一峰，[JavaScript 教程 - 事件](https://wangdoc.com/javascript/events/)