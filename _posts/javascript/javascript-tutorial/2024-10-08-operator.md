---
layout: post
title: 《JavaScript 教程》摘录
categories: blog
tags:
  - javascript
---

本文是对[《JavaScript 教程 - 运算符》](https://wangdoc.com/javascript/operators/)一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。

## 一、算术运算符

### 1.1 概述

JavaScript 共提供 10 个算术运算符，用来完成基本的算术运算。包括 `+`、`-`、`*`、`/`、`**`（指数运算符）、`%`（余数运算符）、`++x`（或者 `x++`，即自增运算符）、`--x`（或者 `x--`，即）自减运算符、`+x`（数值运算符） 和 `-x`（负数值运算符）。

### 1.2 加法运算符

#### 基本规则

相比于其他运算符，加法运算符（`+`）比较特殊，即可当作算数运算符，又可对字符串进行连接操作。

只要有一个是运算子是字符串，进行的就是字符串的连接操作（此时，如果另一个运算子不是字符串，会被转为字符串）。

```javascript
1 + 'a' // "1a"
false + 'a' // "falsea"
```

加法运算符是在**运行时**决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“**重载**”（overload）。

```javascript
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
```

除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：**所有运算子一律转为数值，再进行相应的数学运算**。

```javascript
1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

#### 对象的相加

如果运算子是对象，必须先转成原始类型的值，然后再相加。它的规则是：首先自动调用对象的 `valueOf` 方法，如果此时返回的是原始类型的值，则进行相应的操作，如果 `valueOf` 方法得到的是对象类型，再自动调用对象的 `toString` 方法，将对象转为字符串。

```javascript
var obj = { p: 1 };
obj + 2 // "[object Object]2"
```

上面代码中，对象 `obj` 转成原始类型的值是 `[object Object]`，再加 `2` 就得到了上面的结果。

（1）首先，自动调用对象的 `valueOf` 方法。

```javascript
var obj = { p: 1 };
obj.valueOf() // { p: 1 }
```

（2）一般来说，对象的 `valueOf` 方法总是返回对象自身，这时再自动调用对象的 `toString` 方法，将其转为字符串。

```javascript
var obj = { p: 1 };
obj.valueOf().toString() // "[object Object]"
```

对象的 `toString` 方法默认返回 `[object Object]`，所以就得到了最前面那个例子的结果。

注意，如果 `valueOf` 方法返回的是原始类型的值，就不再调用 `toString` 方法，否则会调用 `toString` 方法，尝试将对象转为字符串。

知道了这个规则以后，就可以自己定义 `valueOf` 方法或 `toString` 方法，得到想要的结果。

```javascript
var obj = {
  valueOf: function () {
    return 1;
  }
};

obj + 2 // 3
```

上面代码中，我们定义 `obj` 对象的 `valueOf` 方法返回 `1`，于是 `obj + 2` 就得到了 `3`。这个例子中，由于 `valueOf` 方法直接返回一个原始类型的值，所以不再调用 `toString` 方法。

下面是自定义 `toString` 方法的例子。

```javascript
var obj = {
  toString: function () {
    return 'hello';
  }
};

obj + 2 // "hello2"
```

上面代码中，对象 obj 的 `toString` 方法返回字符串 `hello`。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。

这里有一个特例，如果运算子是一个 `Date` 对象的实例，那么会优先执行 `toString` 方法。

```javascript
var obj = new Date();
obj.valueOf = function () { return 1 };
obj.toString = function () { return 'hello' };

obj + 2 // "hello2"
```

上面代码中，对象 `obj` 是一个 `Date` 对象的实例，并且自定义了 `valueOf` 方法和 `toString` 方法，结果 `toString` 方法优先执行。

### 1.3 余数运算符

对于余数运算符（`%`）来说，运算结果的正负号由第一个运算子的正负号决定。

```javascript
-1 % 2 // -1
1 % -2 // 1
```

所以，为了得到负数的正确余数值，可以先使用绝对值函数。

```javascript
// 错误的写法
function isOdd(n) {
  return n % 2 === 1;
}
isOdd(-5) // false
isOdd(-4) // false

// 正确的写法
function isOdd(n) {
  return Math.abs(n % 2) === 1;
}
isOdd(-5) // true
isOdd(-4) // false
```

余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。

```javascript
6.5 % 2.1
// 0.19999999999999973
```

### 1.4 自增和自减运算符

对于自增和自减运算符，运算之后，变量的值发生变化，这种效应叫做运算的**副作用**（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。

自增和自减运算符放置的位置不同，会导致不同的行为。

- 如果放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。
- 如果放在变量之后，会先返回变量操作前的值，再进行自增/自减操作。

```javascript
var x = 1;
var y = 1;

x++ // 1
++y // 2
```

上面代码中，`x` 是先返回当前值，然后自增，所以得到 `1`；`y` 是先自增，然后返回新的值，所以得到 `2`。

### 1.5 数值运算符，负数值运算符

数值运算符（`+`）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。

数值运算符的作用在于可以将任何值转为数值（与 `Number` 函数的作用相同）。

```javascript
+true // 1
+[] // 0
+{} // NaN
```

上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行 `NaN` 也是数值）。

负数值运算符（`-`），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。

### 1.6 指数运算符

指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。

```javascript
2 ** 4 // 16
```

注意，指数运算符是**右结合**。即多个指数运算符连用时，先进行最右边的计算。

```javascript
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
```

上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。

## 二、比较运算符

### 2.1 概述

JavaScript 提供了 8 个比较运算符，他们是：`>`、`<`、`>=`、`<=`、`==`、`===`、`!=` 和 `!==`。

这八个比较运算符分成两类：相等比较和非相等比较。对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 `Unicode` 码点）；否则，将两个运算子都转成数值，再比较数值的大小。

### 2.2 非相等运算符：字符串的比较

字符串按照字典顺序进行比较。首先比较首字符的 `Unicode` 码点。如果相等，再比较第二个字符的 `Unicode` 码点，以此类推。

```javascript
'cat' > 'dog' // false
'cat' > 'Cat' // true' c 的 Unicode 码点是 99，C 的 Unicode 码点是 67
'大' > '小' // false “大”的 Unicode 码点是 22823，“小”是23567
```

### 2.3 非相等运算符：非字符串的比较

如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。

#### （1）原始类型值

如果两个运算子都是原始类型的值，则先转成数值再比较。

```javascript
5 > '4' // true
// 等同于 5 > Number('4')
// 即 5 > 4

true > false // true
// 等同于 Number(true) > Number(false)
// 即 1 > 0

2 > true // true
// 等同于 2 > Number(true)
// 即 2 > 1
```

任何值（包括 `NaN` 本身）与 `NaN` 使用非相等运算符进行比较，返回的都是 `false`。

```javascript
1 > NaN // false
1 <= NaN // false
'1' > NaN // false
'1' <= NaN // false
NaN > NaN // false
NaN <= NaN // false
```

#### （2）对象

如果运算子是对象，会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用 `valueOf` 方法；如果返回的还是对象，再接着调用 `toString` 方法。

```javascript
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'

x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 (function () { return '1' })() > '11'
// 即 '1' > '11'

[2] > [1] // true
// 等同于 [2].valueOf().toString() > [1].valueOf().toString()
// 即 '2' > '1'
```

### 2.4 严格相等运算符

- 相等运算符（`==`）比较两个值是否**相等**。如果两个值不是同一类型，相等运算符会将它们转换成同一个类型，再用严格相等运算符进行比较。
- 严格相等运算符（`===`）比较两个值是否为“**同一个值**”。如果两个值不是同一类型，严格相等运算符直接返回 `false`。

对于严格相等运算符：

- 如果两个值的类型不同，直接返回 `false`。
- 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回 `true`，值不同就返回 `false`。
- 复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向**同一个地址**。
- `undefined` 和 `null` 与自身严格相等。

### 2.5 严格不相等运算符

严格不相等运算符（`!==`）先求严格相等运算符的结果，然后取相反值。

### 2.6 相等运算符

相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。比较不同类型的数据时，相等运算符会先将数据进行**类型转换**，然后再用严格相等运算符比较。

- 原始类型的值会转换成数值再进行比较。

  ```javascript
  1 == true // true
  // 等同于 1 === Number(true)

  2 == false // false
  // 等同于 2 === Number(false)

  'true' == true // false
  // 等同于 Number('true') === Number(true)
  // 等同于 NaN === 1

  '' == 0 // true
  // 等同于 Number('') === 0
  // 等同于 0 === 0

  '' == false  // true
  // 等同于 Number('') === Number(false)
  // 等同于 0 === 0

  '1' == true  // true
  // 等同于 Number('1') === Number(true)
  // 等同于 1 === 1

  '\n  123  \t' == 123 // true
  // 因为字符串转为数字时，省略前置和后置的空格
  ```

- 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。先调用对象的 `valueOf()` 方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用 `toString()` 方法，得到字符串形式，再进行比较。

  ```javascript
  // 数组与数值的比较
  [1] == 1 // true

  // 数组与字符串的比较
  [1] == '1' // true
  [1, 2] == '1,2' // true

  // 对象与布尔值的比较
  [1] == true // true
  [2] == true // false
  ```

- `undefined` 和 `null` 只有与自身比较，或者互相比较时，才会返回 `true`；与其他类型的值比较时，结果都为 `false`。

  ```javascript
  undefined == undefined // true
  null == null // true
  undefined == null // true
  ```

- 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。

  ```javascript
  0 == ''             // true
  0 == '0'            // true

  2 == true           // false
  2 == false          // false

  false == 'false'    // false
  false == '0'        // true

  false == undefined  // false
  false == null       // false
  null == undefined   // true

  ' \t\r\n ' == 0     // true
  ```

建议不要使用相等运算符（`==`），最好只使用严格相等运算符（`===`）。

### 2.7 不相等运算符

不相等运算符（`!=`）先求相等运算符的结果，然后取相反值。

## 三、布尔运算符

### 3.1 概述

布尔运算符用于将表达式转为布尔值，共包含四个运算符：`!`（取反运算符）、`&&`（且运算符）、`||`（或运算符）和 `?:`（三元运算符）。

### 3.2 取反运算符（!）

- `undefined`、`null`、`false`、`0`、`NaN` 和空字符串（`''`）取反后为 `true`，其他值都为 `false`。
- 对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 `Boolean()` 函数的作用相同。这是一种常用的类型转换的写法。

  ```javascript
  !!x
  // 等同于
  Boolean(x)
  ```

### 3.3 且运算符（&&）

且运算符（`&&`）的运算规则是：如果第一个运算子的布尔值为 `true`，则返回第二个运算子的**值**（注意是值，不是布尔值）；如果第一个运算子的布尔值为 `false`，则直接返回第一个运算子的**值**，且不再对第二个运算子求值。

```javascript
't' && '' // ""
't' && 'f' // "f"
'' && 'f' // ""
```

这种跳过第二个运算子的机制，被称为“**短路**”。有时候可以用它取代 if 结构。

```javascript
if (i) {
  doSomething();
}

// 等价于
i && doSomething();
```

且运算符可以多个连用，这时返回第一个布尔值为 `false` 的表达式的值。如果所有表达式的布尔值都为 `true`，则返回最后一个表达式的值。

```javascript
true && 'foo' && '' && 4 && 'foo' && true
// ''

1 && 2 && 3
// 3
```

### 3.4 或运算符（||）

或运算符（`||`）的运算规则是：如果第一个运算子的布尔值为 `true`，则返回第一个运算子的**值**，且不再对第二个运算子求值；如果第一个运算子的布尔值为 `false`，则返回第二个运算子的**值**。

```javascript
't' || '' // "t"
't' || 'f' // "t"
'' || 'f' // "f"
'' || '' // ""
```

或运算符可以多个连用，这时返回第一个布尔值为 `true` 的表达式的值。如果所有表达式都为 `false`，则返回最后一个表达式的值。

```javascript
false || 0 || '' || 4 || 'foo' || true
// 4

false || 0 || ''
// ''
```

## 四、二进制位运算符

## 五、其他运算符，运算顺序

