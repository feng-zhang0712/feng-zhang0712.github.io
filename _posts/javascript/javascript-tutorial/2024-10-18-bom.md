---
layout: post
title: 《JavaScript 教程 - 浏览器模型》摘录
categories: blog
tags:
  - JavaScript
  - BOM
---

> 本文是对[《JavaScript 教程 - 浏览器模型》](https://wangdoc.com/javascript/bom/)一章中部分知识点的摘录，请访问原文，获取更多详细信息。

## 一、浏览器模型概述

### 1.1 代码嵌入网页的方法

网页中嵌入 JavaScript 代码，主要有四种方法。

- `<script>` 元素直接嵌入代码。

  `<script>` 标签的 `type` 属性用来指定脚本类型。`type` 属性可以设为两种值。

  - `text/javascript`：这是**默认值**，也是历史上一贯设定的值。如果你省略 `type` 属性，默认就是这个值。对于老式浏览器，设为这个值比较好。
  - `application/javascript`：对于较新的浏览器，建议设为这个值。

  **如果 `type` 属性的值，浏览器不认识，那么它不会执行其中的代码**。利用这一点，可以在 `<script>` 标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的 `type` 属性即可。

- `<script>` 标签加载外部脚本。

  `<script>` 标签通过 `src` 属性加载外部脚本。为了防止攻击者篡改外部脚本，`script` 标签允许设置一个 `integrity` 属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。

  ```html
  <script src="https://www.example.com/script.js"
    integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=">
  </script>
  ```

- 事件属性：网页元素的事件属性（比如 `onclick`），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。

  ```html
  <button id="myBtn" onclick="console.log(this.id)">点击</button>
  ```

- URL 协议：URL 支持 `javascript:` 协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。

  ```html
  <a href="javascript:console.log('Hello')">点击</a>
  ```

  `javascript:` 协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以 `javascript:` 网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上 `void`，或者在脚本最后加上 `void 0`。

  ```html
  <a href="javascript: void new Date().toLocaleTimeString();">点击</a>
  <a href="javascript: new Date().toLocaleTimeString();void 0;">点击</a>
  ```

  上面这两种写法，点击链接后，执行代码都不会网页跳转。

### 1.2 script 元素

#### （1）工作原理

正常的网页加载流程是这样的。

1. 对于 HTML 网页，浏览器边下载边解析。
2. 解析过程中，浏览器发现 `<script>` 元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。
3. 如果 `<script>` 元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。
4. JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。

**加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染**。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。

如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“**假死**”状态，这被称为“**阻塞效应**”。

为了避免这种情况，较好的做法是将 `<script>` 标签都放在页面底部，而不是头部。这样做有几个好处。

- 即使遇到脚本失去响应，网页主体的渲染也已经完成，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。
- 避免因 DOM 结构生成之前调用 DOM 节点而导致的 JavaScript 报错，因为这时 DOM 已经生成了。

```html
<head>
  <script>
    console.log(document.body.innerHTML);
  </script>
</head>
<body>
</body>
```

上面代码执行时会报错，因为此时 `document.body` 元素还未生成。有几种方式可以解决这个问题。

- 设定 `DOMContentLoaded` 事件的回调函数。
- 使用 `<script>` 标签的 `onload` 属性。
- 将脚本放在页面底部。

如果有多个 `script` 标签，比如下面这样。

```html
<script src="a.js"></script>
<script src="b.js"></script>
```

浏览器会同时**并行**下载 `a.js` 和 `b.js`，但是，执行时会保证先执行 `a.js`，然后再执行 `b.js`，即使后者先下载完成，也是如此。也就是说，**脚本的执行顺序由它们在页面中的出现顺序决定**，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。

**解析和执行 CSS，也会产生阻塞**。

此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载 6～20 个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。

#### （2）defer 属性

`defer` 属性可以延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。`defer` 属性的运行流程如下。

1. 浏览器开始解析 HTML 网页。
2. 解析过程中，发现带有 `defer` 属性的 `<script>` 元素。
3. 浏览器继续往下解析 HTML 网页，同时并行下载 `<script>` 元素加载的外部脚本。
4. 浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。

有了 `defer` 属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在 `DOMContentLoaded` 事件触发前执行（即刚刚读取完 `</html>` 标签），而且可以保证执行顺序就是它们在页面上出现的顺序。

- 对于内置而不是加载外部脚本的 `script` 标签，以及动态生成的 `script` 标签，`defer` 属性不起作用。
- 使用 `defer` 加载的外部脚本不应该使用 `document.write` 方法。

#### （3）async 属性

`async` 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。

1. 浏览器开始解析 HTML 网页。
2. 解析过程中，发现带有 `async` 属性的 `script` 标签。
3. 浏览器继续往下解析 HTML 网页，同时并行下载 `<script>` 标签中的外部脚本。
4. 脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。
5. 脚本执行完毕，浏览器恢复解析 HTML 网页。

`async` 属性可以保证脚本下载的同时，浏览器继续渲染。

- 一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。
- 使用 `async` 属性的脚本文件里面的代码，不应该使用 `document.write` 方法。

一般来说，如果脚本之间没有依赖关系，就使用 `async` 属性，如果脚本之间有依赖关系，就使用 `defer` 属性。如果同时使用 `async` 和 `defer` 属性，后者不起作用，浏览器行为由 `async` 属性决定。

#### （4）脚本的动态加载

`<script>` 元素还可以动态生成，这种方法的好处是，**动态生成的 `script` 标签不会阻塞页面渲染，也就不会造成浏览器假死**。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。可以通过设置 `async` 属性为 `false` 解决这个问题。

```javascript
['a.js', 'b.js'].forEach(function(src) {
  var script = document.createElement('script');
  script.src = src;
  script.async = false;
  document.head.appendChild(script);
});
```

#### （5）加载使用的协议

如果不指定协议，浏览器默认采用 HTTP 协议下载。如果要采用 HTTPS 协议下载，必需写明。但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。

```html
<script src="//example.js"></script>
```

### 1.3 浏览器的组成

浏览器的核心是两部分：**渲染引擎**和 **JavaScript 解释器**（又称 JavaScript 引擎）。

#### （1）渲染引擎

渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。

渲染引擎处理网页，通常分成四个阶段。

1. 解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。
2. 对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。
3. 布局：计算出渲染树的布局（layout）。
4. 绘制：将渲染树绘制到屏幕。

以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。

#### （2）重流和重绘

渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。

页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（`a:hover`）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。

重流和重绘并不一定一起发生，**重流必然导致重绘，重绘不一定需要重流**。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。

作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘 `table` 布局和 `flex` 布局，开销都会比较大。

下面是一些优化技巧。

- 读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。
- 缓存 DOM 信息。
- 不要一项一项地改变样式，而是使用 CSS `class` 一次性改变样式。
- 使用 `documentFragment` 操作 DOM
- 动画使用 `absolute` 定位或 `fixed` 定位，这样可以减少对其他元素的影响。
- 只在必要时才显示隐藏元素。
- 使用 `window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。
- 使用虚拟 DOM（virtual DOM）库。

#### （3）JavaScript 引擎

JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。

JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。

为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。

早期，浏览器内部对 JavaScript 的处理过程如下：

1. 读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。
2. 对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。
3. 使用“翻译器”（translator），将代码转为字节码（bytecode）。
4. 使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。

逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。

字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。

## 二、window 对象

### 2.1 概述

浏览器里面，`window` 对象指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。

### 2.2 window 对象的属性

#### （1）通用属性

- `window.name` 字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的 `target` 属性使用。
- `window.closed` 布尔值，表示窗口是否关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。

  ```javascript
  var popup = window.open();
  if ((popup !== null) && !popup.closed) {
    // 窗口仍然打开着
  }
  ```

- `window.opener` 属性表示打开当前窗口的**父窗口**。通过 `opener` 属性，可以获得父窗口的全局属性和方法，但只限于两个窗口**同源**的情况，且其中一个窗口由另一个打开。`<a>` 元素添加 `rel="noopener"` 属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。

  ```html
  <a href="https://an.evil.site" target="_blank" rel="noopener">
  恶意网站
  </a>
  ```

  如果两个窗口之间不需要通信，建议将子窗口的 `opener` 属性显式设为 `null`，这样可以减少一些安全隐患。

  ```javascript
  var newWin = window.open('example.html', 'newWindow', 'height=400,width=400');
  newWin.opener = null;
  ```

- `window.self` 和 `window.window` 属性都指向窗口（`window`）本身。这两个属性只读。
- `window.frames` 属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括 `frame` 元素和 `iframe` 元素。

  `window.frames[0]` 表示页面中第一个框架窗口。如果 `iframe` 元素设置了 `id` 或 `name` 属性，那么就可以用属性值，引用这个 `iframe` 窗口。比如 `<iframe name="myIFrame">` 可以用 `frames['myIFrame']` 或者 `frames.myIFrame` 来引用。

  `frames` 属性实际上是 `window` 对象的别名。

  ```javascript
  frames === window // true
  ```

  因此，`frames[0]` 也可以用 `window[0]` 表示。但是，从语义上看，`frames` 更清晰，而且考虑到 `window` 还是全局对象，因此推荐表示多窗口时，总是使用 `frames[0]` 的写法。

- `window.length` 属性返回当前网页包含的框架总数。如果当前网页不包含 `frame` 和 `iframe` 元素，那么 `window.length` 就返回 0。
- `window.frameElement` 属性主要用于当前窗口嵌在另一个网页的情况（嵌入 `<object>`、`<iframe>` 或 `<embed>` 元素），返回当前窗口所在的那个元素节点。

  ```javascript
  // HTML 代码如下
  // <iframe src="about.html"></iframe>

  // 下面的脚本在 about.html 里面
  var frameEl = window.frameElement;
  if (frameEl) {
    frameEl.src = 'other.html';
  }
  ```

  上面代码中，`frameEl` 变量就是 `<iframe>` 元素。

- `window.top` 属性指向**最顶层窗口**，主要用于在框架窗口（`frame`）里面获取顶层窗口。
- `window.parent` 属性指向**父窗口**。如果当前窗口没有父窗口，`window.parent` 指向自身。
- `window.status` 属性用于读写浏览器状态栏的文本。很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。
- `window.devicePixelRatio` 属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。它表示一个 CSS 像素由多少个物理像素组成。

#### （2）位置大小属性

- `window.screenX` 和 `window.screenY` 属性：返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。
- `window.innerHeight` 和 `window.innerWidth` 属性：返回**网页在当前窗口中可见部分的**高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。

  用户放大网页的时候（比如将网页从 100% 的大小放大为 200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是 960px），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。注意，这两个属性值包括滚动条的高度和宽度。

- `window.outerHeight` 和 `window.outerWidth` 属性：返回**浏览器窗口的高度和宽度**，包括浏览器菜单和边框（单位像素）。这两个属性只读。
- `window.scrollX` 和 `window.scrollY` 属性返回页面的水平/垂直滚动距离，单位都为像素。这两个属性只读。
- `window.pageXOffset` 和 `window.pageYOffset` 属性是 `window.scrollX` 和 `window.scrollY` 别名。

#### （3）组件属性

组件属性返回浏览器的组件对象。这样的属性有下面几个。

- `window.menubar`：菜单栏对象
- `window.toolbar`：工具栏对象
- `window.locationbar`：地址栏对象
- `window.scrollbars`：窗口的滚动条对象
- `window.statusbar`：状态栏对象
- `window.personalbar`：用户安装的个人工具栏对象

这些对象的 `visible` 属性是一个布尔值，表示这些组件是否可见。这些属性只读。

#### （4）全局对象属性

全局对象属性指向一些浏览器原生的全局对象。

- `window.document`：指向 `document` 对象。注意，这个属性有同源限制。只有来自**同源**的脚本才能读取这个属性。
- `window.location`：指向 `Location` 对象，用于获取当前窗口的 URL 信息。它等同于 `document.location` 属性。
- `window.navigator`：指向 `Navigator` 对象，用于获取**环境信息**。
- `window.history`：指向 `History` 对象，表示浏览器的浏览历史。
- `window.localStorage`：指向本地储存的 `localStorage` 数据。
- `window.sessionStorage`：指向本地储存的 `sessionStorage` 数据。
- `window.console`：指向 `console` 对象，用于操作控制台。
- `window.screen`：指向 `Screen` 对象，表示屏幕信息。

#### （5）window.isSecureContext

`window.isSecureContext` 布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是 `true`，否则就是 `false`。

### 2.3 window 对象的方法

#### （1）window.alert()，window.confirm()，window.prompt()

`window.alert()`、`window.confirm()`、`window.prompt()` 都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。

- `window.alert(message)` 方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。无返回值。
- `window.confirm(message)` 方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。返回一个布尔值，表示是否选择了确定（`true`）还是取消（`false`）。
- `window.prompt(message, defaultValue)` 方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。返回一个包含用户输入文本的字符串，或 `null`。

#### （2）window.open(), window.close()，window.stop()

- `window.open(url, target, [windowFeatures])` 方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用。

  - `url`：字符串，表示新窗口的网址。如果省略，默认网址就是 `about:blank`。
  - `target`：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用 `_blank`，表示新建一个没有名字的窗口。另外还有几个预设值，`_self` 表示当前窗口，`_top` 表示顶层窗口，`_parent` 表示上一层窗口。
  - `windowFeatures`：字符串，内容为逗号分隔的键值对，表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。关于此参数支持的配置项，请参考 [windowfeatures 属性](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open#windowfeatures)。

- `window.close()` 方法用于关闭当前窗口，一般只用来关闭 `window.open` 方法新建的窗口。该方法只对顶层窗口有效，`iframe` 框架之中的窗口使用该方法无效。
- `window.stop()` 方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。

#### （3）window.moveTo()，window.moveBy()

- `window.moveTo(x, y)` 方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。
- `window.moveBy(deltaX, deltaY)` 方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。

为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用 `window.open()` 方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。

#### （4）window.resizeTo()，window.resizeBy()

- `window.resizeTo(aWidth, aHeight)` 方法用于缩放窗口到指定大小。它接受两个参数，第一个是缩放后的窗口宽度（`aWidth` 属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（`aHeight` 属性）。
- `window.resizeBy(xDelta, yDelta)` 方法用于缩放窗口。它与 `window.resizeTo()` 的区别是，它按照相对的量缩放，`window.resizeTo()` 需要给出缩放后的绝对大小。它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。

#### （5）window.scrollTo()，window.scroll()，window.scrollBy()

- `window.scrollTo(x-coord, y-coord)` | `window.scrollTo(options)` 方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。它也可以接受一个配置对象作为参数，配置对象 `options` 有三个属性。

  - `top`：滚动后页面左上角的垂直坐标，即 `y` 坐标。
  - `left`：滚动后页面左上角的水平坐标，即 `x` 坐标。
  - `behavior`：字符串，表示滚动的方式，有三个可能值（`smooth`、`instant`、`auto`），默认值为 `auto`。

- `window.scrollBy(x-coord, y-coord)` | `window.scrollBy(options)` 方法用于将网页滚动指定距离（单位像素）。
- `window.scroll(x-coord, y-coord)` | `window.scroll(options)` 方法是 `window.scrollTo()` 方法的别名。

如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。

- `Element.scrollTop`
- `Element.scrollLeft`
- `Element.scrollIntoView()`

#### （6）window.print()

`window.print()` 方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。

#### （7）window.focus()，window.blur()

- `window.focus()` 方法会激活窗口，使其获得焦点，出现在其他窗口的前面。
- `window.blur()` 方法将焦点从窗口移除。

#### （8）window.getSelection()

`window.getSelection()` 方法返回一个 `Selection` 对象，表示用户现在选中的文本。使用 `Selection` 对象的 `toString()` 方法可以得到选中的文本。

```javascript
var selObj = window.getSelection();
var selectedText = selObj.toString();
```

#### （9）window.getComputedStyle()，window.matchMedia()

- `window.getComputedStyle(element, pseudoElt)` 方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象。
- `window.matchMedia(mediaQueryString)` 方法用来检查 CSS 的 `mediaQuery` 语句。

#### （10）window.requestAnimationFrame()

`window.requestAnimationFrame(callback)` 可以在浏览器下一次重绘之前，执行用户提供的回调函数。重绘通常是 16ms（如果屏幕刷新率是 60FPS） 执行一次，浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，`requestAnimationFrame()` 会暂停执行。

如果某个函数会改变网页的布局，一般就放在 `window.requestAnimationFrame()` 里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。

```javascript
window.requestAnimationFrame(callback)
```

上面代码中，`callback` 是一个回调函数。`callback` 执行时，它的参数就是系统传入的一个高精度时间戳（`performance.now()` 的返回值），单位是毫秒，表示距离网页加载的时间。

`window.requestAnimationFrame()` 接受一个回调函数作为参数，返回值是一个整数，这个整数可以传入 `window.cancelAnimationFrame()`，用来取消回调函数的执行。

```javascript
var element = document.getElementById('animate');
element.style.position = 'absolute';

var start = null;

function step(timestamp) {
  if (!start) start = timestamp;
  var progress = timestamp - start;
  // 元素不断向右移，最大不超过200像素
  element.style.left = Math.min(progress / 10, 200) + 'px';
  // 如果距离第一次执行不超过 2000 毫秒，
  // 就继续执行动画
  if (progress < 2000) {
    window.requestAnimationFrame(step);
  }
}

window.requestAnimationFrame(step);
```

上面代码定义了一个网页动画，持续时间是 2 秒，会让元素向右移动。

#### （11）window.requestIdleCallback()

`window.requestIdleCallback(callback, options)` 能够保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用 `window.requestIdleCallback()` 将其推迟执行，以保证网页性能。

它跟 `window.requestAnimationFrame()` 的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在 16ms 之内完成；`window.requestIdleCallback()` 可以保证回调函数在系统资源空闲时执行。

该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。

```javascript
window.requestIdleCallback(callback[, options])
```

- `callback` 参数是一个回调函数。该回调函数执行时，系统会传入一个 `IdleDeadline` 对象作为参数。`IdleDeadline` 对象有一个属性和一个方法。
  - `didTimeout` 属性（布尔值，表示是否为超时调用）。
  - `timeRemaining()` 方法（返回该空闲时段剩余的毫秒数）。
- `options` 参数是一个配置对象，目前只有 `timeout` 一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。

`window.requestIdleCallback()` 方法返回一个整数。该整数可以传入 `window.cancelIdleCallback()` 取消回调函数。

```javascript
requestIdleCallback(function (deadline) {
  while (deadline.timeRemaining() > 0) {
    doWorkIfNeeded();
  }
});
```

如果由于超时导致回调函数执行，则 `deadline.timeRemaining()` 返回 `0`，`deadline.didTimeout` 返回 `true`。

如果多次执行 `window.requestIdleCallback()`，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。

### 2.4 事件

#### （1）load 事件和 onload 属性

`load` 事件发生在文档在浏览器窗口加载完毕时。`window.onload` 属性可以指定这个事件的回调函数。

#### （2）error 事件和 onerror 属性

`error` 事件发生在浏览器脚本发生错误时，`window.onerror` 属性可以指定该事件的回调函数。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。

#### （3）window 对象的事件监听属性

除了具备元素节点都有的 GlobalEventHandlers 接口，`window` 对象还具有以下的事件监听函数属性。

- `window.onbeforeprint`：`beforeprint` 事件的监听函数。
- `window.onafterprint`：`afterprint`事件的监听函数。
- `window.onbeforeunload`：`beforeunload` 事件的监听函数。
- `window.onunload`：`unload` 事件的监听函数。
- `window.onhashchange`：`hashchange` 事件的监听函数。
- `window.onlanguagechange`: `languagechange` 的监听函数。
- `window.onmessage`：`message` 事件的监听函数。
- `window.onmessageerror`：`MessageError` 事件的监听函数。
- `window.ononline`：`online` 事件的监听函数。
- `window.onoffline`：`offline` 事件的监听函数。
- `window.onpageshow`：`pageshow` 事件的监听函数。
- `window.onpagehide`：`pagehide` 事件的监听函数。
- `window.onpopstate`：`popstate` 事件的监听函数。
- `window.onstorage`：`storage` 事件的监听函数。
- `window.onunhandledrejection`：未处理的 `Promise` 对象的 `reject` 事件的监听函数。

### 2.5 多窗口操作

#### （1）窗口的引用

各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。

- `top`：顶层窗口，即最上层的那个窗口
- `parent`：父窗口
- `self`：当前窗口，即自身

与这些变量对应，浏览器还提供一些特殊的窗口名，供 `window.open()` 方法、`<a>` 标签、`<form>` 标签等引用。

- `_top`：顶层窗口
- `_parent`：父窗口
- `_blank`：新窗口

```javascript
<a href="somepage.html" target="_top">Link</a>
```

上面代码就表示在顶层窗口打开链接。

#### （2）iframe 元素

- `<iframe>` 元素的 `contentWindow` 属性，可以获得 `iframe` 节点包含的 `window` 对象。
- `<iframe>` 元素的 `contentDocument` 属性，可以拿到子窗口的 `document` 对象。
- `<iframe>` 元素遵守**同源策略**，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用 `window.postMessage` 方法。
- `<iframe>` 窗口内部，使用 `window.parent` 引用父窗口。如果当前页面没有父窗口，则 `window.parent` 属性返回自身。因此，可以通过 `window.parent` 是否等于 `window.self`，判断当前窗口是否为 `iframe` 窗口。

```javascript
if (window.parent !== window.self) {
  // 当前窗口是子窗口
}
```

#### （3）window.frames 属性

`window.frames` 属性返回一个类似数组的对象，成员是所有子窗口的 `window` 对象。可以使用这个属性，实现窗口之间的互相引用。比如，`frames[0]` 返回第一个子窗口，`frames[1].frames[2]`返 回第二个子窗口内部的第三个子窗口。

注意，`window.frames` 每个成员的值，是框架内的窗口（即框架的 `window` 对象），而不是 `iframe` 标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用 `window.frames[0].document` 的写法。

另外，如果 `<iframe>` 元素设置了 `name` 或 `id` 属性，那么属性值会自动成为全局变量，并且可以通过 `window.frames` 属性引用，返回子窗口的 `window` 对象。

## 三、Navigator 对象，Screen 对象

`window.navigator` 属性指向一个包含浏览器和系统信息的 Navigator 对象。脚本通过这个属性了解用户的环境信息。

### 3.1 Navigator 对象的属性

- `navigator.userAgent` 属性返回浏览器的 User Agent 字符串，表示用户**设备信息**，包含了浏览器的厂商、版本、操作系统等信息。

  下面是 Chrome 浏览器的 userAgent。

  ```javascript
  navigator.userAgent
  // "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36"
  ```

  通过 `userAgent` 属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。不过，通过 `userAgent` 可以大致准确地识别手机浏览器，方法就是测试是否包含 `mobi` 字符串。

- `Navigator.plugins` 属性返回一个类似数组的对象，成员是 Plugin 实例对象，表示浏览器安装的插件，比如 Flash、ActiveX 等。
- `Navigator.platform` 属性返回用户的操作系统信息，比如 MacIntel、Win32、Linux x86_64 等。
- `Navigator.onLine` 属性返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。用户变成在线会触发 `online` 事件，变成离线会触发 `offline` 事件，可以通过 `window.ononline` 和 `window.onoffline` 指定这两个事件的回调函数。
- `Navigator.language` 属性返回一个字符串，表示浏览器的首选语言。该属性只读。
- `Navigator.languages` 属性返回一个数组，表示用户可以接受的语言。`Navigator.language` 总是这个数组的第一个成员。HTTP 请求头信息的 Accept-Language 字段，就来自这个数组。
- `Navigator.geolocation` 属性返回一个 Geolocation 对象，包含用户地理位置的信息。注意，该 API 只有在 HTTPS 协议下可用。
  
  Geolocation 对象提供下面三个方法。

  - `Geolocation.getCurrentPosition()`：得到用户的当前位置
  - `Geolocation.watchPosition()`：监听用户位置变化
  - `Geolocation.clearWatch()`：取消 `watchPosition()` 方法指定的监听函数

- `Navigator.cookieEnabled` 属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。注意，这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关。

### 3.2 Navigator 对象的方法

- `Navigator.javaEnabled()` 布尔值，表示浏览器是否能运行 Java Applet 小程序。注意，该方法目前[已弃用](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/javaEnabled)。
- `Navigator.sendBeacon(url, data)` 方法用于向服务器异步发送数据。

### 3.3 Screen 对象

Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。`window.screen` 属性指向这个对象。

- `Screen.height`：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。
- `Screen.width`：浏览器窗口所在的屏幕的宽度（单位像素）。
- `Screen.availHeight`：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于 `height` 减去那些被系统组件的高度。
- `Screen.availWidth`：浏览器窗口可用的屏幕宽度（单位像素）。
- `Screen.pixelDepth`：整数，表示屏幕的色彩位数，比如 24 表示屏幕提供 24 位色彩。
- `Screen.colorDepth`：`Screen.pixelDepth` 的别名。严格地说，`colorDepth` 表示应用程序的颜色深度，`pixelDepth` 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。
- `Screen.orientation`：返回一个对象，表示屏幕的方向。该对象的 `type` 属性是一个字符串，表示屏幕的具体方向。
  - `landscape-primary` 表示横放。
  - `landscape-secondary` 表示颠倒的横放。
  - `portrait-primary` 表示竖放。
  - `portrait-secondary` 表示颠倒的竖放。

## 四、Cookie

### 1. 概述

**Cookie 是服务器保存在浏览器的一小段文本信息**，一般大小不能超过 4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。

HTTP 协议不带有状态，有些请求需要区分状态，就通过 Cookie 附带字符串，让服务器返回不一样的回应。举例来说，用户登录以后，服务器往往会在网站上留下一个 Cookie，记录用户编号（比如 `id=1234`），以后每次浏览器向服务器请求数据，就会带上这个字符串，服务器从而知道是谁在请求，应该回应什么内容。

**Cookie 的目的就是区分用户，以及放置状态信息**，它的使用场景主要如下。

- 对话（session）管理：保存登录状态、购物车等需要记录的信息。
- 个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。
- 追踪用户：记录和分析用户行为。

Cookie 不是一种理想的客户端存储机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端存储建议使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。

每个 Cookie 都有以下几方面的元数据。

- 所属域名（默认为当前域名）
- 生效的路径（默认为当前网址）
- Cookie 的名字
- Cookie 的值（真正的数据写在这里面）
- 到期时间（超过这个时间会失效）

举例来说，用户访问网址 `www.example.com`，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为 `www.example.com`，生效路径为根路径 `/`。

如果 Cookie 的生效路径设为 `/forums`，那么这个 Cookie 只有在访问 `www.example.com/forums` 及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。

`window.navigator.cookieEnabled` 布尔值，表示浏览器是否打开 Cookie 功能。`document.cookie` 属性返回当前网页的 Cookie。

```javascript
window.navigator.cookieEnabled // true
document.cookie // "id=foo;key=bar"
```

- 一般来说，单个域名设置的 Cookie 不应超过 **30** 个，每个 Cookie 的大小不能超过 **4KB**。超过限制以后，Cookie 将被忽略，不会被设置。
- Cookie 是按照**域名**区分的，`foo.com` 只能读取自己放置的 Cookie，无法读取其他网站（比如 `bar.com`）放置的 Cookie。一般情况下，一级域名也不能读取二级域名留下的 Cookie，比如 `mydomain.com` 不能读取 `subdomain.mydomain.com` 设置的 Cookie。但是有一个例外，设置 Cookie 的时候（不管是一级域名设置的，还是二级域名设置的），明确将 `domain` 属性设为一级域名，则这个域名下面的各级域名可以共享这个 Cookie。
- 区分 Cookie 时不考虑协议和端口。

### 2. Cookie 与 HTTP 协议

#### 2.1 HTTP 回应：Cookie 的生成

服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个 `Set-Cookie` 字段。HTTP 回应可以包含多个 `Set-Cookie` 字段，即在浏览器生成多个 Cookie。

```http
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

除了 Cookie 的值，`Set-Cookie` 字段还可以附加 Cookie 的属性。

```http
Set-Cookie: <cookie-name>=<cookie-value>; Expires=<date>
Set-Cookie: <cookie-name>=<cookie-value>; Max-Age=<non-zero-digit>
Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>
Set-Cookie: <cookie-name>=<cookie-value>; Path=<path-value>
Set-Cookie: <cookie-name>=<cookie-value>; Secure
Set-Cookie: <cookie-name>=<cookie-value>; HttpOnly
```

一个 `Set-Cookie` 字段里面，可以同时包括多个属性，没有次序的要求。

```http
Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>; Secure; HttpOnly
```

如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的 `domain`、`path`、`key` 和 `secure` 都匹配。只要有一个属性不同，就会生成一个全新的 Cookie。

```http
Set-Cookie: key1=value1; domain=example.com; path=/blog
```

#### 2.2 HTTP 请求：Cookie 的发送

浏览器向服务器发送 HTTP 请求时，可以带上相应的 Cookie。`Cookie` 字段可以包含多个 Cookie，使用分号（`;`）分隔。

```http
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。

- Cookie 的各种属性，比如何时过期。
- 哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。

### 3. Cookie 的属性

#### 3.1 Expires，Max-Age

- `Expires` 属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用 `Date.prototype.toUTCString()` 进行格式转换。如果不设置该属性，或者设为 `null`，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据**本地时间**，决定 Cookie 是否过期，而本地时间是不精确的。
- `Max-Age` 属性指定从现在开始 Cookie 存在的秒数，比如 `60 * 60 * 24 * 365`（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。

如果同时指定了 `Expires` 和 `Max-Age`，那么 `Max-Age` 的值将优先生效。

#### 3.2 Domain，Path

- `Domain` 属性指定 Cookie 属于哪个域名，以后浏览器向服务器发送 HTTP 请求时，通过这个属性判断是否要附带某个 Cookie。

  `Domain` 属性只能是当前域名或者当前域名的上级域名，但设为上级域名时，**不能设为顶级域名或公共域名**。举例来说，当前域名为 `x.y.z.com`，那么 `Domain` 属性可以设为 `x.y.z.com`，或者 `y.z.com`，或者 `z.com`，但不能设为 `foo.x.y.z.com`，或者 `another.domain.com`。另一个例子是，当前域名为 `wangdoc.github.io`，则 `Domain` 属性只能设为 `wangdoc.github.io`，不能设为 `github.io`，因为后者是一个公共域名。

- `Path` 属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。

#### 3.3 Secure，HttpOnly

- `Secure` 属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。
- `HttpOnly` 属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是 `document.cookie` 属性、`XMLHttpRequest` 对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。

#### 3.4 SameSite

Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 **CSRF 攻击**。

这种第三方网站引导而附带发送的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。比如，Facebook 在第三方网站插入一张看不见的图片。

```html
<img src="facebook.com" style="visibility:hidden;">
```

浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。

Cookie 的 `SameSite` 属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值：`Strict`、`Lax` 和 `None`。

##### （1）Strict

`Strict` 最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。只有当前网页的 URL 与请求目标一致，才会带上 Cookie。这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。

```http
Set-Cookie: CookieName=CookieValue; SameSite=Strict;
```

##### （2）Lax

`Lax` 规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

```http
Set-Cookie: CookieName=CookieValue; SameSite=Lax;
```

导航到目标网址的 GET 请求，只包括三种情况：链接、预加载请求、GET 表单。设置了 `Strict` 或 `Lax` 以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 `SameSite` 属性。

| 请求类型 | 正常情况 | Lax | 示例 |
| :-: | :-: | :-: | :-: |
| 链接 | 发送 Cookie | 发送 Cookie | `<a href="..."></a>` |
| 预加载 | 发送 Cookie | 发送 Cookie | `<link rel="prerender" href="..."/>` |
| GET 表单 | 发送 Cookie | 发送 Cookie | `<form method="GET" action="...">` |
| POST 表单 | 发送 Cookie | 不发送 | `<form method="POST" action="...">` |
| iframe | 发送 Cookie | 不发送 | `<iframe src="..."></iframe>` |
| AJAX | 发送 Cookie | 不发送 | `$.get("...")` |
| Image | 发送 Cookie | 不发送 | `<img src="...">` |

##### （3）None

网站可以选择显式关闭 `SameSite` 属性，将其设为 `None`。不过，前提是必须同时设置 `Secure` 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

### 4. document.cookie

`document.cookie` 属性用于读写当前网页的 Cookie。

- `document.cookie` 属性读取的时候，会返回当前网页的所有 Cookie，前提是该 Cookie 不能有 `HTTPOnly` 属性。
- `document.cookie` 一次只能写入一个 Cookie，而且写入并不是覆盖，而是**添加**。写入的时候，Cookie 的值必须写成 `key=value` 的形式。写入的时候必须对分号、逗号和空格进行转义，可以用 `encodeURIComponent` 方法达到。
- 浏览器向服务器发送 Cookie 的时候，`Cookie` 字段是使用一行将所有 Cookie 全部发送；服务器向浏览器设置 Cookie 的时候，`Set-Cookie` 字段是一行设置一个 Cookie。
- 删除一个现存 Cookie 的唯一方法，是设置它的 `expires` 属性为一个过去的日期。

写入 Cookie 的时候，可以一起写入 Cookie 的属性。

```http
document.cookie = "foo=bar; expires=Fri, 31 Dec 2020 23:59:59 GMT";
```

各个属性的写入注意点如下。

- `path` 属性必须为绝对路径，默认为当前路径。
- `domain` 属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是 `example.com`，就不能将其设为 `foo.com`。该属性默认为当前的一级域名（不含二级域名）。如果显式设置该属性，则该域名的任意子域名也可以读取 Cookie。
- `max-age` 属性的值为秒数。
- `expires` 属性的值为 UTC 格式，可以使用 `Date.prototype.toUTCString()` 进行日期格式转换。

`document.cookie` 写入 Cookie 的例子如下。

```http
document.cookie = 'fontSize=14; '
  + 'expires=' + someDate.toGMTString() + '; '
  + 'path=/subdirectory; '
  + 'domain=example.com';
```

## 五、XMLHttpRequest 对象

### 5.1 简介

AJAX 是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。AJAX 指通过 JavaScript 脚本发起 HTTP 通信。

XMLHttpRequest 对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。它实可以使用多种协议（比如 `file` 或 `ftp`），发送任何格式的数据（包括字符串和二进制）。

```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function () {
  // ...
}
xhr.onerror = function (e) {
  console.error(xhr.statusText);
};
// 第三个参数 true，表示请求是异步的。
xhr.open('GET', 'http://www.example.com/page.php', true);
// 使用 send() 方法，实际发出请求。
xhr.send(null);
```

注意，AJAX 只能向**同源**网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错。

### 5.2 XMLHttpRequest 的实例属性

#### （1）XMLHttpRequest.readyState

`XMLHttpRequest.readyState` 返回一个整数，表示实例对象的当前状态。该属性只读。通信过程中，每当实例对象发生状态变化，它的 `readyState` 属性的值就会改变。这个值每次变化，都会触发 `readyStateChange` 事件。它可能返回以下值。

- `0` 表示 XMLHttpRequest 实例已经生成，但是实例的 `open()` 还没有被调用。
- `1` 表示 `open()` 已经调用，但是实例的 `send()` 还没有调用，仍然可以使用实例的 `setRequestHeader()` 方法，设定 HTTP 请求的头信息。
- `2` 表示实例的 `send()` 已经调用，并且服务器返回的头信息和状态码已经收到。
- `3` 表示正在接收服务器传来的数据体（`body` 部分）。这时，如果实例的 `responseType` 属性等于 `text` 或者空字符串，`responseText` 属性就会包含已经收到的部分信息。
- `4` 表示服务器返回的数据已经完全接收，或者本次接收已经失败。

#### （2）XMLHttpRequest.onreadystatechange

`XMLHttpRequest.onreadystatechange` 属性指向一个监听函数。`readystatechange` 事件发生时（实例的 `readyState` 属性变化），就会执行这个属性。

#### （3）XMLHttpRequest.response

`XMLHttpRequest.response` 属性表示服务器返回的数据体（即 HTTP 回应的 `body` 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由 `XMLHttpRequest.responseType` 属性决定。该属性只读。

#### （4）XMLHttpRequest.responseType

`XMLHttpRequest.responseType` 属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用 `open()` 方法之后、调用 `send()` 方法之前，设置这个属性的值，告诉浏览器如何解读返回的数据。如果 `responseType` 设为空字符串，就等同于默认值text。

`XMLHttpRequest.responseType` 属性可以等于以下值。

- 空字符串：等同于 `text`，表示服务器返回文本数据。
- `arraybuffer`：`ArrayBuffer` 对象，表示服务器返回二进制数组。
- `blob`：`Blob` 对象，表示服务器返回二进制对象。
- `document`：`Document` 对象，表示服务器返回一个文档对象。
- `json`：`JSON` 对象。
- `text`：字符串。

#### （5）XMLHttpRequest.responseText

`XMLHttpRequest.responseText` 属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。

#### （6）XMLHttpRequest.responseXML

`XMLHttpRequest.responseXML` 属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。

该属性生效的前提是 HTTP 回应的 `Content-Type` 头信息等于 `text/xml` 或 `application/xml`。这要求在发送请求前，`XMLHttpRequest.responseType` 属性要设为 `document`。如果 HTTP 回应的 `Content-Type` 头信息不等于 `text/xml` 和 `application/xml`，但是想从 `responseXML` 拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用 `XMLHttpRequest.overrideMimeType()` 方法，强制进行 XML 解析。

该属性得到的数据，是直接解析后的文档 DOM 树。

#### （7）XMLHttpRequest.responseURL

`XMLHttpRequest.responseURL` 属性是字符串，表示发送数据的服务器的网址。

#### （8）XMLHttpRequest.status，XMLHttpRequest.statusText

- `XMLHttpRequest.status` 属性返回一个整数，表示服务器回应的 HTTP 状态码。

  - `200`, OK，访问正常
  - `301`, Moved Permanently，永久移动
  - `302`, Moved temporarily，暂时移动
  - `304`, Not Modified，未修改
  - `307`, Temporary Redirect，暂时重定向
  - `401`, Unauthorized，未授权
  - `403`, Forbidden，禁止访问
  - `404`, Not Found，未发现指定网址
  - `500`, Internal Server Error，服务器发生错误

- `XMLHttpRequest.statusText` 属性返回一个字符串，表示服务器发送的状态提示。

#### （9）XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout

- `XMLHttpRequest.timeout` 属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于 `0`，就表示没有时间限制。
- `XMLHttpRequestEventTarget.ontimeout` 属性用于设置一个监听函数，如果发生 `timeout` 事件，就会执行这个监听函数。

#### （10）事件监听属性

XMLHttpRequest 对象可以对以下事件指定监听函数。

- `XMLHttpRequest.onloadstart`：`loadstart` 事件（HTTP 请求发出）的监听函数
- `XMLHttpRequest.onload`：`load` 事件（请求成功完成）的监听函数
- `XMLHttpRequest.onloadend`：`loadend` 事件（请求完成，不管成功或失败）的监听函数
- `XMLHttpRequest.onprogress`：`progress` 事件（正在发送和加载数据）的监听函数
- `XMLHttpRequest.ontimeout`：`timeout` 事件（用户指定的时限超过了，请求还未完成）的监听函数
- `XMLHttpRequest.onabort`：`abort` 事件（请求中止，比如用户调用了 `abort()` 方法）的监听函数
- `XMLHttpRequest.onerror`：`error` 事件（请求失败）的监听函数

#### （11）XMLHttpRequest.withCredentials

`XMLHttpRequest.withCredentials` 布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为 `false`。

如果需要跨域 AJAX 请求发送 Cookie，需要 `withCredentials` 属性设为 `true`。服务器还必须显式返回 `Access-Control-Allow-Credentials` 这个头信息。

#### （12）XMLHttpRequest.upload

通过 XMLHttpRequest 发送文件之后，通过 `XMLHttpRequest.upload` 属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：`loadstart`、`loadend`、`load`、`abort`、`error`、`progress`、`timeout`。

### 5.3 XMLHttpRequest 的实例方法

#### （1）XMLHttpRequest.open()

`XMLHttpRequest.open(method, url, async, user, password)` 用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。

```javascript
void open(
  string method,
  string url,
  optional boolean async,
  optional string user,
  optional string password
);
```

#### （2）XMLHttpRequest.send()

`XMLHttpRequest.send(body)` 用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。

`send` 方法的参数 `body` 可以接受多种格式的数据。

```javascript
void send();
void send(ArrayBufferView data);
void send(Blob data);
void send(Document data);
void send(String data);
void send(FormData data);
```

#### （3）XMLHttpRequest.setRequestHeader()

`XMLHttpRequest.setRequestHeader(header, value)` 用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在 `open()` 之后、`send()` 之前调用。

```javascript
xhr.setRequestHeader('Content-Type', 'application/json');
```

#### （4）XMLHttpRequest.overrideMimeType()

`XMLHttpRequest.overrideMimeType(mimeType)` 用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是 `text/xml`，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成 `text/plain`，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。

```javascript
xhr.overrideMimeType('text/plain')
```

注意，该方法必须在 `send()` 之前调用。

修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用 `responseType` 属性告诉服务器，就像下面的例子。只有在服务器无法返回某种数据类型时，才使用 `overrideMimeType()`。

```javascript
var xhr = new XMLHttpRequest();
xhr.onload = function(e) {
  var arraybuffer = xhr.response;
  // ...
}
xhr.open('GET', url);
xhr.responseType = 'arraybuffer';
xhr.send();
```

#### （5）XMLHttpRequest.getResponseHeader()，XMLHttpRequest.getAllResponseHeaders()

- `XMLHttpRequest.getResponseHeader(name)` 返回 HTTP 响应中头信息指定字段的值。
- `XMLHttpRequest.getAllResponseHeaders()` 返回一个字符串，表示服务器发来的所有 HTTP 头信息。

#### （6）XMLHttpRequest.abort()

`XMLHttpRequest.abort()` 用来终止已经发出的 HTTP 请求。调用这个方法以后，`readyState` 属性变为 `4`，`status` 属性变为 `0`。

### 5.4 XMLHttpRequest 实例的事件

- `readyState` 属性的值发生改变，就会触发 `readyStateChange` 事件。可以通过 `onReadyStateChange` 属性，指定这个事件的监听函数。
- 上传文件时，XMLHttpRequest 实例对象本身和实例的 `upload` 属性，都有一个 `progress` 事件，会不断返回上传的进度。

  ```javascript
  var xhr = new XMLHttpRequest();

  xhr.addEventListener('progress', function (oEvent) {
    if (oEvent.lengthComputable) {
      var percentComplete = oEvent.loaded / oEvent.total;
    } else {
      console.log('无法计算进展');
    }
  });

  xhr.open();
  ```

- `load` 事件表示服务器传来的数据接收完毕，`error` 事件表示请求出错，`abort` 事件表示请求被中断（比如用户取消请求）。
- `abort`、`load` 和 `error` 这三个事件，会伴随一个 `loadend` 事件，表示请求结束，但不知道其是否成功。

  ```javascript
  xhr.addEventListener('loadend', function (e) {
    console.log('请求结束，状态未知');
  });
  ```

- 服务器超过指定时间还没有返回结果，就会触发 `timeout` 事件。

### 5.5 Navigator.sendBeacon()

用户卸载网页的时候，有时需要向服务器发一些数据。如果使用 `unload` 事件或 `beforeunload` 事件的监听函数，或者使用 `setTimeout()`，会导致很多问题。为此，浏览器引入了 `Navigator.sendBeacon(url, data)`。这个方法还是**异步**发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。

```javascript
window.addEventListener('unload', function () {
  var succeed = navigator.sendBeacon('/log', JSON.stringify({
    some: "data"
  }));
}, false);
```

`Navigator.sendBeacon(url, data)` 的返回值是一个布尔值，成功发送数据为 `true`，否则为 `false`。

**该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据**。它不能指定回调函数。这个方法的优先级较低，不会占用页面资源。一般是在浏览器空闲的时候，才会发送。

## 六、同源限制

### 6.1 概述

同源指协议、域名和端口都相同的地址。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。对于非同源，共有三种行为受到限制。

- 无法接触非同源网页的 DOM。
- 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
- 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

### 6.2 Cookie

Cookie 是服务器写入浏览器的一小段信息，只有**同源**的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置 `document.domain` 共享 Cookie。

举例来说，A 网页的网址是 `http://w1.example.com/a.html`，B 网页的网址是 `http://w2.example.com/b.html`，那么只要设置相同的 `document.domain`，两个网页就可以共享 Cookie。因为浏览器通过 `document.domain` 属性来检查是否同源。

```javascript
// 两个网页都需要设置
document.domain = 'example.com';
```

注意，A 和 B 两个网页都需要设置 `document.domain` 属性，才能达到同源的目的。因为设置 `document.domain` 的同时，会把端口重置为 `null`，因此如果只设置一个网页的 `document.domain`，会导致两个网址的端口不同，还是达不到同源的目的。这种方法只适用于 Cookie 和 `iframe` 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍 PostMessage API。

另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如 `example.com`。

```http
Set-Cookie: key=value; domain=example.com; path=/
```

这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。

### 6.3 iframe 和多窗口通信

iframe 窗口中的脚本，可以获得父窗口和子窗口。但是，只有在**同源**的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。

- 片段识别符（fragment identifier）
- 跨文档通信 API（Cross-document messaging）

#### （1）片段识别符

**片段标识符**（fragment identifier）指的是，URL 的 `#` 号后面的部分。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符（同样的，子窗口也可以改变父窗口的片段标识符）。

```javascript
var src = originURL + '#' + data;
document.getElementById('myIFrame').src = src;
```

子窗口通过监听 `hashchange` 事件得到通知。

```javascript
window.onhashchange = function () {
  var message = window.location.hash;
  // ...
};
```

#### （2）window.postMessage()

HTML5 引入了跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 **`window.postMessage` 方法，允许跨窗口通信，不论这两个窗口是否同源**。举例来说，父窗口 `a.com` 向子窗口 `b.com` 发消息，调用 `postMessage` 方法就可以了。

```javascript
// 父窗口打开一个子窗口
var popup = window.open('http://b.com', 'title');
// 父窗口向子窗口发消息
popup.postMessage('Hello World!', 'http://b.com');
```

`postMessage` 方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为 `*`，表示不限制域名，向所有窗口发送（子窗口向父窗口发送消息的写法类似）。

父窗口和子窗口都可以通过 `message` 事件，监听对方的消息。

```javascript
// 父窗口和子窗口都可以用下面的代码监听 message 消息
window.addEventListener('message', function (e) {
  console.log(e.data); // 消息内容
  console.log(e.source); // 发送消息的窗口
  console.log(e.origin); // 消息发送者的源（origin），即协议、域名、端口
},false);
```

#### （3）LocalStorage

通过 `window.postMessage` 可以读写其他窗口的 LocalStorage。

父窗口发送消息代码如下。

```javascript
var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
// 存入对象
win.postMessage(
  JSON.stringify({key: 'storage', method: 'set', data: obj}),
  'http://b.com'
);
// 读取对象
win.postMessage(
  JSON.stringify({key: 'storage', method: "get"}),
  "*"
);
window.onmessage = function(e) {
  if (e.origin != 'http://a.com') return;
  console.log(JSON.parse(e.data).name);
};
```

子窗口接收消息的代码如下。

```javascript
window.onmessage = function(e) {
  if (e.origin !== 'http://b.com') return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case 'set':
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case 'get':
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, 'http://a.com');
      break;
    case 'remove':
      localStorage.removeItem(payload.key);
      break;
  }
};
```

### 6.4 AJAX

同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制：JSONP、WebSocket 和 CORS。

#### （1）JSONP

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。它的做法如下。

1. 第一步，网页添加一个 `<script>` 元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。请求的脚本网址有个 `callback` 参数（`?callback=bar`），用来告诉服务器，客户端的回调函数名称（`bar`）。

    ```html
    <script src="http://api.foo.com?callback=bar"></script>
    ```

2. 第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（`bar({...})`）。
3. 第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是 `<script>` 标签请求的脚本内容。这时，客户端只要定义了 `bar()`，就能在该函数体内，拿到服务器返回的 JSON 数据。

下面看一个实例。首先，网页动态插入 `<script>` 元素，由它向跨域网址发出请求。

```javascript
window.onload = function () {
  var script = document.createElement('script');
  script.setAttribute('type', 'text/javascript');
  script.src = 'http://example.com/ip?callback=foo';
  document.body.appendChild(script);
}

function foo(data) {
  console.log('Your public IP address is: ' + data.ip);
};
```

上面代码通过动态添加 `<script>` 元素，向服务器 `example.com` 发出请求。注意，该请求的查询字符串有一个 `callback` 参数，用来指定回调函数的名字，这对于 JSONP 是必需的。

服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。

```javascript
foo({
  'ip': '8.8.8.8'
});
```

由于 `<script>` 元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了 `foo` 函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 `JSON.parse` 的步骤。

JSONP 的缺点是只能发送 GET 请求。

#### （2）WebSocket

WebSocket 是一种通信协议，使用 `ws://`（非加密）和 `wss://`（加密）作为协议前缀。**该协议不实行同源政策**，只要服务器支持，就可以通过它进行跨源通信。

下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自[维基百科](https://en.wikipedia.org/wiki/WebSocket)）。

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

上面代码中，有一个字段是 `Origin`，表示该请求的请求源（origin），即发自哪个域名。

正是因为有了 `Origin` 这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

#### （3）CORS

见下一章。

## 七、CORS 通信

CORS 是一个 W3C 标准，全称是“跨源资源共享”（Cross-origin resource sharing），或者通俗地称为“跨域资源共享”。它允许浏览器向跨源的服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。

### 1. 简介

CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。

整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，**实现 CORS 通信的关键是服务器**。只要服务器实现了 CORS 接口，就可以跨源通信。

### 2. 两种请求

CORS 请求分成两类：**简单请求**（simple request）和**非简单请求**（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

1. 请求方法是以下三种方法之一。

    - `HEAD`
    - `GET`
    - `POST`

2. HTTP 的头信息不超出以下几种字段。

    - `Accept`
    - `Accept-Language`
    - `Content-Language`
    - `Last-Event-ID`
    - `Content-Type`：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。

这样划分的原因是，表单在历史上一直可以跨源发出请求。简单请求就是**表单请求**，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。

### 3. 简单请求

#### 3.1 基本流程

对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 `Origin` 字段，用来说明本次请求来自哪个域（协议 + 域名 + 端口）。

如果 `Origin` 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 `Access-Control-Allow-Origin` 字段，就知道出错了，从而抛出一个错误，被 `XMLHttpRequest` 的 `onerror` 回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 `200`。

如果 `Origin` 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

```http
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
```

- `Access-Control-Allow-Origin` 字段是必须的。它的值要么是请求时 `Origin` 字段的值，要么是一个 `*`，表示接受任意域名的请求。
- `Access-Control-Allow-Credentials` 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 `true`，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为 `true`，如果服务器不要浏览器发送 Cookie，不发送该字段即可。
- `Access-Control-Expose-Headers` 该字段可选。CORS 请求时，XMLHttpRequest 对象的 `getResponseHeader()` 只能拿到 6 个服务器返回的基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在 `Access-Control-Expose-Headers` 里面指定。上面的例子指定，`getResponseHeader('FooBar')` 可以返回 `FooBar` 字段的值。

#### 3.2 withCredentials 属性

CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 **CSRF 攻击**的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定 `Access-Control-Allow-Credentials` 字段，告诉浏览器可以发送 Cookie。

```http
Access-Control-Allow-Credentials: true
```

同时，开发者必须在 AJAX 请求中打开 `withCredentials` 属性。否则，即使服务器要求发送 Cookie，浏览器也不会发送。

```javascript
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

### 4. 非简单请求

#### 4.1 预检请求

非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为**预检请求**（preflight）。浏览器先询问服务器，当前网页所在的**域名**是否在服务器的许可名单之中，以及可以使用哪些 **HTTP 方法**和**头信息**字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量 DELETE 和 PUT 请求，这些传统的表单不可能跨源发出的请求。

下面是一段浏览器的 JavaScript 脚本。

```javascript
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```

上面代码中，HTTP 请求的方法是 PUT，并且发送一个自定义头信息 `X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

“预检”请求用的请求方法是 `OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是 `Origin`，表示请求来自哪个源。除了 `Origin` 字段，“预检”请求的头信息包括两个特殊字段。

- `Access-Control-Request-Method` 字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 `PUT`。
- `Access-Control-Request-Headers` 字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 `X-Custom-Header`。

#### 4.2 预检请求的回应

服务器收到“预检”请求以后，检查了 `Origin`、`Access-Control-Request-Method` 和 `Access-Control-Request-Headers` 字段以后，确认允许跨源请求，就可以做出回应。

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
```

上面的 HTTP 回应中，关键的是 `Access-Control-Allow-Origin` 字段，表示 `http://api.bob.com` 可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。

```http
OPTIONS http://api.bob.com HTTP/1.1
Status: 200
Access-Control-Allow-Origin: https://notyourdomain.com
Access-Control-Allow-Method: POST
```

这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 `onerror` 回调函数捕获。控制台会打印出如下的报错信息。

```text
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```

服务器回应的其他 CORS 相关字段如下。

- `Access-Control-Allow-Methods` 字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨源请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。
- `Access-Control-Allow-Headers` 如果浏览器请求包括 `Access-Control-Request-Headers` 字段，则 `Access-Control-Allow-Headers` 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。
- `Access-Control-Allow-Credentials` 字段与简单请求时的含义相同。
- `Access-Control-Max-Age` 字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 2 0天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。

### 4.3 浏览器的正常请求和回应

一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 `Origin` 头信息字段。服务器的回应，也都会有一个 `Access-Control-Allow-Origin` 头信息字段。

下面是“预检”请求之后，浏览器的正常 CORS 请求。

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面头信息的 `Origin` 字段是浏览器自动添加的。

下面是服务器正常的回应。

```http
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

上面头信息中，`Access-Control-Allow-Origin` 字段是每次回应都必定包含的。

### 5. 与 JSONP 的比较

CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持 `GET` 请求，CORS 支持所有类型的 HTTP 请求。**JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据**。

## 八、Storage 接口

### 8.1 概述

Storage 接口用于脚本在浏览器保存数据。两个对象部署了这个接口：`window.sessionStorage` 和 `window.localStorage`。

- `sessionStorage` 保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空；
- `localStorage` 保存的数据长期存在，下次访问该网站的时候，网页可以直接读取以前保存的数据。

除了保存期限的长短不同，这两个对象的其他方面都一致。

- 保存的数据都以“**键值对**”的形式存在。所有的数据都是以**文本格式**保存。每个域名的存储上限一般是 5 MB - 10 MB。
- Storage 接口受**同域限制**。某个网页存入的数据，只有同域下的网页才能读取，如果跨域操作会报错。

### 8.2 属性和方法

- `Storage.length` 是 Storage 接口唯一的一个属性，返回保存的数据项个数。
- `Storage.setItem(key, value)` 用于存入数据。两个参数都是字符串。如果不是字符串，会自动转成字符串。如果储存空间已满，该方法会抛错。也可以像对象一样直接赋值。
- `Storage.getItem(key)` 用于读取某个字符串键名对应的数据。
- `Storage.removeItem(key)` 用于清除某个键名对应的键值。
- `Storage.clear()` 用于清除所有保存的数据。
- `Storage.key(index)` 返回 `index` 位置对应的键名。

### 8.3 storage 事件

Storage 接口储存的数据发生变化时，会触发 `storage` 事件，可以指定这个事件的监听函数。

```javascript
window.addEventListener('storage', onStorageChange);
```

监听函数接受一个 `event` 实例对象作为参数。这个实例对象继承了 StorageEvent 接口，有几个特有的属性，都是只读属性。

- `StorageEvent.key`：字符串，表示发生变动的键名。如果 `storage` 事件是由 `clear()` 引起，该属性返回 `null`。
- `StorageEvent.oldValue`：字符串，表示旧的键值。
- `StorageEvent.newValue`：字符串，表示新的键值。如果 `storage` 事件是由 `clear()` 或删除该键值对引发的，该属性返回 `null`。
- `StorageEvent.storageArea`：对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。
- `StorageEvent.url`：字符串，表示原始触发 `storage` 事件的那个网页的网址。

注意，该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在**同域名**的**其他窗口**触发。也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。

## 九、History 对象

### 9.1 概述

`window.history` 属性指向 History 对象，它表示当前窗口的浏览历史。History 对象保存了当前窗口访问过的所有页面网址。

### 9.2 属性

History 对象主要有两个属性。

- `History.length`：当前窗口访问过的网址数量（包括当前网页）。
- `History.state`：History 堆栈最上层的状态值。

### 9.3 方法

- `History.back()`：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。
- `History.forward()`：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。
- `History.go(delta)`：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如 `go(1)` 相当于 `forward()`，`go(-1)` 相当于 `back()`。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为 `0`，相当于刷新当前页面。
- `History.pushState(state, title, url)` 用于在历史中添加一条记录。

  该方法接受三个参数，依次为：

  - `state`：一个与添加的记录相关联的状态对象，主要用于 `popstate` 事件。该事件触发时，该对象会传入回调函数。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填 `null`。
  - `title`：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。
  - `url`：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。

  假定当前网址是 `example.com/1.html`，使用 `pushState()` 在浏览记录（History 对象）中添加一个新记录。

  ```javascript
  history.pushState({ foo: 'bar' }, 'page 2', '2.html');
  ```

  添加新记录后，浏览器地址栏立刻显示 `example.com/2.html`，但并不会跳转到 `2.html`，甚至也不会检查 `2.html` 是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问 `google.com`)，然后点击了倒退按钮，页面的 URL 将显示 `2.html`；你再点击一次倒退按钮，URL 将显示 `1.html`。

  **`pushState()` 不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应**。

  使用该方法之后，就可以用 `History.state` 属性读出状态对象。

  ```javascript
  history.pushState({ foo: 'bar' }, 'page 2', '2.html');
  history.state // {foo: "bar"}
  ```

  如果 `pushState` 的 URL 参数设置了一个新的锚点值（即 `hash`），并不会触发 `hashchange` 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。

  如果 `pushState()` 设置了一个跨域网址，则会报错。

  ```javascript
  // 报错
  // 当前网址为 http://example.com
  history.pushState(null, '', 'https://twitter.com/hello');
  ```

  上面代码中，`pushState` 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。

- `History.replaceState(state, title, url)` 用来修改 History 对象的当前记录，使用方法与 `pushState()` 一样。

### 9.4 popstate 事件

每当同一个文档的浏览历史（即 `history` 对象）出现变化时，就会触发 `popstate` 事件。

注意，仅仅调用 `pushState()` 或 `replaceState()`，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 `History.back()`、`History.forward()`、`History.go()` 时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。

使用的时候，可以为 `popstate` 事件指定回调函数。

```javascript
window.onpopstate = function (event) {
  console.log('location: ' + document.location);
  console.log('state: ' + JSON.stringify(event.state));
};

// 或者
window.addEventListener('popstate', function(event) {
  console.log('location: ' + document.location);
  console.log('state: ' + JSON.stringify(event.state));
});
```

回调函数的参数是一个 `event` 事件对象，它的 `state` 属性指向 `pushState` 和 `replaceState` 方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数），这个 `state` 对象也可以直接通过 `history.state` 读取。

页面第一次加载的时候，浏览器不会触发 `popstate` 事件。

## 十、Location 对象，URL 对象，URLSearchParams 对象

### 10.1 Location 对象

`Location` 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 `window.location` 和 `document.location` 属性，可以拿到这个对象。

#### 1.1 属性

Location 对象提供以下属性。

- `Location.href：` 整个 URL。
- `Location.protocol`：当前 URL 的协议，包括冒号（`:`）。
- `Location.hostname`：主机名，不包括端口。
- `Location.host`：主机。如果端口不是协议默认的 `80` 和 `433`，则还会包括冒号（`:`）和端口。
- `Location.port`：端口号。
- `Location.origin`：URL 的协议、主机名和端口。
- `Location.pathname`：URL 的路径部分，从根路径 `/` 开始。
- `Location.search`：查询字符串部分，从问号 `?` 开始。
- `Location.hash`：片段字符串部分，从 `#` 开始。
- `Location.username`：域名前面的用户名。
- `Location.password`：域名前面的密码。

这些属性里面，只有 `origin` 属性是只读的，其他属性都可写。

如果对 `Location.href` 写入新的 URL 地址，浏览器会立刻跳转到这个新地址。这个特性常常用于让网页自动滚动到新的锚点。

```javascript
// 跳转到新网址
document.location.href = 'http://www.example.com';
```

#### 1.2 方法

- `Location.assign(url)` 方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。
- `Location.replace(url)` 方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。它与 `assign` 方法的差异在于，`replace` 会在浏览器的浏览历史 `History` 里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。

  ```javascript
  // 跳转到新的网址
  document.location.replace('http://www.example.com')
  ```

- `Location.reload(force)` 方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。它接受一个布尔值作为参数。如果参数为 `true`，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即 `scrollTop === 0`）。如果参数是 `false` 或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。
- `Location.toString()` 方法返回整个 URL 字符串，相当于读取 `Location.href` 属性。

### 10.2 URL 的编码和解码

网页的 URL 只能包含合法的字符。合法字符分成两类。

- **元字符**：冒号（`:`），斜杠（`/`），at（`@`），问号（`?`），等号（`=`），`&`，井号（`#`），分号（`;`），逗号（`,`），加号（`+`），美元符号（`$`）
- **语义字符**：`a-z`，`A-Z`，`0-9`，连词号（`-`），下划线（`_`），点（`.`），感叹号（`!`），波浪线（`~`），星号（`*`），单引号（`'`），圆括号（`()`）

除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（`%`）加上两个大写的十六进制字母。

比如，UTF-8 的操作系统上，`http://www.example.com/q=春节` 这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成 `http://www.example.com/q=%E6%98%A5%E8%8A%82`。其中，“春”转成了 `%E6%98%A5`，“节”转成了 `%E8%8A%82`。这是因为“春”和“节”的 UTF-8 编码分别是 `E6 98 A5` 和 `E8 8A 82`，将每个字节前面加上百分号，就构成了 URL 编码。

JavaScript 提供四个 URL 的编码/解码方法。

- `encodeURI(URI)` 方法用于转码整个 URL。它会将**元字符和语义字符之外**的字符，都进行转义。
- `encodeURIComponent(str)` 方法用于转码 URL 的组成部分，会转码除了**语义字符之外**的所有字符，即元字符也会被转码。

  ```javascript
  encodeURIComponent('春节')
  // "%E6%98%A5%E8%8A%82"
  encodeURIComponent('http://www.example.com/q=春节')
  // "http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82"
  ```

- `decodeURI(encodedURI)` 方法用于整个 URL 的解码。它是 `encodeURI()` 方法的逆运算。
- `decodeURIComponent(encodedURI)` 方法用于URL 片段的解码。它是 `encodeURIComponent()` 方法的逆运算

### 10.3 URL 接口

#### 3.1 构造函数

`URL(url, base)` 构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。

除了字符串，`URL()` 的参数也可以是另一个 URL 实例。这时，`URL()` 会自动读取该实例的 `href` 属性，作为实际参数。

#### 3.2 实例属性

URL 实例的属性与 Location 对象的属性基本一致，返回当前 URL 的信息。

- `URL.href`：返回整个 URL
- `URL.protocol`：返回协议，以冒号 `:` 结尾
- `URL.hostname`：返回域名
- `URL.host`：返回域名与端口，包含 `:` 号，默认的 `80` 和 `443` 端口会省略
- `URL.port`：返回端口
- `URL.origin`：返回协议、域名和端口
- `URL.pathname`：返回路径，以斜杠 `/` 开头
- `URL.search`：返回查询字符串，以问号 `?` 开头
- `URL.searchParams`：返回一个 URLSearchParams 实例，该属性是 Location 对象没有的
- `URL.hash`：返回片段识别符，以井号 `#` 开头
- `URL.username`：返回域名前面的用户名
- `URL.password`：返回域名前面的密码

这些属性里面，只有 `origin` 属性是只读的，其他属性都可写，并且会立即生效。

#### 3.3 静态方法

- `URL.createObjectURL(object)` 方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了 `File` 对象或 `Blob` 对象的 URL。

  注意，每次使用 `URL.createObjectURL()` 方法，都会在内存里面生成一个 URL 实例。如果不再需要该方法生成的 URL 字符串，为了节省内存，可以使用 `URL.revokeObjectURL()` 方法释放这个实例。

  ```text
  blob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1
  ```

- `URL.revokeObjectURL(objectURL)` 方法用来释放 `URL.createObjectURL()` 方法生成的 URL 实例。它的参数就是 `URL.createObjectURL()` 方法返回的 URL 字符串。

### 10.4 URLSearchParams 对象

`URLSearchParams` 对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号 `?` 有没有都行，也可以是对应查询字符串的数组或对象。

```javascript
// 方法一：传入字符串
var params = new URLSearchParams('?foo=1&bar=2');
// 等同于
var params = new URLSearchParams(document.location.search);

// 方法二：传入数组
var params = new URLSearchParams([['foo', 1], ['bar', 2]]);

// 方法三：传入对象
var params = new URLSearchParams({'foo' : 1 , 'bar' : 2});
```

浏览器向服务器发送表单数据时，可以直接使用 `URLSearchParams` 实例作为表单数据。

```javascript
const params = new URLSearchParams({foo: 1, bar: 2});
fetch('https://example.com/api', {
  method: 'POST',
  body: params
}).then(...)
```

`URLSearchParams` 可以与 `URL()` 接口结合使用。

```javascript
var url = new URL(window.location);
var foo = url.searchParams.get('foo') || 'somedefault';
```

`URLSearchParams` 实例有遍历器接口，可以用 `for...of` 循环遍历。`URLSearchParams` 没有实例属性，只有实例方法。

- `URLSearchParams.toString()` 方法返回实例的字符串形式。
- `URLSearchParams.append(name, value)` 方法用来追加一个查询参数。它接受两个参数，第一个为键名，第二个为键值，没有返回值。
- `URLSearchParams.set(name, value)` 方法用来设置查询字符串的键值。
- `URLSearchParams.get(name)` 方法用来读取查询字符串里面的指定键。它接受键名作为参数。
- `URLSearchParams.getAll(name)` 方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。
- `URLSearchParams.has(name)` 方法返回一个布尔值，表示查询字符串是否包含指定的键名。
- `URLSearchParams.delete(name)` 方法用来删除指定的查询参数。它接受键名作为参数。

  ```javascript
  var params = new URLSearchParams('?foo=1&foo=2');
  params.getAll('foo') // ["1", "2"]
  ```

- `URLSearchParams.sort()` 方法对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。
- `URLSearchParams.keys()`，`URLSearchParams.values()`，`URLSearchParams.entries()` 这三个方法都返回一个遍历器对象，供 `for...of` 循环遍历。它们的区别在于，`keys` 方法返回的是键名的遍历器，`values` 方法返回的是键值的遍历器，`entries` 返回的是键值对的遍历器。

## 十一、ArrayBuffer 对象，Blob 对象

```javascript
```

```javascript
```

```javascript
```

## 十二、File 对象，FileList 对象，FileReader 对象

```javascript
```

```javascript
```

```javascript
```

## 十三、表单，FormData 对象

```javascript
```

```javascript
```

```javascript
```

## 十四、IndexedDB API

### 1. 概述

通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。

IndexedDB 具有以下特点。

- **键值对储存**。IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以“键值对”的形式保存，每个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
- **异步**。IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 `LocalStorage` 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
- **支持事务**。IndexedDB 支持**事务**（transaction），这意味着一系列操作步骤中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
- **同源限制**。IndexedDB 受到同源限制，每个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
- **储存空间大**。IndexedDB 的储存空间比 `LocalStorage` 大得多，一般来说不少于 250MB，甚至没有上限。
- **支持二进制储存**。IndexedDB 不仅可以储存字符串，还可以储存二进制数据（`ArrayBuffer` 对象和 `Blob` 对象）。

### 2. 基本概念

IndexedDB 是一个比较复杂的 API。它把不同的实体，抽象成一个个对象接口。

- 数据库：`IDBDatabase` 对象。数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。
- 对象仓库：`IDBObjectStore` 对象。每个数据库包含若干个对象仓库（object store）。
- 索引：`IDBIndex` 对象。指对象仓库保存的数据记录。每条记录只有主键和数据体两部分。
- 事务：`IDBTransaction` 对象。数据记录的读写和删改，都要通过事务完成。
- 操作请求：`IDBRequest` 对象。
- 指针：`IDBCursor` 对象。
- 主键集合：`IDBKeyRange` 对象。

### 3. 操作流程

#### 3.1 打开数据库

```javascript
```

```javascript
```

#### 3.2 新建数据库

```javascript
```

```javascript
```

#### 3.3 新增数据

```javascript
```

```javascript
```

#### 3.4 读取数据

```javascript
```

```javascript
```

#### 3.5 遍历数据

```javascript
```

```javascript
```

#### 3.6 更新数据

```javascript
```

```javascript
```

#### 3.7 删除数据

```javascript
```

```javascript
```

#### 3.8 使用索引

```javascript
```

```javascript
```

### 4. indexedDB 对象

#### 4.1 indexedDB.open()

#### 4.2 indexedDB.deleteDatabase()

#### 4.3 indexedDB.cmp()

### 5. IDBRequest 对象

```javascript
```

```javascript
```

### 6. IDBDatabase 对象

#### 6.1 属性

#### 6.2 方法

### 7. IDBObjectStore 对象

#### 7.1 属性

#### 7.2 方法

### 8. IDBTransaction 对象

```javascript
```

```javascript
```

### 9. IDBIndex 对象

```javascript
```

```javascript
```

### 10. IDBCursor 对象

```javascript
```

```javascript
```

### 11. IDBKeyRange 对象

```javascript
```

```javascript
```

```javascript
```

## 十五、Web Worker

### 15.1 概述

JavaScript 语言采用单线程模型，Web Worker 的引入，为 JavaScript 创造了多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。

Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

Web Worker 有以下几个使用注意点。

- **同源限制**：分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。
- **DOM 限制**：Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 `window`、`document`、`parent` 这些对象。但是，Worker 线程可以使用 `navigator` 对象和 `location` 对象。
- **全局对象限制**：Worker 的全局对象 `WorkerGlobalScope`，不同于网页的全局对象 Window，很多接口拿不到。比如，理论上 Worker 线程不能使用 `console.log`，因为标准里面没有提到 Worker 的全局对象存在 `console` 接口，只定义了 Navigator 接口和 Location 接口。不过，浏览器实际上支持 Worker 线程使用 `console.log`，保险的做法还是不使用这个方法。
- **通信联系**：Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
- **脚本限制**：Worker 线程不能执行 `alert()` 和 `confirm()`，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。
- **文件限制**：**Worker 线程无法读取本地文件**，即不能打开本机的文件系统（`file://`），**它所加载的脚本，必须来自网络**。

### 15.2 基本用法

#### （1）主线程

在主线程创建使用 Worker 的步骤如下。

1. 主线程采用 `new` 命令，调用 `Worker()` 构造函数，新建一个 Worker 线程。`Worker()` 构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功，Worker 会失败。
2. 主线程调用 `worker.postMessage()` 向 Worker 发消息。`worker.postMessage()` 的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。
3. 主线程通过 `worker.onmessage` 指定监听函数，接收子线程发回来的消息。
4. Worker 完成任务以后，主线程就可以把它关掉。

```javascript
var worker = new Worker('work.js');
worker.postMessage('Hello World');
worker.postMessage({method: 'echo', args: ['Work']});
worker.onmessage = function (event) {
  // do something...
}
worker.terminate();
```

#### （2）Worker 线程

Worker 线程内部需要有一个监听函数，监听 `message` 事件。可以使用 `self.addEventListener()` 或者 `self.onmessage` 指定监听函数。其中，`self` 代表子线程自身，即子线程的全局对象。监听函数的参数是一个事件对象，它的 `data` 属性包含主线程发来的数据。

```javascript
// 写法一
this.addEventListener('message', function (e) {
  this.postMessage('You said: ' + e.data);
}, false);

// 写法二
addEventListener('message', function (e) {
  postMessage('You said: ' + e.data);
}, false);
```

#### （3）Worker 加载脚本

可以通过 `importScripts()` 在 Worker 内部加载其他脚本。该方法可以同时加载多个脚本。

```javascript
importScripts('script1.js', 'script2.js');
```

#### （4）错误处理

主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的 `error` 事件。

```javascript
worker.onerror = function (event) {
  console.log(
    'ERROR: Line ', event.lineno, ' in ', event.filename, ': ', event.message
  );
};

// 或者
worker.addEventListener('error', function (event) {
  // ...
});
```

#### （5）关闭 Worker

使用完毕，为了节省系统资源，必须关闭 Worker。

```javascript
// 主线程
worker.terminate();
// Worker 线程
self.close();
```

### 15.3 数据通信

主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。这种通信是拷贝关系，即是**传值**而不是传址，Worker 对通信内容的修改，不会影响到主线程。浏览器内部的运行机制是，先将通信内容**串行化**，然后把串行化后的字符串发给 Worker，后者再将它还原。

主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。

但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做 **Transferable Objects**。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便，不会产生性能负担。

如果要直接转移数据的控制权，就要使用下面的写法。

```javascript
// Transferable Objects 格式
worker.postMessage(arrayBuffer, [arrayBuffer]);

// 例子
var ab = new ArrayBuffer(1);
worker.postMessage(ab, [ab]);
```

### 15.4 同页面的 Web Worker

通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。

```html
<!DOCTYPE html>
  <body>
    <script id="worker" type="app/worker">
      addEventListener('message', function () {
        postMessage('some message');
      }, false);
    </script>
  </body>
</html>
```

上面是一段嵌入网页的脚本，注意必须指定 `<script>` 标签的 `type` 属性是一个浏览器不认识的值，上例是 `app/worker`。

然后，读取这一段嵌入页面的脚本，用 Worker 来处理。

```javascript
var blob = new Blob([document.querySelector('#worker').textContent]);
var url = window.URL.createObjectURL(blob);
var worker = new Worker(url);
worker.onmessage = function (e) {
  // e.data === 'some message'
};
```

上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。

### 15.5 实例：Worker 线程完成轮询

有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。

```javascript
function createWorker(f) {
  var blob = new Blob(['(' + f.toString() + ')()']);
  var url = window.URL.createObjectURL(blob);
  var worker = new Worker(url);
  return worker;
}

var pollingWorker = createWorker(function (e) {
  var cache;
  function compare(new, old) { ... };
  setInterval(function () {
    fetch('/my-api-endpoint').then(function (res) {
      var data = res.json();
      if (!compare(data, cache)) {
        cache = data;
        self.postMessage(data);
      }
    })
  }, 1000)
});

pollingWorker.onmessage = function () {
  // render data
}

pollingWorker.postMessage('init');
```

上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。

### 15.6 API

#### （1）主线程

浏览器原生提供 `Worker()` 构造函数，用来供主线程生成 Worker 线程。`Worker()` 构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。

```javascript
// 主线程
var myWorker = new Worker('worker.js', { name : 'myWorker' });
// Worker 线程
self.name // myWorker
```

`Worker()` 构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。

- `Worker.onerror`：指定 `error` 事件的监听函数。
- `Worker.onmessage`：指定 `message` 事件的监听函数，发送过来的数据在 `Event.data` 属性中。
- `Worker.onmessageerror`：指定 `messageerror` 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。
- `Worker.postMessage()`：向 Worker 线程发送消息。
- `Worker.terminate()`：立即终止 Worker 线程。

#### （2）Worker 线程

Web Worker 有自己的全局对象，不是主线程的 `window`，而是一个专门为 Worker 定制的全局对象。因此定义在 `window` 上面的对象和方法不是全部都可以使用。

Worker 线程有一些自己的全局属性和方法。

- `self.name`： Worker 的名字。该属性只读，由构造函数指定。
- `self.onmessage`：指定 `message` 事件的监听函数。
- `self.onmessageerror`：指定 `messageerror` 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。
- `self.close()`：关闭 Worker 线程。
- `self.postMessage()`：向产生这个 Worker 的线程发送消息。
- `self.importScripts()`：加载 JS 脚本。

## 十六、参考

- 阮一峰，[JavaScript 教程 - 浏览器模型](https://wangdoc.com/javascript/bom/)
