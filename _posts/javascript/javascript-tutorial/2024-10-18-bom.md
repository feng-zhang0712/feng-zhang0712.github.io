---
layout: post
title: 《JavaScript 教程 - 浏览器模型》摘录
categories: blog
tags:
  - javascript
  - bom
---

> 本文是对[《JavaScript 教程 - 浏览器模型》](https://wangdoc.com/javascript/bom/)一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。

## 一、浏览器模型概述

### 1. 代码嵌入网页的方法

网页中嵌入 JavaScript 代码，主要有四种方法。

- `<script>` 元素直接嵌入代码。

  `<script>` 标签的 `type` 属性用来指定脚本类型。`type` 属性可以设为两种值。

  - `text/javascript`：这是**默认值**，也是历史上一贯设定的值。如果你省略 `type` 属性，默认就是这个值。对于老式浏览器，设为这个值比较好。
  - `application/javascript`：对于较新的浏览器，建议设为这个值。

  如果 `type` 属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在 `<script>` 标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的 `type` 属性即可。

- `<script>` 标签通过 src 属性加载外部脚本。为了防止攻击者篡改外部脚本，script 标签允许设置一个 `integrity` 属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。

  ```html
  <script src="https://www.example.com/script.js"
    integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=">
  </script>
  ```

- 事件属性：网页元素的事件属性（比如 `onclick`），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。

  ```javascript
  <button id="myBtn" onclick="console.log(this.id)">点击</button>
  ```

- URL 协议：URL 支持 `javascript:` 协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。

  ```javascript
  <a href="javascript:console.log('Hello')">点击</a>
  ```

  `javascript:` 协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以 `javascript:` 网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上 `void`，或者在脚本最后加上 `void 0`。

  ```javascript
  <a href="javascript: void new Date().toLocaleTimeString();">点击</a>
  <a href="javascript: new Date().toLocaleTimeString();void 0;">点击</a>
  ```

  上面这两种写法，点击链接后，执行代码都不会网页跳转。

### 2. script 元素

#### 2.1 工作原理

正常的网页加载流程是这样的。

1. 对于 HTML 网页，浏览器边下载边解析。
2. 解析过程中，浏览器发现 `<script>` 元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。
3. 如果 `<script>` 元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。
4. JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。

**加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染**。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。

如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“**假死**”状态，这被称为“**阻塞效应**”。

为了避免这种情况，较好的做法是将 `<script>` 标签都放在页面底部，而不是头部。这样做有几个好处。

- 即使遇到脚本失去响应，网页主体的渲染也已经完成，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。
- 避免因 DOM 结构生成之前调用 DOM 节点而导致的 JavaScript 报错，因为这时 DOM 已经生成了。

```html
<head>
  <script>
    console.log(document.body.innerHTML);
  </script>
</head>
<body>
</body>
```

上面代码执行时会报错，因为此时 document.body 元素还未生成。有几种方式可以解决这个问题。

- 设定 `DOMContentLoaded` 事件的回调函数。
- 使用 `<script>` 标签的 `onload` 属性。
- 将脚本放在页面底部。

如果有多个 `script` 标签，比如下面这样。

```html
<script src="a.js"></script>
<script src="b.js"></script>
```

浏览器会同时**并行**下载 `a.js` 和 `b.js`，但是，执行时会保证先执行 `a.js`，然后再执行 `b.js`，即使后者先下载完成，也是如此。也就是说，**脚本的执行顺序由它们在页面中的出现顺序决定**，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。

**解析和执行 CSS，也会产生阻塞**。

此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载 6～20 个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。

#### 2.2 defer 属性

`defer` 属性可以延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。

`defer` 属性的运行流程如下。

1. 浏览器开始解析 HTML 网页。
2. 解析过程中，发现带有 `defer` 属性的 `<script>` 元素。
3. 浏览器继续往下解析 HTML 网页，同时并行下载 `<script>` 元素加载的外部脚本。
4. 浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。

有了 `defer` 属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在 `DOMContentLoaded` 事件触发前执行（即刚刚读取完 `</html>` 标签），而且可以保证执行顺序就是它们在页面上出现的顺序。

- 对于内置而不是加载外部脚本的 `script` 标签，以及动态生成的 `script` 标签，`defer` 属性不起作用。
- 使用 `defer` 加载的外部脚本不应该使用 `document.write` 方法。

#### 2.3 async 属性

`async` 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。

1. 浏览器开始解析 HTML 网页。
2. 解析过程中，发现带有 `async` 属性的 `script` 标签。
3. 浏览器继续往下解析 HTML 网页，同时并行下载 `<script>` 标签中的外部脚本。
4. 脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。
5. 脚本执行完毕，浏览器恢复解析 HTML 网页。

`async` 属性可以保证脚本下载的同时，浏览器继续渲染。

- 一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。
- 使用 `async` 属性的脚本文件里面的代码，不应该使用 `document.write` 方法。

一般来说，如果脚本之间没有依赖关系，就使用 `async` 属性，如果脚本之间有依赖关系，就使用 `defer` 属性。如果同时使用 `async` 和 `defer` 属性，后者不起作用，浏览器行为由 `async` 属性决定。

#### 2.4 脚本的动态加载

`<script>` 元素还可以动态生成，这种方法的好处是，动态生成的 `script` 标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。可以通过设置 `async` 属性为 `false` 解决这个问题。

```javascript
['a.js', 'b.js'].forEach(function(src) {
  var script = document.createElement('script');
  script.src = src;
  script.async = false;
  document.head.appendChild(script);
});
```

#### 2.5 加载使用的协议

如果不指定协议，浏览器默认采用 HTTP 协议下载。如果要采用 HTTPS 协议下载，必需写明。但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。

```javascript
<script src="//example.js"></script>
```

### 3. 浏览器的组成

浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。

#### 3.1 渲染引擎

渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。

渲染引擎处理网页，通常分成四个阶段。

1. 解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。
2. 对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。
3. 布局：计算出渲染树的布局（layout）。
4. 绘制：将渲染树绘制到屏幕。

以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。

#### 3.2 重流和重绘

渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。

页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（`a:hover`）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。

重流和重绘并不一定一起发生，**重流必然导致重绘，重绘不一定需要重流**。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。

大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。

作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘 `table` 布局和 `flex` 布局，开销都会比较大。

下面是一些优化技巧。

- 读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。
- 缓存 DOM 信息。
- 不要一项一项地改变样式，而是使用 CSS `class` 一次性改变样式。
- 使用 `documentFragment` 操作 DOM
- 动画使用 `absolute` 定位或 `fixed` 定位，这样可以减少对其他元素的影响。
- 只在必要时才显示隐藏元素。
- 使用 `window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。
- 使用虚拟 DOM（virtual DOM）库。

#### 3.3 JavaScript 引擎

JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。

JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。

为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。

早期，浏览器内部对 JavaScript 的处理过程如下：

1. 读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。
2. 对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。
3. 使用“翻译器”（translator），将代码转为字节码（bytecode）。
4. 使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。

逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。

字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。

## 二、window 对象

### 1. 概述

浏览器里面，`window` 对象指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。

### 2. window 对象的属性

#### 2.1 通用属性

- `window.name` 属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的 `target` 属性使用。
- `window.closed` 属性返回一个布尔值，表示窗口是否关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。

  ```javascript
  var popup = window.open();
  if ((popup !== null) && !popup.closed) {
    // 窗口仍然打开着
  }
  ```

- `window.opener` 属性表示打开当前窗口的**父窗口**。

  如果两个窗口之间不需要通信，建议将子窗口的 `opener` 属性显式设为 `null`，这样可以减少一些安全隐患。

  ```javascript
  var newWin = window.open('example.html', 'newWindow', 'height=400,width=400');
  newWin.opener = null;
  ```

  通过 `opener` 属性，可以获得父窗口的全局属性和方法，但只限于两个窗口**同源**的情况，且其中一个窗口由另一个打开。`<a>` 元素添加 `rel="noopener"` 属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。

  ```html
  <a href="https://an.evil.site" target="_blank" rel="noopener">
  恶意网站
  </a>
  ```

- `window.self` 和 `window.window` 属性都指向窗口（`window`）本身。这两个属性只读。
- `window.frames` 属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括 `frame` 元素和 `iframe` 元素。

  `window.frames[0]` 表示页面中第一个框架窗口。

  如果 `iframe` 元素设置了 `id` 或 `name` 属性，那么就可以用属性值，引用这个 `iframe` 窗口。比如 `<iframe name="myIFrame">` 可以用 `frames['myIFrame']` 或者 `frames.myIFrame` 来引用。

  `frames` 属性实际上是 `window` 对象的别名。

  ```javascript
  frames === window // true
  ```

  因此，`frames[0]` 也可以用 `window[0]` 表示。但是，从语义上看，`frames` 更清晰，而且考虑到 `window` 还是全局对象，因此推荐表示多窗口时，总是使用 `frames[0]` 的写法。

- `window.length` 属性返回当前网页包含的框架总数。如果当前网页不包含 `frame` 和 `iframe` 元素，那么 `window.length` 就返回 0。
- `window.frameElement` 属性主要用于当前窗口嵌在另一个网页的情况（嵌入 `<object>`、`<iframe>` 或 `<embed>` 元素），返回当前窗口所在的那个元素节点。

  ```javascript
  // HTML 代码如下
  // <iframe src="about.html"></iframe>

  // 下面的脚本在 about.html 里面
  var frameEl = window.frameElement;
  if (frameEl) {
    frameEl.src = 'other.html';
  }
  ```

  上面代码中，`frameEl` 变量就是 `<iframe>` 元素。

- `window.top` 属性指向**最顶层窗口**，主要用于在框架窗口（`frame`）里面获取顶层窗口。
- `window.parent` 属性指向**父窗口**。如果当前窗口没有父窗口，`window.parent` 指向自身。
- `window.status` 属性用于读写浏览器状态栏的文本。很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。
- `window.devicePixelRatio` 属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。它表示一个 CSS 像素由多少个物理像素组成。

#### 2.2 位置大小属性

- `window.screenX` 和 `window.screenY` 属性：返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。
- `window.innerHeight` 和 `window.innerWidth` 属性：返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。

  用户放大网页的时候（比如将网页从 100% 的大小放大为 200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是 960px），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。注意，这两个属性值包括滚动条的高度和宽度。

- `window.outerHeight` 和 `window.outerWidth` 属性：返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。
- `window.scrollX` 和 `window.scrollY` 属性返回页面的水平/垂直滚动距离，单位都为像素。这两个属性只读。
- `window.pageXOffset` 和 `window.pageYOffset` 属性是 `window.scrollX` 和 `window.scrollY` 别名。

#### 2.3 组件属性

组件属性返回浏览器的组件对象。这样的属性有下面几个。

- `window.locationbar`：地址栏对象
- `window.menubar`：菜单栏对象
- `window.scrollbars`：窗口的滚动条对象
- `window.toolbar`：工具栏对象
- `window.statusbar`：状态栏对象
- `window.personalbar`：用户安装的个人工具栏对象

这些对象的 `visible` 属性是一个布尔值，表示这些组件是否可见。这些属性只读。

#### 2.4 全局对象属性

全局对象属性指向一些浏览器原生的全局对象。

- `window.document`：指向 `document` 对象。注意，这个属性有同源限制。只有来自**同源**的脚本才能读取这个属性。
- `window.location`：指向 `Location` 对象，用于获取当前窗口的 URL 信息。它等同于 `document.location` 属性。
- `window.navigator`：指向 `Navigator` 对象，用于获取**环境信息**。
- `window.history`：指向 `History` 对象，表示浏览器的浏览历史。
- `window.localStorage`：指向本地储存的 `localStorage` 数据。
- `window.sessionStorage`：指向本地储存的 `sessionStorage` 数据。
- `window.console`：指向 `console` 对象，用于操作控制台。
- `window.screen`：指向 `Screen` 对象，表示屏幕信息。

#### 2.5 window.isSecureContext

`window.isSecureContext` 属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是 `true`，否则就是 `false`。

### 3. window 对象的方法

#### 3.1 window.alert()，window.prompt()，window.confirm()

window.alert()、window.prompt()、window.confirm() 都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。

- `window.alert(message)` 方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。无返回值。
- `window.confirm(message)` 方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。返回一个布尔值，表示是否选择了确定（`true`）还是取消（`false`）。
- `window.prompt(message, defaultValue)` 方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。返回一个包含用户输入文本的字符串，或 `null`。

#### 3.2 window.open(), window.close()，window.stop()

- `window.open(url, target, [windowFeatures])` 方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用。

  - url：字符串，表示新窗口的网址。如果省略，默认网址就是 `about:blank`。
  - target：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用 `_blank`，表示新建一个没有名字的窗口。另外还有几个预设值，`_self` 表示当前窗口，`_top` 表示顶层窗口，`_parent` 表示上一层窗口。
  - `windowFeatures`：字符串，内容为逗号分隔的键值对，表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。关于此参数支持的配置项，请参考 [windowfeatures 属性](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open#windowfeatures)。

- `window.close()` 方法用于关闭当前窗口，一般只用来关闭 `window.open` 方法新建的窗口。该方法只对顶层窗口有效，`iframe` 框架之中的窗口使用该方法无效。
- `window.stop()` 方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。

#### 3.3 window.moveTo()，window.moveBy()

- `window.moveTo(x, y)` 方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。
- `window.moveBy(deltaX, deltaY)` 方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。

为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用 `window.open()` 方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。

#### 3.4 window.resizeTo()，window.resizeBy()

- `window.resizeTo(aWidth, aHeight)` 方法用于缩放窗口到指定大小。它接受两个参数，第一个是缩放后的窗口宽度（`aWidth` 属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（`aHeight` 属性）。
- `window.resizeBy(xDelta, yDelta)` 方法用于缩放窗口。它与 `window.resizeTo()` 的区别是，它按照相对的量缩放，`window.resizeTo()` 需要给出缩放后的绝对大小。它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。

#### 3.5 window.scrollTo()，window.scroll()，window.scrollBy()

- `window.scrollTo(x-coord, y-coord)` | `window.scrollTo(options)` 方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。它也可以接受一个配置对象作为参数，配置对象 `options` 有三个属性。

  - `top`：滚动后页面左上角的垂直坐标，即 `y` 坐标。
  - `left`：滚动后页面左上角的水平坐标，即 `x` 坐标。
  - `behavior`：字符串，表示滚动的方式，有三个可能值（`smooth`、`instant`、`auto`），默认值为 `auto`。

- `window.scrollBy(x-coord, y-coord)` | `window.scrollBy(options)` 方法用于将网页滚动指定距离（单位像素）。
- `window.scroll(x-coord, y-coord)` | `window.scroll(options)` 方法是 `window.scrollTo()` 方法的别名。

如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。

- `Element.scrollTop`
- `Element.scrollLeft`
- `Element.scrollIntoView()`

#### 3.6 window.print()

`window.print()` 方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。

#### 3.7 window.focus()，window.blur()

- `window.focus()` 方法会激活窗口，使其获得焦点，出现在其他窗口的前面。
- `window.blur()` 方法将焦点从窗口移除。

#### 3.8 window.getSelection()

`window.getSelection()` 方法返回一个 `Selection` 对象，表示用户现在选中的文本。使用 `Selection` 对象的 `toString()` 方法可以得到选中的文本。

```javascript
var selObj = window.getSelection();
var selectedText = selObj.toString();
```

#### 3.9 window.getComputedStyle()，window.matchMedia()

- `window.getComputedStyle(element, pseudoElt)` 方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象。
- `window.matchMedia(mediaQueryString)` 方法用来检查 CSS 的 `mediaQuery` 语句。

#### 3.10 window.requestAnimationFrame()

`window.requestAnimationFrame()` 方法跟 `setTimeout` 类似，都是推迟某个函数的执行。不同之处在于，`setTimeout` 必须指定推迟的时间，`window.requestAnimationFrame()` 则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，`requestAnimationFrame()` 会暂停执行。

如果某个函数会改变网页的布局，一般就放在 `window.requestAnimationFrame()` 里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。

该方法接受一个回调函数作为参数。

```javascript
window.requestAnimationFrame(callback)
```

上面代码中，`callback` 是一个回调函数。`callback` 执行时，它的参数就是系统传入的一个高精度时间戳（`performance.now()` 的返回值），单位是毫秒，表示距离网页加载的时间。

`window.requestAnimationFrame()` 的返回值是一个整数，这个整数可以传入 `window.cancelAnimationFrame()`，用来取消回调函数的执行。

下面是一个 `window.requestAnimationFrame()` 执行网页动画的例子。

```javascript
var element = document.getElementById('animate');
element.style.position = 'absolute';

var start = null;

function step(timestamp) {
  if (!start) start = timestamp;
  var progress = timestamp - start;
  // 元素不断向右移，最大不超过200像素
  element.style.left = Math.min(progress / 10, 200) + 'px';
  // 如果距离第一次执行不超过 2000 毫秒，
  // 就继续执行动画
  if (progress < 2000) {
    window.requestAnimationFrame(step);
  }
}

window.requestAnimationFrame(step);
```

上面代码定义了一个网页动画，持续时间是 2 秒，会让元素向右移动。

#### 3.11 window.requestIdleCallback()

`window.requestIdleCallback()` 跟 `setTimeout` 类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用 `window.requestIdleCallback()` 将其推迟执行，以保证网页性能。

它跟 `window.requestAnimationFrame()` 的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在 16ms 之内完成；`window.requestIdleCallback()` 可以保证回调函数在系统资源空闲时执行。

该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。

```javascript
window.requestIdleCallback(callback[, options])
```

`callback` 参数是一个回调函数。该回调函数执行时，系统会传入一个 `IdleDeadline` 对象作为参数。`IdleDeadline` 对象有一个 `didTimeout` 属性（布尔值，表示是否为超时调用）和一个 `timeRemaining()` 方法（返回该空闲时段剩余的毫秒数）。

`options` 参数是一个配置对象，目前只有 `timeout` 一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。

`window.requestIdleCallback()` 方法返回一个整数。该整数可以传入 `window.cancelIdleCallback()` 取消回调函数。

下面是一个例子。

```javascript
requestIdleCallback(myNonEssentialWork);

function myNonEssentialWork(deadline) {
  while (deadline.timeRemaining() > 0) {
    doWorkIfNeeded();
  }
}
```

上面代码中，`requestIdleCallback()` 用来执行非关键任务 `myNonEssentialWork`。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。

下面是指定 `timeout` 的例子。

```javascript
requestIdleCallback(processPendingAnalyticsEvents, { timeout: 2000 });
```

上面代码指定，`processPendingAnalyticsEvents` 必须在未来 2 秒之内执行。

如果由于超时导致回调函数执行，则 `deadline.timeRemaining()` 返回 `0`，`deadline.didTimeout` 返回 `true`。

如果多次执行 `window.requestIdleCallback()`，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。

### 4. 事件

#### 4.1 load 事件和 onload 属性

load 事件发生在文档在浏览器窗口加载完毕时。window.onload 属性可以指定这个事件的回调函数。

#### 4.2 error 事件和 onerror 属性

error 事件发生在浏览器脚本发生错误时，window.onerror 属性可以指定该事件的回调函数。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。

#### 4.3 window 对象的事件监听属性

除了具备元素节点都有的 GlobalEventHandlers 接口，`window` 对象还具有以下的事件监听函数属性。

- `window.onafterprint`：`afterprint`事件的监听函数。
- `window.onbeforeprint`：`beforeprint` 事件的监听函数。
- `window.onbeforeunload`：`beforeunload` 事件的监听函数。
- `window.onhashchange`：`hashchange` 事件的监听函数。
- `window.onlanguagechange`: `languagechange` 的监听函数。
- `window.onmessage`：`message` 事件的监听函数。
- `window.onmessageerror`：`MessageError` 事件的监听函数。
- `window.onoffline`：`offline` 事件的监听函数。
- `window.ononline`：`online` 事件的监听函数。
- `window.onpagehide`：`pagehide` 事件的监听函数。
- `window.onpageshow`：`pageshow` 事件的监听函数。
- `window.onpopstate`：`popstate` 事件的监听函数。
- `window.onstorage`：`storage` 事件的监听函数。
- `window.onunhandledrejection`：未处理的 `Promise` 对象的 `reject` 事件的监听函数。
- `window.onunload`：`unload` 事件的监听函数。

### 5. 多窗口操作

由于网页可以使用 `iframe` 元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。

#### 5.1 窗口的引用

各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。

- `top`：顶层窗口，即最上层的那个窗口
- `parent`：父窗口
- `self`：当前窗口，即自身

与这些变量对应，浏览器还提供一些特殊的窗口名，供 `window.open()` 方法、`<a>` 标签、`<form>` 标签等引用。

- `_top`：顶层窗口
- `_parent`：父窗口
- `_blank`：新窗口

```javascript
<a href="somepage.html" target="_top">Link</a>
```

上面代码就表示在顶层窗口打开链接。

#### 5.2 iframe 元素

对于 `iframe` 嵌入的窗口，`document.getElementById` 方法可以拿到该窗口的 DOM 节点，然后使用 `contentWindow` 属性获得 `iframe` 节点包含的 `window` 对象。

`<iframe>` 元素的 `contentDocument` 属性，可以拿到子窗口的 `document` 对象。

`<iframe>` 元素遵守**同源策略**，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用 `window.postMessage` 方法。

`<iframe>` 窗口内部，使用 `window.parent` 引用父窗口。如果当前页面没有父窗口，则 `window.parent` 属性返回自身。因此，可以通过 `window.parent` 是否等于 `window.self`，判断当前窗口是否为 `iframe` 窗口。

```javascript
if (window.parent !== window.self) {
  // 当前窗口是子窗口
}
```

`<iframe>` 窗口的 `window` 对象，有一个 `frameElement` 属性，返回 `4` 在父窗口中的 DOM 节点。

#### 5.3 window.frames 属性

`window.frames` 属性返回一个类似数组的对象，成员是所有子窗口的 `window` 对象。可以使用这个属性，实现窗口之间的互相引用。比如，`frames[0]` 返回第一个子窗口，`frames[1].frames[2]`返 回第二个子窗口内部的第三个子窗口。

注意，`window.frames` 每个成员的值，是框架内的窗口（即框架的 `window` 对象），而不是 `iframe` 标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用 `window.frames[0].document` 的写法。

另外，如果 `<iframe>` 元素设置了 `name` 或 `id` 属性，那么属性值会自动成为全局变量，并且可以通过 `window.frames` 属性引用，返回子窗口的 `window` 对象。

## 三、Navigator 对象，Screen 对象

`window.navigator` 属性指向一个包含浏览器和系统信息的 Navigator 对象。脚本通过这个属性了解用户的环境信息。

### 1. Navigator 对象的属性

- `navigator.userAgent` 属性返回浏览器的 User Agent 字符串，表示用户**设备信息**，包含了浏览器的厂商、版本、操作系统等信息。

  下面是 Chrome 浏览器的 userAgent。

  ```javascript
  navigator.userAgent
  // "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36"
  ```

  通过 `userAgent` 属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。不过，通过 `userAgent` 可以大致准确地识别手机浏览器，方法就是测试是否包含 `mobi` 字符串。

- `Navigator.plugins` 属性返回一个类似数组的对象，成员是 Plugin 实例对象，表示浏览器安装的插件，比如 Flash、ActiveX 等。
- `Navigator.platform` 属性返回用户的操作系统信息，比如 MacIntel、Win32、Linux x86_64 等。
- `Navigator.onLine` 属性返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。用户变成在线会触发 `online` 事件，变成离线会触发 `offline` 事件，可以通过 `window.ononline` 和 `window.onoffline` 指定这两个事件的回调函数。
- `Navigator.language` 属性返回一个字符串，表示浏览器的首选语言。该属性只读。
- `Navigator.languages` 属性返回一个数组，表示用户可以接受的语言。`Navigator.language` 总是这个数组的第一个成员。HTTP 请求头信息的 Accept-Language 字段，就来自这个数组。
- `Navigator.geolocation` 属性返回一个 Geolocation 对象，包含用户地理位置的信息。注意，该 API 只有在 HTTPS 协议下可用。
- `Navigator.cookieEnabled` 属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。注意，这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关。

### 2. Navigator 对象的方法

- `Navigator.javaEnabled()` 方法返回一个布尔值，表示浏览器是否能运行 Java Applet 小程序。注意，该方法目前[已弃用](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/javaEnabled)。
- `Navigator.sendBeacon(url, data)` 方法用于向服务器异步发送数据。

### 3. Screen 对象

Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。`window.screen` 属性指向这个对象。

- `Screen.height`：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。
- `Screen.width`：浏览器窗口所在的屏幕的宽度（单位像素）。
- `Screen.availHeight`：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于 `height` 减去那些被系统组件的高度。
- `Screen.availWidth`：浏览器窗口可用的屏幕宽度（单位像素）。
- `Screen.pixelDepth`：整数，表示屏幕的色彩位数，比如 24 表示屏幕提供 24 位色彩。
- `Screen.colorDepth`：`Screen.pixelDepth` 的别名。严格地说，`colorDepth` 表示应用程序的颜色深度，`pixelDepth` 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。
- `Screen.orientation`：返回一个对象，表示屏幕的方向。该对象的 `type` 属性是一个字符串，表示屏幕的具体方向。
  - `landscape-primary` 表示横放。
  - `landscape-secondary` 表示颠倒的横放。
  - `portrait-primary` 表示竖放。
  - `portrait-secondary` 表示颠倒的竖放。

## 四、Cookie

### 1. 概述

**Cookie 是服务器保存在浏览器的一小段文本信息**，一般大小不能超过 4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。

HTTP 协议不带有状态，有些请求需要区分状态，就通过 Cookie 附带字符串，让服务器返回不一样的回应。举例来说，用户登录以后，服务器往往会在网站上留下一个 Cookie，记录用户编号（比如 `id=1234`），以后每次浏览器向服务器请求数据，就会带上这个字符串，服务器从而知道是谁在请求，应该回应什么内容。

**Cookie 的目的就是区分用户，以及放置状态信息**，它的使用场景主要如下。

- 对话（session）管理：保存登录状态、购物车等需要记录的信息。
- 个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。
- 追踪用户：记录和分析用户行为。

Cookie 不是一种理想的客户端存储机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端存储建议使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。

每个 Cookie 都有以下几方面的元数据。

- Cookie 的名字
- Cookie 的值（真正的数据写在这里面）
- 到期时间（超过这个时间会失效）
- 所属域名（默认为当前域名）
- 生效的路径（默认为当前网址）

举例来说，用户访问网址 `www.example.com`，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为 `www.example.com`，生效路径为根路径 `/`。

如果 Cookie 的生效路径设为 `/forums`，那么这个 Cookie 只有在访问 `www.example.com/forums` 及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。

`window.navigator.cookieEnabled` 属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。`document.cookie` 属性返回当前网页的 Cookie。

```javascript
window.navigator.cookieEnabled // true
document.cookie // "id=foo;key=bar"
```

- 一般来说，单个域名设置的 Cookie 不应超过 30 个，每个 Cookie 的大小不能超过 4KB。超过限制以后，Cookie 将被忽略，不会被设置。
- Cookie 是按照域名区分的，`foo.com` 只能读取自己放置的 Cookie，无法读取其他网站（比如 `bar.com`）放置的 Cookie。一般情况下，一级域名也不能读取二级域名留下的 Cookie，比如 `mydomain.com` 不能读取 `subdomain.mydomain.com` 设置的 Cookie。但是有一个例外，设置 Cookie 的时候（不管是一级域名设置的，还是二级域名设置的），明确将 `domain` 属性设为一级域名，则这个域名下面的各级域名可以共享这个 Cookie。
- 区分 Cookie 时不考虑协议和端口。

### 2. Cookie 与 HTTP 协议

#### 2.1 HTTP 回应：Cookie 的生成

服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个 `Set-Cookie` 字段。HTTP 回应可以包含多个 `Set-Cookie` 字段，即在浏览器生成多个 Cookie。

如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的 `key`、`domain`、`path` 和 `secure` 都匹配。只要有一个属性不同，就会生成一个全新的 Cookie。

```http
Set-Cookie: key1=value1; domain=example.com; path=/blog
```

#### 2.2 HTTP 请求：Cookie 的发送

浏览器向服务器发送 HTTP 请求时，可以带上相应的 Cookie。`Cookie` 字段可以包含多个 Cookie，使用分号（`;`）分隔。

```http
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

### 3. Cookie 的属性

#### 3.1 Expires，Max-Age

- `Expires` 属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用 `Date.prototype.toUTCString()` 进行格式转换。如果不设置该属性，或者设为 `null`，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据**本地时间**，决定 Cookie 是否过期，而本地时间是不精确的。
- `Max-Age` 属性指定从现在开始 Cookie 存在的秒数，比如 `60 * 60 * 24 * 365`（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。

如果同时指定了 `Expires` 和 `Max-Age`，那么 `Max-Age` 的值将优先生效。

#### 3.2 Domain，Path

- `Domain` 属性指定 Cookie 属于哪个域名，以后浏览器向服务器发送 HTTP 请求时，通过这个属性判断是否要附带某个 Cookie。

  `Domain` 属性只能是当前域名或者当前域名的上级域名，但设为上级域名时，**不能设为顶级域名或公共域名**。举例来说，当前域名为 `x.y.z.com`，那么 `Domain` 属性可以设为 `x.y.z.com`，或者 `y.z.com`，或者 `z.com`，但不能设为 `foo.x.y.z.com`，或者 `another.domain.com`。另一个例子是，当前域名为 `wangdoc.github.io`，则 `Domain` 属性只能设为 `wangdoc.github.io`，不能设为 `github.io`，因为后者是一个公共域名。

- `Path` 属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。

#### 3.3 Secure，HttpOnly

- `Secure` 属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。
- `HttpOnly` 属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是 `document.cookie` 属性、`XMLHttpRequest` 对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。

#### 3.4 SameSite

Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 **CSRF 攻击**。

这种第三方网站引导而附带发送的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。比如，Facebook 在第三方网站插入一张看不见的图片。

```html
<img src="facebook.com" style="visibility:hidden;">
```

浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。

Cookie 的 `SameSite` 属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值：`Strict`、`Lax` 和 `None`。

##### （1）Strict

`Strict` 最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。只有当前网页的 URL 与请求目标一致，才会带上 Cookie。这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。

```http
Set-Cookie: CookieName=CookieValue; SameSite=Strict;
```

##### （2）Lax

`Lax` 规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

```http
Set-Cookie: CookieName=CookieValue; SameSite=Lax;
```

导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。设置了 `Strict` 或 `Lax` 以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 `SameSite` 属性。

| 请求类型 | 正常情况 | Lax | 示例 |
| :-: | :-: | :-: | :-: |
| 链接 | 发送 Cookie | 发送 Cookie | `<a href="..."></a>` |
| 预加载 | 发送 Cookie | 发送 Cookie | `<link rel="prerender" href="..."/>` |
| GET 表单 | 发送 Cookie | 发送 Cookie | `<form method="GET" action="...">` |
| POST 表单 | 发送 Cookie | 不发送 | `<form method="POST" action="...">` |
| iframe | 发送 Cookie | 不发送 | `<iframe src="..."></iframe>` |
| AJAX | 发送 Cookie | 不发送 | `$.get("...")` |
| Image | 发送 Cookie | 不发送 | `<img src="...">` |

##### （3）None

网站可以选择显式关闭 `SameSite` 属性，将其设为 `None`。不过，前提是必须同时设置 `Secure` 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

### 4. document.cookie

`document.cookie` 属性用于读写当前网页的 Cookie。document.cookie 一次只能写入一个 Cookie，而且写入并不是覆盖，而是**添加**。写入的时候，Cookie 的值必须写成 `key=value` 的形式。

浏览器向服务器发送 Cookie 的时候，`Cookie` 字段是使用一行将所有 Cookie 全部发送；服务器向浏览器设置 Cookie 的时候，`Set-Cookie` 字段是一行设置一个 Cookie。

删除一个现存 Cookie 的唯一方法，是设置它的 `expires` 属性为一个过去的日期。

## 五、XMLHttpRequest 对象

### 1. 简介

AJAX 是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。AJAX 指通过 JavaScript 脚本发起 HTTP 通信。

XMLHttpRequest 对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。它实可以使用多种协议（比如 `file` 或 `ftp`），发送任何格式的数据（包括字符串和二进制）。

```javascript
var xhr = new XMLHttpRequest();

xhr.onreadystatechange = handleStateChange;
function handleStateChange() {
  // ...
}

xhr.onerror = function (e) {
  console.error(xhr.statusText);
};

// 第三个参数true，表示请求是异步的。
xhr.open('GET', 'http://www.example.com/page.php', true);

// 使用 send() 方法，实际发出请求。
xhr.send(null);
```

注意，AJAX 只能向**同源**网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错。

### 2. XMLHttpRequest 的实例属性

#### 2.1 XMLHttpRequest.readyState

`XMLHttpRequest.readyState` 返回一个整数，表示实例对象的当前状态。该属性只读。通信过程中，每当实例对象发生状态变化，它的 `readyState` 属性的值就会改变。这个值每次变化，都会触发 `readyStateChange` 事件。它可能返回以下值。

- `0` 表示 XMLHttpRequest 实例已经生成，但是实例的 `open()` 方法还没有被调用。
- `1` 表示 `open()` 方法已经调用，但是实例的 `send()` 方法还没有调用，仍然可以使用实例的 `setRequestHeader()` 方法，设定 HTTP 请求的头信息。
- `2` 表示实例的 `send()` 方法已经调用，并且服务器返回的头信息和状态码已经收到。
- `3` 表示正在接收服务器传来的数据体（`body` 部分）。这时，如果实例的 `responseType` 属性等于 `text` 或者空字符串，`responseText` 属性就会包含已经收到的部分信息。
- `4` 表示服务器返回的数据已经完全接收，或者本次接收已经失败。

#### 2.2 XMLHttpRequest.onreadystatechange

`XMLHttpRequest.onreadystatechange` 属性指向一个监听函数。`readystatechange` 事件发生时（实例的 `readyState` 属性变化），就会执行这个属性。

#### 2.3 XMLHttpRequest.response

`XMLHttpRequest.response` 属性表示服务器返回的数据体（即 HTTP 回应的 `body` 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由 `XMLHttpRequest.responseType` 属性决定。该属性只读。

#### 2.4 XMLHttpRequest.responseType

`XMLHttpRequest.responseType` 属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用 `open()` 方法之后、调用 `send()` 方法之前，设置这个属性的值，告诉浏览器如何解读返回的数据。如果 `responseType` 设为空字符串，就等同于默认值text。

`XMLHttpRequest.responseType` 属性可以等于以下值。

- 空字符串：等同于 `text`，表示服务器返回文本数据。
- `arraybuffer`：`ArrayBuffer` 对象，表示服务器返回二进制数组。
- `blob`：`Blob` 对象，表示服务器返回二进制对象。
- `document`：`Document` 对象，表示服务器返回一个文档对象。
- `json`：`JSON` 对象。
- `text`：字符串。

#### 2.5 XMLHttpRequest.responseText

`XMLHttpRequest.responseText` 属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。

#### 2.6 XMLHttpRequest.responseXML

`XMLHttpRequest.responseXML` 属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。

该属性生效的前提是 HTTP 回应的 `Content-Type` 头信息等于 `text/xml` 或 `application/xml`。这要求在发送请求前，`XMLHttpRequest.responseType` 属性要设为 `document`。如果 HTTP 回应的 `Content-Type` 头信息不等于 `text/xml` 和 `application/xml`，但是想从 `responseXML` 拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用 `XMLHttpRequest.overrideMimeType()` 方法，强制进行 XML 解析。

该属性得到的数据，是直接解析后的文档 DOM 树。

#### 2.7 XMLHttpRequest.responseURL

`XMLHttpRequest.responseURL` 属性是字符串，表示发送数据的服务器的网址。

#### 2.8 XMLHttpRequest.status，XMLHttpRequest.statusText

- `XMLHttpRequest.status` 属性返回一个整数，表示服务器回应的 HTTP 状态码。

  - `200`, OK，访问正常
  - `301`, Moved Permanently，永久移动
  - `302`, Moved temporarily，暂时移动
  - `304`, Not Modified，未修改
  - `307`, Temporary Redirect，暂时重定向
  - `401`, Unauthorized，未授权
  - `403`, Forbidden，禁止访问
  - `404`, Not Found，未发现指定网址
  - `500`, Internal Server Error，服务器发生错误

- `XMLHttpRequest.statusText` 属性返回一个字符串，表示服务器发送的状态提示。

#### 2.9 XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout

- `XMLHttpRequest.timeout` 属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于 `0`，就表示没有时间限制。
- `XMLHttpRequestEventTarget.ontimeout` 属性用于设置一个监听函数，如果发生 `timeout` 事件，就会执行这个监听函数。

#### 2.10 事件监听属性

XMLHttpRequest 对象可以对以下事件指定监听函数。

- `XMLHttpRequest.onloadstart`：`loadstart` 事件（HTTP 请求发出）的监听函数
- `XMLHttpRequest.onload`：`load` 事件（请求成功完成）的监听函数
- `XMLHttpRequest.onloadend`：`loadend` 事件（请求完成，不管成功或失败）的监听函数
- `XMLHttpRequest.onprogress`：`progress` 事件（正在发送和加载数据）的监听函数
- `XMLHttpRequest.ontimeout`：`timeout` 事件（用户指定的时限超过了，请求还未完成）的监听函数
- `XMLHttpRequest.onabort`：`abort` 事件（请求中止，比如用户调用了 `abort()` 方法）的监听函数
- `XMLHttpRequest.onerror`：`error` 事件（请求失败）的监听函数

#### 2.11 XMLHttpRequest.withCredentials

`XMLHttpRequest.withCredentials` 属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为 `false`。

如果需要跨域 AJAX 请求发送 Cookie，需要 `withCredentials` 属性设为 `true`。服务器还必须显式返回 `Access-Control-Allow-Credentials` 这个头信息。

#### 2.12 XMLHttpRequest.upload

通过 XMLHttpRequest 发送文件之后，通过 `XMLHttpRequest.upload` 属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：`loadstart`、`loadend`、`load`、`abort`、`error`、`progress`、`timeout`。

### 3. XMLHttpRequest 的实例方法

#### 3.1 XMLHttpRequest.open()

`XMLHttpRequest.open(method, url, async, user, password)` 方法用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。

```javascript
void open(
  string method,
  string url,
  optional boolean async,
  optional string user,
  optional string password
);
```

#### 3.2 XMLHttpRequest.send()

`XMLHttpRequest.send(body)` 方法用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。

`send` 方法的参数 `body` 可以接受多种格式的数据。

```javascript
void send();
void send(ArrayBufferView data);
void send(Blob data);
void send(Document data);
void send(String data);
void send(FormData data);
```

#### 3.3 XMLHttpRequest.setRequestHeader()

`XMLHttpRequest.setRequestHeader(header, value)` 方法用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在 `open()` 之后、`send()` 之前调用。

```javascript
xhr.setRequestHeader('Content-Type', 'application/json');
```

#### 3.4 XMLHttpRequest.overrideMimeType()

`XMLHttpRequest.overrideMimeType(mimeType)` 方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是 `text/xml`，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成 `text/plain`，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。

```javascript
xhr.overrideMimeType('text/plain')
```

注意，该方法必须在 `send()` 方法之前调用。

修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用 `responseType` 属性告诉服务器，就像下面的例子。只有在服务器无法返回某种数据类型时，才使用 `overrideMimeType()` 方法。

```javascript
var xhr = new XMLHttpRequest();
xhr.onload = function(e) {
  var arraybuffer = xhr.response;
  // ...
}
xhr.open('GET', url);
xhr.responseType = 'arraybuffer';
xhr.send();
```

#### 3.5 XMLHttpRequest.getResponseHeader()，XMLHttpRequest.getAllResponseHeaders()

- `XMLHttpRequest.getResponseHeader(name)` 方法返回 HTTP 响应中头信息指定字段的值。
- `XMLHttpRequest.getAllResponseHeaders()` 方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。

#### 3.6 XMLHttpRequest.abort()

`XMLHttpRequest.abort()` 方法用来终止已经发出的 HTTP 请求。调用这个方法以后，`readyState` 属性变为 `4`，`status` 属性变为 `0`。

### 4. XMLHttpRequest 实例的事件

- `readyState` 属性的值发生改变，就会触发 readyStateChange 事件。可以通过 `onReadyStateChange` 属性，指定这个事件的监听函数。
- 上传文件时，XMLHttpRequest 实例对象本身和实例的 `upload` 属性，都有一个 `progress` 事件，会不断返回上传的进度。

  ```javascript
  var xhr = new XMLHttpRequest();

  xhr.addEventListener('progress', function (oEvent) {
    if (oEvent.lengthComputable) {
      var percentComplete = oEvent.loaded / oEvent.total;
    } else {
      console.log('无法计算进展');
    }
  });

  xhr.open();
  ```

- `load` 事件表示服务器传来的数据接收完毕，`error` 事件表示请求出错，`abort` 事件表示请求被中断（比如用户取消请求）。
- `abort`、`load` 和 `error` 这三个事件，会伴随一个 `loadend` 事件，表示请求结束，但不知道其是否成功。

  ```javascript
  xhr.addEventListener('loadend', function (e) {
    console.log('请求结束，状态未知');
  });
  ```

- 服务器超过指定时间还没有返回结果，就会触发 `timeout` 事件。

### 5. Navigator.sendBeacon()

用户卸载网页的时候，有时需要向服务器发一些数据。如果使用 `unload` 事件或 `beforeunload` 事件的监听函数，或者使用 `setTimeout()`，会导致很多问题。为此，浏览器引入了 `Navigator.sendBeacon(url, data)` 方法。这个方法还是**异步**发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。

```javascript
window.addEventListener('unload', function () {
  var succeed = navigator.sendBeacon('/log', JSON.stringify({
    some: "data"
  }));
}, false);
```

`Navigator.sendBeacon(url, data)` 方法的返回值是一个布尔值，成功发送数据为 `true`，否则为 `false`。

**该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据**。它不能指定回调函数。这个方法的优先级较低，不会占用页面资源。一般是在浏览器空闲的时候，才会发送。

## 六、同源限制

### 1. 概述

同源指协议、域名和端口都相同的地址。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

对于非同源，共有三种行为受到限制。

- 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
- 无法接触非同源网页的 DOM。
- 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

### 2. Cookie

Cookie 是服务器写入浏览器的一小段信息，只有**同源**的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置 `document.domain` 共享 Cookie。

举例来说，A 网页的网址是 `http://w1.example.com/a.html`，B 网页的网址是 `http://w2.example.com/b.html`，那么只要设置相同的 `document.domain`，两个网页就可以共享 Cookie。因为浏览器通过 `document.domain` 属性来检查是否同源。

```javascript
// 两个网页都需要设置
document.domain = 'example.com';
```

注意，A 和 B 两个网页都需要设置 `document.domain` 属性，才能达到同源的目的。因为设置 `document.domain` 的同时，会把端口重置为 `null`，因此如果只设置一个网页的 `document.domain`，会导致两个网址的端口不同，还是达不到同源的目的。这种方法只适用于 Cookie 和 `iframe` 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍 PostMessage API。

另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如 `example.com`。

```http
Set-Cookie: key=value; domain=example.com; path=/
```

这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。

### 3. iframe 和多窗口通信

iframe 窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。

- 片段识别符（fragment identifier）
- 跨文档通信 API（Cross-document messaging）

#### 3.1 片段识别符

**片段标识符**（fragment identifier）指的是，URL 的#号后面的部分。如果只是改变片段标识符，页面不会重新刷新。

父窗口可以把信息，写入子窗口的片段标识符（同样的，子窗口也可以改变父窗口的片段标识符。）。

```javascript
var src = originURL + '#' + data;
document.getElementById('myIFrame').src = src;
```

子窗口通过监听 `hashchange` 事件得到通知。

```javascript
window.onhashchange = function () {
  var message = window.location.hash;
  // ...
};
```

#### 3.2 window.postMessage()

HTML5 引入了跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 `window.postMessage` 方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口 `aaa.com` 向子窗口 `bbb.com` 发消息，调用 `postMessage` 方法就可以了。

```javascript
// 父窗口打开一个子窗口
var popup = window.open('http://bbb.com', 'title');
// 父窗口向子窗口发消息
popup.postMessage('Hello World!', 'http://bbb.com');
```

`postMessage` 方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为 `*`，表示不限制域名，向所有窗口发送（子窗口向父窗口发送消息的写法类似）。

父窗口和子窗口都可以通过 `message` 事件，监听对方的消息。

```javascript
// 父窗口和子窗口都可以用下面的代码监听 message 消息
window.addEventListener('message', function (e) {
  console.log(e.data); // 消息内容
  console.log(e.source); // 发送消息的窗口
  console.log(e.origin); // 消息发送者的源（origin），即协议、域名、端口
},false);
```

#### 3.3 LocalStorage

通过 `window.postMessage` 可以读写其他窗口的 LocalStorage。下面是一个例子。

父窗口发送消息代码如下。

```javascript
var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
// 存入对象
win.postMessage(
  JSON.stringify({key: 'storage', method: 'set', data: obj}),
  'http://bbb.com'
);
// 读取对象
win.postMessage(
  JSON.stringify({key: 'storage', method: "get"}),
  "*"
);
window.onmessage = function(e) {
  if (e.origin != 'http://aaa.com') return;
  console.log(JSON.parse(e.data).name);
};
```

子窗口接收消息的代码如下。

```javascript
window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case 'set':
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case 'get':
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, 'http://aaa.com');
      break;
    case 'remove':
      localStorage.removeItem(payload.key);
      break;
  }
};
```

### 4. AJAX

同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制：JSONP、WebSocket 和 CORS。

#### 4.1 JSONP

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。它的做法如下。

1. 第一步，网页添加一个 `<script>` 元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。请求的脚本网址有一个 `callback` 参数（`?callback=bar`），用来告诉服务器，客户端的回调函数名称（`bar`）。

    ```html
    <script src="http://api.foo.com?callback=bar"></script>
    ```

2. 第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（`bar({...})`）。
3. 第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是 `<script>` 标签请求的脚本内容。这时，客户端只要定义了 `bar()` 函数，就能在该函数体内，拿到服务器返回的 JSON 数据。

下面看一个实例。首先，网页动态插入 `<script>` 元素，由它向跨域网址发出请求。

```javascript
window.onload = function () {
  var script = document.createElement('script');
  script.setAttribute('type', 'text/javascript');
  script.src = 'http://example.com/ip?callback=foo';
  document.body.appendChild(script);
}

function foo(data) {
  console.log('Your public IP address is: ' + data.ip);
};
```

上面代码通过动态添加 `<script>` 元素，向服务器 `example.com` 发出请求。注意，该请求的查询字符串有一个 `callback` 参数，用来指定回调函数的名字，这对于 JSONP 是必需的。

服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。

```javascript
foo({
  'ip': '8.8.8.8'
});
```

由于 `<script>` 元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了 `foo` 函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 `JSON.parse` 的步骤。

JSONP 的缺点是只能发送 GET 请求

#### 4.2 WebSocket

WebSocket 是一种通信协议，使用 `ws://`（非加密）和 `wss://`（加密）作为协议前缀。**该协议不实行同源政策**，只要服务器支持，就可以通过它进行跨源通信。

下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自[维基百科](https://en.wikipedia.org/wiki/WebSocket)）。

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

上面代码中，有一个字段是 `Origin`，表示该请求的请求源（origin），即发自哪个域名。

正是因为有了 `Origin` 这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

#### 4.3 CORS

见下一章。

## 七、CORS 通信

CORS 是一个 W3C 标准，全称是“跨源资源共享”（Cross-origin resource sharing），或者通俗地称为“跨域资源共享”。它允许浏览器向跨源的服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。

### 1. 简介

CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。

整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，**实现 CORS 通信的关键是服务器**。只要服务器实现了 CORS 接口，就可以跨源通信。

### 2. 两种请求

CORS 请求分成两类：**简单请求**（simple request）和**非简单请求**（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

1. 请求方法是以下三种方法之一。

    - `HEAD`
    - `GET`
    - `POST`

2. HTTP 的头信息不超出以下几种字段。

    - `Accept`
    - `Accept-Language`
    - `Content-Language`
    - `Last-Event-ID`
    - `Content-Type`：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。

这样划分的原因是，表单在历史上一直可以跨源发出请求。简单请求就是**表单请求**，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。

### 3. 简单请求

#### 3.1 基本流程

对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 `Origin` 字段，用来说明本次请求来自哪个域（协议 + 域名 + 端口）。

如果 `Origin` 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 `Access-Control-Allow-Origin` 字段，就知道出错了，从而抛出一个错误，被 `XMLHttpRequest` 的 `onerror` 回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 `200`。

如果 `Origin` 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

```http
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
```

- `Access-Control-Allow-Origin` 字段是必须的。它的值要么是请求时 `Origin` 字段的值，要么是一个 `*`，表示接受任意域名的请求。
- `Access-Control-Allow-Credentials` 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 `true`，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为 `true`，如果服务器不要浏览器发送 Cookie，不发送该字段即可。
- `Access-Control-Expose-Headers` 该字段可选。CORS 请求时，XMLHttpRequest 对象的 `getResponseHeader()` 方法只能拿到 6 个服务器返回的基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在 `Access-Control-Expose-Headers` 里面指定。上面的例子指定，`getResponseHeader('FooBar')` 可以返回 `FooBar` 字段的值。

#### 3.2 withCredentials 属性

CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 **CSRF 攻击**的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定 `Access-Control-Allow-Credentials` 字段，告诉浏览器可以发送 Cookie。

```http
Access-Control-Allow-Credentials: true
```

同时，开发者必须在 AJAX 请求中打开 `withCredentials` 属性。否则，即使服务器要求发送 Cookie，浏览器也不会发送。

```javascript
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

### 4. 非简单请求

#### 4.1 预检请求

非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为**预检请求**（preflight）。浏览器先询问服务器，当前网页所在的**域名**是否在服务器的许可名单之中，以及可以使用哪些 **HTTP 方法**和**头信息**字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量 DELETE 和 PUT 请求，这些传统的表单不可能跨源发出的请求。

下面是一段浏览器的 JavaScript 脚本。

```javascript
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```

上面代码中，HTTP 请求的方法是 PUT，并且发送一个自定义头信息 `X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

“预检”请求用的请求方法是 `OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是 `Origin`，表示请求来自哪个源。

除了 `Origin` 字段，“预检”请求的头信息包括两个特殊字段。

- `Access-Control-Request-Method` 字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 `PUT`。
- `Access-Control-Request-Headers` 字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 `X-Custom-Header`。

#### 4.2 预检请求的回应

服务器收到“预检”请求以后，检查了 `Origin`、`Access-Control-Request-Method` 和 `Access-Control-Request-Headers` 字段以后，确认允许跨源请求，就可以做出回应。

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
```

上面的 HTTP 回应中，关键的是 `Access-Control-Allow-Origin` 字段，表示 http://api.bob.com 可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。

```http
OPTIONS http://api.bob.com HTTP/1.1
Status: 200
Access-Control-Allow-Origin: https://notyourdomain.com
Access-Control-Allow-Method: POST
```

这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 `onerror` 回调函数捕获。控制台会打印出如下的报错信息。

```text
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```

服务器回应的其他 CORS 相关字段如下。

- `Access-Control-Allow-Methods` 字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨源请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。
- `Access-Control-Allow-Headers` 如果浏览器请求包括 `Access-Control-Request-Headers` 字段，则 `Access-Control-Allow-Headers` 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。
- `Access-Control-Allow-Credentials` 字段与简单请求时的含义相同。
- `Access-Control-Max-Age` 字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 2 0天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。

### 4.3 浏览器的正常请求和回应

一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 `Origin` 头信息字段。服务器的回应，也都会有一个 `Access-Control-Allow-Origin` 头信息字段。

下面是“预检”请求之后，浏览器的正常 CORS 请求。

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面头信息的 `Origin` 字段是浏览器自动添加的。

下面是服务器正常的回应。

```http
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

上面头信息中，`Access-Control-Allow-Origin` 字段是每次回应都必定包含的。

### 5. 与 JSONP 的比较

CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持 `GET` 请求，CORS 支持所有类型的 HTTP 请求。**JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据**。

## 八、Storage 接口

```javascript
```

```javascript
```

```javascript
```

## 九、History 对象

```javascript
```

```javascript
```

```javascript
```

## 十、Location 对象，URL 对象，URLSearchParams 对象

```javascript
```

```javascript
```

```javascript
```

## 十一、ArrayBuffer 对象，Blob 对象

```javascript
```

```javascript
```

```javascript
```

## 十二、File 对象，FileList 对象，FileReader 对象

```javascript
```

```javascript
```

```javascript
```

## 十三、表单，FormData 对象

```javascript
```

```javascript
```

```javascript
```

## 十四、IndexedDB API

```javascript
```

```javascript
```

```javascript
```

## 十五、Web Worker

```javascript
```

```javascript
```

```javascript
```

## 十六参考

- 阮一峰，[JavaScript 教程 - 浏览器模型](https://wangdoc.com/javascript/bom/)

```javascript
```
