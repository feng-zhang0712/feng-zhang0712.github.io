---
layout: post
title: 《JavaScript 教程》摘录
categories: blog
---

> 本文是对[《JavaScript 教程 - 运算符》](https://wangdoc.com/javascript/operators/)一章中部分知识点的摘录，请访问原文，获取更多详细信息。

## 一、算术运算符

### 1.1 概述

JavaScript 共提供 10 个算术运算符，用来完成基本的算术运算。

- `+`
- `-`
- `*`
- `/`
- `**`（指数运算符）
- `%`（余数运算符）
- `++x`（或者 `x++`，即自增运算符）
- `--x`（或者 `x--`，即）自减运算符
- `+x`（数值运算符）
- `-x`（负数值运算符）

### 1.2 加法运算符

#### （1）基本规则

加法运算符（`+`）即可当作**算数运算符**，又可进行**字符串连接**操作。它的运算规则是：只要有一个是运算子是字符串，进行的就是字符串连接操作（此时，如果另一个运算子不是字符串，会被转为字符串）。

```javascript
1 + 'a' // "1a"
false + 'a' // "falsea"
```

加法运算符是在**运行时**决定，到底是执行相加，还是执行连接。运算子的不同，会导致不同的语法行为，这种现象称为“**重载**”（overload）。除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：**所有运算子一律转为数值，再进行相应的数学运算**。

```javascript
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"

1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

#### （2）对象的相加

如果运算子是对象，必须先转成原始类型的值，然后再相加。首先调用对象的 [`[Symbol.toPrimitive]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)，如果这个方法不存在，则首先自动调用对象的 `valueOf()`，如果此时返回的是原始类型的值，则进行相应的操作，如果 `valueOf()` 得到的是对象类型，再自动调用对象的 `toString()`，将对象转为字符串。

```javascript
var obj = { p: 1 };
obj + 2 // "[object Object]2"
```

如果运算子是 `Date` 对象的实例，则会优先执行 `toString()`。

```javascript
var obj = new Date();
obj.valueOf = function () { return 1 };
obj.toString = function () { return 'hello' };
obj + 2 // "hello2"
```

### 1.3 余数运算符

余数运算符（`%`）运算结果的正负号由**第一个**运算子的正负号决定。

```javascript
-1 % 2 // -1
1 % -2 // 1
```

余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。

```javascript
6.5 % 2.1
// 0.19999999999999973
```

### 1.4 自增和自减运算符

对于自增和自减运算符，运算之后，变量的值发生变化，这种效应叫做运算的**副作用**（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。

- 如果运算符放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。
- 如果运算符放在变量之后，会先返回变量操作前的值，再进行自增/自减操作。

```javascript
var x = 1;
var y = 1;
x++ // 1
++y // 2
```

### 1.5 数值运算符，负数值运算符

数值运算符（`+`）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。**数值运算符可以将任何值转为数值**（与 `Number` 函数的作用相同）。

```javascript
+true // 1
+[] // 0
+{} // NaN
```

负数值运算符（`-`），也同样将一个值转为数值，只不过得到的值正负相反。

### 1.6 指数运算符

指数运算符（`**`）完成指数运算，前一个运算子是**底数**，后一个运算子是**指数**。注意，指数运算符是**右结合**。即多个指数运算符连用时，先进行最右边的计算。

```javascript
2 ** 4 // 16
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
```

## 二、比较运算符

### 2.1 概述

JavaScript 提供了 8 个比较运算符：`>`、`<`、`>=`、`<=`、`==`、`===`、`!=` 和 `!==`。

这八个比较运算符分成两类：相等比较和非相等比较。**对于非相等（`>`、`<`、`>=` 和 `<=`）的比较，算法是先看两个运算子是否都是字符串，如果是，就按照字典顺序比较（实际上是比较 `Unicode` 码点）；否则，将两个运算子都转成数值，再比较数值的大小**。

### 2.2 非相等运算符：字符串的比较

字符串按照字典顺序逐个字符进行比较。首先比较首字符的 `Unicode` 码点。如果相等，再比较第二个字符的 `Unicode` 码点，以此类推。

```javascript
'cat' > 'dog' // false
'cat' > 'Cat' // true' c 的 Unicode 码点是 99，C 的 Unicode 码点是 67
'大' > '小' // false “大”的 Unicode 码点是 22823，“小”是 23567
```

### 2.3 非相等运算符：非字符串的比较

如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。

#### （1）原始类型值

**如果两个运算子都是原始类型的值，则先转成数值再比较**。

```javascript
5 > '4' // true
// 等同于 5 > Number('4')
// 即 5 > 4

true > false // true
// 等同于 Number(true) > Number(false)
// 即 1 > 0

2 > true // true
// 等同于 2 > Number(true)
// 即 2 > 1
```

任何值（包括 `NaN` 本身）与 `NaN` 使用非相等运算符进行比较，返回的都是 `false`。

```javascript
1 > NaN // false
1 <= NaN // false
'1' > NaN // false
'1' <= NaN // false
NaN > NaN // false
NaN <= NaN // false
```

#### （2）对象

**如果运算子是对象，会转为原始类型的值，再进行比较**。对象转换成原始类型的值，算法是先调用 `valueOf()`；如果返回的还是对象，再接着调用 `toString()`。

```javascript
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'

x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 (function () { return '1' })() > '11'
// 即 '1' > '11'

[2] > [1] // true
// 等同于 [2].valueOf().toString() > [1].valueOf().toString()
// 即 '2' > '1'
```

### 2.4 严格相等运算符，严格不相等运算符

- 相等运算符（`==`）比较两个值是否**相等**。如果两个值不是同一类型，相等运算符会将它们转换成同一个类型，再用严格相等运算符进行比较。
- 严格相等运算符（`===`）比较两个值是否为“**同一个值**”。如果两个值不是同一类型，严格相等运算符直接返回 `false`。

对于严格相等运算符：

- 如果两个值的类型不同，直接返回 `false`。
- 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回 `true`，值不同就返回 `false`。
- 复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向**同一个地址**。
- `undefined` 和 `null` 与自身严格相等。

严格不相等运算符（`!==`）先求严格相等运算符的结果，然后取相反值。

### 2.5 相等运算符，不相等运算符

相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。比较不同类型的数据时，相等运算符会先将数据进行**类型转换**，然后再用严格相等运算符比较。

- 原始类型的值会转换成数值再进行比较。

  ```javascript
  1 == true // true
  // 等同于 1 === Number(true)

  2 == false // false
  // 等同于 2 === Number(false)

  'true' == true // false
  // 等同于 Number('true') === Number(true)
  // 等同于 NaN === 1

  '' == 0 // true
  // 等同于 Number('') === 0
  // 等同于 0 === 0

  '' == false  // true
  // 等同于 Number('') === Number(false)
  // 等同于 0 === 0

  '1' == true  // true
  // 等同于 Number('1') === Number(true)
  // 等同于 1 === 1

  '\n  123  \t' == 123 // true
  // 因为字符串转为数字时，省略前置和后置的空格
  ```

- 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。先调用对象的 `valueOf()`，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用 `toString()`，得到字符串形式，再进行比较。

  ```javascript
  // 数组与数值的比较
  [1] == 1 // true

  // 数组与字符串的比较
  [1] == '1' // true
  [1, 2] == '1,2' // true

  // 对象与布尔值的比较
  [1] == true // true
  [2] == true // false
  ```

- `undefined` 和 `null` 只有与自身比较，或者互相比较时，才会返回 `true`；与其他类型的值比较时，结果都为 `false`。

  ```javascript
  undefined == undefined // true
  null == null // true
  undefined == null // true
  ```

- 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。

  ```javascript
  0 == ''             // true
  0 == '0'            // true

  2 == true           // false
  2 == false          // false

  false == 'false'    // false
  false == '0'        // true

  false == undefined  // false
  false == null       // false
  null == undefined   // true

  ' \t\r\n ' == 0     // true
  ```

建议不要使用相等运算符（`==`），最好只使用严格相等运算符（`===`）。

不相等运算符（`!=`）先求相等运算符的结果，然后取相反值。

## 三、布尔运算符

### 3.1 概述

布尔运算符用于将表达式转为布尔值，共包含四个运算符：`||`（或运算符）、`&&`（且运算符）、`!`（取反运算符）和 `?:`（三元运算符）。

### 3.2 取反运算符（`!`）

- `undefined`、`null`、`false`、`0`、`NaN` 和空字符串（`''`）取反后为 `true`，其他值都为 `false`。
- 对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 `Boolean()` 函数的作用相同。这是一种常用的类型转换的写法。

  ```javascript
  !!x
  // 等同于
  Boolean(x)
  ```

### 3.3 且运算符（`&&`）

且运算符（`&&`）的运算规则如下。

- **如果第一个运算子的布尔值为 `true`，则返回第二个运算子的值（注意是值，不是布尔值）**。
- **如果第一个运算子的布尔值为 `false`，则直接返回第一个运算子的值，且不再对第二个运算子求值**。

```javascript
't' && '' // ""
't' && 'f' // "f"
'' && 'f' // ""
```

这种跳过第二个运算子的机制，被称为“**短路**”。有时候可以用它取代 `if` 结构。

```javascript
if (i) {
  doSomething();
}
// 等价于
i && doSomething();
```

**如果多个且运算符连用，返回第一个布尔值为 `false` 的表达式的值。如果所有表达式的布尔值都为 `true`，则返回最后一个表达式的值**。

```javascript
true && 'foo' && '' && 4 && 'foo' && true
// ''
1 && 2 && 3
// 3
```

### 3.4 或运算符（`||`）

或运算符（`||`）的运算规则如下。

- **如果第一个运算子的布尔值为 `true`，则返回第一个运算子的值，且不再对第二个运算子求值**。
- **如果第一个运算子的布尔值为 `false`，则返回第二个运算子的值**。

```javascript
't' || '' // "t"
't' || 'f' // "t"
'' || 'f' // "f"
'' || '' // ""
```

**如果多个或运算符连用，返回第一个布尔值为 `true` 的表达式的值。如果所有表达式都为 `false`，则返回最后一个表达式的值**。

```javascript
false || 0 || '' || 4 || 'foo' || true
// 4
false || 0 || ''
// ''
```

## 四、二进制位运算符

### 4.1 概述

二进制位运算符用于直接对二进制位进行计算，共有 7 个。

- 二进制**与**运算符（and）：符号为 `&`，表示若两个二进制位都为 `1`，则结果为 `1`，否则为 `0`。
- 二进制**或**运算符（or）：符号为 `|`，表示若两个二进制位都为 `0`，则结果为 `0`，否则为 `1`。
- 二进制**否**运算符（not）：符号为 `~`，表示对一个二进制位取反。
- **异或**运算符（xor）：符号为 `^`，表示若两个二进制位不相同，则结果为 `1`，否则为 `0`。
- **左移**运算符（left shift）：符号为 `<<`。
- **右移**运算符（right shift）：符号为 `>>`。
- **头部补零的右移**运算符（zero filled right shift）：符号为 `>>>`。

**这些位运算符直接处理每个比特位（bit），且位运算都只对整数有效。如果一个运算子不是整数，会自动转为整数后再执行**。另外，虽然在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是以 **32 位带符号的整数**进行运算的，并且返回值也是一个 32 位带符号的整数。

```javascript
i = i | 0;
```

上面这行代码的意思，就是将 `i`（不管是整数或小数）转为 32 位整数。利用这个特性，可以写出一个函数，将任意数值转为 32 位整数。

```javascript
function toInt32(x) {
  return x | 0;
}

toInt32(1.001) // 1
toInt32(1.999) // 1
toInt32(1) // 1
toInt32(-1) // -1
toInt32(Math.pow(2, 32) + 1) // 1
toInt32(Math.pow(2, 32) - 1) // -1
```

`toInt32()` 将任意值与 `0` 进行一次**或**运算，这个位运算会自动将一个值转为 32 位整数。上面代码中，`toInt32()` 用于将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于 2 的 32 次方的整数，大于 32 位的数位都会被舍去。

### 4.2 二进制或运算符

二进制或运算符（`|`）**逐位**比较两个运算子，两个二进制位之中只要有一个为 `1`，就返回 `1`，否则返回 `0`。

```javascript
0 | 3 // 3
```

位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，**将一个小数与 `0` 进行二进制或运算，等同于对该数去除小数部分，即取整数位**。

```javascript
2.9 | 0 // 2
-2.9 | 0 // -2
```

### 4.3 二进制与运算符

二进制与运算符（`&`）**逐位**比较两个运算子，两个二进制位之中只要有一个位为 `0`，就返回 `0`，否则返回 `1`。

```javascript
0 & 3 // 0
```

### 4.4 二进制否运算符

二进制否运算符（`~`）将每个二进制位都变为相反值（`0` 变为 `1`，`1` 变为 `0`）。

```javascript
~ 3 // -4
```

上面表达式对 `3` 进行二进制否运算，得到 `-4`。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为 32 位的二进制整数再进行运算。其计算过程如下。

1. 首先计算 `3` 的 32 位整数形式是 `00000000000000000000000000000011`；
2. 进行二进制**否**运算后得到 `11111111111111111111111111111100`；
3. 由于第一位（符号位）是 `1`，所以这个数是一个负数。JavaScript 内部采用**补码**形式表示负数，即需要将这个数减去 `1`，再取一次反，然后加上负号，才能得到这个负数对应的 10 进制值。也就是，`11111111111111111111111111111100 - 1 = 11111111111111111111111111111011`，再取一次反得到 `00000000000000000000000000000100`，由于第 2 步得到的是个负数，所以加上负号就是 `-4`。

考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于 `-1`。

```javascript
~ -3 // 2
```

对一个整数连续两次二进制否运算，得到它自身。

```javascript
~~3 // 3
```

二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，**对一个小数连续进行两次二进制否运算，能达到取整效果**。**使用二进制否运算取整，是所有取整方法中最快的一种**。

```javascript
~~2.9 // 2
~~47.11 // 47
~~1.9999 // 1
~~3 // 3
```

对字符串和其他类型的值进行二进制否运算，JavaScript 引擎会先调用 `Number` 函数，将其转为数值。

```javascript
// 相当于 ~Number('011')
~'011'  // -12

// 相当于 ~Number('42 cats')
~'42 cats' // -1

// 相当于 ~Number('0xcafebabe')
~'0xcafebabe' // 889275713

// 相当于 ~Number('deadbeef')
~'deadbeef' // -1

// 相当于 ~Number([])
~[] // -1

// 相当于 ~Number(NaN)
~NaN // -1

// 相当于 ~Number(null)
~null // -1
```

### 4.5 异或运算符

异或运算（`^`）在两个二进制位不同时返回 `1`，相同时返回 `0`。

```javascript
0 ^ 3 // 3
```

“异或运算”有一个特殊运用，连续对两个数 `a` 和 `b` 进行三次异或运算，`a^=b; b^=a; a^=b;`，可以**互换**它们的值。这意味着，**“异或运算”可以在不引入临时变量的前提下，互换两个变量的值**。这是互换两个变量的值的最快方法。

```javascript
var a = 10;
var b = 99;
a ^= b, b ^= a, a ^= b;
a // 99
b // 10
```

**异或运算可以用来取整**。

```javascript
12.9 ^ 0 // 12
```

### 4.6 左移运算符

左移运算符（`<<`）表示将一个数的二进制值向左移动指定的位数，尾部补 `0`，即乘以 `2` 的指定次方。向左移动的时候，最高位的符号位是一起移动的。

```javascript
// 4 的二进制形式为100，
// 左移一位为1000（即十进制的8）
// 相当于乘以2的1次方
4 << 1
// 8
-4 << 1
// -8
```

上面代码中，`-4` 左移一位得到 `-8`，是因为 `-4` 的二进制形式是 `11111111111111111111111111111100`，左移一位后得到 `11111111111111111111111111111000`，该数转为十进制（减去 `1` 后取反，再加上负号）即为 `-8`。

**如果左移 `0` 位，就相当于将该数值转为 32 位整数，等同于取整，对于正数和负数都有效**。

```javascript
13.5 << 0
// 13
-13.5 << 0
// -13
```

左移运算符用于二进制数值非常方便。

```javascript
var color = {r: 186, g: 218, b: 85};
// RGB to HEX
// (1 << 24)的作用为保证结果是6位数
var rgb2hex = function(r, g, b) {
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)
    .toString(16) // 先转成十六进制，然后返回字符串
    .substr(1);   // 去除字符串的最高位，返回后面六个字符串
}
rgb2hex(color.r, color.g, color.b)
// "#bada55"
```

上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。

### 4.7 右移运算符

右移运算符（`>>`）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补 `0`；如果是负数，头部全部补 `1`。右移运算符基本上相当于除以 `2` 的指定次方（最高位即符号位参与移动）。

```javascript
4 >> 1
// 2
/*
// 因为 4 的二进制形式为 00000000000000000000000000000100
// 右移一位得到 00000000000000000000000000000010
// 即为十进制的 2
*/

-4 >> 1
// -2
/*
// 因为 -4 的二进制形式为 11111111111111111111111111111100
// 右移一位，头部补 1，得到 11111111111111111111111111111110
// 即为十进制的 -2
*/
```

右移运算可以模拟 2 的整除运算。

```javascript
5 >> 1
// 2
// 相当于 5 / 2 = 2

21 >> 2
// 5
// 相当于 21 / 4 = 5

21 >> 3
// 2
// 相当于 21 / 8 = 2

21 >> 4
// 1
// 相当于 21 / 16 = 1
```

### 4.8 头部补零的右移运算符

头部补零的右移运算符（`>>>`）与右移运算符（`>>`）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补 `0`，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（`>>`）完全一致，区别主要在于负数。

```javascript
4 >>> 1
// 2

-4 >>> 1
// 2147483646
/*
// 因为 -4 的二进制形式为11111111111111111111111111111100
// 带符号位的右移一位，得到 01111111111111111111111111111110
// 即为十进制的 2147483646
*/
```

这个运算实际上将一个值转为 32 位无符号整数。

**查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符**。

```javascript
-1 >>> 0 // 4294967295
```

上面代码表示，`-1` 作为 32 位整数时，内部的储存形式使用无符号整数格式解读，值为 `4294967295`（即 `(2^32)-1`，等于 `11111111111111111111111111111111`）。

### 4.9 开关作用

位运算符可以用作设置对象属性的**开关**。

假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。

```javascript
var FLAG_A = 1; // 0001
var FLAG_B = 2; // 0010
var FLAG_C = 4; // 0100
var FLAG_D = 8; // 1000
```

上面代码设置 `A`、`B`、`C`、`D` 四个开关，每个开关分别占有一个二进制位。

- 可以用二进制**与**运算，检查当前设置是否打开了指定开关。

  ```javascript
  var flags = 5; // 二进制的0101
  if (flags & FLAG_C) {
    // ...
  }
  // 0101 & 0100 => 0100 => true
  ```

  上面代码检验是否打开了开关 `C`。如果打开，会返回 `true`，否则返回 `false`。

- 现在假设需要打开 `A`、`B`、`D` 三个开关，我们可以构造一个掩码变量。

  ```javascript
  var mask = FLAG_A | FLAG_B | FLAG_D;
  // 0001 | 0010 | 1000 => 1011
  ```

  上面代码对 `A`、`B`、`D` 三个变量进行二进制或运算，得到掩码值为二进制的 `1011`。

  有了掩码，二进制**或**运算可以确保打开指定的开关。

  ```text
  flags = flags | mask;
  ```

  上面代码中，计算后得到的 `flags` 变量，代表三个开关的二进制位都打开了。

- 二进制**与**运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。

  ```text
  flags = flags & mask;
  ```

- 异或运算可以**切换**（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。

  ```text
  flags = flags ^ mask;
  ```

- 二进制**否**运算可以翻转当前设置，即原设置为 `0`，运算后变为 `1`；原设置为 `1`，运算后变为 `0`。

  ```text
  flags = ~flags;
  ```

## 五、其他运算符，运算顺序

### 5.1 void 运算符

`void` 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 `undefined`。

```javascript
void 0 // undefined
void(0) // undefined
```

上面是 `void` 运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为 `void` 运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，`void 4 + 7` 实际上等同于 `(void 4) + 7`。

`void` 运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。

```html
<a href="javascript: void(document.form.submit())">
  提交
</a>
```

上面的代码中，用户点击链接提交表单，但是不产生页面跳转。

### 5.2 逗号运算符

逗号运算符用于对两个表达式求值，并返回后一个表达式的值。

```javascript
'a', 'b' // "b"

var x = 0;
var y = (x++, 10);
x // 1
y // 10
```

逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。

```javascript
var value = (console.log('Hi!'), true);
// Hi!
value // true
```

## 六、参考

- 阮一峰，[JavaScript 教程 - 运算符](https://wangdoc.com/javascript/operators/)