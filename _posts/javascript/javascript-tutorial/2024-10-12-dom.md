---
layout: post
title: 《JavaScript 教程》摘录
categories: blog
tags:
  - JavaScript
  - DOM
---

> 本文是对[《JavaScript 教程 - DOM》](https://wangdoc.com/javascript/dom/)一章中部分知识点的摘录，请访问原文，获取更多详细信息。

## 一、概述

DOM 是 JavaScript 操作网页的接口，全称为“**文档对象模型**”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。DOM 的最小组成单位叫做**节点**（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。

节点的类型有七种。浏览器提供一个原生的节点对象 `Node`，这七种节点都继承了 `Node`。

- `Document`：整个文档树的顶层节点
- `DocumentType`：`doctype` 标签（比如 `<!DOCTYPE html>`）
- `DocumentFragment`：文档的片段
- `Element`：网页的各种 HTML 标签（比如 `<body>`、`<a>` 等）
- `Attr`：网页元素的属性（比如 `class="right"`）
- `Text`：标签之间或标签包含的文本
- `Comment`：注释

一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 **DOM 树**。它有一个顶层节点，下一层都是顶层节点的子节点。

浏览器原生提供 `document` 节点，代表整个文档。文档的第一层有两个节点：

- 第一个是文档类型节点（`<!doctype html>`）；
- 第二个是 HTML 网页的顶层容器标签 `<html>`，它构成了树结构的**根节点**（root node），其他 HTML 标签节点都是它的下级节点。

除了根节点，其他节点有三种层级关系。

- 父节点关系（parentNode）：直接的那个上级节点
- 子节点关系（childNodes）：直接的下级节点
- 同级节点关系（sibling）：拥有同一个父节点的节点

DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括 `firstChild`（第一个子节点）和 `lastChild`（最后一个子节点）等属性，同级节点接口包括 `previousSibling`（紧邻在前的那个同级节点）和 `nextSibling`（紧邻在后的那个同级节点）属性。

## 二、Node 接口

所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。

### 1. 属性

#### 1.1 Node.prototype.nodeType

`nodeType` 属性返回一个整数值，表示节点的**类型**。不同节点的 `nodeType` 属性值和对应的常量如下。

- 文档节点（document）：`9`，对应常量 `Node.DOCUMENT_NODE`
- 文档类型节点（DocumentType）：`10`，对应常量 `Node.DOCUMENT_TYPE_NODE`
- 文档片断节点（DocumentFragment）：`11`，对应常量 `Node.DOCUMENT_FRAGMENT_NODE`
- 元素节点（element）：`1`，对应常量 `Node.ELEMENT_NODE`
- 属性节点（attr）：`2`，对应常量 `Node.ATTRIBUTE_NODE`
- 文本节点（text）：`3`，对应常量 `Node.TEXT_NODE`
- 注释节点（Comment）：`8`，对应常量 `Node.COMMENT_NODE`

```javascript
document.nodeType // 9
document.nodeType === Node.DOCUMENT_NODE // true
```

#### 1.2 Node.prototype.nodeName

`nodeName` 属性返回节点的**名称**。不同节点的 `nodeName` 属性值如下。

- 文档节点（document）：`#document`
- 文档类型节点（DocumentType）：文档的类型
- 文档片断节点（DocumentFragment）：`#document-fragment`
- 元素节点（element）：大写的标签名
- 属性节点（attr）：属性的名称
- 文本节点（text）：`#text`
- 注释节点（Comment）：`#comment`

```javascript
// HTML 代码如下
// <div id="d1">hello world</div>
var div = document.getElementById('d1');
div.nodeName // "DIV"
```

#### 1.3 Node.prototype.nodeValue

`nodeValue` 属性返回一个字符串，表示当前节点本身的**文本值**，该属性**可读写**。

只有**属性节点**（attr）、**文本节点**（text）和**注释节点**（comment）有文本值，因此这三类节点的 `nodeValue` 可以返回结果，其他类型的节点一律返回 `null`。也只有这三类节点可以设置 `nodeValue` 属性的值，其他类型的节点设置无效。

```javascript
// HTML 代码如下
// <div id="d1">hello world</div>
var div = document.getElementById('d1');
div.nodeValue // null
div.firstChild.nodeValue // "hello world"
```

上面代码中，`div` 是元素节点，`nodeValue` 属性返回 `null`。`div.firstChild` 是文本节点，所以可以返回文本值。

#### 1.4 Node.prototype.textContent

`textContent` 属性返回**当前节点和它的所有后代节点**的**文本内容**。

- `textContent` 属性自动忽略当前节点内部的 HTML 标签，返回所有**文本内容**。
- 该属性**可读写**，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它会自动对 HTML 标签转义。

```javascript
// HTML 代码为
// <div id="divA">This is <span>some</span> text</div>
document.getElementById('divA').textContent
// This is some text
```

#### 1.5 Node.prototype.baseURI

`baseURI` 属性返回一个字符串，表示当前网页的**绝对路径**。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为**只读**。该属性的值一般由当前网址的 URL（即 `window.location` 属性）决定，但是可以使用 HTML 的 `<base>` 标签，改变该属性的值。

```javascript
// 当前网页的网址为
// http://www.example.com/index.html
document.baseURI
// "http://www.example.com/index.html"
<base href="http://www.example.com/page.html">
```

#### 1.6 Node.prototype.ownerDocument

`Node.ownerDocument` 属性返回当前节点所在的顶层文档对象，即 `document` 对象。

```javascript
var d = p.ownerDocument;
d === document // true
```

#### 1.7 Node.prototype.previousSibling，Node.prototype.nextSibling

- `previousSibling` 属性返回当前节点**前面的**、**距离最近的一个同级节点**。
- `nextSibling` 属性返回紧跟在当前节点**后面的第一个同级节点**。

```javascript
// HTML 代码如下
// <div id="d1">hello</div><div id="d2">world</div>
var d1 = document.getElementById('d1');
var d2 = document.getElementById('d2');
d2.previousSibling === d1 // true

// HTML 代码如下
// <div id="d1">hello</div><div id="d2">world</div>
var d1 = document.getElementById('d1');
var d2 = document.getElementById('d2');
d1.nextSibling === d2 // true
```

注意，这两个属性还包括文本节点和注释节点。因此如果当前节点前面/后面有空格，他们都会返回一个文本节点，内容为空格。

#### 1.8 Node.prototype.parentNode

- `parentNode` 属性返回当前节点的**父节点**。对于一个节点来说，它的父节点只可能是三种类型：**文档节点**（document）、**文档片段节点**（documentfragment）和**元素节点**（element）。文档节点（document）和文档片段节点（documentfragment）的父节点都是 `null`。
- `parentElement` 属性返回当前节点的**父元素节点**。此属性只包含元素节点。

```javascript
if (node.parentNode) {
  node.parentNode.removeChild(node);
}
if (node.parentElement) {
  node.parentElement.style.color = 'red';
}
```

#### 1.9 Node.prototype.firstChild，Node.prototype.lastChild

- `firstChild` 属性返回当前节点的第一个子节点。`firstChild` 返回的除了元素节点，还可能是文本节点或注释节点。
- `lastChild` 属性返回当前节点的最后一个子节点。用法与 `firstChild` 属性相同。

#### 1.10 Node.prototype.childNodes

`childNodes` 属性返回一个类似数组的对象（`NodeList` 集合），成员包括当前节点的所有子节点。`childNodes` 属性的返回值包括**元素节点**、**文本节点**和**注释节点**。如果当前节点不包括任何子节点，则返回一个空的 `NodeList` 集合。

`NodeList` 对象是一个**动态集合**，子节点发生的变化会立刻反映在返回结果之中。

#### 1.11 Node.prototype.isConnected

`isConnected` 布尔值，表示当前节点是否在文档之中。

### 2. 方法

#### 2.1 Node.prototype.appendChild()

`appendChild(aChild)` 接受一个节点对象作为参数，将其作为**最后一个**子节点，插入当前节点。该方法的返回值是插入文档的子节点。

```javascript
var p = document.createElement('p');
document.body.appendChild(p);
```

如果参数节点是 DOM 已经存在的节点，`appendChild()` 会将其从原来的位置，**移动**到新位置。

```javascript
var div = document.getElementById('myDiv');
document.body.appendChild(div);
```

#### 2.2 Node.prototype.hasChildNodes()

`hasChildNodes()` 返回布尔值，表示当前节点是否有子节点。子节点包括所有类型的节点，哪怕节点只包含一个空格，`hasChildNodes()` 方法也会返回 `true`。

#### 2.3 Node.prototype.cloneNode()

`cloneNode(deep)` 用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。

```javascript
var cloneUL = document.querySelector('ul').cloneNode(true);
```

- 克隆一个节点，会拷贝该节点的所有属性，但是会丧失 `addEventListener()` 方法和 `on-属性`（即 `node.onclick = fn`），添加在这个节点上的事件回调函数。
- 该方法返回的节点不在文档中，即没有任何父节点，必须使用诸如 `Node.appendChild()` 这样的方法添加到文档之中。
- 克隆一个节点之后，DOM 有可能出现两个有相同 `id` 属性的网页元素，这时应该修改其中一个元素的 `id` 属性。如果原节点有 `name` 属性，可能也需要修改。

#### 2.4 Node.prototype.insertBefore()

`insertBefore(newNode, referenceNode)` 用于将某个节点插入父节点内部的指定位置。

- 第一个参数是所要插入的节点 `newNode`。
- 第二个参数是父节点 `parentNode` 内部的一个子节点 `referenceNode`。如果第二个参数为 `null`，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。

```javascript
var p = document.createElement('p');
document.body.insertBefore(p, document.body.firstChild);
```

上面代码中，新建一个 `<p>` 节点，插在 `document.body.firstChild` 的前面，也就是成为 `document.body` 的第一个子节点。

由于不存在 `insertAfter` 方法，如果新节点要插在父节点的某个子节点后面，可以用 `insertBefore()` 结合 `nextSibling` 属性模拟。

```javascript
parent.insertBefore(s1, s2.nextSibling);
```

上面代码中，`parent` 是父节点，`s1` 是一个全新的节点，`s2` 是可以将 `s1` 节点，插在 `s2` 节点的后面。如果 `s2` 是当前节点的最后一个子节点，则 `s2.nextSibling` 返 回 `null`，这时 `s1` 节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在 `s2` 的后面。

#### 2.5 Node.prototype.removeChild()

`removeChild(child)` 接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。

```javascript
var divA = document.getElementById('A');
divA.parentNode.removeChild(divA);
```

#### 2.6 Node.prototype.replaceChild()

`replaceChild(newChild, oldChild)` 用于将一个新的节点，替换当前节点的某个子节点。

```javascript
var replacedNode = parentNode.replaceChild(newChild, oldChild);
```

#### 2.7 Node.prototype.contains()

`contains(otherNode)` 返回一个布尔值，表示参数节点是否满足以下三个条件之一。

- 参数节点为**当前节点**。
- 参数节点为当前节点的**子节点**。
- 参数节点为当前节点的**后代节点**。

#### 2.8 Node.prototype.compareDocumentPosition()

`compareDocumentPosition(otherNode)` 与 `contains()` 完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的**关系**。

- `000000`：十进制的 0，表示两个节点**相同**
- `000001`：十进制的 1，表示两个节点不在同一个文档（即有一个节点不在当前文档）
- `000010`：十进制的 2，表示参数节点在当前节点的**前面**
- `000100`：十进制的 4，表示参数节点在当前节点的**后面**
- `001000`：十进制的 8，表示参数节点**包含**当前节点
- `010000`：十进制的 16，表示当前节点**包含**参数节点
- `100000`：十进制的 32，表示浏览器内部使用

```javascript
// HTML 代码如下
// <div id="mydiv">
//   <form><input id="test" /></form>
// </div>
var div = document.getElementById('mydiv');
var input = document.getElementById('test');
div.compareDocumentPosition(input) // 20
input.compareDocumentPosition(div) // 10
```

上面代码中，节点 `div` 包含节点 `input`（二进制 `010000`），而且节点 `input` 在节点 `div` 的后面（二进制 `000100`），所以第一个 `compareDocumentPosition()` 方法返回 `20`（二进制 `010100`，即 `010000` + `000100`），第二个 `compareDocumentPosition()` 方法返回 `10`（二进制 `001010`）。

由于 `compareDocumentPosition()` 返回值的含义，定义在每个比特位上，所以如果要检查某种特定的含义，就需要使用比特位运算符。

```javascript
var head = document.head;
var body = document.body;
if (head.compareDocumentPosition(body) & 4) {
  console.log('文档结构正确');
} else {
  console.log('<body> 不能在 <head> 前面');
}
```

上面代码中，`compareDocumentPosition()` 的返回值与 `4`（又称掩码）进行与运算（`&`），得到一个布尔值，表示 `<head>` 是否在 `<body>` 前面。

#### 2.9 Node.prototype.isEqualNode()，Node.prototype.isSameNode()

- `isEqualNode(otherNode)` 返回一个布尔值，用于检查两个节点是否**相等**。所谓相等的节点，指的是两个节点的**类型**相同、**属性**相同、**子节点**相同。
- `isSameNode(otherNode)` 返回一个布尔值，表示两个节点是否为**同一个**节点。

#### 2.10 Node.prototype.normalize()

`normalize()` 用于清理当前节点内部的所有**文本节点**（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。该方法是 `Text.splitText()` 的逆方法。

```javascript
var wrapper = document.createElement('div');
wrapper.appendChild(document.createTextNode('Part 1 '));
wrapper.appendChild(document.createTextNode('Part 2 '));
wrapper.childNodes.length // 2
wrapper.normalize();
wrapper.childNodes.length // 1
```

上面代码使用 `normalize()` 之前，`wrapper` 节点有两个毗邻的文本子节点。使 `normalize()` 之后，两个文本子节点被合并成一个。

#### 2.11 Node.prototype.getRootNode()

`getRootNode(options)` 返回当前节点所在文档的根节点 `document`，与 `ownerDocument` 属性的作用相同。

## 三、NodeList 接口，HTMLCollection 接口

DOM 提供两种节点集合，用于容纳多个节点：`NodeList` 和 `HTMLCollection`。`NodeList` 可以包含各种类型的节点，`HTMLCollection` 只能包含 HTML 元素节点。

### 1. NodeList 接口

#### 1.1 概述

`NodeList` 实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到 `NodeList` 实例。

- `Node.childNodes`
- `document.querySelectorAll()` 等节点搜索方法

`NodeList` 是对象不是数组，但可以使用 `length` 属性和 `forEach()` 。

`NodeList` 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 `NodeList` 实例。目前，只有 `Node.childNodes` 返回的是动态集合，其他的都是静态集合。

#### 1.2 NodeList.prototype.length

`length` 属性返回 `NodeList` 实例包含的节点数量。

#### 1.3 NodeList.prototype.forEach()

`forEach()` 方法用于遍历 `NodeList` 的所有成员。

#### 1.4 NodeList.prototype.item()

`item(index)` 接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（`[]`），而不使用 `item()`。

```javascript
document.body.childNodes.item(0)
document.body.childNodes[0]
```

#### 1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()

这三个方法都返回一个 ES6 的**遍历器对象**，可以通过 `for...of` 循环遍历获取每个成员的信息。`keys()` 返回键名的遍历器，`values()` 返回键值的遍历器，`entries()` 返回的遍历器同时包含键名和键值的信息。

### 2. HTMLCollection 接口

#### 2.1 概述

`HTMLCollection` 是一个只包含**元素节点**（element）对象的集合，不包含其他类型的节点。它的返回值是一个类似数组的对象，`HTMLCollection` 只能使用 `for` 循环遍历。

返回 `HTMLCollection` 实例的，主要是一些 `Document` 对象的集合属性，比如 `document.links`、`document.forms`、`document.images` 等。

如果元素节点有 `id` 或 `name` 属性，那么 `HTMLCollection` 实例上面，可以使用 `id` 属性或 `name` 属性引用该节点元素。

```javascript
// HTML 代码如下
// <img id="pic" src="http://example.com/foo.jpg">
var pic = document.getElementById('pic');
document.images.pic === pic // true
```

上面代码中，`document.images` 是一个 `HTMLCollection` 实例，可以通过 `<img>` 元素的 `id` 属性值，从 `HTMLCollection` 实例上取到这个元素。

#### 2.2 HTMLCollection.prototype.length

`length` 属性返回 `HTMLCollection` 实例包含的成员数量。

#### 2.3 HTMLCollection.prototype.item()

`item(index)` 接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（`[]`），而不使用 `item()`。

```javascript
var c = document.images;
var img0 = c.item(0);
```

#### 2.4 HTMLCollection.prototype.namedItem()

`namedItem(key)` 的参数是一个字符串，表示 `id` 属性或 `name` 属性的值，返回当前集合中对应的元素节点。

```javascript
// HTML 代码如下
// <img id="pic" src="http://example.com/foo.jpg">
var pic = document.getElementById('pic');
document.images.namedItem('pic') === pic // true
```

`Collection.namedItem('value')` 等同于 `Collection['value']`。

## 四、ParentNode 接口，ChildNode 接口

节点对象除了继承 `Node` 接口以外，还拥有其他接口。`ParentNode` 接口表示当前节点是一个父节点，提供一些处理子节点的方法。`ChildNode` 接口表示当前节点是一个子节点，提供一些相关方法。

### 1. ParentNode 接口

如果当前节点是父节点，就会混入（mixin）`ParentNode` 接口。只有**文档节点**（document）、**文档片段节点**（documentFragment）和**元素节点**（element）拥有 `ParentNode` 接口。

#### 1.1 ParentNode.children

`children` 属性返回一个 `HTMLCollection` 实例，成员是当前节点的**所有元素子节点**。该属性只读。

#### 1.2 ParentNode.firstElementChild，ParentNode.lastElementChild

- `firstElementChild` 属性返回当前节点的**第一个元素子节点**。
- `lastElementChild` 属性返回当前节点的**最后一个元素子节点**。

#### 1.3 ParentNode.childElementCount

`childElementCount` 属性返回一个整数，表示当前节点的所有元素子节点的数目。

#### 1.4 ParentNode.append()，ParentNode.prepend()

- `append(node1, node2, ...)` 为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。该方法可以添加**元素节点**（参数为元素节点）和**文本节点**（参数为字符串）。
- `prepend(node1, node2, ...)` 为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与 `append()` 完全一致，也是没有返回值。

注意，`append()` 与 `Node.prototype.appendChild()` 有三点不同。

- `append()` 允许字符串作为参数，`appendChild()` 只允许子节点作为参数。
- `append()` 没有返回值，而 `appendChild()` 返回添加的子节点。
- `append()` 可以添加多个子节点和字符串（即允许多个参数），`appendChild()` 只能添加一个节点（即只允许一个参数）。

```javascript
var parent = document.body;
// 添加元素子节点
var p = document.createElement('p');
parent.append(p);
// 添加文本子节点
parent.append('Hello');
// 添加多个元素子节点
var p1 = document.createElement('p');
var p2 = document.createElement('p');
parent.append(p1, p2);
// 添加元素子节点和文本子节点
var p = document.createElement('p');
parent.append('Hello', p);
```

### 2. ChildNode 接口

如果一个节点有父节点，那么该节点就拥有了 `ChildNode` 接口。

#### 2.1 ChildNode.remove()

`remove()` 用于从父节点移除当前节点。

#### 2.2 ChildNode.before()，ChildNode.after()

- `before(node1, node2, ...)` 方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。该方法可以插入**元素节点**和**文本节点**。
- `after(node1, node2, ...` 方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与 `before()` 完全相同。

```javascript
var p = document.createElement('p');
var p1 = document.createElement('p');
// 插入元素节点
el.before(p);
// 插入文本节点
el.before('Hello');
// 插入多个元素节点
el.before(p, p1);
// 插入元素节点和文本节点
el.before(p, 'Hello');
```

#### 2.3 ChildNode.replaceWith()

`replaceWith(node1, node2, ...)` 方法使用参数节点，替换当前节点。参数可以是**元素节点**、**文本节点**。

```javascript
var span = document.createElement('span');
el.replaceWith(span);
```

## 五、Document 节点

### 1. 概述

`document` 节点对象代表整个文档，每张网页都有自己的 `document` 对象。`window.document` 属性就指向这个对象。当浏览器开始载入 HTML 文档，该对象就存在。`document` 对象有不同的办法可以获取。

- 正常的网页，直接使用 `document` 或 `window.document`。
- `iframe` 框架里面的网页，使用 iframe 节点的 `contentDocument` 属性。
- Ajax 操作返回的文档，使用 `XMLHttpRequest` 对象的 `responseXML` 属性。
- 内部节点的 `ownerDocument` 属性。

`document` 对象继承了 `EventTarget` 接口和 `Node` 接口，并且混入（mixin）了 `ParentNode` 接口。这意味着，这些接口的方法都可以在 `document` 对象上调用。除此之外，`document` 对象还有很多自己的属性和方法。

### 2. 属性

#### 2.1 快捷方式属性

以下属性是指向文档内部的某个节点的快捷方式。

- `document.defaultView`：返回 `document` 对象所属的 `window` 对象。如果当前文档不属于 `window` 对象，该属性返回 `null`。
- `document.doctype`：`document` 对象一般有两个子节点。第一个子节点是 `document.doctype`，指向 `<DOCTYPE>` 节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成 `<!DOCTYPE html>`。
- `document.documentElement`：返回当前文档的**根元素节点**（root）。它通常是 `document` 节点的第二个子节点，紧跟在 `document.doctype` 节点后面。HTML 网页的该属性，一般是 `<html>` 节点。
- `document.head`：指向 `<head>` 节点，该属性**可读写**。
- `document.body`：指向 `<body>` 节点，该属性**可读写**。
- `document.scrollingElement`：返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。标准模式下，这个属性返回的文档的根元素 `document.documentElement`（即 `<html>`）。兼容（quirk）模式下，返回的是 `<body>` 元素，如果该元素不存在，返回 `null`。
- `document.activeElement`：返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是 `<input>`、`<textarea>`、`<select>` 等表单元素，如果当前没有焦点元素，返回 `<body>` 元素或 `null`。
- `document.fullscreenElement`：返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回 `null`。

#### 2.2 节点集合属性

以下属性（除 `document.styleSheets` 属性外）返回一个 `HTMLCollection` 实例，表示文档内部特定元素的集合。这些集合都是**动态的**，原节点有任何变化，立刻会反映在集合中。

- `document.links`：返回当前文档所有设定了 href 属性的 `<a>` 及 `<area>` 节点。
- `document.forms`：返回所有 `<form>` 表单节点。
- `document.images`：返回页面所有 `<img>` 图片节点。
- `document.embeds`，`document.plugins`：所有 `<embed>` 节点。
- `document.scripts`：返回所有 `<script>` 节点。
- `document.styleSheets`：返回网页内嵌或引入的 CSS 样式表集合。

除了 `document.styleSheets` 属性，以上的其他集合属性返回的都是 `HTMLCollection` 实例。`document.styleSheets` 属性返回的是 `StyleSheetList` 实例。

#### 2.3 文档静态信息属性

- `document.documentURI`，`document.URL`：返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，`documentURI` 继承自 `Document` 接口，可用于所有文档；`URL` 继承自 `HTMLDocument` 接口，只能用于 HTML 文档。
- `document.domain`：返回当前文档的**域名**，不包含协议和端口。
- `document.location`：`Location` 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 `window.location` 和 `document.location` 属性，可以拿到这个对象。
- `document.lastModified`：返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。
- `document.title`：返回当前文档的标题。默认情况下，返回 `<title>` 节点的值。该属性**可读写**。
- `document.characterSet`：返回当前文档的编码，比如 UTF-8 等等。
- `document.referrer`：返回一个字符串，表示当前文档的访问者来自哪里。`document.referrer` 的值，总是与 HTTP 头信息的 `Referer` 字段保持一致。
- `document.dir`：返回一个字符串，表示文字方向。它有两个可能的值：`rtl` 表示文字从右到左，阿拉伯文是这种方式；`ltr` 表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。
- `document.compatMode`：返回浏览器处理文档的模式，可能的值为 `BackCompat`（向后兼容模式）和 `CSS1Compat`（严格模式）。一般来说，如果网页代码的第一行设置了明确的 `DOCTYPE`（比如 `<!doctype html>`），`document.compatMode` 的值都为 `CSS1Compat`。

#### 2.4 文档状态属性

- `document.hidden`：布尔值，表示当前页面**是否可见**。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得 `document.hidden` 返回 `true`。
- `document.visibilityState`：返回文档的**可见状态**。

  - `visible`：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。
  - `hidden`：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。
  - `prerender`：页面处于正在渲染状态，对于用户来说，该页面不可见。
  - `unloaded`：页面从内存里面卸载了。

- `document.readyState`：返回当前文档的**状态**，共有三种可能的值。

  - `loading`：加载 HTML 代码阶段（尚未完成解析）。
  - `interactive`：加载外部资源阶段。
  - `complete`：加载完成。

`document.readyState` 属性变化的过程如下。

1. 浏览器开始解析 HTML 文档，`document.readyState` 属性等于 `loading`。
2. 浏览器遇到 HTML 文档中的 `<script>` 元素，并且没有 `async` 或 `defer` 属性，就暂停解析，开始执行脚本，这时 `document.readyState` 属性还是 `loading`。
3. HTML 文档解析完成，`document.readyState` 属性变成 `interactive`。
4. 浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，`document.readyState` 属性变成 `complete`。

#### 2.5 document.cookie

`document.cookie` 属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。

#### 2.6 document.designMode

`document.designMode` 属性控制当前文档是否可编辑。该属性只有两个值 `on` 和 `off`，默认值为 `off`。

#### 2.7 document.currentScript

`document.currentScript` 属性只用在 `<script>` 元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即 `<script>` 元素的 DOM 节点。

```html
<script id="foo">
  console.log(
    document.currentScript === document.getElementById('foo')
  ); // true
</script>
```

上面代码中，`document.currentScript` 就是 `<script>` 元素节点。

#### 2.8 document.implementation

`document.implementation` 属性返回一个 `DOMImplementation` 对象。该对象有三个方法，主要用于创建独立于当前文档的新的 `Document` 对象。

- `DOMImplementation.createDocument()`：创建一个 XML 文档。
- `DOMImplementation.createHTMLDocument()`：创建一个 HTML 文档。
- `DOMImplementation.createDocumentType()`：创建一个 DocumentType 对象。

下面是创建 HTML 文档的例子。

```javascript
var doc = document.implementation.createHTMLDocument('Title');
var p = doc.createElement('p');
p.innerHTML = 'hello world';
doc.body.appendChild(p);
document.replaceChild(
  doc.documentElement,
  document.documentElement
);
```

上面代码中，第一步生成一个新的 HTML 文档 `doc`，然后用它的根元素 `doc.documentElement` 替换掉 `document.documentElement`。这会使得当前文档的内容全部消失，变成 `hello world`。

### 3. 方法

#### 3.1 document.open()，document.close()

- `document.open()` 清除当前文档所有内容，使得文档处于**可写状态**，供 `document.write` 方法写入内容。
- `document.close()` 用来关闭 `document.open()` 打开的文档。

```javascript
document.open();
document.write('hello world');
document.close();
```

#### 3.2 document.write()，document.writeln()

`document.write(markup)` 方法用于向当前文档写入内容。`document.write` 是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对 `innerHTML` 属性赋值）。所以，除了某些特殊情况，应该尽量**避免使用** `document.write()` 这个方法。

- `document.write()` 会当作 HTML 代码解析，不会转义。
- 在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行 `document.close()`），`document.write()` 写入的内容就会追加在已有内容的后面。
- 如果页面已经解析完成（`DOMContentLoaded` 事件发生之后）再调用 `write()` ，它会先调用 `open()` ，擦除当前文档所有内容，然后再写入。

`document.writeln(line)` 与 `write()` 完全一致，除了会在输出内容的尾部添加换行符。注意，`document.writeln()` 添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入 `<br>`。

#### 3.3 document.querySelector()，document.querySelectorAll()

`document.querySelector(selectors)` 接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回**第一个**匹配的节点。
`document.querySelectorAll(selectors)` 与 `querySelector()` 用法类似，区别是返回一个 `NodeList` 对象，包含所有匹配给定选择器的节点。

这两个方法不支持 CSS 伪元素的选择器（比如 `:first-line` 和 `:first-letter`）和伪类的选择器（比如 `:link` 和 `:visited`），即无法选中伪元素和伪类。

这两个方法都可以在 `document` 对象以及元素节点上调用。

#### 3.4 document.getElementById()，document.getElementsByTagName()，document.getElementsByClassName()，document.getElementsByName()

- `document.getElementById(id)` 返回匹配指定 `id` 属性的元素节点。该方法的参数大小写敏感且只能在 `document` 对象上使用。
- `document.getElementsByTagName(name)` 搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（`HTMLCollection` 实例），可以**实时**反映 HTML 文档的变化。该方法可以在 `document` 对象以及元素节点上调用。
- `document.getElementsByClassName(names)` 返回一个类似数组的对象（`HTMLCollection` 实例），包括了所有 `class` 名字符合指定条件的元素，元素的变化**实时**反映在返回结果中。该方法可以在 `document` 对象以及元素节点上调用。
- `document.getElementsByName(name)` 用于选择拥有 `name` 属性的 HTML 元素（比如 `<form>`、`<radio>`、`<img>`、`<frame>`、`<embed>` 和 `<object>` 等），返回一个类似数组的的对象（`NodeList` 实例），因为 `name` 属性相同的元素可能不止一个。

#### 3.5 document.elementFromPoint()，document.elementsFromPoint()

- `document.elementFromPoint()` 返回位于页面指定位置**最上层**的元素节点。该方法的两个参数，依次是相对于当前视口**左上角**的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。
- `document.elementsFromPoint()` 返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。

```javascript
var element = document.elementFromPoint(50, 50);
```

上面代码选中在 `(50, 50)` 这个坐标位置的最上层的那个 HTML 元素。

#### 3.6 document.createElement()，document.createTextNode()，document.createAttribute()，document.createComment()，document.createDocumentFragment()，document.createEvent()

- `document.createDocumentFragment()` 生成一个空的文档片段对象（`DocumentFragment` 实例）。`DocumentFragment` 是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为 `DocumentFragment` 不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。
- `document.createElement(tagName, options)` 用来生成元素节点，并返回该节点。参数为元素的标签名（不包含 `<` 和 `>`，否则会报错）。
- `document.createAttribute(name)` 生成一个新的属性节点（Attr 实例），并返回它。参数是属性的名称。
- `document.createTextNode(data)` 用来生成**文本节点**（Text 实例），并返回该节点。它的参数是文本节点的内容。

  - 该方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。
  - 该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。

    ```javascript
    var div = document.createElement('div');
    div.appendChild(document.createTextNode('<span>Foo & bar</span>'));
    console.log(div.innerHTML)
    // &lt;span&gt;Foo &amp; bar&lt;/span&gt;
    ```

    上面代码中，`createTextNode()` 对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。

- `document.createComment(data)` 生成一个新的注释节点，并返回该节点。参数是一个字符。
- `document.createEvent(type)` 生成一个事件对象（`Event` 实例），该对象可以被 `element.dispatchEvent()` 方法使用，触发指定事件。

  `document.createEvent()` 的参数是事件类型，比如 `UIEvents`、`MouseEvents`、`MutationEvents`、`HTMLEvents`。

  ```javascript
  var event = document.createEvent('Event');
  event.initEvent('build', true, true);
  document.addEventListener('build', function (e) {
    console.log(e.type); // "build"
  }, false);
  document.dispatchEvent(event);
  ```

  上面代码新建了一个名为 `build` 的事件实例，然后触发该事件。

#### 3.7 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()

这三个方法用于处理 `document` 节点的事件。它们都继承自 `EventTarget` 接口，详细介绍参见《EventTarget 接口》一章。

```javascript
// 添加事件监听函数
document.addEventListener('click', listener, false);
// 移除事件监听函数
document.removeEventListener('click', listener, false);
// 触发事件
var event = new Event('click');
document.dispatchEvent(event);
```

#### 3.8 document.hasFocus()

`document.hasFocus()` 返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。

注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。

#### 3.9 document.adoptNode()，document.importNode()

- `document.adoptNode()` 将某个节点及其子节点，从原来所在的文档或 `DocumentFragment` 里面移除，归属当前 `document` 对象，返回插入后的新节点。插入的节点对象的 `ownerDocument` 属性，会变成当前的 `document` 对象，而 `parentNode` 属性是 `null`。

  ```javascript
  var node = document.adoptNode(externalNode);
  document.appendChild(node);
  ```

  注意，`document.adoptNode()` 只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用 `appendChild()` 方法或 `insertBefore()` 方法，将新节点插入当前文档树。

- `document.importNode()` 从原来所在的文档或 `DocumentFragment` 里面，**拷贝**某个节点及其子节点，让它们归属当前 `document` 对象。拷贝的节点对象的 `ownerDocument` 属性，会变成当前的 `document` 对象，而 `parentNode` 属性是 `null`。

  ```javascript
  var node = document.importNode(externalNode, deep);
  ```

  `document.importNode()` 的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（`false`）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为 `true`。

  注意，`document.importNode()` 只是拷贝外部节点，这时该节点的父节点是 `null`。下一步还必须将这个节点插入当前文档树。

  ```javascript
  var iframe = document.getElementsByTagName('iframe')[0];
  var oldNode = iframe.contentWindow.document.getElementById('myNode');
  var newNode = document.importNode(oldNode, true);
  document.getElementById("container").appendChild(newNode);
  ```

  上面代码从 `iframe` 窗口拷贝一个指定节点 `myNode` 插入当前文档。

#### 3.10 document.createNodeIterator()，document.createTreeWalker()

`document.createNodeIterator(root, whatToShow, filter)` 返回一个子节点遍历器。`document.createNodeIterator()` 第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型。几种主要的节点类型写法如下。

- 所有节点：`NodeFilter.SHOW_ALL`
- 元素节点：`NodeFilter.SHOW_ELEMENT`
- 文本节点：`NodeFilter.SHOW_TEXT`
- 评论节点：`NodeFilter.SHOW_COMMENT`

```javascript
var nodeIterator = document.createNodeIterator(
  document.body,
  NodeFilter.SHOW_ELEMENT
);
```

上面代码返回 `<body>` 元素子节点的遍历器。

`document.createNodeIterator()` 返回一个“遍历器”对象（`NodeFilter` 实例）。该实例的 `nextNode()` 和 `previousNode()` 可以用来遍历所有子节点。

```javascript
var nodeIterator = document.createNodeIterator(document.body);
var pars = [];
var currentNode;
while (currentNode = nodeIterator.nextNode()) {
  pars.push(currentNode);
}
```

上面代码中，使用遍历器的 `nextNode()` 方法，将根节点的所有子节点，依次读入一个数组。`nextNode()` 方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回 `null`。`previousNode()` 方法则是先将指针移向上一个节点，然后返回该节点。

注意，遍历器返回的第一个节点，总是**根节点**。

```javascript
pars[0] === document.body // true
```

`document.createTreeWalker(root, whatToShow, filter)` 返回一个 DOM 的子树遍历器。它与 `document.createNodeIterator()` 基本类似，区别在于它返回的是 `TreeWalker` 实例且第一个节点不是根节点。

#### 3.11 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()

##### （1）document.execCommand()

如果 `document.designMode` 属性设为 `on`，那么整个文档用户可编辑；如果元素的 `contenteditable` 属性设为 `true`，那么该元素可编辑。这两种情况下，可以使用 `document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)`，改变内容的样式，比如 `document.execCommand('bold')` 会使得字体加粗。

```javascript
document.execCommand(command, showDefaultUI, input)
```

该方法接受三个参数。

- `command`：字符串，表示所要实施的样式。
- `showDefaultUI`：布尔值，表示是否要使用默认的用户界面，建议总是设为 `false`。
- `input`：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为 `true`，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。

`document.execCommand()` 的返回值是一个布尔值。如果为 `false`，表示这个方法无法生效。

这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。

##### （2）document.queryCommandSupported()

`document.queryCommandSupported(command)` 返回一个布尔值，表示浏览器是否支持 `document.execCommand()` 的某个命令。

##### （3）document.queryCommandEnabled()

`document.queryCommandEnabled(command)` 返回一个布尔值，表示当前是否可用 `document.execCommand()` 的某个命令。比如，`bold`（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。

```javascript
// HTML 代码为
// <input type="button" value="Copy" onclick="doCopy()">

function doCopy(){
  // 浏览器是否支持 copy 命令（选中内容复制到剪贴板）
  if (document.queryCommandSupported('copy')) {
    copyText('你好');
  }else{
    console.log('浏览器不支持');
  }
}

function copyText(text) {
  var input = document.createElement('textarea');
  document.body.appendChild(input);
  input.value = text;
  input.focus();
  input.select();

  // 当前是否有选中文字
  if (document.queryCommandEnabled('copy')) {
    var success = document.execCommand('copy');
    input.remove();
    console.log('Copy Ok');
  } else {
    console.log('queryCommandEnabled is false');
  }
}
```

上面代码中，先判断浏览器是否支持 `copy` 命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。

#### 3.12 document.getSelection()

这个方法指向 `window.getSelection()`，参见 `window` 对象一节的介绍。

## 六、Element 节点

### 1. 简介

`Element` 节点对象对应网页的 HTML 元素。每个 HTML 元素，在 DOM 树上都会转化成一个 `Element` 节点对象。不同的 HTML 元素对应不同的的元素节点，浏览器使用不同的构造函数，生成不同的元素节点，比如 `<a>` 元素的构造函数是`HTMLAnchorElement()`，`<button>` 是 `HTMLButtonElement()`。因此，元素节点不是一种对象，而是许多种对象，这些对象除了继承 `Element` 对象的属性和方法，还有各自独有的属性和方法。

### 2. 实例属性

#### 2.1 元素特性的相关属性

- `Element.id`：返回指定元素的 `id` 属性，该属性可读写。
- `Element.tagName`：返回指定元素的大写标签名，与 `nodeName` 属性的值相等。
- `Element.dir`：用于读写当前元素的文字方向，可能是从左到右（"`ltr`"），也可能是从右到左（"`rtl`"）。
- `Element.accessKey`：用于读写分配给当前元素的快捷键。
- `Element.draggable`：返回一个布尔值，表示当前元素是否可拖动。该属性**可读写**。
- `Element.lang`：返回当前元素的语言设置。该属性**可读写**。
- `Element.tabIndex`：返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性**可读写**。

  - 如果是正整数，则按照顺序，从小到大遍历。
  - 如果是负值（通常是 `-1`），则 Tab 键不会遍历到该元素。
  - 如果两个元素的 `tabIndex` 属性的正整数值相同，则按照出现的顺序遍历。
  - 遍历完所有 `tabIndex` 为正整数的元素以后，再遍历所有 `tabIndex` 等于 `0`、或者属性值是非法值、或者没有 `tabIndex` 属性的元素，顺序为它们在网页中出现的顺序。

- `Element.title`：用来读写当前元素的 HTML 属性 `title`。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。

#### 2.2 元素状态的相关属性

- `Element.hidden`：返回一个布尔值，表示当前 HTML 元素的 `hidden` 属性的值。该属性**可读写**，用来控制当前元素**是否可见**。

  - 该属性与 CSS 设置互相独立。CSS 对当前元素可见性的设置，`Element.hidden` 并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。
  - CSS 设置的优先级高于 `Element.hidden`。如果 CSS 指定了该元素不可见（`display: none`）或可见（`visibility: visible`），那么 `Element.hidden` 并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。

- `Element.contentEditable`：返回一个字符串，表示是否设置了 `contenteditable` 属性，HTML 元素可以设置 `contentEditable` 属性，使得元素的内容可以编辑。有三种可能的值。该属性可写。

  - `"true"`：元素内容可编辑；
  - `"false"`：元素内容不可编辑；
  - `"inherit"`：元素是否可编辑，继承了父元素的设置。

  ```html
  <div contenteditable>123</div>
  ```

- `Element.isContentEditable`：返回一个布尔值，同样表示是否设置了 `contenteditable` 属性。该属性只读。

#### 2.3 Element.attributes

`Element.attributes` 属性返回一个类似数组的对象，成员是当前元素节点的所有**属性节点**。

#### 2.4 Element.className，Element.classList

- `className` 属性用来读写当前元素节点的 `class` 属性。它的值是一个字符串，每个 `class` 之间用空格分割。
- `classList` 属性返回一个类似数组的**对象**，当前元素节点的每个 `class` 就是这个对象的一个成员。

```javascript
// HTML 代码 <div class="one two three" id="myDiv"></div>
var div = document.getElementById('myDiv');
div.className
// "one two three"
div.classList
// {
//   0: "one"
//   1: "two"
//   2: "three"
//   length: 3
// }
```

`classList` 对象有下列方法。

- `add()`：增加一个 `class`。
- `remove()`：移除一个 `class`。
- `contains()`：检查当前元素是否包含某个 `class`。
- `toggle()`：将某个 `class` 移入或移出当前元素，该方法可以接受一个布尔值，作为第二个参数。如果为 `true`，则添加该属性；如果为 `false`，则去除该属性。。
- `item()`：返回指定索引位置的 `class`。
- `toString()`：将 `class` 的列表转为字符串。

```javascript
var div = document.getElementById('myDiv');
div.classList.add('myCssClass');
div.classList.add('foo', 'bar');
div.classList.remove('myCssClass');
div.classList.toggle('myCssClass'); // 如果 myCssClass 不存在就加入，否则移除
div.classList.contains('myCssClass'); // 返回 true 或者 false
div.classList.item(0); // 返回第一个 Class
div.classList.toString();
```

#### 2.5 Element.dataset

网页元素可以自定义 `data-` 属性，用来添加数据。`Element.dataset` 属性返回一个对象，可以从这个对象读写 `data-` 属性。

```javascript
// <article
//   id="foo"
//   data-columns="3"
//   data-index-number="12314"
//   data-parent="cars">
//   ...
// </article>
var article = document.getElementById('foo');
article.dataset.columns // "3"
article.dataset.indexNumber // "12314"
article.dataset.parent // "cars"
```

HTML 代码中，`data-` 属性的属性名，只能包含英文字母、数字、连词线（`-`）、点（`.`）、冒号（`:`）和下划线（`_`）。它们转成 JavaScript 对应的 `dataset` 属性名，规则如下。

- 开头的 `data-` 会省略。
- 如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。
- 其他字符不变。

因此，`data-abc-def` 对应 `dataset.abcDef`，`data-abc-1` 对应 `dataset["abc-1"]`。

除了使用 `dataset` 读写 `data-` 属性，也可以使用 `Element.getAttribute()` 和 `Element.setAttribute()`，通过完整的属性名读写这些属性。

```javascript
var mydiv = document.getElementById('mydiv');
mydiv.dataset.foo = 'bar';
mydiv.getAttribute('data-foo') // "bar"
```

#### 2.6 Element.innerHTM，Element.outerHTML

- `Element.innerHTML` 属性返回一个字符串，表示该元素**包含的**所有 HTML 代码。该属性**可读写**，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括 `<HTML>` 和 `<body>` 元素。
  
  - 如果将 `innerHTML` 属性设为空，等于删除所有它包含的所有节点。
  - 读取属性值的时候，如果文本节点包含 `&`、小于号（`<`）和大于号（`>`），`innerHTML` 属性会将它们转为实体形式 `&amp;`、`&lt;`、`&gt;`。
  - 如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有 `<script>` 标签，虽然可以生成 `script` 节点，但是插入的代码不会执行。
  - 如果想得到原文，或者为了安全考虑，如果插入的是文本，最好用 `Element.textContent` 属性代替 `innerHTML`。

  ```javascript
  // HTML代码如下 <p id="para"> 5 > 3 </p>
  document.getElementById('para').innerHTML
  // 5 &gt; 3
  ```

- `Element.outerHTML` 属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括**该元素**本身和**所有子元素**，该属性**可读写**。如果一个节点没有父节点，设置 `outerHTML` 属性会报错。

  ```javascript
  // HTML 代码如下
  // <div id="d"><p>Hello</p></div>
  var d = document.getElementById('d');
  d.outerHTML
  // '<div id="d"><p>Hello</p></div>'
  ```

#### 2.7 Element.clientWidth，Element.clientHeight，Element.clientLeft，Element.clientTop

- `Element.clientWidth` 属性返回元素节点的 **CSS 宽度**（单位像素），只对**块级元素**有效，包括元素本身的宽度和 `padding`（不包括 `border`、`margin`），如果有垂直滚动条，还要减去垂直滚动条的宽度。
- `Element.clientHeight` 属性返回元素节点的 **CSS 高度**（单位像素），只对**块级元素**生效，包括元素本身的高度和 `padding`（不包括 `border`、`margin`），对于行内元素返回 `0`。如果块级元素没有设置 CSS 高度，则返回实际高度。

  - `document.documentElement` 的 `clientHeight` 属性，返回当前**视口**的高度（即浏览器窗口的高度），等同于 `window.innerHeight` 属性减去水平滚动条的高度（如果有的话）。
  - `document.body` 的高度返回**网页**的**实际高度**。

  一般来说，`document.body.clientHeight` 大于 `document.documentElement.clientHeight`。

  ```javascript
  document.documentElement.clientHeight // 视口高度
  document.body.clientHeight // 网页总高度
  ```

- `Element.clientLeft` 属性等于元素节点**左边框**（left border）的**宽度**（单位像素），不包括左侧的 `padding` 和 `margin`。如果没有设置左边框，或者是行内元素（`display: inline`），该属性返回 `0`。该属性总是返回整数值，如果是小数，会四舍五入。
- `Element.clientTop` 属性等于网页元素**顶部边框**的**宽度**（单位像素），其他特点都与 `clientLeft` 相同。

#### 2.8 Element.scrollWidth，Element.scrollHeight，Element.scrollLeft，Element.scrollTop

- `Element.scrollWidth` 和 `Element.scrollHeight` 属性返回一个整数值（小数会四舍五入），表示当前元素的总宽度和总高度（单位像素）。

  整张网页的总高度可以从 `document.documentElement` 或 `document.body` 上读取。

  ```javascript
  // 返回网页的总高度
  document.documentElement.scrollHeight
  document.body.scrollHeight
  ```

这两个属性都包括溢出容器部分、当前不可见的部分、`padding` 和伪元素（`::before` 或 `::after`）的高度，但是不包括 `border`、`margin` 以及水平滚动条的高度（如果有水平滚动条的话）。

- `Element.scrollLeft` 属性表示当前元素的水平滚动条向右侧滚动的像素数量。
- `Element.scrollTop` 属性表示当前元素的垂直滚动条向下滚动的像素数量。

如果要查看整张网页的水平的和垂直的滚动距离，要从 `document.documentElement` 元素上读取。

```javascript
document.documentElement.scrollLeft
document.documentElement.scrollTop
```

#### 2.9 Element.offsetWidth，Element.offsetHeight，Element.offsetLeft，Element.offsetTop，Element.offsetParent

- `Element.offsetWidth` 属性表示元素的 CSS **水平宽度**（单位像素），包括元素本身的宽度、`padding` 和 `border`，以及垂直滚动条的宽度（如果存在滚动条）。
- `Element.offsetHeight` 属性表示元素的 CSS **垂直高度**（单位像素），包括元素本身的高度、`padding` 和 `border`，以及水平滚动条的高度（如果存在滚动条）。

这两个属性都是**只读**属性，只比 `Element.clientHeight` 和 `Element.clientWidth` 多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如 `display: none;`），则返回 `0`。

- `Element.offsetParent` 属性返回最靠近当前元素的、并且 CSS 的 `position` 属性不等于 `static` 的上层元素。

  ```html
  <div style="position: absolute;">
    <p>
      <span>Hello</span>
    </p>
  </div>
  ```

  上面代码中，`span` 元素的 `offsetParent` 属性是 `div` 元素。

- `Element.offsetLeft` 返回当前元素左上角相对于 `Element.offsetParent` 节点的水平位移。
- `Element.offsetTop` 返回垂直位移，单位为像素。

通常，`Element.offsetLeft` 和 `Element.offsetTop` 是指相对于父节点的位移。

#### 2.10 Element.style

`style` 属性用来读写该元素的行内样式信息。

#### 2.11 Element.children，Element.childElementCount，Element.firstElementChild，Element.lastElementChild

- `Element.children` 属性返回一个类似数组的对象（`HTMLCollection` 实例），包括当前**元素节点**的所有子元素。
- `Element.childElementCount` 属性返回当前元素节点包含的子元素节点的个数，与 `Element.children.length` 的值相同。
- `Element.firstElementChild` 属性返回当前元素的第一个元素子节点。
- `Element.lastElementChild` 属性返回当前元素的最后一个元素子节点。

#### 2.12 Element.nextElementSibling，Element.previousElementSibling

- `Element.previousElementSibling` 属性返回当前元素节点的前一个同级元素节点。
- `Element.nextElementSibling` 属性返回当前元素节点的后一个同级元素节点。

### 3. 实例方法

#### 3.1 属性相关方法

元素节点提供六个方法，用来操作属性。

- `getAttribute()`：读取某个属性的值。
- `getAttributeNames()`：返回当前元素的所有属性名。
- `setAttribute()`：写入属性值。
- `hasAttribute()`：某个属性是否存在。
- `hasAttributes()`：当前元素是否有属性。
- `removeAttribute()`：删除属性。

#### 3.1 Element.querySelector()，Element.querySelectorAll()

- `Element.querySelector(selectors)` 接受 CSS 选择器作为参数（多个选择器之间用逗号分隔），返回父元素的**第一个**匹配的子元素。该方法可以接受复杂的 CSS 选择器。

  浏览器执行 `querySelector()` 时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。

  ```javascript
  // HTML 代码
  // <div>
  // <blockquote id="outer">
  //   <p>Hello</p>
  //   <div id="inner">
  //     <p>World</p>
  //   </div>
  // </blockquote>
  // </div>
  var outer = document.getElementById('outer');
  outer.querySelector('div p')
  // <p>Hello</p>
  ```

  上面代码实际上返回的是第一个 `p` 元素，而不是第二个。

- `Element.querySelectorAll(selectors)` 接受 CSS 选择器作为参数多个选择器之间用逗号分隔），返回一个 `NodeList` 实例，包含所有匹配的子元素。该方法的执行机制与 `querySelector` 方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。

#### 3.2 Element.getElementsByClassName()，Element.getElementsByTagName()

- `Element.getElementsByClassName(names)` 返回一个 `HTMLCollection` 实例，成员是**当前节点**的所有具有指定 `class` 的子元素节点。
- `Element.getElementsByTagName(tagName)` 返回一个 `HTMLCollection` 实例，成员是**当前节点**的所有匹配指定标签名的子元素节点。

这两个方法与 `document.getElementsByClassName()` 的用法类似，只是搜索范围不是整个文档，而是**当前**元素节点。

```javascript
element.getElementsByClassName('red test');
table.getElementsByTagName('td');
```

#### 3.3 Element.closest()

`Element.closest(selectors)` 方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个**祖先节点**（包括当前节点本身）。

```javascript
// HTML 代码如下
// <article>
//   <div id="div-01">Here is div-01
//     <div id="div-02">Here is div-02
//       <div id="div-03">Here is div-03</div>
//     </div>
//   </div>
// </article>
var div03 = document.getElementById('div-03');
// div-03 最近的祖先节点
div03.closest("#div-02") // div-02
div03.closest("div div") // div-03
div03.closest("article > div") //div-01
div03.closest(":not(div)") // article
```

上面代码中，由于 `closest()` 将当前节点也考虑在内，所以第二个 `closest()` 方法返回 `div-03`。

#### 3.4 Element.matches()

`Element.matches(selectors)` 返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。

#### 3.5 事件相关方法

以下三个方法与 `Element` 节点的事件相关。这些方法都继承自 `EventTarget` 接口，详见相关章节。

- `Element.addEventListener()`：添加事件的回调函数
- `Element.removeEventListener()`：移除事件监听函数
- `Element.dispatchEvent()`：触发事件

#### 3.6 Element.scrollIntoView()

`Element.scrollIntoView(alignToTop | options)` 滚动当前元素，进入浏览器的可见区域，类似于设置 `window.location.hash` 的效果。

```javascript
el.scrollIntoView(); // 等同于 el.scrollIntoView(true)
el.scrollIntoView(false);
```

该方法可以接受一个布尔值作为参数。如果为 `true`，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为 `false`，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为 `true`。

#### 3.7 Element.getBoundingClientRect()，Element.getClientRects()

- `Element.getBoundingClientRect()` 返回一个 `rect` 对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。该对象具有以下属性（全部为只读）。

  - `x`：元素左上角相对于视口的横坐标
  - `y`：元素左上角相对于视口的纵坐标
  - `left`：元素左上角相对于视口的横坐标，与 `x` 属性相等
  - `right`：元素右边界相对于视口的横坐标（等于 `x + width`）
  - `top`：元素顶部相对于视口的纵坐标，与 `y` 属性相等
  - `bottom`：元素底部相对于视口的纵坐标（等于 `y + height`）
  - `width`：元素宽度
  - `height`：元素高度

  由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将 `left` 属性加上 `window.scrollX`，`top` 属性加上 `window.scrollY`。

  注意，`Element.getBoundingClientRect()` 的所有属性，都把边框（`border` 属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，`width` 和 `height` 包括了元素本身 + `padding` + `border`。

- `Element.getClientRects()` 返回一个类似数组的**对象**，里面是当前元素在页面上形成的所有**矩形**（所以方法名中的 Rect 用的是复数）。每个矩形都有 `top`、`bottom`、`left`、`right`、`width` 和 `height` 六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。

  对于盒状元素（比如 `<div>` 和 `<p>`），该方法返回的对象中只有该元素一个成员。对于行内元素（比如 `<span>`、`<a>`、`<em>`），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和 `Element.getBoundingClientRect()` 的主要区别，后者对于行内元素总是返回一个矩形。

```javascript
var el = document.getElementById('inline');
el.getClientRects().length // 3
el.getClientRects()[0].left // 8
el.getClientRects()[0].right // 113.908203125
el.getClientRects()[0].bottom // 31.200000762939453
el.getClientRects()[0].height // 23.200000762939453
el.getClientRects()[0].width // 105.908203125
```

这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。

#### 3.8 Element.insertAdjacentElement()，Element.insertAdjacentHTML()，Element.insertAdjacentText()

- `Element.insertAdjacentElement(position, element)` 在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点。
- `Element.insertAdjacentHTML(position, text)` 用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。
- `Element.insertAdjacentText(where, data)` 在相对于当前节点的指定位置，插入一个文本节点。

这三个方法都可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点/待解析的 HTML 字符串/将要插入的文本内容。第一个参数只可以取如下的值。

- `beforebegin`：当前元素之前
- `afterbegin`：当前元素内部的第一个子节点前面
- `beforeend`：当前元素内部的最后一个子节点后面
- `afterend`：当前元素之后

```javascript
// HTML 代码：<div id="one">one</div>
var d1 = document.getElementById('one');
d1.insertAdjacentHTML('afterend', '<div id="two">two</div>');
// 执行后的 HTML 代码：
// <div id="one">one</div><div id="two">two</div>
```

#### 3.9 Element.remove()

`Element.remove()` 继承自 `ChildNode` 接口，用于将当前元素节点从它的父节点移除。

#### 3.10 Element.focus()，Element.blur()

- `Element.focus()` 用于将当前页面的焦点，转移到指定元素上。`document.activeElement` 属性可以得到当前获得焦点的元素。
- `Element.blur()` 用于将焦点从指定元素移除。

`Element.focus()` 可以接受一个对象作为参数。参数对象的 `preventScroll` 属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。

```javascript
function getFocus() {
  document.getElementById('btn').focus({ preventScroll: false });
}
```

上面代码会让 `btn` 元素获得焦点，并滚动到可见区域。

#### 3.11 Element.click()

`Element.click()` 用于在当前元素上模拟一次鼠标点击，相当于触发了 `click` 事件。

## 七、属性的操作

### 1. Element.attributes 属性

`attributes` 属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的**实时**变化都会反映在这个节点对象上。

### 2. 元素的标准属性

HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。这些属性都是可写的。

HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如 `onClick`。

### 3. 属性操作的标准方法

#### 3.1 概述

元素节点提供六个方法，用来操作属性。

- `getAttribute()`
- `getAttributeNames()`
- `setAttribute()`
- `hasAttribute()`
- `hasAttributes()`
- `removeAttribute()`

#### 3.2 Element.getAttribute()

- `Element.getAttribute(property)` 方法返回当前元素节点的指定属性。
- `Element.getAttributeNames()` 返回一个数组，成员是当前元素的所有属性的名字。
- `Element.setAttribute(property, value)` 方法用于为当前元素节点新增属性。
- `Element.hasAttribute(property)` 方法返回一个布尔值，表示当前元素节点是否包含指定属性。
- `Element.hasAttributes()` 方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回 `false`，否则返回 `true`。
- `Element.removeAttribute(property)` 方法移除指定属性。该方法没有返回值。

### 4. dataset 属性

参考 [Element.dataset](#25-elementdataset)。

## 八、Text 节点和 DocumentFragment 节点

### 1. Text 节点的概念

文本节点（`Text`）代表元素节点（`Element`）和属性节点（`Attribute`）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。

通常我们使用父节点的 `firstChild`、`nextSibling` 等属性获取文本节点，或者使用 `Document` 节点的 `createTextNode()` 创造一个文本节点。

浏览器原生提供一个 `Text` 构造函数。它返回一个文本节点实例，参数是该文本节点的文本内容。

文本节点除了继承 `Node` 接口，还继承了 `CharacterData` 接口。

```javascript
var text1 = new Text(); // 空字符串
var text2 = new Text('This is a text node'); // 非空字符串
```

注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，`<p> </p>`包含一个空格，它的子节点就是一个文本节点。

### 2. Text 节点的属性

- `data` 属性等同于 `nodeValue` 属性，用来设置或读取文本节点的内容。
- `length` 属性返回当前文本节点的文本长度。
- `previousElementSibling` 属性返回当前文本节点前面最近的同级元素节点。
- `nextElementSibling` 属性返回紧跟在当前文本节点后面的那个同级元素节点。
- `wholeText` 属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，`wholeText` 属性的返回值，与 `data` 属性和 `textContent` 属性相同。

  ```javascript
  // <p id="para">A <em>B</em> C</p>
  var el = document.getElementById('para');
  el.firstChild.wholeText // "A "
  el.firstChild.data // "A "
  ```

  但是，一旦移除 `<em>` 节点，`wholeText` 属性与 `data` 属性就会有差异，因为这时其实 `<p>` 节点下面包含了两个毗邻的文本节点。

  ```javascript
  el.removeChild(para.childNodes[1]);
  el.firstChild.wholeText // "A C"
  el.firstChild.data // "A "
  ```

### 3. Text 节点的方法

- `appendData(str)`：在 `Text` 节点尾部追加字符串。
- `deleteData(startIndex, str)`：删除 `Text` 节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。
- `insertData(index, str)`：在 `Text` 节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。
- `replaceData(startIndex, replacedStr, str)`：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。
- `subStringData(startIndex, length)`：用于获取子字符串，第一个参数为子字符串在 `Text` 节点中的开始位置，第二个参数为子字符串长度。

- `remove()` 方法用于移除当前 `Text` 节点。

- `splitText(offset)` 方法将 `Text` 节点一分为二，变成两个毗邻的 `Text` 节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。分割后，该方法返回分割位置后方的字符串，而原 `Text` 节点变成只包含分割位置前方的字符串。

  ```javascript
  // html 代码为 <p id="p">foobar</p>
  var p = document.getElementById('p');
  var textnode = p.firstChild;
  var newText = textnode.splitText(3);
  newText // "bar"
  textnode // "foo"
  ```

  父元素节点的 `normalize()` 方法可以将毗邻的两个 `Text` 节点合并。

  ```javascript
  p.childNodes.length // 2
  // 将毗邻的两个 Text 节点合并
  p.normalize();
  p.childNodes.length // 1
  ```

### 4. DocumentFragment 节点

`DocumentFragment` 节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，`parentNode` 返回 `null`，但是可以插入任意数量的子节点。它不属于当前文档，操作 `DocumentFragment` 节点，要比直接操作 DOM 树快得多。

它一般用于构建一个 DOM 结构，然后插入当前文档。`document.createDocumentFragment()`，以及浏览器原生的 `DocumentFragment` 构造函数，可以创建一个空的 `DocumentFragment` 节点。然后再使用其他 DOM 方法，向其添加子节点。

```javascript
var docFrag = document.createDocumentFragment();
// 等同于
var docFrag = new DocumentFragment();
var li = document.createElement('li');
li.textContent = 'Hello World';
docFrag.appendChild(li);
document.querySelector('ul').appendChild(docFrag);
```

注意，`DocumentFragment` 节点**本身不能被插入当前文档**。当它作为 `appendChild()`、`insertBefore()`、`replaceChild()` 等方法的参数时，是它的所有**子节点**插入当前文档，而不是它自身。一旦 `DocumentFragment` 节点被添加进当前文档，它自身就变成了空节点（`textContent` 属性为空字符串），可以被再次使用。如果想要保存 `DocumentFragment` 节点的内容，可以使用 `cloneNode` 方法。

`DocumentFragment` 节点对象没有自己的属性和方法，全部继承自 `Node` 节点和 `ParentNode` 接口。也就是说，`DocumentFragment` 节点比 `Node` 节点多出以下四个属性。

- `children`：返回一个动态的 `HTMLCollection` 集合对象，包括当前 `DocumentFragment` 对象的所有子元素节点。
- `firstElementChild`：返回当前 `DocumentFragment` 对象的第一个子元素节点。
- `lastElementChild`：返回当前 `DocumentFragment` 对象的最后一个子元素节点。
- `childElementCount`：返回当前 `DocumentFragment` 对象的所有子元素数量。

## 九、

```javascript

```

```javascript

```

```javascript

```

## 十、Mutation Observer API

### 1. 概述

**Mutation Observer API 用来监视 DOM 变动**。概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是**异步触发**，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。

Mutation Observer 有以下特点。

- 它等待所有脚本任务完成后，才会运行（即异步触发方式）。
- 它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。
- 它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。

### 2. MutationObserver 构造函数

MutationObserver 构造函数会创建一个观察器实例，它接受一个回调函数，回调函数会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例。

```javascript
var observer = new MutationObserver(function (mutations, observer) {
  mutations.forEach(function(mutation) {
    console.log(mutation);
  });
});
```

### 3. MutationObserver 的实例方法

- `disconnect()` 用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。
- `takeRecords()` 用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。
- `observe(target[, options])` 用来启动监听，它接受两个参数。

  - 第一个参数：所要观察的 DOM 节点
  - 第二个参数：一个配置对象，指定所要观察的特定变动

  观察器所能观察的 DOM 变动类型（即 `options` 配置对象），有以下几种。

  - `childList`：子节点的变动（指新增，删除或者更改）。
  - `attributes`：属性的变动。
  - `characterData`：节点内容或节点文本的变动。

  想要观察哪一种变动类型，就在 `option` 对象中指定它的值为 `true`。至少必须同时指定这三种观察的一种，若均未指定将报错。

  除了变动类型，`options` 对象还可以设定以下属性：

  - `subtree`：布尔值，表示是否将该观察器应用于该节点的所有后代节点。
  - `attributeOldValue`：布尔值，表示观察 `attributes` 变动时，是否需要记录变动前的属性值。
  - `characterDataOldValue`：布尔值，表示观察 `characterData` 变动时，是否需要记录变动前的值。
  - `attributeFilter`：数组，表示需要观察的特定属性（比如['class','src']）。

  ```javascript
  // 开始监听文档根节点（即 <html> 标签）的变动
  mutationObserver.observe(document.documentElement, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true,
    attributeOldValue: true,
    characterDataOldValue: true
  });
  ```

### 4. MutationRecord 对象

DOM 每次发生变化，就会生成一条变动记录（`MutationRecord` 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个 `MutationRecord` 实例所组成的数组。

`MutationRecord` 对象包含了 DOM 的相关信息，有如下属性：

- `type`：观察的变动类型（`childList`、`attributes` 或者 `characterData`）。
- `target`：发生变动的 DOM 节点。
- `previousSibling`：前一个同级节点，如果没有则返回 `null`。
- `nextSibling`：下一个同级节点，如果没有则返回 `null`。
- `attributeName`：发生变动的属性。如果设置了 `attributeFilter`，则只返回预先指定的属性。
- `oldValue`：变动前的值。这个属性只对 `attribute` 和 `characterData` 变动有效，如果发生 `childList` 变动，则返回 `null`。
- `addedNodes`：新增的 DOM 节点。
- `removedNodes`：删除的 DOM 节点。

### 5. 应用示例

#### 5.1 子元素的变动

下面的例子说明如何读取变动记录。

```javascript
var mo = new MutationObserver(function (records){
  records.map(function(record){
    console.log('Mutation type: ' + record.type);
    console.log('Mutation target: ' + record.target);
  });
});
mo.observe(document.body, {
  'childList': true,
  'subtree': true
});
```

#### 5.2 属性的变动

下面的例子说明如何追踪属性的变动。

```javascript
var mo = new MutationObserver(function (records) {
  records.map(function (record) {
    console.log('Previous attribute value: ' + record.oldValue);
  });
});
mo.observe(document.getElementById('#my_element'), {
  'attributes': true,
  'attributeOldValue': true
});
```

#### 5.3 取代 DOMContentLoaded 事件

网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用 `DOMContentLoaded` 事件。

```javascript
var observer = new MutationObserver(callback);
observer.observe(document.documentElement, {
  childList: true,
  subtree: true
});
```

上面代码中，监听 `document.documentElement`（即网页的 `<html>` HTML 节点）的子节点的变动，`subtree` 属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。

下面的代码，使用 MutationObserver 对象封装一个监听 DOM 生成的函数。

```javascript
(function(win){
  'use strict';

  var listeners = [];
  var doc = win.document;
  var MutationObserver = win.MutationObserver || win.WebKitMutationObserver;
  var observer;

  function ready(selector, fn){
    // 储存选择器和回调函数
    listeners.push({
      selector: selector,
      fn: fn
    });
    if(!observer){
      // 监听document变化
      observer = new MutationObserver(check);
      observer.observe(doc.documentElement, {
        childList: true,
        subtree: true
      });
    }
    // 检查该节点是否已经在DOM中
    check();
  }

  function check(){
  // 检查是否匹配已储存的节点
    for(var i = 0; i < listeners.length; i++){
      var listener = listeners[i];
      // 检查指定节点是否有匹配
      var elements = doc.querySelectorAll(listener.selector);
      for(var j = 0; j < elements.length; j++){
        var element = elements[j];
        // 确保回调函数只会对该元素调用一次
        if(!element.ready){
          element.ready = true;
          // 对该节点调用回调函数
          listener.fn.call(element, element);
        }
      }
    }
  }

  // 对外暴露ready
  win.ready = ready;

})(this);

// 使用方法
ready('.foo', function(element){
  // ...
});
```

## 十一、参考

- 阮一峰，[JavaScript 教程 - DOM](https://wangdoc.com/javascript/dom/)