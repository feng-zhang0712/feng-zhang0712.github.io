---
layout: post
title: 《JavaScript 教程》摘录
categories: blog
tags:
  - javascript
  - dom
---

> 本文是对[《JavaScript 教程 - DOM》](https://wangdoc.com/javascript/dom/)一章中部分知识点的摘录，主要包含了重点内容，以及对笔者来说模糊的知识点。

## 一、概述

DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。

DOM 的最小组成单位叫做**节点**（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。

节点的类型有七种。

- `Document`：整个文档树的顶层节点
- `DocumentType`：`doctype` 标签（比如 `<!DOCTYPE html>`）
- `Element`：网页的各种 HTML 标签（比如 `<body>`、`<a>` 等）
- `Attr`：网页元素的属性（比如 `class="right"`）
- `Text`：标签之间或标签包含的文本
- `Comment`：注释
- `DocumentFragment`：文档的片段

浏览器提供一个原生的节点对象 `Node`，上面这七种节点都继承了 `Node`，因此具有一些共同的属性和方法。

一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 **DOM 树**。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，又像一棵树。

浏览器原生提供 `document` 节点，代表整个文档。

文档的第一层有两个节点，第一个是文档类型节点（`<!doctype html>`），第二个是 HTML 网页的顶层容器标签 `<html>`。后者构成了树结构的**根节点**（root node），其他 HTML 标签节点都是它的下级节点。除了根节点，其他节点都有三种层级关系。

- 父节点关系（parentNode）：直接的那个上级节点
- 子节点关系（childNodes）：直接的下级节点
- 同级节点关系（sibling）：拥有同一个父节点的节点

DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括 `firstChild`（第一个子节点）和 `lastChild`（最后一个子节点）等属性，同级节点接口包括 `nextSibling`（紧邻在后的那个同级节点）和 `previousSibling`（紧邻在前的那个同级节点）属性。

## 二、Node 接口

所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。

### 1. 属性

#### 1.1 Node.prototype.nodeType

`nodeType` 属性返回一个整数值，表示节点的**类型**。Node 对象定义了几个常量，对应这些类型值。不同节点的 `nodeType` 属性值和对应的常量如下。

- 元素节点（element）：`1`，对应常量 `Node.ELEMENT_NODE`
- 属性节点（attr）：`2`，对应常量 `Node.ATTRIBUTE_NODE`
- 文本节点（text）：`3`，对应常量 `Node.TEXT_NODE`
- 注释节点（Comment）：`8`，对应常量 `Node.COMMENT_NODE`
- 文档节点（document）：`9`，对应常量 `Node.DOCUMENT_NODE`
- 文档类型节点（DocumentType）：`10`，对应常量 `Node.DOCUMENT_TYPE_NODE`
- 文档片断节点（DocumentFragment）：`11`，对应常量 `Node.DOCUMENT_FRAGMENT_NODE`

```javascript
document.nodeType // 9
document.nodeType === Node.DOCUMENT_NODE // true
```

#### 1.2 Node.prototype.nodeName

`nodeName` 属性返回节点的**名称**。不同节点的 `nodeName` 属性值如下。

- 元素节点（element）：大写的标签名
- 属性节点（attr）：属性的名称
- 文本节点（text）：`#text`
- 注释节点（Comment）：`#comment`
- 文档节点（document）：`#document`
- 文档片断节点（DocumentFragment）：`#document-fragment`
- 文档类型节点（DocumentType）：文档的类型

```javascript
// HTML 代码如下
// <div id="d1">hello world</div>
var div = document.getElementById('d1');
div.nodeName // "DIV"
```

上面代码中，元素节点 `<div>` 的 `nodeName` 属性就是大写的标签名 `DIV`。

#### 1.3 Node.prototype.nodeValue

`nodeValue` 属性返回一个字符串，表示当前节点本身的**文本值**，该属性**可读写**。

只有**文本节点**（text）、**注释节点**（comment）和**属性节点**（attr）有文本值，因此这三类节点的 `nodeValue` 可以返回结果，其他类型的节点一律返回 `null`。也只有这三类节点可以设置 `nodeValue` 属性的值，其他类型的节点设置无效。

```javascript
// HTML 代码如下
// <div id="d1">hello world</div>
var div = document.getElementById('d1');
div.nodeValue // null
div.firstChild.nodeValue // "hello world"
```

上面代码中，`div` 是元素节点，`nodeValue` 属性返回 `null`。`div.firstChild` 是文本节点，所以可以返回文本值。

#### 1.4 Node.prototype.textContent

`textContent` 属性返回**当前节点和它的所有后代节点**的**文本内容**。

- `textContent` 属性自动忽略当前节点内部的 HTML 标签，返回所有**文本内容**。
- 该属性**可读写**，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它会自动对 HTML 标签转义。

```javascript
// HTML 代码为
// <div id="divA">This is <span>some</span> text</div>

document.getElementById('divA').textContent
// This is some text
```

#### 1.5 Node.prototype.baseURI

`baseURI` 属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为**只读**。

该属性的值一般由当前网址的 URL（即 `window.location` 属性）决定，但是可以使用 HTML 的 `<base>` 标签，改变该属性的值。

```javascript
// 当前网页的网址为
// http://www.example.com/index.html
document.baseURI
// "http://www.example.com/index.html"

<base href="http://www.example.com/page.html">
```

#### 1.6 Node.prototype.ownerDocument

`Node.ownerDocument` 属性返回当前节点所在的顶层文档对象，即 `document` 对象。

```javascript
var d = p.ownerDocument;
d === document // true
```

#### 1.7 Node.prototype.previousSibling，Node.prototype.nextSibling

- `previousSibling` 属性返回当前节点**前面的**、**距离最近的一个同级节点**。如果当前节点前面没有同级节点，则返回 `null`。
`nextSibling` 属性返回紧跟在当前节点**后面的第一个同级节点**。如果当前节点后面没有同级节点，则返回 `null`。

```javascript
// HTML 代码如下
// <div id="d1">hello</div><div id="d2">world</div>
var d1 = document.getElementById('d1');
var d2 = document.getElementById('d2');

d2.previousSibling === d1 // true

// HTML 代码如下
// <div id="d1">hello</div><div id="d2">world</div>
var d1 = document.getElementById('d1');
var d2 = document.getElementById('d2');

d1.nextSibling === d2 // true
```

注意，这两个属性还包括文本节点和注释节点（<!-- comment -->）。因此如果当前节点前面/后面有空格，他们都会返回一个文本节点，内容为空格。

#### 1.8 Node.prototype.parentNode

- `parentNode` 属性返回当前节点的**父节点**。对于一个节点来说，它的父节点只可能是三种类型：**元素节点**（element）、**文档节点**（document）和**文档片段节点**（documentfragment）。文档节点（document）和文档片段节点（documentfragment）的父节点都是 `null`。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是 `null`。
- `parentElement` 属性返回当前节点的**父元素节点**。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回 `null`。由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。`parentElement` 属性相当于把后两种父节点都排除了。

```javascript
if (node.parentNode) {
  node.parentNode.removeChild(node);
}

if (node.parentElement) {
  node.parentElement.style.color = 'red';
}
```

#### 1.9 Node.prototype.firstChild，Node.prototype.lastChild

- `firstChild` 属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回 `null`。`firstChild` 返回的除了元素节点，还可能是文本节点或注释节点。
- `lastChild` 属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回 `null`。用法与 `firstChild` 属性相同。

#### 1.10 Node.prototype.childNodes

`childNodes` 属性返回一个类似数组的对象（`NodeList` 集合），成员包括当前节点的所有子节点。

`childNodes` 属性的返回值包括**元素节点**、**文本节点**和**注释节点**。如果当前节点不包括任何子节点，则返回一个空的 `NodeList` 集合。由于 `NodeList` 对象是一个**动态集合**，一旦子节点发生变化，立刻会反映在返回结果之中。

#### 1.11 Node.prototype.isConnected

`isConnected` 属性返回一个布尔值，表示当前节点是否在文档之中。

### 2. 方法

#### 2.1 Node.prototype.appendChild()

`appendChild()` 方法接受一个节点对象作为参数，将其作为**最后一个**子节点，插入当前节点。该方法的返回值就是插入文档的子节点。

```javascript
var p = document.createElement('p');
document.body.appendChild(p);
```

如果参数节点是 DOM 已经存在的节点，`appendChild()` 方法会将其从原来的位置，**移动**到新位置。

```javascript
var div = document.getElementById('myDiv');
document.body.appendChild(div);
```

#### 2.2 Node.prototype.hasChildNodes()

`hasChildNodes()` 方法返回一个布尔值，表示当前节点是否有子节点（子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，`hasChildNodes()` 方法也会返回 `true`。）。

#### 2.3 Node.prototype.cloneNode()

`cloneNode()` 方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。

```javascript
var cloneUL = document.querySelector('ul').cloneNode(true);
```

- 克隆一个节点，会拷贝该节点的所有属性，但是会丧失 `addEventListener()` 方法和 `on-属性`（即 `node.onclick = fn`），添加在这个节点上的事件回调函数。
- 该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如 `Node.appendChild()` 这样的方法添加到文档之中。
- 克隆一个节点之后，DOM 有可能出现两个有相同 `id` 属性的网页元素，这时应该修改其中一个元素的 `id` 属性。如果原节点有 `name` 属性，可能也需要修改。

#### 2.4 Node.prototype.insertBefore()

`insertBefore()` 方法用于将某个节点插入父节点内部的指定位置。

```javascript
var p = document.createElement('p');
document.body.insertBefore(p, document.body.firstChild);
```

上面代码中，新建一个 `<p>` 节点，插在 `document.body.firstChild` 的前面，也就是成为 `document.body` 的第一个子节点。

`insertBefore()` 方法接受两个参数：

- 第一个参数是所要插入的节点 `newNode`。
- 第二个参数是父节点 `parentNode` 内部的一个子节点 `referenceNode`。如果第二个参数为 `null`，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。

`newNode` 将插在 `referenceNode` 这个子节点的前面。返回值是插入的新节点 newNode。

由于不存在 `insertAfter` 方法，如果新节点要插在父节点的某个子节点后面，可以用 `insertBefore()` 方法结合 `nextSibling` 属性模拟。

```javascript
parent.insertBefore(s1, s2.nextSibling);
```

上面代码中，`parent` 是父节点，`s1` 是一个全新的节点，`s2` 是可以将 `s1` 节点，插在 `s2` 节点的后面。如果 `s2` 是当前节点的最后一个子节点，则 `s2.nextSibling` 返 回 `null`，这时 `s1` 节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在 `s2` 的后面。

#### 2.5 Node.prototype.removeChild()

`removeChild()` 方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。

```javascript
var divA = document.getElementById('A');
divA.parentNode.removeChild(divA);
```

#### 2.6 Node.prototype.replaceChild()

`replaceChild()` 方法用于将一个新的节点，替换当前节点的某一个子节点。

```javascript
var replacedNode = parentNode.replaceChild(newChild, oldChild);
```

#### 2.7 Node.prototype.contains()

`contains()` 方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。

- 参数节点为**当前节点**。
- 参数节点为当前节点的**子节点**。
- 参数节点为当前节点的**后代节点**。

#### 2.8 Node.prototype.compareDocumentPosition()

`compareDocumentPosition()` 方法的用法，与 `contains()` 方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的**关系**。

- `000000`：十进制的 0，表示两个节点**相同**
- `000001`：十进制的 1，表示两个节点不在同一个文档（即有一个节点不在当前文档）
- `000010`：十进制的 2，表示参数节点在当前节点的**前面**
- `000100`：十进制的 4，表示参数节点在当前节点的**后面**
- `001000`：十进制的 8，表示参数节点**包含**当前节点
- `010000`：十进制的 16，表示当前节点**包含**参数节点
- `100000`：十进制的 32，表示浏览器内部使用

```javascript
// HTML 代码如下
// <div id="mydiv">
//   <form><input id="test" /></form>
// </div>

var div = document.getElementById('mydiv');
var input = document.getElementById('test');

div.compareDocumentPosition(input) // 20
input.compareDocumentPosition(div) // 10
```

上面代码中，节点 `div` 包含节点 `input`（二进制 `010000`），而且节点 `input` 在节点 `div` 的后面（二进制 `000100`），所以第一个 `compareDocumentPosition()` 方法返回 `20`（二进制 `010100`，即 `010000` + `000100`），第二个 `compareDocumentPosition()` 方法返回 `10`（二进制 `001010`）。

由于 `compareDocumentPosition()` 返回值的含义，定义在每个比特位上，所以如果要检查某种特定的含义，就需要使用比特位运算符。

```javascript
var head = document.head;
var body = document.body;
if (head.compareDocumentPosition(body) & 4) {
  console.log('文档结构正确');
} else {
  console.log('<body> 不能在 <head> 前面');
}
```

上面代码中，`compareDocumentPosition()` 的返回值与 `4`（又称掩码）进行与运算（`&`），得到一个布尔值，表示 `<head>` 是否在 `<body>` 前面。

#### 2.9 Node.prototype.isEqualNode()，Node.prototype.isSameNode()

- `isEqualNode()` 方法返回一个布尔值，用于检查两个节点是否**相等**。所谓相等的节点，指的是两个节点的**类型**相同、**属性**相同、**子节点**相同。
- `isSameNode()` 方法返回一个布尔值，表示两个节点是否为**同一个**节点。

#### 2.10 Node.prototype.normalize()

`normalize()` 方法用于清理当前节点内部的所有**文本节点**（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。该方法是 `Text.splitText()` 的逆方法。

```javascript
var wrapper = document.createElement('div');

wrapper.appendChild(document.createTextNode('Part 1 '));
wrapper.appendChild(document.createTextNode('Part 2 '));

wrapper.childNodes.length // 2
wrapper.normalize();
wrapper.childNodes.length // 1
```

上面代码使用 `normalize()` 方法之前，`wrapper` 节点有两个毗邻的文本子节点。使 `normalize()` 方法之后，两个文本子节点被合并成一个。

#### 2.11 Node.prototype.getRootNode()

`getRootNode()` 方法返回当前节点所在文档的根节点 `document`，与 `ownerDocument` 属性的作用相同。

## 三、NodeList 接口，HTMLCollection 接口

DOM 提供两种节点集合，用于容纳多个节点：`NodeList` 和 `HTMLCollection`。`NodeList` 可以包含各种类型的节点，`HTMLCollection` 只能包含 HTML 元素节点。

### 1. NodeList 接口

#### 1.1 概述

`NodeList` 实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到 `NodeList` 实例。

- `Node.childNodes`
- `document.querySelectorAll()` 等节点搜索方法

`NodeList` 是对象不是数组，但可以使用 `length` 属性和 `forEach()` 方法。如果要使用数组的其他方法，应先将其转为数组。

注意，`NodeList` 实例可能是**动态集合**，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 `NodeList` 实例。目前，只有 `Node.childNodes` 返回的是一个动态集合，其他的 `NodeList` 都是静态集合。

#### 1.2 NodeList.prototype.length

`length` 属性返回 `NodeList` 实例包含的节点数量。

#### 1.3 NodeList.prototype.forEach()

`forEach()` 方法用于遍历 `NodeList` 的所有成员。

#### 1.4 NodeList.prototype.item()

`item()` 方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（`[]`），而不使用 `item()` 方法。

```javascript
document.body.childNodes.item(0)
document.body.childNodes[0]
```

#### 1.5 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()

这三个方法都返回一个 ES6 的**遍历器对象**，可以通过 `for...of` 循环遍历获取每一个成员的信息。区别在于，`keys()` 返回键名的遍历器，`values()` 返回键值的遍历器，`entries()` 返回的遍历器同时包含键名和键值的信息。

```javascript
var children = document.body.childNodes;

for (var key of children.keys()) {
  console.log(key);
}
// 0
// 1
// 2
// ...

for (var value of children.values()) {
  console.log(value);
}
// #text
// <script>
// ...

for (var entry of children.entries()) {
  console.log(entry);
}
// Array [ 0, #text ]
// Array [ 1, <script> ]
// ...
```

### 2. HTMLCollection 接口

#### 2.1 概述

`HTMLCollection` 是一个只包含**元素节点**（element）对象的集合，，不包含其他类型的节点。它的返回值是一个类似数组的对象，`HTMLCollection` 只能使用 `for` 循环遍历。

返回 `HTMLCollection` 实例的，主要是一些 `Document` 对象的集合属性，比如 `document.links`、`document.forms`、`document.images` 等。

如果元素节点有 `id` 或 `name` 属性，那么 `HTMLCollection` 实例上面，可以使用 `id` 属性或 `name` 属性引用该节点元素。如果没有对应的节点，则返回 `null`。

```javascript
// HTML 代码如下
// <img id="pic" src="http://example.com/foo.jpg">

var pic = document.getElementById('pic');
document.images.pic === pic // true
```

上面代码中，`document.images` 是一个 `HTMLCollection` 实例，可以通过 `<img>` 元素的 `id` 属性值，从 `HTMLCollection` 实例上取到这个元素。

#### 2.2 HTMLCollection.prototype.length

`length` 属性返回 `HTMLCollection` 实例包含的成员数量。

#### 2.3 HTMLCollection.prototype.item()

`item()` 方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。一般情况下使用方括号运算符（`[]`），而不使用 `item()` 方法。

```javascript
var c = document.images;
var img0 = c.item(0);
```

#### 2.4 HTMLCollection.prototype.namedItem()

`namedItem()` 方法的参数是一个字符串，表示 `id` 属性或 `name` 属性的值，返回当前集合中对应的元素节点。如果没有对应的节点，则返回 `null`。

```javascript
// HTML 代码如下
// <img id="pic" src="http://example.com/foo.jpg">

var pic = document.getElementById('pic');
document.images.namedItem('pic') === pic // true
```

`Collection.namedItem('value')` 等同于 `Collection['value']`。

## 四、

节点对象除了继承 `Node` 接口以外，还拥有其他接口。`ParentNode` 接口表示当前节点是一个父节点，提供一些处理子节点的方法。`ChildNode` 接口表示当前节点是一个子节点，提供一些相关方法。

### 1. ParentNode 接口

如果当前节点是父节点，就会混入（mixin）`ParentNode` 接口。只有**元素节点**（element）、**文档节点**（document）和**文档片段节点**（documentFragment）拥有 `ParentNode` 接口。

#### 1.1 ParentNode.children

`children` 属性返回一个 `HTMLCollection` 实例，成员是当前节点的**所有元素子节点**。该属性只读。

#### 1.2 ParentNode.firstElementChild，ParentNode.lastElementChild

- `firstElementChild` 属性返回当前节点的**第一个元素子节点**。
- `lastElementChild` 属性返回当前节点的**最后一个元素子节点**。

#### 1.3 ParentNode.childElementCount

`childElementCount` 属性返回一个整数，表示当前节点的所有元素子节点的数目。

#### 1.4 ParentNode.append()，ParentNode.prepend()

- `append()` 方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。该方法可以添加**元素节点**（参数为元素节点）和**文本节点**（参数为字符串）。
- `prepend()` 方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与 `append()` 方法完全一致，也是没有返回值。

注意，`append()` 方法与 `Node.prototype.appendChild()` 方法有三点不同。

- `append()` 允许字符串作为参数，`appendChild()` 只允许子节点作为参数。
- `append()` 没有返回值，而 `appendChild()` 返回添加的子节点。
- `append()` 可以添加多个子节点和字符串（即允许多个参数），`appendChild()` 只能添加一个节点（即只允许一个参数）。

```javascript
var parent = document.body;

// 添加元素子节点
var p = document.createElement('p');
parent.append(p);

// 添加文本子节点
parent.append('Hello');

// 添加多个元素子节点
var p1 = document.createElement('p');
var p2 = document.createElement('p');
parent.append(p1, p2);

// 添加元素子节点和文本子节点
var p = document.createElement('p');
parent.append('Hello', p);
```

### 2. ChildNode 接口

如果一个节点有父节点，那么该节点就拥有了 `ChildNode` 接口。

#### 2.1 ChildNode.remove()

`remove()` 方法用于从父节点移除当前节点。

```javascript
el.remove()
```

#### 2.2 ChildNode.before()，ChildNode.after()

- `before()` 方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。该方法可以插入**元素节点**和**文本节点**。
- `after()` 方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与 `before()` 方法完全相同。

```javascript
var p = document.createElement('p');
var p1 = document.createElement('p');

// 插入元素节点
el.before(p);

// 插入文本节点
el.before('Hello');

// 插入多个元素节点
el.before(p, p1);

// 插入元素节点和文本节点
el.before(p, 'Hello');
```

#### 2.3 ChildNode.replaceWith()

`replaceWith()` 方法使用参数节点，替换当前节点。参数可以是**元素节点**，也可以是**文本节点**。

```javascript
var span = document.createElement('span');
el.replaceWith(span);
```

## 五、Document 节点

### 1. 概述

`document` 节点对象代表整个文档，每张网页都有自己的 `document` 对象。`window.document` 属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。

`document` 对象有不同的办法可以获取。

- 正常的网页，直接使用 `document` 或 `window.document`。
- `iframe` 框架里面的网页，使用 iframe 节点的 `contentDocument` 属性。
- Ajax 操作返回的文档，使用 `XMLHttpRequest` 对象的 `responseXML` 属性。
- 内部节点的 `ownerDocument` 属性。

`document` 对象继承了 `EventTarget` 接口和 `Node` 接口，并且混入（mixin）了 `ParentNode` 接口。这意味着，这些接口的方法都可以在 `document` 对象上调用。除此之外，`document` 对象还有很多自己的属性和方法。

### 2. 属性

#### 2.1 快捷方式属性

以下属性是指向文档内部的某个节点的快捷方式。

- `document.defaultView`：返回 `document` 对象所属的 `window` 对象。如果当前文档不属于 `window` 对象，该属性返回 `null`。
- `document.doctype`：`document` 对象一般有两个子节点。第一个子节点是 `document.doctype`，指向 `<DOCTYPE>` 节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成 `<!DOCTYPE html>`。
- `document.documentElement`：返回当前文档的**根元素节点**（root）。它通常是 `document` 节点的第二个子节点，紧跟在 `document.doctype` 节点后面。HTML 网页的该属性，一般是 `<html>` 节点。
- `document.head`：指向 `<head>` 节点，该属性**可读写**。
- `document.body`：指向 `<body>` 节点，该属性**可读写**。
- `document.scrollingElement`：返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。标准模式下，这个属性返回的文档的根元素 `document.documentElement`（即 `<html>`）。兼容（quirk）模式下，返回的是 `<body>` 元素，如果该元素不存在，返回 `null`。
- `document.activeElement`：返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是 `<input>`、`<textarea>`、`<select>` 等表单元素，如果当前没有焦点元素，返回 `<body>` 元素或 `null`。
- `document.fullscreenElement`：返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回 `null`。

#### 2.2 节点集合属性

以下属性（除 `document.styleSheets` 属性外）返回一个 `HTMLCollection` 实例，表示文档内部特定元素的集合。这些集合都是**动态的**，原节点有任何变化，立刻会反映在集合中。

- `document.links`：返回当前文档所有设定了 href 属性的 `<a>` 及 `<area>` 节点。
- `document.forms`：返回所有 `<form>` 表单节点。
- `document.images`：返回页面所有 `<img>` 图片节点。
- `document.embeds`，`document.plugins`：所有 `<embed>` 节点。
- `document.scripts`：返回所有 `<script>` 节点。
- `document.styleSheets`：返回网页内嵌或引入的 CSS 样式表集合。

除了 `document.styleSheets` 属性，以上的其他集合属性返回的都是 `HTMLCollection` 实例。`document.styleSheets` 属性返回的是 `StyleSheetList` 实例。

#### 2.3 文档静态信息属性

- `document.documentURI`，`document.URL`：返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，`documentURI` 继承自 `Document` 接口，可用于所有文档；`URL` 继承自 `HTMLDocument` 接口，只能用于 HTML 文档。
- `document.domain`：返回当前文档的**域名**，不包含协议和端口。
- `document.location`：`Location` 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 `window.location` 和 `document.location` 属性，可以拿到这个对象。
- `document.lastModified`：返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。
- `document.title`：返回当前文档的标题。默认情况下，返回 `<title>` 节点的值。该属性**可读写**。
- `document.characterSet`：返回当前文档的编码，比如 UTF-8 等等。
- `document.referrer`：返回一个字符串，表示当前文档的访问者来自哪里。`document.referrer` 的值，总是与 HTTP 头信息的 `Referer` 字段保持一致。
- `document.dir`：返回一个字符串，表示文字方向。它有两个可能的值：`rtl` 表示文字从右到左，阿拉伯文是这种方式；`ltr` 表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。
- `document.compatMode`：返回浏览器处理文档的模式，可能的值为 `BackCompat`（向后兼容模式）和 `CSS1Compat`（严格模式）。一般来说，如果网页代码的第一行设置了明确的 `DOCTYPE`（比如 `<!doctype html>`），`document.compatMode` 的值都为 `CSS1Compat`。

#### 2.4 文档状态属性

- `document.hidden`：返回一个布尔值，表示当前页面**是否可见**。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得 `document.hidden` 返回 `true`。
- `document.visibilityState`：返回文档的**可见状态**。

  - `visible`：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。
  - `hidden`：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。
  - `prerender`：页面处于正在渲染状态，对于用户来说，该页面不可见。
  - `unloaded`：页面从内存里面卸载了。

- `document.readyState`：返回当前文档的**状态**，共有三种可能的值。

  - `loading`：加载 HTML 代码阶段（尚未完成解析）。
  - `interactive`：加载外部资源阶段。
  - `complete`：加载完成。

`document.readyState` 属性变化的过程如下。

1. 浏览器开始解析 HTML 文档，`document.readyState` 属性等于 `loading`。
2. 浏览器遇到 HTML 文档中的 `<script>` 元素，并且没有 `async` 或 `defer` 属性，就暂停解析，开始执行脚本，这时 `document.readyState` 属性还是 `loading`。
3. HTML 文档解析完成，`document.readyState` 属性变成 `interactive`。
4. 浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，`document.readyState` 属性变成 `complete`。

#### 2.5 document.cookie

`document.cookie` 属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。

#### 2.6 document.designMode

`document.designMode` 属性控制当前文档是否可编辑。该属性只有两个值 `on` 和 `off`，默认值为 `off`。

#### 2.7 document.currentScript

`document.currentScript` 属性只用在 `<script>` 元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即 `<script>` 元素的 DOM 节点。

```html
<script id="foo">
  console.log(
    document.currentScript === document.getElementById('foo')
  ); // true
</script>
```

上面代码中，`document.currentScript` 就是 `<script>` 元素节点。

#### 2.8 document.implementation

`document.implementation` 属性返回一个 `DOMImplementation` 对象。该对象有三个方法，主要用于创建独立于当前文档的新的 `Document` 对象。

- `DOMImplementation.createDocument()`：创建一个 XML 文档。
- `DOMImplementation.createHTMLDocument()`：创建一个 HTML 文档。
- `DOMImplementation.createDocumentType()`：创建一个 DocumentType 对象。

下面是创建 HTML 文档的例子。

```javascript
var doc = document.implementation.createHTMLDocument('Title');
var p = doc.createElement('p');
p.innerHTML = 'hello world';
doc.body.appendChild(p);

document.replaceChild(
  doc.documentElement,
  document.documentElement
);
```

上面代码中，第一步生成一个新的 HTML 文档 `doc`，然后用它的根元素 `doc.documentElement` 替换掉 `document.documentElement`。这会使得当前文档的内容全部消失，变成 `hello world`。

### 3. 方法

#### 3.1 document.open()，document.close()

- `document.open()` 方法清除当前文档所有内容，使得文档处于**可写状态**，供 `document.write` 方法写入内容。
- `document.close()` 方法用来关闭 `document.open()` 打开的文档。

```javascript
document.open();
document.write('hello world');
document.close();
```

#### 3.2 document.write()，document.writeln()

`document.write()` 方法用于向当前文档写入内容。`document.write` 是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对 `innerHTML` 属性赋值）。所以，除了某些特殊情况，应该尽量**避免使用** `document.write()` 这个方法。

- `document.write()` 会当作 HTML 代码解析，不会转义。
- 在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行 `document.close()`），`document.write()` 写入的内容就会追加在已有内容的后面。
- 如果页面已经解析完成（`DOMContentLoaded` 事件发生之后），再调用 `write()` 方法，它会先调用 `open()` 方法，擦除当前文档所有内容，然后再写入。

`document.writeln()` 方法与 `write()` 方法完全一致，除了会在输出内容的尾部添加换行符。注意，`document.writeln()` 方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入 `<br>`。

#### 3.3 document.querySelector()，document.querySelectorAll()

`document.querySelector()` 方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回**第一个**匹配的节点。
`document.querySelectorAll()` 方法与 `querySelector()` 用法类似，区别是返回一个 `NodeList` 对象，包含所有匹配给定选择器的节点。

这两个方法不支持 CSS 伪元素的选择器（比如 `:first-line` 和 `:first-letter`）和伪类的选择器（比如 `:link` 和 `:visited`），即无法选中伪元素和伪类。

这两个方法都可以在 `document` 对象以及元素节点上调用。

#### 3.4 document.getElementById()，document.getElementsByName()，document.getElementsByClassName()，document.getElementsByTagName()

- `document.getElementById()` 方法返回匹配指定 `id` 属性的元素节点。该方法的参数大小写敏感且只能在 `document` 对象上使用。
- `document.getElementsByClassName()` 方法返回一个类似数组的对象（`HTMLCollection` 实例），包括了所有 `class` 名字符合指定条件的元素，元素的变化**实时**反映在返回结果中。该方法可以在 `document` 对象以及元素节点上调用。
- `document.getElementsByTagName()` 方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（`HTMLCollection` 实例），可以**实时**反映 HTML 文档的变化。该方法可以在 `document` 对象以及元素节点上调用。
- `document.getElementsByName()` 方法用于选择拥有 `name` 属性的 HTML 元素（比如 `<form>`、`<radio>`、`<img>`、`<frame>`、`<embed>` 和 `<object>` 等），返回一个类似数组的的对象（`NodeList` 实例），因为 `name` 属性相同的元素可能不止一个。

#### 3.5 document.elementFromPoint()，document.elementsFromPoint()

- `document.elementFromPoint()` 方法返回位于页面指定位置**最上层**的元素节点。该方法的两个参数，依次是相对于当前视口**左上角**的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。
- `document.elementsFromPoint()` 返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。

```javascript
var element = document.elementFromPoint(50, 50);
```

上面代码选中在 `(50, 50)` 这个坐标位置的最上层的那个 HTML 元素。

#### 3.6 document.createElement()，document.createTextNode()，document.createAttribute()，document.createComment()，document.createDocumentFragment()，document.createEvent()

- `document.createElement()` 方法用来生成元素节点，并返回该节点。参数为元素的标签名（不包含 `<` 和 `>`，否则会报错）。
- `document.createTextNode()` 方法用来生成**文本节点**（Text 实例），并返回该节点。它的参数是文本节点的内容。

  - 该方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。
  - 该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。

    ```javascript
    var div = document.createElement('div');
    div.appendChild(document.createTextNode('<span>Foo & bar</span>'));
    console.log(div.innerHTML)
    // &lt;span&gt;Foo &amp; bar&lt;/span&gt;
    ```

    上面代码中，`createTextNode()` 方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。

- `document.createAttribute()` 方法生成一个新的属性节点（Attr 实例），并返回它。参数是属性的名称。
- `document.createComment()` 方法生成一个新的注释节点，并返回该节点。参数是一个字符。
- `document.createDocumentFragment()` 方法生成一个空的文档片段对象（`DocumentFragment` 实例）。

  `DocumentFragment` 是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为 `DocumentFragment` 不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。

- `document.createEvent()` 方法生成一个事件对象（`Event` 实例），该对象可以被 `element.dispatchEvent()` 方法使用，触发指定事件。

  `document.createEvent()` 方法的参数是事件类型，比如 `UIEvents`、`MouseEvents`、`MutationEvents`、`HTMLEvents`。

  ```javascript
  var event = document.createEvent('Event');
  event.initEvent('build', true, true);
  document.addEventListener('build', function (e) {
    console.log(e.type); // "build"
  }, false);
  document.dispatchEvent(event);
  ```

  上面代码新建了一个名为 `build` 的事件实例，然后触发该事件。

#### 3.7 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()

这三个方法用于处理 `document` 节点的事件。它们都继承自 `EventTarget` 接口，详细介绍参见《EventTarget 接口》一章。

```javascript
// 添加事件监听函数
document.addEventListener('click', listener, false);

// 移除事件监听函数
document.removeEventListener('click', listener, false);

// 触发事件
var event = new Event('click');
document.dispatchEvent(event);
```

#### 3.8 document.hasFocus()

`document.hasFocus()` 方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。

注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。

#### 3.9 document.adoptNode()，document.importNode()

`document.adoptNode()` 方法将某个节点及其子节点，从原来所在的文档或 `DocumentFragment` 里面移除，归属当前 `document` 对象，返回插入后的新节点。插入的节点对象的 `ownerDocument` 属性，会变成当前的 `document` 对象，而 `parentNode` 属性是 `null`。

```javascript
var node = document.adoptNode(externalNode);
document.appendChild(node);
```

注意，`document.adoptNode()` 方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用 `appendChild()` 方法或 `insertBefore()` 方法，将新节点插入当前文档树。

`document.importNode()` 方法从原来所在的文档或 `DocumentFragment` 里面，**拷贝**某个节点及其子节点，让它们归属当前 `document` 对象。拷贝的节点对象的 `ownerDocument` 属性，会变成当前的 `document` 对象，而 `parentNode` 属性是 `null`。

```javascript
var node = document.importNode(externalNode, deep);
```

`document.importNode()` 方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（`false`）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为 `true`。

注意，`document.importNode()` 方法只是拷贝外部节点，这时该节点的父节点是 `null`。下一步还必须将这个节点插入当前文档树。

```javascript
var iframe = document.getElementsByTagName('iframe')[0];
var oldNode = iframe.contentWindow.document.getElementById('myNode');
var newNode = document.importNode(oldNode, true);
document.getElementById("container").appendChild(newNode);
```

上面代码从 `iframe` 窗口，拷贝一个指定节点 `myNode`，插入当前文档。

#### 3.10 document.createNodeIterator()，document.createTreeWalker()

`document.createNodeIterator()` 方法返回一个子节点遍历器。`document.createNodeIterator()` 方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型。几种主要的节点类型写法如下。

- 所有节点：NodeFilter.SHOW_ALL
- 元素节点：NodeFilter.SHOW_ELEMENT
- 文本节点：NodeFilter.SHOW_TEXT
- 评论节点：NodeFilter.SHOW_COMMENT

```javascript
var nodeIterator = document.createNodeIterator(
  document.body,
  NodeFilter.SHOW_ELEMENT
);
```

上面代码返回 `<body>` 元素子节点的遍历器。

`document.createNodeIterator()` 方法返回一个“遍历器”对象（`NodeFilter` 实例）。该实例的 `nextNode()` 方法和` previousNode()` 方法，可以用来遍历所有子节点。

```javascript
var nodeIterator = document.createNodeIterator(document.body);
var pars = [];
var currentNode;

while (currentNode = nodeIterator.nextNode()) {
  pars.push(currentNode);
}
```

上面代码中，使用遍历器的 `nextNode()` 方法，将根节点的所有子节点，依次读入一个数组。`nextNode()` 方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回 `null`。`previousNode()` 方法则是先将指针移向上一个节点，然后返回该节点。

注意，遍历器返回的第一个节点，总是**根节点**。

```javascript
pars[0] === document.body // true
```

`document.createTreeWalker()` 方法返回一个 DOM 的子树遍历器。它与 `document.createNodeIterator()` 方法基本类似，区别在于它返回的是 `TreeWalker` 实例且第一个节点不是根节点。

#### 3.11 document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()

##### （1）document.execCommand()

如果 `document.designMode` 属性设为 `on`，那么整个文档用户可编辑；如果元素的 `contenteditable` 属性设为 `true`，那么该元素可编辑。这两种情况下，可以使用 `document.execCommand()` 方法，改变内容的样式，比如 `document.execCommand('bold')` 会使得字体加粗。

```javascript
document.execCommand(command, showDefaultUI, input)
```

该方法接受三个参数。

- `command`：字符串，表示所要实施的样式。
- `showDefaultUI`：布尔值，表示是否要使用默认的用户界面，建议总是设为 `false`。
- `input`：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为 `true`，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。

`document.execCommand()` 的返回值是一个布尔值。如果为 `false`，表示这个方法无法生效。

这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。

##### （2）document.queryCommandSupported()

`document.queryCommandSupported()` 方法返回一个布尔值，表示浏览器是否支持 `document.execCommand()` 的某个命令。

##### （3）document.queryCommandEnabled()

`document.queryCommandEnabled()` 方法返回一个布尔值，表示当前是否可用 `document.execCommand()` 的某个命令。比如，`bold`（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。

```javascript
// HTML 代码为
// <input type="button" value="Copy" onclick="doCopy()">

function doCopy(){
  // 浏览器是否支持 copy 命令（选中内容复制到剪贴板）
  if (document.queryCommandSupported('copy')) {
    copyText('你好');
  }else{
    console.log('浏览器不支持');
  }
}

function copyText(text) {
  var input = document.createElement('textarea');
  document.body.appendChild(input);
  input.value = text;
  input.focus();
  input.select();

  // 当前是否有选中文字
  if (document.queryCommandEnabled('copy')) {
    var success = document.execCommand('copy');
    input.remove();
    console.log('Copy Ok');
  } else {
    console.log('queryCommandEnabled is false');
  }
}
```

上面代码中，先判断浏览器是否支持 `copy` 命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。

#### 3.12 document.getSelection()

这个方法指向 `window.getSelection()`，参见 `window` 对象一节的介绍。

## 六、Element 节点

### 1. 简介

### 2. 实例属性

#### 2.1 元素特性的相关属性

```javascript

```

```javascript

```

```javascript

```

#### 2.2 元素状态的相关属性

```javascript

```

```javascript

```

```javascript

```

#### 2.3 Element.attributes

```javascript

```

```javascript

```

```javascript

```

#### 2.4 Element.className，Element.classList

```javascript

```

```javascript

```

```javascript

```

#### 2.5 Element.dataset

```javascript

```

```javascript

```

```javascript

```

#### 2.6 Element.innerHTM，Element.outerHTML

```javascript

```

```javascript

```

```javascript

```

#### 2.7 Element.clientLeft，Element.clientTop，Element.clientHeight，Element.clientWidth

```javascript

```

```javascript

```

```javascript

```

#### 2.8 Element.scrollLeft，Element.scrollTop，Element.scrollHeight，Element.scrollWidth

```javascript

```

```javascript

```

```javascript

```

#### 2.9 Element.offsetLeft，Element.offsetTop，Element.offsetHeight，Element.offsetWidth，Element.offsetParent

```javascript

```

```javascript

```

```javascript

```

#### 2.10 Element.style

```javascript

```

```javascript

```

```javascript

```

#### 2.11 Element.children，Element.childElementCount，Element.firstElementChild，Element.lastElementChild

```javascript

```

```javascript

```

```javascript

```

#### 2.12 Element.nextElementSibling，Element.previousElementSibling

```javascript

```

```javascript

```

```javascript

```

### 3. 实例方法

#### 3.1 属性相关方法

```javascript

```

```javascript

```

```javascript

```

#### 3.1 Element.querySelector()，Element.querySelectorAll()

```javascript

```

```javascript

```

```javascript

```

#### 3.2 Element.getElementsByClassName()，Element.getElementsByTagName()

```javascript

```

```javascript

```

```javascript

```

#### 3.3 Element.closest()

```javascript

```

```javascript

```

```javascript

```

#### 3.4 Element.matches()

```javascript

```

```javascript

```

```javascript

```

#### 3.5 事件相关方法

```javascript

```

```javascript

```

```javascript

```

#### 3.6 Element.scrollIntoView()

```javascript

```

```javascript

```

```javascript

```

#### 3.7 Element.getBoundingClientRect()，Element.getClientRects()

```javascript

```

```javascript

```

```javascript

```

#### 3.8 Element.insertAdjacentElement()，Element.insertAdjacentHTML()，Element.insertAdjacentText()

```javascript

```

```javascript

```

```javascript

```

#### 3.9 Element.remove()

```javascript

```

```javascript

```

```javascript

```

#### 3.10 Element.focus()，Element.blur()

```javascript

```

```javascript

```

```javascript

```

#### 3.11 Element.click()

```javascript

```

```javascript

```

```javascript

```

## 七、

```javascript

```

## 八、

```javascript

```

## 九、

```javascript

```

## 十、

## 十一、参考

- 阮一峰，[JavaScript 教程 - DOM](https://wangdoc.com/javascript/dom/)