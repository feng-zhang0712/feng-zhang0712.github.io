---
layout: post
title: ES6 - Function
categories: blog
tags:
  - React
  - ES6
  - Function
---

> 本文是对[《ECMAScript 6 入门 - 函数的扩展》](https://es6.ruanyifeng.com/#docs/function)一章中知识点的摘录，请访问原文，获取更多详细信息。

## 一、函数参数的默认值

ES6 允许为函数的参数设置默认值。

参数默认值可以与解构赋值的默认值，结合起来使用。函数参数的默认值生效以后，参数解构赋值依然会进行。

```javascript
function f({ a, b = 'world' } = { a: 'hello' }) {
  console.log(b);
}

f() // world
```

指定了默认值以后，函数的 `length` 属性，将返回没有指定默认值的参数个数。`length` 属性的含义是该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，`rest` 参数也不会计入 `length` 属性。

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。

利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。

```javascript
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo() // Error: Missing parameter
```

可以将参数默认值设为 `undefined`，表明这个参数是可以省略的。

```javascript
function foo(optional = undefined) {
  // ...
}
```

- 默认值生效的条件是对应位置的值严格等于 `undefined`。
- 使用参数默认值时，函数不能有同名参数。
- 参数默认值是**惰性求值**的。参数默认值不是传值的，而是每次都重新计算默认值表达式的值。
- 通常情况下，定义了默认值的参数，应该是函数的尾参数。
- 对于使用了默认值的参数，参数变量是默认声明的，所以函数体内不能使用 `let` 或 `const` 再次声明。

## 二、rest 参数

ES6 引入 `rest` 参数（形式为 `...` 变量名），用于获取函数的多余参数，这样就不需要使用 `arguments` 对象了。

- `arguments` 对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用 `Array.from` 先将其转为数组。`rest` 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。
- `rest` 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
- 函数的 `length` 属性，不包括 `rest` 参数。

## 三、严格模式

ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。这样规定的原因是，函数内部的严格模式，同时适用于函数参数和函数体。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。

可以设定全局性的严格模式，或者把函数包在一个无参数的立即执行函数里面，来规避这个限制。

## 四、name 属性

函数的 name 属性，返回该函数的函数名。

- `Function` 构造函数返回的函数实例，`name` 属性的值为 `anonymous`。
- `bind` 返回的函数，`name` 属性值会加上 `bound` 前缀。

## 五、箭头函数

- 箭头函数没有自己的 `this` 对象。
- 不可以当作构造函数，也就是说，不可以对箭头函数使用 new 命令，否则会抛出一个错误。
- 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `rest` 参数代替。
- 不可以使用 `yield` 命令，因此箭头函数不能用作 Generator 函数。

箭头函数内部的 `this` 指向是固定的，既是定义时上层作用域中的 `this`。也不能用 `call()`、`apply()`、`bind()` 这些方法去改变 `this` 的指向。

```javascript
function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() => this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100);
setTimeout(() => console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0
```

上面代码中，前者的 `this` 绑定定义时所在的作用域（即 `Timer` 函数），后者的 `this` 指向运行时所在的作用域（即全局对象）。

由于箭头函数使得 `this` 从“动态”变成“静态”，下面两个场合不应该使用箭头函数。

- 第一个场合是定义对象的方法，且该方法内部包括 `this`。
- 第二个场合是需要动态 `this` 的时候，也不应使用箭头函数。

## 六、尾调用优化

### 6.1 尾调用、尾调用优化

**尾调用**（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要是最后一步操作即可。

```javascript
function f(x){
  return g(x);
}
```

以下三种情况，都不属于尾调用。

```javascript
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}
```

尾调用之所以与其他调用不同，就在于它的特殊的调用位置。函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

“**尾调用优化**”（Tail call optimization）即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

### 6.2 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为**尾递归**。

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

### 6.3 递归函数的改写

尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。

递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。

### 6.4 严格模式

ES6 的尾调用优化只在严格模式下开启，正常模式无效。因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。

- `func.arguments`：返回调用时函数的参数。
- `func.caller`：返回调用当前函数的那个函数。

尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。

### 6.5 尾递归优化的实现

尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。

```javascript
function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001
```

上面代码中，`tco` 函数是尾递归优化的实现，它的奥妙就在于状态变量 active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归 `sum` 返回的都是 `undefined`，所以就避免了递归执行；而 `accumulated` 数组存放每一轮 `sum` 执行的参数，总是有值的，这就保证了 `accumulator` 函数内部的 `while` 循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。

## 七、函数参数的尾逗号

ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。

## 八、Function.prototype.toString()

ES2019 对函数实例的 `toString()` 做出了修改。修改后的 `toString()` 返回函数代码本身、注释和空格。

## 九、catch 命令的参数省略

对于 JavaScript 语言的 `try...catch` 结构，ES2019 做出了改变，允许 `catch` 语句省略参数。

```javascript
try {
  // ...
} catch {
  // ...
}
```

## 十、参考

- 阮一峰，[函数的扩展](https://es6.ruanyifeng.com/#docs/function)
