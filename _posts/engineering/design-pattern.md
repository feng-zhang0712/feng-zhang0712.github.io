# 设计模式

## 一、介绍

### 1.1 设计模式的目的

设计模式概念的提出，是为了让软件程序在以下方面得到更好的提升。

- 满足**高内聚、低耦合**的特性；
- 提升代码**重用性**；
- 提升代码**可读性**；
- 提升代码**可扩展性**；
- 提升代码**可靠性**。

### 1.2 设计模式七大原则

- 单一职责原则
- 接口隔离原则
- 依赖倒转（倒置）原则
- 里氏替换原则
- 开闭原则
- 迪米特法则
- 合成复用原则

#### （1）单一职责原则（Single Responsibility Principle）

对类来说，即一个类应该只负责一项职责。如类 `A` 负责两个不同职责：职责1、职责2。当职责1需求变更而改变 `A` 时，可能造成职责2执行错误，所以需要将类A的粒度分解为 `A1`、`A2`。

单一职责原则注意事项和细节。

- 降低类的复杂度，一个类只负责一项职责。
- 提高类的可读性，可维护性。
- 降低变更引起的风险。
- 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；如果类中方法数量足够少，可以在方法级别保持单一职责原则。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=1.4&p=6)。

#### （2）接口隔离原则（Interface Segregation Principle）

客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小接口上。

![不符合接口隔离原则的设计](/assets/non-interface-segregation-principle.png)

上面示例中，类 `A` 通过接口 `Interface1` 依赖类 `B`，类 `C` 通过接口 `Interface1` 依赖类 `D`，如果接口 `Interface1` 对于类 `A` 和类 `C` 来说不是最小接口，那么类 `B` 和类 `D` 必须去实现他们不需要的方法。

按隔离原则应当这样处理：将接口 `Interface1` 拆分为独立的几个接口，类 `A` 和类 `C` 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。改造后的设计如下图所示。

![符合接口隔离原则的设计](/assets/interface-segregation-principle.png)

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=266.0&p=8)。

#### （3）依赖倒转原则（Dependence Inversion Principle）

依赖倒转原则，指满足以下几个条件的设计原则。

- 高层模块不应该依赖低层模块，二者都应该依赖其抽象。
- 抽象不应该依赖细节，细节应该依赖抽象。
- 依赖倒转的中心思想是**面向接口编程**。
- 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类。
- 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。

依赖关系的传递主要有三种方式。

- **接口传递**。
- **构造方法传递**。
- **setter 方式传递**。

在使用依赖倒转原则时，应该注意以下几点。

- 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。
- 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。
- 继承时遵循里氏替换原则。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=294.3&p=11)。

#### （4）里氏替换原则（Liskov Substitution Principle）

在面向对象的编程中，继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵守这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。也就是说，继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来**侵入性**，增加对象间的**耦合性**，使程序的**可移植性降低**，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能受到影响。

在实际编程中，解决上述问题的一个方法，就是使用**里氏替换原则**。

简单理解，里氏替换原则描述了这样一种场景：如果对每个类型为 `T1` 的对象 `o1`，都有类型为 `T2` 的对象 `o2`，使得以 `T1` 定义的所有程序 `P` 在所有的对象 `o1` 都代换成 `o2` 时，程序 `P` 的行为没有发生变化，那么类型 `T2` 是类型 `T1` 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。

在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。通用的做法是，原来的父类和子类都继承一个更通俗的**基类**，原有的继承关系去掉，采用**聚合**、**组合**和**依赖**等关系代替。

里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**聚合**、**组合**和**依赖**来解决问题。

注意，在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=8.4&p=15)。

#### （5）开闭原则（Open Closed Principle）

**开闭原则**是编程中最基础、最重要的设计原则。一个软件实体如类、模块和函数应该**对（提供方）扩展开放**，**对（使用方）修改关闭**。用抽象构建框架，用实现扩展细节。当软件需要变化时，尽量通过**扩展**软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=266.7&p=16)。

#### （6）迪米特法则（Demeter Principle）

**迪米特法则**又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，或者说，一个对象应该对其他对象保持最少的了解。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供公共方法，不应该泄露任何信息。迪米特法则还有个更简单的定义：只与直接的朋友通信。所谓直接的朋友，是这样一种关系：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，比如依赖、关联、组合和聚合等。其中，我们称出现**成员变量**、**方法参数**和**方法返回值**中的类为**直接的朋友**，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

迪米特法则的核心是降**低类之间的耦合度**，由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类（对象）间的耦合关系， 并不是要求完全没有依赖关系。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=417.1&p=19)。

#### （7）合成复用原则（Composite Reuse Principle）

合成复用原则，指尽量使用**合成**或**聚合**的方式，而不是使用继承的方式来复用类的功能。

合成复用原则的核心思想是，找出代码中可能需要变化之处，把它们独立出来，最终目的是实现对象之间的**松耦合**。这就要求我们针对**接口**编程，而不是针对实现编程。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=130.9&p=22)。

## 二、类之间的关系

类之间的关系主要有六种，包括：**依赖**、**泛化**（继承）、**实现**、**关联**、**聚合**与**组合**。

### 2.1 依赖关系（Dependence）

只要在类中用到了对方，那么他们之间就存在依赖关系。依赖关系主要包含以下几种情况。

- 类中用到了对方。
- 如果是类的**成员属性**。
- 如果是方法接收的**参数**类型。
- 如果是方法的**返回值**。
- 如果在**方法**中用到。

### 2.2 泛化关系（Generalization）

泛化关系实际上就是**继承关系**，它是依赖关系的特例。

### 2.3 实现关系（Implementation）

实现关系是指类**实现**某个接口，它是依赖关系的特例。

### 2.4 关联关系（Association）

关联关系实际上就是类与类之间的联系，它是依赖关系的特例。关联具有导航性：即**单向关系**和**双向关系**。

### 2.5 聚合关系（Aggregation）

聚合关系表示的是**整体**和**部分**的关系，整体与部分**可以分开**。聚合关系是关联关系的特例，所以聚合关系具有关联的导航性与多重性。

### 2.6 组合关系（Composition）

组合关系也是**整体**与**部分**的关系，但是整体与部分**不可分开**。

## 三、创建型模式

### 3.1 单例模式

单例模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。

### 3.2 简单工厂模式

简单工厂模式属于工厂模式的一种。它是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。它定义了一个创建对象的类，由这个类来封装实例化对象的行为。在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=115.5&p=41)。

### 3.3 工厂方法模式

工厂方法模式定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式**将对象的实例化推迟到子类**。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=1.4&p=44)。

### 3.4 抽象工厂模式

抽象工厂模式定义了一个 `interface` 用于创建相关或有依赖关系的对象簇，而无需指明具体的类。抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）。将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

[查看示例](https://www.bilibili.com/video/BV1G4411c7N4?t=7.8&p=46)。

### 3.5

### 四、结构型模式

### 4.1

### 4.2

### 4.3

### 4.4

### 4.5

### 4.6

### 4.7

### 五、行为型模式

### 5.1

### 5.2

### 5.3

### 5.4

### 5.5

### 5.6

### 5.7

### 5.8

### 5.9

### 5.10

### 5.11
