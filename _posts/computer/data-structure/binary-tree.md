# 二叉树

树结构是一类重要的非线性数据结构。直观来看，树是以分支关系定义的层次结构。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示。树在计算机领域中也得到广泛应用，尤以二叉树最为常用。如在操作系统中，用树来表示文件目录的组织结构；在编译系统中，用树来表示源程序的语法结构；在数据库系统中，树结构也是信息的重要组织形式之一。

## 二叉树的定义

二叉树（Binary Tree）是 n（n >= 0）个结点所构成的集合，它或为空树（n = 0）；或为非空树，对于非空树T：

- 有且仅有一个称之为根的结点；
- 除根结点以外的其余结点分为两个互不相交的子集 $T_1$ 和 $T_2$，分别称为 T 的左子树和右子树，且 $T_1$ 和 $T_2$ 本身又都是二叉树。

二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点：

- 二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）；
- 二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。由此，二叉树可以有5种基本形态，如下图所示。

![二叉树的5种基本形态](/assets/binary-tree-types.png)

在《[树](tree.md#树)》一节中引入的有关 [树的术语](tree.md#二树的基本术语)，是都适用于二叉树。

## 三、案例引入

随着大数据时代的到来,如何采用有效的数据压缩技术,来节省数据文件的存储空间和网络
传输时间越来越引起人们的重视。

### 案例：利用二叉树求解表达式的值

一般情况下,一个表达式由一个运算符和两个操作数构成,两个操作数之间有次序之分,并
且操作数本身也可以是表达式,这个结构类似于二叉树,因此可以利用二叉树来表示表达式。
以二叉树表示表达式的递归定义如下:
(1)若表达式为数或简单变量,则相应二叉树中仅有一个根结点,其数据域存放该表达
式信息；
(2)若表达式为“第一操作数运算符 第二操作数”的形式,则相应的二叉树中以左子树表
示第一操作数,右子树表示第二操作数,根结点的数据域存放运算符(若为一元运算符,则左子
树为空),其中,操作数本身又为表达式。
如图 5.5 所示的二叉树表示表达式a+b*(c-d)-e/f。在二叉树中表达式中并无括号,但其结
构却有效地表达了其运算符间的运算次序。利用二叉树的遍历等操作,可实现表达式的求值运算,
有关内容将在5.8节详细介绍。
0
a
d
图5.4 哈夫曼树及编码示例
图5.5 表达式(a+b*(c-d)-e/f)的二叉树
5.3 二叉树的抽象数据类型定义
二叉树的抽象数据类型定义如下:
ADT BinaryTree {
数据对象D:D是具有相同特性的数据元素的集合。
数据关系 R:
若 D=,则 R=0,称BinaryTree为空二叉树;
若D≠,则R={H},H是如下二元关系:
(1)在D中存在唯一的称为根的数据元素root,它在关系H下无前驱;
(2)若D-{root}=,则存在D-{root}={Dı, Dr},且D:ND=0;
(3)若D≠,则D中存在唯一的元素x1, <root,xi>∈H,且存在D上的关系HCH;若D ≠ $,
则 D. 中存在唯一的元素 x², <root, x->EH,且存在D上的关系H+CH;H={<root, xi>, <root,
Xr>, H｣, Hr};

(4)(Dı, {H})是一棵符合本定义的二叉树,称为根的左子树,(Dr {H})是一棵符合本定义的二
叉树,称为根的右子树。
基本操作P:
InitBiTree(&T)
操作结果:构造空二叉树 T
DestroyBiTree(&T)
初始条件:二叉树T存在。
操作结果:销毁二叉树 T。
CreateBiTree(&T, definition)
初始条件;definition 给出二叉树T的定义。
操作结果:按definition 构造二叉树T。
ClearBiTree(&T)
初始条件:二叉树T存在。
操作结果:将二叉树清为空树。
BiTreeEmpty(T)
初始条件:二叉树存在。
操作结果:若为空二叉树,则返回true,否则false。
()味叉二
BiTreeDepth (T)
初始条件:二叉树T存在。
操作结果:返回T的深度。
Root (T)
初始条件:二叉树T存在。
操作结果:返回T的根。
Value (T,e)
初始条件:二叉树存在,e是中某个结点。
操作结果:返回e的值。
Assign (T, &e, value)
初始条件:二叉树T存在,是T中某个结点。
操作结果:结点e赋值为value。
Parent (T, e)
初始条件:二叉树T存在,e是中某个结点。
审判商树义
操作结果:若e是T的非根结点,则返回它的双亲,否则返回“空”。
LeftChild(T,e)
初始条件:二叉树T存在,是中某个结点。
操作结果:返回e的左孩子。若无左孩子,则返回“空”。
RightChild(T,e)
初始条件:二叉树T存在,e是T中某个结点。1914
操作结果:返回e的右孩子。若无右孩子,则返回“空”。
LeftSibling (T, e)
初始条件:二叉树T存在,e是T中某个结点。
操作结果:返回e的左兄弟。若是T的左孩子或无左兄弟,则返回“空”。
RightSibling (T,e)
初始条件:二叉树T存在,e e是T中某个结点。
操作结果:返回e的右兄弟。若是T的右孩子或无右兄弟,则返回“空”。
InsertChild(&T,P,LR,C) 即行,曾出譲点杂,如可或資社
TOA
即
一同出E抒
初始条件:二叉树T存在,p指向T中某个结点,LR为0或1,非空二叉树与不相交且右子树为空。
操作结果:根据LR为0或1,插入C为T中p所指结点的左或右子树。p所指结点的原有左或右子树则成
为c的右子树。

MX DeleteChild (&T, p, LR)
初始条件:二叉树存在,p指向T中某个结点,LR为0或1。
操作结果:根据LR为0或1,删除T中所指结点的左或右子树。
PreOrderTraverse (T)
初始条件:二叉树T存在。
操作结果:先序遍历,对每个结点访问一次。
InOrderTraverse (T)
初始条件:二叉树T存在。
操作结果:中序遍历,对每个结点访问一次。
PostOrderTraverse (T)
初始条件:二叉树T存在。
操作结果:后序遍历,对每个结点访问一次。
LevelOrderTraverse (T)
初始条件:二叉树T存在。
操作结果:层序遍历,对每个结点访问一次。
} ADT BinaryTree

## 四、二叉树的性质和存储结构

5.4.1 二叉树的性质
二叉树具有下列重要特性:
性质1 在二叉树的第层上至多有21个结点(≥1)。
证明:利用归纳法容易证得此性质。
i=1时,只有一个根结点。显然,21=2=1是对的。
现在假定对所有的j(1≤j<i),命题成立,即第j层上至多有21个结点。那么,可以证明j=i
时命题也成立。
由归纳假设:第-1层上至多有22个结点。由于二叉树每个结点的度至多为2,故在第î层
上的最大结点数为第-1层上的最大结点数的2倍,即2×2+2=21。
性质2 深度为k的二叉树至多有2-1个结点(k≥1)。
证明:由性质1可见,深度为k的二叉树的最大结点数为
k
(第i层上的最大结点数) = 21 = 2* -1
i=1
i=1
性质3 对任何一棵二叉树T,如果其终端结点数为no,度为2的结点数为2,则no = z2 + 1。
证明:设 nm为二叉树T中度为1的结点数。因为二叉树中所有结点的度均小于或等于2,所
以其结点总数为
n = no + 2 + 22
(5-1)
再看二叉树中的分支数。除了根结点外,其余结点都有一个分支进入,设为分支总数,则
n=B+1。由于这些分支是由度为1或2的结点射出的,所以又有B=nm+2n20
于是得
n = nm + 2nz + 1
(5-2)

由式(5-1)和式(5-2)得果酸菜球失,縣
20 = 22 + 1
现在介绍两种特殊形态的二叉树,它们是满二叉树和完全二叉树。眼
果味,加大会以
满二叉树:深度为k且含有21个结点的二叉树。图5.6(a)所示是一棵深度为4的满二叉树。
8
11 (12
(a)满二叉树
(b)完全二叉树
①
3
(c)非完全二叉树
(d)非完全二叉树
图5.6 特殊形态的二叉树
满二叉树的特点是:每一层上的结点数都是最大结点数,即每一层i的结点数都具有最大
12-10
可以对满二叉树的结点进行连续编号,约定编号从根结点起,自上而下,自左至右。由此可
引出完全二叉树的定义。
完全二叉树:深度为k的,有n个结点的二叉树,当且仅当其每一个结点都与深度为k的满
二叉树中编号从1至n的结点一一对应时,称之为完全二叉树。图5.6(b)所示为一棵深度为4
的完全二叉树。
完全二叉树的特点是:
(1)叶子结点只可能在层次最大的两层上出现;
(2)对任一结点,若其右分支下的子孙的最大层次为1,则其左分支下的子孙的最大层次必
为/或Z+1。图5.6中(c)和(d)不是完全二叉树。
完全二叉树在很多场合下出现,下面的性质和性质5是完全二叉树的两个重要特性。
性质4 具有n个结点的完全二叉树的深度为logzn」+1。
证明:假设深度为k,则根据性质和完全二叉树的定义有
2-1-1 <n≤2-1 或 201≤n<2*
于是k-1≤logzn <k,因为k是整数,所以k=Llogzn」+1。
性质5 如果对一棵有n个结点的完全二叉树(其深度为log2n+1)的结点按层序编号(从
第1层到第Llogzn」+1层,每层从左到右),则对任一结点i(1≤i≤n),有濺射大
①符号Lx表示不大于x的最大整数,反之,[x]表示不小于x的最小整数。
119

Page 128
数据结构(C语言版)(第2版)
(1)如果i=1,则结点i是二叉树的根,无双亲;如果i>1,则其双亲 PARENT(i)是结
点Li/2」。
(2)如果2i>n,则结点无左孩子(结点为叶子结点);否则其左孩子LCHILD()是结点2i。
(3)如果2i+1>n,则结点i无右孩子;否则其右孩子RCHILD(i)是结点2+1。
在此省略证明过程,读者可由图5.7直观地看出性质5所描述的结点与编号的对应关系。
[i/2]
i+1
2i
2i+1
2i+2
21+3
LCHILD (i)
LCHILD (i+1)
i+1
2i
2i+1
...
21+2
2i+3
RCHILD (i) RCHILD (i+1)
(a)结点和+1在同一层上
(b)结点和+1不在同一层上
图5.7 完全二叉树中结点和+1的左、右孩子
5.4.2 二叉树的存储结构
类似线性表,二叉树的存储结构也可采用顺序存储和链式存储两种方式。
1. 顺序存储结构
//-----二叉树的顺序存储表示--
#define MAXTSIZE 100
typedef TElemType SqBiTree [MAXTSIZE];
SqBiTree bt%3B
//二叉树的最大结点数
110号单元存储根结点
顺序存储结构使用一组地址连续的存储单元来存储数据元素,为了能够在存储结构中反
映出结点之间的逻辑关系,必须将二叉树中的结点依照一定的规律安排在这组单元中。
对于完全二叉树,只要从根起按层序存储即可,依次自上而下、自左至右存储结点元素,即
将完全二叉树上编号为的结点元素存储在如上定义的一维数组中下标为-1的分量中。例如,
图5.8(a)所示为图5.6(b)所示完全二叉树的顺序存储结构。
对于一般二叉树,则应将其每个结点与完全二叉树上的结点相对照,存储在一维数组的相应分量
中,图5.6(c)所示二叉树的顺序存储结构如图5.8(b)所示,图中以“0”表示不存在此结点。
1 2 3 4 5 6 7 8 9 10 11 12
2 3 4 5 0 0 0 0 6 7
(a)完全二叉树
(b)一般二叉树
图5.8 二叉树的顺序存储结构
120
由此可见,这种顺序存储结构仅适用于完全二叉树。因为,在最坏的情况下,一个深度为 k
且只有k个结点的单支树(树中不存在度为2的结点)却需要长度为2-1的一维数组。这造成了
存储空间的极大浪费,所以对于一般二叉树,更适合采取下面的链式存储结构。榮星了年
2. 链式存储结构
设计不同的结点结构可构成不同形式的链式存储结构。由二叉树的定义得知,二叉树的结点

Page 129
第5章树和二叉树
(见图5.9(a))由一个数据元素和分别指向其左、右子树的两个分支构成,则表示二叉树的链表
中的结点至少包含3个域:数据域和左、右指针域,如图5.9(b)所示。有时,为了便于找到结
点的双亲,还可在结点结构中增加一个指向其双亲结点的指针域,如图5.9(c)所示。利用这两
种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表,如图5.10所示。链表的头指
针指向二叉树的根结点。容易证得,在含有n个结点的二叉链表中有n+1个空链域。在5.5节中
将会看到可以利用这些空链域存储其他有用信息,从而得到另一种链式存储结构——线索链表。
parent
data因,即午剧
Ichild rchild
lchild
data rchild
lchild
data
parent rchild
(a)二叉树的结点 (b)含有两个指针域的结点结构 (c)含有三个指针域的结点结构
台图5.9 二叉树的结点及其存储结构
A
VAN
AA
B
B
JB
D
CA
BA
ADA
(a)单支树的二叉链表
(b)二叉链表
AGA
图5.10 链表存储结构
(c)三叉链表
界刷衣(S)
在不同的存储结构中,实现二叉树的操作方法也不同,如找结点x的双亲PARENT(T, e),在
三叉链表中很容易实现,而在二叉链表中则需从根指针出发巡查。由此,在具体应用中采用什么
存储结构,除根据二叉树的形态之外还应考虑需进行何种操作。读者可试以5.4.1 小节中定义的各
种操作对以上定义的各种存储结构进行比较。在下一节的二叉树遍历及其应用的算法均采用以下
定义的二叉链表形式实现。
//- - - - -二叉树的二叉链表存储表示
typedef struct BiTNode{
TElemType data;
struct BiTNode *lchild, *rchild;
//结点数据域
//左右孩子指针
}BiTNode *BiTree;

## 五、遍历二叉树和线索二叉树

在二叉树的一些应用中,常常要求在树中查找具有某种特征的结点,或者是对树中的全部结
点逐一进行处理,这就提出了一个遍历二叉树的问题。线索二叉树是在第一次遍历时将结点的前
121

Page 130
122
数据结构(C语言版)(第2版)
驱、后继信息存储下来,便于再次遍历二叉树。
5.5.1 遍历二叉树
1. 遍历二叉树算法描述
遍历二叉树(traversing binary tree)是指按某条搜索路径巡访树中每个结点,使得每个结点
均被访问一次,而且仅被访问一次。访问的含义很广,可以是对结点做各种处理,包括输出结点
的信息,对结点进行运算和修改等。遍历二叉树是二叉树最基本的操作,也是二叉树其他各种操
作的基础,遍历的实质是对二叉树进行线性化的过程,即遍历的结果是将非线性结构的树中结点
排成一个线性序列。由于二叉树的每个结点都可能有两棵子树,因而需要寻找一种规律,以便使
二叉树上的结点能排列在一个线性队列上,从而便于遍历。
回顾二叉树的递归定义可知,二叉树是由3个基本单元组成:根结点、左子树和右子树。因
此,若能依次遍历这三部分,便是遍历了整个二叉树。假如从L、D、R分别表示遍历左子树、访
问根结点和遍历右子树,则可有DLR、LDR、LRD、DRL、RDL、RLD 这6种遍历二叉树的方案。
若限定先左后右,则只有前3种情况,分别称之为先(根)序遍历、中(根)序遍历和后(根)
序遍历。基于二叉树的递归定义,可得下述遍历二叉树的递归算法定义。
先序遍历二叉树的操作定义如下:
若二叉树为空,则空操作;否则
(1)访问根结点;
(2)先序遍历左子树;
(3)先序遍历右子树。
中序遍历二叉树的操作定义如下:
若二叉树为空,则空操作;否则
(1)中序遍历左子树;
(2)访问根结点;
(3)中序遍历右子树。
后序遍历二叉树的操作定义如下:
若二叉树为空,则空操作;否则
(1)后序遍历左子树;
(2)后序遍历右子树;
(3)访问根结点。
例如,图5.5 所示的二叉树表示下述表达式
a + b *(c-d)- e/f
若先序遍历此二叉树,按访问结点的先后次序将结点排列起来,可得到二叉树的先序序列为
-+a*b-cd/ef
(5-3)
类似地,中序遍历此二叉树,可得此二叉树的中序序列为
a+b*c-d-e/f
(5-4)
后序遍历此二叉树,可得此二叉树的后序序列为
abcd− * + ef/ -
(5-5)
从表达式来看,以上3个序列(5-3)(5-4)和(5-5)恰好为表达式的前缀表示(波兰式)、
中缀表示和后缀表示(逆波兰式)。

Page 131
第5章 树和二叉树
算法 5.1 给出了中序遍历二叉树基本操作的递归算法在二叉链表上的实现,算法将结点的访
澣料的
问简化成数据的输出。
算法 5.1 中序遍历的递归算法怪理员
【算法描述】
void InOrderTraverse (BiTree T)
{ //中序遍历二叉树的递归算法
【新西詳】
if(T)
//若二叉树非空
{
InOrderTraverse (T->1child);
//中序遍历左子树
cout<<T->data;
//访问根结点
柳證非g果地上
InOrderTraverse (T->rchild);
//中序遍历右子树
}
【】
}
只要改变输出语句的顺序,读者便可类似地实现先序遍历和后序遍历的递归算法,此处不再
一一列举。
从上述二叉树遍历的定义可知,3种遍历算法不同处仅在于访问根结点和遍历左、右子树的先
后关系。如果在算法中暂且抹去和递归无关的cout语句,则3个遍历算法完全相同。由此,从递归
执行过程的角度来看先序、中序和后序遍历也是完全相同的。图 5.11(b)中用带箭头的虚线表示
了这3种遍历算法的递归执行过程。其中,向下的箭头表示更深一层的递归调用,向上的箭头表示
从递归调用退出返回;虚线旁三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历二叉
树过程中访问结点时输出的信息。例如,由于中序遍历中访问结点是在遍历左子树之后、遍历右子
树之前进行,则带圆形的字符标在向左递归返回和向右递归调用之间。由此,只要沿虚线从1出发
到2结束,将沿途所见的三角形(或圆形、或方形)内的字符记下,便得到遍历二叉树的先序(或
中序、或后序)序列。例如,从图5.11(b)分别可得图5.11(a)所示表达式的前缀表示(-*abc)、
中缀表示(a*b-c)和后缀表示(ab*c-)。
2
ATT
C
A
a
/b\
回回
外出
a
b
a
(a)表达式(a*b-c)的二叉树
(b)遍历的递归执行过程
图5.113种遍历过程示意图
根据前面 3.4.4 小节的内容,可利用栈将递归算法改写成非递归算法,如算法5.2所示。例如,
从中序遍历递归算法执行过程中递归工作栈的状态可见:
(1)工作记录中包含两项,其一是递归调用的语句编号,其二是指向根结点的指针,则当栈
顶记录中的指针非空时,应遍历左子树,即指向左子树根的指针进栈;
(2)若栈顶记录中的指针值为空,则应退至上一层,若是从左子树返回,则应访问当前层(即
123

Page 132
124
数据结构(C语言版)(第2版)
栈顶记录)中指针所指的根结点;
(3)若是从右子树返回,则表明当前层的遍历结束,应继续退栈。从另一个角度看,这意味
着遍历右子树时不再需要保存当前层的根指针,直接修改栈顶记录中的指针即可。
起
示
算法5.2 中序遍历的非递归算法
【算法步骤】
① 初始化一个空栈S,指针指向根结点。
② 申请一个结点空间q,用来存放栈顶弹出的元素。
③当p非空或者找S非空时,循环执行以下操作:
如果p非空,则将p进栈,p指向该结点的左孩子;
如果p为空,则弹出栈顶元素并访问,将p指向该结点的右孩子。
【算法描述】
void InOrderTraverse (BiTree T)
{ //中序遍历二叉树的非递归算法
InitStack (S);p=T;
q=new BiTNode;
while(p||! StackEmpty(S))
if(p)
//p非空
Push (S,p);
//根指针进栈
p=p->lchild;
//根指针进栈,遍历左子树
}
else
/p 为空
{
Pop (S, q);
//退栈
d*) cout<<q-> data;
//访问根结点
p=q->rchild;
//遍历右子树
}
// while
}
按上述算法,图5.11(a)所示的二叉树的中序非递归遍历的栈S的变化过程如图5.12 所示。
P→"b"
b
"
P→“NULL”
P→“NULL”
a
*
*
*
@出栈
*出栈
P→“NULL”
P→“NULL”
P→“NULL”
P→“NULL”
-出栈
C c出栈 栈空
(明)累备回 图5.12 非递归中序遍历时栈的变化情况

Page 133
【算法分析】
第5章树和二叉树
无论是递归还是非递归遍历二叉树,因为每个结点被访问一次,则不论按哪一种次序进行遍
历,对含n个结点的二叉树,其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量,
即树的深度,最坏情况下为n,则空间复杂度也为O(n)。
二叉树的先序、中序和后序遍历是最常用的三种遍历方式。此外,还有一种按层次遍历
二叉树的方式,这种方式按照“从上到下,从左到右”的顺序遍历二叉树,即先遍历二叉树
第一层的结点,然后是第二层的结点,直到最底层的结点,对每一层的遍历按照从左到右的
次序进行。例如,图5.11(a)所示的二叉树的层次遍历序列是-*cab。层次遍历不是一个递归
过程,层次遍历算法的实现可以借助队列这种数据结构,这里不做详细讨论,算法留给读者
自行完成。
2. 根据遍历序列确定二叉树
从前面讨论的二叉树的遍历知道,若二叉树中各结点的值均不相同,任意一棵二叉树结点的
先序序列、中序序列和后序序列都是唯一的。反过来,若已知二叉树遍历的任意两种序列,能否
确定这棵二叉树呢?这样确定的二叉树是否是唯一的呢?
由二叉树的先序序列和中序序列,或由其后序序列和中序序列均能唯一地确定一棵二叉树。
根据定义,二叉树的先序遍历是先访问根结点,其次再按先序遍历方式遍历根结点的左子树,
最后按先序遍历方式遍历根结点的右子树。这就是说,在先序序列中,第一个结点一定是二叉树
的根结点。另一方面,中序遍历是先遍历左子树,然后访问根结点,最后再遍历右子树。这样,
根结点在中序序列中必然将中序序列分割成两个子序列,前一个子序列是根结点的左子树的中序
序列,而后一个子序列是根结点的右子树的中序序列。根据这两个子序列,在先序序列中找到对
应的左子序列和右子序列。在先序序列中,左子序列的第一个结点是左子树的根结点,右子序列
的第一个结点是右子树的根结点。这样,就确定了二叉树的三个结点。同时,左子树和右子树的
根结点又可以分别把左子序列和右子序列划分成两个子序列,如此递归下去,当取尽先序序列中
的结点时,便可以得到一棵二叉树。
同理,由二叉树的后序序列和中序序列也可唯一地确定一棵二叉树。因为,依据后序遍历和
中序遍历的定义,后序序列的最后一个结点,就如同先序序列的第一个结点一样,可将中序序列
分成两个子序列,分别为这个结点左子树的中序序列和右子树的中序序列,再拿出后序序列的倒
数第二个结点,并继续分割中序序列,如此递归下去,当倒着取尽后序序列中的结点时,便可以
得到一棵二叉树。
【例 5.1】 已知一棵二叉树的中序序列和后序序列分别是 BDCEAFHG 和 DECBHGFA,请
画出这棵二叉树。
(1)由后序遍历特征,根结点必在后序序列尾部,即根结点是A;
(2)由中序遍历特征,根结点必在其中间,而且其左部必全部是左子树子孙(BDCE),其右
部必全部是右子树子孙(FHG);
(3)继而,根据后序中的DECB子树可确定为A的左孩子,根据HGF子串可确定F为A
的右孩子;依此类推,可以唯一地确定一棵二叉树,如图5.13所示。
但是,由一棵二叉树的先序序列和后序序列不能唯一确定一棵二叉树,因为无法确定左右子
树两部分。例如,如果有先序序列AB,后序序列BA,因为无法确定B为左子树还是右子树,所
以可得到如图5.14所示的两棵不同的二叉树。 斯·江西

新图5.13 由中序序列和后序序列确定的二叉树
图5.14两棵不同的二叉树
3. 二叉树遍历算法的应用
“遍历”是二叉树各种操作的基础,假设访问结点的具体操作不仅仅局限于输出结点数
据域的值,而把“访问”延伸到对结点的判别、计数等其他操作,可以解决一些关于二叉树
的其他实际问题。如果在遍历过程中生成结点,这样便可建立二叉树的存储结构。
(1)创建二叉树的存储结构——二叉链表
为简化问题,设二叉树中结点的元素均为一个单字符。假设按先序遍历的顺序建立二叉链表,
T 为指向根结点的指针,对于给定的一个字符序列,依次读入字符,从根结点开始,递归创建二
叉树。
算法 5.3 先序遍历的顺序建立二叉链表
【算法步骤】
① 扫描字符序列,读入字符 ch。
② 如果 ch 是一个“#”字符,则表明该二叉树为空树,即T为NULL;否则执行以下操作:
●申请一个结点空间 T;
将ch 赋给T->data;
● 递归创建T的左子树;
递归创建T的右子树;
【算法描述】
void CreateBiTree (BiTree &T)
{ //按先序次序输入二叉树中结点的值(一个字符),创建二叉链表表示的二叉树 T
cin>>ch;
if(ch=='#') T=NULL;
else
{
( T=new BiTNode;
//递归结束,建空树
//递归创建二叉树
//生成根结点
//根结点数据域置为 ch
T->data=ch;
AT CreateBiTree(T->lchild);
//递归创建左子树
CreateBiTree (T->rchild);
//递归创建右子树
//else
类
126
例如,对图 5.10(b)所示的二叉树,读入字符的顺序为:ABC##DE#G##F### (其中#表示
空树),可建立相应的二叉链表。

Page 135
(2)复制二叉树
第5章树和二叉树
复制二叉树就是利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。根据二叉
树的特点,复制步骤如下:若二叉树不空,则首先复制根结点,这相当于二叉树先序遍历算法中
访问根结点的语句;然后分别复制二叉树根结点的左子树和右子树,这相当于先序遍历中递归遍
历左子树和右子树的语句。因此,复制函数的实现与二叉树先序遍历的实现非常类似。
算法5.4 复制二叉树
【算法步骤】
我不限素菜中叉二卡 6.
如果是空树,递归结束,否则执行以下操作:
【名】
申请一个新结点空间,复制根结点;
递归复制左子树;
● 递归复制右子树。
【算法描述】
void Copy(BiTree T,BiTree &NewT)
{//复制一棵和T完全相同的二叉树
if(T==NULL)
{
NewT=NULL;
return;
}
else
{
//如果是空树,递归结束
NewT=new BiTNode:一个一冊点器随中文
NewT->data=T->data;
Copy(T->lchild,NewT->lchild);
Copy (T->rchild,NewT->rchild);
//复制根结点
//递归复制左子树
//递归复制右子树
//else
(3)计算二叉树的深度
匠
二叉树的深度为树中结点的最大层次,二叉树的深度为左右子树深度的较大者加1。
算法 5.5 计算二叉树的深度
【算法步骤】
如果是空树,递归结束,深度为0,否则执行以下操作:
● 递归计算左子树的深度记为m;
递归计算右子树的深度记为n;
如果 m 大于n,二叉树的深度为m+1,否则为n+1。
【算法描述】
int Depth(BiTree T)
{ //计算二叉树T 的深度
if(T==NULL) return 0;
else
{
Mid
//如果是空树,深度为0,递归结束
_m=Depth (T->lchild);
//递归计算左子树的深度记为mbidof
n=Depth (T->rchild);
//递归计算右子树的深度记为nlingl
if(m>n) return (m+1);
//二叉树的深度为man的较大者加1
127

Page 136
128
数据结构(C语言版)(第2版)
else return(n+1);
}
显然,计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。
(4)统计二叉树中结点的个数
如果是空树,则结点个数为0;否则,结点个数为左子树的结点个数加上右子树的结点个数
再加上1。
算法 5.6 统计二叉树中结点的个数
【算法描述】
int NodeCount (BiTree T)
{ //统计二叉树T中结点的个数
}
if(T==NULL) return 0;
//如果是空树,则结点个数为0,递归结束
else return NodeCount (T->lchild)+NodeCount(T->rchild)+1;
//否则结点个数为左子树的结点个数+右子树的结点个数+1
读者可以模仿此算法,写出以下算法:统计二叉树中叶结点(度为0)的个数,为 1 的
结点个数和度为2的结点个数。算法实现的关键是如何表示度为0、度为1或度为2的结点。
5.5.2 线索二叉树
1. 线索二叉树的基本概念
遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列,得到二叉树中结点的先序
序列、中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作,使每个结点(除第
一个和最后一个外)在这些线性序列中有且仅有一个直接前驱和直接后继(在不至于混淆的情况,
后续描述中省去“直接”二字。例如在图5.5所示的二叉树结点的中序序列a+b*c-d-e/f中,“c”
的前驱是“*”,后继是“-”。
但是,当以二叉链表作为存储结构时,只能找到结点的左、右孩子信息,而不能直接得
到结点在任一序列中的前驱和后继信息,这种信息只有在遍历的动态过程中才能得到,为此
引入线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。
虽然可以在每个结点中增加两个指针域来存放在遍历时得到的有关前驱和后继信息,但这样
做使得结构的存储密度大大降低。由于有n个结点的二叉链表中必定存在n+1个空链域,因此
可以充分利用这些空链域来存放结点的前驱和后继信息。
试做如下规定:若结点有左子树,则其Ichild 域指示其左孩子,否则令 lchild 域指示其前驱;
若结点有右子树,则其rchild 域指示其右孩子,否则令rchild 域指示其后继。为了避免混淆,尚
需改变结点结构,增加两个标志域,其结点形式如图 5.15 所示。
lchild
LTag
data
RTag
rchild)
图5.15线索二叉树的结点形式
(LIU
其中:
[0 lchild域指示结点的左孩子
LTag:
=
1 lchild域指示结点的前驱
cuter (n<m) 11

Page 137
970
RTag =
第5章树和二叉树
lchild域指示结点的左孩子
索中树干g
1 lchild域指示结点的后继
二叉树的二叉线索类型定义如下:
1-----二叉树的二叉线索存储表示--___王叫。詳興
typedef struct BiThrNode
TElemType data;
struct BiThrNode *lchild, *rchild;
//左右孩子指针
int LTag,RTag;
}BiThrNode *BiThrTree;
//左右标志
果戚
以这种结点结构构成的二叉链表作为二叉树的存储结构,叫做线索链表,其中指向结点前驱
和后继的指针,叫做线索。加上线索的二叉树称之为线索二叉树(Threaded Binary Tree)。对二叉
树以某种次序遍历使其变为线索二叉树的过程叫做线索化。
例如图 5.16(a)所示为中序线索二叉树,与其对应的中序线索链表如图5.16(b)所示。其
中实线为指针(指向左、右子树),虚线为线索(指向前驱和后继)。为了方便起见,仿照线性表
的存储结构,在二叉树的线索链表上也添加一个头结点,并令其 Ichild 域的指针指向二叉树的根
结点,其 rchild 域的指针指向中序遍历时访问的最后一个结点;同时,令二叉树中序序列中第一
个结点的 lchild 域指针和最后一个结点rchild 域的指针均指向头结点。这好比为二叉树建立了一
个双向线索链表,既可从第一个结点起顺后继进行遍历,也可从最后一个结点起顺前驱进行遍历。
2.构造线索二叉树
由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索,而前驱或
后继的信息只有在遍历时才能得到,因此线索化的过程即为在遍历的过程中修改空指针的过程,
可用递归算法。对二叉树按照不同的遍历次序进行线索化,可以得到不同的线索二叉树,包括先
序线索二叉树、中序线索二叉树和后序线索二叉树。下面重点介绍中序线索化的算法。
为了记下遍历过程中访问结点的先后关系,附设一个指针 pre 始终指向刚刚访问过的结点,而指针
p指向当前访问的结点,由此记录下遍历过程中访问结点的先后关系。算法5.7 是对树中任意一个结点
p为根的子树中序线索化的过程,算法5.8通过调用算法5.7来完成整个二叉树的中序线索化。
thrt
NULL
NULL
+0
bt
8.
【食】
*
e
f
10-01911
C
d 1
(a)中序线索二叉树
(b)中序线索链表
图5.16线索二叉树及其存储结构
129

Page 138
130
数据结构(C语言版)(第2版)
算法 5.7 以结点p为根的子树中序线索化
【算法步骤】
①如果p非空,左子树递归线索化。
② 如果p的左孩子为空,则给p加上左线索,将其LTag置为1,让p的左孩子指针指向 pre
(前驱);否则将p的LTag置为0。
如果 pre 的右孩子为空,则给pre加上右线索,将其RTag置为1,让pre的右孩子指针指
向p(后继);否则将 pre 的RTag 置为0。
④将 pre 指向刚访问过的结点p,即 pre = po
⑤ 右子树递归线索化。
【算法描述】
void InThreading (BiThrTree p)
{//pre 是全局变量,初始化时其右孩子指针为空,便于在树的最左点开始建线索
if (p)
{
{
TV
InThreading (p->lchild);
if(!p->lchild)
p->LTag=1;
p->lchild=pre;
else p->LTag=0;
if(!pre->rchild)
//左子树递归线索化
//p的左孩子为空
//给p加上左线索
//p的左孩子指针指向
pre(前驱)
//if
//pre的右孩子为空
}
}
}
pre->RTag=1;
pre->rchld=p;
else p->RTag=0;
pre=p:
InThrending(p->rchild);
//给pre加上右线索
//pre的右孩子指针指向p(后继)
//if
//保持pre 指向p的前驱
//右子树递归线索化
算法5.8 带头结点的二叉树中序线索化
【算法描述】
void InOrderThreading(BiThrTree &Thrt, BiThrTree T)
{ //中序遍历二叉树,并将其中序线索化,Thrt 指向头结点
Thrt=new BiThrNode;
Thrt->LTag=0;
//建头结点
Thrt->RTag=1;
Thrt->rchild=Thrt;
Thrt->lchild=Thrt;
if(!T)
else
{
Thrt->lchild=T; pre=Thrt;
InThreading (T);
pre->rchild=Thrt;
pre->RTag=1;
//头结点有左孩子,若树非空,则其左孩子为树根
//头结点的右孩子指针为右线索
//初始化时右指针指向自己
//若树为空,则左指针也指向自己
//头结点的左孩子指向根,pre初值指向头结点
//调用算法5.7,对以为根的二叉树进行中序线索化
//算法5.7 结束后,pre为最右结点,pre的线索指向头结点

Page 139
第5章树和二叉树
Thrt->rchild=pre;
//头结点的右线索指向pre
}
3. 遍历线索二叉树
由于有了结点的前驱和后继信息,线索二叉树的遍历和在指定次序下查找结点的前驱和后继
算法都变得简单。因此,若需经常查找结点在所遍历线性序列中的前驱和后继,则采用线索链表
作为存储结构。
下面分3种情况讨论在线索二叉树中如何查找结点的前驱和后继。
(1)在中序线索二叉树中查找
① 查找指针所指结点的前驱:
面
綜叉二
田
其
2.職
若 p-> LTag为1,则p的左链指示其前驱;
若 p- > LTag 为0,则说明p有左子树,结点的前驱是遍历左子树时最后访问的一个结
点(左子树中最右下的结点)。
②查找指针所指结点的后继:
若 p- > RTag 为1,则p的右链指示其后继,以图5.16所示的中序线索树为例来看,结
点b的后继为结点*;
若 p-> RTag为0,则说明p有右子树。根据中序遍历的规律可知,结点的后继应是遍
历其右子树时访问的第一个结点,即右子树中最左下的结点。例如在找结点*的后继时,
首先沿右指针找到其右子树的根结点-,然后顺其左指针往下直至其左标志为1的结
点,即为结点*的后继,在图中是结点 c。
(2)在先序线索二叉树中查找
① 查找p指针所指结点的前驱:
若p->LTag为1,则p的左链指示其前驱;
若 p- > LTag 为0,则说明p有左子树。此时p的前驱有两种情况:若*p是其双亲的左
孩子,则其前驱为其双亲结点;否则应是其双亲的左子树上先序遍历最后访问到的结点。
查找p指针所指结点的后继:
若p->RTag为1,则p的右指示其后继;
● 若p->RTag为0,则说明有右子树。按先序遍历的规则可知,*p的后继必为其左子
树根(若存在)或右子树根。
(3)在后序线索二叉树中查找
① 查找p指针所指结点的前驱:
● 若p->LTag为1,则p的左链指示其前驱;
若 p- > LTag 为0,当p->RTag也为0时,则p的右指示其前驱;若p-> LTag 为 0,
而p->RTag为1时,则p的左链指示其前驱。
②查找p指针所指结点的后继情况比较复杂,分以下情况讨论:
● 若*p 是二叉树的根,则其后继为空;
● 若*p 是其双亲的右孩子,则其后继为双亲结点;
● 若*p 是其双亲的左孩子,且*p没有右兄弟,则其后继为双亲结点;
若*p是其双亲的左孩子,且*p有右兄弟,则其后继为双亲的右子树上按后序遍历列出
的第一个结点(即右子树中“最左下”的叶结点)。
131

Page 140
数据结构(C语言版)(第2版)
例如,图5.17 所示为后序线索二叉树,结点B的后继为结点
C,结点 C 的后继为结点D,结点F的后继为结点G,而结点D
的后继为结点E。
可见,在先序线索化树上找前驱或在后序线索化树上找后继
时都比较复杂,此时若需要,可直接建立含4个指针的线索链表。
出
图5.17 后序后继线索二叉树
由于有了结点的前驱和后继的信息,线索二叉树的遍历操作
无需设栈,避免了频繁的进栈、出栈,因此在时间和空间上都较
遍历二叉树节省。如果遍历某种次序的线索二叉树,则只要从该次序下的根结点出发,反复查找
其在该次序下的后继,直到叶子结点。下面以遍历中序线索二叉树为例介绍该算法。
算法5.9 遍历中序线索二叉树
【算法步骤】
① 指针p指向根结点。
②p为非空树或遍历未结束时,循环执行以下操作:
沿左孩子向下,到达最左下结点*p,它是中序的第一个结点;
访问*p;
● 沿右线索反复查找当前结点*p的后继结点并访问后继结点,直至右线索为0或者遍
历结束;
转向p的右子树。
【算法描述】
void InOrderTraverse_Thr (BiThrTree T)
中文
{//T 指向头结点,头结点的左child 指向根结点,可参见线索化算法5.8。
//中序遍历二叉线索树的非递归算法,对每个数据元素直接输出
p=T->lchild;
while (p!=T)
//p指向根结点
//空树或遍历结束时,p==T
while(p->LTag==0) p=p->lchild;
cout<<p->data;
Tan while(p->RTag==1&&p->rchild!=T)
//沿左孩子向下
//访问其左子树为空的结点
乐视
p=p->rchild; cout<<p->data;
//沿右线索访问后继结点
}
p=p->rchild;
//转向p的右子树
}
【算法分析】
遍历线索二叉树的时间复杂度为O(n),空间复杂度为O(1),这是因为线索二叉树的遍历不需
要使用栈来实现递归操作。
