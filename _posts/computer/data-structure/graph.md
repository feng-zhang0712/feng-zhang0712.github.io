Page 157
第6章
图
图是一种比线性表和树更为复杂的数据结构。在线性表中,数据元素之间仅有线性关系,
每个数据元素只有一个直接前驱和一个直接后继;在树形结构中,数据元素之间有着明显的层
次关系,并且每一层中的数据元素可能和下一层中的多个元素(即其孩子结点)相关,但只能
和上一层中一个元素(即其双亲结点)相关;而在图结构中,结点之间的关系可以是任意的,
图中任意两个数据元素之间都可能相关。由此,图的应用极为广泛,已渗入到诸如物理、化学、
电信工程、计算机科学,以及数学等其他分支中。在离散数学中,图论是专门研究图的性质的
数学分支,而在数据结构中,则应用图论的知识讨论如何在计算机上实现图的操作,因此主要
学习图的存储结构,以及若干图的操作的实现。
6.1图的定义和基本术语
6.1.1 图的定义
图(Graph)G由两个集合V和E组成,记为G=(V,E),其中V是顶点的有穷非空集合,
E是V中顶点偶对的有穷集合,这些顶点偶对称为边。V(G)和E(G)通常分别表示图G 的顶点集
合和边集合,E(G)可以为空集。若E(G)为空,则图G只有顶点而没有边。 单間(
对于图 G,若边集E(G)为有向边的集合,则称该图为有向图;若边集E(G)为无向边的集合,
则称该图为无向图。
在有向图中,顶点对<x,y>是有序的,它称为从顶点x到顶点y的一条有向边。因此,<x,
y>与<y, x>是不同的两条边。顶点对用一对尖括号括起来,x是有向边的始点,y是有向边的终点。
<x,y>也称作一条弧,则x为弧尾,y为弧头。 画面長图解:居室南
在无向图中,顶点对(x,y)是无序的,它称为与顶
点x和顶点y相关联的一条边。这条边没有特定的方向,
(x, y)与(y, x)是同一条边。为了有别于有向图,无向图
的顶点对用一对圆括号括起来。
G₁
站
G2
VA
Ꮩ
(a)有向图 G
(b)无向图 Gr
图6.1 图的示例
图 6.1 分别给出了有向图和无向图的示例。
6.1.2 图的基本术语
用n表示图中顶点数目,用e表示边的数目,下面介绍图结构中的一些基本术语。
149

Page 158
150
数据结构(C语言版)(第2版)
(1)子图:假设有两个图G=(V,E)和G'=('E'),如果'⊆V且E'CE,则称G'为G 的子
图。例如,图 6.2所示为图6.1中G和G子图的一些例子。
2
Vs V₁
V
(a)G的子图
(b)Gz的子图
图6.2子图示例
(2)无向完全图和有向完全图:对于无向图,若具有 n(n-1)/2条边,则称为无向完全图。
对于有向图,若具有n(n-1)条弧,则称为有向完全图。
(3)稀疏图和稠密图:有很少条边或弧(如e<nlogn)的图称为稀疏图,反之称为稠密图。
(4)权和网:在实际应用中,每条边可以标上具有某种含义的数值,该数值称为该边上的权。
这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。
(5)邻接点:对于无向图G,如果图的边(v, v')EE,则称顶点v和v互为邻接点,即v和v
相邻接。边(v,v')依附于顶点v和v',或者说边(v,v)与顶点v和v相关联。
(6)度、入度和出度:顶点v的度是指和v相关联的边的数目,记为TD(v)。例如,图6.1(b)中
Gz的顶点 vs 的度是3。对于有向图,顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目,记
为ID(v);出度是以顶点v为尾的弧的数目,记为OD(v)。顶点v的度为TD(v)=ID(v)+OD(v)。例如,
图 6.1 中 G 的顶点v的入度ID(vi)=1, 出度OD(vi)=2, 度TD(vi)=ID(vi)+OD(vi)=3。一般地,如果
顶点v的度记为TD(v),那么一个有n个顶点,e条边的图,满足如下关系
e=-
2
i=1
(7)路径和路径长度:在无向图G中,从顶点v到顶点v'的路径是一个顶点序列(v = Vi, 0,
Vi, 1st., Vi, m = v'),其中(Vij-1, Vi,j)∈E,1≤j≤m。如果G是有向图,则路径也是有向的,
顶点序列应满足<Vi,j-1, Vi, j>EE,1≤j≤m。路径长度是一条路径上经过的边或弧的数目。
(8)回路或环:第一个顶点和最后一个顶点相同的路径称为回路或环。斯克面中V
(9)简单路径、简单回路或简单环:序列中顶点不重复出现的路径称为简单路径。除了第一
个顶点和最后一个顶点之外,其余顶点不重复出现的回路,称为简单回路或简单环。
(10)连通、连通图和连通分量:在无向图G中,如果从顶点v到顶点v有路径,则称v和v'
是连通的。如果对于图中任意两个顶点viviEV,v和v都是连通的,则称G是连通图。图 6.1
(b)中的 G就是一个连通图,而图6.3(a)中的G,则是非连通图,但G,有3个连通分量,如图
6.3(b)所示。所谓连通分量,指的是无向图中的极大连通子图。
G3
B
(a)无向图G
(b)G的3个连通分量
雷木本基狀 图6.3 无向图及其连通分量
K

Page 159
————┤第6章 图
(11)强连通图和强连通分量:在有向图G中,如果对于每一对vi, v;EV, vi≠vi,从v到 v; 和
从v到v都存在路径,则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。
例如图6.1(a)中的G不是强连通图,但它有两个强连通分量,如图 6.4 所示。
(12)连通图的生成树:一个极小连通子图,它含有图中全部
顶点,但只有足以构成一棵树的 n-1 条边,这样的连通子图称为
连通图的生成树。图6.5所示为G,中最大连通分量的一棵生成树。
如果在一棵生成树上添加一条边,必定构成一个环,因为这条边
使得它依附的那两个顶点之间有了第二条路径。
2
Ꮩ
图6.4G的两个强连通分量
图6.4
一棵有n个顶点的生成树有且仅有n-1条边。如果一个图有
n个顶点和小于n-1条边,则是非连通图。如果它多于n-1条边,则一定有环。但是,有n-1
条边的图不一定是生成树。
(13)有向树和生成森林:有一个顶点的入度为0,其余顶点的入度均为1的有向图称为有向
树。一个有向图的生成森林是由若干棵有向树组成,含有图中全部顶点,但只有足以构成若干棵
不相交的有向树的弧。图6.6所示为其一例。
B
B
F)
F
E
D
(M)
E
图6.5G的最大连通分量的一棵生成树
图6.6一个有向图及其生成森林
8.0
D
6.2 案例引入
SNS(Social Networking Services),即社会性网络服务,是指帮助人们建立社会性网络的互联
网应用服务;也指社会现有的已成熟普及的信息载体,如短信 SMS服务。SNS的另一种常用解
释是“社交网站”或“社交网”(Social Network Site)。SNS的理论基础为“六度空间理论”。基
于此理论,SNS社区将用户关系梳理好后,可以将海量的内容灌入SNS社区。例如,喜欢电影的
朋友,把内容传递给爱好相同的朋友;备战考研的同学,把研究生入学考试的相关信息和自己的
复习经验传递给身边其他考研的同学。这种传递的形式非常简单,用户产生交互,内容即通过渠
道传递到真实的关系网中,杂乱无章的内容与人群通过SNS社区变得有序,如图6.7所示。
案例 6.1:六度空间理论。
六度空间理论是一个数学领域的猜想,又称为六度分割理论(Six Degrees of Separation)。六
度空间理论是20 世纪60年代由美国的心理学家米格兰姆(Stanley Milgram)提出的,理论指出:
你和任何一个陌生人之间所间隔的人不会超过6个,也就是说,最多通过6个中间人你就能够认
识任何一个陌生人,如图6.8所示。
随着新技术的发展,六度空间理论的应用价值受到了人们的广泛关注,除了前面提到的微
软的人立方搜索,很多领域都运用了六度空间理论,例如SNS 网站、BLOG 网站、电子游戏社
区、直销网络等。
151

Page 160
数据结构(C语言版)(第2版)
六度空间理论的出现使得人们对于自身的人际关系网络的威力有了新的认识。但为什么偏
偏是“六度”,而不是“七度”、“八度”或者“千百度”呢?这可能要从人际关系网络的另外一个
特征——“150 定律”来寻找解释。“150定律”指出,人类智力允许人类拥有稳定社交网络的人
数是148人,四舍五入大约是150人。这样我们可以对六度空间理论做如下数学解释(并非数学
证明):若每个人平均认识150人,其六度便是150°=11 390 625 000 000,消除一些重复的结点,
也远远超过了整个地球人口的若干多倍。
SNS社区
图6.7 SNS社区有序化示意图
6
3
图6.8六度空间理论示意图
那么,如何从理论上验证六度空间理论呢?六度空间理论的数学模型属于图结构,我们把六
度空间理论中的人际关系网络图抽象成一个无向图G,用图G中的一个顶点表示一个人,两个人
“认识”与否,用代表这两个人的顶点之间是否有一条边来表示。然后利用本章所学的图的有关算
法即可从理论上进行验证,本章6.7节将给出此案例的分析与实现。
6.3
图的类型定义
图是一种数据结构,加上一组基本操作,就构成了抽象数据类型。抽象数据类型图的定义如下:
ADT Graph {
数据对象:V是具有相同特性的数据元素的集合,称为顶点集。
数据关系:
R = {VR}
VR = {<V, w>lv, w∈V且P(v,w) <v,w>表示从v到w的弧,
谓词P(v,w)定义了弧<v,w>的意义或信息}
基本操作:
CreateGraph (&G, V,VR)
初始条件:V是图的顶点集,VR是图中弧的集合。
操作结果:按v和VR的定义构造图 G。
I DestroyGraph(&G)
初始条件:图G 存在。
操作结果:销毁图 G。
LocateVex (G, u)
初始条件:图G 存在,u和G中顶点有相同特征。
操作结果:若G中存在顶点u,则返回该顶点在图中的位置;否则返回其他信息。
GetVex (G, v)
初始条件:图G 存在,v是G中某个顶点。
操作结果:返回v的值。
152

Page 161
PutVex (&G, v, value);
初始条件:图G存在,v是G中某个顶点。
操作结果:对v赋值 value
FirstAdjvex (G,v)
初始条件:图G存在,v是G中某个顶点。
第6章 图
操作结果:返回 v的第一个邻接顶点。若v在G中没有邻接顶点,则返回“空”。
NextAdjvex (G,v,w)
初始条件:图G存在,v是G中某个顶点,w是v的邻接顶点。
操作结果:返回v的(相对于w的)下一个邻接顶点。若w是v的最后一个邻接点,则返回“空”。
InsertVex(&G,v)
初始条件:图G 存在,v和图中顶点有相同特征。
操作结果:在图G中增添新顶点v。
a DeleteVex(&G, v)
初始条件:图G存在,v是G中某个顶点。
操作结果:删除G中顶点v及其相关的弧。
InsertArc(&G,v,w)
初始条件:图G 存在,v和w是G中两个顶点。
操作结果:在G中增添弧<v,w>,若G是无向图,则还增添对称弧<w, v>。
DeleteArc (&G,v,w)
初始条件:图G存在,v和w是G中两个顶点。
操作结果:在G中删除弧<v,w>,若G是无向图,则还删除对称弧<w, v>
DFSTraverse (G)
初始条件:图G存在。
操作结果:对图进行深度优先遍历,在遍历过程中对每个顶点访问一次。
BFSTraverse (G)
初始条件:图G存在。
操作结果:对图进行广度优先遍历,在遍历过程中对每个顶点访问一次。
}ADT Graph
6.4 图的存储结构
由于图的结构比较复杂,任意两个顶点之间都可能存在联系,因此无法以数据元素在存储区
中的物理位置来表示元素之间的关系,即图没有顺序存储结构,但可以借助二维数组来表示元素
之间的关系,即邻接矩阵表示法。另一方面,由于图的任意两个顶点间都可能存在关系,因此,
用链式存储表示图是很自然的事,图的链式存储有多种,有邻接表、十字链表和邻接多重表,应
根据实际需要的不同选择不同的存储结构。
6.4.1 邻接矩阵
1. 邻接矩阵表示法
邻接矩阵(Adjacency Matrix)是表示顶点之间相邻关系的矩阵。设G(V,E)是具有n个顶点
的图,则 G 的邻接矩阵是具有如下性质的n阶方阵
4[i][j]=
# (v¡, v; ) ₁ (v¿¡, v; ) ≤ E
E
反之
153

Page 162
数据结构(C语言版)(第2版)
例如,图 6.1 中所示的G和G的邻接矩阵如图6.9 所示。
50 1 0 1 07
0 1 1 0
1
0
1
01
00 00
G1.ares =
,G2.ares
0 1
0
1 1
000 1
1
0
1
00
L10 0 0
0 1
1
0 0
图6.9 图的邻接矩阵
若G是网,则邻接矩阵可以定义为
Wij
4[i][j]=<
1.若(v)或(v/v)∈E
8
- 反之
其中,w.j表示边上的权值;∞表示计算机允许的、大于所有边权值的数。例如,图6.10所示
为一个有向网和它的邻接矩阵。
5
8
4
3.
7
∞ 5 8 7 8
∞
9
8
∞
4
8
∞
8
6
VA
(a)网
8
8
8
∞
8
9
8
8
5 8
8
6
∞
∞
∞ 5 8 8
3
8
8
8 1 8
(b)邻接矩阵
154
图6.10 网及其邻接矩阵
用邻接矩阵表示法表示图,除了一个用于存储邻接矩阵的二维数组外,还需要用一个一维数
组来存储顶点信息。其形式说明如下:
//-----图的邻接矩阵存储表示---
#define MaxInt 32767
//表示极大值,即∞
//最大顶点数
//假设顶点的数据类型为字符型
//假设边的权值类型为整型
#define MVNum 100
typedef char VerTexType;
typedef int ArcType;
☑✰ typedef struct
{
VerTexType vexs[MVNum];
ArcType arcs [MVNum] [MVNum];
int vexnum, arcnum;
}AMGraph;
2.采用邻接矩阵表示法创建无向网
//顶点表
//邻接矩阵
//图的当前点数和边数
已知一个图的点和边,使用邻接矩阵表示法来创建此图的方法比较简单,下面以一个无向网
为例来说明创建图的算法。
算法6.1 采用邻接矩阵表示法创建无向网
【算法步骤】
① 输入总顶点数和总边数。
② 依次输入点的信息存入顶点表中。
③ 初始化邻接矩阵,使每个权值初始化为极大值。

Page 163
第6章 图
④ 构造邻接矩阵。依次输入每条边依附的顶点和其权值,确定两个顶点在图中的位置之后,
使相应边赋予相应的权值,同时使其对称边赋予相同的权值。
【算法描述】
Status CreateUDN (AMGraph &G)
{//采用邻接矩阵表示法,创建无向网 G
cin>>G.vexnum>>G.arcnum;
for(i=0;i<G.vexnum; ++i)
//输入总顶点数,总边数
//依次输入点的信息
cin>>G.vexs[i];
for(i=0;i<G.vexnum; ++i)
//初始化邻接矩阵,边的权值均置为极大值 MaxInt
for(j=0;j<G.vexnum;++j)
G.arcs[i][j]=MaxInt;
for(k=0;k<G.arcnum;++k)
{
cin>>v1>>v2>>w;
//构造邻接矩阵
sisb
//输入一条边依附的顶点及权值
i=LocateVex(G,vl); j=LocateVex(G,v2);//确定v1v2G中的位置,即顶点数组的下标
G.arcs[i][j]=w;
G.arcs[j][i]=G.arcs[i][j];
return OK;
}
//边<v1,v2>的权值置为w
//置<v1, v2>的对称边<v2,v1>的权值为w
//for
【算法分析】
该算法的时间复杂度是O(n²)。
若要建立无向图,只需对上述算法做两处小的改动:一是初始化邻接矩阵时,将边的权值均
初始化为0;二是构造邻接矩阵时,将权值改为常量值1即可。同样,将该算法稍做修改即可
建立一个有向网或有向图。
3. 邻接矩阵表示法的优缺点
(1)优点
①便于判断两个顶点之间是否有边,即根据4[i][j]=0或1来判断。
②便于计算各个顶点的度。对于无向图,邻接矩阵第i行元素之和就是顶点的度;对于有
向图,第i行元素之和就是顶点的出度,第i列元素之和就是顶点的入度。
(2)缺点
①不便于增加和删除顶点。
②不便于统计边的数目,需要扫描邻接矩阵所有元素才能统计完毕,时间复杂度为O(n²)。
③ 空间复杂度高。如果是有向图,n个顶点需要2个单元存储边。如果是无向图,因其邻接矩阵
是对称的,所以对规模较大的邻接矩阵可以采用压缩存储的方法,仅存储下三角(或上三角)的元素,
这样需要n(n-1)/2个单元即可。但无论以何种方式存储,邻接矩阵表示法的空间复杂度均为O(n²),这
对于稀疏图而言尤其浪费空间。
下面介绍的邻接表将邻接矩阵的n行改成n个单链表,适合表示稀疏图。
6.4.2 邻接表
1.邻接表表示法
邻接表(Adjacency List)是图的一种链式存储结构。在邻接表中,对图中每个顶点v;建立一
个单链表,把与v相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶
155

Page 164
156
数据结构(C语言版)(第2版)
点的信息,把这一结点看成链表的表头,其余结点存放有关边的信息,这样邻接表便由两部分组
成:表头结点表和边表。
(1)表头结点表:由所有表头结点以顺序结构的形式存储,以便可以随机访问任一顶点的边
链表。表头结点包括数据域(data)和链域(firstarc)两部分,如图6.11(a)所示。其中,数据
域用于存储顶点v的名称或其他有关信息;链域用于指向链表中第一个结点(即与顶点v邻接的
第一个邻接点)。
(2)边表:由表示图中顶点间关系的2n 个边链表组成。边链表中边结点包括邻接点域
(adjvex)、数据域(info)和链域(nextarc)三部分,如图6.11(b)所示。其中,邻接点域指示
与顶点v邻接的点在图中的位置;数据域存储和边相关的信息,如权值等;链域指示与顶点 V
邻接的下一条边的结点。
data firstarc
adjvex
info
nextarc
(a)表头结点
(b)边结点
图6.11 表头结点和边结点
例如,图 6.12(a)和(b)所示分别为图6.1中G和Gz的邻接表。
在无向图的邻接表中,顶点v的度恰为第i个链表中的结点数;而在有向图中,第i个链表中
的结点个数只是顶点v的出度,为求入度,必须遍历整个邻接表。在所有链表中,其邻接点域的值
为i的结点的个数是顶点v的入度。有时,为了便于确定顶点的入度,可以建立一个有向图的邻
接表,即对每个顶点v建立一个链接所有进入v的边的表,例如,图6.12(c)所示为有向图 G 的
逆邻接表。
0 Ꮴ
- 3.
1 Λ
0
2
1 Λ
1 V₂
4
2
0 Λ
o
3 Λ
1
Λ
2
4
3
1
^
1 V₂
0
^
2
3
3
Λ
3 V4
2
0
Λ
2 V3
0 Λ
3
0 Λ
(a)G的邻接表
4
Vs
2
3 V4
- 2 ^
(b)G的邻接表
(c)G的逆邻接表
图6.12邻接表和逆邻接表
根据上述讨论,要定义一个邻接表,需要先定义其存放顶点的头结点和表示边的边结点。图
的邻接表存储结构说明如下:
//--- ---图的邻接表存储表示-
#define MVNum 100
typedef struct ArcNode
{
int adjvex;
struct ArcNode * nextarc;
Other Info info%;B
}ArcNode;
typedef struct VNode.
{
VerTexType data;
//最大顶点数
//边结点
//该边所指向的顶点的位置
//指向下一条边的指针
//和边相关的信息
//顶点信息

Page 165
ArcNode *firstarc;
}VNode AdjList[MVNum];
typedef struct
{
Adj List vertices;
//指向第一条依附该顶点的边的指针
//AdjList 表示邻接表类型
//邻接表
第6章图
int vexnum, arcnum;
}ALGraph;
2.采用邻接表表示法创建无向图
//图的当前顶点数和边数
基于上述的邻接表表示法,要创建一个图则需要创建其相应的顶点表和边表。下面以一个无
向图为例来说明采用邻接表表示法创建无向图的算法。
算法6.2 采用邻接表表示法创建无向图
【算法步骤】
① 输入总顶点数和总边数。
② 依次输入点的信息存入顶点表中,使每个表头结点的指针域初始化为NULL。
③ 创建邻接表。依次输入每条边依附的两个顶点,确定这两个顶点的序号i和j之后,将此
边结点分别插入v和v对应的两个边链表的头部。
【算法描述】
Status CreateUDG (ALGraph &G)
{//采用邻接表表示法,创建无向图 G
cin>>G.vexnum>>G.arcnum;
for(i=0;i<G.vexnum; ++i)
{
cin>> G.vertices[i].data;
//输入总顶点数,总边数
//输入各点,构造表头结点表
//输入顶点值
G.vertices[i].firstarc=NULL;
}
for(k=0;k<G.arcnum;++k)
{
cin>>v1>>v2;
//初始化表头结点的指针域为NULL
//for
//输入各边,构造邻接表
//输入一条边依附的两个顶点
i=LocateVex(G,vl); j=LocateVex (G,v2);
//确定v1 和v2 在G中位置,即顶点在G.vertices 中的序号
p1=new ArcNode;
p1->adjvex=j;
//生成一个新的边结点*p1
//邻接点序号为j
p1->nextarc=G.vertices[i].firstarc; G.vertices[i].firstarc=p1;
//将新结点*p1 插入顶点v的边表头部
p2=new ArcNode;
//生成另一个对称的新的边结点*p2
//邻接点序号为i
P
p2->adjvex=i;
p2->nextarc=G.vertices[j].firstarc; G.vertices[j].firstarc=p2;
//将新结点*p2 插入顶点 vs 的边表头箭
return OK;
//for
【算法分析】
该算法的时间复杂度是O(n+e)。
建立有向图的邻接表与此类似,只是更加简单,每读入一个顶点对序号<i,j>,仅需生成一
个邻接点序号为j的边表结点,并将其插入到v的边链表头部即可。若要创建网的邻接表,可以
157

Page 166
数据结构(C语言版)(第2版)
将边的权值存储在 info 域中。
注意
值得注意的是,一个图的邻接矩阵表示是唯一的,但其邻接表表示不唯一,这是因
为邻接表表示中,各边表结点的链接次序取决于建立邻接表的算法,以及边的输入次序。
邻接矩阵和邻接表是图的两种最常用的存储结构,它们各有所长。与邻接矩阵相比,邻接表
有其自己的优缺点。
3.邻接表表示法的优缺点
(1)优点
① 便于增加和删除顶点。
② 便于统计边的数目,按顶点表顺序扫描所有边表可得到边的数目,时间复杂度为
O(n + e)。
③ 空间效率高。对于一个具有n个顶点条边的图G,若G是无向图,则在其邻接表表示
中有n个顶点表结点和2个边表结点;若G是有向图,则在它的邻接表表示或逆邻接表表示中
均有n个顶点表结点和e个边表结点。因此,邻接表或逆邻接表表示的空间复杂度为O(n+e),
适合表示稀疏图。对于稠密图,考虑到邻接表中要附加链域,因此常采取邻接矩阵表示法。
(2)缺点
①不便于判断顶点之间是否有边,要判定v和v之间是否有边,就需扫描第i个边表,最坏
情况下要耗费 O(n)时间。
②不便于计算有向图各个顶点的度。对于无向图,在邻接表表示中顶点v的度是第i个边表
中的结点个数。在有向图的邻接表中,第i个边表上的结点个数是顶点v的出度,但求v的入度
较困难,需遍历各顶点的边表。若有向图采用逆邻接表表示,则与邻接表表示相反,求顶点的入
度容易,而求顶点的出度较难。
下面介绍的十字链表便于求得顶点的入度和出度。
6.4.3 十字链表
十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以看成是将有向图的邻接表
和逆邻接表结合起来得到的一种链表。在十字链表中,对应于有向图中每一条弧有一个结点,对
应于每个顶点也有一个结点。这些结点的结构如图6.13 所示。
tailvex
headvex
hlink
tlink
info
(a)弧结点
图6.13 弧结点和顶点结点
data
firstin
firstout
(b)顶点结点
158
在弧结点中有5个域:其中尾域(tailvex)和头域(headvex)分别指示弧尾和弧头这两个顶点在
图中的位置,链域hlink 指向弧头相同的下一条弧,而链域tlink指向弧尾相同的下一条弧,info 域指
向该弧的相关信息。弧头相同的弧在同一链表上,弧尾相同的弧也在同一链表上。它们的头结点即为
顶点结点,它由3个域组成:其中data 域存储和顶点相关的信息,如顶点的名称等;firstin 和 firstout
为两个链域,分别指向以该顶点为弧头或弧尾的第一个弧结点。例如,图6.14(a)中所示图的十字
链表如图 6.14(b)所示。若将有向图的邻接矩阵看成是稀疏矩阵的话,则十字链表也可以看成是邻
接矩阵的链表存储结构,在图的十字链表中,弧结点所在的链表非循环链表,结点之间相对位置自然
形成,不一定按顶点序号有序,表头结点即顶点结点,它们之间不是链接,而是顺序存储。

Page 167
V₁
0 V
0102^
1 V₂
^
V3
2 V3
-
201
23 AA
3 V4
(a)
30 Λ
1^ 3 2 ^^
(b)
图6.14 有向图的十字链表
有向图的十字链表存储表示的形式说明如下所示:
//- - - - -有向图的十字链表存储表示
#define MAX_VERTEX_NUM 20
typedef strut ArcBox
{
int tailvext, headvex;
struct ArcBox *hlink, *tlink;
InfoType *info;
}ArcBox;
typedef struct VexNode
//该弧的尾和头顶点的位置
//分别为弧头相同和弧尾相同的弧的链域
//该弧相关信息的指针
{
VertexType data;
ArcBox *firstin,*firstout;
//分别指向该顶点第一条入弧和出弧
}VexNode;
typedef struct
第6章 图
{
VexNode xlist[MAX_VERTEX_NUM];
int vexnnm, arcnum;
}OLGraph;
//表头向量
//有向图的当前顶点数和弧数
只要输入n个顶点的信息和条弧的信息,便可建立该有向图的十字链表,读者可以模仿算
法 6.2 写出采用十字链表表示法创建有向图的算法。建立十字链表的时间复杂度和建立邻接表是
相同的。在十字链表中既容易找到以v为尾的弧,也容易找到以为头的弧,因而容易求得顶点
的出度和入度(或需要,可在建立十字链表的同时求出)。在某些有向图的应用中,十字链表是很
有用的工具。
6.4.4 邻接多重表
邻接多重表(Adjacency Multilist)是无向图的另一种链式存储结构。虽然邻接表是无向图的
一种很有效的存储结构,在邻接表中容易求得顶点和边的各种信息。但是,在邻接表中每一条边
(Vi,vy)有两个结点,分别在第i个和第j个链表中,这给某些图的操作带来不便。例如在某些图
的应用问题中需要对边进行某种操作,如对已被搜索过的边作记号或删除一条边等,此时需要找
到表示同一条边的两个结点。因此,在进行这一类操作的无向图的问题中采用邻接多重表存储
结构更为适宜。
邻接多重表的结构和十字链表类似。在邻接多重表中,每一条边用一个结点表示,它由如图
6.15(a)所示的6个域组成。其中,mark为标志域,可用以标记该条边是否被搜索过;ivex 和jvex
为该边依附的两个顶点在图中的位置;ilink指向下一条依附于顶点ivex 的边;jlink 指向下一条依
159

Page 168
160
数据结构(C语言版)(第2版)
附于顶点 jvex 的边,info为指向和边相关的各种信息的指针域。
每一个顶点也用一个结点表示,它由如图6.15(b)所示的两个域组成。其中,data 域存储和
该顶点相关的信息,firstedge 域指示第一条依附于该顶点的边。例如,图6.16所示为无向图 Gr
的邻接多重表。在邻接多重表中,所有依附于同一顶点的边串联在同一链表中,由于每条边依附
于两个顶点,则每个边结点同时链接在两个链表中。可见,对无向图而言,其邻接多重表和邻接
表的差别,仅仅在于同一条边在邻接表中用两个结点表示,而在邻接多重表中只有一个结点。因
此,除了在边结点中增加一个标志域外,邻接多重表所需的存储量和邻接表相同。
mark
ivex
ilink
jvex
jlink
info
data
firstedge
(a)边结点
(b)顶点结点
图6.15 边结点和顶点结点
0 V₁
0
1
0
Λ
3
Λ
1 V₂
2 V3
2
1
2
3
3 V4
4. V
4
^
21 Λ
4 ^
图6.16 无向图G的邻接多重表
在邻接多重表上,各种基本操作的实现和邻接表相似。邻接多重表的类型说明如下:
//---- --无向图的邻接多重表存储表示-
#define MAX_VERTEX_NUM 20
typedef enum{unvisited, visited} VisitIf;
typedef struct EBox
{
VisitIf mark;
int ivex, jvex;
struct EBox *ilink, *jlink;
InfoType *info;
}Ebox;
typedef struct VexBox
}
VertexType data;
EBox *firstedge;
}VexBox;
typedef struct {
VexBox adjmulist[MAX_VERTEX_NUM];
int vexnum, edgenum;
}AMLGraph;
//访问标记
//该边依附的两个顶点的位置
//分别指向依附这两个顶点的下一条边
//该边信息指针
//指向第一条依附该顶点的边
//无向图的当前顶点数和边数
6.5 图的遍历
和树的遍历类似,图的遍历也是从图中某一顶点出发,按照某种方法对图中所有顶点访问且

Page 169
第6章图
仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。
然而,图的遍历要比树的遍历复杂得多。因为图的任一顶点都可能和其余的顶点相邻接。所
以在访问了某个顶点之后,可能沿着某条路径搜索之后,又回到该顶点上。例如,图6.1(b)中
所示的 Ga,由于图中存在回路,因此在访问了vi、V2、V3、V4之后,沿着边<v4, Vi>又可访问到 Vı。
为了避免同一顶点被访问多次,在遍历图的过程中,必须记下每个已访问过的顶点。为此,设一
个辅助数组 visited[n],其初始值置为“false”或者0,一旦访问了顶点vi,便置 visited[i]为“true”
或者1。
根据搜索路径的方向,通常有两条遍历图的路径:深度优先搜索和广度优先搜索。它们对无
向图和有向图都适用。
6.5.1 深度优先搜索
1. 深度优先搜索遍历的过程
深度优先搜索(Depth First Search,DFS)遍历类似于树的先序遍历,是树的先序遍历的推广。
对于一个连通图,深度优先搜索遍历的过程如下。
(1)从图中某个顶点v出发,访问 v。
(2)找出刚访问过的顶点的第一个未被访问的邻接点,访问该顶点。以该顶点为新顶点,重
复此步骤,直至刚访问过的顶点没有未被访问的邻接点为止。
(3)返回前一个访问过的且仍有未被访问的邻接点的顶点,找出该顶点的下一个未被访问的
邻接点,访问该顶点。
(4)重复步骤(2)和(3),直至图中所有顶点都被访问过,搜索结束。
以图 6.17(a)中所示的无向图G为例,深度优先搜索遍历图的过程如图6.17(b)所示。
具体过程如下。
G4
V
V₁₂
Vi
8
(a)无向图Ga
(b)深度优先搜索的过程
(c)广度优先搜索的过程
图6.17 遍历图的过程
(1)从顶点vz出发,访问 vı。
(2)在访问了顶点vi之后,选择第一个未被访问的邻接点vz,访问vzvz为新顶点,重复
此步,访问 V4,Vs、Vs。在访问了vs之后,由于vs的邻接点都已被访问,此步结束。0元
(3)搜索从vs回到vs,由于同样的理由,搜索继续回到V4,V2直至v1,此时由于v的另一个
邻接点未被访问,则搜索又从vnv3,再继续进行下去。由此,得到的顶点访问序列为:
①图中以带箭头的粗实线表示遍历时的访问路径,以带箭头的虚线表示回溯的路径。小圆圈表示已被访问
过的邻接点,大圆圈表示访问的邻接点。
161

Page 170
162
数据结构(C语言版)(第2版)
V1-V2-V4-V8-V5-V3-V6-V7
图 6.17(b)中所示的所有顶点加上标有实箭头的边,构成一棵vi为根的树,称为深度优
先生成树,如图6.18(a)所示。
(V₁₂
(a)G4的深度优先生成树 (b)Ga的广度优先生成树
图6.18 生成树
2. 深度优先搜索遍历的算法实现
显然,深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已
被访问,需附设访问标志数组 visited[n],其初值为“false”,一旦某个顶点被访问,则其相应的分
量置为“true”。
算法6.3 深度优先搜索遍历连通图
【算法步骤】
①从图中某个顶点v出发,访问v,并置visited[v]的值为true。
② 依次检查v的所有邻接点w,如果visited[w]的值为false,再从w出发进行递归遍历,
直到图中所有顶点都被访问过。
【算法描述】
bool visited[MVNum];
//访问标志数组,其初值为“false"
void DFS (Graph G,int v)
{//从第v个顶点出发递归地深度优先遍历图 G
cout<<v;visited[v]=true;
//访问第v个顶点,并置访问标志数组相应分量值为true
for (w=FirstAdjvex(G,v);w>=0;w=NextAdjvex (G,v,w))
//依次检查v的所有邻接点w, FirstAdjvex (G, v)表示v的第一个邻接点
//NextAdjvex (G,v,w)表示v相对于w的下一个邻接点,w≥0表示存在邻接点
if(!visited[w]) DFS (G,w);
//对v的尚未访问的邻接顶点w递归调用 DFS
若是非连通图,上述遍历过程执行之后,图中一定还有顶点未被访问,需要从图中另选
一个未被访问的顶点作为起始点,重复上述深度优先搜索过程,直到图中所有顶点均被访问
过为止。这样,要实现对非连通图的遍历,需要循环调用算法6.3,具体实现如算法6.4 所示。
算法6.4 深度优先搜索遍历非连通图
【算法描述】
void DFSTraverse (Graph G)
{ //对非连通图G做深度优先遍历
for(v=0;v<G.vexnum;++v) visited[v]=false;
for(v=0;v<G.vexnum; ++v)
//访问标志数组初始化
//循环调用算法6.3

Page 171
}
if(!visited[v]) DFS (G,v);
第6章图
//对尚未访问的顶点调用 DFS
对于算法6.4,每调用一次算法6.3将遍历一个连通分量,有多少次调用,就说明图中有多少
个连通分量。
在算法 6.3 中,对于查找邻接点的操作 FirstAdjVex(G, v)及NextAdjVex(G,v,w)并没有具体展
开。如果图的存储结构不同,这两个操作的实现方法不同,时间耗费也不同。下面的算法6.5、算
法6.6分别用邻接矩阵和邻接表具体实现了算法 6.3 的功能。
算法6.5采用邻接矩阵表示图的深度优先搜索遍历
【算法描述】
void DFS_AM (AMGraph G,int v)
{ //图G为邻接矩阵类型,从第一个顶点出发深度优先搜索遍历图G
}
cout<<v;visited[v]=true;
for (w=0;w<G.vexnum;w++)
//访问第v个顶点,并置访问标志数组相应分量值为true
//依次检查邻接矩阵v所在的行
if((G.arcs[v][w]!=0)&&(!visited[w])) DFS (G,w);
//G.arcs[v][w]!=0表示w是v的邻接点,如果w未访问,则递归调用DFS
算法6.6 采用邻接表表示图的深度优先搜索遍历
【算法描述】
void DFS_AL (ALGraph G,int v)
{ //图G为邻接表类型,从第一个顶点出发深度优先搜索遍历图G
cout<<v;visited[v]=true;
p=G.vertices[v].firstarc;
while(p!=NULL)
{
w=p->adjvex;
if(!visited[w]) DFS (Gw);
p=p->nextarc;
}
//访问第v个顶点,并置访问标志数组相应分量值为true
//p指向v的边链表的第一个边结点
//边结点非空
//表示w是v的邻接点
//如果w未访问,则递归调用DFS
//p指向下一个边结点
//while
3. 深度优先搜索遍历的算法分析
分析上述算法,在遍历图时,对图中每个顶点至多调用一次DFS函数,因为一旦某个顶点被
标志成已被访问,就不再从它出发进行搜索。因此,遍历图的过程实质上是对每个顶点查找其邻
接点的过程,其耗费的时间则取决于所采用的存储结构。当用邻接矩阵表示图时,查找每个顶点
的邻接点的时间复杂度为O(n²),其中n为图中顶点数。而当以邻接表做图的存储结构时,查找邻
接点的时间复杂度为O(e),其中e为图中边数。由此,当以邻接表做存储结构时,深度优先搜索
遍历图的时间复杂度为O(n+e)。
6.5.2 广度优先搜索
1. 广度优先搜索遍历的过程
广度优先搜索(Breadth First Search, BFS)遍历类似于树的按层次遍历的过程。
广度优先搜索遍历的过程如下。
(1)从图中某个顶点v出发,访问 v。
163

Page 172
164
数据结构(C语言版)(第2版)
(2)依次访问v的各个未曾访问过的邻接点。
(3)分别从这些邻接点出发依次访问它们的邻接点,并使“先被访问的顶点的邻接点”先于
“后被访问的顶点的邻接点”被访问。重复步骤(3),直至图中所有已被访问的顶点的邻接点都被
访问到。
例如,对图 G进行广度优先搜索遍历的过程如图6.17(c)所示,具体过程如下。
(1)从顶点出发,访问 vi
(2)依次访问v的各个未曾访问过的邻接点V2V3。
(3)依次访问v2的邻接点V4和Vs,以及vs的邻接点ve和V,最后访问va的邻接点 vs。由于
这些顶点的邻接点均已被访问,并且图中所有顶点都被访问,由此完成了图的遍历。得到的顶点
访问序列为:
V1 V2 V3 V4 V5-V6-V7-V8
图 6.17(c)中所示的所有顶点加上标有实箭头的边,构成一棵v为根的树,称为广度优
先生成树,如图6.18(b)所示。
2.广度优先搜索遍历的算法实现
可以看出,广度优先搜索遍历的特点是:尽可能先对横向进行搜索。设x和y是两个相继被
访问过的顶点,若当前是以x为出发点进行搜索,则在访问x的所有未曾被访问过的邻接点之后,
紧接着是以y为出发点进行横向搜索,并对搜索到的y的邻接点中尚未被访问的顶点进行访问。
也就是说,先访问的顶点其邻接点亦先被访问。为此,算法实现时需引进队列保存已被访问过的
顶点。
和深度优先搜索类似,广度优先搜索在遍历的过程中也需要一个访问标志数组。
算法 6.7 广度优先搜索遍历连通图
【算法步骤】
①从图中某个顶点v出发,访问v,并置 visited[v]的值为true,然后将v进队。
② 只要队列不空,则重复下述操作:
●队头顶点z出队;
依次检查的所有邻接点w,如果visited[w]的值为false,则访问w,并置 visited[w]的值
为true,然后将w进队。
【算法描述】
void BFS (Graph G,int v)
{ //按广度优先非递归遍历连通图 G
cout<<v;visited[v]=true;
InitQueue (Q);
EnQueue (Q, v) ;
//访问第v个顶点,并置访问标志数组相应分量值为true
//辅助队列Q初始化,置空
//v进队
//队列非空
while(!QueueEmpty (Q))
{
DeQueue (Q, u);
//队头元素出队并置为u
for (w=FirstAdjvex(Gu);w>=0;w=NextAdjvex (G,u,w))
//依次检查的所有邻接点w, FirstAdjvex(Gu)表示u的第一个邻接点
//NextAdjVex (Gu,w)表示u相对于w的下一个邻接点,w≥0表示存在邻接点
if (!visited[w])
{
//w为u的尚未访问的邻接顶点
cout<<w; visited[w]=true; //访问w,并置访问标志数组相应分量值为true

Page 173
EnQueue (Q, w);
}
}
://w进队
//if
//while
第6章图
若是非连通图,上述遍历过程执行之后,图中一定还有顶点未被访问,需要从图中另选
一个未被访问的顶点作为起始点,重复上述广度优先搜索过程,直到图中所有顶点均被访问
过为止。
对于非连通图的遍历,实现算法类似于算法6.4,仅需将原算法中的DFS 函数调用改为BFS
函数调用。
读者可以参考算法6.5和算法6.6,分别用邻接矩阵和邻接表具体实现算法6.7的功能。
3. 广度优先搜索遍历的算法分析
分析上述算法,每个顶点至多进一次队列。遍历图的过程实质上是通过边找邻接点的过程,
因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同,即当用邻接矩阵存储时,时间
复杂度为O(n²);用邻接表存储时,时间复杂度为O(n+e)。两种遍历方法的不同之处仅仅在于对
顶点访问的顺序不同。
6.6 图的应用
中戲
现实生活中的许多问题都可以转化为图来解决。例如,如何以最小成本构建一个通信网络,
如何计算地图中两地之间的最短路径,如何为复杂活动中各子任务的完成寻找一个较优的顺序等。
本节将结合这些常用的实际问题,介绍图的几个常用算法,包括最小生成树,最短路径、拓扑排
序和关键路径算法。
6.6.1 最小生成树
假设要在n个城市之间建立通信联络网,则连通n个城市只需要n-1条线路。这时,自然
会考虑这样一个问题,如何在最节省经费的前提下建立这个通信网。 ®
在每两个城市之间都可设置一条线路,相应地都要付出一定的经济代价。n个城市之间,
最多可能设置 n(n-1)/2条线路,那么,如何在这些可能的线路中选择n-1条,以使总的耗
费最少呢?
可以用连通网来表示n个城市,以及n个城市间可能设置的通信线路,其中网的顶点表
示城市,边表示两城市之间的线路,赋予边的权值表示相应的代价。对于n个顶点的连通网
可以建立许多不同的生成树,每一棵生成树都可以是一个通信网。最合理的通信网应该是代
价之和最小的生成树。在一个连通网的所有生成树中,各边的代价之和最小的那棵生成树称
为该连通网的最小代价生成树(Minimum Cost Spanning Tree),简称为最小生成树。
构造最小生成树有多种算法,其中多数算法利用了最小生成树的下列一种简称为MST 的
性质:假设N=(V,E)是一个连通网,U是顶点集的一个非空子集。若(u,v)是一条具有最小
权值(代价)的边,其中 u∈ U,v∈ V-U,则必存在一棵包含边(u, v)的最小生成树。
可以用反证法来证明。假设网的任何一棵最小生成树都不包含(u,v)。设是连通网上的
一棵最小生成树,当将边(u,v)加入到中时,由生成树的定义,T中必存在一条包含(u,v)的回
165

Page 174
数据结构(C语言版)(第2版)
路。另一方面,由于T是生成树,则在T上必存在另一条边(u'v'),其中u'∈U, v'∈V - U,且
u 和 u' 之间、v和v'之间均有路径相通。删去边(u'v'),便可消除上述回路,同时得到另一棵生
成树 '。因为(u,v)的权值不高于(u',v'),则T的权值亦不高于T,T是包含(u,v)的一棵最小生成
树。由此和假设矛盾。
普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法是两个利用MST 性质构造最小生成树的
算法。下面先介绍普里姆算法。
1. 普里姆算法
(1)普里姆算法的构造过程
假设N=(V,E)是连通网,TE是N上最小生成树中边的集合。
① U= {0}(zuo∈V),TE = {}。
② 在所有 u∈U,vEV-U的边(u,v)EE中找一条权值最小的边(uovo)并入集合TE,同时 vo
并入 U。
③重复②,直至U=V为止。
此时 TE 中必有 n-1条边,则T=(V,TE)为N的最小生成树。
图 6.19 所示为一个连通网Gs从v开始构造最小生成树的例子。可以看出,普里姆算法逐步
增加U中的顶点,可称为“加点法”。
注意
Gs
V,
VA
V₂
3
6.
2
V
Vo
(a)
V6
(d)
(V5
V3
4
V6
V₁
V6
(b)
5
VA
4
3
4
V6
Vs
V6
(e)
(f)
图6.19 普里姆算法构造最小生成树的过程
每次选择最小边时,可能存在多条同样权值的可选,此时任选其一即可。
166
(2)普里姆算法的实现
假设一个无向网G以邻接矩阵形式存储,从顶点出发构造G的最小生成树T,要求输出 T
的各条边。为实现这个算法需附设一个辅助数组 closedge,以记录从U到V-U具有最小权值的
边。对每个顶点viEV-U,在辅助数组中存在一个相应分量 closedge[i-1],它包括两个域: lowcost
和 adjvex, 其中 lowcost 存储最小边上的权值,adjvex 存储最小边在U中的那个顶点。显然,
closedge[i-1].lowcost = Min{cost(u,vi)u∈U},其中cost(u,v)表示赋于边(u,v)的权。
//辅助数组的定义,用来记录从顶点集UV-U的权值最小的边

Page 175
struct
{
第6章图
VerTexType adjvex;
ArcType lowcost;
}closedge [MVNum];
算法6.8 普里姆算法
【算法步骤】
//最小边在U中的那个顶点
//最小边上的权值
①首先将初始顶点u加入U中,对其余的每一个顶点v, 将closedge[j]均初始化为到的边信息。
② 循环n-1次,做如下处理:
从各组边 closedge 中选出最小边 closedge[k],输出此边;
● 将k加入U中;
● 更新剩余的每组最小边信息 closedge[j],对于V-U中的边,新增加了一条从k到j的
边,如果新边的权值比 closed ge[j].lowcost 小,则将 closedge[j].lowcost 更新为新边的
权值。
【算法描述】
void MiniSpanTree_Prim(AMGraph G, VerTexType u
{//无向网G 以邻接矩阵形式存储,从顶点u出发构造G的最小生成树T,输出 T 的各条边
k=LocateVex (G, u);
for(j=0;j<G.vexnum;++j)
if(j!=k) closedge[j]={u,G.arcs[k][j]}; //{adjvex, lowcost}
closedge[k].lowcost=0;
//k为顶点u的下标
//对V-U的每一个顶点v,初始化 closedge[j]
//初始,U={u}
for(i=1;i<G.vexnum; ++i)
{ //选择其余n-1 个顶点,生成n-1条边(n=G.vexnum)
k=Min(closedge);
//求出T的下一个结点:第k个顶点,closedge[k]中存有当前最小边
u0=closedge[k].adjvex;
* v0=G.vexs[k];
//u0为最小边的一个顶点,u∈u
//v0为最小边的另一个顶点,vo∈v-u
cout<<u0<<v0;
//输出当前的最小边(u0,vo)
closedge[k].lowcost=0;
//第k个顶点并入U集
for(j=0;j<G.vexnum; ++j)
}
}
if(G.arcs[k][j]<closedge[j].lowcost) //新顶点并入后重新选择最小边
closedge[j]={G.vexs[k],G.arcs[k][j]};
【算法分析】
//for
分析算法6.8,假设网中有n个顶点,则第一个进行初始化的循环语句的频度为n,第二个循
环语句的频度为 n-1。其中第二个有两个内循环:其一是在 closedge[v].lowcost 中求最小值,其
频度为 n-1;其二是重新选择具有最小权值的边,其频度为n。由此,普里姆算法的时间复杂度
为O(n²),与网中的边数无关,因此适用于求稠密网的最小生成树。
【例6.1】 利用算法6.8,对图6.19(a)所示的连通网G;从顶点v开始构造最小生成树,
给出算法中各参量的变化。
各参量的变化如表6.1所示。
167

Page 176
168
数据结构(C语言版)(第2版)
表6.1
图6.19 构造最小生成树过程中辅助数组中各分量的值
i
0
1
2
3
4
5
U
V-U
k
(uo, Vo)
closedge[i]
adjvex
lowcost
0
56
V₁ Vi
VI
Vi
{v₁}
{V2, V3, V4, V5, V6}
2
(V1, V3)
1
5
8
8
adjvex
V3
ㄥˋ
V3
V3
{V1, V3}
{V2, V4, V5, V6}
5
(V3, V6)
lowcost
0 5
0
5
6
4
adjvex
lowcost
0
ㄕㄥ
V3
5 0
adjvex
lowcost
0
35
26
22
0
0
V6
3 6
V3
{V1, V3, V6}
{V2, V4, V5}
3
(V6, V4)
6
V3
6
0
0
{V1, V3, V6, V4}
{V2, V5}
1
(V3, V2)
adjvex
V2
{V1, V3, V6, V4, V2}
{V5}
4
(V2, V5)
lowcost
0
0 0 0
3
0
adjvex
{V1, V3, V6, V4, V2, V5}
{}
lowcost
0
0 0 0 0
0
初始状态时,由于U={vi},则到V-U中各顶点的最小边,即为从依附于顶点v的各条边
中,找到一条权值最小的边(vi,v3)为生成树上的第一条边,同时将顶点v,并入集合U中。然后
修改辅助数组中的值,首先将 closedge[2].lowcost 改为0,表明顶点vs已并入U。由于边(V3, V2)上
的权值小于 closedge[1].lowcost,则需修改 closedge[1]为边(v3,vz)及其权值。同理修改 closedge[4]
和 closedge[5]。依次类推,直到 U = V。
2.克鲁斯卡尔算法
(1)克鲁斯卡尔算法的构造过程
假设连通网N=(V,E),将N中的边按权值从小到大的顺序排列。
① 初始状态为只有n个顶点而无边的非连通图T=(V,{}),图中每个顶点自成一个连通分量。
②在E中选择权值最小的边,若该边依附的顶点落在T中不同的连通分量上(即不形成回
路),则将此边加入到T中,否则舍去此边而选择下一条权值最小的边。
③重复②,直至7中所有顶点都在同一连通分量上为止。
例如,对图 6.19(a)所示的连通网G,图6.20所示为依照克鲁斯卡尔算法构造一棵最小生
成树的过程。权值分别为1、2、3、4的4条边由于满足上述条件,则先后被加入到T 中,权值
为5的两条边(v1,Va)和(v3, v4)被舍去。因为它们依附的两顶点在同一连通分量上,它们若加入 T
中,则会使T中产生回路,而下一条权值(=5)最小的边(v2,3)联结两个连通分量,则可加入 T。
由此,构造成一棵最小生成树。
V6
V
(b) (c)
3
4
s
V6
V₁
Va
(d)
图6.20 克鲁斯卡尔算法构造最小生成树的过程

Page 177
———┤第6章 图
可以看出,克鲁斯卡尔算法逐步增加生成树的边,与普里姆算法相比,可称为“加边法”。
与普里姆算法一样,每次选择最小边时,可能有多条同样权值的边可选,可以任选其一。
(2)克鲁斯卡尔算法的实现
算法的实现要引入以下辅助的数据结构。
① 结构体数组 Edge: 存储边的信息,包括边的两个顶点信息和权值。
//辅助数组 Edges 的定义
struct
{
VerTexType Head;
//边的始点
VerTexType Tail;
//边的终点
ArcType lowcost;
//边上的权值
}Edge[arcnum];
冰
糖
② Vexset[i]:标识各个顶点所属的连通分量。对每个顶点vEV,在辅助数组中存在一个相应元
素 Vexset[i]表示该顶点所在的连通分量。初始时 Vexset[i]=i,表示各顶点自成一个连通分量。
//辅助数组 Vexset 的定义
int Vexset [MVNum];
算法6.9 克鲁斯卡尔算法
【算法步骤】
①将数组 Edge 中的元素按权值从小到大排序。
②依次查看数组 Edge 中的边,循环执行以下操作:
依次从排好序的数组 Edge 中选出一条边(Uı,Uz);
在 Vexset 中分别查找vv2 所在的连通分量VS 和VS2,进行判断:英
如果 vs 和 VS2不等,表明所选的两个顶点分属不同的连通分量,输出此边,并合并
VS1和VS2 两个连通分量;
如果VS 和VS2 相等,表明所选的两个顶点属于同一个连通分量,舍去此边而选择下
一条权值最小的边。
【算法描述】
800
void MiniSpanTree_ Kruskal (AMGraph G)
{ //无向网G以邻接矩阵形式存储,构造G的最小生成树T,输出的各条边
Sort (Edge);
for(i=0;i<G.vexnum; ++i)
Vexset[i]=i;
for(i=0;i<G.arcnum; ++i)
{
v1=LocateVex(G,Edge[i].Head);
v2=LocateVex(G,Edge[i].Tail);
vs1=Vexset[v1];
vs2=Vexset[v2];
if (vsl!=vs2)
{
//将数组 Edge 中的元素按权值从小到大排序
//辅助数组,表示各顶点自成一个连通分量
//依次查看数组 Edge 中的边
//v1 为边的始点 Head 的下标
//v2 为边的终点Tail的下标
//获取边Edge[i]的始点所在的连通分量 vs1
//获取边 Edge[i]的终点所在的连通分量 vs2
//边的两个顶点分属不同的连通分量
cout<< Edge[i].Head << Edge[i].Tail;//输出此边
for(j=0;j<G.vexnum;++j)
//合并vs和vsz两个分量,即两个集合统一编号
if (Vexset[j]==vs2) Vexset[j]=vs1; //集合编号为vs2的都改为vs1
169

Page 178
170
数据结构(C语言版)(第2版)
}
【算法分析】
//if
//for
假若以第8章将介绍的“堆”来存放网中的边进行堆排序,对于包含条边的网,上述算法
排序时间是O(elogze)。在for循环中最耗时的操作是合并两个不同的连通分量,只要采取合适的
数据结构,可以证明其执行时间为O(logze),因此整个for循环的执行时间是O(elogze),由此,
克鲁斯卡尔算法的时间复杂度为O(elogze),与网中的边数有关,与普里姆算法相比,克鲁斯卡尔
算法更适合于求稀疏网的最小生成树。
6.6.2 最短路径
假若要在计算机上建立一个交通咨询系统,则可以采用图的结构来表示实际的交通网络。如
图6.21 所示,图中顶点表示城市,边表示城市间的交通联系。例如,一位旅客要从A城到B城,
他希望选择一条中转次数最少的路线。假设图中每一站都需要换车,则这个问题反映到图上就是
要找一条从顶点A到B所含边的数目最少的路径。只需从顶点A出发对图做广度优先搜索,
旦遇到顶点 B就终止。由此所得的广度优先生成树上,从根顶点A到顶点B的路径就是中转次
数最少的路径,路径上A与B之间的顶点数就是中转次数,但是,这只是一类最简单的图的最
短路径问题。有时,对于旅客来说,可能更关心的是节省交通费用;而对于司机来说,里程和
速度则是他们感兴趣的信息。为了在图上表示有关信息,可对边赋以权,权的值表示两城市间的
距离,或途中所需时间,或交通费用等。此时路径长度的度量就不再是路径上边的数目,而是路
径上边的权值之和。考虑到交通图的有向性,例如,汽车的上山和下山,轮船的顺水和逆水,所
花费的时间或代价就不相同,所以交通网往往是用带权有向网表示。在带有向网中,习惯上称
路径上的第一个顶点为源点(Source),最后一个顶点为终点(Destination)。
乌鲁木齐于星森和平西路
呼和浩特
1892
668
(北京)
704
1145
137
695
天津
西宁
216兰州
成都
676
511
西安
842
(沈阳)
(郑州)
534
武汉)
349
(徐州
367 南昌 622
674
651
上海
825
(大连)
967
409
1100
902
株州]
639 贵阳
昆明
672
675
607 【柳州
南宁 255
广州 140
(深圳)
图6.21 一个表示交通网的图
【福州
397
哈尔滨
242
长春
305

Page 179
———— 第6章图
本节主要讨论两种最常见的最短路径问题:一种是求从某个源点到其余各顶点的最短路径,
另一种是求每一对顶点之间的最短路径。
1. 从某个源点到其余各顶点的最短路径
本节将讨论单源点的最短路径问题:给定带权有向图G和源点vo,求从vo到G中其余各顶
点的最短路径。迪杰斯特拉(Dijkstra)提出了一个按路径长度递增的次序产生最短路径的算法,
称为迪杰斯特拉算法。
[]Q]²M = [NG
(1)迪杰斯特拉算法的求解过程
对于网N=(V,E),将N中的顶点分成两组:
第一组 S:已求出的最短路径的终点集合(初始时只包含源点vo)。“封中“个一下面入
第二组 V-S:尚未求出的最短路径的顶点集合(初始时为V-{vo})。是
算法将按各顶点vo间最短路径长度递增的次序,逐个将集合 V-S 中的顶点加入到集合S中
去。在这个过程中,总保持从vo到集合S中各顶点的路径长度始终不大于到集合V-S中各顶点
的路径长度。
这种求解方法能确保是正确的。因为,假设S为已求得最短路径的终点的集合,则可证明:
下一条最短路径(设其终点为x)或者是边(v,x),或者是中间只经过S中的顶点而最后到达顶点x
的路径。
这可用反证法来证明。假设此路径上有一个顶点不在 S 中,则
说明存在一条终点不在S而长度比此路径短的路径。但是,这是不
可能的。因为算法是按路径长度递增的次序来产生最短路径的,故
长度比此路径短的所有路径均已产生,它们的终点必定在 S 中,即
假设不成立。
Vs
100
60
30
10
10
20
3
50
例如,图 6.22 所示的带权有向图G中,从vo到其余各顶点之间的
最短路径如表 6.2 所示。
图6.22 带权有向图 Go
表6.2
有向图 Go 中从 vo到其余各点的最短路径
源点
终点
最短路径
路径长度
V2
(V0, V2)
10
V4
(V0, V4)
30
Vo
V3
V5
Vi
(V0, V4, V3)
(V0, V4, V3, V5)
无
50
60
∞
根据迪杰斯特拉算法的求解过程,首先求出vo到vz的路径(vo,vz),然后按路径长度递增的次
序依次得到 vova的路径(vo,V4),vo到vs的路径(Vo, V4,V3),vo到vs的路径(vo,V4,V3,Vs),而从 vo
到v没有路径。此情
(2)迪杰斯特拉算法的实现
假设用带权的邻接矩阵ares来表示带权有向网G,G.arcs[i][j]表示弧<v, V>上的权值。若<vi, V>
不存在,则置 Gares[i][j]为∞,源点为 VO
算法的实现要引入以下辅助的数据结构。
① 一维数组 S[i]:记录从源点vo到终点v是否已被确定最短路径长度,true表示确定,false
表示尚未确定。
171

Page 180
172
数据结构(C语言版)(第2版)
② 一维数组 Path[i]:记录从源点vo到终点v的当前最短路径上v的直接前驱顶点序号。其
初值为:如果从vo到v;有弧,则Path [i]为vo;否则为-1。
③ 一维数组 D[]:记录从源点vo到终点v的当前最短路径长度。其初值为:如果从vo 到 Vi
有弧,则 D[i]为弧上的权值;否则为∞。
显然,长度最短的一条最短路径必为(vo,ve),满足以下条件:
D[k] = Min{D[i]]V;EV-S}
求得顶点ve的最短路径后,将其加入到第一组顶点集S中。
每当加入一个新的顶点到顶点集S,对第二组剩余的各个顶点而言,多了一个“中转”顶点,
从而多了一个“中转”路径,所以要对第二组剩余的各个顶点的最短路径长度进行更新。
原来vo到v的最短路径长度为D[i],加进ve之后,以ve作为中间顶点的“中转”路径长度为:
D[k] + G.arcs[k][i],若D[k]+G.arcs[k][i]<D[i],则用 D[k]+Gares[k][i]取代 D[i]。
更新后,再选择数组D中值最小的顶点加入到第一组顶点集S中,如此进行下去,直到图中
所有顶点都加入到第一组顶点集S中为止。
算法6.10 迪杰斯特拉算法
【算法步骤】
① 初始化:
将源点 vo加到S中,即S[v0] = true;
将vo到各个终点的最短路径长度初始化为权值,即D[i] = Garcs[vo][vi], (vEV-S);
● 如果vo和顶点v之间有弧,则将v的前驱置为vo,即 Path[i] = vo,否则 Path[i] = -1。
② 循环n-1次,执行以下操作:
● 选择下一条最短路径的终点 vk,使得:
D[k] = Min{D[i]]VEV-S}
将ve加到S中,即 S[vx] = true;
根据条件更新从vo出发到集合 V-S 上任一顶点的最短路径的长度,若条件
D[k] + Gares [k][i]<D[i]成立,则更新 D[i] = D[k] + Garcs[k][i],同时更改v的前驱为
Ve; Path [i] = k。
【算法描述】
void ShortestPath_DIJ(AMGraph G, int v0)
{//用 Dijkstra算法求有向网Gv0顶点到其余顶点的最短路径
n=G.vexnum;
//n为G中顶点的个数
for(v=0;v<n;++v)
}
S[v]=false;
D[v]=G.arcs[v0][v];
if(D[v]<MaxInt) Path[v]=v0;
else Path[v]=-1;
s[v0]=true;
//n个顶点依次初始化
// 初始为空集
///将v0到各个终点的最短路径长度初始化为弧上的权值
//如果vo和v之间有弧,则将v的前驱置为v
//如果v0和v之间无弧,则将v的前驱置为1
//for
//将v0 加入S
[v0]=0;
//源点到源点的距离为0
/*--------初始化结束,开始主循环,每次求得v0到某个顶点v的最短路径,将v加到S集-
for(i=1;i<n;++i)
{
min=MaxInt;
for (w=0;w<n;++w)
//对其余n-1个顶点,依次进行计算

Page 181
第6章图
if(!S[w]&&[w]<min)
{v=w;min=D[w]; }
S[v]=true;
for(w=0;w<n;++w)
//选择一条当前的最短路径,终点为v
//将v加入s
//更新从vo出发到集合V-S上所有顶点的最短路径长度
if (!S[w]&&(D[v]+G.arcs[v][w]<D[w]))
{
D[w]=D[v]+G.arcs[v][w];
Path[w]=v;
}
}
//更新D[w]
//更改w的前驱为v
//if
//for
【例6.2】 利用算法6.10,对图6.22 所示的有向网G。求解最短路径,给出算法中各参量的
初始化结果和求解过程中的变化。
G的邻接矩阵如图6.23 所示。
∞ ∞ 10 ∞ 30 100
88
5.00 8
103 8 8 8 8
88
8 8 8 8 8
88888
50 ∞
8
8
160
8
8
20 ∞
8 ∞
8
图6.23G的邻接矩阵
(1)对图中6个顶点依次初始化,初始化结果如表6.3 所示。
表 6.3
迪杰斯特拉算法初始化结果
v=0
v=1
v=2
v=3
v=4
v=5
S
true
false
false
false
false
false
D
0
8
10
8
30
100
Path
-1
-1
0
-1
0
0
(2)求解过程中各参量的变化如表 6.4 所示。
表 6.4
终点
i = 1
8
迪杰斯特拉算法求解过程中各参量的变化
从vo到各终点的最短路径长度值和最短路径的求解过程
i=2
8
i=3
8
i=4
V₁
V2
10(vo, V2)
V3
8
60(Vo, V2, V3)
50(vo,V4,V3)
V4
30(vo, V4)
30(vo, V4)
V5
100(vo, vs)
100(vo, vs)
Vk
V2
V4
Path
Path[3] = 2
S[2] = true
S[4] = true
S
{vo, V2}
{vo, V2, V4}
60(V0, V4, V3, V5)
V5
Path[5] = 3
S[5] = true
{Vo, V2, V4, V3, V5}
如何从表 6.4 中读取源点vo到终点ve的最短路径?以顶点 k=5为例:
90(V0, V4, V5)
V3
Path[3] = 4
Path[5] = 4
S[3] = true
{Vo, V2, V4, V3}
Path[5] = 3→Path[3] = 4→Path[4] = 0
i=5
8
无
173

Page 182
数据结构(C语言版)(第2版)
反过来排列,得到路径0、4、3、5,这就是源点到终点vs的最短路径。
【算法分析】
算法 6.10 求解最短路径的主循环共进行n-1次,每次执行的时间是O(n),所以算法的时间
复杂度是O(㎡)。如果用带权的邻接表作为有向图的存储结构,则虽然修改D的时间可以减少,
但由于在D 向量中选择最小分量的时间不变,所以时间复杂度为O(n²)。
人们可能只希望找到从源点到某一个特定终点的最短路径,但是,这个问题和求源点到其他
所有顶点的最短路径一样复杂,也需要利用迪杰斯特拉算法来解决,其时间复杂度为O(n²)。
2.每一对顶点之间的最短路径
求解每一对顶点之间的最短路径有两种方法:其一是分别以图中的每个顶点为源点共调用 n
次迪杰斯特拉算法;其二是采用下面介绍的弗洛伊德(Floyd)算法。两种算法的时间复杂度均为
O(n²),但后者形式上较简单。
弗洛伊德算法仍然使用带权的邻接矩阵ares来表示有向网G,求从顶点v到v的最短路径。
算法的实现要引入以下辅助的数据结构。
(1)二维数组 Path[i][j]:最短路径上顶点v的前一顶点的序号。
(2)二维数组 D[i][j]:
记录顶点v和vy之间的最短路径长度。
算法6.11 弗洛伊德算法
【算法步骤】
将v到v的最短路径长度初始化,即 D[i][j] = G.arcs[i][j],然后进行n次比较和更新。
① 在v和v间加入顶点vo,比较(vivi)和(vivo,V)的路径长度,取其中较短者作为Vi
到 v 的中间顶点序号不大于0的最短路径。
三
② 在v和v间加入顶点vi,得到(via..., Vı)和(Vi,...,),其中(vi.,vı )是 v 到 vı 的且
中间顶点的序号不大于0的最短路径,(vi,...,vㄢ)是vi到vy的且中间顶点的序号不大于0的最短
路径,这两条路径已在上一步中求出。比较(vi,……,Vı,, )与上一步求出的v到v的中间顶点
序号不大于0的最短路径,取其中较短者作为vv的中间顶点序号不大于1的最短路径。
③ 依次类推,在v和v间加入顶点vk,若(Vi,...,ve)和(Ves...,v)分别是从v到va和从
Ve到 v的中间顶点的序号不大于k-1的最短路径,则将(vi,..., Yes,y)和已经得到的从v到
v且中间顶点序号不大于k-1的最短路径相比较,其长度较短者便是从v到v的中间顶点的序
号不大于k 的最短路径。这样,经过n次比较后,最后求得的必是从v到v的最短路径。按此
方法,可以同时求得各对顶点间的最短路径。
根据上述求解过程,图中的所有顶点v和v间的最短路径长度对应一个n阶方阵 D。在上
述n+1步中,D的值不断变化,对应一个n阶方阵序列。
n阶方阵序列可定义为:
其中,
D(E),D(0),D(1),……, D(),
D1
(n-1)
D()[i][j] = G.ares[i][j]
174
D*[i][j] = Min{D)[i][j],D)[][]+ D()[k][j]}
0≤k≤n-1
显然,D()[i][j]是从v 到 v 的中间顶点的序号不大于1的最短路径的长度;D“[i][j]是从v到
v的中间顶点的序号不大于k的最短路径的长度;D(-)[i][j]就是从v到v的最短路径的长度。
【算法描述】
void ShortestPath_Floyd (AMGraph G)

Page 183
第6章图
{//用Floyd算法求有向网G中各对顶点i和j之间的最短路径
for (i=0;i<G. vexnum; ++i)
for(j=0;j<G.vexnum; ++j)
{
}
D[i][j] G. arcs [i][j];
if (D[i][j] <MaxInt) Path[i][j]=i;
else Path[i][j]=-1;
for (k=0;k<G.vexnum; ++k)
for (i=0;i<G. vexnum; ++i)
for(j=0;j<G.vexnum; ++j)
if (D[i] [k] +D[k] [j] <D[i][j])
{
D[i][j]=D[i] [k] +D[k] [j];
Path [i][j]=Path[k] [j];
//各对结点之间初始已知路径及距离
//如果i和j之间有弧,则将j的前驱置为i
//如果i和j之间无弧,则将的前驱置为-1
//for
//从i经k到j的一条路径更短
//D[i][j]
//更改j的前驱为k
S
//if
Y並曲
【例6.3】 利用算法6.11,对图6.24所示有向网G,求解最短路径,给出每一对顶点之间的
最短路径及其路径长度在求解过程中的变化。
Gz的邻接矩阵如图6.25 所示。
6
5
3
8
0
1
2
3
3
0
1
8
4 0
8
0
9
2
1
3
5
0
8
2
8
8
6
0
3
9
4
0
1
图6.24 带权有向图G,
图6.25G,的邻接矩阵
每一对顶点i和j之间的最短路径Path[i][j]以及其路径长度D[i][j]在求解过程中的变化如
表6.5所示。
表 6.5
弗洛伊德算法求解过程中最短路径及其路径长度的变化
D(-1)
0
1
0
0
1
1
8 0
2
3
58
38
0
0
-1
11
0
1
-1
-1
2
2
2
3
-1
-1
13
-1
2
(0)
D
1
2 3
0
3
4270
89
104
80
42
066
38
8 O
8
Path()
0
28906F
Path)
3
27
0
-1
-1 0
1
-1 -1 1
2 0 -1 0
10
3.
ד||-|-||
012
-1
211
0
D(D)
1-
33
838
0
-1
3.
1
0
10
209
162
1
Path()
4 0 6
8
0 1
2 12 0
0
39
D(2)
0 1 2
10
4
0
0 1 1
10
10
Path(2)
1 2
3
3
19
26
16€
D(3)
0 1
2
3
0 1
9
3
11 0
8
2
3
4
0
6
0
9 10 6
0
Path(3)
3
0 1 2
3
-1 0 1 1
-1
0
-1 -1 1
1 2 -1 1
1 2 -1
3
3.
1
1
-1 -1 -1 3 -1 -1 -1
27
0 -1
1 2 0 -1 1 2
3
-1 2
0
13
-1 2
00
-1
1
3
-1
175

Page 184
数据结构(C语言版)(第2版)
如何从表 6.5 中读取两个顶点之间的最短路径?以Path(3)为例,对最短路径的读法加以说
明。从 D(3)知,顶点1到顶点2的最短路径长度为D[1][2]=8,其最短路径看 Path[1][2] = 3,表
明顶点2的前驱是顶点3;再看Path[1][3]=1,表明顶点3的前驱是顶点1。所以从顶点1到顶
点2的最短路径为<1,3>,<3,2>。
6.6.3 拓扑排序
1. AOV-网
一个无环的有向图称作有向无环图(Directed Acycline Graph),简称 DAG图。有向无环图是
描述一项工程或系统的进行过程的有效工具。通常把计划、施工过程、生产流程、程序流程等都
当成一个工程。除了很小的工程外,一般的工程都可分为若干个称做活动(Activity)的子工程,
而这些子工程之间,通常受着一定条件的约束,如其中某些子工程的开始必须在另一些子工程完
成之后。
例如,一个软件专业的学生必须学习一系列基本课程(见表6.6),其中有些课程是基础课,
独立于其他课程,如《高等数学》;而另一些课程必须在学完作为其基础的先修课程才能开始。比
如,在《程序设计基础》和《离散数学》学完之前就不能开始学习《数据结构》。这些先决条件定
义了课程之间的领先(优先)关系。这个关系可以用有向图更清楚地表示,如图6.26 所示。图中
顶点表示课程,有向弧表示先决条件。若课程是课程j的先决条件,则图中有弧<i,j>。
表 6.6
课程编号
软件专业的必修课及其关系
课程名称
先修课程
C₁
C2
程序设计基础
离散数学
无
C₁
C3
数据结构
Ci, C2
C4
汇编语言
C₁
Cs
高级语言程序设计
C3, C4
Co
计算机原理
CII
C₁
编译原理
C3, Cs
C8
操作系统
C3, Co
C9
高等数学
C10
线性代数
CII
普通物理
C12
数值分析
无
C9
C9
C1, C9, C10
176
这种用顶点表示活动,用弧表示活动间的优先关
系的有向图称为顶点表示活动的网(Activity On
Vertex Network),简称AOV-网。在网中,若从顶点
V到顶点v有一条有向路径,则v是v的前驱;v是
V;的后继。若<vi,v>是网中一条弧,则v是v的直接
前驱,v是v的直接后继。
在 AOV-网中,不应该出现有向环,因为存在环
意味着某项活动应以自己为先决条件。显然,这是荒
图6.26 表示课程之间优先关系的有向图

Page 185
第6章图
谬的。若设计出这样的流程图,工程便无法进行。而对程序的数据流图来说,则表明存在一个死
循环。因此,对给定的AOV-网应首先判定网中是否存在环。检测的办法是对有向图的顶点进行
拓扑排序,若网中所有顶点都在它的拓扑有序序列中,则该AOV-网中必定不存在环。
所谓拓扑排序就是将AOV-网中所有顶点排成一个线性序列,该序列满足:若在AOV-网中由
顶点v到顶点v有一条路径,则在该线性序列中的顶点v必定在顶点v,之前。
例如,图6.26所示的有向图有如下两个拓扑有序序列(当然,对此图也可构造出其他的拓扑
有序序列):
和
C1, C2, C3, C4, C5, C7, C9, C10, C11, C6, C12, C8
C9, C10, C11, C6, C1, C12, C4, C2, C3, C5, C7, C8
学生必须按照拓扑有序的顺序来安排学习计划,这样才能保证学习一门课程时其先修课程
已经学过。那么如何进行拓扑排序呢?
2. 拓扑排序的过程
(1)在有向图中选一个无前驱的顶点且输出它。
(2)从图中删除该顶点和所有以它为尾的弧。
(3)重复(1)和(2),直至不存在无前驱的顶点。
(4)若此时输出的顶点数小于有向图中的顶点数,则说明有向图中存在环,否则输出的顶点
序列即为一个拓扑序列。
以图 6.27(a)中所示的有向图为例,vivo没有前驱,则可任选一个。假设先输出 v6,在
删除 v% 及弧<v6, V4>,<V6,vs>之后,只有顶点v没有前驱,则输出vi且删去v及弧<vi, v2
<V1,V3>和<V1,V4>,之后vs和va都没有前驱。依次类推,可从中任选一个继续进行。整个拓扑排
序的过程如图6.27 所示。最后得到该有向图的拓扑有序序列为
V
V6, V1, V4, V3, V2, V5
玲
V₂
V₁
V₁
(a)AOV-网 (b)输出ve之后 (c)输出之后 (d)输出va之后 (e)输出vs之后
图6.27AOV-网及其拓扑有序序列产生的过程
3. 拓扑排序的实现
(f)输出vz之后
针对上述拓扑排序的过程,可采用邻接表做有向图的存储结构。
算法的实现要引入以下辅助的数据结构。
(1)一维数组 indegree[i]:存放各顶点入度,没有前驱的顶点就是入度为零的顶点。删除顶
点及以它为尾的弧的操作,可不必真正对图的存储结构进行改变,可用弧头顶点的入度减1的办
法来实现。
1.0.8
(2)栈S:暂存所有入度为零的顶点,这样可以避免重复扫描数组 indegree 检测入度为0的
顶点,提高算法的效率。
(3)一维数组 topo[i]:记录拓扑序列的顶点序号。
带
177

Page 186
数据结构(C语言版)(第2版)
算法 6.12 拓扑排序
【算法步骤】
① 求出各顶点的入度存入数组indegree[i]中,并将入度为0的顶点入栈。
② 只要栈不空,则重复以下操作:
将栈顶顶点v出栈并保存在拓扑序列数组 topo 中;
对顶点v的每个邻接点ve的入度减1,如果ve的入度变为0,则将ve入栈。
③ 如果输出顶点个数少于AOV-网的顶点个数,则网中存在有向环,无法进行拓扑排序,否
则拓扑排序成功。
【算法描述】
Status TopologicalSort (ALGraph G,int topo[])
{ //有向图G采用邻接表存储结构
//若G无回路,则生成G的一个拓扑序列topo[]并返回 OK,否则 ERROR
FindInDegree (G,indegree);
InitStack (S);
for(i=0;i<G.vexnum; ++i)
if(!indegree[i]) Push(Si);
m=0;
( while(!StackEmpty(S))
{
Pop (S, i);
topo[m]=i;
++m;
//求出各顶点的入度存入数组indegree 中
//栈S初始化为空
//人度为0者进栈
//对输出顶点计数,初始为0
//栈S非空
//将栈顶顶点v出栈
//将v保存在拓扑序列数组topo
中
}
p=G.vertices[i].firstarc;
while(p!=NULL)
{
k=p->adjvex;
//对输出顶点计数
//p指向vi的第一个邻接点
--indegree[k];
if(indegree[k]==0) Push (S,k);
p=p->nextarc;
}
}
if(m<G.vexnum) return ERROR;
else return OK;
//vk为V的邻接点
//v的每个邻接点的入度减1
//若入度减为0,则入栈
//p指向顶点vi下一个邻接结点
//while
//while
//该有向图有回路
【算法分析】
178
分析算法6.12,对有n个顶点和e条边的有向图而言,建立求各顶点入度的时间复杂度为O(e);
建立零入度顶点栈的时间复杂度为O(n);在拓扑排序过程中,若有向图无环,则每个顶点进一次
栈,出一次栈,入度减1的操作在循环中总共执行2次,所以,总的时间复杂度为O(n+ e)。
上述拓扑排序的算法亦是下面讨论的求关键路径算法的基础。
6.6.4 关键路径
1. AOE-网
与AOV-网相对应的是AOE-网(Activity On Edge),即以边表示活动的网。AOE-网是一个
带权的有向无环图,其中,顶点表示事件,弧表示活动,又表示活动持续的时间。通常,AOE-

Page 187
网可用来估算工程的完成时间。
第6章图
例如,图 6.28 所示为一个有11项活动的AOE-网。其中有9个事件vo, V1,...,vs,每个事件
表示在它之前的活动已经完成,在它之后的活动可以开始。例如,vo表示整个工程开始,vs 表
示整个工程结束,va表示aa和as已经完成,an和as可以
开始了。与每个活动相联系的数是执行该活动所需的时
间,比如,活动ap需要6天,an需要4天等非可
AOE-网在工程计划和经营管理中有广泛的应用,针对
实际的应用问题,通常需要解决以下两个问题:
a=6.
Vo
a₁=9
V6
910=2
VA
V8
a8-7
a-4
(1)估算完成整项工程至少需要多少时间;
a6=2
V3
图 6.28
一个 AOE-网
(2)判断哪些活动是影响工程进度的关键。即查双
工程进度控制的关键在于抓住关键活动。在一定范围内,非关键活动的提前完成对于整个工
程的进度没有直接的好处,它的稍许拖延也不会影响整个工程的进度。工程的指挥者可以把非关
键活动的人力和物力资源暂时调给关键活动,加速其进展速度,以使整个工程提前完工。
由于整个工程只有一个开始点和一个完成点,故在正常的情况(无环)下,网中只有一个入度
为零的点,称作源点,也只有一个出度为零的点,称作汇点。在AOE-网中,一条路径各弧上的权
值之和称为该路径的带权路径长度(后面简称路径长度)。要估算整项工程完成的最短时间,就是
要找一条从源点到汇点的带权路径长度最长的路径,称为关键路径(Critical Path)。关键路径上的
活动叫做关键活动,这些活动是影响工程进度的关键,它们的提前或拖延将使整个工程提前或拖延。
例如,在图 6.28中,vo是源点,vs是汇点,关键路径有两条:(vo, Vi,V4, V6,V8)或(Vo,V1,V4, V7, V8),
长度均为18。关键活动为(a1,a4,97, 10)或(a1,a4, as, a11)。比如,关键活动ap需要6天完成,如果
aq 提前1天,整个工程也可以提前1天完成。所以不论是估算工期,还是研究如何加快工程进度,
主要问题就在于要找到AOE-网的关键路径。
0-(0)9v
如何确定关键路径,首先定义4个描述量。
(1)事件vi的最早发生时间ve(i)
@+ (0pv}xsM = (Nav
= {cow + (0)ev}zsM = (Sov
进入事件 vi的每一活动都结束,v才可发生,所以ve(i)是从源点到v的最长路径长度。
求ve(i)的值,可根据拓扑顺序从源点开始向汇点递推。通常将工程的开始顶点事件vo的最早
发生时间定义为0,即
ve(0) = 0
at=4ave + (P)avlxeM =(djav
ve(i) = Max {ve(k) + Wk, i} <Vk, VET, 1≤i≤n-1
by
其中,T是所有以v;为头的弧的集合,Wki是弧<vv>的权值,即对应活动<V,V>的持续时间。
(2)事件v的最迟发生时间va(i)
事件v的发生不得延误v的每一后继事件的最迟发生时间。为了不拖延工期,v的最迟发生
时间不得迟于其后继事件ve的最迟发生时间减去活动<vi,v>的持续时间。 1=(V)]v
求出 ve(i)后,可根据逆拓扑顺序从汇点开始向源点递推,求出vl(i).SM(C)lv
vl(n-1)= ve(n-1)
vl(i) = Min{vl(k)-wi, k} <Vi,v>ES,0≤i<n-2MM(拉
其中,S是所有以v为尾的弧的集合,wit是弧<vi, vi>的权值。
(3)活动 ai = <v, vi>的最早开始时间 e(i)
(lv}niM = (Elv
-(1)\him- (91
只有事件 v发生了,活动a才能开始。所以,活动a的最早开始时间等于事件 v 的最早发
生时间 ve(j),即
179

Page 188
180
数据结构(C语言版)(第2版)
e(i) = ve(j)
(4)活动ai=<vi, vi>的最晚开始时间 (i)
活动 a的开始时间需保证不延误事件ve的最迟发生时间。所以活动a的最晚开始时间(i)等
于事件ve 的最迟发生时间vi(k)减去活动a的持续时间 Wik,即:
l(i) = vl(k) - wj, k
显然,对于关键活动而言,e(i)=l(i)。对于非关键活动,l(i)-e(i)的值是该工程的期限余量,
在此范围内的适度延误不会影响整个工程的工期。
一个活动a的最迟开始时间(i)和其最早开始时间e(i)的差值(i)-e(i)是该活动完成的时间余
量。它是在不增加完成整个工程所需的总时间的情况下,活动a可以拖延的时间。当一活动的时
间余量为零时,说明该活动必须如期完成,否则就会拖延整个工程的进度。所以称l(i)-e(i) = 0,
即l(i) =e(i)时的活动a是关键活动。
2. 关键路径求解的过程
(1)对图中顶点进行排序,在排序过程中按拓扑序列求出每个事件的最早发生时间ve(i)。
(2)按逆拓扑序列求出每个事件的最迟发生时间 vl(i)。
(3)求出每个活动a的最早开始时间 e(i)。
(4)求出每个活动a的最晚开始时间(i)。
(5)找出e(i)=I(i)的活动a,即为关键活动。由关键活动形成的由源点到汇点的每一条路径
就是关键路径,关键路径有可能不止一条。
【例6.4】 对图6.28所示的AOE-网,计算关键路径。
计算过程如下。
(1)计算各顶点事件v的最早发生时间ve(i)。
ve(0) = 0
ve(1) = Max{ve(0) + wo,1} = 6
ve(2) = Max{ve(0) + wo,z} = 4
ve(3) = Max{ve(0) + Wo,3} = 5
ve(4) = Max{ve(1)+w1,4,ve (2) + W2,4} = 7
ve(5) = Max{ve(3) + w3s}=7
ve(6) = Max{ve(4) + w4,6}=16
ve(7) = Max{ve(4)+w4,7,ve(5) + W5,7} = 14
ve(8) = Max{ve(6) + w6.8,ve(7) + w7,8} = 18
(2)计算各顶点事件v的最迟发生时间vl(i)。
vl(8) =ve(8) = 18
vl(7) = Min{vl(8)-w7,8}= = 14
vl(6) = Min{vl(8)-W6,8} = 16
vl(5) = Min{vl(7)-w5,7} = 10
vl(4) = Min{vl(6)-W46,v1(7)-W4,7} = 7
vl(3) = Min{vl(5)-W3,5} = 8
vl(2) = Min{vl(4)-W2,4}=6
vl(1) = Min{vl(4)-W1,4}=6
vl(0)=Min{vl(1) – Wo,1, vl(2) – Wo,2, vl(3) – Wo,3} =0

Page 189
(3)计算各活动a的最早开始时间 e(i)。
e(aı) = ve(0) = 0
e(az) = ve(0) = 0
e(a3) = ve(0) = 0
e(a) = ve(1) = 6
e(as) = ve(2) = 4
e(a) = ve(3) = 5
e(a) = ve(4) = 7
e(as) = ve(4) = 7
e(a) = ve (5) = 7
e(a10) = ve(6) = 16
e(an) = ve(7) = 14
(4)计算各活动的最迟开始时间(i)。
1(an)=vl(8)-W7,8=
= 14
1(a10)=vl(8)-W6.8=16
1(a) =vl(7)-W5,7 = = 10
l(a8) = vl(7)-W4,7 =70(世界觀,或刻套
1(a)=vl(6)-W4.6= 7
1(a) =vl(5)-W3.5 = 8
y = 10
品关
第6章 图
1(as) =vl(4)-W2,4= 6
1(a)=vl(4)-W1,4=6
l(a3) = vl(3)-W0,3
= 3
l(a2)=vl(2)-W0.2 = 2
l(an) = vl(1) - wo,1=0个新固姐,克海带个不回
上
将顶点的发生时间和活动的开始时间分别分别汇总为表6.7(a)和表6.7(b)。由表 6.7
(b)可以看出,图6.28所示的AOE-网有两条关键路径:一条是由活动(a1,a4,a7, 10)组成的关
键路径,另一条是由(a1,a4,as, a11)组成的关键路径,如图 6.29 所示。
表 6.7
图 6.28 所示网的关键路径求解的中间结果
(a)顶点的发生时间
(b)活动的开始时间
顶点讠
ve(i)
(i)
dgisws
活动 ai
e(i)
l(i)
l(i)-e(i)
0
0
0
an
0
0
0
1
6
6
a2
0
2
2
2
4
6
a3
0
3
3
3
5
8
6
6
0
4
7
7
as
4
6
2
5
7
10
a6
5
8
3
6
16
16
a7
7
7
0
7
14
14
as
7
7
0
8
18
18
a9
7
10
3
a10
16
16
0
all
14
14
0
181

Page 190
数据结构(C语言版)(第2版)
3. 关键路径算法的实现
由于每个事件的最早发生时间 ve(i)和最迟发生时间
vl(i)要在拓扑序列的基础上进行计算,所以关键路径算法
的实现要基于拓扑排序算法,我们仍采用邻接表做有向图
的存储结构。
算法的实现要引入以下辅助的数据结构。
(1)一维数组 ve[i]:事件v的最早发生时间。
(2)一维数组 vl[i]:事件v的最迟发生时间。
(3)一维数组 topo[i]:记录拓扑序列的顶点序号。
算法6.13 关键路径算法
【算法步骤】
① 调用拓扑排序算法,使拓扑序列保存在 topo中。
V6
a10
a4
a7.
a.
V8
o
as
all
V₁₂
图6.29图6.28所示网的关键路径
(chy = (ps)
ajax = (e(s)9
奭而書
②将每个事件的最早发生时间 ve[i]初始化为0,ve[i]=0。
根据 topo 中的值,按从前向后的拓扑次序,依次求每个事件的最早发生时间,循环几次,
执行以下操作:
取得拓扑序列中的顶点序号k,k=topo[i];
01
用指针p依次指向k的每个邻接顶点,取得每个邻接顶点的序号j=p->adjvex,依次
更新顶点j的最早发生时间 ve[j]
if(ve[j]<ve[k] + p->weight) ve[j] = ve[k] + p->weight;
将每个事件的最迟发生时间 vl[i]初始化为汇点的最早发生时间,vl[i] = ve[n-1]。 (5)
⑤ 根据 topo 中的值,按从后向前的逆拓扑次序,依次求每个事件的最迟发生时间, 循环n
次,执行以下操作:
● 取得拓扑序列中的顶点序号 kk=topo[];
(S)lv = (ss)
● 用指针p依次指向k的每个邻接顶点,取得每个邻接顶点的序号j=p->adjvex,依次
根据k的邻接点,更新 k的最迟发生时间 vl[k]
if(vl[k]>vl[j]-p->weight) vl[k] = vl[j]-p->weight; 80.04
⑥ 判断某一活动是否为关键活动,循环n次,执行以下操作:对于每个顶点,用指针p依
次指向i的每个邻接顶点,取得每个邻接顶点的序号j=p->adjvex,分别计算活动<vi,v>的最早
和最迟开始时间 e和 Z,
e = ve[i]; 1 = vl[j]-p->weight;
如果e和Z相等,则活动<vi,v>为关键活动,输出弧<vi, V>。
【算法描述】
Status Critical Path (ALGraph G)
{//G为邻接表存储的有向网,输出G的各项关键活动
if (!TopologicalOrder (G,topo)) return ERROR;
//调用拓扑排序算法,使拓扑序列保存在topo中,若调用失败,则存在有向环,返回ERROR
n=G.vexnum;
for(i=0;i<n;i++)
//n为顶点个数
//给每个事件的最早发生时间置初值 0
/* -
ve[i]=0;
按拓扑次序求每个事件的最早发生时间
for(i=0;i<n;i++)
{
182

Page 191
k=topo[i];
p=G.vertices[k].firstarc;
while(p!=NULL)
{
j=p->adjvex;
if(ve[j]<ve[k]+p->weight)
ve[j]=ve[k]+p->weight;
p=p->nextarc;
for(i=0;i<n;i++)
//取得拓扑序列中的顶点序号 k
//p指向k 的第一个邻接顶点
第6章图
依次更新k的所有邻接顶点的最早发生时间
//j为邻接顶点的序号
//更新顶点j的最早发生时间ve[j]
空调六
//p指向k的下一个邻接顶点
//while
//for
//给每个事件的最迟发生时间置初值ve[n-1]
vl[i]=ve[n-1];
/*- -
-按逆拓扑次序求每个事件的最迟发生时间-
1005
for(i=n-1;i>=0;i--)
{
k=topo[i];
p=G.vertices[k].firstarc;
while(p!=NULL)
{
j=p->adjvex;
}
/*- - -
if(vl[k]>vl[j]-p->weight)
vl[k]=vl[j]-p->weight;
p=p->nextarc;
//取得拓扑序列中的顶点序号 k
//p指向k 的第一个邻接顶点
//根据k的邻接点,更新k的最迟发生时间
//j为邻接顶点的序号
//更新顶点k的最迟发生时间v1[k]
//p 指向k 的下一个邻接顶点
//while
//for源
-判断每一活动是否为关键活动-
for(i=0;i<n;i++)//每次循环针对v为活动开始点的所有活动
p=G.vertices[i].firstarc;
f while(p!=NULL),鍵
{
j=p->adjvex;
e=vel
1=vl[j]-p->weight;
if(e==1)回兰素需
//p指向 i的第一个邻接顶点
//ji的邻接顶点的序号
//计算活动<vivy>的最早开始时间
//计算活动<vvg>的最迟开始时间
//若为关键活动,则输出<vi, vj>
cout<<G.vertices[i].data <<G.vertices[j].data;
人升歌
p=p->nextarc;
} //while
}
【算法分析】
//p指向i的下一个邻接顶点
燦
//for
-*/
-*/
在算法 6.13 中,在求每个事件的最早和最迟发生时间,以及活动的最早和最迟开始时间时,都要
对所有顶点及每个顶点边表中所有的边结点进行检查,由此,求关键路径算法的时间复杂度为O(n+e)。
实践已经证明:用AOE-网来估算某些工程完成的时间是非常有用的。实际上,求关键路径
的方法本身最初就是与维修和建造工程一起发展的。但是,由于网中各项活动是互相牵涉的,因
此,影响关键活动的因素亦是多方面的,任何一项活动持续时间的改变都可能引起关键路径的改
变。所以,当子工程在进行过程中持续时间有所调整时,就要重新计算关键路径。另外,若网中
有几条关键路径,那么,单是提高一条关键路径上关键活动的速度,还不能导致整个工程缩短工
183

Page 192
数据结构(C语言版)(第2版)
期,而必须同时提高在几条关键路径上的活动速度。
6.7 案例分析与实现
184
案例 6.1:六度空间理论。
【案例分析】
在六度空间理论提出之后的30多年的时间里,社会学家试图证明(或否定)此假设的正确性,
但是该理论从来没有得到过严谨的证明,虽然屡屡应验,但它只是一种假说。很多社会学家主持
的验证研究,都使用了网络时代的新型通信手段——E-mail。
比较著名的实验是2001年哥伦比亚大学社会学系的登肯·瓦兹主持的一项验证工程。166个
不同国家的六万多名志愿者参加了该项研究。瓦兹随机选定18名目标(比如一名美国的教授、
一名澳大利亚警察和一名挪威兽医等),要求志愿者选择其中的一名作为自己的目标,并发送电
子邮件给自己认为最有可能发送邮件给目标的亲友。研究取得了较好的验证成果,瓦兹在世界
最顶级的科学学术期刊《科学》杂志上发表了论文,表明邮件要达到目标,平均也只要经历5~
7个人左右。
但实际上,这种研究方式有很大的局限性和困难。第一,使用E-mail保持社会关系的人群是
有限的;第二,要记录和跟踪所有 E-mail 的走向是一项巨大的工程,需要大量的人力和较长的时
间;第三,验证过程与志愿者的意愿紧密相关,志愿者可能会遗漏某些相识的人。
现代人使用电话和短信进行联络的频率远远大于使用E-mail的频率。由于电话和短信的通
信都有一个运营商,与 E-mail 的通信相比,更便于跟踪。为了排除部分广告电话和广告短信,
我们可以假设任意两个人在一年内,电话或短信相互收发两次以上即定义为两人“认识”,这样
便很容易根据电话或短信的通信信息确定两人是否存在“认识”的关系。但在实际操作中,由
于通信数据保密的原因,我们无法获取实际的通信数据,所以我们只能从理论上介绍并分析验
证的方法。
我们把六度空间理论中的人际关系网络图抽象成一个不带权值的无向图G,用图G中的一
个顶点表示一个人,两个人“认识”与否,用代表这两个人的顶点之间是否有一条边来表示。
这样六度空间理论问题便可描述为:在图G中,任意两个顶点之间都存在一条路径长度不超过
7的路径。
在实际验证过程中,可以通过测试满足要求的数据达到一定的百分比(比如99.5%)来进行
验证。这样我们便把待验证六度空间理论问题描述为:在图G中,任意一个顶点到其余99.5%以
上的顶点都存在一条路径长度不超过7的路径。
比较简单的一种验证方案是:利用广度优先搜索方法,对任意一个顶点,通过对图G的“7层”
遍历,就可以统计出所有路径长度不超过7的顶点数,从而得到这些顶点在所有顶点中的所占比例。
【案例实现】回
款大集
算法6.14 六度空间理论的验证
【算法步骤】
① 完成系列初始化工作:设变量 Visit_Num 用来记录路径长度不超过7的顶点个数,初值为
0;Start 为指定的一个起始顶点,置visited[Start]的值为true,即将 Start 标记为六度顶点的始点;
辅助队列Q初始化为空,然后将 Start 进队。