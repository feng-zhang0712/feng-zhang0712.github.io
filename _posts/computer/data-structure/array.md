Page 95
第4章
串、数组和广义表
计算机上的非数值处理的对象大部分是字符串数据,字符串一般简称为串串是一种特殊的
线性表,其特殊性体现在数据元素是一个字符,也就是说,串是一种内容受限的线性表。由于现
今使用的计算机硬件结构是面向数值计算的需要而设计的,在处理字符串数据时比处理整数和浮
点数要复杂得多。而且,在不同类型的应用中,所处理的字符串具有不同的特点,要有效地实现
字符串的处理,就必须根据具体情况使用合适的存储结构。本章的第一部分主要讨论串的定义、
存储结构和基本操作,重点讨论串的模式匹配算法,ddded AMG拍?患,與您顷
本章后两部分讨论的多维数组和广义表可以看成是线性表的一种扩充,即线性表的数据元
素自身又是一个数据结构。高级语言都支持数组,但在高级语言中,重点介绍数组的使用,而
本章重点介绍数组的内部实现,并介绍对于一些特殊的二维数组如何实现压缩存储。最后介绍
广义表的基本概念和存储结构。
查辭示
4.1 串的定义罢
中文人解示限割彣
串(string)(或字符串)是由零个或多个字符组成的有限序列,一般记为
s="a₁ a₂an" (n≥0)
个三常谷
其中,s是串的名,用双引号括起来的字符序列是串的值; a(1≤i≤n)可以是字母、数字
或其他字符串中字符的数目n称为串的长度。零个字符串称为空串(null string),其长
度为零。
sdddesdd
串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常
称字符在序列中的序号为该字符串中的位置。子串在主串中的位置则以子串的第一个字符在主
串中的位置来表示。
例如,假设 a、b、c、d为如下的4个串:
a=“BEI”,b=“JING”
905
c=“BEIJING”, d⇐“BEI JING”
则它们的长度分别为3、4、7和8;并且a和b都是cd的子串,ac和d中的位置都是1,
而b在c中的位置是4,在d中的位置则是5。
称两个串是相等的,当且仅当这两个串的值相等。也就是说,只有当两个串的长度相等,
并且各个对应位置的字符都相等时才相等。例如,上例中的串a、b、c和d彼此都不相等。
在各种应用中,空格常常是串的字符集合中的一个元素;因而可以出现在其他字符中间。由
87

Page 96
数据结构(C语言版)(第2版)
"
一个或多个空格组成的串“ 称为空格串(blank string, 请注意:此处不是空串),其长度为串
中空格字符的个数。为了清楚起见,以后我们用符号“ ”来表示“空串”。
4.2 案例引入
字符串在实际中有极为广泛的应用,在文字编辑、信息检索、语言编译等软件系统中,字符
串均是重要的操作对象;在网络入侵检测、计算机病毒特征码匹配以及DNA序列匹配等应用中,
都需要进行串匹配,也称模式匹配。
案例4.1:病毒感染检测。
医学研究者最近发现了某些新病毒,通过对这些病毒的分析,得知它们的DNA 序列都是环
状的。现在研究者已收集了大量的病毒DNA和人的DNA数据,想快速检测出这些人是否感染了
相应的病毒。为了方便研究,研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串
序列,然后检测某种病毒DNA序列是否在患者的DNA序列中出现过,如果出现过,则此人感染
该病毒,否则没有感染。例如,假设病毒的DNA序列为baa,患者1的DNA序列为 aaabbba,
则感染,患者2的DNA序列为babbba,则未感染。(注意,人的DNA序列是线性的,而病毒的
DNA序列是环状的)
研究者将待检测的数据保存在一个文本文件中,文件格式和内容规定如下(图4.1 截取了部
分数据)。
文件有 num+1行,第一行有一个整数num,表示有 num 个待检测的任务(num<=300)。
接下来每行i(2<=i<=num+1)对应一个任务,每行有两个数据,用空格分隔,第一个数据表
示病毒的DNA序列(长度<=6000),第二个数据表示人的DNA序列(长度<=10000)。
要求将检测结果输出到文件中,文件中包括 num行,每行有三个数据,用空格分隔,前两个
数据分别表示输入文件中对应病毒的DNA序列人的DNA序列,如果该人感染了对应的病毒,该
行第三个数据则为“YES”,否则为“NO”。图4.1数据对应的输出结果如图4.2所示。
|病毒感染检测输入数据.txt-记事本)
文件(F)编辑(E) 格式(O) 查看(V)
10
baa
bbaabbba
baa
aaabbbba
Aaabb
abceaabb
aabb
abaabcea
abcd
cdabbbab
abcd
cabbbbab
abcde
bcdedbda
acc
bdedbcda
cde
cdcdcdec
cced
cdccdcce
病毒感染检测输出结果.txt-记事本
文件(F) 编辑(E) 格式(O) 查看(V) 帮
,中其
baa
bbaabbba
YES
baa
aaabbbba
YES
aabb
abceaabb
YES
aabb
abaabcea
YES
abcd
cdabbbab
YES
abcd
cabbbbab
NO
abcde
bcdedbda
NO
acc
bdedbcda
NO
cde
cdcdcdec
YES
cced
cdccdcce
YES
图4.2 病毒感染检测输出结果
图4.1 病毒感染检测输入数据
这个案例中要处理的操作对象便是字符串,将病毒的DNA序列看作是子串,患者的 DNA序
列看作是主串,检测任务的实质就是看子串是否在主串中出现过,即4.3.3小节讨论的字符串的模
式匹配算法。但因为此案例中病毒的DNA序列是环状的,这样需要对传统模式匹配算法进行改
进。案例的具体分析与实现将在4.6节给出。
88
88

Page 97
第4章串、数组和广义表
4.3 串的类型定义、存储结构及其运算
4.3.1 串的抽象类型定义
串的逻辑结构和线性表极为相似,区别仅在于串的数据对象约束为字符集。然而,串的
基本操作和线性表有很大差别。在线性表的基本操作中,大多以“单个元素”作为操作对象,
例如,在线性表中查找某个元素,求取某个元素,在某个位置上插入一个元素或删除一个元
素等;而在串的基本操作中,通常以“串的整体”作为操作对象,例如,在串中查找某个子
串,求取一个子串,在串的某个位置上插入一个子串,以及删除一个子串等。
串的抽象数据类型的定义如下:
ADT String{
数据对象:D={aila ∈CharacterSet,i=1,2,…,n,n≥0}
数据关系:R1={<ai-yai>|ai-lvai∈D,i=2,…,n}
基本操作:1舊址都为味制糖
StrAssign(&T, chars)
初始条件:chars是字符串常量。
操作结果:生成一个其值等于 chars的串T
StrCopy(&T,S)
初始条件:串存在。
操作结果:由串s 复制得串T。
StrEmpty (S)
初始条件:串s存在。
鞏固
操作结果:若S为空串,则返回true,否则返回false。
StrCompare (S,T)
初始条件:串s 和T存在。
操作结果:若S>T,则返回值>0;若S=T,则返回值=0;若<T,则返回值<0。
StrLength (S)
初始条件:串存在。
操作结果:返回S的元素个数,称为串的长度。
ClearString(&S)
初始条件:串s存在。
操作结果:将S清为空串。
Concat(&T, S1,S2)
初始条件:串 S1 和S2 存在。
操作结果:用T返回S1和2联接而成的新串。
SubString (& Sub, S, pos, len)
初始条件:串s存在,1≤pos=StrLength(S) 0≤len≤ StrLength(S)-pos+1。
操作结果:用Sub 返回串的第pos 个字符起长度为len 的子串。
Index (S, T, pos)
初始条件:串S和T存在,是非空串,1≤pos≤StrLength(S)。
操作结果:若主串s中存在和串值相同的子串,则返回主串中第pos 个字符之后第一次出现的位
置;否则函数值为0。
Replace(&S,T,V)
89

Page 98
数据结构(C语言版)(第2版)
初始条件:串s,T和V存在,T是非空串。
操作结果:用v替换主串中出现的所有与T相等的不重叠的子串。
StrInsert(&S,pos,T)
不重盡的水油串
初始条件:串s和T存在,1≤pos=StrLength(S)+1。
操作结果:在串的第pos 个字符之前插入串T。
StrDelete (&S, pos, len)
初始条件:串存在,1≤pos≤StrLength(S)-len+1。
操作结果:从串s中删除第pos 个字符起长度为len 的子串。
DestroyString(&S)
初始条件:串s存在。
操作结果:串s 被销毁。
}ADT String
对于串的基本操作集可以有不同的定义方法,读者在使用高级程序设计语言中的串类型时,
应该语言的参考手册为准。
4.3.2 串的存储结构
与线性表类似,串也有两种基本存储结构:顺序存储和链式存储。但考虑到存储效率和算法
的方便性,串多采用顺序存储结构。
1. 串的顺序存储
类似于线性表的顺序存储结构,用一组地址连续的存储单元存储串值的字符序列。按照预
定义的大小,为每个定义的变量分配一个固定长度的存储区,则可用定长数组如下描述:
//- - - - - 串的定长顺序存储结构-
#define MAXLEN 255
//串的最大长度
typedef struct {
char ch [MAXLEN+1];
//存储串的一维数组
int length;
}SString;
//串的当前长度
90
90
其中,MAXLEN 表示串的最大长度,ch是存储字符串的一维数组,每个分量存储一个字符,length
表示字符串的当前长度。为了便于说明问题,本章后面算法描述当中所用到的顺序存储的字符
串都是从下标为1的数组分量开始存储的,下标为0的分量闲置不用。
这种定义方式是静态的,在编译时刻就确定了串空间的大小。而多数情况下,串的操作是
以串的整体形式参与的,串变量之间的长度相差较大,在操作中串值长度的变化也较大,这样
为串变量设定固定大小的空间不尽合理。因此最好是根据实际需要,在程序执行过程中动态地
分配和释放字符数组空间。在C语言中,存在一个称之为“堆”(Heap)的自由存储区,可以
为每个新产生的串动态分配一块实际串长所需的存储空间,若分配成功,则返回一个指向起始
地址的指针,作为串的基址,同时为了以后处理方便,约定串长也作为存储结构的一部分。这
种字符串的存储方式也称为串的堆式顺序存储结构,定义如下:
//- - - - - 串的堆式顺序存储结构-
typedef struct {
char *ch;
int length;
}HString;
//若是非空串,则按串长分配存储区,否则 ch 为 NULL
//串的当前长度

Page 99
2.串的链式存储
第4章串、数组和广义表
顺序串的插入和删除操作不方便,需要移动大量的字符。因此,可采用单链表方式存储串。由
于串结构的特殊性——结构中的每个数据元素是一个字符,则在用链表存储串值时,存在一个“结
点大小”的问题,即每个结点可以存放一个字符,也可以存放多个字符。例如,图4.3(a)所示为
结点大小为4(即每个结点存放4个字符)的链表,图4.3(b)所示为结点大小为1的链表。当结
点大小大于1时,由于串长不一定是结点大小的整倍数,则链表中的最后一个结点不一定全被串值
占满,此时通常补上“#”或其他的非串值字符(通常“#”不属于串的字符集,是一个特殊的符号)。
head
B CD
E F G H
(a)结点大小为4的链表
head
A
B
I
I
# # # A
(b)结点大小为1的链表
图4.3 串值的链表存储方式
为了便于进行串的操作,当以链表存储串值时,除头指针外,还可附设一个尾指针指示链
表中的最后一个结点,并给出当前串的长度。称如此定义的串存储结构为块链结构,说明如下:
//--- - - - 串的链式存储结构---
☐☐ #define CHUNKSIZE 80
typedef struct Chunk{
char ch[CHUNKSIZE];
struct Chunk *next;
}Chunk;
typedef struct {
//可由用户定义的块大小
10回,也始不
18 band
Chunk *head, *tail;
//串的头和尾指针
int length;
//串的当前长度
}LString;
在链式存储方式中,结点大小的选择直接影响着串处理的效率。在各种串的处理系统中,所
处理的串往往很长或很多,如一本书的几百万个字符,情报资料的成千上万个条目,这就要求考
串值的存储密度。
显然,存储密度小(如结点大小为1时),运算处理方便,然而,存储占用量大。如果在串处
理过程中需进行内、外存交换的话,则会因为内、外存交换操作过多而影响处理的总效率。应该
看到,串的字符集的大小也是一个重要因素。一般来说,字符集小,则字符的机内编码就短,这
也影响串值存储方式的选取。
串值的链式存储结构对某些串操作,如联接操作等,有一定方便之处,但总地说来,不如顺
序存储结构灵活,它占用存储量大且操作复杂。此外,串值在链式存储结构时,串操作的实现和
线性表在链表存储结构中的操作类似,故在此不作详细讨论。下面4.3.3 小节的模式匹配算法是采
用串的定长顺序存储结构实现的。
4.3.3 串的模式匹配算法
1
子串的定位运算通常称为串的模式匹配或串匹配。此运算的应用非常广泛,比如在搜索引擎、
91

Page 100
92
数据结构(C语言版)(第2版)
拼写检查、语言翻译、数据压缩等应用中,都需要进行串匹配。
串的模式匹配设有两个字符串S和T,设S为主串,也称正文串;设为子串,也称为模式。
在主串S中查找与模式相匹配的子串,如果匹配成功,确定相匹配的子串中的第一个字符在主
串S中出现的位置。
著名的模式匹配算法有BF算法和KMP算法,下面详细介绍这两种算法。
1. BF算法
最简单直观的模式匹配算法是BF(Brute-Force)算法。
算法 4.1 BF算法
模式匹配不一定是从主串的第一个位置开始,可以指定主串中查找的起始位置 pos。如果采
用字符串顺序存储结构,可以写出不依赖于其他串操作的匹配算法。
【算法步骤】
① 分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置,初值为pos,
j初值为1。
② 如果两个串均未比较到串尾,即i和j均分别小于等于S和T的长度时,则循环执行以下
操作:
S[i].ch 和 T[j].ch 比较,若相等,则和j分别指示串中下个位置,继续比较后续字符;
若不等,指针后退重新开始匹配,从主串的下一个字符(i=i-j+2)起再重新和模式的
第一个字符(j=1)比较。
③ 如果j> T.length,说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等,
则匹配成功,返回和模式T中第一个字符相等的字符串S中的序号(i-T.length);否则称匹配
不成功,返回0。
【算法描述】
int Index_BF (SString S, SString T, int pos)
{ //返回模式在主串s中第pos 个字符开始第一次出现的位置。若不存在,则返回值为0
//其中,T非空,1≤pos≤S.length
i=pos; j=1;
while(i<=S.length && j<=T.length)
{
if(S[i].ch==T[j].ch){++1;++j;}
else{i=i-j+2;j=1;}
if(j>T.length) return i-T.length;
else return 0;
//初始化
//两个串均未比较到串尾
//继续比较后继字符
//指针后退重新开始匹配
//匹配成功
//匹配失败
图4.4展示了模式T=“abcac”和主串S的匹配过程(pos= 1)。
【算法分析】
BF算法的匹配过程易于理解,且在某些应用场合效率也较高。在匹配成功的情况下,考虑以
下两种极端情况。
(1)最好情况下,每趟不成功的匹配都发生在模式串的第一个字符与主串中相应字符的比较。
例如:
S=“aaaaaba”
T=“ba”

Page 101
第一趟匹配
Me
i=3
a bab ca bcacbab
abc
↑ j=3
↓i=2
第二趟匹配
a babc abcacbab
a
tj-1
tj=110
↓ i=7
第三趟匹配
a babc ab cacbab
abcac
tj=5
↓i=4
第四趟匹配
a babc abcacbab
a
li=5
第五趟匹配
a babc ab cac bab
j=1
↓i=11
第六趟匹配
a babc ab cac bab
abcac
tj=6
图4.4 BF算法的匹配过程
第4章串、数组和广义表
设主串的长度为n,子串的长度为m,假设从主串的第i个位置开始与模式串匹配成功,则在
前 i-1 趟匹配中字符总共比较了 i-1 次;若第i趟成功的字符比较次数为m,则总比较次数为
i-1+m。对于成功匹配的主串,其起始位置由1到n-m+1,假定这n-m+1个起始位置上的
匹配成功概率相等,则最好的情况下匹配成功的平均比较次数为
n-m+1
n-m+1
1
Σp(i-1+m):
n-m+1
Σ i-1+m=-(n+m)
2
m=1/(n+m)
i=1
i=1
即最好情况下的平均时间复杂度是O(n+m)。
(2)最坏情况下,每趟不成功的匹配都发生在模式串的最后一个字符与主串中相应字符的
比较。
例如:
S=“aaaaaab’
T=“aab”
假设从主串的第i个位置开始与模式串匹配成功,则在前 -1 趟匹配中字符总共比较了
(i-1)×m 次;若第趟成功的字符比较次数为m,则总比较次数ixm。因此最坏情况下匹配成功
的平均比较次数为
n-m+1
n-m+1
1
1
Zp(ixm) = Σ ixm==mx(n-m+2) 20
i=1
n-m+1
即最坏情况下的平均时间复杂度是O(nxm)。
i=1
BF 算法思路直观简明。但当匹配失败时,主串的指针讠总是回溯到-j+2位置,模式串的
指针总是恢复到首字符位置j=1,因此,算法时间复杂度高。下面将介绍另一种改进的模式匹
配算法。
2. KMP算法
这种改进算法是由 Knuth、Morris 和 Pratt 同时设计实现的,因此简称KMP算法。此算
93

Page 102
94
数据结构(C语言版)(第2版)
法可以在 O(n +m)的时间数量级上完成串的模式匹配操作。其改进在于:每当一趟匹配过程
中出现字符比较不等时,不需回溯i指针,而是利用已经得到的“部分匹配”的结果将模式
向右“滑动”尽可能远的一段距离后,继续进行比较。下面先从具体例子看起。
回顾图 4.4 中的匹配过程示例,在第三趟的匹配中,当=7j=5字符比较不等时,又从i=4、
j=1重新开始比较。然后,经仔细观察可发现,i=4 和 j = 1, i = 5 和 j=1,以及i=6和 j = 1 这
3次比较都是不必进行的。因为从第三趟部分匹配的结果就可得出,主串中第4个、第5个和第6
个字符必然是“b”、“c”和“a”(即模式串中第2个、第3个和第4个字符)。因为模式中的第一
个字符是“a”,因此它无需再和这3个字符进行比较,而仅需将模式向右滑动3个字符的位置继
续进行i=7、j=2时的字符比较即可。同理,在第一趟匹配中出现字符不等时,仅需将模式向右
移动两个字符的位置继续进行=3、j=1时的字符比较。由此,在整个匹配的过程中,i指针没
有回溯,如图4.5所示。
↓i=3
第一趟匹配 a
a
babc ab cac bab
bc
1:tj=3
ti
+11=7.
第二趟匹配
a b a b.
C
a
bc ac bab
a b C
a c
1 j=5
j=1
i=11
第三趟匹配
a bab ca
b C a
cbab
(a)
b
a
C
→↑j=6
j=2
图4.5 KMP算法的匹配过程
现在讨论一般情况。假设主串为“SıS2.sn”,模式串为“tytz...”,从上例的分析可知,为了
实现改进算法,需要解决下述问题:当匹配过程中产生“失配”(即 s;≠ț)时,模式串“向右滑
动”可行的距离多远,换句话说,当主串中第i个字符与模式中第j个字符“失配”(即比较不等)
时,主串中第i个字符(指针不回溯)应与模式中哪个字符再比较?
假设此时应与模式中第k(k<j)个字符继续比较,则模式中前k-1个字符的子串必须满足下
列关系式(4-1),且不可能存在K>k满足下列关系式(4-1)
"titz***tk-1" = “Si-k+1Si-k+2***Si-1”
而已经得到的“部分匹配”的结果是
“-k+15-k+2.5'-1”
=
“Si-k+1Si-k+2***Si-1”
由式(4-1)和式(4-2)推得下列等式
“titz.tk-1”=“j-k+15-k+2.5-1”
(4-1)
(4-2)
(4-3)
反之,若模式串中存在满足式(4-3)的两个子串,则当匹配过程中,主串中第i个字符与模
式中第j个字符比较不等时,仅需将模式向右滑动至模式中第k个字符和主串中第i个字符对齐,
此时,模式中头k-1 个字符的子串“t2...tk-1”必定与主串中第i个字符之前长度为k-1 的子串
“Si-k+1Si-k+2***Si-1”相等,由此,匹配仅需从模式中第k个字符与主串中第i个字符开始,依次
向后进行比较。
à

Page 103
第4章串、数组和广义表
若令 next[j] = k,则 next[j]表明当模式中第j个字符与主串中相应字符“失配”时,在模
式中需重新和主串中该字符进行比较的字符的位置。由此可引出模式串的next 函数的定义:
|0_j=1(t与s,比较不等时,下一步进行t与s的比较)
next[j]={Max{k|1<k<且有“转”=“j-k+15/-k+2.5-1"}
(4-4)
1k=1(不存在相同子串,下一步进行t与s的比较)
由此定义可推出模式串的next 函数值,如图4.6所示。
在求得模式的 next 函数之后,匹配可如下进
行:假设以指针i和j分别指示主串和模式中正待
比较的字符,令i的初值为pos,j的初值为1。若
在匹配过程中 si=t,则i和j分别增 1,否则,
不变,而j退到 next[j]的位置再比较,若相等,图4.6 模式串的 next 函数值
则指针各自增1,否则,再退到下一个 next 值的位
1 2 3
4
5 6 7 8
模式串
next[j]
|| a ba
a b
0
a
C
01 1 2 2 3 1 2
置,依次类推,直至下列两种可能:一种是,退到某个next值(next [ next [ ……next[j]]])
时字符比较相等,则指针各自增1,继续进行匹配;另一种是,退到值为零(即模式的第一个字
符“失配”),则此时需将模式继续向右滑动一个位置,即从主串的下一个字符 Si+1起和模式重
新开始匹配。图4.7所示正是上述匹配过程的一个例子。
acabaabaabcacaabc
↓i=2
主串
第一趟
模式
a b
↑j=2
next[2]=1立即據西
主串
第二趟
模式
a
主串
第三趟
模式
第四趟
主串
模式
\i=2
acabaabaab caca a b c
tj=1 next[1]=0
↓i=3 → ↓i=8
acabaabaabcaca abc
abaabc
↑j=1 → j=6 next[6]=3
=8 → ↓ i=14
acabaabaabcacaabc
(ab)aabcac
tj=3
↑j=9
图4.7 利用模式的next函数进行匹配的过程示例
KMP算法如算法 4.2所示,它在形式上和算法4.1极为相似。不同之处仅在于:当匹配过程
中产生“失配”时,指针i不变,指针j退回到 next[j]所指示的位置上重新进行比较,并且当
指针j退至零时,指针i和指针j需同时增 1。即若主串的第i个字符和模式的第1个字符不等,
应从主串的第+1个字符起重新进行匹配。
算法 4.2 KMP算法
【算法描述】
Tixen
int Index_KMP(SString S,SString Tint pos)
类
95
95

Page 104
数据结构(C语言版)(第2版)
{ //利用模式串T的next函数求在主串中第pos 个字符之后的位置
//其中,T非空,1≤pos≤S.length
i=pos;j=1;
while(i<=S.length && j<=S.length)
//两个串均未比较到串尾
{
if(j==0 || S[i]==T[j]){++1;++j; }
else j=next[j];
//继续比较后继字符
//模式串向右移动
}
if(j>T[0]) return i-T[0];
//匹配成功
else return 0;
//匹配失败
}
KMP算法是在已知模式串的next 函数值的基础上执行的,那么,如何求得模式串的 next 函
数值呢?
从上述讨论可见,此函数值仅取决于模式串本身,而和相匹配的主串无关,可从分析其定义
出发用递推的方法求得 next 函数值。
由定义得知:
next[1] = 0
(4-5)
设 next[j]=k,这表明在模式串中存在下列关系:
“titz.tk-1”=“j-k+15-k+2.5-1”
(4-6)
其中 k为满足1<ky的某个值,并且不可能存在k'>k满足等式(4-7)。此时next[j+1]=?可能
有以下两种情况。
(1)若 t=ty,则表明在模式串中
"tit2.tk"
=
"tj-k+1tj-k+2***tj”
(4-7)
并且不可能存在k'>k满足等式(4-7),这就是说next[j+1]=k+1,即
next[j+1]=next[j]+1
(4-8)
(2)若t≠t,则表明在模式串中
"tit2tk" "tj-k+1tj-k+2***tj"
此时可把求 next 函数值的问题看成是一个模式匹配的问题,整个模式串既是主串又是模式串,而
当前在匹配的过程中,已有5-k+1=1,j-k+2=2,…,
·, -1=Ze-1,则当时应将模式向右滑
动至以模式中的第 next[k]个字符和主串中的第j个字符相比较。若next[k]=K,且=tx,则说明
在主串中第j+1个字符之前存在一个长度为k(即next[k])的最长子串,和模式串中从首字符起
长度为k的子串相等,即
96
96
“titz.tk”=“ty-k+15-K+2.0t;" (1<k'<k<j)
这就是说next[j+1] = k'+1,即
next[j+1] = next[k]+1
(4-9)
(4-10)
同理,若 t≠ te,则将模式继续向右滑动直至将模式中第 next[k]个字符和t 对齐,…, 依
次类推,直至t和模式中某个字符匹配成功或者不存在任何K(1<<j)满足等式(4-9),则
next[j+1]=1
(4-11)
例如,图 4.8 中的模式串,已求得前6个字符的 next 函数值,现求 next [7], 因为 next[6] = 3,

Page 105
又 to ≠ ts,则需比较t和t(因为next[3]=1),这相当于将子串模
式向右滑动。由于 to ≠ tı,而且 next [1] = 0,所以 next [7] = 1,而
因为ㄣ=,则 next [8] = 2。
第4章串、数组和广义表
-
1 2 3 4 5 6
78
j
模式
aba abc
ac
next[j]
011 2 2 3
12
根据上述分析所得结果(式(4-5)、式(4-8)、式(4-10)和式
(4-11)),仿照 KMP算法,可得到求next 函数值的算法,如算法4.3
所示。
(a b a)
(a)
图4.8模式串的next 函数值
算法 4.3 计算 next 函数值
【算法描述】
void get_next (SString Tint next[])
{ //求模式串T的next函数值并存入数组 next
i=1;next[1]=0;j=0;
while(i<T[0])
if(j==0 || T[i]==T[j]){++1;++j;next[i]=j; }
AA
else j=next[j];
}
蛋糕
算法 4.3 的时间复杂度为O(m)。通常,模式串的长度m比主串的长度n要小得多,因此,对
整个匹配算法来说,所增加的这点时间是值得的。
最后,要说明以下两点。
懷的
(1)虽然 BF 算法的时间复杂度是O(nxm),但在一般情况下,其实际的执行时间近似于
O(n+ m),因此至今仍被采用。KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下,
才显得比BF算法快得多。但是KMP算法的最大特点是指示主串的指针不需回溯,整个匹配过程
中,对主串仅需从头至尾扫描一遍,这对处理从外设输入的庞大文件很有效,可以边读入匹配,
而无需回头重读。
(2)前面定义的next函数在某些情况下尚有缺陷。例如模式“aaaab”在和主串“aaabaaaab”匹配
时,当i=4、 j=4时s.ch[4]≠t.ch[4],由next[j]的指示还需进行i=4、j=3,i=4､j=2,i=4、j=1
这3次比较。实际上,因为模式中第1~3个字符和第4个字符都相等,因此不需要再和主串中第4个
字符相比较,而可以将模式连续向右滑动4个字符的位置直接进行=5j=1时的字符比较。这就是说,
若按上述定义得到 next[j]=k,而模式中 (=4,则当主串中
字符 s;和比较不等时,不需要再和进行比较,而直接和
Tnext k)进行比较,换句话说,此时的next[j]应和next[k]相同。
由此可得计算 next 函数修正值的算法如算法4.4 所示,next
函数修正值的计算结果如图4.9所示。此时匹配算法不变。
算法 4.4 计算 next 函数修正值
next[j]
j
1
2
3
4
5
模式串
a
a
a
a
b
0
1
2
3
4
nextval[j]
4
图4.9
next 函数修正值
0000
【算法描述】
void get_nextval (SString T, int nextval[])个
{ //求模式串T的next函数修正值并存入数组 nextval
i=1;nextval[1]=0;j=0;
while(i<T[0])
{
if(j==0 || T[i]==T[j])
Tabor/
97
97

Page 106
98
数据结构(C语言版)(第2版)
}
{
++1;++j;
if(T[i]!=T[j]) nextval[i]=j;
else nextval[i]=nextval[j];
}
else j=nextval[j];
4.4 数组
4.4.1 数组的类型定义
数组是由类型相同的数据元素构成的有序集合,每个元素称为数组元素,每个元素受n(n>
1)个线性关系的约束,每个元素在n个线性关系中的序号 n,n,…,in称为该元素的下标,可
以通过下标访问该数据元素。因为数组中每个元素处于n(n≥1)个关系中,故称该数组为n维
数组。数组可以看成是线性表的推广,其特点是结构中的元素本身可以是具有某种结构的数据,
但属于同一数据类型。
例如,一维数组可以看成是一个线性表,二维数组可以看成数据元素是线性表的线性表。图
4.10(a)所示的二维数组可以看成是一个线性表
a02
do, n-1
doo
dol
ao, n-1
a10
all a¹ ...
all
a, n-1
a12
a1, -1
Amxn=
, Amxn=
L-1, 0
am-1, 1
am-1,2
am-1, -1
(a)矩阵形式表示
dm-1, 0
am-1,1
am-1, -1
(b)列向量的一维数组
SON "dreasden"
1=A=170=
Ax₁ = ((α α...α, -1), (a,1),..., (am-1, 0am-1, 1... am-1, -1))
(c)行向量的一维数组
[]
图4.10 二维数组图例
A = (α, a₁,···, ap) (p=m-n-1)|||\] 125
其中每个数据元素a是一个列向量形式的线性表
aj = (aqj,qy,.., mi,j)
0≤j<n-1
(见图4.10(b))或者a是一个行向量形式的线性表四时也
a₁ = (aio, a¡1, ***, ai,n−1)
0<i<m-1
(见图4.10(c))。在C语言中,一个二维数组类型可以定义为其分量类型为一维数组类型的一维
数组类型,也就是说,
ElemType
typedef
Array2[m][n];
等价于
typedef
ElemType
Array1[n];

Page 107
typedef
Array1
Array2[m];
第4章串、数组和广义表
同理,一个n维数组类型可以定义为其数据元素为n-1维数组类型的一维数组类型。
数组一旦被定义,它的维数和维界就不再改变。因此,除了结构的初始化和销毁之外,数组
只有存取元素和修改元素值的操作。
抽象数据类型数组可形式地定义为:
ADT Array {
数据对象:j=0,.,bi-1,i=1,2,…,n,
D = { ajzjz...jp In (>0)称为数组的维数,b是数组第i维的长度,
ji是数组元素的第i维下标,ajyjz.jn ∈ElemSet}
数据关系:R={R1,R2,…, Rn}
基本操作:
InitArray(&A, n, boundi, ..., boundn)
操作结果:若维数n和各维长度合法,则构造相应的数组A,并返回 OK。
DestroyArray(&A)
操作结果:销毁数组A。
Value (A, &e, indexl,..., indexn)
初始条件:A是n维数组,e为元素变量,随后是n个下标值。
操作结果:若各下标不超界,则e赋值为所指定的A的元素值,并返回 OK。
Assign (&A, e, indexl,..., indexn)
初始条件:A是n维数组,e为元素变量,随后是n个下标值。
操作结果:若下标不超界,则将e的值赋给所指定的A的元素,并返回 OK。
} ADT Array
4.4.2 数组的顺序存储
0,0.0004
由于数组一般不做插入或删除操作,也就是说,一旦建立了数组,则结构中的数据元素个数
和元素之间的关系就不再发生变动。因此,采用顺序存储结构表示数组比较合适。
由于存储单元是一维的结构,而数组可能是多维的结构,则用一组连续存储单元存放数组的
数据元素就有次序约定问题。例如图4.10(a)所示的二维数组可以看成如图4.10(b)所示的一
维数组,也可看成如图4.10(c)所示的一维数组。对应地,对二维数组可有两种存储方式:一种
是以列序为主序的存储方式,如图4.11(a)所示;一种是以行序为主序的存储方式,如图4.11
(b)所示。在扩展 Basic、Pascal、Java 和 C语言中,用的都是以行序为主序的存储结构,而在
FORTRAN 语言中,用的是以列序为主序的存储结构。
由此,对于数组,一旦规定了其维数和各维的长度,便可为它分配存储空间。反之,只要
给出一组下标便可求得相应数组元素的存储位置。下面仅用以行序为主序的存储结构为例予以
说明。
假设每个数据元素占个存储单元,则二维数组 4[0.. m-1, 0.. n-1] (即下标从0开始,共有
m行n列)中任一元素 af 的存储位置可由下式确定
科
..
(西怨门报显示砖
(4-12)
式中,LOC(i,j)是a)的存储位置;LOC(0,0)是ao的存储位置,即二维数组4的起始存储位置,
也称为基地址或基址。
回空
LOC(i,j)=LOC(0,0)+(nxi+j)L
99

Page 108
数据结构(C语言版)(第2版)
LOC(A)=LOC(200)
a00
...
LOC(4%)=LOC(an)
a00
LOC(A)=LOC(a)
am-1, 0
all
LOC(A'))=LOC(a10)
ao, n-1
a10
all
...
am-1, 1
...
LOC(A))=LOC(ao, n-1)
do, n-1
a1, n-1
...
am-1, n-1
A=(A), A.,品)
A(aj, aj, am-1,j)
(D
...
a1, n-1
...
dm-1,0
LOC(A))=LOC(am-1, 0)
am-1, 1
am-1, -1
A=(A), A, A1)
(aio ai, ai.m-1)
(a)以列序为主序
(b)以行序为主序
图4.11 二维数组的两种存储方式
AD
将式(4-12)推广到一般情况,可得到n维数组 4[0..by-1,0..bz-1,…, 0.. b-1]的数据元
素存储位置的计算公式:
LOC(i,j2,…, jn) =LOC(0,0,.,0)+(bzx...xbxji+bzx...xbnxjz
瓶
可缩写成
+...+bnxjn=1+jn) L
n-1
n
= LOC(0, 0, 0) + jìbe+jn L
+
i=1 k=i+1
LOC (1, J2, Jn) = LOC(0, 0, ..., 0)+Σciji
i=1
(4-13)
100
其中,Cn = L, Citi = b;×ci, 1<i<n。
式(4-13)称为n维数组的映像函数。容易看出,数组元素的存储位置是其下标的线性函数,
一旦确定了数组各维的长度,c就是常数。由于计算各个元素存储位置的时间相等,所以存取数
组中任一元素的时间也相等,即数组是一种随机存取结构。
4.4.3 特殊矩阵的压缩存储
矩阵是很多科学与工程计算问题中研究的数学对象,矩阵用二维数组来表示是最自然的方法。
但是,在数值分析中经常出现一些阶数很高的矩阵,同时在矩阵中有很多值相同的元素或者是零
元素。有时为了节省存储空间,可以对这类矩阵进行压缩存储。所谓压缩存储,是指为多个值相

Page 109
第4章串、数组和广义表
同的元只分配一个存储空间,对零元不分配空间。
假若值相同的元素或者零元素在矩阵中的分布有一定规律,则称此类矩阵为特殊矩阵。
特殊矩阵主要包括对称矩阵、三角矩阵和对角矩阵等,下面我们重点讨论这三种特殊矩阵的
压缩存储。
1. 对称矩阵
若n阶矩阵A中的元满足下述性质
aij = a ji
1≤i,j<n
则称为n阶对称矩阵。
对于对称矩阵,可以为每一对对称元分配一个存储空间,则可将n㎡个元压缩存储到n(n+1)/2
个元的空间中,不失一般性,可以行序为主序存储其下三角(包括对角线)中的元。
假设以一维数组 sa[n(n+1)/2]作为n阶对称矩阵的存储结构,则sa[k]和矩阵元 aj之间存
在着一一对应的关系:
i(i-1)
+j-1
当≥j
2
k=
(4-14)
j(j-1)
+i-1
当<j
2
对于任意给定的一组下标(j),均可在sa 中找到矩阵元ay;反之,对所有的k=0,1,2,…,
n(n+1)
2-1,都能确定 sa[k]中的元在矩阵中的位置(i,j)。由此,称sa[n(n+1)/2]为n阶对称矩阵A
2
的压缩存储(见图4.12)。
an
a21
d22
a31
an, 1
an, n
n(n-1)
n(n+1)
k=
0
1
2
3
2
2
图4.12对称矩阵的压缩存储
2. 三角矩阵
以主对角线划分,三角矩阵有上三角矩阵和下三角矩阵两种。上三角矩阵是指矩阵下三角(不
包括对角线)中的元均为常数或零的n阶矩阵,下三角矩阵与之相反。对三角矩阵进行压缩存
储时,除了和对称矩阵一样,只存储其上(下)三角中的元素之外,再加一个存储常数c的存储
空间即可。
(1)上三角矩阵
sa[k]和矩阵元 ai之间的对应关系为
92LI
(2)下三角矩阵
(i-1)(2n-i+2)P/- 21
2+(ji)
当≤j
2
(4-15)
k =
n(n+1)
单品
当>j
2
sa[k]和矩阵元 ajj之间的对应关系为
101

Page 110
102
数据结构(C语言版)(第2版)
i(i-1)
+j-1
当≥j
2
1淋(4-16)
的酒無料] n(n+1)
当<j
2
3.对角矩阵
对角矩阵所有的非零元都集中在以主对角线为中心的带状区域中,即除了主对角线上
和直接在对角线上、下方若干条对角线上的元之外,所有其他的元皆为零,如图4.13 所示。
对这种矩阵,也可按某个原则(或以行为主,或以对角线的顺序)将其压缩存储到一维数
组上。
a条对角线
(+1期
个庾
n列
>n 行
a12
a21
a22
a23
O
an-1. n
an. n-1
an.n
(a)一般情形
(b)三对角矩阵
图4.13 对角矩阵
ir中中国]na海
在上述这些特殊矩阵中,非零元的分布都有一个明显的规律,从而可将其压缩存储到一维数
组中,并找到每个非零元在一维数组中的对应关系。
然而,在实际应用中还经常会遇到另一类矩阵,其非零元较零元少,且分布没有一定规律,
称之为稀疏矩阵。这类矩阵的压缩存储就要比特殊矩阵复杂,在此不做讨论。
4.5 广义表
4.5.1 广义表的定义
顾名思义,广义表是线性表的推广,也称为列表。广泛地用于人工智能等领域的表处理语言
LISP 语言,把广义表作为基本的数据结构,就连程序也表示为一系列的广义表。
广义表一般记作
LS=(a₁, a₂, an) (-)
其中,LS 是广义表(a1,a2,...,an)的名称,n是其长度。在线性表的定义中,a(1≤i≤n)只限于
是单个元素。而在广义表的定义中,a可以是单个元素,也可以是广义表,分别称为广义表 LS
的原子和子表。习惯上,用大写字母表示广义表的名称,用小写字母表示原子。
显然,广义表的定义是一个递归的定义,因为在描述广义表时又用到了广义表的概念。下面
列举一些广义表的例子。

Page 111
(1)4=()——A是一个空表,其长度为零。
(2)B=(e)——B只有一个原子e,其长度为1午刷
第4章串、数组和广义表
示期
(3)C= (a,(b, c, d))——C 的长度为2,两个元素分别为原子和子表(b,c,d)。
(4) D= (A, B, C)——D的长度为3,3个元素都是广义表。显然,将子表的值代入后,则有
D = ((), (e), (a, (b, c, d)))。
(5)E= (a,E)——这是一个递归的表,其长度为2。E相当于一个无限的广义表 E=(a, (a,
(a,…)))。
从上述定义和例子可推出广义表的如下3个重要结论。
(1)广义表的元素可以是子表,而子表的元素还可以是子表……由此,广义表是一个多层次
的结构,可以用图形象地表示。例如,图4.14表示的是广义表D,图中以圆圈表示广义表,以方
块表示原子。
D
A
C
e
a
b
C d
图4.14 广义表的图形表示
(2)广义表可为其他广义表所共享。例如在上述例子中,广义表A、B和CD的子表,
则在D 中可以不必列出子表的值,而是通过子表的名称来引用。
(3)广义表可以是一个递归的表,即广义表也可以是其本身的一个子表。例如,表E 就是一
个递归的表。
由于广义表的结构比较复杂,其各种运算的实现也不如线性表简单,其中,最重要的两个运算如下。
(1)取表头 GetHead(LS):取出的表头为非空广义表的第一个元素,它可以是一个单原子,也
可以是一个子表。
(2)取表尾 GetTail(LS):取出的表尾为除去表头之外,由其余元素构成的表。即表尾一定是
一个广义表。
例如:
GetHead(B)=e,
GetHead(D) = A,
GetTail(B)=(),
GetTail(D) = (B,C),
由于(B,C)为非空广义表,则可继续分解得到:
GetHead(B,C)=B, GetTail(B,C)= (C),
值得提醒的是,广义表()和(())不同。前者为空表,长度n=0;后者长度n=1,可分解得到
其表头、表尾均为空表()。
4.5.2 广义表的存储结构
由于广义表中的数据元素可以有不同的结构(或是原子,或是列表),因此难以用顺序存储结
构表示,通常采用链式存储结构。常用的链式存储结构有两种,头尾链表的存储结构和扩展线性
链表的存储结构。
103

Page 112
104
数据结构(C语言版)(第2版)
1. 头尾链表的存储结构
由于广义表中的数据元素可能为原子或广义表,由此需要两种结构的结点:一种是表结
点,用以表示广义表;一种是原子结点,用以表示原子。从上节得知:若广义表不空,则可
分解成表头和表尾,因此,一对确定的表头和表尾可唯一确定广义表。一个表结点可由3个
域组成:标志域、指示表头的指针域和指示表尾的指针域。而原子结点只需两个域:标志域
和值域。如图 4.15所示,其中tag是标志域,值为1时表明结点是子表,值为0时表明结点
是原子。
tag=1
hp
tp
表结点
tag=0
atom
原子结点
图4.15 头尾链表表示的结点结构
其形式定义说明如下:
//- - - - -广义表的头尾链表存储表示-
typedef enum{ATOM,LIST} ElemTag;
//ATOM==0:原子;LIST==1:子表
typedef struct GLNode
ElemTag tag;
union
{
//公共部分,用于区分原子结点和表结点
//原子结点和表结点的联合部分
//atom是原子结点的值域,AtomType 由用户定义
//ptr是表结点的指针域,ptr.hp和ptr.tp 分别指向表头和表尾
AtomType atom;
struct{struct GLNode*hp, *tp:}ptr;
};
}*GList;
//广义表类型
上节中曾列举了广义表的例子,它们的存储结构如图4.16所示,在这种存储结构中有以下几
种情况。
A=NULL
B
1
Λ
D-1
E
1
0 e
Λ
1
0 a
1
Λ
0
a
1
1
(d)bes Hiso
0 b
0 C
0d
1
Λ
usa
S.a.
图4.16 头尾链表表示的存储结构示例
(1)除空表的表头指针为空外,对任何非空广义表,其表头指针均指向一个表结点,且该结

Page 113
第4章串、数组和广义表
点中的hp 域指示广义表表头(或为原子结点,或为表结点),域指向广义表表尾(除非表尾为
空,则指针为空,否则必为表结点)。
(2)容易分清列表中原子和子表所在层次。如在广义表D中,原子a和e在同一层次上,
而b、c和d在同一层次且比a和e低一层,B和C是同一层的子表。
(3)最高层的表结点个数即为广义表的长度。
以上3个特点在某种程度上给广义表的操作带来方便。
2. 扩展线性链表的存储结构
在这种结构中,无论是原子结点还是表结点均由三个域组成,其结点结构如图 4.17 所示。
tag=1
hp
tp
tag=0
atom
tp
表结点
原子结点
图4.17 扩展线性链表表示的结点结构
4.5.1 小节中广义表例子所对应的这种表示法的存储结构,如图4.18所示。
A-
1
Λ
B
1
Λ
C 1
Λ
0
e
^
D.
1
Λ
0
a
1
1
Λ
Λ
E
1
Λ
0
a
A
Ob Oc⚫ odA
图4.18 扩展线性链表表示的存储结构示例
4.6
案例分析与实现
案例 4.1:病毒感染检测。
【案例分析】
因为患者的 DNA和病毒DNA均是由一些字母组成的字符串序列,要检测某种病毒 DNA序
列是否在患者的DNA序列中出现过,实际上就是字符串的模式匹配问题。可以利用BF算法,也
可以利用更高效的KMP算法。但与一般的模式匹配问题不同的是,此案例中病毒的DNA序列是
环状的,这样需要对传统的BF算法或KMP算法进行改进。
下面给出利用 BF算法实现检测的方案。
【案例实现】
对于每一个待检测的任务,假设病毒DNA序列的长度是m,因为病毒DNA序列是环状的,
105

Page 114
106
数据结构(C语言版)(第2版)
为了线性取到每个可行的长度为m的模式串,可将存储病毒DNA序列的字符串长度扩大为2m,
将病毒DNA序列连续存储两次。然后循环m次,依次取得每个长度为m的环状字符串,将此字
符串作为模式串,将人的DNA序列作为主串,调用BF算法进行模式匹配。只要匹配成功,即可
中止循环,表明该人感染了对应的病毒;否则,循环m次结束循环时,可通过BF算法的返回值
判断该人是否感染了对应的病毒。
算法 4.5 病毒感染检测
【算法步骤】
①从文件中读取待检测的任务数 num。
②根据 num 个数依次检测每对病毒DNA和人的DNA是否匹配,循环num 次,执行以下操作:
● 从文件中分别读取一对病毒DNA序列和人的DNA序列;
● 设置一个标志性变量flag,用来标识是否匹配成功,初始为0,表示未匹配;
● 病毒DNA序列的长度是m,将存储病毒DNA序列的字符串长度扩大为2m,将病毒
DNA序列连续存储两次;
循环 m 次,重复执行以下操作:水师
依次取得每个长度为m的病毒DNA环状字符串;
将此字符串作为模式串,将人的DNA序列作为主串,调用BF算法进行模式匹配,
将匹配结果返回赋值给 flag;
若 flag 非 0,表示匹配成功,中止循环,表明该人感染了对应的病毒。
● 退出循环时,判断flag的值,若flag 非0,输出“YES”,否则,输出“NO”。
【算法描述】
void Virus detection ()
{//利用BF算法实现病毒检测
ifstream inFile("病毒感染检测输入数据.txt");
ofstream outFile("病毒感染检测输出结果.txt");
inFile>>num;
while(num--)
{
inFile>>Virus.ch+1;
inFile>>Person.ch+1;
Vir=Virus.ch;
flag=0;
//读取待检测的任务数
//依次检测每对病毒DNA 和人的DNA 是否匹配
//读取病毒DNA序列,字符串从下标1开始存放
//读取人的DNA序列
//將病毒 DNA 临时暂存在 Vir 中,以备输出
//用来标识是否匹配,初始为0,匹配后为非0
//病毒DNA序列的长度是m
m=Virus.length;
for(i=m+1,j=1;j<=m;j++)
I AMG Virus.ch[2*m+1]='\0';
Virus.ch[i++]=Virus.ch[j];
//将病毒字符串的长度扩大2倍
//添加结束符号AIL
A
for(i=0;i<m;i++)
//依次取得每个长度为m的病毒DNA 环状字符串 temp
for(j=1;j<=m;j++) temp.ch[j]=Virus.ch[i+j];
temp.ch[m+1]='\0';
flag=Index_BF(Person,temp,1); //模式匹配
if(flag) break;
//添加结束符号
//匹配即可退出循环
//for