# 栈和队列

栈和队列是两种重要的线性结构。从数据结构角度看,栈和队列也是线性表,其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为限定性的数据结构。但从数据类型角度看，它们是和线性表不相同的两类重要的抽象数据类型。

## 一、栈和队列的定义和特点

### 1.1 栈的定义和特点

**栈**（stack）是限定仅在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为**栈顶**（top），相应地，表头端称为**栈底**（bottom）。不含元素的空表称为**空栈**。

假设栈 S=($a_1$, $a_2$, ..., $a_n$)，则称 $a_1$ 为浅底元素，$a_n$ 为栈顶元素。栈中元素按 $a_1$, $a_2$, ..., $a_n$ 的次序进栈，出栈的第一个元素应为栈顶元素。换句话说，栈的修改是按后进先出的原则进行的，如图（a）所示。因此，栈又称为**后进先出**（Last In First Out，LIFO）的线性表，它的这个特点可用图（b）所示的铁路调度站形象地示。

![栈的是示意图](/assets/stack.png)

在日常生活中，还有很多类似栈的例子。例如，洗干净的盘子总是逐个往上叠放在已经洗好的盘子上面，而用时从上往下逐个取用。栈的操作特点正是上述实际应用的抽象。在程序设计中，如果需要按照保存数据时相反的顺序来使用数据，则可以利用栈来实现。

### 1.2 队列的定义和特点

队列（queue）是一种先进先出（First In First Out，FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。这和日常生活中的排队是一致的，最早进入队列的元素最早离开。在队列中，允许插入的一端称为队尾（rear），允许删除的一端则称为队头（front）。假设队列为 q=($a_1$, $a_2$, ..., $a_n$)，那么，$a_1$ 就是队头元素，$a_n$ 则是队尾元素。队列中的元素是按照 $a_1$, $a_2$, ..., $a_n$ 的顺序进入的，退出队列也只能按照这个次序依次退出，也就是说，只有在 $a_1$, $a_2$, ..., $a_{n-1}$ 都离开队列之后，$a_n$ 才能退出队列。

![队列的示意图](/assets/queue.png)

队列在程序设计中也经常出现。一个最典型的例子就是操作系统中的作业排队。在允许多道程序运行的计算机系统中，同时有几个作业运行。如果运行的结果都需要通过通道输出，那就要按请求输入的先后次序排队。每当通道传输完毕可以接受新的输出任务时，队头的作业先从队列中退出做输出操作。凡是申请输出的作业都从队尾进入队列。

## 二、栈的表示和操作的实现

### 2.1 栈的类型定义

栈的基本操作除了入栈和出栈外，还有栈的初始化、栈空的判定，以及取栈顶元素等。

栈有两种存储表示方法，分别称为顺序栈和链栈。

### 2.2 顺序栈的表示和实现

顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针 `top` 指示栈顶元素在顺序栈中的位置。通常习惯的做法是：以 `top = 0` 表示空栈，鉴于C语言中数组的下标约定从0开始，则当以C语言作描述语言时，如此设定会带来很大不便，因此另设指针 `base` 指示栈底元素在顺序栈中的位置。当 `top` 和 `base` 的值相等时，表示空栈。顺序栈的定义如下。

```c
//---- 顺序栈的存储结构- - - -
#define MAXSIZE 100 //顺序栈存储空间的初始分配量
typedef struct
{
  SElemType *base; //栈底指针
  SElemType *top; //栈顶指针
  int stacksize; //栈可用的最大容量
} SqStack;
```

上面代码中，`base` 为栈底指针，初始化完成后，栈底指针 `base` 始终指向栈底的位置，若 `base` 的值为 `NULL`，则表明栈结构不存在。`top` 为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针 `top` 增1；删除栈顶元素时，指针 `top` 减1。因此，栈空时，`top` 和 `base` 的值相等，都指向栈底；栈非空时，`top` 始终指向栈顶元素的上一个位置。

下图所示，为顺序栈中数据元素和栈指针之间的对应关系。

![栈中元素和栈指针之间的关系](/assets/stack-element-cursor.png)

由于顺序栈的插入和删除只在栈顶进行，因此顺序栈的基本操作比顺序表要简单得多。

另外，顺序栈和顺序表一样，受到最大空间容量的限制，虽然可以在“满员”时重新分配空间扩大容量，但工作量较大，应该尽量避免。因此在应用程序无法预先估计栈可能达到的最大容量时，还是应该使用下面介绍的链栈。

### 2.3 链栈的表示和实现

链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示，如下图所示。

![链栈示意图](/assets/linked-stack.png)

链栈的结点结构与单链表的结构相同，在此用 StackNode 表示，定义如下。

```c
//----- 链栈的存储结构-
typedef struct StackNode
{
  ElemType data;
  struct StackNode *next;
} StackNode, *LinkStack;
```

由于栈的主要操作是在栈顶插入和删除，显然以链表的头部作为栈顶是最方便的，而且没必要像单链表那样为了操作方便附加一
个头结点。

### 2.4 栈与递归

栈有一个重要应用是在程序设计语言中实现递归。递归算法设计中最常用的手段,
它通常把一个大型复杂问题的描述和求解变得简洁和清晰。因此递归算法常常比非递归算
法更易设计,尤其是当问题本身或所涉及的数据结构是递归定义的时候,使用递归方法更
加合适。为使读者增强理解和设计递归算法的能力,本节将介绍栈在递归算法的内部实现
中所起的作用。
3.4.1 采用递归算法解决的问题
所谓递归是指,若在一个函数、过程或者数据结构定义的内部又直接或间接)出现定义本身
的应用,则称它们是递归的,或者是递归定义的。在以下三种情况下,常常使用递归的方法。
1. 定义是递归的
有很多数学函数是递归定义的,如大家熟悉的阶乘函数
61

Page 70
数据结构(C语言版)(第2版)
若n=0
Fact(n) =
(3-1)
n*Fact(n-1) 若n>0空武古皇
二阶 Fibonacci 数列
若n=1或n=2
Fib(n)=
(3-2)
Fib(n-1)+Fib(n-2) 其他情形
对于(3-1)中的阶乘函数,可以使用递归过程来求解。
long Fact (long n)
{
if (n==0) return 1;
else return n*Fact(n-1);
//递归终止的条件
//递归步骤
}
图3.7所示为主程序调用函数Fact(4)的执行过程。在函数过程中,else语句以参数3、2、
1、0 执行递归调用。最后一次递归调用的函数参数为0执行if语句,递归终止,逐步返回,
返回时依次计算1*1、2*1、3*2、4*6,最后将计算结果24返回给主程序。
类似地,可写出 Fibonacci 数列的递归程序:
long Fib(long n)
{
if(n==1||n==2) return 1;
//递归终止的条件
else return Fib(n-1)+ Fib(n-2);
//递归步骤
}
对于类似这种的复杂问题,若能够分解成几个相对简单且解法相同或类似的问题来求解,
便称作递归求解。例如,在图3.7中,计算4!时先计算3!,然后再进一步分解进行求解,这种分
解-求解的策略叫做“分治法”。
参数
计算
返回
0
0!=1
0
1
参数
计算
返回
+
電話:1*fact (0)
1
1返
参数
计算
返回
+
2
2*fact (1)
2
回
回
2
参数
计算
返回
+
值
3.
3*fact (2)
6
3
参数
计算
返回 6L.A.8
4
4*fact (3)
24
24
24
主程序 main 调用 fact (4)
图3.7 求解4!的过程
文
印堂
数
参数传递
冷器内的传2
62
62

Page 71
采取“分治法”进行递归求解的问题需要满足以下三个条件。
第3章 栈和队列
,我因
(1)能将一个问题转变成一个新问题,而新问题与原问题的解法相同或类同,不同的仅是处
理的对象,并且这些处理对象更小且变化规律。
(2)可以通过上述转化而使问题简化。
(3)必须有一个明确的递归出口,或称递归的边界。
“分治法”求解递归问题算法的一般形式为:
void p(参数表)
{
if(递归结束条件成立)可直接求解;
else p(较小的参数);
//递归终止的条件
//递归步骤
具
可见,上述阶乘函数和 Fibonacci 数列的递归过程均与此一般形式相对应。醜8
2. 数据结构是递归的
某些数据结构本身具有递归的特性,则它们的操作可递归地描述。
地址译
例如,对于链表,其结点 LNode 的定义由数据域data 和指针域 next组成,而指针域 next 是一种
指向 LNode 类型的指针,即LNode 的定义中又用到了其自身,所以链表是一种递归的数据结构。
对于递归的数据结构,相应算法采用递归的方法来实现特别方便。链表的创建和链表结点的
遍历输出都可以采用递归的方法。算法3.9是从前向后遍历输出链表结点的递归算法,调用此递
归函数前,参数p指向单链表的首元结点,在递归过程中,p不断指向后继结点,直到p为NULL
时递归结束。显然,这个问题满足上述给出的采用“分治法”进行递归求解的问题需要满足的三
个条件。
算法 3.9 遍历输出链表中各个结点的递归算法
【算法步骤】
①如果p为NULL,递归结束返回。
水氣(1)
37人賽區山西路圖(S)院成
② 否则输出 p->data,p指向后继结点继续递归。如个一看不回野(2)
【算法描述】
void TraverseList (LinkList
seList(LinkList p)並
}
}
if(p==NULL) return;
else
{
cout<<p->data<<end;
TraverseList(p->next);
//递归终止
//输出当前结点的数据域
//p指向后继指点继续递归
在递归算法中,如果当递归结束条件成立,只执行return 操作时,“分治法”求解递归问题算
法的一般形式可以简化为:
{
void p(参数表)
if(递归结束条件不成立)
p(较小的参数);
同
}
63

Page 72
数据结构(C语言版)(第2版)
因此,算法3.9可以简化为:
void TraverseList (LinkList p)
}
{
if(p)
{
cout<<p->data<<end;
TraverseList(p->next);
后面章节要介绍的广义表、二叉树等也是典型
的具有递归特性的数据结构,其相应算法也可采用
递归的方法来实现。
3. 问题的解法是递归的
A
B
C
还有一类问题,虽然问题本身没有明显的递归
结构,但用递归求解比迭代求解更简单,如 Hanoi
塔问题、八皇后问题、迷宫问题等。
【例3.1】 n 阶 Hanoi 塔问题。
【问题描述】
假设有3个分别命名为A、B和C 的塔座,在
塔座A上插有n个直径大小各不相同,依小到大编
号为1,2,…,n的圆盘(如图3.8所示)。现要求
将塔座A上的n个圆盘移至塔座C上,并仍按同样
顺序叠排,圆盘移动时必须遵循下列规则:
去算
++
A
B
C
A
B
C
(1)每次只能移动一个圆盘;
A
B
(2)圆盘可以插在A、B和C中的任一塔座上;
图3.8 Hanoi 塔问题
(3)任何时刻都不能将一个较大的圆盘压在较
小的圆盘之上。
【问题分析】
如何实现移动圆盘的操作呢?可以用分治求解的递归方法来解决这个问题。设A柱上最初的盘子
总数为n,则当n=1时,只要将编号为1的圆盘从塔座A直接移至塔座C上即可;否则,执行以下
三步:
(1)用C柱做过渡,将A柱上的(n-1)个盘子移到B柱上;
(2)将A柱上最后一个盘子直接移到C柱上;
(3)用A柱做过渡,将B柱上的(n-1)个盘子移到C柱上。
具体移动过程如图3.8所示,图中 n=4。
根据这种解法,如何将n-1个圆盘从一个塔座移至另一个塔座的问题是一个和原问题具有
相同特征属性的问题,只是问题的规模小1,因此可以用同样的方法求解。
为了便于描述算法,将搬动操作定义为move(A,n,C),是指将编号为n的圆盘从A移到 C,
同时设一个初值为0的全局变量m,对搬动进行计数:
int _m=0;
void move (char A,int n,char C)
{
64
64
cout<<++m<<","<<n<<","<<A<<">"<<C<<endl;}

Page 73
算法 3.10 Hanoi 塔问题的的递归算法鳎
奧重
【算法步骤】新星点,嵌入口
①如果n=1,则直接将编号为1的圆盘从A移到C,递归结束。
●递归,将A上编号为1至2-1的圆盘移到B,C做辅助塔;
直接将编号为n的圆盘从A移到C;
● 递归,将B 上编号为1至n-1的圆盘移到C,A做辅助塔。
【算法描述】
void Hanoi (int n,char A, char B, char C)
{ //将塔座A上的n个圆盘按规则搬到C上,B做辅助塔
if(n==1) move(A,1,C);
else
{
}
Hanoi (n-1, A, C, B);
move (A, n, C);
Hanoi (n-1, B, A, C);
//将编号为1的圆盘从A移到C
第3章 栈和队列
//将A上编号为1至n-1的圆盘移到B,C做辅助塔
//将编号为n的圆盘从A移到C
//将B上编号为1至n-1的圆盘移到C,A做辅助塔
3.4.2 递归过程与递归工作栈
一个递归函数,在函数的执行过程中,需多次进行自我调用。那么,这个递归函数是如何执
行的?先看任意两个函数之间进行调用的情形。
与汇编语言程序设计中主程序和子程序之间的链接及信息交换相类似,在高级语言编制的程序
中,调用函数和被调用函数之间的链接及信息交换需通过栈来进行。
通常,当在一个函数的运行期间调用另一个函数时,在运行被调用函数之前,系统需先完成
3件事:
(1)将所有的实参、返回地址等信息传递给被调用函数保存;
(2)为被调用函数的局部变量分配存储区;
(3)将控制转移到被调函数的入口。
而从被调用函数返回调用函数之前,系统也应完成3件工作:
(1)保存被调函数的计算结果;
示意图面可
(2)释放被调函数的数据区;
(3)依照被调函数保存的返回地址将控制转移到调用函数。
当有多个函数构成嵌套调用时,按照“后调用先返回”的原则,上述函数之间的信息传递和
控制转移必须通过“栈”来实现,即系统将整个程序运行时所需的数据空间安排在一个栈中,每
当调用一个函数时,就为它在栈顶分配一个存储区,每当从一个函数退出时,就释放它的存储区,
则当前正运行的函数的数据区必在栈顶。
例如,在图3.9(c)所示的主函数main 中调用了函数first,而在函数first 中又调用了函数 second,
则图3.9(a)所示为当前正在执行函数 second 中某个语句时栈的状态,而图3.9(b)展示从函数 second
退出之后正执行函数 first 中某个语句时栈的状态(图中以语句标号表示返回地址)。
一个递归函数的运行过程类似于多个函数的嵌套调用,只是调用函数和被调用函数是同一
65

Page 74
数据结构(C语言版)(第2版)
个函数,因此,和每次调用相关的一个重要概念是递归函数运行的“层次”。假设调用该递归函
数的主函数为第0层,则从主函数调用递归函数为进入第1层;从第i层递归调用本函数为进
入“下一层”,即第i+1层。反之,退出第i层递归应返回至“上一层”,即第-1层。为了保
证递归函数正确执行,系统需设立一个“递归工作栈”作为整个递归函数运行期间使用的数据
存储区。每一层递归所需信息构成一个工作记录,其中包括所有的实参、所有的局部变量,以
及上一层的返回地址。每进入一层递归,就产生一个新的工作记录压入栈顶。每退出一层递归,
就从栈顶弹出一个工作记录,则当前执行层的工作记录必是递归工作栈栈顶的工作记录,称这
个记录为“活动记录”。
2
1
i
X
У
A
...
mni
E =
m
n
void first(ints,
void second(int d):
void main(){
}
int m,n:
first(m,n);
1: ...
int t):
宗求
栈顶
1
l m n i
(a)
...
m
n
E =
(b)
int
first (ints,
int i;
...
second (i):
int
...
int _t){
版
second (int d) {
int x,y:
(c)
图3.9 主函数main 执行期间运行栈的状态测遜口
下面以图3.10所示的阶乘函数Fact(4)为例,介绍递归过程中递归工作栈和活动记录的使用。
主函数调用 Fact(4),当函数运行结束后,控制返回到 RetLoc1,在此处n赋为24(即4!):
RetLocl
void main( )
{
long n;
//调用 Fact (4)时记录进栈
n=Fact(4);
//返回地址 RetLoci 在赋值语句
味計劃
为说明方便起见,将阶乘函数算法改写为:
66
66
long Fact (long n )
{
12 long temp;
RetLoc2
if (n==0) return 1;
鏡文學
//活动记录退栈
//返回地址 RetLoc2 在计算语句
else temp=n*Fact(n-1);
;
//活动记录进栈

Page 75
二 第3章 栈和队列
return temp; 朝中友://活动记录退栈 $n荮
}
这里暂忽略局部变量 temp 的入栈和出栈情况。RetLoc2 是递归调用Fact(n-1)的返回地址,当
Fact(n-1)结束后,返回到 RetLoc2,在此处计算 n*(n-1)!,然后将结果赋给临时变量 temp。
主函数执行后依次启动了5个函数调用。图3.10所示为每次函数调用时活动记录的进栈情
况。主程序外部调用Fact(4)的活动记录在栈底,Fact(1)调用Fact(0)进栈的活动记录在栈顶。
递归结束条件出现于函数Fact(0)的内部,执行 Fact(0)引起了返回语句的执行。退出栈顶的活
动记录,返回地址返回到上一层 Fact(1)的调用递归处 RetLoc2,继续执行语句 temp=1*1,接着执
行 return temp 又引起新的退栈操作。此退栈过程直至Fact(4)执行完毕后,将控制权转移给 main
为止,其过程如图3.11 所示。
退栈的活动记录
0
RetLoc2
1
RetLoc2
调用者
参数表 返回地址
Fact (1)
0
2
RetLoc2
Fact (2)
1
((n)VO = (x)2
退栈后执行的计算
100-(wte
temp=1*1; //从 Fact (0)返回1
著
return temp; // temp=1
temp=2*1;//从Fact(1)返回1
W return
return temp; // temp=2 雙
temp=3*2;//从 Fact (2)返回 2
return temp; // temp=6
Fact (3)
2
temp=4*6; //从 Fact(3)返回6
Horst modi
3
RetLoc2钱不
return temp; // temp=24
Fact (4)
3
main()
4
4
RetLocl
图3.10 求解4!活动记录进栈过程
n= Fact (4) //从 Fact(4)返回24
图3.11 求解4!活动记录退栈过程
3.4.3 递归算法的效率分析
1. 时间复杂度的分析
在算法分析中,当一个算法中包含递归调用时,其时间复杂度的分析可以转化为一个递归
方程求解。实际上,这个问题是数学上求解渐近阶的问题,而递归方程的形式多种多样,其求
解方法也不一而足。迭代法是求解递归方程的一种常用方法,其基本步骤是迭代地展开递归方
程的右端,使之成为一个非递归的和式,然后通过对和式的估计来达到对方程左端(即方程的
解)的估计。
下面以阶乘的递归函数 Fact(n)为例,说明通过迭代法求解递归方程来计算时间复杂度的
方法。查将此回蚀中表示,派 出
空不ù:回 (2)
设 Fact(n)的执行时间是T(n)。此递归函数中语句if(n==0) return 1;的执行时间是O(1),
递归调用 Fact(n-1)的执行时间是T(n-1),所以 else return n*Fact(n-1);的执行时间是O(1)+
T(n-1)。其中,设两数相乘和赋值操作的执行时间为O(1),则对某常数 C、D 有如下递归
方程:
D
1)={0+(n-1)
1:T(n)=
C+T(n-1) n≥1日(清畨2舰
20
67

Page 76
数据结构(C语言版)(第2版)
设 n>2,利用上式对T(n-1)展开,即在上式中用n-1 代替n 得到
再代入T(n)=C+T(n-1)中,有
T(n-1)=C+T(n-2)
T(n)=2C+T(n-2)
同理,当n>3 时有
電話:T(n)=3C+T(n-3)
依次类推,当n>i时有
nim
NAH T(n) =iC+T(n-i) Benefity
最后,当i=n时有
T(n)=nC+T(0)=nC+D
1-101064
求得递归方程的解为:T(n)=O(n)
采用这种方法计算 Fibonacci 数列和Hanoi 塔问题递归算法的时间复杂度均为O(2″)。
2.空间复杂度的分析
递归函数在执行时,系统需设立一个“递归工作栈”存储每一层递归所需的信息,此工作栈是
递归函数执行的辅助空间,因此,分析递归算法的空间复杂度需要分析工作栈的大小。
对于递归算法,空间复杂度
S(n) = O(f(n))
68
其中,f(n)为“递归工作栈”中工作记录的个数与问题规模的函数关系。
根据这种分析方法不难得到,前面讨论的阶乘问题、Fibonacci数列问题、Hanoi塔问题的递归
算法的空间复杂度均为O(n)。
3.4.4 利用栈将递归转换为非递归的方法
通过上述讨论,可以看出递归程序在执行时需要系统提供隐式栈这种数据结构来实现,对于
一般的递归过程,仿照递归算法执行过程中递归工作栈的状态变化可直接写出相应的非递归算法。
这种利用栈消除递归过程的步骤如下。
(1)设置一个工作栈存放递归工作记录(包括实参、返回地址及局部变量等)。
(2)进入非递归调用入口(即被调用程序开始处)将调用程序传来的实在参数和返回地址入
栈(递归程序不可以作为主程序,因而可认为初始是被某个调用程序调用)。不过
(3)进入递归调用入口:当不满足递归结束条件时,逐层递归,将实参、返回地址及局部变
量入栈,这一过程可用循环语句来实现——模拟递归分解的过程。
(4)递归结束条件满足,将到达递归出口的给定常数作为当前的函数值。
(5)返回处理:在栈不空的情况下,反复退出栈顶记录,根据记录中的返回地址进行题意规
定的操作,即逐层计算当前函数值,直至栈空为止——模拟递归求值过程。ý的
通过以上步骤,可将任何递归算法改写成非递归算法。但改写后的非递归算法和原来比较起
来,结构不够清晰,可读性差,有的还需要经过一系列的优化,这里不再举例详述,具体示例参
见 5.5.1 节中二叉树中序遍历的非递归算法。
由于递归函数结构清晰,程序易读,而且其正确性容易得到证明,因此,利用允许递归调用
的语言(如C语言)进行程序设计时,给用户编制程序和调试程序带来很大方便。因为对这样一
类递归问题编程时,不需用户自己而由系统来管理递归工作栈。


3.5 队列的表示和操作的实现限去換
3.5.1 队列的类型定义的求婚
队列的操作与栈的操作类似,不同的是,删除是在表的头部(即队头)进行。
下面给出队列的抽象数据类型定义:
ADT Queue {
数据对象:D={aila∈ElemSet i=1,2,…,n,n≥0}
数据关系:R={<ai-ya> |ai-a∈D,i=2,…,n}
0 约定其中a端为队列头,a端为队列尾。
基本操作:
InitQueue(&Q)
操作结果:构造一个空队列 Q。
DestroyQueue (&Q)
初始条件:队列Q已存在。
操作结果:队列Q被销毁,不再存在。
ClearQueue(&Q)
初始条件:队列Q已存在。
操作结果:将Q清为空队列。
QueueEmpty (Q)
初始条件:队列Q已存在。
操作结果:若Q为空队列,则返回true,否则返回 false。
QueueLength (Q)
初始条件:队列Q已存在。
操作结果:返回Q的元素个数,即队列的长度。
GetHead (Q)
初始条件:Q为非空队列。
操作结果:返回Q的队头元素。
EnQueue (&Q,e)
初始条件:队列Q已存在。
操作结果:插入元素e为Q的新的队尾元素。
DeQueue (&Q, &e)
初始条件:Q为非空队列。
操作结果:删除Q的队头元素,并用e返回其值。
QueueTraverse (Q)
初始条件:Q已存在且非空。
操作结果:从队头到队尾,依次对Q的每个数据元素访问。多四科港氣,来
}ADT Queue
曲
和栈类似,在本书后面内容中引用的队列都是如上定义的队列类型,队列的数据元素类型在
应用程序内定义。
3.5.2 循环队列——队列的顺序表示和实现
队列也有两种存储表示,顺序表示和链式表示。
PLE PLAY
69
69

Page 78
数据结构(C语言版)(第2版)
和顺序栈相类似,在队列的顺序存储结构中,除了用一组地址连续的存储单元依次存放从队
列头到队列尾的元素之外,尚需附设两个整型变量front 和 rear 分别指示队列头元素及队列尾元素
的位置(后面分别称为头指针和尾指针)。队列的顺序存储结构表示如下:
//----- 队列的顺序存储结构-
#define MAXQSIZE 100
typedef struct
//队列可能达到的最大长度 5ML8.8
{
QElemType *base;
//存储空间的基地址
int front;
//头指针
int rear;
//尾指针
}SqQueue;
为了在C语言中描述方便起见,在此约定:初始化创建空队列时,令 front =rear=0,每当插入
新的队列尾元素时,尾指针 rear增1;每当删除队列头元素时,头指针 front 增1。因此,在非空队列
中,头指针始终指向队列头元素,而尾指针始终指向队列尾元素的下一个位置,如图3.12 所示。
5
Q.rear
Jo
- Q.front
Js
4
Q.rear.
Q.rear
3
2
J3
Q.front
J3
1
J₂
Q.rear
0
Q.front
Q.front
J₁
(a)空队列
(b)JI、J和Js相继入队 (c)J和J互相继出队 (d)Ja、Js和J。相继入队之后,J和
Ja再相继出队
图3.12 顺序分配的队列中头、尾指针和元素之间的关系
假设当前队列分配的最大空间为6,则当队列处于图3.12(d)所示的状态时不可再继续
插入新的队尾元素,否则会出现溢出现象,即因数组越界而导致程序的非法操作错误。事实
上,此时队列的实际可用空间并未占满,所以这种现象称
为“假溢出”。这是由“队尾入队,队头出队”这种受限制
的操作造成的。
怎样解决这种“假溢出”问题呢?一个较巧妙的办法是
将顺序队列变为一个环状的空间,如图3.13所示,称之为循
环队列。
Q.rear
+
队列
maxsize-1
0
午餐
Q.front
图3.13 循环队列示意图
头、尾指针以及队列元素之间的关系不变,只是在循环
队列中,头、尾指针“依环状增1”的操作可用“模”运算
来实现。通过取模,头指针和尾指针就可以在顺序表空间内以头尾衔接的方式“循环”移动。
在图 3.14(a)中,队头元素是Js,在元素 J。入队之前,在Q.rear 的值为5,当元素。入队之
后,通过“模”运算,Q.rear=(Q.rear+1)%6,得到Q.rear 的值为0,而不会出现图3.12(d)的
“假溢出”状态。
70
70

Page 79
第3章栈和队列
S
J6
J6
J6
Q.front
Q.front
Q.front
J5
J5 星
Q.rear
J10 OXAM
Q.rear
J9
J9
周末 S8 真
J8
J8
Q.rear
Q.front
J7
J7
Q.rear
(a)一般情况 (b)队列空间被占满(c)空队(d)呈“满”状态的循环队列
图3.14 循环队列中头、尾指针和元素之间的关系
在图 3.14(b)中,JT、Js、Jo、Jio相继入队,则队列空间均被占满,此时头、尾指针相同。
在图3.14(c)中,若Js和J。相继从图3.14(a)所示的队列中出队,使队列此时呈“空”的
状态,头、尾指针的值也是相同的。
由此可见,对于循环队列不能以头、尾指针的值是否相同来判别队列空间是“满”还是“空”。
在这种情况下,如何区别队满还是队空呢?
通常有以下两种处理方法。
(1)少用一个元素空间,即队列空间大小为m时,有m-1个元素就认为是队满。这样判断队
空的条件不变,即当头、尾指针的值相同时,则认为队空;而当尾指针在循环意义上加1后是等
于头指针,则认为队满。因此,在循环队列中队空和队满的条件是:
队空的条件:Q.front = Q.rear
队满的条件:(Qrear+1)%MAXQSIZE:
-
: Q.front
如图3.14(d)所示,当J7、J8、J9进入图3.14(a)所示的队列后,(Q.rear+1)%MAXQSIZE
的值等于Q.front,此时认为队满。
(2)另设一个标志位以区别队列是“空”还是“满”。具体描述参考本章习题中算法设计题的
第(7)题,由读者自行设计完成。
下面给出用第一种方法实现循环队列的操作,循环队列的类型定义同前面给出的顺序队列的
类型定义。
1. 初始化
循环队列的初始化操作就是动态分配一个预定义大小为 MAXQSIZE 的数组空间。浙案】
算法3.11 循环队列的初始化
【算法步骤】
回空者
① 为队列分配一个最大容量为MAXSIZE 的数组空间,base 指向数组空间的首地址。
② 头指针和尾指针置为零,表示队列为空。
【算法描述】
Status InitQueue (SqQueue &Q)
{ //构造一个空队列Q
Q.base=new QElemType [MAXQSIZE]
if(!Q.base) exit (OVERFLOW);
Q.front=Q.rear=0;
return OK;
//为队列分配一个最大容量为MAXSIZE 的数组空间
//存储分配失败
//头指针和尾指针置为零,队列为空
101
}
素菜鸡
71

Page 80
72
数据结构(C语言版)(第2版)
2. 求队列长度
对于非循环队列,尾指针和头指针的差值便是队列长度,而对于循环队列,差值可能为负数,
所以需要将差值加上MAXQSIZE,然后与MAXQSIZE 求余。
算法3.12 求循环队列的长度
【算法描述】
int QueueLength(SqQueue Q)
{ //返回Q的元素个数,即队列的长度
}
return(Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
3.入队
入队操作是指在队尾插入一个新的元素。
算法3.13 循环队列的入队
【算法步骤】国空原来同取,
① 判断队列是否满,若满则返回 ERROR。
②将新元素插入队尾。
③队尾指针加1。
【算法描述】
Status EnQueue (SqQueue &Q,QElemType e)
{ //插入元素e为Q的新的队尾元素
}
if((Q.rear+1)%MAXQSIZE==Q.front) 1 //尾指针在循环意义上加1后等于头指针,表明队满
return ERROR;
Q.base[Q.rear]=e;
Q.rear=(Q.rear+1)%MAXQSIZE;
return OK,章過具
: 4.出队
出队操作是将队头元素删除。
算法3.14 循环队列的出队
【算法步骤】
//新元素插入队尾
//队尾指针加1
① 判断队列是否为空,若空则返回 ERROR。
② 保存队头元素。
③队头指针加1。同时, IEXAM (量Y
【算法描述】
Status DeQueue (SqQueue &Q,QElemType &e)
{ //删除Q的队头元素,用e返回其值
if(Q.front==Q.rear) return ERROR;
//队空
e=Q.base[Q.front];
//保存队头元素
Q.front=(Q.front+1)%MAXQSIZE;
//队头指针加1
return OK;
}
5. 取队头元素
当队列非空时,此操作返回当前队头元素的值,队头指针保持不变。

Page 81
算法 3.15 取循环队列的队头元素
【算法描述】
SElemType GetHead (SqQueue Q)
{ //返回Q的队头元素,不修改队头指针
if(Q.front!=Q.rear)
return Q.base[Q.front];
}
//队列非空
//返回队头元素的值,队头指针不变
第3章 栈和队列
人
由上述分析可见,如果用户的应用程序中设有循环队列,则必须为它设定一个最大队列长度;
若用户无法预估所用队列的最大长度,则宜采用链队。
3.5.3 链队——队列的链式表示和实现
链队是指采用链式存储结构实现的队列。通常链队用单链表来表
示,如图3.15 所示。一个链队显然需要两个分别指示队头和队尾的指
针(分别称为头指针和尾指针)才能唯一确定。这里和线性表的单链
表一样,为了操作方便起见,给链队添加一个头结点,并令头指针始
终指向头结点。队列的链式存储结构表示如下:
//-----
-- 队列的链式存储结构-
typedef struct QNode
data next
Q.front
队头
{
QElemType data;
struct QNode *next%;B
}QNode *Queueptr;
typedef struct
{
QueuePtr front;
QueuePtr rear;
}LinkQueue;
//队头指针
//队尾指针
Q.rear
^
队尾
图3.15链队列示意图
链队的操作即为单链表插入和删除操作的特殊情况,只是需进一步修改尾指针或头指针。下
面给出链队初始化、入队、出队操作的实现。
1. 初始化
链队的初始化操作就是构造一个只有一个头结点的空队,如图3.16(a)所示。
算法 3.16 链队的初始化
【算法步骤】
①生成新结点作为头结点,队头和队尾指针指向此结点。
②头结点的指针域置空。
【算法描述】
Status InitQueue (LinkQueue &Q)
}
{ //构造一个空队列
,空调
Q.front=Q.rear=new QNode;
Q.front->next=NULL;
return OK;
//生成新结点作为头结点,队头和队尾指针指向此结点
//头结点的指针域置空
73
73

Page 82
数据结构(C语言版)(第2版)
2.入队
表示
和循环队列的入队操作不同的是,链队在入队前不需要判断是否满,需要为入队元素动态
分配一个结点空间,如图3.16(b)和(c)所示。
Q.front
Λ
Q.rear
(a)空队列
有时从大一个Q.front
Q.rear
Q.front
Q.rear
(b)元素x入队
Q.front
Q.rear
X
(c))
)元素y入队
X
y Λ
X
у Λ
存储池
(d)元素x出队
图3.16 队列运算指针变化状况
算法3.17 链队的入队
【算法步骤】
①为入队元素分配结点空间,用指针p指向。
②将新结点数据域置为e
③将新结点插入到队尾。
④ 修改队尾指针为p。
【算法描述】
Status EnQueue (LinkQueue &Q,QElemType e)
{ //插入元素e为Q的新的队尾元素
p=new QNode;
p->data=e;
p->next=NULL; Q.rear->next=p;
Q.rear=p;
return OK;
//为人队元素分配结点空间,用指针p指向
//将新结点数据域置为e
//将新结点插入到队尾
//修改队尾指针
}
3.出队
74
和循环队列一样,链队在出队前也需要判断队列是否为空,不同的是,链队在出队后需要释
放出队头元素的所占空间,如图3.16(d)所示。
算法 3.18 链队的出队
【算法步骤】
① 判断队列是否为空,若空则返回 ERROR。
11.0

Page 83
第3章 栈和队列
② 临时保存队头元素的空间,以备释放。容并非十
③ 修改队头指针,指向下一个结点。 2
火
④判断出队元素是否为最后一个元素,若是,则将队尾指针重新赋值,指向头结点。
⑤ 释放原队头元素的空间。
【算法描述】
Status DeQueue (LinkQueue &Q,QElemType &e)
{//删除Q的队头元素,用e返回其值
if(Q.front==Q.rear) return ERROR;
p=Q.front->next;
e=p->data;
Q.front->next=p->next;
if(Q.rear==p) Q.rear=Q.front;
//若队列空,则返回 ERROR
//p指向队头元素
//e保存队头元素的值
//修改头指针
【游指凳】
//最后一个元素被删,队尾指针指向头结点
delete pi
return OK;
}
//释放原队头元素的空间lfeul
需要注意的是,在链队出队操作时还要考虑当队列中最后一个元素被删后,队列尾指针也丢
失了,因此需对队尾指针重新赋值(指向头结点)。
4.取队头元素
与循环队列一样,当队列非空时,此操作返回当前队头元素的值,队头指针保持不变。
算法 3.19 取链队的队头元素。
【算法描述】
SElemType GetHead (LinkQueue Q)
{//返回Q的队头元素,不修改队头指针个
if(Q.front!=Q.rear) 養
My return Q.front->next->data;
}
阳单
//队列非空有一年出版第一百然,对人
//返回队头元素的值,队头指针不变 質數土祘仓
工小熊
3.6 案例分析与实现
在 3.2 节我们引入了3个有关线应用的案例和一个有关队列应用的案例。本节对这四个案例
作进一步的分析,然后分别利用栈和队列的基本操作给出案例中相关算法的具体实现。
案例 3.1:数制的转换。
【案例分析】((())
当将一个十进制整数转换为八进制数时,在计算过程中,把N与8求余得到的八进制数
的各位依次进栈,计算完毕后将栈中的八进制数依次出栈输出,输出结果就是待求得的八进制数。
【案例实现】
在具体实现时,栈可以采用顺序存储表示也可以采用链式存储表示。
算法 3.20 数制的转换
【算法步骤】
① 初始化一个空栈 S。
75
75

Page 84
76
数据结构(C语言版)(第2版)
②当十进制数N非零时,循环执行以下操作:
把N与8求余得到的八进制数压入栈 S;
霞界
N更新为N8的商
③当栈S非空时,循环执行以下操作:
● 弹出栈顶元素e;
● 输出 e。
【算法描述】
void conversion (int N)
{ //对于任意一个非负十进制数,打印输出与其等值的八进制数
InitStack (S);
while(N)
Push (SN号8);
N=N/8;
}
w while(!StackEmpty(S))
{
Pop (S,e);
cout<<e;
}
}
//初始化空栈s
//当N非零时,循环
//把N与8求余得到的八进制数压入栈 S
//N更新为N与8的商
//当栈s非空时,循环
//弹出栈顶元素e
//输出e
【算法分析】
显然,该算法的时间和空间复杂度均为O(logn)。
这是利用栈的后进先出特性的最简单的例子。在这个例子中,栈的操作是单调的,即先一味
地入栈,然后一味地出栈。也许,有的读者会提出疑问:用数组直接实现不是更简单吗?但仔细
分析上述算法不难看出,栈的引入简化了程序设计的问题,划分了不同的关注层次,使思考范围
缩小了。而用数组不仅掩盖了问题的本质,还要分散精力去考虑数组下标增减等细节问题。
在实际利用栈的问题中,入栈和出栈操作大都不是单调的,而是交错进行的。下面的案例
3.2 和 3.3 都属于这种情况。
案例 3.2:括号匹配的检验。对会展
【案例分析】
检验算法借助一个栈,每当读入一个左括号,则直接入栈,等待相匹配的同类右括号;每当
读入一个右括号,若与当前栈顶的左括号类型相同,则二者匹配,将栈顶的左括号出栈,直到表
达式扫描完毕。
在处理过程中,还要考虑括号不匹配出错的情况。例如,当出现(([]))这种情况时,由于前
面入栈的左括号均已和后面出现的右括号相匹配,栈已空,因此最后扫描的右括号不能得到匹配;
出现[([])这种错误,当表达式扫描结束时,栈中还有一个左括号没有匹配;出现(()]这种错误显然
是栈顶的左括号和最后的括号不匹配。
【
【案例实现】
算法 3.21 括号的匹配
【算法步骤】
① 初始化一个空栈 S。

Page 85
第3章 栈和队列
② 设置一标记性变量flag,用来标记匹配结果以控制循环及返回结果,1表示正确匹配,0
表示错误匹配,flag 初值为1。
③扫描表达式,依次读入字符ch,如果表达式没有扫描完毕或flag 非零,则循环执行以下操作:
若 ch 是左括号“T”或“(”,则将其压入栈;蟣弄萍工頭。 单
斜
若ch 是右括号“)”,则根据当前栈顶元素的值分情况考虑:若栈非空且栈顶元素是“(”,
则正确匹配,否则错误匹配,flag 置为0; 单
若ch 是右括号“门”,则根据当前栈顶元素的值分情况考虑:若栈非空且栈顶元素是“”,
则正确匹配,否则错误匹配, flag 置为0。
退出循环后,如果栈空且flag值为1,则匹配成功,返回true,否则返回 false。
【算法描述】
Status Matching()
{ //检验表达式中所含括号是否正确匹配,如果匹配,则返回true,否则返回 false
//表达式以“#”结束
//初始化空栈
//标记匹配结果以控制循环及返回结果
//读入第一个字符
//假设表达式以“#”结尾
InitStack (S);
flag=1;
cin>>ch;
while(ch!='#'&&flag)
{
{
}
switch(ch)
case '['|| '(':
Push (S, ch);
break;
case ')':
if (!StackEmpty (S) &&GetTop (S)=='(')
Pop (S,x);
else flag=0;
break;
case ']':
if (!StackEmpty(S) &&GetTop (S)=='[')
Pop (S,x);
else flag=0;
break;
}
cin>>ch;
//若是左括号,则将其压入栈
//若是“)”,则根据当前栈顶元素的值分情况考虑
//若栈非空且栈顶元素是“(”,则正确匹配
//若栈空或栈顶元素不是“(”,则错误失败
//若是“]”,则根据当前栈顶元素的值分情况考虑
//若栈非空且栈顶元素是“[”,则正确匹配
//若栈空或栈顶元素不是“”,则错误匹配
//switch
//继续读入下一个字符
//while
由
}
if (StackEmpty(S) &&flag) return true;
else return false;
【算法分析】
//匹配成功
電://匹配失败
此算法从头到尾扫描表达式中每个字符,若表达式的字符串长度为n,则此算法的时间复杂
度为O(n)。算法在运行时所占用的辅助空间主要取决于S栈的大小,显然,S栈的空间大小不会
超过n,所以此算法的空间复杂度也同样为O(n)。
77

Page 86
78
数据结构(C语言版)(第2版)
案例 3.3:表达式求值。
【案例分析】
任何一个表达式都是由操作数(operand)、运算符(operator)和界限符(delimiter)组成的,
统称它们为单词。一般地,操作数既可以是常数,也可以是被说明为变量或常量的标识符;运算
符可以分为算术运算符、关系运算符和逻辑运算符3类;基本界限符有左右括号和表达式结束符
等。为了叙述的简洁,在此仅讨论简单算术表达式的求值问题,这种表达式只含加、减、乘、除
4种运算符。读者不难将它推广到更一般的表达式上。
是
下面把运算符和界限符统称为算符。0728n
我们知道,算术四则运算遵循以下3条规则:
用gs7且空妹果似
(1)先乘除,后加减;
(2)从左算到右;
(3)先括号内,后括号外。药
回来调,听到果城,西南市委聂发现者问
根据上述3条运算规则,在运算的每一步中,任意两个相继出现的算符和62之间的优
先关系,至多是下面3种关系之一:
01 < 02
6的优先权低于02
0₁ = 02
0的优先权等于02
0 > 02 6的优先权高于02
表3.1定义了算符之间的这种优先关系。
表 3.1
算符间的优先关系
2
#
+
>
V
<
<
>
>
>
<
<
V
>
>
*
>
>
<
>
>
/
>
>
<
>
>
<
<
<
<
<
>
>
>
>
>
#
<
<
V
<
<
由规则(1),先进行乘除运算,后进行加减运算,所以有“+”“*”;“+”<“/”; "*"
“+”;“/”>“+”等。
由规则(2),运算遵循左结合性,当两个运算符相同时,先出现的运算符优先级高,所以有
>“+”;“” >“-”;“*”
> "*"; "/" > "/"。
由规则(3),括号内的优先级高,+、-、*和/为0时的优先性均低于“”但高于“)”。
表中的“(”=“)”表示当左右括号相遇时,括号内的运算已经完成。为了便于实现,假设
每个表达式均以“#”开始,以“#”结束。所以“#”=“#”表示整个表达式求值完毕。“)”与
“(”、“#”与“)”以及“(”与“#”之间无优先关系,这是因为表达式中不允许它们相继出现,
一旦遇到这种情况,则可以认为出现了语法错误。在下面的讨论中,我们假定所输入的表达
式不会出现语法错误。
【案例实现】
为实现算符优先算法,可以使用两个工作栈,一个称做 OPTR,用以寄存运算符;另一个称

Page 87
第3章 栈和队列
作 OPND,用以寄存操作数或运算结果。駛的
算法 3.22 表达式求值
【算法步骤】
① 初始化 OPTR 栈和OPND 栈,将表达式起始符“#”压入 OPTR栈。
②扫描表达式,读入第一个字符ch,如果表达式没有扫描完毕至“#”或OPTR的栈顶元素
不为“#”时,则循环执行以下操作:
若ch不是运算符,则压入 OPND栈,读入下一字符 ch;
● 若ch 是运算符,则根据OPTR的栈顶元素和ch的优先级比较结果,做不同的处理:
若是小于,则ch压入OPTR栈,读入下一字符ch; 6.E 澍義田间
若是大于,则弹出 OPTR 栈顶的运算符,从OPND 栈弹出两个数,进行相应运算,
结果压入 OPND 栈;
若是等于,则OPTR 的栈顶元素是“(”且ch是“)”,这时弹出 OPTR栈顶的“(”,
相当于括号匹配成功,然后读入下一字符 ch。
③ OPND 栈顶元素即为表达式求值结果,返回此元素。
【算法描述】
char EvaluateExpression ()
{//算术表达式求值的算符优先算法,设OPT和OPND分别为运算符栈和操作数栈
InitStack (OPND):40 HerT
InitStack (OPTR);
(ST)
//初始化OPND 栈
//初始化 OPTR 栈
Push (OPTR, '%23');
cin>>ch;
while(ch!='#' | |GetTop (OPTR)!='#')
{
if(!In(ch))(Push(
else
{Push (OPND,ch);cin>>ch;}
switch (Precede (GetTop (OPTR), ch))
{
case '<':
Push (OPTR, ch);cin>>ch;
break;
case '>': 公司会
Pop (OPTR, theta);
Pop (OPND,b); Pop (OPND,a);
//将表达式起始符“#”压入OPTR栈
//表达式没有扫描完毕或OPTR的栈顶元素不为“#”
//ch不是运算符则进OPND栈
//比较OPTR的栈顶元素和ch的优先级
//当前字符ch 压入OPTR栈,读入下一字符 ch
//弹出 OPTR 栈顶的运算符
//弹出 OPND 栈顶的两个运算数
Push (OPND, Operate (a,theta,b));//将运算结果压入OPND栈
break;
【神衣時架】
case = 平
出 //OPTR的栈顶元素是“(”且ch是“)”
Pop (OPTR,x);cin>>ch;
break;
//弹出OPTR栈顶的“(”,读入下一字符ch文时
两断
//switch
周菜蓉
//while 直,將發
}
return GetTop (OPND);//OPND栈顶元素即为表达式求值结果
算法调用的三个函数需要读者自行补充完成。其中函数In是判定读入的字符ch 是否为运算
符,Precede 是判定运算符栈的栈顶元素与读入的运算符之间优先关系的函数,Operate 为进行二
元运算的函数。
79

Page 88
80
数据结构(C语言版)(第2版)
另外需要特别说明的是,上述算法中的操作数只能是一位数,因为这里使用的OPND 栈是字
符栈,如果要进行多位数的运算,则需要将 OPND 栈改为数栈,读入的数字字符拼成数之后再入
栈。读者可以改进此算法,使之能完成多位数的运算。
【算法分析】
同算法3.21一样,此算法从头到尾扫描表达式中每个字符,若表达式的字符串长度为n,则
此算法的时间复杂度为O(n)。算法在运行时所占用的辅助空间主要取决于OPTR栈和 OPND 栈的
大小,显然,它们的空间大小之和不会超过n,所以此算法的空间复杂度也同样为O(n)。
【例3.2】 算法表达式的值过程。
利用算法3.22 对算术表达式3*(7-2)进行求值,给出其求值的具体过程。
在表达式两端先增加“#”,改写为
#3* (7-2) #
具体操作过程如表3.2所示。
表3.2
算术表达式 3*(7-2)的求值过程
步骤
OPTR栈
OPND 栈
读入字符
主要操作
1
#
3*(7-2)#
Push(OPND, ‘3’)
2
#
3
*(7-2)#
Push(OPTR, ‘*’)
3
#*
3
(7-2)#
Push(OPTR, ‘(’)
4
#*(
3
7-2)#
Push(OPND,‘7’)
5
#*(
37
-2)#
Push(OPTR,‘-’)
6
#*(-
37
2)#
Push(OPND, ‘2’)
7
#*(-
372
#
Push(OPND,Operate('7', '-', '2'))
8
#*(
35
#
Pop(OPTR){消去一对括号
9
#*
35
#
Push(OPND, Operate(‘3’,
'5'))
10
#
15
#
return(GetTop(OPND))
在高级语言的编译处理过程中,实际上不只是表达式求值可以借助栈来实现,高级语言中一
般语法成分的分析都可以借助栈来实现,在编译原理后续课程中会涉及栈在语法、语义等分析算
法中的应用。
案例 3.4:舞伴问题。
【案例分析】
对于舞伴配对问题,先入队的男士女士先出队配成舞伴,因此设置两个队列分别存放男士
和女士入队者。假设男士和女士的记录存放在一个数组中作为输入,然后依次扫描该数组的各元
素,并根据性别来决定是进入男队还是女队。当这两个队列构造完成之后,依次将两队当前的队
头元素出队来配成舞伴,直至某队列变空为止。此时,若某队仍有等待配对者,则输出此队列中
排在队头的等待者的姓名,此人将是下一轮舞曲开始时第一个可获得舞伴的人。
【案例实现】
算法中有关数据结构的定义如下:
//----- 跳舞者个人信息--
typedef struct

Page 89
第3章 栈和队列
char name [20];
char sex;
}Person;
//----- 队列的顺序存储结构-
#define MAXQSIZE 100
typedef struct
//姓名
//性别,'F'表示女性,'M'表示男性
//队列可能达到的最大长度
{
Person *base;
int front;
int rear;
}SqQueue;
SqQueue Mdancers, Fdancers;
算法3.23 舞伴问题
【算法步骤】
① 初始化 Mdancers 队列和 Fdancers 队列。
//队列中数据元素类型为Person
//头指针金正
//尾指针
//分别存放男士和女士入队者队列
② 反复循环,依次将跳舞者根据其性别插入 Mdancers 队列或 Fdancers 队列。
③ 当Mdancers 队列和 Fdancers 队列均为非空时,反复循环,依次输出男女舞伴的姓名。
④ 如果 Mdancers 队列为空而Fdancers 队列非空,则输出Fdancers 队列的队头女士的姓名。
⑤ 如果 Fdancers 队列为空而 Mdancers 队列非空,则输出 Mdancers 队列的队头男士的姓名。
【算法描述】
void DancePartner (Person dancer[],int num)
{ //结构数组 dancer 中存放跳舞的男女,num是跳舞的人数。
InitQueue (Mdancers);
InitQueue (Fdancers);
for(i=0;i<num;i++)
//男士队列初始化
//女士队列初始化
//依次将跳舞者根据其性别入队
p=dancer[i];
if(p.sex=='F') EnQueue (Fdancers,p);
//插入女队
else EnQueue (Mdancers, p);
//插入男队
}
cout<<"The dancing partners are:\n";
while(!QueueEmpty (Fdancers) && !QueueEmpty (Mdancers))
{//依次输出男女舞伴的姓名
}
DeQueue (Fdancers,p);
cout<<p.name<<"
";
DeQueue (Mdancers,p);
cout<<p.name<<endl;
if (!QueueEmpty (Fdancers))
p=GetHead (Fdancers)
//女士出队来
//输出出队女士姓名
//男士出队
//输出出队男士姓名
//女士队列非空,输出队头女士的姓名
//取女士队头
cout<<"The first woman to get a partner is: "<< p.name<<endl;
}
else if(!QueueEmpty (Mdancers))
//男士队列非空,输出队头男士的姓名
炸
81
81

Page 90
82
82
数据结构(C语言版)(第2版)
p=GetHead (Mdancers)
//取男士队头
}
cout<<"The first man to get a partner is: "<< p.name<<endl;
【算法分析】
若跳舞者人数总计为n,则此算法的时间复杂度为O(n)。空间复杂度取决于 Mdancers 队列和
Fdancers 队列的长度,二者长度之和不会超过n,因此空间复杂度也同样为O(n)。
队列在程序设计中也有很多应用,凡是符合先进先出原则的数学模型,都可以用队列。最
典型的例子是操作系统中用来解决主机与外设之间速度不匹配问题或多个用户引起的资源竞争
问题。
例如,一个局域网上有一台共享的网络打印机,网上每个用户都可以将数据发送给网络打印
机进行打印。为了保证能够正常打印,操作系统为网络打印机生成一个“作业队列”,每个申请打
印的“作业”应按先后的顺序排队,打印机从作业队列中逐个提取作业进行打印。
这方面的例子很多,在操作系统等后续课程中会涉及大量队列这种数据结构的应用。
在实际应用中,队列应用的例子更是常见,通常用以模拟排队情景。例如,拿汽车加油站来
说,通常的结构基本上是:入口和出口为单行道,加油车道可能有若干条。每辆车加油都要经过
三段路程,第一段是在入口处排队等候进入加油车道;第二段是在加油车道排队等候加油;第三
段是在进入出口处排队等候离开。实际上,这三段都是队列结构。若用算法模拟这个过程,总共
需要设置的队列个数应该为加油车道数加上2。
: 3.7
3.7 小 小结
本章介绍了两种特殊的线性表:栈和队列,主要内容如下。
(1)栈是限定仅在表尾进行插入或删除的线性表,又称为后进先出的线性表。栈有两种存储
表示,顺序表示(顺序栈)和链式表示(链栈)。栈的主要操作是进栈和出栈,对于顺序栈的进栈
和出栈操作要注意判断栈满或栈空。
(2)队列是一种先进先出的线性表。它只允许在表的一端进行插入,而在另一端删除元素。
队列也有两种存储表示,顺序表示(循环队列)和链式表示(链队)。队列的主要操作是进队和出
队,对于顺序的循环队列的进队和出队操作要注意判断队满或队空。凡是涉及队头或队尾指针的
修改都要将其对 MAXQSIZE 求模。
(3)栈和队列是在程序设计中被广泛使用的两种数据结构,其具体的应用场景都是与其表示
方法和运算规则相互联系的。表3.3分别从逻辑结构、存储结构和运算规则3方面对二者进行了
比较。
表 3.3
栈和队列的比较
栈和队列
栈
队列
比较项目
逻辑结构
和线性表一样,数据元素之间存在一对一的 和线性表一样,数据元素之间存在一对一的
关系
关系